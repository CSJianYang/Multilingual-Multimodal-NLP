[
    {
        "title": "Construct K Palindrome Strings",
        "question_content": "Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.\n&nbsp;\nExample 1:\n\nInput: s = \"annabelle\", k = 2\nOutput: true\nExplanation: You can construct two palindromes using all characters in s.\nSome possible constructions \"anna\" + \"elble\", \"anbna\" + \"elle\", \"anellena\" + \"b\"\n\nExample 2:\n\nInput: s = \"leetcode\", k = 3\nOutput: false\nExplanation: It is impossible to construct 3 palindromes using all the characters of s.\n\nExample 3:\n\nInput: s = \"true\", k = 4\nOutput: true\nExplanation: The only possible solution is to put each character in a separate string.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts consists of lowercase English letters.\n\t1 <= k <= 105",
        "solutions": [
            {
                "id": 563379,
                "title": "java-c-python-straight-forward",
                "content": "# **Intuition**\\nCondition 1. `odd characters <= k`\\nCount the occurrences of all characters.\\nIf one character has odd times occurrences,\\nthere must be at least one palindrome,\\nwith odd length and this character in the middle.\\nSo we count the characters that appear odd times,\\nthe number of odd character should not be bigger than `k`.\\n\\nCondition 2. `k <= s.length()`\\nAlso, if we have one character in each palindrome,\\nwe will have at most `s.length()`  palindromes,\\nso we need `k <= s.length()`.\\n\\nThe above two condition are necessary and sufficient conditions for this problem.\\nSo we return `odd <= k <= n`\\n<br>\\n\\n# **Construction**\\n@spjparmar immediately got a question like why this works always for all strings.\\nHe gave the some following dry runs. :)\\nFor any string with 0 odd character count , we can form k no. of palindrome strings for sure with k<=n\\n(This is why k<=n)\\n\\n**eg**\\naabb, k=1| abba\\naabb, k=2 | aa, bb\\naabb, k=3 | a, a, bb\\naabb, k=4 | a, a, b, b\\n\\nFor any string with odd character count <=k , we can always form k palindrome string for sure with k<=n\\n**eg2**\\naabbc, k=1 | aacbb\\naabbc, k=2 | aca, bb\\naabbc, k=3 | a,a, bcb\\naabbc, k=4 | a, a, c ,bb\\naabbc, k=5 | a, a, c, b, b\\n\\n**eg3**\\naabc, k=1 | N/A\\naabc, k=2 | aba, c\\naabc, k=3 | aa, b, c\\naabc, k=4 | a, a, b, c\\n\\nHope this helps somebody.\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0, n = s.length(), count[] = new int[26];\\n        for (int i = 0; i < n; ++i) {\\n            count[s.charAt(i) - \\'a\\'] ^= 1;\\n            odd += count[s.charAt(i) - \\'a\\'] > 0 ? 1 : -1;\\n        }\\n        return odd <= k && k <= n;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def canConstruct(self, s, k):\\n        return sum(i & 1 for i in collections.Counter(s).values()) <= k <= len(s)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0, n = s.length(), count[] = new int[26];\\n        for (int i = 0; i < n; ++i) {\\n            count[s.charAt(i) - \\'a\\'] ^= 1;\\n            odd += count[s.charAt(i) - \\'a\\'] > 0 ? 1 : -1;\\n        }\\n        return odd <= k && k <= n;\\n    }\\n```\n```cpp\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n    }\\n```\n```py\\n    def canConstruct(self, s, k):\\n        return sum(i & 1 for i in collections.Counter(s).values()) <= k <= len(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 563298,
                "title": "java-python-3-count-odd-occurrences-2-codes-w-brief-explanation-and-analysis",
                "content": "**Explanation of the method** - credit to **@lionkingeatapple**\\nIf we need to construct `k` palindromes, and each palindrome at most has`1` character with odd times of occurrence. The oddest times of occurrence we can have is `1 * k = k`. Therefore, `oddNum <= k`. And it is impossible to construct `k` palindromes when the input string s\\'s length is less than `k`. So we can conclude that in order to construct `k` palindromes it must satisfy the condition `oddNum <= k` && `k <= s.length()`.\\n\\n----\\n\\n1. Each palindrome at most has one character with odd times of occurrence;\\n2. `Non-empty` means each  palindrome at least has one character, hence `k <= s.length()`.\\n\\n**Method 1:**\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++count[s.charAt(i) - \\'a\\'];\\n        }\\n        int oddNum = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            oddNum += count[i] % 2;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\\nOr make the above 2 for loops as 1:\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        int oddNum = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            oddNum += ++count[s.charAt(i) - \\'a\\'] % 2 == 0 ? -1 : 1;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return sum(v % 2 for v in collections.Counter(s).values()) <= k <= len(s)\\n```\\n\\n----\\n\\n**Method 2:**\\nOr use bit manipulation:\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        return Integer.bitCount(odd) <= k && k <= s.length();\\n    }\\n```\\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        odd = 0\\n        for c in s:\\n            odd ^= 1 << (ord(c) - ord(\\'a\\'))\\n        return bin(odd).count(\\'1\\') <= k <= len(s)\\n```\\n\\n**Analysis:**\\nTime: O(n), space: O(1), where n = s.length().",
                "solutionTags": [],
                "code": "```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++count[s.charAt(i) - \\'a\\'];\\n        }\\n        int oddNum = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            oddNum += count[i] % 2;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        int oddNum = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            oddNum += ++count[s.charAt(i) - \\'a\\'] % 2 == 0 ? -1 : 1;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return sum(v % 2 for v in collections.Counter(s).values()) <= k <= len(s)\\n```\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        return Integer.bitCount(odd) <= k && k <= s.length();\\n    }\\n```\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        odd = 0\\n        for c in s:\\n            odd ^= 1 << (ord(c) - ord(\\'a\\'))\\n        return bin(odd).count(\\'1\\') <= k <= len(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 809033,
                "title": "clear-python-3-solution-faster-than-91-with-explanation",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        h = Counter(s)\\n        countOdd = 0\\n        for value in h.values():\\n            if value % 2:\\n                countOdd += 1\\n        if countOdd > k:\\n            return False\\n        return True\\n```\\nThe solution is based on the understanding that a string can be a palindrome only if it has **at most 1 character** whose frequency is odd. So if the number of characters having an odd frequency is greater than the number of palindromes we need to form, then naturally it\\'s impossible to do so.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        h = Counter(s)\\n        countOdd = 0\\n        for value in h.values():\\n            if value % 2:\\n                countOdd += 1\\n        if countOdd > k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337643,
                "title": "c-super-simple-solution-only-6-short-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> freq(26);\\n        for (auto ch : s) freq[ch - \\'a\\']++;\\n        \\n        int odd = 0;\\n        for (auto f : freq) odd += (f % 2);\\n        \\n        return odd <= k;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> freq(26);\\n        for (auto ch : s) freq[ch - \\'a\\']++;\\n        \\n        int odd = 0;\\n        for (auto f : freq) odd += (f % 2);\\n        \\n        return odd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564236,
                "title": "java-counting-simple-explained",
                "content": "Idea is following: count of chars can be even or odd. Those that are even - they can be used in one of substrings to form the palindrome, so we don\\'t care about those.\\nIf character has odd frequency - it can be inserted only 1 or 3 or 5... etc. to form the palindrome. However number of such characters cannot be more than number of strings, in other words - only one such char is allowed per substring. \\nThis leads to solution - count all frequencies, count those that are odd. If number of such chars > then k - it\\'s not possible to balance it to form all palindromes.\\n\\nO(n) time - iterate over every char in string to count freq.\\nO(1) space - use fixed size array to count freq.\\n\\n```\\n  public boolean canConstruct(String s, int k) {\\n    if (s == null || s.isEmpty() || s.length() < k)\\n      return false;\\n    \\n    int[] count = new int[26];\\n    //count freq of every character\\n    for (char ch : s.toCharArray()) ++count[ch - \\'a\\'];\\n    //count chars that has odd freq\\n    int countOfOdd = 0;\\n    for (int i = 0; i < 26; i++) \\n      if (count[i] % 2 == 1)\\n        ++countOfOdd;\\n    return countOfOdd <= k;\\n  }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n  public boolean canConstruct(String s, int k) {\\n    if (s == null || s.isEmpty() || s.length() < k)\\n      return false;\\n    \\n    int[] count = new int[26];\\n    //count freq of every character\\n    for (char ch : s.toCharArray()) ++count[ch - \\'a\\'];\\n    //count chars that has odd freq\\n    int countOfOdd = 0;\\n    for (int i = 0; i < 26; i++) \\n      if (count[i] % 2 == 1)\\n        ++countOfOdd;\\n    return countOfOdd <= k;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563647,
                "title": "java-o-n-time-and-o-1-space-beats-100",
                "content": "We can just simply use a 26 bit integer to store the set bits and then use XOR to flip the bits. \\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        \\n        return Integer.bitCount(odd) <= k && k <= s.length(); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        \\n        return Integer.bitCount(odd) <= k && k <= s.length(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563311,
                "title": "c-number-of-odd-frequency-character",
                "content": "If `k` is more than `n` then palindromes are never possible.\\nOtherwise, if the odd frequency character count is less than `k`, you can always make `k` palindromes.\\n\\nFor example : `s = Leetcode` and `k = 5`\\n\\nWe have odd freq characters : `{L, e, t, c, o, d}` , we can create 5 palindromes, but then atleast one of the characters from these odd frequency ones, will be left, Hence false.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n)\\n            return 0;\\n        if(k == n)\\n            return 1;\\n        vector<int> f(26);\\n        for(int i = 0; i < n; i++)\\n            f[s[i] - \\'a\\']++;\\n        \\n        int c = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            if(f[i] % 2 == 1)\\n                c++;\\n        }\\n        return c <= k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n)\\n            return 0;\\n        if(k == n)\\n            return 1;\\n        vector<int> f(26);\\n        for(int i = 0; i < n; i++)\\n            f[s[i] - \\'a\\']++;\\n        \\n        int c = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            if(f[i] % 2 == 1)\\n                c++;\\n        }\\n        return c <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911162,
                "title": "c-easy-t-c-o-n-and-s-c-o-1-beats-98-4-in-t-c-and-95-in-s-c",
                "content": "# Intuition: \\nCount for the number of charachters having odd number of occurences\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\nIf the number of odd occurences of charachters are less than k, we can partition the string in k no.of palndromes.We are counting for odd occurences because eve occurences can be arranged in any order around the \\'centre\\' of the palindrome.And we need to check additionally, if the k is less than the length of the string to be partiotined, then we don\\'t have any way do partition it.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n\\n        int a[26];  // to store the count of charachters\\n        memset(a,0,sizeof(a));\\n        int n=s.length();\\n        if(k>n)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            // if count is odd, then increment the resultant\\n            if(a[i]%2)res++;\\n        }\\n        return res<=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n\\n        int a[26];  // to store the count of charachters\\n        memset(a,0,sizeof(a));\\n        int n=s.length();\\n        if(k>n)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            // if count is odd, then increment the resultant\\n            if(a[i]%2)res++;\\n        }\\n        return res<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382658,
                "title": "easy-c-explaination-o-n-using-map",
                "content": "class Solution {\\npublic:\\n\\n//         we can have only odd number of a particular char only one time in a pallindrome\\n   ```\\n bool canConstruct(string s, int k) \\n{\\n\\t\\t if(s.size()<k)\\n\\t\\t\\t\\treturn false;\\n       unordered_map<char,int> frq;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                    frq[s[i]]++;\\n            }\\n            int cnt=0;\\n            for(auto x: frq)\\n                    \\n            {\\n                    if(x.second%2==1)\\n                            cnt++;\\n            }\\n            if(cnt>k)\\n                    return false;\\n           else\\n            return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n//         we can have only odd number of a particular char only one time in a pallindrome\\n   ```\\n bool canConstruct(string s, int k) \\n{\\n\\t\\t if(s.size()<k)\\n\\t\\t\\t\\treturn false;\\n       unordered_map<char,int> frq;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                    frq[s[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1351209,
                "title": "simple-java-solution",
                "content": "-Count all odd number of characters in string and check whether they are less or equal to k\\n```\\npublic boolean canConstruct(String s, int k) {\\n\\t\\tif(s.length()<k) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character,Integer> map=new HashMap<>();\\n\\t\\tfor(char c:s.toCharArray()) {\\n\\t\\t\\tmap.put(c,map.getOrDefault(c, 0)+1);\\n\\t\\t}\\n\\t\\tint odd=0;\\n\\t\\tfor(int count:map.values()) {\\n\\t\\t\\tif(count%2==1) {\\n\\t\\t\\t\\todd++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn odd<=k;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n\\t\\tif(s.length()<k) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character,Integer> map=new HashMap<>();\\n\\t\\tfor(char c:s.toCharArray()) {\\n\\t\\t\\tmap.put(c,map.getOrDefault(c, 0)+1);\\n\\t\\t}\\n\\t\\tint odd=0;\\n\\t\\tfor(int count:map.values()) {\\n\\t\\t\\tif(count%2==1) {\\n\\t\\t\\t\\todd++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn odd<=k;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563330,
                "title": "python-count-odd",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s) < k:\\n            return False\\n        \\n        dic = {}\\n        for x in s:\\n            if x not in dic:\\n                dic[x] = 1\\n            else:\\n                dic[x] += 1\\n        \\n        odd = 0\\n        for key,val in dic.items():        \\n            odd += val % 2\\n        even = len(dic) - odd\\n        \\n        \\n        return True if odd <= k else False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s) < k:\\n            return False\\n        \\n        dic = {}\\n        for x in s:\\n            if x not in dic:\\n                dic[x] = 1\\n            else:\\n                dic[x] += 1\\n        \\n        odd = 0\\n        for key,val in dic.items():        \\n            odd += val % 2\\n        even = len(dic) - odd\\n        \\n        \\n        return True if odd <= k else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566998,
                "title": "java-solution",
                "content": "class Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\t\\n        int n = s.length();\\n        \\n        if(n<k)\\n        {\\n            return false;\\n        }\\n        \\n        HashMap<Character,Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c = s.charAt(i);\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        \\n        int ans = 0; \\n        \\n        for(Map.Entry<Character,Integer> e:map.entrySet())\\n        {\\n            int v = e.getValue();\\n            \\n            if(v%2!=0)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans<=k;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\t\\n        int n = s.length();\\n        \\n        if(n<k)\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1674075,
                "title": "beginner-friendly-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int>mp;\\n        int counte=0,counto=0;\\n        for(auto ch:s){\\n            mp[ch]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2==0){\\n                counte++;\\n            }else{\\n                counto++;\\n            }\\n        }\\n        if(k>=counto&&s.length()>=k){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int>mp;\\n        int counte=0,counto=0;\\n        for(auto ch:s){\\n            mp[ch]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2==0){\\n                counte++;\\n            }else{\\n                counto++;\\n            }\\n        }\\n        if(k>=counto&&s.length()>=k){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419950,
                "title": "js-o-n-solution-with-comments",
                "content": "```\\nvar canConstruct = function(s, k) {\\n\\t// if string length is less than k, we cannot form k palindromes from the string, so return false\\n    if(k > s.length) {\\n        return false;\\n    }\\n\\t// created a map to keep count of each letter in the string\\n    const map = new Map();    // O(26)\\n    for(let i = 0; i < s.length; ++i) {    // O(n)\\n        map.set(s[i], map.has(s[i]) ? map.get(s[i]) + 1 : 1);\\n    }\\n\\t// check how many letters have odd count\\n    let oddCount = 0;\\n    map.forEach((value, key) => {    // O(26)\\n        if(value % 2 !== 0) {\\n            ++oddCount;\\n        }\\n    })\\n\\t// if letters with odd count are greater than k, that means more than k palindromes need to be formed to\\n\\t// make palindromes from the string where all the letters are utilised, so return false\\n\\t// palindrome can be of 2 form: `aaaaa` and `aabaa`, one letter can have odd and even occurences, but \\n\\t// there will be at least x palindromes if x letters are there with odd number of frequency\\n    if(oddCount > k) {\\n        return false;\\n    }\\n\\t// since the previous conditions do not hold, we can make k palindromes from the string, so return true\\n    return true;\\n};\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(26) ~ O(1)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConstruct = function(s, k) {\\n\\t// if string length is less than k, we cannot form k palindromes from the string, so return false\\n    if(k > s.length) {\\n        return false;\\n    }\\n\\t// created a map to keep count of each letter in the string\\n    const map = new Map();    // O(26)\\n    for(let i = 0; i < s.length; ++i) {    // O(n)\\n        map.set(s[i], map.has(s[i]) ? map.get(s[i]) + 1 : 1);\\n    }\\n\\t// check how many letters have odd count\\n    let oddCount = 0;\\n    map.forEach((value, key) => {    // O(26)\\n        if(value % 2 !== 0) {\\n            ++oddCount;\\n        }\\n    })\\n\\t// if letters with odd count are greater than k, that means more than k palindromes need to be formed to\\n\\t// make palindromes from the string where all the letters are utilised, so return false\\n\\t// palindrome can be of 2 form: `aaaaa` and `aabaa`, one letter can have odd and even occurences, but \\n\\t// there will be at least x palindromes if x letters are there with odd number of frequency\\n    if(oddCount > k) {\\n        return false;\\n    }\\n\\t// since the previous conditions do not hold, we can make k palindromes from the string, so return true\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 724516,
                "title": "c-solution-based-on-pidgeonhole-principle",
                "content": "If we have more odd frequency characters than palindromes, then at least 2 odd frequency characters must be in the same palindrome. Since this is not possible, we return true if we have fewer or equal to k odd frequency characters.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> count(26, 0);\\n        for (char c: s)\\n            count[c-\\'a\\']++;\\n        \\n        int countOdd = count_if(count.begin(), count.end(), [](int i) {\\n            return i % 2;\\n        });\\n        \\n        // Pidgeonhole, 2 odd freq chars must be in a palindrome, which is impossible        \\n        return countOdd <= k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> count(26, 0);\\n        for (char c: s)\\n            count[c-\\'a\\']++;\\n        \\n        int countOdd = count_if(count.begin(), count.end(), [](int i) {\\n            return i % 2;\\n        });\\n        \\n        // Pidgeonhole, 2 odd freq chars must be in a palindrome, which is impossible        \\n        return countOdd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692722,
                "title": "o-1-most-detailed-explanation",
                "content": "The problem is quite simple and interesting as well. Lets start from very basic:\\n\\n**Q.** Suppose we are given a string ```str```, and we are free to jumble the characters, and we need to tell that wheather ```str``` can be palindrome after jumbling.\\n* So, we will keep a track of frequency of each character appeared in ```str``` (with the help of hashmap or array of size 26)\\n*  **Now how to check**: \\uD83D\\uDC49 Even occurances of any character ```c``` is allowed. But there must be either 0 or 1 character with odd occurances\\n*  For example: \"abba\" is palindrome and there are no character with odd frequency. Similarly, \"abcba\" or \"abcccba\" is also a palindrome but there is 1 character with odd frequency.\\n\\nKeeping this in mind: \\n* We will store the frequency of each character in input string using hashmap (or array of size 26).\\n* We have no issue with even frequency character. As they will always from palindrome.\\n* We are concerned with odd freq character. Count that how many character has odd frequency. [say cnt]\\n* In order to split input string into \\'k\\' palindromic string, number of odd freq character must be less than equal to k [or cnt<=k], \\n* This is because then only we can distribute each of the odd frequency character in one of the \\'k\\' strings.\\n* Simple! We are done! We are just required to check this condition only.\\n\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k){ return false; } // obvious edge case\\n        \\n        unordered_map<char, int> m; // {char, freq}\\n        for(int i=0; i<s.size(); i++){  m[s[i]]++;  }\\n\\t\\t\\n        int cnt=0; // to count odd freq character\\n        for(auto& it: m){\\n            if(it.second%2==1){ cnt++; }\\n        }\\n        return (cnt<=k);\\n    }\\n};\\n```\\nTime Complexity: O(26) ~ O(1)  ||  Space Complexity: O(26) ~ O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```str```\n```str```\n```str```\n```c```\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k){ return false; } // obvious edge case\\n        \\n        unordered_map<char, int> m; // {char, freq}\\n        for(int i=0; i<s.size(); i++){  m[s[i]]++;  }\\n\\t\\t\\n        int cnt=0; // to count odd freq character\\n        for(auto& it: m){\\n            if(it.second%2==1){ cnt++; }\\n        }\\n        return (cnt<=k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814817,
                "title": "c-python3-solution-xor",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Python3\\n```\\nclass Solution:\\n    def canConstruct(self, S, K):\\n        return bin(reduce(operator.xor, map(lambda x: 1 << (ord(x) - 97), S))).count(\\'1\\') <= K <= len(S)\\n```\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int val = 0;\\n        for(char c: s) val ^= (1 << (c - \\'a\\'));\\n        return k <= s.length() && __builtin_popcount(val) <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, S, K):\\n        return bin(reduce(operator.xor, map(lambda x: 1 << (ord(x) - 97), S))).count(\\'1\\') <= K <= len(S)\\n```\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int val = 0;\\n        for(char c: s) val ^= (1 << (c - \\'a\\'));\\n        return k <= s.length() && __builtin_popcount(val) <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105478,
                "title": "python-beats-97-with-reasoning",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\'\\'\\'\\n        For a palindrome, its odd-count character has to be less than or eqaul to one. \\n        Then in order to get k many palindromic substrings, the number of odd-count chracters in s has to be less than\\n        or equal to k \\'\\'\\'\\n        \\n        if len(s) < k:\\n            return False\\n        freq = Counter(s)\\n        return sum(1 for val in freq.values() if val % 2 != 0) <= k\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\'\\'\\'\\n        For a palindrome, its odd-count character has to be less than or eqaul to one. \\n        Then in order to get k many palindromic substrings, the number of odd-count chracters in s has to be less than\\n        or equal to k \\'\\'\\'\\n        \\n        if len(s) < k:\\n            return False\\n        freq = Counter(s)\\n        return sum(1 for val in freq.values() if val % 2 != 0) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070676,
                "title": "math-javascript",
                "content": "Code is self explantory.\\nBasically we will follow the below steps:\\n1. Calculate frequency of all the characters\\n2. Those characters whose frequency is odd, see if they are greater than 2. if > 2 then increment `evens` counts along\\n    with incrementing `odds`.\\n3. We **assume** \\tthat we will make palindromic string of size **1** only out of `odds` . \\n4. `k - odds` palindromic strings are required to be made out of `s.length - odds` characters. Which is possible as \\n    `k - odds < s.length - odds` which is resulted in (`odds` getting cancelled from both the side), `k < s.length` (which we are checking earlier in first line) \\n5. We can make `k - odds` strings out of `evens` which consitutes `s.length - odds` characters. \\n\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        /*\\n        * s = \\'cr\\', k = 7\\n        * Can not make 7 palindromic strings out of string length of 2\\n        *\\n        * In short, atleast k characters are required in the string.\\n        */\\n        return false;\\n    }\\n    \\n    if (s.length === k) {\\n        /*\\n        * s = \"true\", k = 4\\n        * Four palindromic strings of length 1 can be made out of s.\\n        */\\n        return true;\\n    }\\n    \\n    const hash = {};\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        hash[s[i]] || (hash[s[i]] = 0);\\n        hash[s[i]]++;\\n    }\\n    \\n    let odds = 0;\\n    let evens = 0;\\n    let key;\\n    \\n    const keys = Object.keys(hash);\\n    for(let i = 0; i < keys.length; i++) {\\n        key = keys[i];\\n        \\n        if (hash[key] % 2 === 0) {\\n            evens++;\\n        } else {\\n            if (Math.floor(hash[key] / 2) > 0) {\\n                /*\\n                * s = \"annabellebb\", b is 3 times, which is 2 + 1 => meaning, \\n                * there is only 1 b left hanging without getting paired. Which needs \\n                * chars around it to form palidromic sequence\\n                */\\n                evens++;\\n            }\\n            odds++;\\n        }\\n    }\\n    \\n    if (odds > k) {\\n        /*\\n        * s = \"leetcode\", k = 3\\n        * There are 5 chars with frequence 1. They can\\'t be clubbed together to form palindromic strings\\n        *\\n        * Return false if k > number of odds in `s`\\n        */\\n        return false;\\n    }\\n    \\n    /*\\n    * In any other cases where odds < k, we can fit all other evens as per requirement\\n    * For e.g. s = \"annabellebb\", k = 3.  \\n    * \\n    * evens => a, b, e, l, n.  odds => b\\n    * odds < k => 1 < 3. \\n    * We can make (k - odds) palindromic sequnce with given `evens`. \\n    * a = 2, b = 2, e = 2, l = 2, n = 2 => Total 10 characters except 1 loose `b`.\\n    * They can make (k - odds) => 5 - 1 => 4 palindromic strings easily. \\n    *\\n    * So, basically s.length - odds => 11 - 1 => 10 can be easily made by all evens together. s.length < k is already taken care of in start\\n    */\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        /*\\n        * s = \\'cr\\', k = 7\\n        * Can not make 7 palindromic strings out of string length of 2\\n        *\\n        * In short, atleast k characters are required in the string.\\n        */\\n        return false;\\n    }\\n    \\n    if (s.length === k) {\\n        /*\\n        * s = \"true\", k = 4\\n        * Four palindromic strings of length 1 can be made out of s.\\n        */\\n        return true;\\n    }\\n    \\n    const hash = {};\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        hash[s[i]] || (hash[s[i]] = 0);\\n        hash[s[i]]++;\\n    }\\n    \\n    let odds = 0;\\n    let evens = 0;\\n    let key;\\n    \\n    const keys = Object.keys(hash);\\n    for(let i = 0; i < keys.length; i++) {\\n        key = keys[i];\\n        \\n        if (hash[key] % 2 === 0) {\\n            evens++;\\n        } else {\\n            if (Math.floor(hash[key] / 2) > 0) {\\n                /*\\n                * s = \"annabellebb\", b is 3 times, which is 2 + 1 => meaning, \\n                * there is only 1 b left hanging without getting paired. Which needs \\n                * chars around it to form palidromic sequence\\n                */\\n                evens++;\\n            }\\n            odds++;\\n        }\\n    }\\n    \\n    if (odds > k) {\\n        /*\\n        * s = \"leetcode\", k = 3\\n        * There are 5 chars with frequence 1. They can\\'t be clubbed together to form palindromic strings\\n        *\\n        * Return false if k > number of odds in `s`\\n        */\\n        return false;\\n    }\\n    \\n    /*\\n    * In any other cases where odds < k, we can fit all other evens as per requirement\\n    * For e.g. s = \"annabellebb\", k = 3.  \\n    * \\n    * evens => a, b, e, l, n.  odds => b\\n    * odds < k => 1 < 3. \\n    * We can make (k - odds) palindromic sequnce with given `evens`. \\n    * a = 2, b = 2, e = 2, l = 2, n = 2 => Total 10 characters except 1 loose `b`.\\n    * They can make (k - odds) => 5 - 1 => 4 palindromic strings easily. \\n    *\\n    * So, basically s.length - odds => 11 - 1 => 10 can be easily made by all evens together. s.length < k is already taken care of in start\\n    */\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1797109,
                "title": "simple-c-java-python-solutions",
                "content": "### C++ Solution\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        vector<int> mapp(26, 0);\\n        for(char c : s) mapp[c-\\'a\\']++;\\n        \\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n};\\n```\\n\\n### Java Solution\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        int mapp[] = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            mapp[c-\\'a\\']++;\\n        }\\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n}\\n```\\n\\n### Python Solution\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        mapp = [0]*26\\n        for c in s:\\n            mapp[ord(c) - ord(\\'a\\')]+=1\\n        \\n        summ = 0\\n        for i in range(26):\\n            summ += mapp[i]%2\\n        \\n        return summ<=k\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        vector<int> mapp(26, 0);\\n        for(char c : s) mapp[c-\\'a\\']++;\\n        \\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        int mapp[] = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            mapp[c-\\'a\\']++;\\n        }\\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        mapp = [0]*26\\n        for c in s:\\n            mapp[ord(c) - ord(\\'a\\')]+=1\\n        \\n        summ = 0\\n        for i in range(26):\\n            summ += mapp[i]%2\\n        \\n        return summ<=k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737785,
                "title": "c-simple-with-intution",
                "content": "# you just need to check if the character that are present odd number of times are greater than k or not \\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        vector<int>A(26,0);\\n        int odd = 0;\\n        int even = 0;\\n        if(n < k)\\n            return false;\\n        for(char c : s)\\n            A[c - \\'a\\']++;\\n        for(int a : A)\\n        {\\n            if(a == 0)\\n                continue;\\n            if(a % 2 == 1)\\n                odd++;\\n            else\\n                even++;\\n        }\\n        if(odd > k)\\n            return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        vector<int>A(26,0);\\n        int odd = 0;\\n        int even = 0;\\n        if(n < k)\\n            return false;\\n        for(char c : s)\\n            A[c - \\'a\\']++;\\n        for(int a : A)\\n        {\\n            if(a == 0)\\n                continue;\\n            if(a % 2 == 1)\\n                odd++;\\n            else\\n                even++;\\n        }\\n        if(odd > k)\\n            return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617060,
                "title": "java-simple-code-with-detailed-explanation",
                "content": "## Explanation\\n\\nThe idea is quite simple, the core concept is separating the characters in 2 categories:\\n* The ones that have an even amount of occurrences \\n* The ones that have an odd amount of ocurrences.\\n\\n### Even characters\\nThe characters that appear an even number of times are not a problem at all. Why? Because we can add them at the beginning and end of the palindrome without breaking the palindrome condition.\\n\\nLet\\'s see an example where **A** appears an odd number of times:\\n\\n- **A**???**A**\\n- **AA**???**AA**\\n- **AAA**???**AAA**\\n\\nWe don\\'t care what\\'s inside of the sandwich where **A** is the bread.\\n\\n## Odd characters\\nThis is the limiting factor while forming palindromes. Odd characters **MUST** be in the middle of the palindrome , if not it wouldn\\'t be a palindrome.\\n\\n- ???**A**???\\n- ???**AAA**???\\n- ???**AAAAA**???\\n\\nAlso this kind of arrangement are valid but it changes nothing for us:\\n- **A**???**A**???**A**\\n\\nThe problem is that there can be **only middle section** (where we can use our odd characters) per palindrome. So everything gets reduced to counting the amount of odd characters and checking if we have less odd characters than the amount of palindromes __k__.\\n\\n\\n## Code\\nCode is very basic once you understand the idea.\\n\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.isEmpty() || s.length() < k) return false;\\n        int[] count = new int[26];\\n        int odd = 0;\\n\\n        // Count ocurrences\\n        for(char c : s.toCharArray()){\\n            count[c - \\'a\\']++;\\n        }\\n        \\n        // Count characters with odd number of occurrences\\n        for (int i = 0; i < 26 ; i++) {\\n            if (count[i] % 2 != 0) odd++;\\n        }\\n        \\n        return odd <= k;\\n    }\\n}\\n```\\n\\nHope you liked the post, and now some shameless self-promotion: My blog where I also post explanations to LeetCode challenges https://pablomusumeci.com/categories/#leetcode",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.isEmpty() || s.length() < k) return false;\\n        int[] count = new int[26];\\n        int odd = 0;\\n\\n        // Count ocurrences\\n        for(char c : s.toCharArray()){\\n            count[c - \\'a\\']++;\\n        }\\n        \\n        // Count characters with odd number of occurrences\\n        for (int i = 0; i < 26 ; i++) {\\n            if (count[i] % 2 != 0) odd++;\\n        }\\n        \\n        return odd <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442930,
                "title": "python-for-beginners",
                "content": "\\tclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        from collections import Counter\\n        if len(s)<k:\\n            return False\\n        v2=[v for v,b in Counter(s).items() if b%2==1]\\n        if len(v2)>k:\\n            return False    \\n        return True",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        from collections import Counter\\n        if len(s)<k:\\n            return False\\n        v2=[v for v,b in Counter(s).items() if b%2==1]\\n        if len(v2)>k:\\n            return False    \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1079757,
                "title": "javascript-solution-with-comments",
                "content": "```\\n    // return false if length of string is less than k\\n    if(s.length<k) {\\n        return false;\\n    }\\n    // compute frequency of each char in string\\n    let map = new Map();\\n    for(let letter of s) {\\n        map.set(letter,(map.get(letter)||0)+1);\\n    }\\n\\t// return true is size of map is equal to k\\n    if(map.size === k) {\\n        return true;\\n    }\\n\\t// return true or false based on if the odd char count is less than K, or greater than or equal to K.\\n    let count = 0;\\n    for(let key of map.keys()) {\\n        count += map.get(key)%2\\n    }\\n    return count<=k;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    // return false if length of string is less than k\\n    if(s.length<k) {\\n        return false;\\n    }\\n    // compute frequency of each char in string\\n    let map = new Map();\\n    for(let letter of s) {\\n        map.set(letter,(map.get(letter)||0)+1);\\n    }\\n\\t// return true is size of map is equal to k\\n    if(map.size === k) {\\n        return true;\\n    }\\n\\t// return true or false based on if the odd char count is less than K, or greater than or equal to K.\\n    let count = 0;\\n    for(let key of map.keys()) {\\n        count += map.get(key)%2\\n    }\\n    return count<=k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1029137,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar canConstruct = function(s, k) {\\n    if(k === s.length) return true;\\n    if(k > s.length) return false;\\n    \\n    const freq = Array(26).fill(0);\\n    \\n    for(let c of s) {\\n        const idx = c.charCodeAt() - \\'a\\'.charCodeAt();\\n        freq[idx]++;\\n    }\\n    const odds = freq.filter(x => x%2).length;\\n    return odds <= k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar canConstruct = function(s, k) {\\n    if(k === s.length) return true;\\n    if(k > s.length) return false;\\n    \\n    const freq = Array(26).fill(0);\\n    \\n    for(let c of s) {\\n        const idx = c.charCodeAt() - \\'a\\'.charCodeAt();\\n        freq[idx]++;\\n    }\\n    const odds = freq.filter(x => x%2).length;\\n    return odds <= k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016580,
                "title": "python-counting-solution",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counter = collections.Counter(s)\\n        odd = sum([1 for val in counter.values() if val % 2])\\n        return odd <= k and len(s) >= k",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counter = collections.Counter(s)\\n        odd = sum([1 for val in counter.values() if val % 2])\\n        return odd <= k and len(s) >= k",
                "codeTag": "Java"
            },
            {
                "id": 679084,
                "title": "java-count-num-of-odds",
                "content": "False if either:\\n1, s.length() < k;\\nor \\n2, number of odd count chars > k;  (at most k char can be in the center)\\n```\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.length() < k) return false;\\n        int odds = 0, cnt[] = new int[26];\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) odds += cnt[i] % 2;\\n        return odds <= k;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.length() < k) return false;\\n        int odds = 0, cnt[] = new int[26];\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) odds += cnt[i] % 2;\\n        return odds <= k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 647852,
                "title": "faster-and-simpler",
                "content": "\\t\\tk>len(s):\\n            return False\\n        \\n        \\n        dc=collections.Counter(s)\\n        \\n        cnt=0\\n        for key,v in dc.items():\\n            if  v&1:\\n                cnt+=1\\n        if cnt > k:\\n            return False\\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t\\tk>len(s):\\n            return False\\n        \\n        \\n        dc=collections.Counter(s)\\n        \\n        cnt=0\\n        for key,v in dc.items():\\n            if  v&1:\\n                cnt+=1\\n        if cnt > k:\\n            return False\\n        return True",
                "codeTag": "Unknown"
            },
            {
                "id": 598638,
                "title": "super-easy-python-solution-with-explanation",
                "content": "\\n```\\n# The approach of the problem is that -\\n# 1) even length palindromes will have even no. of characters\\n# 2) odd length palindromes will have odd no. of characters\\n# 3) we can have only one letter in odd length palindrome which has odd occurence. \\n\\n# For eg:\\n#     s=\"aabbcccdd\" Here, a->2     k=4\\n#                         b->2  \\n#                         c->3\\n#                         d->2\\n                \\n#     now, \"aa\", \"bb\", \"cc\", \"dcd\", So, each odd occurence character can be adjusted in only one string to make it an odd plaindrome string. So, if we have no. of odd occurence characters greater than k, then we cannot have k palindrome strings.           \\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)==k:\\n            return True\\n        if len(set(s))==k:\\n            return True\\n        \\n        if len(s)<k:\\n            return False\\n        \\n        count=0\\n        d=collections.Counter(s)\\n        print(d)\\n        l=list(d.keys())\\n        for i in range(len(l)):\\n            if d[l[i]]%2==1:\\n                count+=1\\n        return count<=k        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The approach of the problem is that -\\n# 1) even length palindromes will have even no. of characters\\n# 2) odd length palindromes will have odd no. of characters\\n# 3) we can have only one letter in odd length palindrome which has odd occurence. \\n\\n# For eg:\\n#     s=\"aabbcccdd\" Here, a->2     k=4\\n#                         b->2  \\n#                         c->3\\n#                         d->2\\n                \\n#     now, \"aa\", \"bb\", \"cc\", \"dcd\", So, each odd occurence character can be adjusted in only one string to make it an odd plaindrome string. So, if we have no. of odd occurence characters greater than k, then we cannot have k palindrome strings.           \\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)==k:\\n            return True\\n        if len(set(s))==k:\\n            return True\\n        \\n        if len(s)<k:\\n            return False\\n        \\n        count=0\\n        d=collections.Counter(s)\\n        print(d)\\n        l=list(d.keys())\\n        for i in range(len(l)):\\n            if d[l[i]]%2==1:\\n                count+=1\\n        return count<=k        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 570939,
                "title": "c-solution-using-the-concept-that-atmost-k-odd-frequency-character-are-possisble",
                "content": "If u think in a broad way then what we can say is in  a given palindromic string atmost only one character can have  odd frequency and that element would be the position about which that string would be palindrome \\nso for K palindromic strings atmost K elements can have odd freq\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }        \\n        return true;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 565262,
                "title": "c-3-lines",
                "content": "# the key is \"the number of odd char\" should be less than k\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> count(26,0);\\n        for(char c : s) count[c-\\'a\\']++;\\n        return (s.length() < k)?false:(k >= count_if(count.begin(),count.end(),[](int i) {return i%2==1;}));        \\n    }\\n};\\n```\\n\\nanother version:\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26);\\n        for(char c : s) cnt[c-\\'a\\'] ^= 1;\\n        return (s.length() < k)?false:(k >= count(cnt.begin(),cnt.end(),1));        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> count(26,0);\\n        for(char c : s) count[c-\\'a\\']++;\\n        return (s.length() < k)?false:(k >= count_if(count.begin(),count.end(),[](int i) {return i%2==1;}));        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26);\\n        for(char c : s) cnt[c-\\'a\\'] ^= 1;\\n        return (s.length() < k)?false:(k >= count(cnt.begin(),cnt.end(),1));        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563375,
                "title": "python-1line",
                "content": "```\\nreturn len(s) >= k and sum(i % 2 for i in Counter(s).values()) <= k\\n```",
                "solutionTags": [],
                "code": "```\\nreturn len(s) >= k and sum(i % 2 for i in Counter(s).values()) <= k\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487709,
                "title": "simplest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        unordered_map<char,int> m ; \\n        if(s.size()<k)\\n        return false; \\n        for(auto x:s)\\n        m[x]++; \\n\\n        int count = 0; \\n        for(auto x:m)\\n        if(x.second%2==1)\\n        count++; \\n\\n        return count<=k;\\n\\n\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        unordered_map<char,int> m ; \\n        if(s.size()<k)\\n        return false; \\n        for(auto x:s)\\n        m[x]++; \\n\\n        int count = 0; \\n        for(auto x:m)\\n        if(x.second%2==1)\\n        count++; \\n\\n        return count<=k;\\n\\n\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235832,
                "title": "simple-solution-using-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k) return true;\\n    if(s.size()<k) return false;\\n    unordered_map<char,int>mp;\\n    for(auto x:s) mp[x]++;\\n    int odd_count=0;\\n    for(auto x:mp){\\n        if(x.second%2!=0){\\n            odd_count++;\\n        }\\n    }\\n    return odd_count<=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k) return true;\\n    if(s.size()<k) return false;\\n    unordered_map<char,int>mp;\\n    for(auto x:s) mp[x]++;\\n    int odd_count=0;\\n    for(auto x:mp){\\n        if(x.second%2!=0){\\n            odd_count++;\\n        }\\n    }\\n    return odd_count<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845875,
                "title": "this-is-how-it-works",
                "content": "lets talk about the case when k<s.size() // coz it is confusing lol\\n\\nit means we have to do k partitions\\n\\nsuppose no of odd occuring characters be : o\\nassuming o<=k\\n\\n----- ----- ----- ----- ----- ----  -----\\nsuppose these are k partitions, of different lengths ( might be of same length too)\\ni am represeting them by ----  ----  ----- -----  , where a character is present at \\' - \\' \\n\\nnow there are 2 subcases , either all of the k partitions contain one odd character\\n\\nhere q->denotes any character with odd freq \\n---q1---  ---q2---  --q3--  --q4--  --q5-- \\n\\n---q1--- is one partition , while ---q2--- is another and so on\\n\\nsuppose character a and b have odd frequeny, so q1 can be a or b\\nand q2 can be b or a respectively\\n\\nso after eliminating \"odd frequency of odd occuring characters\"\\nWE KNOW know every character has even freq.\\n\\nnow we can fill remaining spaces with elements .\\n\\n---q1--- | ---q2--- | ---q3---| ---q4---\\n\\nthese are the partitions and we are left with characters having even freqency,\\nand the remaining length to be filled in all the partitions is s.size()-[q1+q2...(odd frequency)]\\nif any position of any partition is filled with any character,\\nwe know that characters have even freq , so corresponding palindromic [reverse right to left]\\nposition can be filled with same character.\\nand we have used 2 characters of same type, so we still have all the characters with even freq.\\n\\nthis is how we can fill all partitions.\\n\\nnow same ideology can be extended when o<k\\n\\n\\nsuppose we put one odd character in each partition\\nso new partitions formed = o\\n partitions we need to create =k-o\\nremaining characters left=s.size()-o\\n\\nnow the ques is can we form k-o palindromic paritions given that\\nwe are left with all even freqency characters\\n\\nnow there are further 2 subcases\\nwhen k-o is even\\nwe are left with s.size()-o characters where (size()-o>k-o)\\nwe know all the size()-o character has its sibling ( it occurs even number of time)\\n\\nwe need to create k-o ( even no. of partitions)\\nso what we can do, choose one character and its sibling, and you can create two new partitions\\nnow in last steps, you will be left with characters , having even freq.\\nand you can put it anywhere. [ in any partition]\\n\\n\\n\\nwhat if k-o is odd?\\n\\nwe know k-o-1 is even so first fill at the remaining k-o-1 places .\\nnow we want to create one new partition right?\\nplace all the remaining characters in that partition.\\n\\n\\nIT CAN BE SHOWED THAT WE CAN ALWAYS CONSTRUCT K-PALINDROMS!\\n;) THIS IS INDEPTH PROOF OF THE SOLUTION :D\\n\\ni\\'ve not considered the trivial cases when s.size()<k || s.size()==k ;) they are self explanatory!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "lets talk about the case when k<s.size() // coz it is confusing lol\\n\\nit means we have to do k partitions\\n\\nsuppose no of odd occuring characters be : o\\nassuming o<=k\\n\\n----- ----- ----- ----- ----- ----  -----\\nsuppose these are k partitions, of different lengths ( might be of same length too)\\ni am represeting them by ----  ----  ----- -----  , where a character is present at \\' - \\' \\n\\nnow there are 2 subcases , either all of the k partitions contain one odd character\\n\\nhere q->denotes any character with odd freq \\n---q1---  ---q2---  --q3--  --q4--  --q5-- \\n\\n---q1--- is one partition , while ---q2--- is another and so on\\n\\nsuppose character a and b have odd frequeny, so q1 can be a or b\\nand q2 can be b or a respectively\\n\\nso after eliminating \"odd frequency of odd occuring characters\"\\nWE KNOW know every character has even freq.\\n\\nnow we can fill remaining spaces with elements .\\n\\n---q1--- | ---q2--- | ---q3---| ---q4---\\n\\nthese are the partitions and we are left with characters having even freqency,\\nand the remaining length to be filled in all the partitions is s.size()-[q1+q2...(odd frequency)]\\nif any position of any partition is filled with any character,\\nwe know that characters have even freq , so corresponding palindromic [reverse right to left]\\nposition can be filled with same character.\\nand we have used 2 characters of same type, so we still have all the characters with even freq.\\n\\nthis is how we can fill all partitions.\\n\\nnow same ideology can be extended when o<k\\n\\n\\nsuppose we put one odd character in each partition\\nso new partitions formed = o\\n partitions we need to create =k-o\\nremaining characters left=s.size()-o\\n\\nnow the ques is can we form k-o palindromic paritions given that\\nwe are left with all even freqency characters\\n\\nnow there are further 2 subcases\\nwhen k-o is even\\nwe are left with s.size()-o characters where (size()-o>k-o)\\nwe know all the size()-o character has its sibling ( it occurs even number of time)\\n\\nwe need to create k-o ( even no. of partitions)\\nso what we can do, choose one character and its sibling, and you can create two new partitions\\nnow in last steps, you will be left with characters , having even freq.\\nand you can put it anywhere. [ in any partition]\\n\\n\\n\\nwhat if k-o is odd?\\n\\nwe know k-o-1 is even so first fill at the remaining k-o-1 places .\\nnow we want to create one new partition right?\\nplace all the remaining characters in that partition.\\n\\n\\nIT CAN BE SHOWED THAT WE CAN ALWAYS CONSTRUCT K-PALINDROMS!\\n;) THIS IS INDEPTH PROOF OF THE SOLUTION :D\\n\\ni\\'ve not considered the trivial cases when s.size()<k || s.size()==k ;) they are self explanatory!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2780659,
                "title": "cpp-solution-using-hashmap-and-counting",
                "content": "# Intuition\\nCount the Number of occurence of characters in the string then find the number of odd number of ocurrence of characters.\\n\\n# Approach\\n-> If String is \\'S\\' and if the size of the string is equal to k(integer) then our answer is \"true\" because we can break them into different characters\\n\\n-> If String\\'s size is less than the k then it is not possible to break then into k palindrome strings\\n\\n-> Now, Use a Hashmap to store the number of occurence of the characters of the string\\n\\n-> If the number of characters that have odd counts is > k then the minimum number of palindrome strings we can construct is > k and answer is false, Otherwise you can construct exactly k palindrome strings and answer is true \\n\\n> Why?...... Because if we take all even count character along with one single odd count character in a single string they can form a palindromic string\\n\\n>For Example- S= \"annnabellee\" and k=3 then, possible construction will be \"anlebelna\" ,\"b\" ,\"e\" (you can arrange them for more permutations), If k=2 then answer would be false.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)\\n        return true;\\n        if(s.size()<k)\\n        return false;\\n        \\n        map<char,int> mp;\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int cnt=0;\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second%2!=0)\\n              cnt++;\\n        }\\n        if(cnt>k)\\n         return false;\\n\\n\\n   return true; }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)\\n        return true;\\n        if(s.size()<k)\\n        return false;\\n        \\n        map<char,int> mp;\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int cnt=0;\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second%2!=0)\\n              cnt++;\\n        }\\n        if(cnt>k)\\n         return false;\\n\\n\\n   return true; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608282,
                "title": "c-80-faster-than-all-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n       \\n        int n = s.size(), map[26];\\n        memset(map, 0, sizeof(map));\\n        for (char c : s) map[c - \\'a\\']++;\\n        \\n        int count = 0;\\n        for (int i = 0; i < 26; i++) if (map[i] % 2) count++;\\n        \\n        k -= count;\\n        \\n        int pairs = (n - count) / 2;\\n        while (k > pairs) {\\n            pairs--;\\n            k -= 2;\\n        }\\n        return k >= 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n       \\n        int n = s.size(), map[26];\\n        memset(map, 0, sizeof(map));\\n        for (char c : s) map[c - \\'a\\']++;\\n        \\n        int count = 0;\\n        for (int i = 0; i < 26; i++) if (map[i] % 2) count++;\\n        \\n        k -= count;\\n        \\n        int pairs = (n - count) / 2;\\n        while (k > pairs) {\\n            pairs--;\\n            k -= 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2557672,
                "title": "count-odd-occurances",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        if(k>n)\\n            return false;\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        int cnt=0;\\n        for(auto i: mp)\\n        {\\n            if(i.second%2)\\n                cnt++;\\n        }\\n        \\n        if(cnt>k)\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        if(k>n)\\n            return false;\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        int cnt=0;\\n        for(auto i: mp)\\n        {\\n            if(i.second%2)\\n                cnt++;\\n        }\\n        \\n        if(cnt>k)\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527806,
                "title": "java-explained-logic-of-odd-chars-in-detail-tc-sc",
                "content": "// Understanding Palindorme: A palindromic string is a string, which when read from left to right or right to left spells same\\n\\n// So some observations from above definition\\n// 1. Even Length String\\n// 1.1 An even length string NEEDS to have ALL the characters in PAIR (meaning the freq of each char is even)\\n// 1.2 If a string of even length has ANY character with ODD freq, it CANNOT be a palindrome\\n// 2. Odd Length String\\n// 2.1 An odd length string can ATMOST have 1 character with ODD freq\\n// 2.2 If an odd length string has MORE THAN 1 charcter with ODD freq, it cannot be a Palindorme\\n\\n// Conclusion from above : ANY string can have ATMOST 1 charcter with ODD freq to make it eligible to be a PALINDROME\\n\\n// k = num of palindromes we need to form\\n// So, if the num of CHARS with ODD freq are GREATER THAN \\'k\\', then we CANNOT make \\'k\\' palindromes\\n// WHY ? Because of the established facts above that a string can have ATMOST 1 CHAR with ODD freq to become palindorme and so if we have MORE chars with ODD freq than \\'k\\', then this means in some string MORE THAN 1 char with ODD freq needs to adjust and hence we cannot make \\'k\\' palindromes\\n\\n// TC : O(M + 26); M = s.length()\\n// SC : O(26)\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {     \\n        if(k > s.length()) return false;\\n        \\n        int numOddFreqChars = 0;\\n        int len = s.length();\\n        int[] charFreq = new int[26];\\n        \\n        for(int i = 0; i < len; i++) {\\n            charFreq[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(charFreq[i] % 2 == 1) {\\n                numOddFreqChars++;\\n            }\\n        }\\n        \\n        return numOddFreqChars <= k;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {     \\n        if(k > s.length()) return false;\\n        \\n        int numOddFreqChars = 0;\\n        int len = s.length();\\n        int[] charFreq = new int[26];\\n        \\n        for(int i = 0; i < len; i++) {\\n            charFreq[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(charFreq[i] % 2 == 1) {\\n                numOddFreqChars++;\\n            }\\n        }\\n        \\n        return numOddFreqChars <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463838,
                "title": "c-space-98-beats-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string &s, int &k) {\\n        if(s.length()<k)return false;\\n        if(s.length()==k)return true;\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto &i: v){\\n            if(i%2)k--;\\n        }\\n        return k<0?false:true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string &s, int &k) {\\n        if(s.length()<k)return false;\\n        if(s.length()==k)return true;\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto &i: v){\\n            if(i%2)k--;\\n        }\\n        return k<0?false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453837,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-dictionary",
                "content": "```C#\\npublic class Solution {\\n    public bool CanConstruct(string s, int k) {\\n        if (s.Length < k) return false;\\n        \\n        Dictionary<char, int> d = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            if (!d.ContainsKey(s[i])) d[s[i]] = 0;\\n            d[s[i]]++;\\n        }\\n        \\n        int singles = 0;\\n        foreach (var (_, count) in d) {\\n            singles += count % 2;\\n        }\\n        \\n        if (singles > k) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public bool CanConstruct(string s, int k) {\\n        if (s.Length < k) return false;\\n        \\n        Dictionary<char, int> d = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            if (!d.ContainsKey(s[i])) d[s[i]] = 0;\\n            d[s[i]]++;\\n        }\\n        \\n        int singles = 0;\\n        foreach (var (_, count) in d) {\\n            singles += count % 2;\\n        }\\n        \\n        if (singles > k) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131445,
                "title": "very-easy-java-solution-no-bitwise-no-complex-logic",
                "content": "```\\npublic boolean canConstruct(String s, int k) {\\n        int[] hashTable = new int[26];\\n        if(s.length() < k)  return false;\\n        \\n        for(char ch : s.toCharArray())\\n            hashTable[ch-\\'a\\']++;\\n        \\n        int distinctCharCount=0;\\n        for(int i=0;i<26;i++){\\n            if(hashTable[i] !=0 && hashTable[i] % 2 != 0){\\n                distinctCharCount++;\\n                if(distinctCharCount > k)   return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n        int[] hashTable = new int[26];\\n        if(s.length() < k)  return false;\\n        \\n        for(char ch : s.toCharArray())\\n            hashTable[ch-\\'a\\']++;\\n        \\n        int distinctCharCount=0;\\n        for(int i=0;i<26;i++){\\n            if(hashTable[i] !=0 && hashTable[i] % 2 != 0){\\n                distinctCharCount++;\\n                if(distinctCharCount > k)   return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024069,
                "title": "java-easy-to-understand-hashset",
                "content": "class Solution {\\n   \\n    public boolean canConstruct(String s, int k) {\\n         if(k>s.length()) return false;\\n        Set<Character> set = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            if(set.contains(c))set.remove(c);\\n            else set.add(c);\\n        }\\n        return set.size()<=k;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n   \\n    public boolean canConstruct(String s, int k) {\\n         if(k>s.length()) return false;\\n        Set<Character> set = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            if(set.contains(c))set.remove(c);\\n            else set.add(c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2004975,
                "title": "fully-commented-java-code",
                "content": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        \\n        int n = s.length();\\n        \\n        //Only two cases are possible for contruction of k palindrome to be false\\n        // 1) We dont have enough characters\\n        // 2) We are exceeding the max limit\\n        \\n        //We can only contruct atmost n palindrome for a n length string\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        // Now that we are sure we can contruct a string\\n        // We can be sure we are not exceeding the limit while forming palindrome\\n        // If k is 1 and the string is eeaabb we can still form a string and\\n        // make sure it doesn\\'t exceed limit\\n        // but problem comes with odd number where we have to make sure\\n        // it is not more than the count\\n        \\n        int numOdd = 0;\\n        \\n        int[] count = new int[26];\\n        \\n        for(char c: s.toCharArray()){\\n            count[c-\\'a\\']++;\\n        }\\n        \\n        \\n        \\n        for(int i=0; i<26; i++){\\n            if(count[i] % 2 != 0){\\n                numOdd++;\\n            }\\n        }\\n        \\n        return (numOdd <= k) ? true : false;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        \\n        int n = s.length();\\n        \\n        //Only two cases are possible for contruction of k palindrome to be false\\n        // 1) We dont have enough characters\\n        // 2) We are exceeding the max limit\\n        \\n        //We can only contruct atmost n palindrome for a n length string\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        // Now that we are sure we can contruct a string\\n        // We can be sure we are not exceeding the limit while forming palindrome\\n        // If k is 1 and the string is eeaabb we can still form a string and\\n        // make sure it doesn\\'t exceed limit\\n        // but problem comes with odd number where we have to make sure\\n        // it is not more than the count\\n        \\n        int numOdd = 0;\\n        \\n        int[] count = new int[26];\\n        \\n        for(char c: s.toCharArray()){\\n            count[c-\\'a\\']++;\\n        }\\n        \\n        \\n        \\n        for(int i=0; i<26; i++){\\n            if(count[i] % 2 != 0){\\n                numOdd++;\\n            }\\n        }\\n        \\n        return (numOdd <= k) ? true : false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974120,
                "title": "java-easy-to-understand-90-beat",
                "content": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k > s.length()) {\\n            return false;\\n        }\\n        if(k == s.length()) {\\n            return true;\\n        }\\n        int[] freqCount = new int[26];\\n        for(char letter: s.toCharArray()) {\\n            freqCount[letter - \\'a\\']++;\\n        }\\n        int count = 0;\\n        for(int x: freqCount) {\\n            if(x % 2 == 1) {\\n                count++;\\n            }\\n        }\\n        return count <= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k > s.length()) {\\n            return false;\\n        }\\n        if(k == s.length()) {\\n            return true;\\n        }\\n        int[] freqCount = new int[26];\\n        for(char letter: s.toCharArray()) {\\n            freqCount[letter - \\'a\\']++;\\n        }\\n        int count = 0;\\n        for(int x: freqCount) {\\n            if(x % 2 == 1) {\\n                count++;\\n            }\\n        }\\n        return count <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958062,
                "title": "java-solution-using-hashmap-clean-code-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k > s.length()) return false; \\n        HashMap<Character, Integer> hash = new HashMap<>(); \\n        for (int i = 0; i < s.length(); i++){\\n            hash.put(s.charAt(i), hash.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        List<Integer> list = new ArrayList<Integer>(hash.values()); \\n        int tbt = 0; \\n        for (int i = 0; i < list.size(); i++){\\n            tbt += (list.get(i) % 2); \\n        }\\n        if (tbt <= k) return true; \\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k > s.length()) return false; \\n        HashMap<Character, Integer> hash = new HashMap<>(); \\n        for (int i = 0; i < s.length(); i++){\\n            hash.put(s.charAt(i), hash.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        List<Integer> list = new ArrayList<Integer>(hash.values()); \\n        int tbt = 0; \\n        for (int i = 0; i < list.size(); i++){\\n            tbt += (list.get(i) % 2); \\n        }\\n        if (tbt <= k) return true; \\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885494,
                "title": "c-leetcode-1400-count-number-of-odd-frequency-letters",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size()<k)return false;\\n        if((int)s.size()==k)return true;\\n        int odds = 0;\\n        map<char,int> m;\\n        for(char c : s)\\n            m[c]++;\\n        for(auto x : m){\\n            if(x.second%2)\\n                odds++;\\n        }\\n        if(odds<=k)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size()<k)return false;\\n        if((int)s.size()==k)return true;\\n        int odds = 0;\\n        map<char,int> m;\\n        for(char c : s)\\n            m[c]++;\\n        for(auto x : m){\\n            if(x.second%2)\\n                odds++;\\n        }\\n        if(odds<=k)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806250,
                "title": "python-solution",
                "content": "To construct a palindrome string, every character must have an even number of total count in the string. Only the character in the middle can have a total count of 1. eg: \\'abbcbba\\'. So, to construct k palindrome sub-strings from a single string (s), there should only be k or less than k number of characters having an odd total count in the string (s).\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        dic = {}\\n        \\n        for i in s:\\n            if i not in dic:\\n                dic[i] = 1\\n            else:\\n                dic[i] += 1\\n        c = 0        \\n        for i in dic.values():\\n            if i % 2 == 1:\\n                c += 1\\n        \\n        if c > k:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        dic = {}\\n        \\n        for i in s:\\n            if i not in dic:\\n                dic[i] = 1\\n            else:\\n                dic[i] += 1\\n        c = 0        \\n        for i in dic.values():\\n            if i % 2 == 1:\\n                c += 1\\n        \\n        if c > k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672032,
                "title": "c-easy-to-understand-simple-solution-with-explaination",
                "content": "**The trick is to understand that the characters which occur for the odd number of times will form a separate palindromic string each time consisting either a sinle character or being present at the mid of a string. So, if the count of odd characters happens to be more than k , we return a false and likewise follows**\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> freq;\\n        for(char ch:s)\\n        {\\n            freq[ch]++;\\n        }\\n        int oddCount=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second%2)\\n            {\\n                oddCount++;\\n            }\\n        }\\n        return oddCount<=k&&k<=s.length();\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> freq;\\n        for(char ch:s)\\n        {\\n            freq[ch]++;\\n        }\\n        int oddCount=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second%2)\\n            {\\n                oddCount++;\\n            }\\n        }\\n        return oddCount<=k&&k<=s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667062,
                "title": "easy-c-hashmap-solution",
                "content": "Here in the below code, oddCount is: No.of characters whose frequency is odd.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int n = s.size();\\n        if(k > n)return false;\\n        \\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)m[s[i]]++;\\n        \\n        int oddCount = 0;\\n        for(auto i:m)\\n        {\\n            if((i.second)%2 != 0)oddCount++;\\n        }\\n        \\n        if(oddCount <= k)return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int n = s.size();\\n        if(k > n)return false;\\n        \\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)m[s[i]]++;\\n        \\n        int oddCount = 0;\\n        for(auto i:m)\\n        {\\n            if((i.second)%2 != 0)oddCount++;\\n        }\\n        \\n        if(oddCount <= k)return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656887,
                "title": "simple-python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        ocr = Counter(s)\\n        od = 0\\n        ev = 0\\n        \\n        for i in ocr:\\n            if ocr[i] % 2 == 0:\\n                ev += 1\\n            else:\\n                od += 1\\n                \\n        if od == k:\\n            return True\\n        \\n        if k < od:\\n            return False\\n        \\n        if k > len(s):\\n            return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        ocr = Counter(s)\\n        od = 0\\n        ev = 0\\n        \\n        for i in ocr:\\n            if ocr[i] % 2 == 0:\\n                ev += 1\\n            else:\\n                od += 1\\n                \\n        if od == k:\\n            return True\\n        \\n        if k < od:\\n            return False\\n        \\n        if k > len(s):\\n            return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607563,
                "title": "lessons-learned",
                "content": "**Tricky problem**:\\n* One would only think in terms of **backtracking / dp** approach unless he knows the **greediness** involved in the definition of pallindrome:\\n\\t1.  **A word can be a pallindrome if it has atmost 1 odd count of chars**\\n\\t2.  A word is a pallindrome if \\'#1 is satisfied\\' and \\'chars are arranged in the pallindromic manner (read charAt(i++) == charAt(--j) until i and j meet)\\'.\\n#2 is well known. Whereas greediness is in #1. I never realized this hidden definition of pallindrome.\\n* So for 2 words to be both pallindromes, we can have atmost 1 oddCount from word1 and atmost1 oddCount from word2, totalling to atmost 2 oddCount from words 1 and 2. \\n**Generallizing, for k words to be pallindromes, validate the criteria of atmost k oddCount.**\\n\\n**Code**:\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int n = s.length();\\n        if (n == k) return true;\\n        if (k > n) return false;\\n        \\n        int[] charCountMap = new int[26];\\n        for (char c : s.toCharArray()) {\\n            ++charCountMap[c - \\'a\\'];\\n        }\\n        \\n        int oddCount = 0;\\n        for (int val : charCountMap) {\\n            if (val % 2 == 1) {\\n                ++oddCount;\\n                if (oddCount > k) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n/*\\n\\nif (s.length == k) return true;\\na, 1\\nab, 2\\n\\nabacdc, 2\\nabcdac, 2    - a:2, b:1, c:2, d:1\\nabbacddc, 2  - a:2, b:2, c:2, d:2\\n\\nabcabcabc, 3 - a:3, b:3, c:3\\nannabelle, 2 - a:2, n:2, b:1, e:2, l:2 \\n\\n\\nleetcode, 3 - l:1, t:1, c:1, o:1, d:1, e:3\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int n = s.length();\\n        if (n == k) return true;\\n        if (k > n) return false;\\n        \\n        int[] charCountMap = new int[26];\\n        for (char c : s.toCharArray()) {\\n            ++charCountMap[c - \\'a\\'];\\n        }\\n        \\n        int oddCount = 0;\\n        for (int val : charCountMap) {\\n            if (val % 2 == 1) {\\n                ++oddCount;\\n                if (oddCount > k) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n/*\\n\\nif (s.length == k) return true;\\na, 1\\nab, 2\\n\\nabacdc, 2\\nabcdac, 2    - a:2, b:1, c:2, d:1\\nabbacddc, 2  - a:2, b:2, c:2, d:2\\n\\nabcabcabc, 3 - a:3, b:3, c:3\\nannabelle, 2 - a:2, n:2, b:1, e:2, l:2 \\n\\n\\nleetcode, 3 - l:1, t:1, c:1, o:1, d:1, e:3\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530496,
                "title": "swift-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        var dict = [Character : Int]()\\n        for c in s {\\n            if dict[c] != nil {\\n                dict[c]! += 1\\n            } else {\\n                dict[c] = 1\\n            }\\n        }\\n        var numOdd = 0\\n        for val in dict.values {\\n            if val % 2 != 0 {\\n                numOdd += 1\\n            }\\n        }\\n        return k <= s.count && numOdd <= k\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        var dict = [Character : Int]()\\n        for c in s {\\n            if dict[c] != nil {\\n                dict[c]! += 1\\n            } else {\\n                dict[c] = 1\\n            }\\n        }\\n        var numOdd = 0\\n        for val in dict.values {\\n            if val % 2 != 0 {\\n                numOdd += 1\\n            }\\n        }\\n        return k <= s.count && numOdd <= k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410197,
                "title": "short-java-solution",
                "content": "Just check number of characters with odd count. You need to create at least as many palindromic strings, since you can put at most 1 non-repeating character in a a palindromic string.\\n``` \\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < s.length(); i++)\\n            map[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for (int i = 0; i < 26;i++)\\n            if (map[i]%2 == 1)\\n                odd++;\\n        \\n        return s.length() >= k && odd <= k;\\n    }\\n```\\n\\nOne pass solution\\n```\\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n         int odd = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            map[s.charAt(i)-\\'a\\']++;\\n            if (map[s.charAt(i)-\\'a\\']%2 == 1)\\n                odd++;\\n            else\\n                odd--;\\n        }\\n        return s.length() >= k && odd <= k;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < s.length(); i++)\\n            map[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for (int i = 0; i < 26;i++)\\n            if (map[i]%2 == 1)\\n                odd++;\\n        \\n        return s.length() >= k && odd <= k;\\n    }\\n```\n```\\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n         int odd = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            map[s.charAt(i)-\\'a\\']++;\\n            if (map[s.charAt(i)-\\'a\\']%2 == 1)\\n                odd++;\\n            else\\n                odd--;\\n        }\\n        return s.length() >= k && odd <= k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1379866,
                "title": "97-53-time-efficient-simple-java-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        if(s.length()==k) return true;\\n        int[] f = new int[26];\\n        for(char ch : s.toCharArray())\\n            f[ch-\\'a\\']++;\\n        int oddCount=0, evenCount=0;\\n        for(int i=0; i<26; i++){\\n            if(f[i]%2!=0)\\n                oddCount++;\\n            else\\n                evenCount++;\\n        }\\n        return (evenCount != 0) && (oddCount<=k);\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        if(s.length()==k) return true;\\n        int[] f = new int[26];\\n        for(char ch : s.toCharArray())\\n            f[ch-\\'a\\']++;\\n        int oddCount=0, evenCount=0;\\n        for(int i=0; i<26; i++){\\n            if(f[i]%2!=0)\\n                oddCount++;\\n            else\\n                evenCount++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1347512,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return 0;\\n        map<int,int> freq;\\n        for(char i:s) freq[i]++;\\n        \\n        int singles=0,pairs=0;\\n        \\n        for(auto i:freq){\\n            if(i.second&1) {\\n                singles++;\\n                pairs=pairs+i.second/2;\\n            }\\n            else{\\n                pairs=pairs+i.second/2;\\n            }\\n        }\\n        \\n        if(singles>k) return 0;\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return 0;\\n        map<int,int> freq;\\n        for(char i:s) freq[i]++;\\n        \\n        int singles=0,pairs=0;\\n        \\n        for(auto i:freq){\\n            if(i.second&1) {\\n                singles++;\\n                pairs=pairs+i.second/2;\\n            }\\n            else{\\n                pairs=pairs+i.second/2;\\n            }\\n        }\\n        \\n        if(singles>k) return 0;\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277729,
                "title": "java-5-lines-of-code",
                "content": "Get char with odd count and if it greter then k return false else return true\\n\\n```\\npublic boolean canConstruct(String s, int k) {\\n      if(s.length() < k) return false;\\n      int[] arr = new int[26];\\n      for(int i = 0 ; i < s.length(); i++) arr[s.charAt(i) - \\'a\\']++;\\n      for(int i = 0 ; i < arr.length; i++) if(arr[i] % 2 != 0 && --k < 0) return false;\\n      return true; \\n    } \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n      if(s.length() < k) return false;\\n      int[] arr = new int[26];\\n      for(int i = 0 ; i < s.length(); i++) arr[s.charAt(i) - \\'a\\']++;\\n      for(int i = 0 ; i < arr.length; i++) if(arr[i] % 2 != 0 && --k < 0) return false;\\n      return true; \\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1272281,
                "title": "java",
                "content": "class Solution {\\n\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length())\\n            return false;\\n        if(k==s.length())\\n            return true;\\n        Map<Character,Integer> map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        for(Map.Entry<Character,Integer> entry:map.entrySet()){\\n            if(entry.getValue() %2 !=0)\\n                count++;\\n        }\\n        if(count >k)\\n            return false;\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length())\\n            return false;\\n        if(k==s.length())\\n            return true;\\n        Map<Character,Integer> map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        for(Map.Entry<Character,Integer> entry:map.entrySet()){\\n            if(entry.getValue() %2 !=0)\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1259128,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int i,j,c,n;\\n        n=s.length();\\n        if(k>n)\\n            return false;\\n        int a[26]={0};\\n        for(i=0;i<n;++i)\\n        {\\n            j=s[i]-\\'a\\';\\n            ++a[j];\\n        }\\n        for(i=0;i<26;++i)\\n        {\\n            if(a[i]%2==1)\\n            {\\n                --k;\\n            }\\n        }\\n        return (k>=0);\\n    }\\n};\\n```\\n\\nA palidrome can have a maximum of one odd character.\\nSo we check the number of odd frequency alphabets\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int i,j,c,n;\\n        n=s.length();\\n        if(k>n)\\n            return false;\\n        int a[26]={0};\\n        for(i=0;i<n;++i)\\n        {\\n            j=s[i]-\\'a\\';\\n            ++a[j];\\n        }\\n        for(i=0;i<26;++i)\\n        {\\n            if(a[i]%2==1)\\n            {\\n                --k;\\n            }\\n        }\\n        return (k>=0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248762,
                "title": "c-solution-100-faster-o-n-simple-with-explanation",
                "content": "Whether we can construct \"k\" palindrome strings or not depends on how many \"pairs\" of letters the orignal string have.\\nThe least of \"pairs\" is required, when there\\'re most of \"odd\" length of palindrome strings.\\n\\nExtremely, the first \"k-1\" palindrome strings have only \"one\" (odd) letter each, in total used \"k-1\" letters.\\nThe last palindrome string has \"n - (k - 1)\" letters, need at least \"(n - (k - 1)) / 2\" pairs of letters.\\n\\n```\\nbool canConstruct (char *s, int k) {\\n  int  n, pairs = 0;\\n  char map[128] = {0};\\n\\n  for (n = 0; s[n]; n++) {\\n    if (map[s[n]]) {\\n      pairs++;\\n      map[s[n]] = 0;\\n    } else {\\n      map[s[n]] = 1;\\n    }\\n  }\\n\\n  return (k >= n) && (pairs >= (n - k + 1) / 2);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConstruct (char *s, int k) {\\n  int  n, pairs = 0;\\n  char map[128] = {0};\\n\\n  for (n = 0; s[n]; n++) {\\n    if (map[s[n]]) {\\n      pairs++;\\n      map[s[n]] = 0;\\n    } else {\\n      map[s[n]] = 1;\\n    }\\n  }\\n\\n  return (k >= n) && (pairs >= (n - k + 1) / 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240733,
                "title": "c-simple-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        if(s.length() == k) return true;\\n        vector<int> alphabets(26,0);\\n        for(int i=0; i < s.length(); i++) alphabets[(int)s[i] - (int)\\'a\\']++;\\n        int oddCount = 0;\\n        for(int i=0; i<26; i++) if(alphabets[i]%2) oddCount++;\\n        if(oddCount > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        if(s.length() == k) return true;\\n        vector<int> alphabets(26,0);\\n        for(int i=0; i < s.length(); i++) alphabets[(int)s[i] - (int)\\'a\\']++;\\n        int oddCount = 0;\\n        for(int i=0; i<26; i++) if(alphabets[i]%2) oddCount++;\\n        if(oddCount > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206607,
                "title": "construct-k-palindrome-strings-explaination-with-diagram-comment-if-you-need-any-help",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length()<k)\\n            return false;\\n        int even{},odd{};\\n        map<char,int> m;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k)\\n            return true;\\n        for(auto x: m)\\n        {\\n            if(x.second%2==0)\\n                even++;\\n            else\\n                odd++;\\n        }\\n        if(odd>k)\\n            return false;\\n        return true;\\n       \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/850d9814-b390-458d-8277-2131dae16a10_1620923888.732838.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length()<k)\\n            return false;\\n        int even{},odd{};\\n        map<char,int> m;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k)\\n            return true;\\n        for(auto x: m)\\n        {\\n            if(x.second%2==0)\\n                even++;\\n            else\\n                odd++;\\n        }\\n        if(odd>k)\\n            return false;\\n        return true;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117334,
                "title": "python-1-liner",
                "content": "```py\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum([x%2 for x in Counter(s).values()]) <= k\\n```",
                "solutionTags": [],
                "code": "```py\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum([x%2 for x in Counter(s).values()]) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111910,
                "title": "c-super-duper-simple-elegant-short-concise-easy-to-understand",
                "content": "C++ SUPER DUPER SIMPLE ELEGANT SHORT CONCISE EASY to UNDERSTAND \\n\\n```\\nclass Solution {\\n    \\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> countMap;\\n        \\n        for(auto c : s)\\n            countMap[c]++;\\n        \\n        if(s.length() < k)\\n            return false;\\n        \\n        for(auto pr : countMap){\\n            k -= pr.second % 2==1 ? 1 : 0;\\n            if(k<0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> countMap;\\n        \\n        for(auto c : s)\\n            countMap[c]++;\\n        \\n        if(s.length() < k)\\n            return false;\\n        \\n        for(auto pr : countMap){\\n            k -= pr.second % 2==1 ? 1 : 0;\\n            if(k<0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079932,
                "title": "python3-freq-table",
                "content": "**Algo**\\nCompute the frequency table of `s` and check if the count of odd occurrence `<= k`. Ofc, we need `k <= len(s)` as a prerequisite. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        freq = {}\\n        for c in s: \\n\\t\\t    freq[c] = 1 + freq.get(c, 0)\\n        return sum(freq[c]&1 for c in freq) <= k <= len(s)\\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        freq = {}\\n        for c in s: \\n\\t\\t    freq[c] = 1 + freq.get(c, 0)\\n        return sum(freq[c]&1 for c in freq) <= k <= len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078374,
                "title": "js-count-odd-occurrences-o-n-time-o-1-space-w-comments",
                "content": "The palindrome can be formed in a few ways:\\n1. One character at the middle and the same sequences but mirrored by both sides (abcda). There is only one odd character occurrence. Other cahracter occurrences are even.\\n2. Two same characters at the middle and the same but mirrored sequences by both sides (abccba). All characters occurrences are even.\\n\\nThat means that in worst case it\\'s still possible to form k palindromes if the number of odd character occurrences  are <= k.\\nThe idea is to count the number of occurrances for each character and compare it with k.\\nTime complexity is O(n).\\nSpace complexity is O(1).\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        // it\\'s not possible construct k non-empty palindromes if the number of characters in string is less than k\\n        return false;\\n    }\\n    // code of the first character in english alphabet\\n    const aCode = \\'a\\'.charCodeAt(0);\\n    // reserve and array for each possible character (26 in english alphabet)\\n    const counts = (new Array(26)).fill(0);\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        // substract the code of the first letter in the alpahbet from the code of current letter to make it fit in range of 0 - 25\\n        const code = s.charCodeAt(i) - aCode;\\n        // increment the character occurance\\n        counts[code]++;\\n    }\\n    let oddsCount = 0;\\n    for (let count of counts) {\\n        if (count % 2 === 1) {\\n            // count the number of odd characters\\n            oddsCount++;\\n        }\\n    }\\n    return oddsCount <= k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        // it\\'s not possible construct k non-empty palindromes if the number of characters in string is less than k\\n        return false;\\n    }\\n    // code of the first character in english alphabet\\n    const aCode = \\'a\\'.charCodeAt(0);\\n    // reserve and array for each possible character (26 in english alphabet)\\n    const counts = (new Array(26)).fill(0);\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        // substract the code of the first letter in the alpahbet from the code of current letter to make it fit in range of 0 - 25\\n        const code = s.charCodeAt(i) - aCode;\\n        // increment the character occurance\\n        counts[code]++;\\n    }\\n    let oddsCount = 0;\\n    for (let count of counts) {\\n        if (count % 2 === 1) {\\n            // count the number of odd characters\\n            oddsCount++;\\n        }\\n    }\\n    return oddsCount <= k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1031277,
                "title": "c-check-odd-count-of-characters",
                "content": "A palindrome can be built in two ways:\\n1. Count of all characters is even, i.e. \"aabccbaa\" a->4, b->2, c->2\\n2. Only 1 character have odd count, i.e. \"aabcfcbaa\" a->4, b->2, c->2, f->1\\n\\nWe can check if at max we have k odd counts in the string if yes then we have the answer.\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.size()) return false;\\n        unordered_map<char, int> mp;\\n        for(auto ch:s) {\\n            mp[ch]++;\\n        }\\n        int count = 0;\\n        for(auto m:mp) {\\n            if(m.second % 2 == 1) count++;\\n            if(count > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.size()) return false;\\n        unordered_map<char, int> mp;\\n        for(auto ch:s) {\\n            mp[ch]++;\\n        }\\n        int count = 0;\\n        for(auto m:mp) {\\n            if(m.second % 2 == 1) count++;\\n            if(count > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968226,
                "title": "c-solution-beats-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string& s, int k) {\\n        ios_base::sync_with_stdio(0); cin.tie(0);\\n        if(s.size() < k)\\n            return false;\\n        \\n        int mask = 0;\\n        for(char c : s)\\n            mask ^= (1 << (c-\\'a\\'));\\n        \\n        return (__builtin_popcount(mask) <= k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string& s, int k) {\\n        ios_base::sync_with_stdio(0); cin.tie(0);\\n        if(s.size() < k)\\n            return false;\\n        \\n        int mask = 0;\\n        for(char c : s)\\n            mask ^= (1 << (c-\\'a\\'));\\n        \\n        return (__builtin_popcount(mask) <= k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956557,
                "title": "super-concise-and-clear-python-code-with-explanation",
                "content": "If there are not enough characters in s to make k palindromes, result = False. Edge case\\nFor all other cases:\\nFind the count of the each  letter in s. We now focus on letters that are odd in count. The letters with even count can form a new palidrome or wrap around an exisiting palindrome placing 2 at a time. \\nSo, the number of letters with odd count is what defines how many palindromes can be made.\\nAs long as the number of letters with odd count are less than or equal to k we can form k palindromes.\\n\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        count = collections.Counter(s)\\n        oddCount = sum(x%2 for x in count.values())\\n        return oddCount <= k\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        count = collections.Counter(s)\\n        oddCount = sum(x%2 for x in count.values())\\n        return oddCount <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931230,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char ch : s.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for (Character ch: map.keySet()) {\\n            if (map.get(ch) % 2 != 0) {\\n                k--;\\n            }\\n        }\\n        \\n        return k >= 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char ch : s.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for (Character ch: map.keySet()) {\\n            if (map.get(ch) % 2 != 0) {\\n                k--;\\n            }\\n        }\\n        \\n        return k >= 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926801,
                "title": "c-solution-o-n-simple",
                "content": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int ar[26]={0};\\n        for(char c:s)\\n            ar[c-\\'a\\']++;\\n        int k1=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            k1+=ar[i]%2;\\n        }\\n        return (k>=k1 &&k<=s.size());\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int ar[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 913705,
                "title": "python-easy-to-understand",
                "content": "The logic being, to construct k palindrome strings, the number of letters with odd (or 1) counts need to be less than or equal to k (cause one palindrome string can only have 1 odd count letter in it) and length of s has to be greater than or equal to k.\\n\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        count=collections.Counter(list(s))\\n        c=0\\n        for v in count.values():\\n            if v%2!=0:\\n                c+=1\\n        if c<=k and len(s)>=k:\\n            return True\\n        else:\\n            return False",
                "solutionTags": [],
                "code": "The logic being, to construct k palindrome strings, the number of letters with odd (or 1) counts need to be less than or equal to k (cause one palindrome string can only have 1 odd count letter in it) and length of s has to be greater than or equal to k.\\n\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        count=collections.Counter(list(s))\\n        c=0\\n        for v in count.values():\\n            if v%2!=0:\\n                c+=1\\n        if c<=k and len(s)>=k:\\n            return True\\n        else:\\n            return False",
                "codeTag": "Python3"
            },
            {
                "id": 898912,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    //annabelle a=2 n=2 b=1 e=2 l=2 k=2 odd_char=1 true\\n    \\n    bool canConstruct(string s, int k) {\\n        if (k>s.size()) return false;\\n        unordered_map<char, int> char_map;\\n        for (auto x:s) {\\n            char_map[x]++;\\n        }\\n        int odd_char=0;\\n        for (auto y=char_map.begin(); y!=char_map.end(); y++) {\\n            if (y->second%2==1) {\\n                odd_char++;\\n                if (odd_char>k)\\n                    return false;\\n            }\\n        }\\n        return true;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //annabelle a=2 n=2 b=1 e=2 l=2 k=2 odd_char=1 true\\n    \\n    bool canConstruct(string s, int k) {\\n        if (k>s.size()) return false;\\n        unordered_map<char, int> char_map;\\n        for (auto x:s) {\\n            char_map[x]++;\\n        }\\n        int odd_char=0;\\n        for (auto y=char_map.begin(); y!=char_map.end(); y++) {\\n            if (y->second%2==1) {\\n                odd_char++;\\n                if (odd_char>k)\\n                    return false;\\n            }\\n        }\\n        return true;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878018,
                "title": "easy-o-n-java",
                "content": "```\\npublic boolean canConstruct(String s, int k) {\\n        if (k == s.length()) return true;\\n        if (s.length() < k) return false;\\n        int[] count = new int[26];\\n        for (char c : s.toCharArray()) count[c-\\'a\\']++;\\n        \\n        int countExceptions = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] % 2 == 1) { countExceptions++; }\\n            if (countExceptions > k) return false;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n        if (k == s.length()) return true;\\n        if (s.length() < k) return false;\\n        int[] count = new int[26];\\n        for (char c : s.toCharArray()) count[c-\\'a\\']++;\\n        \\n        int countExceptions = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] % 2 == 1) { countExceptions++; }\\n            if (countExceptions > k) return false;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 865794,
                "title": "consise-o-1-faster-than-100-c",
                "content": "You need to create seperate strings for odd count of characters only, also note that you can at most have 26 odd characters, so if 26<k<=s.size() doesn\\'t matter what characters you have in s you can always use all characters and create required palindromes.\\n```\\nclass Solution {\\n    int cnt[26];\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.size())return 0;\\n        if(k>26)return 1;\\n        for(auto it:s)cnt[it-\\'a\\']++;\\n        int ans=0;\\n        for(auto it:cnt)if(it&1)ans++;\\n        return ans<=k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int cnt[26];\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.size())return 0;\\n        if(k>26)return 1;\\n        for(auto it:s)cnt[it-\\'a\\']++;\\n        int ans=0;\\n        for(auto it:cnt)if(it&1)ans++;\\n        return ans<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814496,
                "title": "very-very-simple-c-code-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }\\n        vector<int>count(26,0);\\n        for(int i=0;i<s.length();i++){\\n            count[s[i]-\\'a\\']++;\\n        }\\n        int odd=0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2==1){\\n                odd++;\\n            }\\n        }\\n        if(odd>k){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }\\n        vector<int>count(26,0);\\n        for(int i=0;i<s.length();i++){\\n            count[s[i]-\\'a\\']++;\\n        }\\n        int odd=0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2==1){\\n                odd++;\\n            }\\n        }\\n        if(odd>k){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784545,
                "title": "minimal-c-using-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size())\\n            return false;\\n        \\n        uint mask = 0;\\n        for (auto c : s)\\n            mask ^= 1 << (c - \\'a\\');\\n        \\n        return (__builtin_popcount(mask) <= k);  // C++20 has std::popcount()\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size())\\n            return false;\\n        \\n        uint mask = 0;\\n        for (auto c : s)\\n            mask ^= 1 << (c - \\'a\\');\\n        \\n        return (__builtin_popcount(mask) <= k);  // C++20 has std::popcount()\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752927,
                "title": "python-simple-soln",
                "content": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        \"\"\"\\n        For string to be pallindrome, it can either have 0 or 1 number of odd count characters.\\n        For string to have k pallindomes, it can have 0 - k number of odd count characters. \\n        \"\"\"\\n        if k > len(s):\\n            return False\\n        \\n        hashmap = collections.defaultdict(int)\\n        \\n        for ch in s:\\n            hashmap[ch] += 1\\n        \\n        odd_character_count = 0\\n        for key in hashmap:\\n            odd_character_count += 1 if hashmap[key] % 2 == 1 else 0\\n            \\n        if odd_character_count > k:\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        \"\"\"\\n        For string to be pallindrome, it can either have 0 or 1 number of odd count characters.\\n        For string to have k pallindomes, it can have 0 - k number of odd count characters. \\n        \"\"\"\\n        if k > len(s):\\n            return False\\n        \\n        hashmap = collections.defaultdict(int)\\n        \\n        for ch in s:\\n            hashmap[ch] += 1\\n        \\n        odd_character_count = 0\\n        for key in hashmap:\\n            odd_character_count += 1 if hashmap[key] % 2 == 1 else 0\\n            \\n        if odd_character_count > k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723185,
                "title": "c-solution",
                "content": "```\\n    public bool CanConstruct(string s, int k) {\\n        if(s.Length<2)\\n            return k>0;\\n        int[] map=new int[26];\\n        foreach(var ch in s)\\n            map[ch-\\'a\\']++;\\n        int odd=0;\\n        foreach(var ch in map)\\n        {\\n            if(ch!=0&&ch%2!=0)\\n                odd++;\\n        }\\n        return odd<=k&&k<=s.Length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool CanConstruct(string s, int k) {\\n        if(s.Length<2)\\n            return k>0;\\n        int[] map=new int[26];\\n        foreach(var ch in s)\\n            map[ch-\\'a\\']++;\\n        int odd=0;\\n        foreach(var ch in map)\\n        {\\n            if(ch!=0&&ch%2!=0)\\n                odd++;\\n        }\\n        return odd<=k&&k<=s.Length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 653134,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }        \\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }        \\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629545,
                "title": "java-faster-than-99-01-and-less-than-100-00-using-bucket-sort",
                "content": "```\\npublic class Solution {\\n    public boolean canConstruct(String s, int k) {\\n     \\n    \\tif (k > s.length()) {\\n    \\t\\treturn false;\\n    \\t}\\n    \\tint[] count = new int[26];\\n    \\tfor (char c : s.toCharArray()) {\\n    \\t\\tcount[c - \\'a\\']++;\\n    \\t}\\n    \\t\\n    \\tint ones = 0;\\n    \\tfor (int i : count) {\\n    \\t\\tif ((i & 1) == 1) {\\n    \\t\\t\\tones++;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn ones <= k;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean canConstruct(String s, int k) {\\n     \\n    \\tif (k > s.length()) {\\n    \\t\\treturn false;\\n    \\t}\\n    \\tint[] count = new int[26];\\n    \\tfor (char c : s.toCharArray()) {\\n    \\t\\tcount[c - \\'a\\']++;\\n    \\t}\\n    \\t\\n    \\tint ones = 0;\\n    \\tfor (int i : count) {\\n    \\t\\tif ((i & 1) == 1) {\\n    \\t\\t\\tones++;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn ones <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597239,
                "title": "javascript-bitwise-beats-100-100-w-comments",
                "content": "```\\nfunction canConstruct(s, k) {\\n    // base case (s is less than k in length)\\n    if (s.length < k)\\n        return false;\\n\\t\\t\\n    // our 26 bit number to representing all 26 lowercase characters (each bit)\\n    let x = 0;\\n\\t\\n    // iterate thru string\\n    for (let i = 0; i < s.length; i++) {\\n        // flip bit corresponding to this lowercase char\\n        x ^= 1 << (s.charCodeAt(i) - 97);\\n    }\\n\\t\\n    // count set bits\\n    let c = 0;\\n    while (x > 0) {\\n        // inc c if rightmost bit is 1\\n        c += x & 1;\\n        // right shift\\n        x >>= 1;\\n    }\\n\\t\\n    // check if number of odds is less or equal to k\\n    return c <= k;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction canConstruct(s, k) {\\n    // base case (s is less than k in length)\\n    if (s.length < k)\\n        return false;\\n\\t\\t\\n    // our 26 bit number to representing all 26 lowercase characters (each bit)\\n    let x = 0;\\n\\t\\n    // iterate thru string\\n    for (let i = 0; i < s.length; i++) {\\n        // flip bit corresponding to this lowercase char\\n        x ^= 1 << (s.charCodeAt(i) - 97);\\n    }\\n\\t\\n    // count set bits\\n    let c = 0;\\n    while (x > 0) {\\n        // inc c if rightmost bit is 1\\n        c += x & 1;\\n        // right shift\\n        x >>= 1;\\n    }\\n\\t\\n    // check if number of odds is less or equal to k\\n    return c <= k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575664,
                "title": "best-and-efficient-solution-with-explanation-c",
                "content": "Explanation: If you think about the pallindrome, you\\'ll eventually come at the conclusion that a pallindrome can hold atmost single, odd-occurrence alphabet. So, k pallindrome can hold at most k odd-occurrence alphabet and if the count of odd-occurrence alphabet will be more than k then it\\'s impossible to create k pallindrome.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // corner case\\n        if (s.length() < k)\\n            return false;\\n        // to keep the occurrence of alphabets.\\n        int _hash = 0;\\n        \\n        // flip bit at position c - \\'a\\' \\n        for (char c : s)\\n            _hash ^= 1 << (c - \\'a\\');\\n        \\n        // count the number of set bit\\n        while(_hash != 0)\\n        {\\n            k--;\\n            _hash &= _hash - 1;\\n        }\\n        \\n        if (k < 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // corner case\\n        if (s.length() < k)\\n            return false;\\n        // to keep the occurrence of alphabets.\\n        int _hash = 0;\\n        \\n        // flip bit at position c - \\'a\\' \\n        for (char c : s)\\n            _hash ^= 1 << (c - \\'a\\');\\n        \\n        // count the number of set bit\\n        while(_hash != 0)\\n        {\\n            k--;\\n            _hash &= _hash - 1;\\n        }\\n        \\n        if (k < 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571843,
                "title": "java-68-using-frequency-count",
                "content": "```\\n  public boolean canConstruct(String s, int k) {\\n     if(s.length()<k) return false;\\n     int count[]=new int[26];int totalOddCount=0; \\n     for(int i=0;i<s.length();i++) count[s.charAt(i)-\\'a\\']++;   \\n     for(int i=0;i<count.length;i++)\\n         if(count[i]%2!=0)\\n             totalOddCount++;\\n        \\n     return totalOddCount<=k;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public boolean canConstruct(String s, int k) {\\n     if(s.length()<k) return false;\\n     int count[]=new int[26];int totalOddCount=0; \\n     for(int i=0;i<s.length();i++) count[s.charAt(i)-\\'a\\']++;   \\n     for(int i=0;i<count.length;i++)\\n         if(count[i]%2!=0)\\n             totalOddCount++;\\n        \\n     return totalOddCount<=k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 568881,
                "title": "most-detailed-java-explanation-for-beginners",
                "content": "```\\n public boolean canConstruct(String s, int k) {\\n        int n= s.length();\\n        \\n        //K has to be less than N becase\\n        //At max, we can make N palindromes from a String of length N\\n        //e.g. If all characters represent one palindrome, then we would have N palindromes\\n        //since in all others scenarios, atleast one of the palindromes can have more than 1 character\\n        //Hence maximum limit to number of palindromes generated in this case is N\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        //We need to count odd numbered characters. Why?\\n        //Since any palindrome can contain at max 1 odd numbered character, that too in the center\\n        //If there are more odd nunmbered characters(O=K+C) then the number of palindromes \\n        //the given string can be broken into(K)\\n        //Then those extra odd numbered characters cannot be accomdated into those K palindroms\\n        //Hence we will not be able to makebreak the given String into K palindromes \\n\\t\\t//in case O=K+C; C>=1\\n        \\n        int oddNumberedCharacters=0;\\n        int[] count = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n           count[(s.charAt(i)-\\'a\\']++;    \\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            oddNumberedCharacters+=count[i]%2;\\n        }\\n        \\n        return  oddNumberedCharacters<=k;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean canConstruct(String s, int k) {\\n        int n= s.length();\\n        \\n        //K has to be less than N becase\\n        //At max, we can make N palindromes from a String of length N\\n        //e.g. If all characters represent one palindrome, then we would have N palindromes\\n        //since in all others scenarios, atleast one of the palindromes can have more than 1 character\\n        //Hence maximum limit to number of palindromes generated in this case is N\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        //We need to count odd numbered characters. Why?\\n        //Since any palindrome can contain at max 1 odd numbered character, that too in the center\\n        //If there are more odd nunmbered characters(O=K+C) then the number of palindromes \\n        //the given string can be broken into(K)\\n        //Then those extra odd numbered characters cannot be accomdated into those K palindroms\\n        //Hence we will not be able to makebreak the given String into K palindromes \\n\\t\\t//in case O=K+C; C>=1\\n        \\n        int oddNumberedCharacters=0;\\n        int[] count = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n           count[(s.charAt(i)-\\'a\\']++;    \\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            oddNumberedCharacters+=count[i]%2;\\n        }\\n        \\n        return  oddNumberedCharacters<=k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 565472,
                "title": "c-3-lines-using-128-bits-register",
                "content": "```\\nclass Solution {\\npublic:    \\n    bool canConstruct(string s, int k) {\\n         __int128 ret = 0;\\n        for (char c : s) ret ^= ( __int128)1 << c;\\n        \\n        return __builtin_popcount(ret >> 96) <= k && (s.size() >= k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    bool canConstruct(string s, int k) {\\n         __int128 ret = 0;\\n        for (char c : s) ret ^= ( __int128)1 << c;\\n        \\n        return __builtin_popcount(ret >> 96) <= k && (s.size() >= k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564240,
                "title": "c-100-100-one-pass-hashset",
                "content": "Explanation\\n-\\nIf we\\'ve seen a letter an even number of times, we can put it anywhere. We only care about the odd leftovers. Each one needs to be the middle letter of a palindrome. If we have more odds than ```k```, we can\\'t do it. We also need to check if there are actually enough letters in the string.\\n\\nAlgorithm\\n-\\n```\\npublic bool CanConstruct(string s, int k) {\\n\\tif (s.Length < k) return false;\\n\\tvar unpaired = new HashSet<char>();\\n\\tforeach (var letter in s)\\n\\t\\tif (unpaired.Contains(letter))\\n\\t\\t\\tunpaired.Remove(letter);\\n\\t\\telse\\n\\t\\t\\tunpaired.Add(letter);\\n\\treturn unpaired.Count <= k;\\n}\\n```\\n\\nProof\\n-\\n![image](https://assets.leetcode.com/users/laprade/image_1586058531.png)\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```k```\n```\\npublic bool CanConstruct(string s, int k) {\\n\\tif (s.Length < k) return false;\\n\\tvar unpaired = new HashSet<char>();\\n\\tforeach (var letter in s)\\n\\t\\tif (unpaired.Contains(letter))\\n\\t\\t\\tunpaired.Remove(letter);\\n\\t\\telse\\n\\t\\t\\tunpaired.Add(letter);\\n\\treturn unpaired.Count <= k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564194,
                "title": "with-explanation",
                "content": "Firstly if size < k then we must obviously return false.\\nIf size >= k and singles = 0. This means all are pairs. In this case:\\n\\t1: k == size, then we can create k palindrome, each palindrome will have single letter. e.g.: k = 4, s = \\'aabb\\' we can create 4 palindromes as: a, a, b, b.\\n\\t2: k > size: Since all characters are in pair (or even count) we can distribute first k characters as shown above and then remaining are all pairs, which can also be distributed. e.g.: k = 4, s= \\'aaaaaabb\\', palindromes can be constructed in steps as follows:  a, a, a, a => aaabb, a, a, a.\\n\\nIf size >= k and singles > 0. (note, when I say singles I mean number of odd chars, for example if s = \\'aaa\\', single = 1  == last \\'a\\' in \\'aa**a**\\'). Here there can be 2 cases:\\n\\t1: singles < k. In this case we can distribute singles among our palindromes. \\n\\te.g: k = 3, singles = 1 = \\'a\\' =>   --a, --, --. \\n\\tor   k=3, singles = 2 = \\'ab\\' => --a, --b, --.   \\n\\tOr k= 3, singles = 3 = \\'abd\\' => --a, --b, --d.\\n\\t2: singles > k. Continuing from above example, it is easy to see that after adding k singles into k palindromes, we have no place to put the k+1th single, so we must return false. \\n\\nThe c++ code for this is given below:\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size() < k )\\n            return 0;\\n        vector<int> cnt(26);\\n        for(char c: s)\\n            cnt[c-\\'a\\']++;\\n\\n        int singles = 0;\\n        for(int e: cnt)\\n           if(e %2 != 0)\\n               singles++;\\n\\n        return singles <= k;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size() < k )\\n            return 0;\\n        vector<int> cnt(26);\\n        for(char c: s)\\n            cnt[c-\\'a\\']++;\\n\\n        int singles = 0;\\n        for(int e: cnt)\\n           if(e %2 != 0)\\n               singles++;\\n\\n        return singles <= k;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563752,
                "title": "python",
                "content": "If you have X characters with odd counts, then you need at least X palindromes to accomodate them; so, other than making sure that s isn\\'t shorter than k, we only need to check that X <= K\\n\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) < k:\\n            return False\\n        \\n        char_counts = dict()\\n        \\n        for char in s:\\n            if char in char_counts:\\n                char_counts[char] += 1\\n            else:\\n                char_counts[char] = 1\\n        \\n        odd_counts = 0\\n        \\n        for char in char_counts:\\n            if char_counts[char] % 2 == 1:\\n                odd_counts += 1\\n        \\n        return odd_counts <= k",
                "solutionTags": [],
                "code": "If you have X characters with odd counts, then you need at least X palindromes to accomodate them; so, other than making sure that s isn\\'t shorter than k, we only need to check that X <= K\\n\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) < k:\\n            return False\\n        \\n        char_counts = dict()\\n        \\n        for char in s:\\n            if char in char_counts:\\n                char_counts[char] += 1\\n            else:\\n                char_counts[char] = 1\\n        \\n        odd_counts = 0\\n        \\n        for char in char_counts:\\n            if char_counts[char] % 2 == 1:\\n                odd_counts += 1\\n        \\n        return odd_counts <= k",
                "codeTag": "Java"
            },
            {
                "id": 563615,
                "title": "count-odd-numbers-javascript-solution-68-ms",
                "content": "```\\nvar canConstruct = function(s, k) {\\n    if (s.length / k < 1) {\\n        return false;\\n    }\\n    \\n    let counts = new Array(26).fill(0);\\n    const aCode = \"a\".charCodeAt();\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        counts[s.charCodeAt(i) - aCode]++;\\n    }\\n    \\n    let oddCount = 0;\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] % 2 === 1) {\\n            oddCount++;\\n        }\\n    }\\n    \\n    return oddCount <= k;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canConstruct = function(s, k) {\\n    if (s.length / k < 1) {\\n        return false;\\n    }\\n    \\n    let counts = new Array(26).fill(0);\\n    const aCode = \"a\".charCodeAt();\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        counts[s.charCodeAt(i) - aCode]++;\\n    }\\n    \\n    let oddCount = 0;\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] % 2 === 1) {\\n            oddCount++;\\n        }\\n    }\\n    \\n    return oddCount <= k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563474,
                "title": "cpp-fastest-easiest",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k){\\n            return true;\\n        }\\n        if(s.size()<k)return false;\\n        int arr[26]={0};\\n        for(int i=0;i<s.size();i++){\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int no=0,ne=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr[i]%2==0)ne++;\\n            else no++;\\n        }\\n        \\n        if(k<no){\\n            return false;\\n        }\\n        else return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k){\\n            return true;\\n        }\\n        if(s.size()<k)return false;\\n        int arr[26]={0};\\n        for(int i=0;i<s.size();i++){\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int no=0,ne=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr[i]%2==0)ne++;\\n            else no++;\\n        }\\n        \\n        if(k<no){\\n            return false;\\n        }\\n        else return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563440,
                "title": "python-one-liner",
                "content": "The first condition is easy: The input string needs to be least k characters long to form k palindromes.\\nThen we need to count the occurences of each character: If a character is included an even number of times we can create a new palindrome with it or use a pair of it as padding on an existing palindrome without increasing the total palindrome count (XXX -> aXXXa). We only need to watch out for odd character counts as each of those will create a new center. If there are more than k centers we can\\'t construct k palindromes.\\n\\nTime and space complexity: ```O(n)```\\n```python\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum(count % 2 for count in collections.Counter(s).values()) <= k\\n```",
                "solutionTags": [],
                "code": "```O(n)```\n```python\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum(count % 2 for count in collections.Counter(s).values()) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090307,
                "title": "python3-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, x: int) -> bool:\\n        \\n        \\n        freq=Counter(s)\\n        odd=0\\n        \\n        for k,v in freq.items():\\n            if v%2:\\n                odd+=1\\n                \\n        if odd>x:\\n            return False\\n        \\n        return len(s)>=x\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, x: int) -> bool:\\n        \\n        \\n        freq=Counter(s)\\n        odd=0\\n        \\n        for k,v in freq.items():\\n            if v%2:\\n                odd+=1\\n                \\n        if odd>x:\\n            return False\\n        \\n        return len(s)>=x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069749,
                "title": "c-solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char, int> mp;\\n        if(k==s.length()){\\n            return true;\\n        }\\n        else if(k>s.length()) return false;\\n\\n        else{\\n            int odd=0;\\n\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        for(auto i:mp){\\n            if(i.second%2 != 0) odd++;\\n        }\\n\\n        if(odd<=k){\\n            return true;\\n        }\\n        else return false;\\n\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char, int> mp;\\n        if(k==s.length()){\\n            return true;\\n        }\\n        else if(k>s.length()) return false;\\n\\n        else{\\n            int odd=0;\\n\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        for(auto i:mp){\\n            if(i.second%2 != 0) odd++;\\n        }\\n\\n        if(odd<=k){\\n            return true;\\n        }\\n        else return false;\\n\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022713,
                "title": "unordered-map-easy-solution-self-explanatory",
                "content": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //leetcode - here how can we split leetcode into 3 palindromic strings\\n        //odd freq char we have  l,t,c,o,d\\n        //ete eoe so odd freq is more than the k we cannot construct k palindromic strings from this\\n        //true          here all 4 having odd frequency\\n        //we can successfully divide into 4 single palindromic strings\\n        int n=s.size();\\n        if(n<k) return false;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++) \\n            mp[s[i]]++;\\n          int t=0;\\n        for(auto x: mp) {\\n            if(x.second&1) {\\n                t++;\\n            }\\n        }\\n        return t<=k;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //leetcode - here how can we split leetcode into 3 palindromic strings\\n        //odd freq char we have  l,t,c,o,d\\n        //ete eoe so odd freq is more than the k we cannot construct k palindromic strings from this\\n        //true          here all 4 having odd frequency\\n        //we can successfully divide into 4 single palindromic strings\\n        int n=s.size();\\n        if(n<k) return false;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++) \\n            mp[s[i]]++;\\n          int t=0;\\n        for(auto x: mp) {\\n            if(x.second&1) {\\n                t++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4003095,
                "title": "using-hashmap-o-n",
                "content": "# Approach\\nThe basic idea is to use a frequency map and counting\\nWe have to form \"k\" palindromes of ANY size\\nThat said \\n - each palindrome must have an EVEN number of letters\\n   example: aaaa, abaaba\\n - each palindrome can have an extra 1 letter\\n   example: aaBaa, abaEaba \\n\\nIt means we can for palindromes IF extra letters do not exceed \"k\"\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar canConstruct = function(s, k) {\\n    const fmap=new Map();\\n    if(s.length===k) return true;\\n    if(k>s.length) return false;\\n\\n    // build a map  \\n    for(let c of s) fmap.set(c,fmap.has(c)?fmap.get(c)+1:1);\\n    \\n    let lettersLeft=false;\\n    for(let [c,count] of fmap.entries()){\\n        if(count>1)\\n            // count extra letters, e.g aaaa=0,aa=0,aa=0 nothing left we can use all a\\'s\\n            // But yzyzy=1, we have extra \\'y\\' we can should use in this or other polindrome\\n            lettersLeft+=count%2; \\n        else\\n            lettersLeft+=count; // if we got here we have some extra letters we need to spread across all palindromes, rememner each palindrome can take only 1 extra letter  \\n        if(lettersLeft>k) // if there are too much extras we return false\\n            return false;\\n    }  \\n    return true;\\n  };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConstruct = function(s, k) {\\n    const fmap=new Map();\\n    if(s.length===k) return true;\\n    if(k>s.length) return false;\\n\\n    // build a map  \\n    for(let c of s) fmap.set(c,fmap.has(c)?fmap.get(c)+1:1);\\n    \\n    let lettersLeft=false;\\n    for(let [c,count] of fmap.entries()){\\n        if(count>1)\\n            // count extra letters, e.g aaaa=0,aa=0,aa=0 nothing left we can use all a\\'s\\n            // But yzyzy=1, we have extra \\'y\\' we can should use in this or other polindrome\\n            lettersLeft+=count%2; \\n        else\\n            lettersLeft+=count; // if we got here we have some extra letters we need to spread across all palindromes, rememner each palindrome can take only 1 extra letter  \\n        if(lettersLeft>k) // if there are too much extras we return false\\n            return false;\\n    }  \\n    return true;\\n  };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949898,
                "title": "c-explained-easy-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int>map;\\n        for(int i=0;i<s.size();i++){\\n            map[s[i]]++;\\n        }\\n        int odd =0;\\n        for(auto x:map){\\n            if(x.second % 2 != 0) odd++;\\n        }\\n        //means remember 1--> one odd could be only used in one string\\n        // 2--> That implies that if we have more odds and less string some odd will not be used\\n        if(odd > k) return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int>map;\\n        for(int i=0;i<s.size();i++){\\n            map[s[i]]++;\\n        }\\n        int odd =0;\\n        for(auto x:map){\\n            if(x.second % 2 != 0) odd++;\\n        }\\n        //means remember 1--> one odd could be only used in one string\\n        // 2--> That implies that if we have more odds and less string some odd will not be used\\n        if(odd > k) return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947438,
                "title": "c-counting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int freq[26] = {0};\\n        int odd = 0;\\n        for(char ch: s) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) odd += freq[i] % 2;\\n        return odd <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int freq[26] = {0};\\n        int odd = 0;\\n        for(char ch: s) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) odd += freq[i] % 2;\\n        return odd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928949,
                "title": "counting-sort-beats-100",
                "content": "# Complexity\\n- Time complexity:\\nO(s.count)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    private static let aAscii = Character(\"a\").asciiValue!\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        let count = s.count\\n        if count < k { return false }\\n        var occurencies = Array(repeating: 0, count: 26)\\n        \\n        for char in s {\\n            occurencies[Int(char.asciiValue! - Self.aAscii)] += 1\\n        }\\n\\n        let numberOfOdds = occurencies.filter { $0 % 2 == 1 }.count\\n\\n        return numberOfOdds <= k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    private static let aAscii = Character(\"a\").asciiValue!\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        let count = s.count\\n        if count < k { return false }\\n        var occurencies = Array(repeating: 0, count: 26)\\n        \\n        for char in s {\\n            occurencies[Int(char.asciiValue! - Self.aAscii)] += 1\\n        }\\n\\n        let numberOfOdds = occurencies.filter { $0 % 2 == 1 }.count\\n\\n        return numberOfOdds <= k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928017,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nif a string has more than one letter whose frequency is odd then that string cannot form palindrome, hence keeping this in mind, we keep track of each letters frequency, if it is odd we increment num by 1 for every odd frequency. If num is Less than k value then we return true.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k >len(s):\\n            return False\\n        num = 0\\n        p = Counter(s).values()\\n        for i in p:\\n            if i % 2 == 1:\\n                num = num+1\\n        if num <= k:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k >len(s):\\n            return False\\n        num = 0\\n        p = Counter(s).values()\\n        for i in p:\\n            if i % 2 == 1:\\n                num = num+1\\n        if num <= k:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897365,
                "title": "greedy-solution-odd-frequency-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n) return 0;\\n        int cnt[26] = {};\\n        for(int i=0;i<n;i++){\\n            cnt[s[i]-\\'a\\']++;\\n        }\\n        int odd_frequency = 0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2)odd_frequency++;\\n        }\\n        if(k < odd_frequency) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n) return 0;\\n        int cnt[26] = {};\\n        for(int i=0;i<n;i++){\\n            cnt[s[i]-\\'a\\']++;\\n        }\\n        int odd_frequency = 0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2)odd_frequency++;\\n        }\\n        if(k < odd_frequency) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894914,
                "title": "optimized-approach-in-c-time-o-n-space-o-1",
                "content": "# Approach\\nUse hashing to count number of occcurences specifically to get odd occuring alphabets in string.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(26) ~ O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bool ans;\\n        if(k==s.length()){\\n            ans=true;\\n        }\\n        else if(k>s.length()){\\n            ans=false;\\n        }\\n        else{\\n            vector<int> count(26,0);\\n            for(auto i:s){\\n                count[i-\\'a\\']++;\\n            }\\n            int odd_count=0;\\n            for(auto i:count){\\n                if(i%2!=0){\\n                    odd_count++;\\n                }\\n            }\\n            if(odd_count>k){\\n                ans=false;\\n            }\\n            else{\\n                ans=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bool ans;\\n        if(k==s.length()){\\n            ans=true;\\n        }\\n        else if(k>s.length()){\\n            ans=false;\\n        }\\n        else{\\n            vector<int> count(26,0);\\n            for(auto i:s){\\n                count[i-\\'a\\']++;\\n            }\\n            int odd_count=0;\\n            for(auto i:count){\\n                if(i%2!=0){\\n                    odd_count++;\\n                }\\n            }\\n            if(odd_count>k){\\n                ans=false;\\n            }\\n            else{\\n                ans=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865494,
                "title": "easy-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int count=0;\\n        for(auto num:mp)\\n        {\\n            if(num.second%2==1)count++;\\n        }\\n\\n\\n        return count>k || s.size()<k?false:true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int count=0;\\n        for(auto num:mp)\\n        {\\n            if(num.second%2==1)count++;\\n        }\\n\\n\\n        return count>k || s.size()<k?false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847816,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n = s.length();\\n        if(k>n) return false;\\n        if(k==n) return true;\\n\\n        HashMap<Character,Integer> hp = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(hp.containsKey(ch)) hp.put(ch,hp.get(ch)+1);\\n            else hp.put(ch,1);\\n        }\\n\\n        int odd = 0;\\n\\n        for(var a : hp.values()){\\n            if(a%2!=0) odd ++;\\n        }\\n\\n        if(odd>k) return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n = s.length();\\n        if(k>n) return false;\\n        if(k==n) return true;\\n\\n        HashMap<Character,Integer> hp = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(hp.containsKey(ch)) hp.put(ch,hp.get(ch)+1);\\n            else hp.put(ch,1);\\n        }\\n\\n        int odd = 0;\\n\\n        for(var a : hp.values()){\\n            if(a%2!=0) odd ++;\\n        }\\n\\n        if(odd>k) return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837757,
                "title": "1400-construct-k-palindrome-strings-java",
                "content": "# Intuition\\nAs a palindrome string can be of even length and odd length.\\nNow for even length it won\\'t be a problem but for odd length we need to keep one chracter in middle of the string so all the character with odd occurences is what will make a diffrence.\\n\\n# Approach\\nCount all the occurnces of the chracters in string and then count no of chracters with odd occurences if the occurnce is gretaer than k then we can not opartition the string.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: constant\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int l = s.length();\\n        if(k>l)\\n        return false;\\n        int[] arr = new int[26];\\n//count all characters occurence\\n        for(int i=0; i<l; i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n\\n        int nOdd = 0;\\n\\n// count all Odd occurences because odd occurences are all that will make difference \\n        for(int i=0; i<26; i++) { \\n            if(arr[i]%2!=0)\\n                  nOdd++;\\n        }\\n\\n        if(nOdd>k)\\n        return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int l = s.length();\\n        if(k>l)\\n        return false;\\n        int[] arr = new int[26];\\n//count all characters occurence\\n        for(int i=0; i<l; i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n\\n        int nOdd = 0;\\n\\n// count all Odd occurences because odd occurences are all that will make difference \\n        for(int i=0; i<26; i++) { \\n            if(arr[i]%2!=0)\\n                  nOdd++;\\n        }\\n\\n        if(nOdd>k)\\n        return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823470,
                "title": "java-easy-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThinking a bit we can see that a pair of odd letters suppose \"abc\" , in such a case there are 3 odd letters and if k=1 or k=2 output shall be **false** but if k=3 output will be **true**.\\nSo what we can observe is:\\nA pair of even letters \"aa\" can make either 1 or 2 palindrome but a pair of odd letters \"ab\" can only make 2, it cannot make 1.\\nSo we just tracked odd nos, **if TotalOddNos<=k then ans will be true** , but **if there are more odd than k then ans will be****false**.(Try to dry run as many testcases possible for better understanding).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a set we can have count of freq of odd nos;\\nif set already contains an char remove the char and continue , cause this char is now even.\\nIn the end set.size() will be total odd chars.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n) (in worst case it will have to store all chars , eg: \"abcde\")\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k)\\n        return false;\\n        if(s.length()==k) return true;\\n        HashSet<Character> set=new HashSet<>();\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(set.contains(s.charAt(i)))\\n            {\\n                set.remove(s.charAt(i));\\n               continue;\\n            }\\n            else\\n            set.add(s.charAt(i));\\n        }\\n        if(set.size()<=k)\\n        return true;\\n        else\\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k)\\n        return false;\\n        if(s.length()==k) return true;\\n        HashSet<Character> set=new HashSet<>();\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(set.contains(s.charAt(i)))\\n            {\\n                set.remove(s.charAt(i));\\n               continue;\\n            }\\n            else\\n            set.add(s.charAt(i));\\n        }\\n        if(set.size()<=k)\\n        return true;\\n        else\\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821414,
                "title": "c-easy-to-understand-straightforward-approach",
                "content": "# Intuition\\nwe need to ensure that each palindrome can have at most one character with an odd frequency, as all other characters with odd frequencies can be paired up to form palindromes. If the number of characters with odd frequencies exceeds `k`, it will not be possible to construct `k` palindromes.\\n\\n# Approach\\n1. If the length of the string `s` is less than `k`, it is not possible to construct `k` palindromes using all characters. Return false in this case.\\n2. Create an unordered map `mp` to store the frequency of each character in the string `s`.\\n3. Count the number of characters with odd frequencies (i.e., frequency % 2 == 1) in the `mp` map and store it in the variable `oddcnt`.\\n4. If `oddcnt` is greater than `k`, it is not possible to construct `k` palindromes using all characters. Return false in this case.\\n5. Otherwise, it is possible to construct `k` palindromes. Return true.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is O(n), where n is the length of the string `s`, as we need to iterate through the string to count the character frequencies.\\n- Space complexity: The space complexity is O(n), where n is the length of the string `s`, due to the unordered map `mp` storing character frequencies.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        \\n        int oddcnt = 0;\\n        unordered_map<char,int> mp;\\n\\n        for(auto each: s)\\n            mp[each]++;\\n\\n        for(auto each: mp){\\n            if(each.second % 2)\\n                oddcnt++;\\n        }\\n\\n        if(oddcnt > k) \\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        \\n        int oddcnt = 0;\\n        unordered_map<char,int> mp;\\n\\n        for(auto each: s)\\n            mp[each]++;\\n\\n        for(auto each: mp){\\n            if(each.second % 2)\\n                oddcnt++;\\n        }\\n\\n        if(oddcnt > k) \\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805888,
                "title": "c-99-simple-logic",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int odds = 0;\\n        vector<int> char_map(26, 0);\\n\\n        for(auto &c : s) \\n            char_map[c - \\'a\\']++;\\n\\n        for(auto &i : char_map)\\n            if(i % 2 != 0) \\n                odds++;\\n\\n        return odds <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int odds = 0;\\n        vector<int> char_map(26, 0);\\n\\n        for(auto &c : s) \\n            char_map[c - \\'a\\']++;\\n\\n        for(auto &i : char_map)\\n            if(i % 2 != 0) \\n                odds++;\\n\\n        return odds <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771005,
                "title": "3-lines-c",
                "content": "```\\nbool canConstruct(string s, int k) {\\n  int mask = 0;\\n  for(auto c: s) { mask ^= (1U << (c-\\'a\\')); }        \\n  return (s.size()>=k) && (__builtin_popcount(mask)<=k);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConstruct(string s, int k) {\\n  int mask = 0;\\n  for(auto c: s) { mask ^= (1U << (c-\\'a\\')); }        \\n  return (s.size()>=k) && (__builtin_popcount(mask)<=k);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766097,
                "title": "simple-java-solution-o-n-tc-explained-intuition",
                "content": "# Intuition\\nHere we dont have to create pallindrome we just need to check if it is possible or not so i followed some simple rules.\\n1. if all the elements are distinct that means \\'a\\' \\'b\\' \\'c\\' are all pallindrome so we can return true.\\n2. if size of string is less that no of required pallindrome then its obviously not possible so false.\\n3. at max the odd appearing character can be equal to k, coz in a pallindrome a odd appearing number has to \\'appear\\' in the middle else it can be a pallindrome so i check for odd occurruing elements \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        HashMap<Character, Integer> count = new HashMap<>();\\n        for(char c : s.toCharArray()) {\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        if(count.size() == k) return true;\\n        if(s.length() < k) return false;\\n        \\n        int j = 0;\\n        for(char c : count.keySet()) {\\n            if(count.get(c) % 2 != 0) j++;\\n        }\\n        \\n        return j <= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        HashMap<Character, Integer> count = new HashMap<>();\\n        for(char c : s.toCharArray()) {\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        if(count.size() == k) return true;\\n        if(s.length() < k) return false;\\n        \\n        int j = 0;\\n        for(char c : count.keySet()) {\\n            if(count.get(c) % 2 != 0) j++;\\n        }\\n        \\n        return j <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764709,
                "title": "super-simple-just-count-odd-count-character-less-or-eq-to-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)<k: return False\\n        o=0\\n        for i in Counter(s).values():\\n            if i%2: o+=1\\n         \\n        return o<=k  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)<k: return False\\n        o=0\\n        for i in Counter(s).values():\\n            if i%2: o+=1\\n         \\n        return o<=k  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733181,
                "title": "easy-way-no",
                "content": "# Easy way (no)\\n![image.png](https://assets.leetcode.com/users/images/73e9e1d6-77d5-4d4d-8609-71c5f5bc3a06_1688749631.1845062.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 45\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 97\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        d = {}\\n        for i in s:\\n            d[i] = d.get(i, 0) + 1\\n        odd_count = sum((1 for i in d if d[i] % 2 == 1))\\n        return odd_count <= k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        d = {}\\n        for i in s:\\n            d[i] = d.get(i, 0) + 1\\n        odd_count = sum((1 for i in d if d[i] % 2 == 1))\\n        return odd_count <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713758,
                "title": "python3-9-lines-t-s-o-n-o-1-t-100",
                "content": "# Intuition\\n\\nWe can first take ALL pairs of the same letter, and these pairs can go into any palindrome.\\n\\nAfter which, we will be left with one of each letter with odd count in `s`. These letters cannot belong to the same palindrome (since each palindrome can only have at most one odd-numbered letter; its center).\\n\\nHence, if `k` is greater than or equal to the number of odd-numbered letters, return `True`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nwhere `n` is the length of `s`\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n# Time: O(n)\\n# Space: O(1)\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n\\n        # if there aren\\'t enough letters to make k palindromes\\n        if k > len(s): return False\\n\\n        # pigeonhole principle, since there are at most 26 alphabets,\\n        # there can be at most 26 odd-numbered letters\\n        if k >= 26: return True\\n\\n        # initialise bit-shift for each letter\\n        letters = {}\\n        for i, c in enumerate(\\'aquickbrownfoxjumpsoverthelazydog\\'):\\n            letters[c] = i\\n\\n        # use bit-string to represent if letter count is even/odd\\n        bs = 0\\n        for c in s:\\n            bs ^= 1 << letters[c]\\n\\n        return bs.bit_count() <= k\\n\\n```\\n\\nhttps://leetcode.com/problems/construct-k-palindrome-strings/submissions/985452122/",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Bitmask"
                ],
                "code": "```\\n# Time: O(n)\\n# Space: O(1)\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n\\n        # if there aren\\'t enough letters to make k palindromes\\n        if k > len(s): return False\\n\\n        # pigeonhole principle, since there are at most 26 alphabets,\\n        # there can be at most 26 odd-numbered letters\\n        if k >= 26: return True\\n\\n        # initialise bit-shift for each letter\\n        letters = {}\\n        for i, c in enumerate(\\'aquickbrownfoxjumpsoverthelazydog\\'):\\n            letters[c] = i\\n\\n        # use bit-string to represent if letter count is even/odd\\n        bs = 0\\n        for c in s:\\n            bs ^= 1 << letters[c]\\n\\n        return bs.bit_count() <= k\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704019,
                "title": "hashmap-easy-c-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLets store no of occurrences of each alphabet.\\n\\nObservation I :\\n\\nIf any alphabet has odd occurence one of its letter should be the middle character in one of the pallindromes.\\n\\nObservation II :\\nIf the number of remaining letters is greater than or equal to the remaining k value there is a possibility.\\nWe can choose to break up pairs or not greedily.\\n\\n# Complexity\\n- Time complexity:\\n$$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26,0);\\n        for(auto x : s){\\n            cnt[x-\\'a\\']++;\\n        }\\n        int summ=0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2==1){\\n                k--;\\n                cnt[i]--;\\n            }\\n            summ+=cnt[i];\\n        }\\n        return (summ>=k && k>=0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26,0);\\n        for(auto x : s){\\n            cnt[x-\\'a\\']++;\\n        }\\n        int summ=0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2==1){\\n                k--;\\n                cnt[i]--;\\n            }\\n            summ+=cnt[i];\\n        }\\n        return (summ>=k && k>=0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678667,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(char c : s) {\\n            m[c]++;\\n        }\\n        int ones = 0;\\n        for(auto x : m) {\\n            if(x.second %2 ==1) {\\n                ones++;\\n            }\\n        }\\n        int n = s.size();\\n        return ones <= k && n>=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(char c : s) {\\n            m[c]++;\\n        }\\n        int ones = 0;\\n        for(auto x : m) {\\n            if(x.second %2 ==1) {\\n                ones++;\\n            }\\n        }\\n        int n = s.size();\\n        return ones <= k && n>=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677544,
                "title": "python-solution-time-complexity-o-n",
                "content": "Here is my solution.\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counts, minimum, maximum = {}, 0, 0\\n\\n        for char in s:\\n            if counts.get(char) is not None:\\n                counts[char] += 1\\n            else:\\n                counts[char] = 1\\n\\n        for char, count in counts.items():\\n            if count % 2 == 0:\\n                maximum += count\\n            elif count % 2 == 1:\\n                minimum += 1\\n                maximum += count\\n\\n        return max(1, minimum) <= k <= maximum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counts, minimum, maximum = {}, 0, 0\\n\\n        for char in s:\\n            if counts.get(char) is not None:\\n                counts[char] += 1\\n            else:\\n                counts[char] = 1\\n\\n        for char, count in counts.items():\\n            if count % 2 == 0:\\n                maximum += count\\n            elif count % 2 == 1:\\n                minimum += 1\\n                maximum += count\\n\\n        return max(1, minimum) <= k <= maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667991,
                "title": "hashmap-beginner-friendly",
                "content": "# Intuition\\njust count odd freq element as we know that even freq elements can make palindrome easily so ignore even freq element. A palindrome can contain at most one odd freq element, so if odd freq characters are greater than k its clear that we cant divide all characters of the string to form k palondrome as we will be left with some odd freq elements.....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        if(s.size() == k)\\n            return true;\\n\\n        if(s.size() < k)\\n            return false;\\n        \\n        map<char, int> m;\\n\\n        for(int i=0; i<s.size(); i++)\\n            m[s[i]]++;\\n\\n        int cnt=0;\\n\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second%2 != 0)\\n                cnt++;\\n        }\\n\\n        if(cnt > k)\\n        {\\n            return false;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        if(s.size() == k)\\n            return true;\\n\\n        if(s.size() < k)\\n            return false;\\n        \\n        map<char, int> m;\\n\\n        for(int i=0; i<s.size(); i++)\\n            m[s[i]]++;\\n\\n        int cnt=0;\\n\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second%2 != 0)\\n                cnt++;\\n        }\\n\\n        if(cnt > k)\\n        {\\n            return false;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630491,
                "title": "java-simple-using-alphabet-array",
                "content": "# Intuition\\nIf the number of odd frequencies is more than k, then return false.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s.length() == k) return true;\\n        if (s.length() < k) return false;\\n        int alph[] = new int[26], countOdd = 0;\\n        for (int i = 0; i < s.length(); i++) alph[s.charAt(i) - \\'a\\']++;\\n        for (int i = 0; i < alph.length; i++) if (alph[i] % 2 == 1) countOdd++;\\n        return countOdd <= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s.length() == k) return true;\\n        if (s.length() < k) return false;\\n        int alph[] = new int[26], countOdd = 0;\\n        for (int i = 0; i < s.length(); i++) alph[s.charAt(i) - \\'a\\']++;\\n        for (int i = 0; i < alph.length; i++) if (alph[i] % 2 == 1) countOdd++;\\n        return countOdd <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600834,
                "title": "easy-to-understand-with-simple-approach",
                "content": "# Intuition\\nLook into characters with odd frequency\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach-\\n1)If the size of string is less than k,return false.\\n2)Store the frequency of each character in a map\\n3)Count the number of elements having odd frequencies.\\n4)If the count<= k return true else false\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int> mp;\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int numOfodd=0;\\n        for(auto i:mp){\\n           if(i.second%2!=0)\\n              numOfodd++;\\n        }\\n        return (numOfodd<=k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int> mp;\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int numOfodd=0;\\n        for(auto i:mp){\\n           if(i.second%2!=0)\\n              numOfodd++;\\n        }\\n        return (numOfodd<=k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593302,
                "title": "easy-trick-with-code",
                "content": "\\n# Approach\\n Easy Trick:\\n Edge case: if( length of s<k) return false;\\n1. Count the frequency of every character.\\n2. Count the number of character whose frequency is odd.\\n3. If no. of odd frequency character > k return false, else return true;\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n=s.length();\\n        if(n==k)return true;\\n        if(k>n)return false;\\n\\n        int[] arr=new int[26];\\n\\n        for(char c:s.toCharArray())arr[c-\\'a\\']++;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++){\\n            if(arr[i]%2!=0)count++;\\n        }\\n        if(count>k)return false;\\n        return true;\\n    }\\n}\\n```\\nPlease upvote if you understood the solution",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n=s.length();\\n        if(n==k)return true;\\n        if(k>n)return false;\\n\\n        int[] arr=new int[26];\\n\\n        for(char c:s.toCharArray())arr[c-\\'a\\']++;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++){\\n            if(arr[i]%2!=0)count++;\\n        }\\n        if(count>k)return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516950,
                "title": "count-frequencies-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k){\\n        \\n    if(s.length()<k)return false;\\n\\n    int[]freqarr=new int[26];\\n\\n    int even=0;\\n\\n    int odd=0;\\n\\n    for(int i=0;i<s.length();i++){\\n        freqarr[s.charAt(i)-\\'a\\']++;\\n    }\\n\\n    for(int i=0;i<26;i++){\\n        if(freqarr[i]%2==0){\\n            even++;\\n        }\\n        else{\\n            odd++;\\n        }\\n    }\\n\\n    if(odd>k)return false;\\n\\n    return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k){\\n        \\n    if(s.length()<k)return false;\\n\\n    int[]freqarr=new int[26];\\n\\n    int even=0;\\n\\n    int odd=0;\\n\\n    for(int i=0;i<s.length();i++){\\n        freqarr[s.charAt(i)-\\'a\\']++;\\n    }\\n\\n    for(int i=0;i<26;i++){\\n        if(freqarr[i]%2==0){\\n            even++;\\n        }\\n        else{\\n            odd++;\\n        }\\n    }\\n\\n    if(odd>k)return false;\\n\\n    return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508841,
                "title": "very-easy-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) \\n    {\\n        int count=0;\\n        if(k>s.length())return false;\\n    if(s.length()==k)return true;\\n    HashMap<Character,Integer> map=new HashMap<>();\\n    for(int i=0; i<s.length(); i++)\\n    {\\n        map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n    }\\n    for(Map.Entry<Character,Integer> entry:map.entrySet())\\n    {\\n        if(entry.getValue()%2!=0)\\n        {\\n         count++;\\n        }\\n    }\\n    if(count>k)return false;\\n\\n\\n    return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) \\n    {\\n        int count=0;\\n        if(k>s.length())return false;\\n    if(s.length()==k)return true;\\n    HashMap<Character,Integer> map=new HashMap<>();\\n    for(int i=0; i<s.length(); i++)\\n    {\\n        map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n    }\\n    for(Map.Entry<Character,Integer> entry:map.entrySet())\\n    {\\n        if(entry.getValue()%2!=0)\\n        {\\n         count++;\\n        }\\n    }\\n    if(count>k)return false;\\n\\n\\n    return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480371,
                "title": "python-greedy-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n\\n        hash = defaultdict(int)\\n\\n        for ch in s:\\n            hash[ch] += 1\\n                    \\n        count = 0\\n        \\n        for num in hash.values():\\n            if num % 2 != 0:\\n                count += 1\\n                \\n        return count <= k\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n\\n        hash = defaultdict(int)\\n\\n        for ch in s:\\n            hash[ch] += 1\\n                    \\n        count = 0\\n        \\n        for num in hash.values():\\n            if num % 2 != 0:\\n                count += 1\\n                \\n        return count <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477466,
                "title": "construct-k-palindrome-strings",
                "content": "----------------- Easy C++ Solution -------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        if(s.size() == k) return true;\\n        vector<int> count(26);\\n        for(char c : s){\\n            count[c-\\'a\\']++;\\n        }\\n        int odd = 0;\\n        for(int i = 0; i < 26; i++){\\n            if(count[i] % 2 == 1){\\n                odd++;\\n            }\\n        }\\n        return odd <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        if(s.size() == k) return true;\\n        vector<int> count(26);\\n        for(char c : s){\\n            count[c-\\'a\\']++;\\n        }\\n        int odd = 0;\\n        for(int i = 0; i < 26; i++){\\n            if(count[i] % 2 == 1){\\n                odd++;\\n            }\\n        }\\n        return odd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444963,
                "title": "java-bitset-solution-with-detailed-comments",
                "content": "# Code\\n```\\n// Class definition for the solution\\nclass Solution {\\n    // Method to check if a given string \\'s\\' can be partitioned into \\'k\\' non-empty palindrome strings\\n    public boolean canConstruct(String s, int k) {\\n        // Create a BitSet of size 26 to represent each lowercase English letter\\n        BitSet chars = new BitSet(26);\\n\\n        // Iterate through the given string \\'s\\'\\n        for (int i = 0; i < s.length(); ++i) {\\n            // Toggle the bit at the index corresponding to the current character,\\n            // effectively counting the occurrences of each character with odd parity\\n            chars.flip(s.charAt(i) - \\'a\\');\\n        }\\n\\n        // If the number of characters with odd occurrences (cardinality of BitSet) is less than or equal to \\'k\\'\\n        // and \\'k\\' is less than or equal to the length of the string \\'s\\', return true\\n        // (meaning the string can be partitioned into \\'k\\' palindrome strings)\\n        return chars.cardinality() <= k && k <= s.length(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Class definition for the solution\\nclass Solution {\\n    // Method to check if a given string \\'s\\' can be partitioned into \\'k\\' non-empty palindrome strings\\n    public boolean canConstruct(String s, int k) {\\n        // Create a BitSet of size 26 to represent each lowercase English letter\\n        BitSet chars = new BitSet(26);\\n\\n        // Iterate through the given string \\'s\\'\\n        for (int i = 0; i < s.length(); ++i) {\\n            // Toggle the bit at the index corresponding to the current character,\\n            // effectively counting the occurrences of each character with odd parity\\n            chars.flip(s.charAt(i) - \\'a\\');\\n        }\\n\\n        // If the number of characters with odd occurrences (cardinality of BitSet) is less than or equal to \\'k\\'\\n        // and \\'k\\' is less than or equal to the length of the string \\'s\\', return true\\n        // (meaning the string can be partitioned into \\'k\\' palindrome strings)\\n        return chars.cardinality() <= k && k <= s.length(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430766,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k>s.length()) return false;\\n        boolean isOdd[] = new boolean[26];\\n        for (char c:s.toCharArray()) isOdd[c-\\'a\\']=!isOdd[c-\\'a\\'];\\n        for (boolean b:isOdd) if (b)k--;\\n        return (k>=0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k>s.length()) return false;\\n        boolean isOdd[] = new boolean[26];\\n        for (char c:s.toCharArray()) isOdd[c-\\'a\\']=!isOdd[c-\\'a\\'];\\n        for (boolean b:isOdd) if (b)k--;\\n        return (k>=0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425546,
                "title": "easy-c-solution-intuitive-using-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhave to check for the characters having odd frequency as they have to be present at different strings.\\nif no of characters having odd frequency is less than equal to k then we return true else false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstoring frequency in unordered_map for each character\\ntraversing map to check for odd frequency character\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(s.length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(s.length)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(auto x:s)\\n        {\\n            m[x]++;\\n        }\\n\\n        if(k>s.length())\\n        {\\n            return false;\\n        }\\n\\n        int no = 0;\\n        for(auto x:m)\\n        {\\n            if(x.second%2!=0)\\n            {\\n                no++;\\n            }\\n        }\\n\\n        if(no<=k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(auto x:s)\\n        {\\n            m[x]++;\\n        }\\n\\n        if(k>s.length())\\n        {\\n            return false;\\n        }\\n\\n        int no = 0;\\n        for(auto x:m)\\n        {\\n            if(x.second%2!=0)\\n            {\\n                no++;\\n            }\\n        }\\n\\n        if(no<=k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410448,
                "title": "c-short-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size()) return false;\\n        int freq[26];\\n        memset(freq, 0, sizeof(freq));\\n        for (char c : s) ++ freq[c - \\'a\\'];\\n        for (int i = 0; i < 26; ++ i) {\\n            if (freq[i] & 1) {\\n                -- k;\\n                if (k < 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size()) return false;\\n        int freq[26];\\n        memset(freq, 0, sizeof(freq));\\n        for (char c : s) ++ freq[c - \\'a\\'];\\n        for (int i = 0; i < 26; ++ i) {\\n            if (freq[i] & 1) {\\n                -- k;\\n                if (k < 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398509,
                "title": "c-greedy-counting-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCounting & Greedy Combinatrics. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will count the number of occurenece of each alphabet in the string and store in count vector.\\n2. Then, we will count the number of maximum total even pairs possible AND the left out odd values.\\n3. This is because we can merge 1 odd value to pair(s) of even value .\\n4. Then we will evaluate the minimum number of palindromic substrings that we will be able to make by the givven formula =>\\n`if(odds<=evens)  \\n  val += odds;`\\n`else \\n  val += evens + (odds - evens);`\\n5. If the val is <= k : true ELSE false\\n6. Taking care of base case :-\\n` if(n==k)    return true;`\\n`if(n<k)     return false;`\\n\\n![download (1).jfif](https://assets.leetcode.com/users/images/56c84a2f-1553-4523-bfd1-adee7f233903_1681070502.749976.jpeg)\\n\\n\\n# Complexity\\n- Time complexity : O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity  : O(26) ~= O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //base cases\\n        int n = s.size();\\n        if(n==k)    return true;\\n        if(n<k)     return false;\\n\\n        //counting occurences\\n        vector<int> count (26,0);\\n        for(auto i : s) \\n            count[i-\\'a\\']++;\\n\\n        //counting possible_even_pairs AND left out Odds\\n        int odds = 0, evens = 0;\\n        for(auto i : count)     {        \\n            evens += i/2;\\n            odds += i%2;\\n        }\\n\\n        //evaluating val using above explained formula\\n        int val=0;\\n        if(odds<=evens)  \\n            val += odds;\\n        else \\n            val += evens + (odds - evens);\\n\\n        return val <= k ? 1 : 0;\\n    }\\n};\\n```\\n\\n![download (2).jfif](https://assets.leetcode.com/users/images/21ec2357-1a51-48c5-8aee-698351e9c16a_1681070518.8362906.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //base cases\\n        int n = s.size();\\n        if(n==k)    return true;\\n        if(n<k)     return false;\\n\\n        //counting occurences\\n        vector<int> count (26,0);\\n        for(auto i : s) \\n            count[i-\\'a\\']++;\\n\\n        //counting possible_even_pairs AND left out Odds\\n        int odds = 0, evens = 0;\\n        for(auto i : count)     {        \\n            evens += i/2;\\n            odds += i%2;\\n        }\\n\\n        //evaluating val using above explained formula\\n        int val=0;\\n        if(odds<=evens)  \\n            val += odds;\\n        else \\n            val += evens + (odds - evens);\\n\\n        return val <= k ? 1 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395252,
                "title": "return-true-for-k-26",
                "content": "# Intuition\\nIf both k and s.length() is greater or equal to 26, we can return solution as true because there can only be 26 bucket in worst case and you will always have enough characters available to expand k. \\n\\n# Complexity\\n- Time complexity:\\nO(1) when k>=26, O(n) otherwise.\\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }else if(k==s.length()){\\n            return true;\\n        }else if(k>=26){\\n            return true;\\n        }\\n        int map[]=new int[26];\\n        for(int i=0;i<s.length();i++){\\n            map[s.charAt(i)-\\'a\\']++;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            cnt+=map[i]%2;\\n        }\\n        return cnt<=k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }else if(k==s.length()){\\n            return true;\\n        }else if(k>=26){\\n            return true;\\n        }\\n        int map[]=new int[26];\\n        for(int i=0;i<s.length();i++){\\n            map[s.charAt(i)-\\'a\\']++;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            cnt+=map[i]%2;\\n        }\\n        return cnt<=k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386350,
                "title": "python-even-odd-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        dic = Counter(s)\\n        even, odd = 0,0\\n        for i in dic.keys():\\n            if dic[i]%2!=0:\\n                odd+=1\\n                dic[i]-=1\\n            even+=dic[i]\\n\\n        if odd > k or odd+even<k:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        dic = Counter(s)\\n        even, odd = 0,0\\n        for i in dic.keys():\\n            if dic[i]%2!=0:\\n                odd+=1\\n                dic[i]-=1\\n            even+=dic[i]\\n\\n        if odd > k or odd+even<k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381403,
                "title": "construct-k-palindrome-strings",
                "content": "# Intuition\\nCondition 1. odd characters <= k\\nCount the occurrences of all characters.\\nIf one character has odd times occurrences,\\nthere must be at least one palindrome,\\nwith odd length and this character in the middle.\\nSo we count the characters that appear odd times,\\nthe number of odd character should not be bigger than k.\\n\\nCondition 2. k <= s.length()\\nAlso, if we have one character in each palindrome,\\nwe will have at most s.length() palindromes,\\nso we need k <= s.length().\\n\\nThe above two condition are necessary and sufficient conditions for this problem.\\nSo we return odd <= k <= n\\n\\n\\nConstruction\\n@spjparmar immediately got a question like why this works always for all strings.\\nHe gave the some following dry runs. :)\\nFor any string with 0 odd character count , we can form k no. of palindrome strings for sure with k<=n\\n(This is why k<=n)\\n\\neg\\naabb, k=1| abba\\naabb, k=2 | aa, bb\\naabb, k=3 | a, a, bb\\naabb, k=4 | a, a, b, b\\n\\nFor any string with odd character count <=k , we can always form k palindrome string for sure with k<=n\\neg2\\naabbc, k=1 | aacbb\\naabbc, k=2 | aca, bb\\naabbc, k=3 | a,a, bcb\\naabbc, k=4 | a, a, c ,bb\\naabbc, k=5 | a, a, c, b, b\\n\\neg3\\naabc, k=1 | N/A\\naabc, k=2 | aba, c\\naabc, k=3 | aa, b, c\\naabc, k=4 | a, a, b, c\\n\\nHope this helps somebody.\\n\\n\\n\\n# Complexity\\n- Time complexity: 0(n)\\n\\n\\n- Space complexity:0(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375694,
                "title": "easy-solution-cpp",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.length()) return false;\\n        if(k == s.length()) return true;\\n        unordered_map<char,int> mp;\\n\\n        for(int i =0; i<s.length(); i++){\\n            mp[s[i]]++;\\n        }\\n        int cnt =0;\\n        for(auto it : mp){\\n            if(it.second % 2 !=0) {cnt++;}\\n        }\\n        if(cnt > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.length()) return false;\\n        if(k == s.length()) return true;\\n        unordered_map<char,int> mp;\\n\\n        for(int i =0; i<s.length(); i++){\\n            mp[s[i]]++;\\n        }\\n        int cnt =0;\\n        for(auto it : mp){\\n            if(it.second % 2 !=0) {cnt++;}\\n        }\\n        if(cnt > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347696,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nbool canConstruct(string s, int k) {\\n    int n = s.length();\\n    if (k>n)\\n        return false;\\n    int wasted = 0;\\n    vector<int> freq(26,0);\\n    for (int i{};i<n;i++)\\n        freq[s[i]-\\'a\\']++;\\n    for (int i{};i<26;i++){\\n        if (freq[i]%2!=0)\\n            wasted++;\\n    }\\n    return wasted<=k;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool canConstruct(string s, int k) {\\n    int n = s.length();\\n    if (k>n)\\n        return false;\\n    int wasted = 0;\\n    vector<int> freq(26,0);\\n    for (int i{};i<n;i++)\\n        freq[s[i]-\\'a\\']++;\\n    for (int i{};i<26;i++){\\n        if (freq[i]%2!=0)\\n            wasted++;\\n    }\\n    return wasted<=k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337670,
                "title": "100-python",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        for i in s:\\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                k -= 1\\n                if k == -1:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        for i in s:\\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                k -= 1\\n                if k == -1:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337245,
                "title": "explaination-let-s-take-it-one-by-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIdea is to first try if the simple logic works. Let me put every thought pointwise.\\n\\n1. S will have some odd occurance as well as some even occurances of characters, sounds obivious?.\\n2. First of all, if odd occurances(Let\\'s call O) are more than K i.e O>K, then it\\'s not possible to build just k palindroms using O occurances.  why? Ok, have you seen a palindrom which contains 2 or more odd occurances? There can be atmost one odd occurance and that too in the center.\\n3. It\\'s easy till this point, Now let\\'s take just one character from all the Os and create first O palindroms. So we already have O palndroms out of the K palindroms that we wanted to create.\\n4. Now, we will have to create K-O palindromes out of S-O characters. Remember that all (S-O) remaing characters are even occurances. So another simple condition that comes to mind is (S-O)>=(K-O) or S>K.\\n5. But is it a sufficient condition? let\\'s think in this way. We will build palindromes incremently from 1 till S-O. After step 3 we have (S-O) chars left. Can we create just one palindrom using all the even occurances? Yes, simply put everything there.\\n6. Can we create 2 palindroms? Yes, just take out 1 pair from the first palindrom and split it into two character. Keep 1 charecter in the center of first one and put 1 character in the second palindrom. We have 2 palindroms.\\n7. Can we create 3? Yes, just take out the center one(which we just put)from first palindrom and put it on 3rd palindrom.\\n8. Can we create 4? Yes, just take another pair from the first palindrom. Keep one character at the center of first palindrom and put the remaining character on 4th palindrom. \\n\\nJust keep repeating and you can create all 1 to S-O palindroms. So be it any K<=S, the answer is true.\\n\\nPost it in the comments and we can discuss any point again if needed.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int []count = new int[26];\\n        Arrays.fill(count,0);\\n        for(int i=0; i<s.length();i++)\\n            count[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2!=0){\\n                odd++;\\n            }\\n        }\\n        if(odd>k)\\n            return false;\\n        if(s.length()<k)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int []count = new int[26];\\n        Arrays.fill(count,0);\\n        for(int i=0; i<s.length();i++)\\n            count[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2!=0){\\n                odd++;\\n            }\\n        }\\n        if(odd>k)\\n            return false;\\n        if(s.length()<k)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275773,
                "title": "intuitive-and-beginner-o-n-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)return true;\\n        if(s.size()<k)return false;\\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int count=0;\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                count++;\\n            }\\n        }\\n    return count<=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)return true;\\n        if(s.size()<k)return false;\\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int count=0;\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                count++;\\n            }\\n        }\\n    return count<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274302,
                "title": "c-map-and-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for (auto& c : s) ++m[c];\\n        int oddCount = 0, evenSum = 0;\\n        for (auto& [f,s] : m){\\n            if (s % 2 == 1) ++oddCount;\\n            evenSum += s - (s % 2 == 1);\\n        }\\n        if (oddCount > k) return false;\\n        return (k -= evenSum + oddCount) <= 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for (auto& c : s) ++m[c];\\n        int oddCount = 0, evenSum = 0;\\n        for (auto& [f,s] : m){\\n            if (s % 2 == 1) ++oddCount;\\n            evenSum += s - (s % 2 == 1);\\n        }\\n        if (oddCount > k) return false;\\n        return (k -= evenSum + oddCount) <= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260751,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n\\n\\n- Space complexity: 0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(n<k) return false;\\n        unordered_map<char,int>m1;\\n        for(int i=0;i<n;i++){\\n            m1[s[i]]++;\\n        }\\n        int oddcount=0;\\n        for(auto x : m1){\\n            if(x.second%2!=0) oddcount++;\\n        }\\n\\n        if(oddcount>k) return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(n<k) return false;\\n        unordered_map<char,int>m1;\\n        for(int i=0;i<n;i++){\\n            m1[s[i]]++;\\n        }\\n        int oddcount=0;\\n        for(auto x : m1){\\n            if(x.second%2!=0) oddcount++;\\n        }\\n\\n        if(oddcount>k) return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260420,
                "title": "easiest-way-to-construct-k-palindrome-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n if(s.length<k){\\n     return false\\n }  \\nlet freq={};\\n\\nfor(let i=0;i<s.length;i++){\\n    let curr=s[i];\\n    if(freq[curr]){\\n        freq[curr]++\\n    }else{\\n        freq[curr]=1\\n    }\\n}\\nlet count=0\\nlet x=Object.keys(freq);\\nfor(let i=0;i<x.length;i++){\\n    let curr=x[i]\\nif(freq[curr]%2!=0){\\n    count++\\n}\\n}\\nif(count>k){\\n    return false\\n}\\nreturn true\\n \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n if(s.length<k){\\n     return false\\n }  \\nlet freq={};\\n\\nfor(let i=0;i<s.length;i++){\\n    let curr=s[i];\\n    if(freq[curr]){\\n        freq[curr]++\\n    }else{\\n        freq[curr]=1\\n    }\\n}\\nlet count=0\\nlet x=Object.keys(freq);\\nfor(let i=0;i<x.length;i++){\\n    let curr=x[i]\\nif(freq[curr]%2!=0){\\n    count++\\n}\\n}\\nif(count>k){\\n    return false\\n}\\nreturn true\\n \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3251439,
                "title": "c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n=s.size(),arr[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            arr[i]=0;\\n        }\\n        if(n<k)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int count=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if((arr[i]&1)!=0)\\n            {\\n                count++;\\n            }\\n        }\\n        cout<<count<<\" \";\\n        if(k<count)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n=s.size(),arr[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            arr[i]=0;\\n        }\\n        if(n<k)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int count=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if((arr[i]&1)!=0)\\n            {\\n                count++;\\n            }\\n        }\\n        cout<<count<<\" \";\\n        if(k<count)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3242990,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        s.count >= k && s\\n            .reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\\n            .filter { $0.value % 2 == 1 }\\n            .count <= k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        s.count >= k && s\\n            .reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\\n            .filter { $0.value % 2 == 1 }\\n            .count <= k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242367,
                "title": "69ms-python",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        r = k\\n        for i in s: \\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                r -= 1\\n                if r == -1:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        r = k\\n        for i in s: \\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                r -= 1\\n                if r == -1:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240141,
                "title": "greedy-very-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n          if(k > s.length())\\n          return false;\\n          \\n          int evencount=0;\\n          int oddcount = 0;\\n          //we will take the mapping of all the character in the string\\n          unordered_map<char,int>mp;\\n          for(int i=0;i<s.length();i++)\\n          {\\n               mp[s[i]]++;\\n          }    \\n\\n          //counting the even frequncy and odd frequency\\n          for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n          {\\n              if((it->second%2) == 0)\\n              evencount++;\\n              else\\n              oddcount++;\\n          }\\n\\n          if(oddcount > k) return false;\\n          return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n          if(k > s.length())\\n          return false;\\n          \\n          int evencount=0;\\n          int oddcount = 0;\\n          //we will take the mapping of all the character in the string\\n          unordered_map<char,int>mp;\\n          for(int i=0;i<s.length();i++)\\n          {\\n               mp[s[i]]++;\\n          }    \\n\\n          //counting the even frequncy and odd frequency\\n          for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n          {\\n              if((it->second%2) == 0)\\n              evencount++;\\n              else\\n              oddcount++;\\n          }\\n\\n          if(oddcount > k) return false;\\n          return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229777,
                "title": "python-easy-solution-using-dict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s)<k:\\n            return False\\n        \\n        dict=Counter(s)\\n        odd=0\\n        for v in dict:\\n            if dict[v]%2==1:\\n                odd+=1\\n        \\n        return odd<=k\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s)<k:\\n            return False\\n        \\n        dict=Counter(s)\\n        odd=0\\n        for v in dict:\\n            if dict[v]%2==1:\\n                odd+=1\\n        \\n        return odd<=k\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228762,
                "title": "follow-this-one-simple-to-solve-intuition-explained",
                "content": "# Intuition\\n**You just need to keep one rule in mind:-**\\n*If the count of the odd frequencies in the string is greater than k, then it\\'s impossible to form k possible palindromes on that string.*\\n\\n# Approach\\nInsert every char inside hashmap. Now iterate again and count the no.of odd frequencies. Now follow the above rule. \\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // Handling edge cases\\n        if(s.size()==k) return true;\\n        if(k > s.size()) return false;\\n        // Insert every char inside hashmap\\n        unordered_map<char,int> map;\\n        for(char c : s) map[c]++;\\n        // Now count the chars with odd frequency\\n        int freq=0;\\n        for(auto it : map){\\n            if(it.second%2 != 0) \\n                freq++;\\n        }\\n        // Apply the rule for k possible palindromes\\n        if(freq > k) return false;\\n        return true;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // Handling edge cases\\n        if(s.size()==k) return true;\\n        if(k > s.size()) return false;\\n        // Insert every char inside hashmap\\n        unordered_map<char,int> map;\\n        for(char c : s) map[c]++;\\n        // Now count the chars with odd frequency\\n        int freq=0;\\n        for(auto it : map){\\n            if(it.second%2 != 0) \\n                freq++;\\n        }\\n        // Apply the rule for k possible palindromes\\n        if(freq > k) return false;\\n        return true;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219092,
                "title": "odd-palindrome-concept-o-n-character-freq-count",
                "content": "-> There is either an odd palindrome or an even palindrome\\n-> In an even palindrome there are no characters with count as odd\\n-> In an odd palindrome, there is only one character with count as odd\\n-> So, just calculate the count for each character in the substring and find the count of the number of odd-count characters \\n-> if the count of odd count characters is greater than the k then we cannot construct k palindromes from these characters\\n\\nT.C -> O(n + c )     S.C-> O(c),  where c is the number of characters and n is the length of the string\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++)\\n        {\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        int odd = 0;\\n        for(Character key: map.keySet())\\n        {\\n            if(map.get(key) % 2 == 1) odd++;\\n        }\\n        if(odd <= k) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++)\\n        {\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        int odd = 0;\\n        for(Character key: map.keySet())\\n        {\\n            if(map.get(key) % 2 == 1) odd++;\\n        }\\n        if(odd <= k) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213857,
                "title": "c-concise-hashmap-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k)return 0;\\n        if(s.size()==k)return 1;\\n        map<char, int> mp; \\n        for(char x: s)\\n        {\\n            mp[x]++;\\n        }\\n        for(auto &[x,y]: mp)\\n        {\\n            if(y&1) k--;\\n        }\\n        return k>=0?1:0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k)return 0;\\n        if(s.size()==k)return 1;\\n        map<char, int> mp; \\n        for(char x: s)\\n        {\\n            mp[x]++;\\n        }\\n        for(auto &[x,y]: mp)\\n        {\\n            if(y&1) k--;\\n        }\\n        return k>=0?1:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189311,
                "title": "c-short-and-concise-solution-with-explanation-o-n-time-complexity",
                "content": "# Approach\\n1) If size of the s is less than k it obviously cant be divided into k non empty strings so we return false.\\n2) We then make a map of char,int mp.\\n3) We then count the frequencies of letters in the map\\n4) Now we make a integer variable count and initialize them to 0.\\n5) Now we make a for loop in map and for any alphabet if frequency is odd we add it to count\\n6) If the count is lesser than or equal to k we return true (as we can adjust one alphabet in middle of every palindromic subsets that we make)\\n7) Else we return false.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        map<char,int> mp;\\n        for(auto x: s){\\n            mp[x]++;\\n        }\\n        int count=0;\\n        for(auto x: mp){\\n            if(x.second%2) count+=1;\\n        }\\n        if(count<=k) return true;\\n        else return false;\\n    }\\n};\\n//   PLEASE UPVOTE IF THE ANSWER WAS HELPFUL...THANK YOU\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        map<char,int> mp;\\n        for(auto x: s){\\n            mp[x]++;\\n        }\\n        int count=0;\\n        for(auto x: mp){\\n            if(x.second%2) count+=1;\\n        }\\n        if(count<=k) return true;\\n        else return false;\\n    }\\n};\\n//   PLEASE UPVOTE IF THE ANSWER WAS HELPFUL...THANK YOU\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188394,
                "title": "javascript-using-intuition-short",
                "content": "Base cases:\\n- If K > the length of the string, then we definitely can\\'t split it up into smaller pieces (\"ABC\" can\\'t be split into 4 palindromes)\\n- If K === the length of the string, then we can make each character its own palindrome\\n- We are restricted by the amount of odd numbered characters there are, if there are 3 Cs for example (\"AABBCCC\"), then we will either need to make \"C\" it\\'s own palindrome or something like \"ACA\", \"BCB\", \"CCC\".\\n- So first, we create a hashmap of all of the letters and their number of occurences. `AABBCCC` would come out to be `{ A: 2, B: 2, C: 3 }`\\n- Therefore, we can count of the number of odds occurrences there are, because we need at least 1 palindrome K for every odd occurence.\\n- In the above example, we have 1 odd number, so we can do K >= 1 (`ABCCCBA` as an example)\\n- In an example like this: `ABBCCC` we have two odd numbers (`A`, and `C`), therefore we need at least 2 palidromic sequences (`A` + `BCCCB` works. Or `BAB` + `C` + `CC` if K were 3)\\n\\nHope this helps.\\n\\n```\\nvar canConstruct = function(s, k) {\\n    if (k > s.length) return false\\n    if (k === s.length) return true\\n    const letterCount = s.split(\\'\\').reduce((acc,el) => {\\n        if (!acc[el]) acc[el] = 0\\n        acc[el] += 1\\n        return acc\\n    }, {})\\n    const numOdds = Object.values(letterCount).reduce((acc, el) => { if (el % 2 !== 0) return acc + 1; return acc}, 0)\\n    if (k < numOdds) return false\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConstruct = function(s, k) {\\n    if (k > s.length) return false\\n    if (k === s.length) return true\\n    const letterCount = s.split(\\'\\').reduce((acc,el) => {\\n        if (!acc[el]) acc[el] = 0\\n        acc[el] += 1\\n        return acc\\n    }, {})\\n    const numOdds = Object.values(letterCount).reduce((acc, el) => { if (el % 2 !== 0) return acc + 1; return acc}, 0)\\n    if (k < numOdds) return false\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1915408,
                "content": [
                    {
                        "username": "aftab0711",
                        "content": "Easy Trick:\\nEdge case: if( length of s<k) return false;\\n1. Count the frequency of every character.\\n2. Count the number of character whose frequency is odd.\\n3. If no. of odd frequency character > k return false, else return true;"
                    },
                    {
                        "username": "arheops",
                        "content": "Not true. Let say you have string AAAA and need make >4."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why the answer of \"leetcode\" if false why not true and the output could be \"l\"+ \"eee\" + \"t\" + \"c\" + \"o\" + \"d\"? the length of output clearly more than k=3 "
                    },
                    {
                        "username": "Lewis0511",
                        "content": "You need to make exactly k palindromes using all the characters. "
                    }
                ]
            },
            {
                "id": 1934761,
                "content": [
                    {
                        "username": "aftab0711",
                        "content": "Easy Trick:\\nEdge case: if( length of s<k) return false;\\n1. Count the frequency of every character.\\n2. Count the number of character whose frequency is odd.\\n3. If no. of odd frequency character > k return false, else return true;"
                    },
                    {
                        "username": "arheops",
                        "content": "Not true. Let say you have string AAAA and need make >4."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why the answer of \"leetcode\" if false why not true and the output could be \"l\"+ \"eee\" + \"t\" + \"c\" + \"o\" + \"d\"? the length of output clearly more than k=3 "
                    },
                    {
                        "username": "Lewis0511",
                        "content": "You need to make exactly k palindromes using all the characters. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Circle and Rectangle Overlapping",
        "question_content": "<p>You are given a circle represented as <code>(radius, xCenter, yCenter)</code> and an axis-aligned rectangle represented as <code>(x1, y1, x2, y2)</code>, where <code>(x1, y1)</code> are the coordinates of the bottom-left corner, and <code>(x2, y2)</code> are the coordinates of the top-right corner of the rectangle.</p>\n\n<p>Return <code>true</code><em> if the circle and rectangle are overlapped otherwise return </em><code>false</code>. In other words, check if there is <strong>any</strong> point <code>(x<sub>i</sub>, y<sub>i</sub>)</code> that belongs to the circle and the rectangle at the same time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/20/sample_4_1728.png\" style=\"width: 258px; height: 167px;\" />\n<pre>\n<strong>Input:</strong> radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Circle and rectangle share the point (1,0).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/20/sample_2_1728.png\" style=\"width: 150px; height: 135px;\" />\n<pre>\n<strong>Input:</strong> radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= radius &lt;= 2000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= xCenter, yCenter &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x1 &lt; x2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= y1 &lt; y2 &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 563463,
                "title": "c-with-simple-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n---\\n\\nMove the center of the circle to the coordinate origin `(0, 0)`, then this problem becomes \"is there a point `(x, y)` (`x1 <= x <= x2`, `y1 <= y <= y2`) satisfying `x^2 + y^2 <= r^2`\".\\n\\nSo just compute minimum values of `x^2` and `y^2`, then compare the sum with `r^2`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/circle-and-rectangle-overlapping/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        x1 -= x_center; x2 -= x_center;\\n        y1 -= y_center; y2 -= y_center;\\n        int minX = x1 * x2 > 0 ? min(x1*x1, x2*x2) : 0, minY = y1 * y2 > 0 ? min(y1*y1, y2*y2) : 0;\\n        return minY + minX <= radius * radius;\\n    }\\n};\\n```\\n\\n---\\n\\nUpdate: 4/18/2020\\n\\n`minX` is the minimum value of `x^2` where `x1 <= x <= x2`.\\n\\nIf `x1` and `x2` have the same sign, `minX = min(x1*x1, x2*x2)`\\n\\nOtherwise, `minX = 0`.",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/circle-and-rectangle-overlapping/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        x1 -= x_center; x2 -= x_center;\\n        y1 -= y_center; y2 -= y_center;\\n        int minX = x1 * x2 > 0 ? min(x1*x1, x2*x2) : 0, minY = y1 * y2 > 0 ? min(y1*y1, y2*y2) : 0;\\n        return minY + minX <= radius * radius;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563341,
                "title": "4-lines-c-o-1-test-shortest-distance-from-center-to-rect-with-pics",
                "content": "Find the shortest distance from the center to the rect and compare it to the radius.\\n![image](https://assets.leetcode.com/users/kutar7580/image_1586018337.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int edgeX = (x_center < x1) ? x1 : (x_center > x2) ? x2 : x_center;\\n        int edgeY = (y_center < y1) ? y1 : (y_center > y2) ? y2 : y_center;\\n        int distX = x_center - edgeX, distY = y_center - edgeY;\\n        return distX * distX + distY * distY <= radius * radius;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int edgeX = (x_center < x1) ? x1 : (x_center > x2) ? x2 : x_center;\\n        int edgeY = (y_center < y1) ? y1 : (y_center > y2) ? y2 : y_center;\\n        int distX = x_center - edgeX, distY = y_center - edgeY;\\n        return distX * distX + distY * distY <= radius * radius;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563317,
                "title": "c-check-rectangle-border",
                "content": "We first check whether the circle is within the rectangle.\\n\\nIf not, we check whether any point on the ractanble border is within the circle.\\n\\n> Update: see optimizations below.\\n\\n```cpp\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = x1; x <= x2; ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = y1; y <= y2; ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}\\n```\\n\\n**Optimized Solution**\\nSame as above, but limit the border scan within the circle radius.\\n```cpp\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = max(x1, xc - r); x <= min(x2, xc + r); ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = max(y1, yc - r); y <= min(y2, yc + r); ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = x1; x <= x2; ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = y1; y <= y2; ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}\\n```\n```cpp\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = max(x1, xc - r); x <= min(x2, xc + r); ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = max(y1, yc - r); y <= min(y2, yc + r); ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563351,
                "title": "python-o-1-simple-geometry",
                "content": "All relative positions of the intersecting shapes could be decomposed into 3 disjoint groups:\\n1.  a corner of a rectangle is inside the circle\\n2.  one of the edges of the rectangle crosses the circle\\n3.  the circle is completely inside the rectangle\\n\\nIdentifing that a given configuration belongs to one of these cases signifies that the shapes intersect.\\n\\nThough to make our code simpler we will not go for the disjointness of the cases and allow our separate conditions to trigger on some of the same cases, obviously that doesn\\'t sacrifice the corectness of the end result. For example x1<=x_c<=x2 and y1<=y_c<=y2 doesn\\'t only search for the circle inside the rectangle, it could also catch certain cases of the corner inside of the rectangle or an edge crossing the circle, but what is important for us that is does its job of the cathing the former thing. The same applies to the second bullet point.\\n\\nHope that helps!\\nCheers!\\n\\n![image](https://assets.leetcode.com/users/bison_a_besoncon/image_1586079758.png)\\n\\n```\\nclass Solution:\\n    def checkOverlap(self, r, x_c, y_c, x1, y1, x2, y2):\\n        corners = [(x1,y1), (x2,y1), (x2,y2), (x1, y2)]\\n        for (x, y) in corners:\\n            if (x_c - x)**2 + (y_c - y)**2 <= r**2:\\n                return True\\n\\n        for x in [x1, x2]:\\n            if x_c-r <= x <= x_c+r and y1<=y_c<=y2:\\n                return True\\n        for y in [y1, y2]:\\n            if y_c-r <= y <= y_c+r and x1<=x_c<=x2:\\n                return True\\n\\t\\t\\t\\t\\n        if x1<=x_c<=x2 and y1<=y_c<=y2:\\n            return True\\n        return False            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, r, x_c, y_c, x1, y1, x2, y2):\\n        corners = [(x1,y1), (x2,y1), (x2,y2), (x1, y2)]\\n        for (x, y) in corners:\\n            if (x_c - x)**2 + (y_c - y)**2 <= r**2:\\n                return True\\n\\n        for x in [x1, x2]:\\n            if x_c-r <= x <= x_c+r and y1<=y_c<=y2:\\n                return True\\n        for y in [y1, y2]:\\n            if y_c-r <= y <= y_c+r and x1<=x_c<=x2:\\n                return True\\n\\t\\t\\t\\t\\n        if x1<=x_c<=x2 and y1<=y_c<=y2:\\n            return True\\n        return False            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 563391,
                "title": "java-3-lines-super-easy-math-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563319,
                "title": "python-o-1-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n\\t\\t# Getting the coords of centre of rectangle\\n        c1 = (x2 + x1) / 2\\n        c2 = (y2 + y1) / 2\\n        \\n\\t\\t# Getting distance between centre of circle and rectangle in x, y direction\\n\\t\\t# Abs for suppose centre of circle in 3rd quad and of rectangle in 1st quad\\n        v1 = abs(x_center - c1) \\n        v2 = abs(y_center - c2)\\n        \\n\\t\\t# Getting half of breadth and lenght of rectangle\\n        h1 = (x2 - x1) / 2 \\n        h2 = (y2 - y1) / 2\\n         \\n\\t\\t# Difference in distance between (i) half of side of rectangle (h1,h2) (ii) distance between circle and rectangle\\n\\t\\t# It can be negative For eg. If circle is completely in rectangle. Hence taking max with zero\\n        u1 = max(0, v1 - h1)\\n        u2 = max(0, v2 - h2)\\n        \\n\\t\\t# Now try to think yourself for this last step\\n\\t\\t# Hint is hypotenuse !!\\n        return (u1 * u1 + u2 * u2 <= radius * radius)\\n\\n        # Hope you get it :)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n\\t\\t# Getting the coords of centre of rectangle\\n        c1 = (x2 + x1) / 2\\n        c2 = (y2 + y1) / 2\\n        \\n\\t\\t# Getting distance between centre of circle and rectangle in x, y direction\\n\\t\\t# Abs for suppose centre of circle in 3rd quad and of rectangle in 1st quad\\n        v1 = abs(x_center - c1) \\n        v2 = abs(y_center - c2)\\n        \\n\\t\\t# Getting half of breadth and lenght of rectangle\\n        h1 = (x2 - x1) / 2 \\n        h2 = (y2 - y1) / 2\\n         \\n\\t\\t# Difference in distance between (i) half of side of rectangle (h1,h2) (ii) distance between circle and rectangle\\n\\t\\t# It can be negative For eg. If circle is completely in rectangle. Hence taking max with zero\\n        u1 = max(0, v1 - h1)\\n        u2 = max(0, v2 - h2)\\n        \\n\\t\\t# Now try to think yourself for this last step\\n\\t\\t# Hint is hypotenuse !!\\n        return (u1 * u1 + u2 * u2 <= radius * radius)\\n\\n        # Hope you get it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563572,
                "title": "java-detailed-explanation-with-graphs",
                "content": "I split it into three different situation:\\n\\n1. The vertex/vertices of the rectangle is inside the circle.\\nIn this situation, given the vertex(x,y) and the circle (radius, x_center, y_center), \\nif `(x - x_center)^2 + (y - y_center)^2 <=radius^2`\\nthen the vertex is inside the circle. Check if four vertices of the rectangle is inside the circle.\\n![image](https://assets.leetcode.com/users/jj-zhang/image_1586021433.png)\\n\\n2. An edge of the rectangle intersects the circle.\\nIn this situation, given the edge (x) and the circle (radius, x_center, y_center),\\nif `radius^2 >= (distance between center point and line) ^ 2`\\nthen the edge intersects the circle.\\n![image](https://assets.leetcode.com/users/jj-zhang/image_1586021470.png)\\n![image](https://assets.leetcode.com/users/jj-zhang/image_1586021485.png)\\nNote that it\\'s necessary to check whether is center point is within the range of the rectangle, or there would be some situation like this.\\n![image](https://assets.leetcode.com/users/jj-zhang/image_1586021525.png)\\n\\n3. The circle is inside the rectangle.\\nIn this situation, we can just check whether **four points**`x_left`,`x_right`,`y_top`, `y_bottom` is inside the rectangle.\\n![image](https://assets.leetcode.com/users/jj-zhang/image_1586021453.png)\\n\\nHere is my Java Code.\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int d_x1 = x_center - x1;\\n        int d_x2 = x_center - x2;\\n        int d_y1 = y_center - y1;\\n        int d_y2 = y_center - y2;\\n        int square = radius * radius;\\n        int x_top = x_center + radius;\\n        int x_bottom = x_center - radius;\\n        int y_top = y_center + radius;\\n        int y_bottom = y_center - radius;\\n        boolean insideX = (x_center >= x1) && (x_center <= x2);\\n        boolean insideY = (y_center >= y1) && (y_center <= y2);\\n        \\n        if ((d_x1 * d_x1 + d_y1 * d_y1 <= square) || (d_x2 * d_x2 + d_y1 * d_y1 <= square) || (d_x1 * d_x1 + d_y2 * d_y2 <= square) || (d_x2 * d_x2 + d_y2 * d_y2 <= square)) {\\n            return true;\\n        }\\n        if (((square - d_x1 * d_x1 >= 0) && insideY) || ((square - d_x2 * d_x2 >= 0) && insideY) || ((square - d_y1 * d_y1 >= 0) && insideX) || ((square - d_y2 * d_y2 >= 0) && insideX)) {\\n            return true;\\n        }\\n        // Circle inside the square.\\n        if ((x_top <= x2) && (x_bottom >= x1) && (y2 >= y_top) && (y1 <= y_bottom)) return true;\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int d_x1 = x_center - x1;\\n        int d_x2 = x_center - x2;\\n        int d_y1 = y_center - y1;\\n        int d_y2 = y_center - y2;\\n        int square = radius * radius;\\n        int x_top = x_center + radius;\\n        int x_bottom = x_center - radius;\\n        int y_top = y_center + radius;\\n        int y_bottom = y_center - radius;\\n        boolean insideX = (x_center >= x1) && (x_center <= x2);\\n        boolean insideY = (y_center >= y1) && (y_center <= y2);\\n        \\n        if ((d_x1 * d_x1 + d_y1 * d_y1 <= square) || (d_x2 * d_x2 + d_y1 * d_y1 <= square) || (d_x1 * d_x1 + d_y2 * d_y2 <= square) || (d_x2 * d_x2 + d_y2 * d_y2 <= square)) {\\n            return true;\\n        }\\n        if (((square - d_x1 * d_x1 >= 0) && insideY) || ((square - d_x2 * d_x2 >= 0) && insideY) || ((square - d_y1 * d_y1 >= 0) && insideX) || ((square - d_y2 * d_y2 >= 0) && insideX)) {\\n            return true;\\n        }\\n        // Circle inside the square.\\n        if ((x_top <= x2) && (x_bottom >= x1) && (y2 >= y_top) && (y1 <= y_bottom)) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563458,
                "title": "c-3-lines-math-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int dx = x_center - max(x1, min(x_center, x2));\\n        int dy = y_center - max(y1, min(y_center, y2));\\n        return (dx * dx + dy * dy) <= (radius * radius);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int dx = x_center - max(x1, min(x_center, x2));\\n        int dy = y_center - max(y1, min(y_center, y2));\\n        return (dx * dx + dy * dy) <= (radius * radius);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565206,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, rx: int, ry: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (rx - min(max(x1, rx), x2)) ** 2 + (ry - min(max(y1, ry), y2)) ** 2 <= r ** 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, rx: int, ry: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (rx - min(max(x1, rx), x2)) ** 2 + (ry - min(max(y1, ry), y2)) ** 2 <= r ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911047,
                "title": "c-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int sqr(int x) {\\n        return x*x;\\n    }\\n    \\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int x = max(x1, min(xCenter, x2));\\n        int y = max(y1, min(yCenter, y2));\\n        \\n        if (sqr(x-xCenter) + sqr(y-yCenter) <= sqr(radius)) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n**I have drawn a figure to understand all cases easily. Have a look and upvote if you like it.**\\n\\n![image](https://assets.leetcode.com/users/images/8fe8036b-6ad0-4866-b539-30d9ed5d825a_1649000365.6651344.png)\\n",
                "solutionTags": [
                    "C",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sqr(int x) {\\n        return x*x;\\n    }\\n    \\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int x = max(x1, min(xCenter, x2));\\n        int y = max(y1, min(yCenter, y2));\\n        \\n        if (sqr(x-xCenter) + sqr(y-yCenter) <= sqr(radius)) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194137,
                "title": "simple-3-line-c-only-integer-calculations-100-100",
                "content": "```x = clamp(x_center, x1, x2)``` and ```y = clamp(y_center, y1, y2)``` get the closest point (x, y) from the circle on the rectangle. Then I calculate lenght of the line between circle\\'s center and our just computed point, and compare it to circle\\'s radius.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) {\\n        x = std::clamp(x, x1, x2) - x;\\n        y = std::clamp(y, y1, y2) - y;\\n        return x * x + y * y <= r * r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```x = clamp(x_center, x1, x2)```\n```y = clamp(y_center, y1, y2)```\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) {\\n        x = std::clamp(x, x1, x2) - x;\\n        y = std::clamp(y, y1, y2) - y;\\n        return x * x + y * y <= r * r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025150,
                "title": "python-o-1-solution-with-explaination-and-derivation",
                "content": "```\\nclass Solution(object):\\n    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):\\n        \"\"\"\\n        :type radius: int\\n        :type x_center: int\\n        :type y_center: int\\n        :type x1: int\\n        :type y1: int\\n        :type x2: int\\n        :type y2: int\\n        :rtype: bool\\n        \"\"\"\\n        # equations:\\n        # for a point (x, y) to be inside the circle, it has to satisfy the following:\\n        # 1. (x - x_center) ^ 2 + (y - y_center) ^ 2 <= radius ^ 2\\n        # for a point (x, y) to be inside the rectangle, it has to satisfy the following:\\n        # 2. x1 <= x <= x2\\n        # 3. y1 <= y <= y2\\n\\n        # For a O(1) solution, we need to find the point in the rectangle that\\'s closest to the center of the circle, \\n\\t\\t# and verify that the distance from that point to the circle\\'s center is less than the radius. \\n\\t\\t\\n        # In other words, find the x in [x1, x2] such that the value of (x - x_center) ^ 2 is minimized. \\n\\t\\t\\n\\t\\t# It should be apparent to the reader that if x_center is within [x1, x2] the minimal value should be 0, \\n\\t\\t# else we just need to test the two boundary value x1 and x2 and use the smallest.\\n\\t\\t\\n        # repeat the same for y\\n\\t\\t\\n        # Finally we can use above (x,y) to check against equation 1.\\n\\n        min_x_distance = self.find_min(x1, x2, x_center)\\n        min_y_distance = self.find_min(y1, y2, y_center)\\n        return min_y_distance + min_x_distance <= radius * radius\\n    \\n    def find_min(self, lower_bound, upper_bound, point):\\n        if point < lower_bound:\\n            return (lower_bound - point) ** 2\\n        if point > upper_bound:\\n            return (upper_bound - point) ** 2\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):\\n        \"\"\"\\n        :type radius: int\\n        :type x_center: int\\n        :type y_center: int\\n        :type x1: int\\n        :type y1: int\\n        :type x2: int\\n        :type y2: int\\n        :rtype: bool\\n        \"\"\"\\n        # equations:\\n        # for a point (x, y) to be inside the circle, it has to satisfy the following:\\n        # 1. (x - x_center) ^ 2 + (y - y_center) ^ 2 <= radius ^ 2\\n        # for a point (x, y) to be inside the rectangle, it has to satisfy the following:\\n        # 2. x1 <= x <= x2\\n        # 3. y1 <= y <= y2\\n\\n        # For a O(1) solution, we need to find the point in the rectangle that\\'s closest to the center of the circle, \\n\\t\\t# and verify that the distance from that point to the circle\\'s center is less than the radius. \\n\\t\\t\\n        # In other words, find the x in [x1, x2] such that the value of (x - x_center) ^ 2 is minimized. \\n\\t\\t\\n\\t\\t# It should be apparent to the reader that if x_center is within [x1, x2] the minimal value should be 0, \\n\\t\\t# else we just need to test the two boundary value x1 and x2 and use the smallest.\\n\\t\\t\\n        # repeat the same for y\\n\\t\\t\\n        # Finally we can use above (x,y) to check against equation 1.\\n\\n        min_x_distance = self.find_min(x1, x2, x_center)\\n        min_y_distance = self.find_min(y1, y2, y_center)\\n        return min_y_distance + min_x_distance <= radius * radius\\n    \\n    def find_min(self, lower_bound, upper_bound, point):\\n        if point < lower_bound:\\n            return (lower_bound - point) ** 2\\n        if point > upper_bound:\\n            return (upper_bound - point) ** 2\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895200,
                "title": "circle-and-rectangle-overlapping",
                "content": "```\\nwe know the equation of circle (x-c1)^2+(y-c2)^2=r^2\\nx1<=i<=x2\\ny1<=j<=y2\\nif((i-c1)^2+(j-c2)^2<=r*r)\\n   -> means that if (i,j) belongs to circle means that it touches or intersects the circle.\\n```\\n```\\nclass Solution \\n{\\n public:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n    {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n           for(int j=y1;j<=y2;j++)\\n           {\\n              int c1=i-x;\\n              int c2=j-y;\\n              if(c1*c1+c2*c2<=r*r)\\n                  return 1;\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Geometry"
                ],
                "code": "```\\nwe know the equation of circle (x-c1)^2+(y-c2)^2=r^2\\nx1<=i<=x2\\ny1<=j<=y2\\nif((i-c1)^2+(j-c2)^2<=r*r)\\n   -> means that if (i,j) belongs to circle means that it touches or intersects the circle.\\n```\n```\\nclass Solution \\n{\\n public:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n    {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n           for(int j=y1;j<=y2;j++)\\n           {\\n              int c1=i-x;\\n              int c2=j-y;\\n              if(c1*c1+c2*c2<=r*r)\\n                  return 1;\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735247,
                "title": "c-easy-to-understand-simple-solution-shifting-center-to-origin",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        x1-=xCenter;\\n        x2-=xCenter;\\n        y1-=yCenter;\\n        y2-=yCenter;\\n        int minX,minY;\\n        if(x1*x2>0)\\n            minX=min(x1*x1,x2*x2);\\n        else\\n            minX=0;\\n        if(y1*y2>0)\\n            minY=min(y1*y1,y2*y2);\\n        else\\n            minY=0;\\n        return minX+minY<=radius*radius;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        x1-=xCenter;\\n        x2-=xCenter;\\n        y1-=yCenter;\\n        y2-=yCenter;\\n        int minX,minY;\\n        if(x1*x2>0)\\n            minX=min(x1*x1,x2*x2);\\n        else\\n            minX=0;\\n        if(y1*y2>0)\\n            minY=min(y1*y1,y2*y2);\\n        else\\n            minY=0;\\n        return minX+minY<=radius*radius;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688824,
                "title": "c-beats-100-speed-and-space",
                "content": "```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n    int tx = x_center;\\n    int ty = y_center;\\n    \\n    \\n    if(x_center<x1) tx = x1; // left\\n    else if(x_center>x2) tx = x2; //right\\n    else tx = x_center; // between y1 and y2\\n    if(y_center<y1) ty = y1; //bottom\\n    else if(y_center>y2) ty = y2; //top\\n    else ty = y_center; //between x1 and x2\\n    \\n    \\n    int disx = x_center - tx;  \\n    int disy = y_center - ty;\\n    int distance = sqrt((disx * disx) + (disy * disy)); //distance formula\\n    \\n    \\n    return distance <= radius;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n    int tx = x_center;\\n    int ty = y_center;\\n    \\n    \\n    if(x_center<x1) tx = x1; // left\\n    else if(x_center>x2) tx = x2; //right\\n    else tx = x_center; // between y1 and y2\\n    if(y_center<y1) ty = y1; //bottom\\n    else if(y_center>y2) ty = y2; //top\\n    else ty = y_center; //between x1 and x2\\n    \\n    \\n    int disx = x_center - tx;  \\n    int disy = y_center - ty;\\n    int distance = sqrt((disx * disx) + (disy * disy)); //distance formula\\n    \\n    \\n    return distance <= radius;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563452,
                "title": "the-smart-brute-force-solution",
                "content": "I noticed that if the rectangle and circle were to overlap, it could only happen at a limited number of x and y coordinates. So instead of trying to figure out exactly which ones, let\\'s just test every possible combination of those x and y coordinates, and check if there are any that are both in the circle and the rectangle.\\n\\n\\n```\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int[] all_x = {x1, x2, x_center, x_center + radius, x_center-radius}; \\n        int[] all_y = {y1, y2, y_center, y_center + radius, y_center-radius};\\n        \\n        for(int x: all_x){\\n            for(int y: all_y){\\n                if(checkInRectangle(x,y,x1, y1, x2, y2) && checkInCircle(x,y, radius, x_center, y_center)) return true;\\n            }\\n        }\\n        return false;\\n\\t}\\n    private boolean checkInCircle(int px, int py, int radius, int x_center, int y_center) {\\n        return Math.sqrt((px-x_center)*(px-x_center) + (py-y_center)*(py-y_center)) <= radius;\\n    }\\n    \\n    private boolean checkInRectangle(int px, int py, int x1, int y1, int x2, int y2) {\\n        return px >= x1 && px <= x2 && py >= y1 && py <= y2;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int[] all_x = {x1, x2, x_center, x_center + radius, x_center-radius}; \\n        int[] all_y = {y1, y2, y_center, y_center + radius, y_center-radius};\\n        \\n        for(int x: all_x){\\n            for(int y: all_y){\\n                if(checkInRectangle(x,y,x1, y1, x2, y2) && checkInCircle(x,y, radius, x_center, y_center)) return true;\\n            }\\n        }\\n        return false;\\n\\t}\\n    private boolean checkInCircle(int px, int py, int radius, int x_center, int y_center) {\\n        return Math.sqrt((px-x_center)*(px-x_center) + (py-y_center)*(py-y_center)) <= radius;\\n    }\\n    \\n    private boolean checkInRectangle(int px, int py, int x1, int y1, int x2, int y2) {\\n        return px >= x1 && px <= x2 && py >= y1 && py <= y2;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563432,
                "title": "swift-math-geometry-solution",
                "content": "```\\nclass Solution {\\n    func checkOverlap(_ radius: Int, _ x_center: Int, _ y_center: Int, _ left: Int, _ bottom: Int, _ right: Int, _ top: Int) -> Bool {\\n        let recW = Double(right - left)\\n        let recH = Double(top - bottom)\\n        let recx = Double(right + left) / 2\\n        let recy = Double(top + bottom) / 2\\n        \\n        // distance between rectange\\'s center and circle\\'s center\\n        let dx = abs(Double(x_center) - Double(recx))\\n        let dy = abs(Double(y_center) - Double(recy))\\n        \\n        if dx > recW/2 + Double(radius) { return false }\\n        if dy > recH/2 + Double(radius) { return false }\\n        if dx <= recW/2 { return true }\\n        if dy <= recH/2 { return true }\\n                     \\n        let sq = ((dx - recW/2) * (dx - recW/2) + (dy - recH/2) * (dy - recH/2))\\n        return (Double(radius) * Double(radius)) >= sq\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    func checkOverlap(_ radius: Int, _ x_center: Int, _ y_center: Int, _ left: Int, _ bottom: Int, _ right: Int, _ top: Int) -> Bool {\\n        let recW = Double(right - left)\\n        let recH = Double(top - bottom)\\n        let recx = Double(right + left) / 2\\n        let recy = Double(top + bottom) / 2\\n        \\n        // distance between rectange\\'s center and circle\\'s center\\n        let dx = abs(Double(x_center) - Double(recx))\\n        let dy = abs(Double(y_center) - Double(recy))\\n        \\n        if dx > recW/2 + Double(radius) { return false }\\n        if dy > recH/2 + Double(radius) { return false }\\n        if dx <= recW/2 { return true }\\n        if dy <= recH/2 { return true }\\n                     \\n        let sq = ((dx - recW/2) * (dx - recW/2) + (dy - recH/2) * (dy - recH/2))\\n        return (Double(radius) * Double(radius)) >= sq\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882948,
                "title": "solution-for-leetcode-problem-1401-circle-and-rectangle-overlapping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->The idea behind this approach is to find the closest point on the rectangle to the center of the circle. If the distance between this closest point and the center of the circle is less than or equal to the radius of the circle, then the circle and rectangle overlap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the closest point on the rectangle to the center of the circle. This can be done by finding the coordinates (closestX, closestY) where closestX is the maximum of x1 and the minimum of xCenter and x2, and closestY is the maximum of y1 and the minimum of yCenter and y2.\\n\\nCalculate the distance between the closest point (closestX, closestY) and the center of the circle (xCenter, yCenter) using the differences in x and y coordinates: distanceX = xCenter - closestX and distanceY = yCenter - closestY.\\n\\nCalculate the squared distance between the closest point and the center of the circle: squaredDistance = distanceX * distanceX + distanceY * distanceY.\\n\\nCompare the squared distance with the squared radius of the circle. If squaredDistance is less than or equal to radius * radius, then there is an overlap; otherwise, there is no overlap.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe calculations involved in finding the closest point, distance, and squared distance are constant-time operations. Therefore, the time complexity of this approach is O(1), or constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe algorithm uses a few integer variables to store intermediate results. These variables do not scale with input size, so the space complexity remains O(1), or constant space.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n                // Calculate the closest point on the rectangle to the center of the circle\\n        int closestX = Math.max(x1, Math.min(xCenter, x2));\\n        int closestY = Math.max(y1, Math.min(yCenter, y2));\\n        \\n        // Calculate the distance between the closest point and the center of the circle\\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        \\n        // Calculate the squared distance\\n        int squaredDistance = distanceX * distanceX + distanceY * distanceY;\\n        \\n        // Compare the squared distance with the squared radius\\n        return squaredDistance <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n                // Calculate the closest point on the rectangle to the center of the circle\\n        int closestX = Math.max(x1, Math.min(xCenter, x2));\\n        int closestY = Math.max(y1, Math.min(yCenter, y2));\\n        \\n        // Calculate the distance between the closest point and the center of the circle\\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        \\n        // Calculate the squared distance\\n        int squaredDistance = distanceX * distanceX + distanceY * distanceY;\\n        \\n        // Compare the squared distance with the squared radius\\n        return squaredDistance <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194118,
                "title": "binary-search-0ms-different-solution-explained",
                "content": "I know this might look like an overkill but for the fellow coders who couldn\\'t quickly come up with the mathematical solution like me!!\\n\\n[I mean, if you can make the machine do the hard work, why not? Right??]\\n\\n# Intuition\\n\\n1. Find the center of the rectangle.\\n2. This divides the rectangle into 4 smaller non-overlapping rectangles.\\n3. Check if center is inside the circle.\\n4. This can be checked mathematically by substituting the point in the circle equation and if it\\'s less than or equal to the radius, we have the answer.\\n5. Else, find the corner of the rectangle that\\'s closest to the center of the circle.\\n6. Now we have a smaller rectangle, 1/4th the area of the earlier, formed by the center in step 2 and the corner in step 5.\\n7. Loop until rectangle becomes A POINT. :)\\n\\nThis algorithm quickly converges to an answer - hence 0ms.\\n\\nThis can be done in like 14 lines of code.\\nCode is well commented to describe the above idea further.\\n\\n# Complexity\\n- Time complexity:\\n\\nlog_base_4(area_of_rectangle)\\n\\nNot to the base 2 as in binary search - since we chose the closest rectangle to the circle center - from amongst the 4 at a time.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nbool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) const noexcept\\n{\\n    // If returned value is less than or equal to zero\\n    // <x,y> is inside or on the circle.\\n    // Also, larger the returned value further that point is away\\n    // from the center of the circle.\\n    auto in_or_out_circle = [=](int x, int y) noexcept -> int\\n    {\\n        return (x-xCenter)*(x-xCenter) +\\n               (y-yCenter)*(y-yCenter) -\\n               radius*radius;\\n    };\\n\\n    while(x1 != x2 || y1 != y2)\\n    {\\n        // finding the center of the rectangle creating 4 new\\n        // smaller rectangles for us to work with.\\n        auto const center_x = x1 + (x2 - x1)/2;\\n        auto const center_y = y1 + (y2 - y1)/2;\\n\\n        if(in_or_out_circle(center_x, center_y) <= 0) return true;\\n\\n        auto min = std::numeric_limits<int>::max();\\n        for(auto [corner_x, corner_y] : {std::pair{x1,y1},\\n                                         std::pair{x1,y2},\\n                                         std::pair{x2,y1},\\n                                         std::pair{x2,y2}})\\n        {\\n             // find the closest corner to circle-center inorder\\n             // to choose the smaller rectangle of interest\\n            auto const val = in_or_out_circle(corner_x, corner_y);\\n            if(val < min)\\n            {\\n                x1 = corner_x;\\n                y1 = corner_y;\\n                min = val;\\n            }\\n        }\\n        // Prior center becomes the new corner of the\\n        // smaller selected rectangle\\n        x2 = center_x;\\n        y2 = center_y;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nbool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) const noexcept\\n{\\n    // If returned value is less than or equal to zero\\n    // <x,y> is inside or on the circle.\\n    // Also, larger the returned value further that point is away\\n    // from the center of the circle.\\n    auto in_or_out_circle = [=](int x, int y) noexcept -> int\\n    {\\n        return (x-xCenter)*(x-xCenter) +\\n               (y-yCenter)*(y-yCenter) -\\n               radius*radius;\\n    };\\n\\n    while(x1 != x2 || y1 != y2)\\n    {\\n        // finding the center of the rectangle creating 4 new\\n        // smaller rectangles for us to work with.\\n        auto const center_x = x1 + (x2 - x1)/2;\\n        auto const center_y = y1 + (y2 - y1)/2;\\n\\n        if(in_or_out_circle(center_x, center_y) <= 0) return true;\\n\\n        auto min = std::numeric_limits<int>::max();\\n        for(auto [corner_x, corner_y] : {std::pair{x1,y1},\\n                                         std::pair{x1,y2},\\n                                         std::pair{x2,y1},\\n                                         std::pair{x2,y2}})\\n        {\\n             // find the closest corner to circle-center inorder\\n             // to choose the smaller rectangle of interest\\n            auto const val = in_or_out_circle(corner_x, corner_y);\\n            if(val < min)\\n            {\\n                x1 = corner_x;\\n                y1 = corner_y;\\n                min = val;\\n            }\\n        }\\n        // Prior center becomes the new corner of the\\n        // smaller selected rectangle\\n        x2 = center_x;\\n        y2 = center_y;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1142484,
                "title": "simple-4-line-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        //Applying the pythagoras theorem for calculating the distance between the pts to know //which pts lies with circlce\\n        for(int i=x1;i<=x2;i++){\\n            for(int j=y1;j<=y2;j++){\\n                if(sqrt(pow((x_center-i),2)+pow(y_center-j,2))<=radius)\\n                    return true;\\n            }\\n        }\\n        return false;\\n     }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        //Applying the pythagoras theorem for calculating the distance between the pts to know //which pts lies with circlce\\n        for(int i=x1;i<=x2;i++){\\n            for(int j=y1;j<=y2;j++){\\n                if(sqrt(pow((x_center-i),2)+pow(y_center-j,2))<=radius)\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 868820,
                "title": "my-java-solution-with-comments",
                "content": "```\\n/*\\n-> (y <= y2 && y >= y1): the two horizontal lines are at different sides of the circle center\\n\\n-> Math.min(Math.abs(y1 - y), Math.abs(y2 - y)): the distance between the horizontal line and the circle center. (There are two such distances. Take the smaller one.)\\n\\n-> (x >= x1 && x <= x2): the two vertical lines are at different sides of the circle center\\n\\n-> Math.min(Math.abs(x1 - x), Math.abs(x2 - x)): the distance between the vertical line and the circle center. (There are two such distances. Take the smaller one.)\\n\\n->The 0 after ?: if the two lines are at different sides, at the return line we will check only the other value (i.e. the value calculated from the other two lines)\\n\\n-> xx * xx + yy * yy <= radius * radius:\\n\\n(a) if xx == 0 and yy==0, that means circle center is in the rectangle\\n(b) if only one of xx and yy is zero, that means we want to check the distance between circle center and the line that is closest to the circle center.\\n(c) if both xx and yy are not zero, that means we want to check the distance between circle center and the rectangle corner that is closest to the circle center.\\n\\n*/\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int y = (y2 >= y_center && y1 <= y_center) ? 0 : Math.min(Math.abs(y2 - y_center), Math.abs(y1-y_center));\\n        int x = (x2 >= x_center && x1 <= x_center) ? 0 : Math.min(Math.abs(x2 - x_center), Math.abs(x1 - x_center));\\n        if (x * x + y*y <= radius * radius)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n/*\\n-> (y <= y2 && y >= y1): the two horizontal lines are at different sides of the circle center\\n\\n-> Math.min(Math.abs(y1 - y), Math.abs(y2 - y)): the distance between the horizontal line and the circle center. (There are two such distances. Take the smaller one.)\\n\\n-> (x >= x1 && x <= x2): the two vertical lines are at different sides of the circle center\\n\\n-> Math.min(Math.abs(x1 - x), Math.abs(x2 - x)): the distance between the vertical line and the circle center. (There are two such distances. Take the smaller one.)\\n\\n->The 0 after ?: if the two lines are at different sides, at the return line we will check only the other value (i.e. the value calculated from the other two lines)\\n\\n-> xx * xx + yy * yy <= radius * radius:\\n\\n(a) if xx == 0 and yy==0, that means circle center is in the rectangle\\n(b) if only one of xx and yy is zero, that means we want to check the distance between circle center and the line that is closest to the circle center.\\n(c) if both xx and yy are not zero, that means we want to check the distance between circle center and the rectangle corner that is closest to the circle center.\\n\\n*/\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int y = (y2 >= y_center && y1 <= y_center) ? 0 : Math.min(Math.abs(y2 - y_center), Math.abs(y1-y_center));\\n        int x = (x2 >= x_center && x1 <= x_center) ? 0 : Math.min(Math.abs(x2 - x_center), Math.abs(x1 - x_center));\\n        if (x * x + y*y <= radius * radius)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639682,
                "title": "python3-two-solutions-circle-and-rectangle-overlapping",
                "content": "First, check if the nearest point is in the circle. For either dimension, if the center is in between the points, only consider the other dimension.\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        x = 0 if x1 <= x_center <= x2 else min(abs(x1-x_center), abs(x2-x_center))\\n        y = 0 if y1 <= y_center <= y2 else min(abs(y1-y_center), abs(y2-y_center))\\n        return x**2 + y**2 <= radius**2\\n```\\nThe second one is more self explanatory:\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def pointInCircle(p, center):\\n            nonlocal radius\\n            xr, yr = center\\n            x, y = p\\n            return  abs(x-xr)**2 + abs(y-yr)**2 <= radius**2\\n        \\n        def segmentOverlaps(s1, s2):\\n            return max(s1[0], s2[0]) <= min(s1[1], s2[1])\\n        \\n        if any(pointInCircle(p, (x_center, y_center))\\n               for p in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]):\\n            return True\\n        \\n        if (not segmentOverlaps([x_center - radius, x_center + radius], sorted([x1, x2])) or\\n            not segmentOverlaps([y_center - radius, y_center + radius], sorted([y1, y2]))):\\n            return False\\n        \\n        return x1 <= x_center <= x2 or y1 <= y_center <= y2\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        x = 0 if x1 <= x_center <= x2 else min(abs(x1-x_center), abs(x2-x_center))\\n        y = 0 if y1 <= y_center <= y2 else min(abs(y1-y_center), abs(y2-y_center))\\n        return x**2 + y**2 <= radius**2\\n```\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def pointInCircle(p, center):\\n            nonlocal radius\\n            xr, yr = center\\n            x, y = p\\n            return  abs(x-xr)**2 + abs(y-yr)**2 <= radius**2\\n        \\n        def segmentOverlaps(s1, s2):\\n            return max(s1[0], s2[0]) <= min(s1[1], s2[1])\\n        \\n        if any(pointInCircle(p, (x_center, y_center))\\n               for p in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]):\\n            return True\\n        \\n        if (not segmentOverlaps([x_center - radius, x_center + radius], sorted([x1, x2])) or\\n            not segmentOverlaps([y_center - radius, y_center + radius], sorted([y1, y2]))):\\n            return False\\n        \\n        return x1 <= x_center <= x2 or y1 <= y_center <= y2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586145,
                "title": "clear-python-solution",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n      # check if center in rectangle\\n      if x_center in range(x1, x2 + 1) and y_center in range(y1, y2 + 1):\\n        return True\\n      \\n      # check a point from each edge and see if it is within radius of circle\\n      \\'\\'\\'\\n       x1,y2--------------+x2,y2\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       +------------------+x2,y1\\n     x1,y1\\n\\n      \\'\\'\\'\\n      def within_radius(x,y):\\n        return (x_center - x)*(x_center - x) + (y_center - y)*(y_center - y) <= r*r\\n      \\n      for x in range(x1, x2+1):\\n        if within_radius(x, y1) or within_radius(x, y2):\\n          return True\\n      \\n      for y in range(y1, y2+1):\\n        if within_radius(x1, y) or within_radius(x2, y):\\n          return True\\n      \\n      return False\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n      # check if center in rectangle\\n      if x_center in range(x1, x2 + 1) and y_center in range(y1, y2 + 1):\\n        return True\\n      \\n      # check a point from each edge and see if it is within radius of circle\\n      \\'\\'\\'\\n       x1,y2--------------+x2,y2\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       +------------------+x2,y1\\n     x1,y1\\n\\n      \\'\\'\\'\\n      def within_radius(x,y):\\n        return (x_center - x)*(x_center - x) + (y_center - y)*(y_center - y) <= r*r\\n      \\n      for x in range(x1, x2+1):\\n        if within_radius(x, y1) or within_radius(x, y2):\\n          return True\\n      \\n      for y in range(y1, y2+1):\\n        if within_radius(x1, y) or within_radius(x2, y):\\n          return True\\n      \\n      return False\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 580034,
                "title": "python-explanation-with-figures",
                "content": "There are essentially 2 possible cases when the intersection occurs.\\n**Case 1:** The side of the rectangle touches or intersects the circle\\n![image](https://assets.leetcode.com/users/sheel93/image_1586909135.png)\\n\\n**Case 2:** The center of the circle lies inside the rectangle\\n![image](https://assets.leetcode.com/users/sheel93/image_1586909163.png)\\n\\nTo test whether the shapes intersect, we need to find a point on or inside the rectangle that is closest to the center of the circle. If this point lies on or inside the circle, it is guaranteed that both the shapes intersect. Let the closest point be denoted by `(x_nearest, y_nearest)`. Then the  distance between the closest point and the center of the circle can be found using `((x_center - x_nearest)^2 + (y_center - y_nearest)^2)^0.5`. If this distance <= radius of the circle, the two shapes intersect. \\n\\nOn close inspection it can be observed that the point of interest only depends on the locations of `(x1, y1)` and `(x2, y2)` relative to `(x_center, y_center)`.  \\n\\nIn case 1, the x-coordinate of the closest point will either be `x1`, `x2`, or `x_center` and the y-coordinate will be one among `y1`, `y2`, and `y_center`.  \\n\\nIn case 2, since the center of the circle lies inside the rectangle, the closest point will be `(x_center, y_center)`.  \\n\\nThe closest point in both the cases can be calculated using the following expressions:  \\n`x_nearest = max(x1, min(x_center, x2))`\\n`y_nearest = max(y1, min(y_center, y2))`\\n\\n```Python\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool: \\n        # Find the nearest point on the rectangle to the center of the circle\\n        x_nearest = max(x1, min(x_center, x2))\\n        y_nearest = max(y1, min(y_center, y2))\\n        \\n        # Find the distance between the nearest point and the center of the circle\\n        # Distance between 2 points, (x1,y1) & (x2,y2) in 2D Euclidean space = ((x1-x2)**2 + (y1-y2)**2)**0.5\\n        distance_x = x_nearest - x_center\\n        distance_y = y_nearest - y_center\\n        return (distance_x**2 + distance_y**2) <= radius**2\\n    \\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool: \\n        # Find the nearest point on the rectangle to the center of the circle\\n        x_nearest = max(x1, min(x_center, x2))\\n        y_nearest = max(y1, min(y_center, y2))\\n        \\n        # Find the distance between the nearest point and the center of the circle\\n        # Distance between 2 points, (x1,y1) & (x2,y2) in 2D Euclidean space = ((x1-x2)**2 + (y1-y2)**2)**0.5\\n        distance_x = x_nearest - x_center\\n        distance_y = y_nearest - y_center\\n        return (distance_x**2 + distance_y**2) <= radius**2\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 563484,
                "title": "c-check-if-any-point-in-the-rectangle-falls-inside-the-circle",
                "content": "This problem can be easily solved by checking if any of the point inside the area of the rectangle falls inside the area of the circle.\\nUsing the equation of the circle, **if any point (x, y) lies inside the the circle, then it should satisfy the following equation:**\\n\\n***(x\\' - x)^2 + (y\\' - y)^2 <= r^2***\\nwhere, (x\\', y\\') is the center of the circle, and r is the radius of the circle\\n\\nThe function implementation of the above formula would be:\\n\\n```\\nbool computeFormula(int radius, int x_center, int y_center, int x, int y)\\n    {\\n        float r = pow(x-x_center, 2) + pow(y-y_center, 2);\\n        if(r <= pow(radius, 2))\\n            return true;\\n        \\n        return false;\\n    }\\n```\\n\\nIterating through all the points in the area of the rectangle, **if any of the point touches the circumference of the circle or falls inside the circle**, then the rectangle and the circle overlap.\\n\\n```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for(int i = x1;i <= x2;i++)\\n        {\\n            for(int j = y1;j <= y2;j++)\\n            {\\n                if(computeFormula(radius, x_center, y_center, i, j))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Geometry"
                ],
                "code": "```\\nbool computeFormula(int radius, int x_center, int y_center, int x, int y)\\n    {\\n        float r = pow(x-x_center, 2) + pow(y-y_center, 2);\\n        if(r <= pow(radius, 2))\\n            return true;\\n        \\n        return false;\\n    }\\n```\n```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for(int i = x1;i <= x2;i++)\\n        {\\n            for(int j = y1;j <= y2;j++)\\n            {\\n                if(computeFormula(radius, x_center, y_center, i, j))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3699442,
                "title": "c-distance-between-the-two-centre",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n public:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n    {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n           for(int j=y1;j<=y2;j++)\\n           {\\n              int c1=i-x;\\n              int c2=j-y;\\n              if(c1*c1+c2*c2<=r*r)\\n                  return 1;\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n public:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n    {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n           for(int j=y1;j<=y2;j++)\\n           {\\n              int c1=i-x;\\n              int c2=j-y;\\n              if(c1*c1+c2*c2<=r*r)\\n                  return 1;\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677990,
                "title": "java-3-lines",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int a = x1 > xc ? x1 - xc : xc > x2 ? xc - x2 : 0;\\n        int b = y1 > yc ? y1 - yc : yc > y2 ? yc - y2 : 0;\\n        return a * a + b * b <= r * r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int a = x1 > xc ? x1 - xc : xc > x2 ? xc - x2 : 0;\\n        int b = y1 > yc ? y1 - yc : yc > y2 ? yc - y2 : 0;\\n        return a * a + b * b <= r * r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632964,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = max(x1, xc - r); x <= min(x2, xc + r); ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = max(y1, yc - r); y <= min(y2, yc + r); ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}",
                "solutionTags": [],
                "code": "```\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = max(x1, xc - r); x <= min(x2, xc + r); ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = max(y1, yc - r); y <= min(y2, yc + r); ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2422915,
                "title": "simple-python-3-solution-explained",
                "content": "```\\nclass Solution:\\n\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \"\"\"\\n        Given circle and a rectangle. Return if they intersect.\\n        \"\"\"\\n\\n        def get_closest(x1, x2, x):\\n            return min(max(x1, x), x2)\\n\\n        # Find the closest point of the rectangle.\\n        # It lies on the rectangle border, and because of circle symmetry it is the point closest to the circle center.\\n        x = get_closest(x1, x2, xCenter)\\n        y = get_closest(y1, y2, yCenter)\\n\\n        # Is the point within the radius?\\n        return radius ** 2 >= (x - xCenter) ** 2 + (y - yCenter) ** 2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \"\"\"\\n        Given circle and a rectangle. Return if they intersect.\\n        \"\"\"\\n\\n        def get_closest(x1, x2, x):\\n            return min(max(x1, x), x2)\\n\\n        # Find the closest point of the rectangle.\\n        # It lies on the rectangle border, and because of circle symmetry it is the point closest to the circle center.\\n        x = get_closest(x1, x2, xCenter)\\n        y = get_closest(y1, y2, yCenter)\\n\\n        # Is the point within the radius?\\n        return radius ** 2 >= (x - xCenter) ** 2 + (y - yCenter) ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203911,
                "title": "c-solution-by-geometry",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        if (xCenter >= x1 && xCenter <= x2){\\n            if (yCenter >= y1 - radius && yCenter <= y2 + radius){\\n                return true;\\n            }\\n        }\\n        if (yCenter >= y1 && yCenter <= y2){\\n            if (xCenter >= x1 - radius && xCenter <= x2 + radius){\\n                return true;\\n            }\\n        }\\n        int rr = radius * radius;\\n        int dx, dy;\\n        dx = xCenter - x1, dy = yCenter - y1;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x1, dy = yCenter - y2;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x2, dy = yCenter - y1;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x2, dy = yCenter - y2;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        if (xCenter >= x1 && xCenter <= x2){\\n            if (yCenter >= y1 - radius && yCenter <= y2 + radius){\\n                return true;\\n            }\\n        }\\n        if (yCenter >= y1 && yCenter <= y2){\\n            if (xCenter >= x1 - radius && xCenter <= x2 + radius){\\n                return true;\\n            }\\n        }\\n        int rr = radius * radius;\\n        int dx, dy;\\n        dx = xCenter - x1, dy = yCenter - y1;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x1, dy = yCenter - y2;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x2, dy = yCenter - y1;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x2, dy = yCenter - y2;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189246,
                "title": "python-shortest-distance-to-center-of-circle-o-1-o-1",
                "content": "1.  For a point `(x,  y)`, its distance to the center of the circle is the square root of  `(x - xCenter)**2 + (y - yCenter)**2 ` . \\n\\n2.  For points inside the rectangle, its x cordinate is in the range of `[x1, x2]`, y cordinate of range `[y1, y2]`. \\n3.  Find the point in rectangle with the smallest `abs(x - xCenter)` and `abs(y - yCenter)`. This is the point closest to the center of the circle inside the rectangle.  If **`(x - xCenter)**2 + (y - yCenter)**2  <= Radius**2 `** , point `(x, y)` is inside the circle.\\n\\n\\n\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def find(a1, a2, aCenter):\\n            if a1 <= aCenter and aCenter <= a2:\\n                return 0 \\n            elif a1 > aCenter:\\n                return  a1 - aCenter\\n            else:\\n                return aCenter - a2\\n\\n        return (find(x1, x2, xCenter))**2 + (find(y1, y2, yCenter))**2 <= radius**2 \\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def find(a1, a2, aCenter):\\n            if a1 <= aCenter and aCenter <= a2:\\n                return 0 \\n            elif a1 > aCenter:\\n                return  a1 - aCenter\\n            else:\\n                return aCenter - a2\\n\\n        return (find(x1, x2, xCenter))**2 + (find(y1, y2, yCenter))**2 <= radius**2 \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2097842,
                "title": "100-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int x = max(x1, min(x2, xCenter));\\n        int y = max(y1, min(y2, yCenter));\\n        if(radius*radius >= (x-xCenter)*(x-xCenter) + (y-yCenter)*(y-yCenter))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int x = max(x1, min(x2, xCenter));\\n        int y = max(y1, min(y2, yCenter));\\n        if(radius*radius >= (x-xCenter)*(x-xCenter) + (y-yCenter)*(y-yCenter))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891909,
                "title": "swift-100-faster-code",
                "content": "```\\nfunc <=(lhs: Double, rhs: Int) -> Bool {\\n    return lhs <= Double(rhs)\\n}\\n\\nclass Solution {\\n    func computeDistance(x1: Int, y1: Int, x2: Int, y2: Int) -> Double {\\n        return sqrt(pow(Double((x2 - x1)), 2) + pow(Double((y2 - y1)), 2))\\n    }\\n    \\n    func checkOverlap(_ radius: Int, _ xCenter: Int, _ yCenter: Int, _ x1: Int, _ y1: Int, _ x2: Int, _ y2: Int) -> Bool {\\n        let topLeftDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x1, y2: y2)\\n        let topRightDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x2, y2: y2)\\n        let bottomLeftDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x1, y2: y1)\\n        let bottomRightDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x2, y2: y1)\\n        if xCenter >= x1 - radius && xCenter <= x2 + radius && yCenter >= y1 && yCenter <= y2 ||\\n            xCenter >= x1 && xCenter <= x2 && yCenter >= y1 - radius && yCenter <= y2 + radius ||\\n            topLeftDistance <= radius ||\\n            topRightDistance <= radius ||\\n            bottomLeftDistance <= radius ||\\n            bottomRightDistance <= radius {\\n            return true\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc <=(lhs: Double, rhs: Int) -> Bool {\\n    return lhs <= Double(rhs)\\n}\\n\\nclass Solution {\\n    func computeDistance(x1: Int, y1: Int, x2: Int, y2: Int) -> Double {\\n        return sqrt(pow(Double((x2 - x1)), 2) + pow(Double((y2 - y1)), 2))\\n    }\\n    \\n    func checkOverlap(_ radius: Int, _ xCenter: Int, _ yCenter: Int, _ x1: Int, _ y1: Int, _ x2: Int, _ y2: Int) -> Bool {\\n        let topLeftDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x1, y2: y2)\\n        let topRightDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x2, y2: y2)\\n        let bottomLeftDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x1, y2: y1)\\n        let bottomRightDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x2, y2: y1)\\n        if xCenter >= x1 - radius && xCenter <= x2 + radius && yCenter >= y1 && yCenter <= y2 ||\\n            xCenter >= x1 && xCenter <= x2 && yCenter >= y1 - radius && yCenter <= y2 + radius ||\\n            topLeftDistance <= radius ||\\n            topRightDistance <= radius ||\\n            bottomLeftDistance <= radius ||\\n            bottomRightDistance <= radius {\\n            return true\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515803,
                "title": "c-0ms-100-math-commented",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Circle and Rectangle Overlapping.\\nMemory Usage: 5.9 MB, less than 21.99% of C++ online submissions for Circle and Rectangle Overlapping.\\n```\\nclass Solution {\\npublic:\\n  int r;\\n  bool is_crossed(int A, int B, int C){\\n    A *= A;\\n    return A > r ? false : B*B + A <= r || C*C + A <= r || B*C <= 0;      //is crossed ?   not  : (yes) point into circle or point into circle or points locate into left and right ?\\n  } \\n  \\n  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n    r = radius*radius;\\n    x1 -= x_center, x2 -= x_center, y1 -= y_center, y2 -= y_center;                              //replace center of coordinates in center of circle\\n    return is_crossed(x1, y1, y2) || is_crossed(x2,y1,y2) || is_crossed(y1,x1,x2) || is_crossed(y2,x1,x2) || (x1*x2 < 0 && y1*y2 < 0);          //if side of rectangle is crossed the circle or rectangle include the circle\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int r;\\n  bool is_crossed(int A, int B, int C){\\n    A *= A;\\n    return A > r ? false : B*B + A <= r || C*C + A <= r || B*C <= 0;      //is crossed ?   not  : (yes) point into circle or point into circle or points locate into left and right ?\\n  } \\n  \\n  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n    r = radius*radius;\\n    x1 -= x_center, x2 -= x_center, y1 -= y_center, y2 -= y_center;                              //replace center of coordinates in center of circle\\n    return is_crossed(x1, y1, y2) || is_crossed(x2,y1,y2) || is_crossed(y1,x1,x2) || is_crossed(y2,x1,x2) || (x1*x2 < 0 && y1*y2 < 0);          //if side of rectangle is crossed the circle or rectangle include the circle\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166572,
                "title": "simple-java-solution",
                "content": "Here is the simple java solution with 0ms 100% fast\\n\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int xn = Math.max(x1,Math.min(x2,x_center));\\n        int yn = Math.max(y1,Math.min(y2,y_center));\\n        \\n        return Math.sqrt((xn-x_center)*(xn-x_center)+(yn-y_center)*(yn-y_center)) <= radius;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int xn = Math.max(x1,Math.min(x2,x_center));\\n        int yn = Math.max(y1,Math.min(y2,y_center));\\n        \\n        return Math.sqrt((xn-x_center)*(xn-x_center)+(yn-y_center)*(yn-y_center)) <= radius;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1133076,
                "title": "python3-geometry",
                "content": "\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2: return True # circle inside rectangle\\n        \\n        for x, y in (x1, y1), (x1, y2), (x2, y1), (x2, y2): \\n            if (x - x_center)**2 + (y - y_center)**2 <= radius**2: return True \\n        \\n        # check edge \\n        for x in [x1, x2]: \\n            if x_center - radius <= x <= x_center + radius and y1 <= y_center <= y2: return True\\n            \\n        for y in [y1, y2]:\\n            if y_center - radius <= y <= y_center + radius and x1 <= x_center <= x2: return True \\n        \\n        return False \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2: return True # circle inside rectangle\\n        \\n        for x, y in (x1, y1), (x1, y2), (x2, y1), (x2, y2): \\n            if (x - x_center)**2 + (y - y_center)**2 <= radius**2: return True \\n        \\n        # check edge \\n        for x in [x1, x2]: \\n            if x_center - radius <= x <= x_center + radius and y1 <= y_center <= y2: return True\\n            \\n        for y in [y1, y2]:\\n            if y_center - radius <= y <= y_center + radius and x1 <= x_center <= x2: return True \\n        \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104674,
                "title": "golang-solution-faster-than-100-with-explanation-and-images",
                "content": "**The Main Idea**\\n\\nThe idea of this solution is to find the distance from the middle of the circle to the edge of a rectangle, and if the distance is smaller than or equal to the radius, we know that the rectangle overlaps with the circle.\\n\\nIf you don\\'t understand, look at the following images:\\n\\n![image](https://assets.leetcode.com/users/images/776c78ba-f825-4c67-bafa-8243f5b8f5d0_1615564816.8738723.jpeg)\\n\\n\\n\\n> As you can see, the circle and the rectangle do not overlap, and this can be shown by the distance between the center of the circle and the closest edge of the rectangle. The length is `\\u221A8 = 2.82842712474619`, `2.82842712474619` is greater than the radius of `1`, so we know that the circle and the rectangle don\\'t overlap.\\n\\n![](https://i.imgur.com/W6g3aVq.jpg)\\n\\n> In the image above, we can see that the circle and the edge of the rectangle overlaps. And we can see that the distance between the closest edge of the square and the center of the circle is equal to the radius, so we can see that the rectangle and the rectangle overlap.\\n\\n![](https://i.imgur.com/h8vdUkm.jpg)\\n\\n> In the image above, we can see that the circle and the rectangle overlap. The distance between the center of the circle and the closest point on the rectangle is `\\u221A5 = 2.23606797749979` and `2.23606797749979 < radius` because `radius = 3`. Since the distance is smaller than the `radius`, we can say that the two shapes overlap.\\n\\n**How It Works:**\\n\\nNow that we have covered the main idea of this function, we can get into the details.\\n\\n**The first part is:**\\n\\n```\\nif x_center < x2 && x_center > x1 && y_center < y2 && y_center > y1 {\\n    return true\\n}\\n```\\n\\nThe part above is for if the circle inside the square. Such as like:\\n\\n![](https://i.imgur.com/ChoNOLK.jpg)\\n\\n\\nAs you can see, the circle radius is smaller than the distance of the closest edge and the center of the circle. We know that the circle and the rectangle overlap, but the computer thinks that they don\\'t overlap because the `distance from the center of the circle to the edge of the rectangle > radius`, so we have to make sure that this is counted as an overlap. We check whether this is overlap by checking whether the center of the circle is between the two x\\'s and between the two y\\'s.\\n\\n**The next part:**\\n\\n```\\nif ((y1 <= y_center+radius && y1 >= y_center) ||\\n    (y2 >= y_center-radius && y2 <= y_center)) && x_center >= x1 &&\\n    x_center <= x2 {\\n    \\n    return true\\n}\\n```\\n\\nThis can be used for something like the example below:\\n\\n![](https://i.imgur.com/5T1fXOG.jpg)\\n\\nThe main idea of:\\n\\n`((y1 <= y_center+radius && y1 >= y_center) || (y2 >= y_center-radius && y2 <= y_center)) && x_center >= x1 && x_center <= x2` \\n\\nis: \\n\\n`(y1 <= y_center + radius || y2 >= y_center - radius) && x_center >= x1 && x_center <= x2`\\n\\nThen after that, we can start to understand the additional parts.\\n\\nFirst, `y1 <= y_center + radius` is for if the circle is beneath the rectangle, just like the image below.\\n\\n![](https://i.imgur.com/8YwF90u.jpg)\\n\\n`y1 <= y_center + radius` in this example is `6 <= 5 + 2` which equals `6 <= 7`. So for this example the `y`\\'s\\' overlap.\\n\\n`y2 >= y_center - radius` is for when the circle is on top of the rectangle like in the picture below:\\n\\n![](https://i.imgur.com/NjPtHcc.jpg)\\n\\n`y2 >= y_center - radius` in this example is `4 >= 6 - 2` which is `4 = 4`. As we can see the `y`\\'s\\' overlap. \\n\\nThe next part, `x_center >= x1 && x_center <= x2` is for checking whether the center of the circle is inside the `x`\\'s values of the rectangle, so we can use the example above again. \\n\\nAs we said before the `y` parts of the shapes overlap. And now we can see that `x_center = 8`. `8 > 5`, `x1 = 5`, and `8 < 10`, and `x2 = 8`.\\n\\nWe can see an example where the `y` parts overlap, but the `x`\\'s parts don\\'t.\\n\\n![](https://i.imgur.com/vTe00bX.jpg)\\n\\nThe `y` parts work, `y2 >= y_center - radius`, which equals `4 >= 5 - 2` and when simplifyed `4 >= 3`. But the `x` parts don\\'t work because the equations are `x_center >= x1` and `x_center <= x2`, and when we put in our numbers we get `13 >= 5` but when we put in the numbers into the second equation, `13 > 10` while we want `x_center <= x2`. So we know that the shapes don\\'t overlap.\\n\\nIt also checks whether `y1 >= y_center` and `y2 <= y_center` because we want to make sure that we don\\'t `return true` for extra test cases.\\n\\n**The Next Part:**\\n\\n```\\nif y_center <= y2 && y_center >= y1 && ((x_center-radius <= x2 && \\n    x_center >= x2) || (x_center+radius >= x1 && x_center <= x1)) {\\n    \\n    return true\\n}\\n```\\n\\nWe use this part if the part before fails. This checks whether the circle is on either side of the rectangle.\\n\\nThis checks whether the `y_center` is greater than or equal to `y1` and if it is smaller than or equal to `y2`. Then it checks whether the `x_center - radius` is smaller than or equal to `x2`, or `x_center - radius >= x1`. It also checks whether `x_center >= x2` and `x_center <= x1`, just like the previous part.\\n\\nWe can explain this with the following images:\\n\\n![](https://i.imgur.com/PyTQ1SK.jpg)\\n\\nThis circle is on the right of the rectangle.\\n\\nWe can see that the `y_center = 4` and `4 < 7`, `y2 = 7`, and `4 > 1`, `y1 = 1`. We can see that `((x_center-radius <= x2 && x_center >= x2) || (x_center+radius >= x1 && x_center <= x1))` is true because `x_center-radius <= x2 && x_center >= x2`, since `x_center = 4`, and that `radius = 2`. `4 - 2 <= 3` and `4 > 3` so we return true.\\n\\nThe next image is on the left of the image:\\n\\n![](https://i.imgur.com/6VIXcKh.jpg)\\n\\nThe `y` part is the same as the last image, so we know that the `y` part overlaps. So we can see that the `y` part overlaps. We can use the formula `x_center + radius >= x1 && x_center <= x1`. `x_center = 3` and the `radius  = 2`. So when we input the numbers into the variables, `3 + 2 >= 4` when simplifyed `5 >= 4`, `x1 = 4`. The next equation is `3 <= 4`. \\n\\nAs we can see `x_center+radius >= x1 && x_center <= x1` is for if the circle is on the right of the rectangle. And `x_center-radius <= x2 && x_center >= x2` is for if the circle is on the left of the rectangle.\\n\\n\\n**The last part:**\\n\\n```\\nif powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) <= \\n    powerOfTwo(radius) {\\n    \\n    return true\\n}\\n```\\n\\nThe idea of `powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) <= powerOfTwo(radius)` is basicly pythagoras theorem, `a^2 + b^2 = c^2`. `a^2 + b^2 = c^2`, and this is basicly `(x_center - x1)^2 + (y_center - y1)^2 = radius^2`. \\n\\nThe distance formula is `d = sqrt((x1 - x2)^2 + (y1 - y2)^2)`, though for this problem we don\\'t need the `sqrt` so we the equation can be `d = (x1 - x2)^2 + (y1 - y2)^2)`, so we can continue to use `(x_center - x1)^2 + (y_center - y1)^2 = radius^2`. \\n\\nAll of the following are similar except for different points, `x1, x2, y1, y2, x_center, y_center`.\\n\\n```\\npowerOfTwo(x_center-x1)+powerOfTwo(y_center-y2) <= powerOfTwo(radius)\\n\\npowerOfTwo(x_center-x2)+powerOfTwo(y_center-y1) <= powerOfTwo(radius)\\n\\npowerOfTwo(x_center-x2)+powerOfTwo(y_center-y2) <= powerOfTwo(radius)\\n```\\n\\n## The Code:\\n\\n``` go\\nfunc checkOverlap(radius int, x_center int, y_center int, x1 int, y1 int, x2 int, y2 int) bool {\\n\\n    if x_center < x2 && x_center > x1 && y_center < y2 && y_center > y1 {\\n        // Checking whether the circle is in the middle of the square\\n        return true\\n    }\\n\\n    if ((y1 <= y_center+radius && y1 >= y_center) ||\\n    (y2 >= y_center-radius && y2 <= y_center)) &&\\n        x_center >= x1 && x_center <= x2 {\\n        return true\\n    }\\n\\n    if y_center <= y2 && y_center >= y1 && ((x_center-radius <= x2 && \\n    x_center >= x2) || (x_center+radius >= x1 && x_center <= x1)) {\\n        return true\\n    }\\n\\n    if powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x1)+powerOfTwo(y_center-y2) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x2)+powerOfTwo(y_center-y1) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x2)+powerOfTwo(y_center-y2) <= \\n            powerOfTwo(radius) {\\n        return true\\n    }\\n\\n    return false\\n}\\n\\nfunc powerOfTwo(n int) int {\\n    return n * n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nif x_center < x2 && x_center > x1 && y_center < y2 && y_center > y1 {\\n    return true\\n}\\n```\n```\\nif ((y1 <= y_center+radius && y1 >= y_center) ||\\n    (y2 >= y_center-radius && y2 <= y_center)) && x_center >= x1 &&\\n    x_center <= x2 {\\n    \\n    return true\\n}\\n```\n```\\nif y_center <= y2 && y_center >= y1 && ((x_center-radius <= x2 && \\n    x_center >= x2) || (x_center+radius >= x1 && x_center <= x1)) {\\n    \\n    return true\\n}\\n```\n```\\nif powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) <= \\n    powerOfTwo(radius) {\\n    \\n    return true\\n}\\n```\n```\\npowerOfTwo(x_center-x1)+powerOfTwo(y_center-y2) <= powerOfTwo(radius)\\n\\npowerOfTwo(x_center-x2)+powerOfTwo(y_center-y1) <= powerOfTwo(radius)\\n\\npowerOfTwo(x_center-x2)+powerOfTwo(y_center-y2) <= powerOfTwo(radius)\\n```\n``` go\\nfunc checkOverlap(radius int, x_center int, y_center int, x1 int, y1 int, x2 int, y2 int) bool {\\n\\n    if x_center < x2 && x_center > x1 && y_center < y2 && y_center > y1 {\\n        // Checking whether the circle is in the middle of the square\\n        return true\\n    }\\n\\n    if ((y1 <= y_center+radius && y1 >= y_center) ||\\n    (y2 >= y_center-radius && y2 <= y_center)) &&\\n        x_center >= x1 && x_center <= x2 {\\n        return true\\n    }\\n\\n    if y_center <= y2 && y_center >= y1 && ((x_center-radius <= x2 && \\n    x_center >= x2) || (x_center+radius >= x1 && x_center <= x1)) {\\n        return true\\n    }\\n\\n    if powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x1)+powerOfTwo(y_center-y2) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x2)+powerOfTwo(y_center-y1) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x2)+powerOfTwo(y_center-y2) <= \\n            powerOfTwo(radius) {\\n        return true\\n    }\\n\\n    return false\\n}\\n\\nfunc powerOfTwo(n int) int {\\n    return n * n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085109,
                "title": "c-faster-than-100-implemented-complementary-algorithm",
                "content": "Instead of finding if they touch,find if the circle is outside the rectangle.\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int a = sqrt(pow(abs(x1 - xc), 2) + pow(abs(y1 - yc), 2));\\n        int b = sqrt(pow(abs(x2 - xc), 2) + pow(abs(y2 - yc), 2));\\n        int c = sqrt(pow(abs(x2 - xc), 2) + pow(abs(y1 - yc), 2));\\n        int d = sqrt(pow(abs(x1 - xc), 2) + pow(abs(y2 - yc), 2));\\n        \\n        if(yc-radius > y2)return false;\\n        if(yc+radius < y1)return false;\\n        if(xc+radius < x1)return false;\\n        if(xc-radius > x2)return false;\\n        \\n        int r= radius;\\n        if(a<r || b<r || c<r || d<r)return true;\\n        \\n        if(xc>x2 && yc<y1)return false;\\n        if(xc>x2 && yc>y2)return false;\\n        if(xc<x1 && yc>y2)return false;\\n        if(xc<x1 && yc<y1)return false;\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int a = sqrt(pow(abs(x1 - xc), 2) + pow(abs(y1 - yc), 2));\\n        int b = sqrt(pow(abs(x2 - xc), 2) + pow(abs(y2 - yc), 2));\\n        int c = sqrt(pow(abs(x2 - xc), 2) + pow(abs(y1 - yc), 2));\\n        int d = sqrt(pow(abs(x1 - xc), 2) + pow(abs(y2 - yc), 2));\\n        \\n        if(yc-radius > y2)return false;\\n        if(yc+radius < y1)return false;\\n        if(xc+radius < x1)return false;\\n        if(xc-radius > x2)return false;\\n        \\n        int r= radius;\\n        if(a<r || b<r || c<r || d<r)return true;\\n        \\n        if(xc>x2 && yc<y1)return false;\\n        if(xc>x2 && yc>y2)return false;\\n        if(xc<x1 && yc>y2)return false;\\n        if(xc<x1 && yc<y1)return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948424,
                "title": "c-0ms-concise",
                "content": "**Solution Observations**\\nFirst I tried Brute Force solution I got TLE, then I realized that we don\\'t have to check every coordinate one by one, instead we can increase x and y coordinates by radius. \\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        // Check four corners of rectangle\\n        int a = sqrt(pow(abs(x1 - x_center), 2) + pow(abs(y1 - y_center), 2));\\n        int b = sqrt(pow(abs(x2 - x_center), 2) + pow(abs(y2 - y_center), 2));\\n        int c = sqrt(pow(abs(x2 - x_center), 2) + pow(abs(y1 - y_center), 2));\\n        int d = sqrt(pow(abs(x1 - x_center), 2) + pow(abs(y2 - y_center), 2));\\n        if (a <= radius || b <= radius || c <= radius || d <= radius) {\\n            return true;\\n        }\\n        for (int x = x1; x <= x2; x += radius) {\\n            for (int y = y1; y <= y2; y += radius) {\\n                int distToCircleCenter = sqrt(pow(abs(x - x_center), 2) + pow(abs(y - y_center), 2));\\n                if (distToCircleCenter <= radius) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        // Check four corners of rectangle\\n        int a = sqrt(pow(abs(x1 - x_center), 2) + pow(abs(y1 - y_center), 2));\\n        int b = sqrt(pow(abs(x2 - x_center), 2) + pow(abs(y2 - y_center), 2));\\n        int c = sqrt(pow(abs(x2 - x_center), 2) + pow(abs(y1 - y_center), 2));\\n        int d = sqrt(pow(abs(x1 - x_center), 2) + pow(abs(y2 - y_center), 2));\\n        if (a <= radius || b <= radius || c <= radius || d <= radius) {\\n            return true;\\n        }\\n        for (int x = x1; x <= x2; x += radius) {\\n            for (int y = y1; y <= y2; y += radius) {\\n                int distToCircleCenter = sqrt(pow(abs(x - x_center), 2) + pow(abs(y - y_center), 2));\\n                if (distToCircleCenter <= radius) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865672,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n        int i, j;\\n        for(i=y1; i<=y2; i++){\\n            for(j=x1; j<=x2; j++){\\n                if((i-y_center)*(i-y_center)+(j-x_center)*(j-x_center)<=radius*radius)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n        int i, j;\\n        for(i=y1; i<=y2; i++){\\n            for(j=x1; j<=x2; j++){\\n                if((i-y_center)*(i-y_center)+(j-x_center)*(j-x_center)<=radius*radius)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861060,
                "title": "python-math-solution-o-1",
                "content": "For a circle with radius ``r`` and center ``a, b``, for internal points ``x, y`` we have: ``(x-a)^2 +(y-b)^2<=r`` eq.(1)\\nFor ``x, y`` inside the rectangle we have``x1<=x<=x2 and y1<=y<=y2`` thus ``x1-a<=x-a<=x2-a and y1-a<=y-a<=y2-a`` eq. (2)\\nTherefore we only need to find ``min(x-a)^2 + min(y-b)^2 or min[abs(x-a) +abs(y-b)]`` which satisfies eq.(2) and to see if it also satisfies eq.(1) \\nThus define a function to see wether the stright line for ``x and y`` pass through ``0`` to find the minimal value of ``abs(x-a) and abs(y-b)``\\n\\n    def min_abs(self, a: int, b:int):\\n        if a<0 and b>0: return 0\\n        elif a>=0: return a*a\\n        else: return b*b\\n    def checkOverlap(self, r: int, a: int, b: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return self.min_abs(x1-a, x2-a) + self.min_abs(y1-b, y2-b) <= r*r",
                "solutionTags": [],
                "code": "For a circle with radius ``r`` and center ``a, b``, for internal points ``x, y`` we have: ``(x-a)^2 +(y-b)^2<=r`` eq.(1)\\nFor ``x, y`` inside the rectangle we have``x1<=x<=x2 and y1<=y<=y2`` thus ``x1-a<=x-a<=x2-a and y1-a<=y-a<=y2-a`` eq. (2)\\nTherefore we only need to find ``min(x-a)^2 + min(y-b)^2 or min[abs(x-a) +abs(y-b)]`` which satisfies eq.(2) and to see if it also satisfies eq.(1) \\nThus define a function to see wether the stright line for ``x and y`` pass through ``0`` to find the minimal value of ``abs(x-a) and abs(y-b)``\\n\\n    def min_abs(self, a: int, b:int):\\n        if a<0 and b>0: return 0\\n        elif a>=0: return a*a\\n        else: return b*b\\n    def checkOverlap(self, r: int, a: int, b: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return self.min_abs(x1-a, x2-a) + self.min_abs(y1-b, y2-b) <= r*r",
                "codeTag": "Python3"
            },
            {
                "id": 690220,
                "title": "simple-c-code",
                "content": "```\\n#define min(x,y)((x)<(y)?(x):(y))\\n\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n    int x=min(min((y_center-y1),0),(y2-y_center));\\n    int y=min(min((x_center-x1),0),(x2-x_center));\\n    return (x*x)+(y*y)<=(radius*radius);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define min(x,y)((x)<(y)?(x):(y))\\n\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n    int x=min(min((y_center-y1),0),(y2-y_center));\\n    int y=min(min((x_center-x1),0),(x2-x_center));\\n    return (x*x)+(y*y)<=(radius*radius);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688643,
                "title": "c-constant-time-space-math",
                "content": "```\\n// this program checks if circle and rectangle over lap ( share at least 1 point in an X Y system)\\n//x_center , y_center - circle cords, x1,y1 - left most lowest most point rectangle points\\n// x2,y2 - right most highest cords of the rectangle\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n// first we check if center of the cirlce is inside the rectangle if so we return true(clearly they share points)\\n    if((x_center>= x1 && x_center<=x2) && (y_center>=y1 && y_center<=y2) ) return true;\\n    // there are cases where the center of the cirlce is not inside the rectangle and \\n\\t//still share points\\n    // we need to check these cases and return the right answer!\\n    \\n    // center of circle is left from rectangle but in rectangle Y axis range of(y1,y2)\\n    else if(x_center<x1 && (y_center>=y1 && y_center<=y2)) { \\n        if((x_center+radius)>=x1) return true;\\n    }\\n    // center of circle is right from rectangle but in rectangle Y axis range of(y1,y2)\\n    else if(x_center >x2 && (y_center>=y1 && y_center<=y2)) { \\n        if((x_center-radius)<=x2) return true;\\n    }\\n    // center of circle is below lowest points in rectangle but in between X1 and X2 AIXS\\n    else if(y_center < y1 && (x_center>=x1 && x_center<=x2)) {\\n        if((y_center+radius) >= y1) return true;\\n    }\\n    // center of circle is above highest points in rectangle but in between X1 and X2 AIXS\\n    else if(y_center > y2 && (x_center >= x1 && x_center<=x2)) {\\n        if((y_center-radius)<=y2) return true;\\n    }\\n    // center of circle is below and right side of the rectangle\\n    // we check if the radius can reach the right most and low most point of the rectangle if so \\n\\t//then they share at least 1 point if its equal to radius and if the radius is even bigger it \\n\\t//may have many points\\n    else if(x_center>x2 && (y_center<y1)) {\\n        double Pythagorean = pow(x_center-x2,2) + pow(y1-y_center,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // Center of circle is above  the right most and top most cord of the rectangle ( x2,y2) and also right of \\n\\t//the rectangle\\n    // we check if the radius can reach the right most and top most cord of the rectangle(x2,y2) if so\\n\\t//they share at least 1 point if not more(if the radius is even bigger)\\n    else if(x_center>x2 && (y_center>y2)) {\\n        double Pythagorean = pow(x_center-x2,2) + pow(y_center-y2,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // center of circle is above and also to th eleft of the top most left most cord \\n\\t//in the rectangle we need to check if its radius can reach that point or \\n\\t//if the radius is even bigger in that case it may share more than 1 point with the rectangle\\n    else if(x_center<x1 && (y_center > y2)) {\\n        double Pythagorean = pow(x_center-x1,2) + pow(y_center-y2,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // center of circle is below and left to the lowest and left most point of the rectangle (x1,y1)\\n    // we need to check if its radius can reach that point or if the radius can reach even more in \\n\\t//that case it  will share more than one point\\n    else if(x_center<x1 && y_center<y1) {\\n        double Pythagorean = pow(x1-x_center,2) + pow(y1-y_center,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    return false;\\n}\\n```\\n![image](https://assets.leetcode.com/users/yarin1/image_1592227941.png)\\n",
                "solutionTags": [],
                "code": "```\\n// this program checks if circle and rectangle over lap ( share at least 1 point in an X Y system)\\n//x_center , y_center - circle cords, x1,y1 - left most lowest most point rectangle points\\n// x2,y2 - right most highest cords of the rectangle\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n// first we check if center of the cirlce is inside the rectangle if so we return true(clearly they share points)\\n    if((x_center>= x1 && x_center<=x2) && (y_center>=y1 && y_center<=y2) ) return true;\\n    // there are cases where the center of the cirlce is not inside the rectangle and \\n\\t//still share points\\n    // we need to check these cases and return the right answer!\\n    \\n    // center of circle is left from rectangle but in rectangle Y axis range of(y1,y2)\\n    else if(x_center<x1 && (y_center>=y1 && y_center<=y2)) { \\n        if((x_center+radius)>=x1) return true;\\n    }\\n    // center of circle is right from rectangle but in rectangle Y axis range of(y1,y2)\\n    else if(x_center >x2 && (y_center>=y1 && y_center<=y2)) { \\n        if((x_center-radius)<=x2) return true;\\n    }\\n    // center of circle is below lowest points in rectangle but in between X1 and X2 AIXS\\n    else if(y_center < y1 && (x_center>=x1 && x_center<=x2)) {\\n        if((y_center+radius) >= y1) return true;\\n    }\\n    // center of circle is above highest points in rectangle but in between X1 and X2 AIXS\\n    else if(y_center > y2 && (x_center >= x1 && x_center<=x2)) {\\n        if((y_center-radius)<=y2) return true;\\n    }\\n    // center of circle is below and right side of the rectangle\\n    // we check if the radius can reach the right most and low most point of the rectangle if so \\n\\t//then they share at least 1 point if its equal to radius and if the radius is even bigger it \\n\\t//may have many points\\n    else if(x_center>x2 && (y_center<y1)) {\\n        double Pythagorean = pow(x_center-x2,2) + pow(y1-y_center,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // Center of circle is above  the right most and top most cord of the rectangle ( x2,y2) and also right of \\n\\t//the rectangle\\n    // we check if the radius can reach the right most and top most cord of the rectangle(x2,y2) if so\\n\\t//they share at least 1 point if not more(if the radius is even bigger)\\n    else if(x_center>x2 && (y_center>y2)) {\\n        double Pythagorean = pow(x_center-x2,2) + pow(y_center-y2,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // center of circle is above and also to th eleft of the top most left most cord \\n\\t//in the rectangle we need to check if its radius can reach that point or \\n\\t//if the radius is even bigger in that case it may share more than 1 point with the rectangle\\n    else if(x_center<x1 && (y_center > y2)) {\\n        double Pythagorean = pow(x_center-x1,2) + pow(y_center-y2,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // center of circle is below and left to the lowest and left most point of the rectangle (x1,y1)\\n    // we need to check if its radius can reach that point or if the radius can reach even more in \\n\\t//that case it  will share more than one point\\n    else if(x_center<x1 && y_center<y1) {\\n        double Pythagorean = pow(x1-x_center,2) + pow(y1-y_center,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 679145,
                "title": "java-concise-and-straightforward",
                "content": "false iff:\\n1, circle center prejectino to axis garranttee to far wary from rectrangle; (see example 1);\\nor\\n2, distance btw circle center and either of the 4 corner of rectangle is smaller than radius;\\n\\n```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if (xc + r < x1 || xc - r > x2 || yc + r < y1 || yc - r > y2) return false;  \\n        if (xc < x1 && yc < y1 && longer(xc, yc, x1, y1, r)) return false;\\n        if (xc < x1 && yc > y2 && longer(xc, yc, x1, y2, r)) return false;\\n        if (xc > x2 && yc < y1 && longer(xc, yc, x2, y1, r)) return false;\\n        if (xc > x2 && yc > y2 && longer(xc, yc, x2, y2, r)) return false;\\n        return true;\\n    }\\n    \\n    private boolean longer(int xc, int yc, int x, int y, int r) {\\n        return (xc - x) * (xc - x) + (yc - y) * (yc - y) > r * r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if (xc + r < x1 || xc - r > x2 || yc + r < y1 || yc - r > y2) return false;  \\n        if (xc < x1 && yc < y1 && longer(xc, yc, x1, y1, r)) return false;\\n        if (xc < x1 && yc > y2 && longer(xc, yc, x1, y2, r)) return false;\\n        if (xc > x2 && yc < y1 && longer(xc, yc, x2, y1, r)) return false;\\n        if (xc > x2 && yc > y2 && longer(xc, yc, x2, y2, r)) return false;\\n        return true;\\n    }\\n    \\n    private boolean longer(int xc, int yc, int x, int y, int r) {\\n        return (xc - x) * (xc - x) + (yc - y) * (yc - y) > r * r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653132,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582138,
                "title": "python-use-a-virtual-square-bounding-the-circle",
                "content": "![image](https://assets.leetcode.com/users/xuawai/image_1587026760.png)\\n\\n1. Assume there is a square of size `(2*radius) * (2*radius)` bounding the circle exactly. Note that `the square area - the circle area = the area of 4 corners in crescent`.\\n2. Check whether the square and the rectangle are overlapped. If not, return False. \\n3. Now the rectangle is overlapped with the square. It does not mean the rectangle is overlapped with the circle, because the rectangle may be overlapped with the 4 corners.\\n4. Check whether the 4 corners and the rectangle are overlapped. If so, return False.\\n5. Now we are sure that the rectangle is overlapped with the square, while not overlapped with the 4 corners. Return True.\\n\\nPython Version:\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:  \\n        # check whether the square and the rectangle are overlapped. If not, return False.  \\n        r_min = min(x_center + radius, x2)\\n        l_max = max(x_center - radius, x1)\\n        t_min = min(y_center + radius, y2)\\n        b_max = max(y_center - radius, y1)\\n        if not (r_min >= l_max and t_min >= b_max):\\n            return False\\n        # Check whether the 4 corners and the rectangle are overlapped.\\n        def d(x, y):\\n            return (x - x_center) ** 2 + (y - y_center) ** 2\\n        r = radius ** 2\\n        # bottom-right corner\\n        if y_center > y2 and x_center < x1 and d(x1, y2) > r:\\n            return False\\n        # top-right corner\\n        if y_center < y1 and x_center < x1 and d(x1, y1) > r:\\n            return False\\n        # top-left corner\\n        if y_center < y1 and x_center > x2 and d(x2, y1) > r:\\n            return False\\n        # bottm-left corner\\n        if y_center > y2 and x_center > x2 and d(x2, y2) > r:\\n            return False\\n        # Now we are sure that the rectangle is overlapped with the square, while not overlapped with the 4 corners.\\n        return True",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/xuawai/image_1587026760.png)\\n\\n1. Assume there is a square of size `(2*radius) * (2*radius)` bounding the circle exactly. Note that `the square area - the circle area = the area of 4 corners in crescent`.\\n2. Check whether the square and the rectangle are overlapped. If not, return False. \\n3. Now the rectangle is overlapped with the square. It does not mean the rectangle is overlapped with the circle, because the rectangle may be overlapped with the 4 corners.\\n4. Check whether the 4 corners and the rectangle are overlapped. If so, return False.\\n5. Now we are sure that the rectangle is overlapped with the square, while not overlapped with the 4 corners. Return True.\\n\\nPython Version:\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:  \\n        # check whether the square and the rectangle are overlapped. If not, return False.  \\n        r_min = min(x_center + radius, x2)\\n        l_max = max(x_center - radius, x1)\\n        t_min = min(y_center + radius, y2)\\n        b_max = max(y_center - radius, y1)\\n        if not (r_min >= l_max and t_min >= b_max):\\n            return False\\n        # Check whether the 4 corners and the rectangle are overlapped.\\n        def d(x, y):\\n            return (x - x_center) ** 2 + (y - y_center) ** 2\\n        r = radius ** 2\\n        # bottom-right corner\\n        if y_center > y2 and x_center < x1 and d(x1, y2) > r:\\n            return False\\n        # top-right corner\\n        if y_center < y1 and x_center < x1 and d(x1, y1) > r:\\n            return False\\n        # top-left corner\\n        if y_center < y1 and x_center > x2 and d(x2, y1) > r:\\n            return False\\n        # bottm-left corner\\n        if y_center > y2 and x_center > x2 and d(x2, y2) > r:\\n            return False\\n        # Now we are sure that the rectangle is overlapped with the square, while not overlapped with the 4 corners.\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 580784,
                "title": "java-100-100-0ms-4-lines",
                "content": "\\tcircle = (x - x_center) * (x - x_center) + (y - y_center) * (y - y_center) <= radius * radius\\n\\tx1 <= x && x <= x2 && y1 <= y && y <= y2\\n    \\n\\txo = x - x_center\\n\\tyo = y - y_center\\n\\tx1 - x_center <= xo <= x2 - x_center \\n\\ty1 - y_center <= yo <= y2 - y_center\\n\\txo^2 + yo^2 <= raidus^2\\n\\t\\n```java\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int xp = 0, yp = 0;\\n        if((x1 - x_center) * (x2 - x_center) > 0) xp = Math.min(Math.abs(x1 - x_center), Math.abs(x2 - x_center));\\n        if((y1 - y_center) * (y2 - y_center) > 0) yp = Math.min(Math.abs(y1 - y_center), Math.abs(y2 - y_center));\\n        return xp * xp + yp * yp <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int xp = 0, yp = 0;\\n        if((x1 - x_center) * (x2 - x_center) > 0) xp = Math.min(Math.abs(x1 - x_center), Math.abs(x2 - x_center));\\n        if((y1 - y_center) * (y2 - y_center) > 0) yp = Math.min(Math.abs(y1 - y_center), Math.abs(y2 - y_center));\\n        return xp * xp + yp * yp <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570622,
                "title": "c-easy-solution",
                "content": "We check if any point (inside/on) the rectangle lies (inside/on) the circle\\nTo check if a point lies (inside/on) the circle   (x-x_center)^2+(y-y_center)^2<=(radius)^2\\n\\ncode:\\n```\\n        for(int i=x1;i<=x2;i++)\\n        {\\n            for(int j=y2;j>=y1;j--)\\n            {\\n                if(pow(i-x_center,2)+pow(j-y_center,2)<=pow(radius,2))\\n                {\\n                    return true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n```",
                "solutionTags": [],
                "code": "```\\n        for(int i=x1;i<=x2;i++)\\n        {\\n            for(int j=y2;j>=y1;j--)\\n            {\\n                if(pow(i-x_center,2)+pow(j-y_center,2)<=pow(radius,2))\\n                {\\n                    return true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 565752,
                "title": "overcomplicated-solution-using-vectors",
                "content": "The implementation is mostly the same as in https://www.***.org/minimum-distance-from-a-point-to-the-line-segment-using-vectors/. The basic idea is that we consider 4 sides of the rectangle and find closest point from center of circle to each side. We get 4 distances to each edge and compare it with radius\\n\\n```\\npublic boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\n        if ((x_center <= x2 && x_center >= x1) && (y_center <= y2 && y_center >= y1)) return true;\\n        \\n        double d1 = distance(x_center, y_center, x1, y1, x1,y2);\\n        double d2 = distance(x_center, y_center, x1, y1, x2,y1);\\n        double d3 = distance(x_center, y_center, x2, y1, x2,y2);\\n        double d4 = distance(x_center, y_center, x1, y2, x2,y2);\\n\\n        return le(d1, radius) || le(d2, radius) || le(d3, radius) || le(d4, radius);\\n    }\\n    \\n    boolean le(double d, int r) {\\n        return d <= r || Math.abs(d - r) < 0.0001;\\n    }\\n\\n    private double distance(int x0, int y0, int x1, int y1, int x2, int y2) {\\n        int[] ab = new int[] {x2 - x1, y2 - y1};\\n        int[] ae = new int[] {x0 - x1, y0 - y1};\\n        int[] be = new int[] {x0 - x2, y0 - y2};\\n\\n        if (dot(ab, be) > 0) {\\n            return distance(x0, y0, x2, y2);\\n        }\\n        else if (dot(ab, ae) < 0) {\\n            return distance(x0, y0, x1, y1);\\n        }\\n        else {\\n            double abMod = distance(x1, y1, x2, y2);\\n            return Math.abs(ab[0] * ae[1] - ab[1] * ae[0]) / abMod;\\n        }\\n    }\\n\\n    private double distance(int x1, int y1, int x2, int y2) {\\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n    }\\n\\n    private int dot(int[] v1, int[] v2) {\\n        return v1[0] * v2[0] + v1[1] * v2[1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\n        if ((x_center <= x2 && x_center >= x1) && (y_center <= y2 && y_center >= y1)) return true;\\n        \\n        double d1 = distance(x_center, y_center, x1, y1, x1,y2);\\n        double d2 = distance(x_center, y_center, x1, y1, x2,y1);\\n        double d3 = distance(x_center, y_center, x2, y1, x2,y2);\\n        double d4 = distance(x_center, y_center, x1, y2, x2,y2);\\n\\n        return le(d1, radius) || le(d2, radius) || le(d3, radius) || le(d4, radius);\\n    }\\n    \\n    boolean le(double d, int r) {\\n        return d <= r || Math.abs(d - r) < 0.0001;\\n    }\\n\\n    private double distance(int x0, int y0, int x1, int y1, int x2, int y2) {\\n        int[] ab = new int[] {x2 - x1, y2 - y1};\\n        int[] ae = new int[] {x0 - x1, y0 - y1};\\n        int[] be = new int[] {x0 - x2, y0 - y2};\\n\\n        if (dot(ab, be) > 0) {\\n            return distance(x0, y0, x2, y2);\\n        }\\n        else if (dot(ab, ae) < 0) {\\n            return distance(x0, y0, x1, y1);\\n        }\\n        else {\\n            double abMod = distance(x1, y1, x2, y2);\\n            return Math.abs(ab[0] * ae[1] - ab[1] * ae[0]) / abMod;\\n        }\\n    }\\n\\n    private double distance(int x1, int y1, int x2, int y2) {\\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n    }\\n\\n    private int dot(int[] v1, int[] v2) {\\n        return v1[0] * v2[0] + v1[1] * v2[1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564542,
                "title": "java-another-one-closest-point-on-rectangle-to-circle-solution",
                "content": "the best solution Q3 \\n```\\n public class Solution {\\n    private int dist(int a1, int a2, int x) {\\n        if (x < a1) return Math.abs(a1 - x);\\n        if (x > a2) return Math.abs(x - a2);\\n        return 0;\\n    }\\n\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int a = dist(x1, x2, x_center);\\n        int b = dist(y1, y2, y_center);\\n        return a * a + b * b <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public class Solution {\\n    private int dist(int a1, int a2, int x) {\\n        if (x < a1) return Math.abs(a1 - x);\\n        if (x > a2) return Math.abs(x - a2);\\n        return 0;\\n    }\\n\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int a = dist(x1, x2, x_center);\\n        int b = dist(y1, y2, y_center);\\n        return a * a + b * b <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564063,
                "title": "100-100-mathematical-easy-to-understand-explanation",
                "content": "Thought Process\\n-\\nThe point of the square closest to the circle must be within the circle if any of the square is within the circle. This closest point is on the edge of the square, possible a corner. It\\'s either lined up with the ```(x,y)``` coordinates of the circle\\'s center, or as close as it can get. The distance from this point is then compared to the radius of the circle.\\n\\nAlgorithm\\n-\\n```\\npublic class Solution {\\n    public bool CheckOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        var x_square = ClosestToCenter(x_center, x1, x2);\\n        var y_square = ClosestToCenter(y_center, y1, y2);\\n        return DistanceSquared(x_center - x_square, y_center - y_square) <= radius * radius;\\n    }\\n    \\n    private static int ClosestToCenter(int a_center, int a1, int a2) {\\n        return a_center < a1 ? a1 : a_center > a2 ? a2 : a_center;\\n    }\\n    \\n    private static int DistanceSquared(int x, int y) {\\n        return x*x + y*y;\\n    }\\n}\\n```\\n\\nProof\\n-\\n![image](https://assets.leetcode.com/users/laprade/image_1586046485.png)\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```(x,y)```\n```\\npublic class Solution {\\n    public bool CheckOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        var x_square = ClosestToCenter(x_center, x1, x2);\\n        var y_square = ClosestToCenter(y_center, y1, y2);\\n        return DistanceSquared(x_center - x_square, y_center - y_square) <= radius * radius;\\n    }\\n    \\n    private static int ClosestToCenter(int a_center, int a1, int a2) {\\n        return a_center < a1 ? a1 : a_center > a2 ? a2 : a_center;\\n    }\\n    \\n    private static int DistanceSquared(int x, int y) {\\n        return x*x + y*y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563599,
                "title": "c-solution-for-beginners-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int checkMinDistance(int a1,int a2,int x){\\n        if(x<a1){\\n            return (a1-x);\\n        }\\n        \\n        if(x>a2){\\n            return (a2-x);\\n        }\\n        \\n        return 0;\\n    }\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) {\\n        int a1=checkMinDistance(x1,x2,x);\\n        int a2=checkMinDistance(y1,y2,y);\\n        \\n        return a1*a1+a2*a2<=r*r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int checkMinDistance(int a1,int a2,int x){\\n        if(x<a1){\\n            return (a1-x);\\n        }\\n        \\n        if(x>a2){\\n            return (a2-x);\\n        }\\n        \\n        return 0;\\n    }\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) {\\n        int a1=checkMinDistance(x1,x2,x);\\n        int a2=checkMinDistance(y1,y2,y);\\n        \\n        return a1*a1+a2*a2<=r*r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563450,
                "title": "java-o-1-solution-with-line-by-line-explanation",
                "content": "For the rectangle coordinates:\\n```\\nx1 = left vertical\\nx2 = right vertical\\ny1 = bottom horizontal\\ny2 = top horizontal\\n```\\n\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\t\\t// Temporary variables to set edges for testing\\n        int testX = x_center;\\n        int testY = y_center;\\n\\t\\t// First, we find the closest edge.\\n\\t\\t// If rectange\\'s left edge is on the right on the circle, then it must be closest vertical edge to the circle\\n        if(x_center < x1) testX = x1;\\n        else if(x_center > x2) testX = x2;\\n\\t\\t\\n\\t\\t// If rectangle\\'s bottom horizontal edge is above the circle, then it must be the closest horizontal edge to the circle \\n        if(y_center < y1) testY = y1;\\n        else if(y_center > y2) testY = y2;\\n        \\n\\t\\t// Get distances from closest edges\\n        double dx = x_center - testX;\\n        double dy = y_center - testY;\\n        \\n\\t\\t// Apply pythagoras to see if the distance is less than the radius\\n        return (dx * dx + dy * dy) <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nx1 = left vertical\\nx2 = right vertical\\ny1 = bottom horizontal\\ny2 = top horizontal\\n```\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\t\\t// Temporary variables to set edges for testing\\n        int testX = x_center;\\n        int testY = y_center;\\n\\t\\t// First, we find the closest edge.\\n\\t\\t// If rectange\\'s left edge is on the right on the circle, then it must be closest vertical edge to the circle\\n        if(x_center < x1) testX = x1;\\n        else if(x_center > x2) testX = x2;\\n\\t\\t\\n\\t\\t// If rectangle\\'s bottom horizontal edge is above the circle, then it must be the closest horizontal edge to the circle \\n        if(y_center < y1) testY = y1;\\n        else if(y_center > y2) testY = y2;\\n        \\n\\t\\t// Get distances from closest edges\\n        double dx = x_center - testX;\\n        double dy = y_center - testY;\\n        \\n\\t\\t// Apply pythagoras to see if the distance is less than the radius\\n        return (dx * dx + dy * dy) <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563418,
                "title": "c-the-cycle-of-function-to-solve-it",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        for(int i=x1;i<=x2;i++){\\n            for(int j=y1;j<=y2;j++){\\n                if(pow(i-xc,2)+pow(j-yc,2)<=pow(r,2)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        for(int i=x1;i<=x2;i++){\\n            for(int j=y1;j<=y2;j++){\\n                if(pow(i-xc,2)+pow(j-yc,2)<=pow(r,2)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563398,
                "title": "clean-python-3-straightforward-o-1",
                "content": "- Case 1: The circle is in the retangle\\n- Case 2: The circle is cut by the retangle\\n- Case 3: The circle overlaps a corner of the retangle\\n\\nTime: `O(1)`\\nSpace: `O(1)`\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        def in_circle(x, y):\\n            return (x - x_center) ** 2 + (y - y_center) ** 2 <= radius ** 2\\n\\n        # case 1\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2: return True\\n\\t\\t\\n        left, right = x_center - radius, x_center + radius\\n        bottom, top = y_center - radius, y_center + radius\\n        x_overlap = left <= x2 and x1 <= right\\n        y_overlap = bottom <= y2 and y1 <= top\\n        if not x_overlap or not y_overlap: return False\\n\\n\\t\\t# case 2\\n        if x1 <= left <= right <= x2 or y1 <= bottom <= top <= y2: return True\\n        if left <= x1 <= x2 <= right or bottom <= y1 <= y2 <= top: return True\\n\\n        # case 3\\n        left_top, left_bottom = (x1, y2), (x1, y1)\\n        right_top, right_bottom = (x2, y2), (x2, y1)\\n        return any(in_circle(x, y) for x, y in (left_top, left_bottom, right_top, right_bottom))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        def in_circle(x, y):\\n            return (x - x_center) ** 2 + (y - y_center) ** 2 <= radius ** 2\\n\\n        # case 1\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2: return True\\n\\t\\t\\n        left, right = x_center - radius, x_center + radius\\n        bottom, top = y_center - radius, y_center + radius\\n        x_overlap = left <= x2 and x1 <= right\\n        y_overlap = bottom <= y2 and y1 <= top\\n        if not x_overlap or not y_overlap: return False\\n\\n\\t\\t# case 2\\n        if x1 <= left <= right <= x2 or y1 <= bottom <= top <= y2: return True\\n        if left <= x1 <= x2 <= right or bottom <= y1 <= y2 <= top: return True\\n\\n        # case 3\\n        left_top, left_bottom = (x1, y2), (x1, y1)\\n        right_top, right_bottom = (x2, y2), (x2, y1)\\n        return any(in_circle(x, y) for x, y in (left_top, left_bottom, right_top, right_bottom))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563380,
                "title": "o-1-time-and-space-only-integer-math-explanation",
                "content": "```C++\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        // inside vertical bounds of rectangle\\n        if (x1 - r <= xc && xc <= x2 + r && y1 <= yc && yc <= y2) {\\n            return true; \\n        }\\n        // inside horizontal bounds of rectangle\\n        if (x1<= xc && xc <= x2 && y1 - r  <= yc && yc <= y2 + r) \\n            return true; \\n        \\n        vector<int> x = {x1,x2};\\n        vector<int> y = {y1,y2};\\n\\n        // or near one of the 4 points\\n        for (int ix = 0;ix < 2;ix++) {\\n            for (int iy = 0;iy < 2; iy++) {\\n                int dx = xc - x[ix];\\n                int dy = yc - y[iy];\\n                if (dx * dx + dy * dy <= r*r)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```C++\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        // inside vertical bounds of rectangle\\n        if (x1 - r <= xc && xc <= x2 + r && y1 <= yc && yc <= y2) {\\n            return true; \\n        }\\n        // inside horizontal bounds of rectangle\\n        if (x1<= xc && xc <= x2 && y1 - r  <= yc && yc <= y2 + r) \\n            return true; \\n        \\n        vector<int> x = {x1,x2};\\n        vector<int> y = {y1,y2};\\n\\n        // or near one of the 4 points\\n        for (int ix = 0;ix < 2;ix++) {\\n            for (int iy = 0;iy < 2; iy++) {\\n                int dx = xc - x[ix];\\n                int dy = yc - y[iy];\\n                if (dx * dx + dy * dy <= r*r)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563325,
                "title": "c-simple-o-1-time-circle-rectangle-intersection-borders-inside-and-tangents-as-sides",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int x_c, int y_c, int x1, int y1, int x2, int y2) {\\n        if(x1 <= x_c && x_c <= x2)\\n        {\\n            if(y1 <= y_c && y_c <= y2)\\n                return 1;\\n        }\\n        \\n        double a = r * r - (x_c - x1)*(x_c - x1) - (y_c - y1) * (y_c - y1);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }\\n        a = r * r - (x_c - x2)*(x_c - x2) - (y_c - y2) * (y_c - y2);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }\\n        a = r * r - (y_c - y1)*(y_c - y1)  - (x_c - x2)*(x_c - x2);\\n        if(a >= 0.0)\\n        {\\n           return 1;\\n        }\\n        a = r * r - (y_c - y2)*(y_c - y2) - (x_c - x1)*(x_c - x1);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }           \\n        \\n        a = r * r - (x_c - x1)*(x_c - x1);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = y_c + a, cy2 = y_c - a;\\n            if((cy >= y1 && cy <= y2) || (cy2 >= y1 && cy2 <= y2))\\n                return 1;\\n        }\\n        a = r * r - (x_c - x2)*(x_c - x2);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = y_c + a, cy2 = y_c - a;\\n            if((cy >= y1 && cy <= y2) || (cy2 >= y1 && cy2 <= y2))\\n                return 1;\\n        }\\n        a = r * r - (y_c - y1)*(y_c - y1);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = x_c + a, cy2 = x_c - a;\\n            if((cy >= x1 && cy <= x2) || (cy2 >= x1 && cy2 <= x2))\\n                return 1;\\n        }\\n        a = r * r - (y_c - y2)*(y_c - y2);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = x_c + a, cy2 = x_c - a;\\n            if((cy >= x1 && cy <= x2) || (cy2 >= x1 && cy2 <= x2))\\n                return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int x_c, int y_c, int x1, int y1, int x2, int y2) {\\n        if(x1 <= x_c && x_c <= x2)\\n        {\\n            if(y1 <= y_c && y_c <= y2)\\n                return 1;\\n        }\\n        \\n        double a = r * r - (x_c - x1)*(x_c - x1) - (y_c - y1) * (y_c - y1);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }\\n        a = r * r - (x_c - x2)*(x_c - x2) - (y_c - y2) * (y_c - y2);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }\\n        a = r * r - (y_c - y1)*(y_c - y1)  - (x_c - x2)*(x_c - x2);\\n        if(a >= 0.0)\\n        {\\n           return 1;\\n        }\\n        a = r * r - (y_c - y2)*(y_c - y2) - (x_c - x1)*(x_c - x1);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }           \\n        \\n        a = r * r - (x_c - x1)*(x_c - x1);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = y_c + a, cy2 = y_c - a;\\n            if((cy >= y1 && cy <= y2) || (cy2 >= y1 && cy2 <= y2))\\n                return 1;\\n        }\\n        a = r * r - (x_c - x2)*(x_c - x2);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = y_c + a, cy2 = y_c - a;\\n            if((cy >= y1 && cy <= y2) || (cy2 >= y1 && cy2 <= y2))\\n                return 1;\\n        }\\n        a = r * r - (y_c - y1)*(y_c - y1);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = x_c + a, cy2 = x_c - a;\\n            if((cy >= x1 && cy <= x2) || (cy2 >= x1 && cy2 <= x2))\\n                return 1;\\n        }\\n        a = r * r - (y_c - y2)*(y_c - y2);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = x_c + a, cy2 = x_c - a;\\n            if((cy >= x1 && cy <= x2) || (cy2 >= x1 && cy2 <= x2))\\n                return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005966,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n      final miniX = max(x1, min(x2, xCenter));\\n      final miniY = max(y1, min(y2, yCenter));\\n      final distance = sqrt(pow(miniX - xCenter, 2) + pow(miniY - yCenter, 2)).toInt();\\n      return distance <= radius;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n      final miniX = max(x1, min(x2, xCenter));\\n      final miniY = max(y1, min(y2, yCenter));\\n      final distance = sqrt(pow(miniX - xCenter, 2) + pow(miniY - yCenter, 2)).toInt();\\n      return distance <= radius;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999409,
                "title": "100-beast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n                \\n        int closestX = Math.max(x1, Math.min(xCenter, x2));\\n        int closestY = Math.max(y1, Math.min(yCenter, y2));\\n        \\n        \\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        \\n        int squaredDistance = distanceX * distanceX + distanceY * distanceY;\\n        \\n        return squaredDistance <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n                \\n        int closestX = Math.max(x1, Math.min(xCenter, x2));\\n        int closestY = Math.max(y1, Math.min(yCenter, y2));\\n        \\n        \\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        \\n        int squaredDistance = distanceX * distanceX + distanceY * distanceY;\\n        \\n        return squaredDistance <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979494,
                "title": "my-solution",
                "content": "```\\n/**\\n * if the circle and the rectangle overlaps,\\n * there must exist a point (`x`, `y`) in the rectangle such that\\n * the distance from the point (`x`, `y`) to the center (`xCenter`, `yCenter`) of the circle\\n * is less than or equal to the length of the radius `radius`, that is,\\n * (`x` - `xCenter`) * (`x` - `xCenter`) + (`y` - `yCenter`) * (`y` - `yCenter`) <= `radius` * `radius`\\n * so the target is,\\n * 1. find a `x` in the range [`x1`, `x2`], both inclusive,\\n *    such that (`x` - `xCenter`) * (`x` - `xCenter`) is minimum\\n * 2. find a `y` in the range [`y1`, `y2`], both inclusive,\\n *    such that (`y` - `yCenter`) * (`y` - `yCenter`) is minimum\\n * if (`x` - `xCenter`) * (`x` - `xCenter`) + (`y` - `yCenter`) * (`y` - `yCenter`) <= `radius` * `radius`\\n * return true\\n * otherwise, return false\\n *\\n * the logic of finding the `x` in the range [`x1`, `x2`], both inclusive, such that\\n * (`x` - `xCenter`) * (`x` - `xCenter`) is minimum is as following,\\n * 1. if `xCenter` is in the range [`x1`, `x2`], both inclusive,\\n *    `x` should be equal to `xCenter`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is zero\\n * 2. if `xCenter` is less than `x1`, `x` should be equal to `x1`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is equal to (`x1` - `xCenter`) * (`x1` - `xCenter`)\\n * 3. if `xCenter` is greater than `x2`, `x` should be equal to `x2`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is equal to (`x2` - `xCenter`) * (`x2` - `xCenter`)\\n *\\n * the logic of finding the `y` in the range [`y1`, `y2`], both inclusive, such that\\n * (`y` - `yCenter`) * (`y` - `yCenter`) is minimum is similar with the logic of doing `x`,\\n *\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  bool checkOverlap(const int radius,\\n                    const int xCenter,\\n                    const int yCenter,\\n                    const int x1,\\n                    const int y1,\\n                    const int x2,\\n                    const int y2) {\\n    return min_distance(xCenter, x1, x2) + min_distance(yCenter, y1, y2) <= power2(radius);\\n  }\\n  \\n private:\\n  int min_distance(const int center, const int a1, const int a2) {\\n    if (center < a1) {\\n      return power2(a1 - center);\\n    }\\n    if (center > a2) {\\n      return power2(center - a2);\\n    }\\n    return 0;\\n  }\\n  \\n  int power2(const int a) {\\n    return a * a;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * if the circle and the rectangle overlaps,\\n * there must exist a point (`x`, `y`) in the rectangle such that\\n * the distance from the point (`x`, `y`) to the center (`xCenter`, `yCenter`) of the circle\\n * is less than or equal to the length of the radius `radius`, that is,\\n * (`x` - `xCenter`) * (`x` - `xCenter`) + (`y` - `yCenter`) * (`y` - `yCenter`) <= `radius` * `radius`\\n * so the target is,\\n * 1. find a `x` in the range [`x1`, `x2`], both inclusive,\\n *    such that (`x` - `xCenter`) * (`x` - `xCenter`) is minimum\\n * 2. find a `y` in the range [`y1`, `y2`], both inclusive,\\n *    such that (`y` - `yCenter`) * (`y` - `yCenter`) is minimum\\n * if (`x` - `xCenter`) * (`x` - `xCenter`) + (`y` - `yCenter`) * (`y` - `yCenter`) <= `radius` * `radius`\\n * return true\\n * otherwise, return false\\n *\\n * the logic of finding the `x` in the range [`x1`, `x2`], both inclusive, such that\\n * (`x` - `xCenter`) * (`x` - `xCenter`) is minimum is as following,\\n * 1. if `xCenter` is in the range [`x1`, `x2`], both inclusive,\\n *    `x` should be equal to `xCenter`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is zero\\n * 2. if `xCenter` is less than `x1`, `x` should be equal to `x1`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is equal to (`x1` - `xCenter`) * (`x1` - `xCenter`)\\n * 3. if `xCenter` is greater than `x2`, `x` should be equal to `x2`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is equal to (`x2` - `xCenter`) * (`x2` - `xCenter`)\\n *\\n * the logic of finding the `y` in the range [`y1`, `y2`], both inclusive, such that\\n * (`y` - `yCenter`) * (`y` - `yCenter`) is minimum is similar with the logic of doing `x`,\\n *\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  bool checkOverlap(const int radius,\\n                    const int xCenter,\\n                    const int yCenter,\\n                    const int x1,\\n                    const int y1,\\n                    const int x2,\\n                    const int y2) {\\n    return min_distance(xCenter, x1, x2) + min_distance(yCenter, y1, y2) <= power2(radius);\\n  }\\n  \\n private:\\n  int min_distance(const int center, const int a1, const int a2) {\\n    if (center < a1) {\\n      return power2(a1 - center);\\n    }\\n    if (center > a2) {\\n      return power2(center - a2);\\n    }\\n    return 0;\\n  }\\n  \\n  int power2(const int a) {\\n    return a * a;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973873,
                "title": "java-soln-using-mathematical-equation-and-wavy-curve-method",
                "content": "# Code\\n```\\nclass Solution {\\n    public static class Pair{\\n        double first;\\n        double second;\\n        public Pair(double first,double second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    public Pair getSolution(int a,int b,int c){\\n        int d = b*b - 4 * a * c;\\n        if(d < 0) return new Pair(Integer.MIN_VALUE,Integer.MIN_VALUE);\\n        double s1 = (-b + Math.sqrt(d)) / 2.0 * a;\\n        double s2 = (-b - Math.sqrt(d)) / 2.0 * a;\\n        return new Pair(s1,s2);\\n    }\\n    public boolean checkRange(double s1,double s2,double r1,double r2){\\n       double x = Math.max(r1,r2);\\n       double y = Math.min(r1,r2);\\n       return !(x < s1 || y > s2);\\n    }\\n\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        //We can have equation of circle and substitue the rectangle boundaries to verify\\n        if(xCenter >= x1 && xCenter <= x2 && yCenter >= y1 && yCenter <= y2){\\n            return true;\\n        }\\n        Pair p1 = getSolution(1,-2*yCenter,(x1-xCenter) * (x1-xCenter) - radius*radius + yCenter * yCenter);\\n        Pair p2 = getSolution(1,-2*yCenter,(x2-xCenter) * (x2-xCenter) - radius*radius + yCenter * yCenter);\\n        Pair p3 = getSolution(1,-2*xCenter,(y1-yCenter) * (y1-yCenter) - radius*radius + xCenter * xCenter); \\n        Pair p4 = getSolution(1,-2*xCenter,(y2-yCenter) * (y2-yCenter) - radius*radius + xCenter * xCenter);\\n\\n        return checkRange(Math.min(p1.first,p1.second),Math.max(p1.first,p1.second),y1,y2) || \\n               checkRange(Math.min(p2.first,p2.second),Math.max(p2.first,p2.second),y1,y2) ||\\n               checkRange(Math.min(p3.first,p3.second),Math.max(p3.first,p3.second),x1,x2) ||\\n               checkRange(Math.min(p4.first,p4.second),Math.max(p4.first,p4.second),x1,x2); \\n   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static class Pair{\\n        double first;\\n        double second;\\n        public Pair(double first,double second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    public Pair getSolution(int a,int b,int c){\\n        int d = b*b - 4 * a * c;\\n        if(d < 0) return new Pair(Integer.MIN_VALUE,Integer.MIN_VALUE);\\n        double s1 = (-b + Math.sqrt(d)) / 2.0 * a;\\n        double s2 = (-b - Math.sqrt(d)) / 2.0 * a;\\n        return new Pair(s1,s2);\\n    }\\n    public boolean checkRange(double s1,double s2,double r1,double r2){\\n       double x = Math.max(r1,r2);\\n       double y = Math.min(r1,r2);\\n       return !(x < s1 || y > s2);\\n    }\\n\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        //We can have equation of circle and substitue the rectangle boundaries to verify\\n        if(xCenter >= x1 && xCenter <= x2 && yCenter >= y1 && yCenter <= y2){\\n            return true;\\n        }\\n        Pair p1 = getSolution(1,-2*yCenter,(x1-xCenter) * (x1-xCenter) - radius*radius + yCenter * yCenter);\\n        Pair p2 = getSolution(1,-2*yCenter,(x2-xCenter) * (x2-xCenter) - radius*radius + yCenter * yCenter);\\n        Pair p3 = getSolution(1,-2*xCenter,(y1-yCenter) * (y1-yCenter) - radius*radius + xCenter * xCenter); \\n        Pair p4 = getSolution(1,-2*xCenter,(y2-yCenter) * (y2-yCenter) - radius*radius + xCenter * xCenter);\\n\\n        return checkRange(Math.min(p1.first,p1.second),Math.max(p1.first,p1.second),y1,y2) || \\n               checkRange(Math.min(p2.first,p2.second),Math.max(p2.first,p2.second),y1,y2) ||\\n               checkRange(Math.min(p3.first,p3.second),Math.max(p3.first,p3.second),x1,x2) ||\\n               checkRange(Math.min(p4.first,p4.second),Math.max(p4.first,p4.second),x1,x2); \\n   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951300,
                "title": "java-in-0ms-is-point-in-rounded-rectangle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing principles of *Mathematical Morphology* (geometric properties of point sets) we can convert the problem of seeing whether the circle is inside the rectangle to one of seeing whether a point -- the center of the circle -- is inside a \"rounded\" rectangle -- the starting rectangle, expanded by \"radius\" in all directions, then rounding the resulting corners by \"radius\".  This, in turn, can be converted to the problem of seeing whether the point fits in the original rectangle, or a cross shape formed by expanding the rectangle independently up and down, and right and left, OR in circles of \"radius\" centered at the original rectangle corners.\\n\\nNote in passing that this same logic can be applied not only to a rectangle but to any convex polygon.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses two subfunctions, one that sees whether a point fits in a rectangle and the other that sees whether a point fits in a circle.  These are applied using the logic in Intution in the main function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe run time depends on the number of vertices which, being fixed, means the time complexity is $$O(1)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince all variables, arguments, and result are scalars, the space complexity is $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        // Check against rectangle:\\n        if ( isPointInRectangle( xCenter, yCenter, x1, y1, x2, y2 ) )\\n            return true;\\n        // Check against North and South walls and square\\n        if ( isPointInRectangle( xCenter, yCenter, x1, y1 - radius, x2, y2 + radius ) ||\\n        // Check against West and East walls and square\\n             isPointInRectangle( xCenter, yCenter, x1 - radius, y1, x2 + radius, y2 ) )\\n            return true;\\n        // check against corner circles:\\n        int[] xrange = { x1, x2 }, yrange = { y1, y2 };\\n        for ( int x : xrange )\\n            for ( int y : yrange )\\n                if ( isPointInCircle( xCenter, yCenter, x, y, radius ) )\\n                    return true;\\n        return false;\\n\\n    }\\n    private boolean isPointInRectangle( int px, int py, int rxlo, int rylo, int rxhi, int ryhi ) {\\n        return px >= rxlo && px <= rxhi && py >= rylo && py <= ryhi;\\n    }\\n    private boolean isPointInCircle( int px, int py, int ccx, int ccy, int radius ) {\\n        return ( ccx - px ) * (ccx - px ) + (ccy - py ) * ( ccy - py ) <= radius * radius;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        // Check against rectangle:\\n        if ( isPointInRectangle( xCenter, yCenter, x1, y1, x2, y2 ) )\\n            return true;\\n        // Check against North and South walls and square\\n        if ( isPointInRectangle( xCenter, yCenter, x1, y1 - radius, x2, y2 + radius ) ||\\n        // Check against West and East walls and square\\n             isPointInRectangle( xCenter, yCenter, x1 - radius, y1, x2 + radius, y2 ) )\\n            return true;\\n        // check against corner circles:\\n        int[] xrange = { x1, x2 }, yrange = { y1, y2 };\\n        for ( int x : xrange )\\n            for ( int y : yrange )\\n                if ( isPointInCircle( xCenter, yCenter, x, y, radius ) )\\n                    return true;\\n        return false;\\n\\n    }\\n    private boolean isPointInRectangle( int px, int py, int rxlo, int rylo, int rxhi, int ryhi ) {\\n        return px >= rxlo && px <= rxhi && py >= rylo && py <= ryhi;\\n    }\\n    private boolean isPointInCircle( int px, int py, int ccx, int ccy, int radius ) {\\n        return ( ccx - px ) * (ccx - px ) + (ccy - py ) * ( ccy - py ) <= radius * radius;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946374,
                "title": "2-solutions-explained",
                "content": "**9 points that cover all testcases**\\nIn this solutions I tried to identify all core testcases and find a relatively small number of points that can handle them (test driven developement so to speak).\\nThe only operations I wanted to use is a check whether these points belong to a rectangle and a circle. I iteratively added the points, eliminating core testcases and solving them. I started from the cornerpoints then added the centerpoint then added the rest four projections.\\n\\n![image](https://assets.leetcode.com/users/images/a80c56cf-3a71-462c-8f5a-f39b4cab9ed7_1692734806.4796188.png)\\n\\n**Algo:**\\nTake cartesian product of sets `{x,x1,x2}` and `{y,y1,y2}`: \\n`{x,x1,x2} x {y,y1,y2}={(x,y), (x,y1), (x, y2), (x1,y), (x1,y1), (x1, y2), (x2,y), (x2,y1), (x2, y2)}`\\nto obtain the set of 9 2d points.  These points are:\\n* 1 center of the circle;\\n* 4 vertices of the rectangle;\\n* 4 projections of the  vertices of the rectangle to the `xy` axes that pass through the center of the circle.\\n\\nCheck if **any** of the points belongs to the rectangle **and** the circle.\\n\\n![image](https://assets.leetcode.com/users/images/8a412389-8ba6-4efc-a315-a38c7eeae05a_1692729751.8346817.png)\\n\\n```\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n{\\n\\tauto f = [&](int a, int b){ return (x-a)*(x-a)+(y-b)*(y-b)<=r*r and a>=x1 and a<=x2 and b>=y1 and b<=y2; };   \\n\\treturn f(x,y) or f(x1,y) or f(x2,y) or f(x,y1) or f(x1,y1) or f(x2,y1) or f(x,y2) or f(x1,y2) or f(x2,y2);\\n}\\n```\\nAs you can see on the picture it\\'s always the **\"middlepoint\"** that is really important thus you can check only this point! So the next solution does precisely that.\\n\\n**magic of `min/max`**\\n**Algo:**\\n* from the set `{x,x1,x2}` pick the middle point (Iet\\'s call it `xm`);\\n* from the set `{x,x1,x2}` pick the middle point (Iet\\'s call it `ym`);\\n* check that `(xm, ym)` lies inside the circle. \\n\\nWhy `(xm, ym)` is important? Because this the point of rectangle closest to the center of the circle!\\n\\n![image](https://assets.leetcode.com/users/images/ed511959-a5b6-4fdf-8196-3874b86052cf_1692728689.7014942.png)\\n\\n```\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n{\\n\\tint xm = min(max(x, x1), x2),\\n\\t\\tym = min(max(y, y1), y2);\\n\\treturn (x-xm)*(x-xm)+(y-ym)*(y-ym)<=r*r;\\n}\\n```\\nWhy `min/max (\\u2227/\\u2228)` are magical ? Because they form an algebra and can sort numbers just by their succesive application. Check this out:\\n[2733. Neither Minimum nor Maximum](https://leetcode.com/problems/neither-minimum-nor-maximum/discuss/3625141/1-liner?currentPage=1&orderBy=most_relevant&query=android)\\n\\nAnother problem about intersections:\\n[836. Rectangle Overlap](https://leetcode.com/problems/rectangle-overlap/discuss/3947417/ok)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n{\\n\\tauto f = [&](int a, int b){ return (x-a)*(x-a)+(y-b)*(y-b)<=r*r and a>=x1 and a<=x2 and b>=y1 and b<=y2; };   \\n\\treturn f(x,y) or f(x1,y) or f(x2,y) or f(x,y1) or f(x1,y1) or f(x2,y1) or f(x,y2) or f(x1,y2) or f(x2,y2);\\n}\\n```\n```\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n{\\n\\tint xm = min(max(x, x1), x2),\\n\\t\\tym = min(max(y, y1), y2);\\n\\treturn (x-xm)*(x-xm)+(y-ym)*(y-ym)<=r*r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946028,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1,\\n                    int x2, int y2) {\\n    auto clamp = [&](int center, int mini, int maxi) {\\n      return max(mini, min(maxi, center));\\n    };\\n\\n    // The closest point to the circle within the rectangle\\n    int closestX = clamp(x_center, x1, x2);\\n    int closestY = clamp(y_center, y1, y2);\\n\\n    // The distance between the circle\\'s center and this closest point\\n    int distanceX = x_center - closestX;\\n    int distanceY = y_center - closestY;\\n\\n    // If the distance is less than the circle\\'s radius, an intersection occurs\\n    return (distanceX * distanceX) + (distanceY * distanceY) <=\\n           (radius * radius);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1,\\n                    int x2, int y2) {\\n    auto clamp = [&](int center, int mini, int maxi) {\\n      return max(mini, min(maxi, center));\\n    };\\n\\n    // The closest point to the circle within the rectangle\\n    int closestX = clamp(x_center, x1, x2);\\n    int closestY = clamp(y_center, y1, y2);\\n\\n    // The distance between the circle\\'s center and this closest point\\n    int distanceX = x_center - closestX;\\n    int distanceY = y_center - closestY;\\n\\n    // If the distance is less than the circle\\'s radius, an intersection occurs\\n    return (distanceX * distanceX) + (distanceY * distanceY) <=\\n           (radius * radius);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934610,
                "title": "c-simple-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n  bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1,\\n                    int x2, int y2) {\\n    if (xCenter + radius < x1 || xCenter - radius > x2) return false;\\n    if (yCenter + radius < y1 || yCenter - radius > y2) return false;\\n    if (xCenter < x1 && yCenter > y2 && out(x1, y2, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter > x2 && yCenter > y2 && out(x2, y2, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter < x1 && yCenter < y1 && out(x1, y1, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter > x2 && yCenter < y1 && out(x2, y1, xCenter, yCenter, radius))\\n      return false;\\n    return true;\\n  }\\n\\n  private:\\n  inline bool out(int x, int y, int xCenter, int yCenter, int radius) {\\n#define SQUARE(x) (x) * (x)\\n    return SQUARE(x - xCenter) + SQUARE(y - yCenter) > SQUARE(radius);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n  bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1,\\n                    int x2, int y2) {\\n    if (xCenter + radius < x1 || xCenter - radius > x2) return false;\\n    if (yCenter + radius < y1 || yCenter - radius > y2) return false;\\n    if (xCenter < x1 && yCenter > y2 && out(x1, y2, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter > x2 && yCenter > y2 && out(x2, y2, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter < x1 && yCenter < y1 && out(x1, y1, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter > x2 && yCenter < y1 && out(x2, y1, xCenter, yCenter, radius))\\n      return false;\\n    return true;\\n  }\\n\\n  private:\\n  inline bool out(int x, int y, int xCenter, int yCenter, int radius) {\\n#define SQUARE(x) (x) * (x)\\n    return SQUARE(x - xCenter) + SQUARE(y - yCenter) > SQUARE(radius);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848126,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xCentre, int yCentre, int x1, int y1, int x2, int y2) {\\n        \\n        int x,y;\\n\\n        if(x1<=xCentre && x2>=xCentre) x = 0;\\n        else x = Math.min(Math.abs(x1-xCentre),Math.abs(x2-xCentre));\\n\\n        if(y1<=yCentre && y2>=yCentre) y = 0;\\n        else y = Math.min(Math.abs(y1-yCentre),Math.abs(y2-yCentre));\\n\\n        if(x*x + y*y <= r*r) return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xCentre, int yCentre, int x1, int y1, int x2, int y2) {\\n        \\n        int x,y;\\n\\n        if(x1<=xCentre && x2>=xCentre) x = 0;\\n        else x = Math.min(Math.abs(x1-xCentre),Math.abs(x2-xCentre));\\n\\n        if(y1<=yCentre && y2>=yCentre) y = 0;\\n        else y = Math.min(Math.abs(y1-yCentre),Math.abs(y2-yCentre));\\n\\n        if(x*x + y*y <= r*r) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716856,
                "title": "golang-simple-solution",
                "content": "# Code\\n```\\nfunc checkOverlap(radius int, xCenter int, yCenter int, x1 int, y1 int, x2 int, y2 int) bool {\\n  // We\\'re going to check if any point on the rectangle\\'s side is within the circle\\n  r2 := radius * radius\\n  xMin, yMin := min(x1, x2), min(y1, y2)\\n  xMax, yMax := max(x1, x2), max(y1, y2)\\n\\n  // Check if the circle is inside the rectangle\\n  if xCenter >= xMin && xCenter <= xMax && yCenter >= yMin && yCenter <= yMax {\\n    return true\\n  }\\n\\n  // Check if one of the sides of the rectangle is within the rectangle\\n  for x := xMin; x <= xMax; x++ {\\n    if (x - xCenter) *  (x - xCenter) + (yMin - yCenter) * (yMin - yCenter) <= r2 {\\n      return true\\n    }\\n    if (x - xCenter) *  (x - xCenter) + (yMax - yCenter) * (yMax - yCenter) <= r2 {\\n      return true\\n    }\\n  }\\n  for y := yMin; y <= yMax; y++ {\\n    if (xMin - xCenter) * (xMin - xCenter) + (y - yCenter) * (y - yCenter) <= r2 {\\n      return true\\n    }\\n    if (xMax - xCenter) * (xMax - xCenter) + (y - yCenter) * (y - yCenter) <= r2 {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkOverlap(radius int, xCenter int, yCenter int, x1 int, y1 int, x2 int, y2 int) bool {\\n  // We\\'re going to check if any point on the rectangle\\'s side is within the circle\\n  r2 := radius * radius\\n  xMin, yMin := min(x1, x2), min(y1, y2)\\n  xMax, yMax := max(x1, x2), max(y1, y2)\\n\\n  // Check if the circle is inside the rectangle\\n  if xCenter >= xMin && xCenter <= xMax && yCenter >= yMin && yCenter <= yMax {\\n    return true\\n  }\\n\\n  // Check if one of the sides of the rectangle is within the rectangle\\n  for x := xMin; x <= xMax; x++ {\\n    if (x - xCenter) *  (x - xCenter) + (yMin - yCenter) * (yMin - yCenter) <= r2 {\\n      return true\\n    }\\n    if (x - xCenter) *  (x - xCenter) + (yMax - yCenter) * (yMax - yCenter) <= r2 {\\n      return true\\n    }\\n  }\\n  for y := yMin; y <= yMax; y++ {\\n    if (xMin - xCenter) * (xMin - xCenter) + (y - yCenter) * (y - yCenter) <= r2 {\\n      return true\\n    }\\n    if (xMax - xCenter) * (xMax - xCenter) + (y - yCenter) * (y - yCenter) <= r2 {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3707131,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    const xEdge = Math.max(x1, Math.min(x2, xCenter));\\n    const yEdge = Math.max(y1, Math.min(y2, yCenter));\\n    const xDistance = xCenter - xEdge;\\n    const yDistance = yCenter - yEdge;\\n\\n    return xDistance ** 2 + yDistance ** 2 <= radius ** 2\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    const xEdge = Math.max(x1, Math.min(x2, xCenter));\\n    const yEdge = Math.max(y1, Math.min(y2, yCenter));\\n    const xDistance = xCenter - xEdge;\\n    const yDistance = yCenter - yEdge;\\n\\n    return xDistance ** 2 + yDistance ** 2 <= radius ** 2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439433,
                "title": "o-radius",
                "content": "```ruby\\ndef check_overlap r, x, y, x1, y1, x2, y2\\n    r2, rw, rh = r * r, x1..x2, y1..y2\\n    for h in 0..r\\n        w = Integer.sqrt r2 - h * h\\n        cw = x - w..x + w\\n        a, b = *(rw.begin < cw.begin ? [rw, cw] : [cw, rw])\\n        if b.begin <= a.end && (rh === y + h || rh === y - h)\\n            return true\\n        end\\n    end\\n    false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef check_overlap r, x, y, x1, y1, x2, y2\\n    r2, rw, rh = r * r, x1..x2, y1..y2\\n    for h in 0..r\\n        w = Integer.sqrt r2 - h * h\\n        cw = x - w..x + w\\n        a, b = *(rw.begin < cw.begin ? [rw, cw] : [cw, rw])\\n        if b.begin <= a.end && (rh === y + h || rh === y - h)\\n            return true\\n        end\\n    end\\n    false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3370592,
                "title": "python-easy-geometry",
                "content": "First we have to find the nearest point on the rectangle to the center of the circle. Calculate the distance between the center of the circle with the nearest x and y coordinates. We can check the intersection by using pythagorean theorem. A point lies inside the circle if distance < radius. A point lies on the circle if d = radius. \\nSo we return check if distance <= radius. \\n\\n# Code\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        nearest_x = max(x1, min(x2, xCenter))\\n        nearest_y = max(y1, min(y2, yCenter))\\n        dist_x = nearest_x - xCenter\\n        dist_y = nearest_y - yCenter\\n\\n        return dist_x ** 2 + dist_y ** 2 <= radius ** 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        nearest_x = max(x1, min(x2, xCenter))\\n        nearest_y = max(y1, min(y2, yCenter))\\n        dist_x = nearest_x - xCenter\\n        dist_y = nearest_y - yCenter\\n\\n        return dist_x ** 2 + dist_y ** 2 <= radius ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353919,
                "title": "antarnab-java-2lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323768,
                "title": "java-using-basic-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109398,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        let x = if x_center < x1 {\\n            x1\\n        } else if x_center > x2 {\\n            x2\\n        } else {\\n            x_center\\n        };\\n        let y = if y_center < y1 {\\n            y1\\n        } else if y_center > y2 {\\n            y2\\n        } else {\\n            y_center\\n        };\\n        let dx = x_center - x;\\n        let dy = y_center - y;\\n        dx * dx + dy * dy <= radius * radius\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        let x = if x_center < x1 {\\n            x1\\n        } else if x_center > x2 {\\n            x2\\n        } else {\\n            x_center\\n        };\\n        let y = if y_center < y1 {\\n            y1\\n        } else if y_center > y2 {\\n            y2\\n        } else {\\n            y_center\\n        };\\n        let dx = x_center - x;\\n        let dy = y_center - y;\\n        dx * dx + dy * dy <= radius * radius\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3103448,
                "title": "c-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought on how to solve this problem is to find the closest edge of the rectangle to the circle\\'s center, and then check if the distance between them is less than or equal to the radius. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, I will first check if the circle\\'s center is inside the rectangle. If so, then it is definitely overlapping. If not, I will find the closest edge of the rectangle to the circle\\'s center and check the distance between them. If the distance is less than or equal to the radius, then the circle and the rectangle overlap, otherwise they don\\'t overlap. \\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        if (xCenter >= x1 && xCenter <= x2 && yCenter >= y1 && yCenter <= y2) {\\n            return true;\\n        }\\n        if (xCenter < x1) {\\n            if (yCenter < y1) {\\n                return (xCenter - x1) * (xCenter - x1) + (yCenter - y1) * (yCenter - y1) <= radius * radius;\\n            } else if (yCenter > y2) {\\n                return (xCenter - x1) * (xCenter - x1) + (yCenter - y2) * (yCenter - y2) <= radius * radius;\\n            } else {\\n                return x1 - xCenter <= radius;\\n            }\\n        } else if (xCenter > x2) {\\n            if (yCenter < y1) {\\n                return (xCenter - x2) * (xCenter - x2) + (yCenter - y1) * (yCenter - y1) <= radius * radius;\\n            } else if (yCenter > y2) {\\n                return (xCenter - x2) * (xCenter - x2) + (yCenter - y2) * (yCenter - y2) <= radius * radius;\\n            } else {\\n                return xCenter - x2 <= radius;\\n            }\\n        } else {\\n            if (yCenter < y1) {\\n                return y1 - yCenter <= radius;\\n            } else if (yCenter > y2) {\\n                return yCenter - y2 <= radius;\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        if (xCenter >= x1 && xCenter <= x2 && yCenter >= y1 && yCenter <= y2) {\\n            return true;\\n        }\\n        if (xCenter < x1) {\\n            if (yCenter < y1) {\\n                return (xCenter - x1) * (xCenter - x1) + (yCenter - y1) * (yCenter - y1) <= radius * radius;\\n            } else if (yCenter > y2) {\\n                return (xCenter - x1) * (xCenter - x1) + (yCenter - y2) * (yCenter - y2) <= radius * radius;\\n            } else {\\n                return x1 - xCenter <= radius;\\n            }\\n        } else if (xCenter > x2) {\\n            if (yCenter < y1) {\\n                return (xCenter - x2) * (xCenter - x2) + (yCenter - y1) * (yCenter - y1) <= radius * radius;\\n            } else if (yCenter > y2) {\\n                return (xCenter - x2) * (xCenter - x2) + (yCenter - y2) * (yCenter - y2) <= radius * radius;\\n            } else {\\n                return xCenter - x2 <= radius;\\n            }\\n        } else {\\n            if (yCenter < y1) {\\n                return y1 - yCenter <= radius;\\n            } else if (yCenter > y2) {\\n                return yCenter - y2 <= radius;\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061816,
                "title": "python-4-line-o-1-solution",
                "content": "```\\ndef checkOverlap(self, d: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:   \\n\\tcorners = [(x1, y1), (x2, y1), (x1, y2), (x2, y2)]\\n\\tif any((xc-x)**2+(yc-y)**2<=d**2 for x, y in corners):\\n\\t\\treturn True\\n\\treturn (x1<=xc<=x2 and y1-d<=yc<=y2+d) or (x1-d<=xc<=x2+d and y1<=yc<=y2)\\n```",
                "solutionTags": [],
                "code": "```\\ndef checkOverlap(self, d: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:   \\n\\tcorners = [(x1, y1), (x2, y1), (x1, y2), (x2, y2)]\\n\\tif any((xc-x)**2+(yc-y)**2<=d**2 for x, y in corners):\\n\\t\\treturn True\\n\\treturn (x1<=xc<=x2 and y1-d<=yc<=y2+d) or (x1-d<=xc<=x2+d and y1<=yc<=y2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2941751,
                "title": "python-beats-80-circle-and-square-intersect",
                "content": "```\\nimport itertools\\nclass Solution:\\n    def in_rect(corners: tuple[int, int, int, int], point: tuple[int, int]) -> bool:\\n        x1, y1, x2, y2 = corners\\n        x, y = point\\n        # Has to be included in both dimensions\\n        return x1 <= x and x <= x2 and y1 <= y and y <= y2\\n    def in_semi(semi: tuple[tuple[int, int], tuple[int, int]], r2: int, point: tuple[int, int]) -> bool:\\n        (right, cx), (up, cy) = semi\\n        x, y = point\\n        if right and x < cx or not right and x > cx:\\n            # Has to be to the right side of the quarter circle/s quarter-cutting radius vectors\\n            return False\\n        if up and y < cy or not up and y > cy:\\n            # Has to be to the right side of the quarter circle/s quarter-cutting radius vectors\\n            return False\\n        # Has to be close enough\\n        return (cx - x)**2 + (cy - y)**2 <= r2\\n    def checkOverlap(self, r: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        # They overlap if the circle\\'s center is in the rounded rectangle around the rectangle or if the\\n        # rectangle\\'s center is in some sort of other relation with the circle... let\\'s do the firs one\\n        horiz_cross = (x1 - r, y1, x2 + r, y2)\\n        vert_cross = (x1, y1 - r, x2, y2 + r)\\n        rects = [horiz_cross, vert_cross]\\n        semis = list(itertools.product(enumerate([x1, x2]), enumerate([y1, y2])))\\n        center = (xCenter, yCenter)\\n        r2 = r**2\\n        return (\\n            any([Solution.in_rect(rect, center) for rect in rects]) or\\n            any([Solution.in_semi(semi, r2, center) for semi in semis])\\n        )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport itertools\\nclass Solution:\\n    def in_rect(corners: tuple[int, int, int, int], point: tuple[int, int]) -> bool:\\n        x1, y1, x2, y2 = corners\\n        x, y = point\\n        # Has to be included in both dimensions\\n        return x1 <= x and x <= x2 and y1 <= y and y <= y2\\n    def in_semi(semi: tuple[tuple[int, int], tuple[int, int]], r2: int, point: tuple[int, int]) -> bool:\\n        (right, cx), (up, cy) = semi\\n        x, y = point\\n        if right and x < cx or not right and x > cx:\\n            # Has to be to the right side of the quarter circle/s quarter-cutting radius vectors\\n            return False\\n        if up and y < cy or not up and y > cy:\\n            # Has to be to the right side of the quarter circle/s quarter-cutting radius vectors\\n            return False\\n        # Has to be close enough\\n        return (cx - x)**2 + (cy - y)**2 <= r2\\n    def checkOverlap(self, r: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        # They overlap if the circle\\'s center is in the rounded rectangle around the rectangle or if the\\n        # rectangle\\'s center is in some sort of other relation with the circle... let\\'s do the firs one\\n        horiz_cross = (x1 - r, y1, x2 + r, y2)\\n        vert_cross = (x1, y1 - r, x2, y2 + r)\\n        rects = [horiz_cross, vert_cross]\\n        semis = list(itertools.product(enumerate([x1, x2]), enumerate([y1, y2])))\\n        center = (xCenter, yCenter)\\n        r2 = r**2\\n        return (\\n            any([Solution.in_rect(rect, center) for rect in rects]) or\\n            any([Solution.in_semi(semi, r2, center) for semi in semis])\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878843,
                "title": "simple-maths-solution",
                "content": "# Intuition\\nSample point from rectangle and check if in circle.\\n\\n# Approach\\nFind a point $(x, y)$ such that $x_1 <= x <= y_2$ and $y_1 <= y <= y_2$ (i.e. in rectangle) which is closest to the circle origin.\\nObviously, if $x_c$ lies within the range $[x_1, x_2]$ then $x = x_c$. If $x_c < x_1$, take $x=x_1$, conversely if $x_c > x_2$ take $x=x_2$. Do same for $y$.\\nFinally test if the point lies within the circle with $(x-x_c)^2+(y-y_c)^2<=r^2$.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkOverlap(self, r: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        x = xc if x1 <= xc <= x2 else x1 if xc < x1 else x2\\n        y = yc if y1 <= yc <= y2 else y1 if yc < y1 else y2\\n        return (x - xc) ** 2 + (y - yc) ** 2 <= r ** 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        x = xc if x1 <= xc <= x2 else x1 if xc < x1 else x2\\n        y = yc if y1 <= yc <= y2 else y1 if yc < y1 else y2\\n        return (x - xc) ** 2 + (y - yc) ** 2 <= r ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873776,
                "title": "cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int a,b,ans;\\n        a= max(x1,min(xCenter,x2));\\n        b=max(y1,min(yCenter,y2));\\n        int x_o = xCenter-a;\\n        int y_o = yCenter-b; \\n        if((x_o*x_o+y_o*y_o)<=(radius)*radius)\\n        ans = true;\\n        else\\n        ans = false;\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int a,b,ans;\\n        a= max(x1,min(xCenter,x2));\\n        b=max(y1,min(yCenter,y2));\\n        int x_o = xCenter-a;\\n        int y_o = yCenter-b; \\n        if((x_o*x_o+y_o*y_o)<=(radius)*radius)\\n        ans = true;\\n        else\\n        ans = false;\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748618,
                "title": "rust-find-closest-point-in-rectangle-to-circle-center",
                "content": "Then check whether the closest point is inside the circle.\\n```rust\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        let x = x_center.max(x1).min(x2);\\n        let y = y_center.max(y1).min(y2);\\n        (x - x_center).pow(2) + (y - y_center).pow(2) <= radius.pow(2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        let x = x_center.max(x1).min(x2);\\n        let y = y_center.max(y1).min(y2);\\n        (x - x_center).pow(2) + (y - y_center).pow(2) <= radius.pow(2)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2727816,
                "title": "python-solution-3-cases",
                "content": "```\\nclass Solution:\\n    # 3 cases:\\n    # 1. Rectangle has >= 1 corners inside the circle\\n    # 2. Rectangle has >= 1 edge inside the circle\\n    # 3. Rectangle has 4 edges enclosing the circle\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        corners = [[x1, y1], [x1, y2], [x2, y2], [x2, y1]]\\n        # Case 1\\n        for x, y in corners:\\n            if (x-xCenter)*(x-xCenter) + (y-yCenter)*(y-yCenter) <= radius*radius:\\n                return True\\n        # Case 2\\n        if (xCenter - radius <= x1 <= xCenter + radius) and y1 <= yCenter <= y2:\\n            return True\\n        if (xCenter - radius <= x2 <= xCenter + radius) and y1 <= yCenter <= y2:\\n            return True\\n        if (yCenter - radius <= y1 <= yCenter + radius) and x1 <= xCenter <= x2:\\n            return True\\n        if (yCenter - radius <= y2 <= yCenter + radius) and x1 <= xCenter <= x2:\\n            return True\\n        # Case 3\\n        if x1 <= xCenter <= x2 and y1 <= yCenter <= y2:\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # 3 cases:\\n    # 1. Rectangle has >= 1 corners inside the circle\\n    # 2. Rectangle has >= 1 edge inside the circle\\n    # 3. Rectangle has 4 edges enclosing the circle\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        corners = [[x1, y1], [x1, y2], [x2, y2], [x2, y1]]\\n        # Case 1\\n        for x, y in corners:\\n            if (x-xCenter)*(x-xCenter) + (y-yCenter)*(y-yCenter) <= radius*radius:\\n                return True\\n        # Case 2\\n        if (xCenter - radius <= x1 <= xCenter + radius) and y1 <= yCenter <= y2:\\n            return True\\n        if (xCenter - radius <= x2 <= xCenter + radius) and y1 <= yCenter <= y2:\\n            return True\\n        if (yCenter - radius <= y1 <= yCenter + radius) and x1 <= xCenter <= x2:\\n            return True\\n        if (yCenter - radius <= y2 <= yCenter + radius) and x1 <= xCenter <= x2:\\n            return True\\n        # Case 3\\n        if x1 <= xCenter <= x2 and y1 <= yCenter <= y2:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658600,
                "title": "my-kotlin-solution-with-time-o-1-and-space-o-1",
                "content": "Below is my solution in kotlin, it should be quite straight-forward.\\n\\n```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) and Space O(1);\\n     */\\n    fun checkOverlap(radius: Int, xCenter: Int, yCenter: Int, x1: Int, y1: Int, x2: Int, y2: Int): Boolean {\\n        val rangeOfX = x1..x2\\n        val xClosestToCenter = rangeOfX.findClosest(xCenter)\\n\\n        val rangeOfY = y1..y2\\n        val yClosestToCenter = rangeOfY.findClosest(yCenter)\\n\\n        return square(xClosestToCenter - xCenter) + square(yClosestToCenter - yCenter) <= square(radius)\\n    }\\n\\n    private fun IntRange.findClosest(target: Int): Int {\\n        return when {\\n            target < first -> first\\n            target > last -> last\\n            else -> target\\n        }\\n    }\\n\\n    private fun square(i: Int) = i * i\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) and Space O(1);\\n     */\\n    fun checkOverlap(radius: Int, xCenter: Int, yCenter: Int, x1: Int, y1: Int, x2: Int, y2: Int): Boolean {\\n        val rangeOfX = x1..x2\\n        val xClosestToCenter = rangeOfX.findClosest(xCenter)\\n\\n        val rangeOfY = y1..y2\\n        val yClosestToCenter = rangeOfY.findClosest(yCenter)\\n\\n        return square(xClosestToCenter - xCenter) + square(yClosestToCenter - yCenter) <= square(radius)\\n    }\\n\\n    private fun IntRange.findClosest(target: Int): Int {\\n        return when {\\n            target < first -> first\\n            target > last -> last\\n            else -> target\\n        }\\n    }\\n\\n    private fun square(i: Int) = i * i\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540813,
                "title": "java-runtime-0-ms-faster-than-100",
                "content": "```java\\nclass Solution {\\n    public boolean checkOverlap(\\n            int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        // Find the closest point to the circle within the rectangle\\n        int closestX = clamp(xCenter, x1, x2);\\n        int closestY = clamp(yCenter, y1, y2);\\n        // Calculate the distance between the circle\\'s center and this closest point\\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        // If the distance is less than the circle\\'s radius, an intersection occurs\\n        int distanceSquared = distanceX * distanceX + distanceY * distanceY;\\n        return distanceSquared <= radius * radius;\\n    }\\n\\n    private int clamp(int val, int min, int max) {\\n        return Math.max(min, Math.min(max, val));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Geometry"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean checkOverlap(\\n            int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        // Find the closest point to the circle within the rectangle\\n        int closestX = clamp(xCenter, x1, x2);\\n        int closestY = clamp(yCenter, y1, y2);\\n        // Calculate the distance between the circle\\'s center and this closest point\\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        // If the distance is less than the circle\\'s radius, an intersection occurs\\n        int distanceSquared = distanceX * distanceX + distanceY * distanceY;\\n        return distanceSquared <= radius * radius;\\n    }\\n\\n    private int clamp(int val, int min, int max) {\\n        return Math.max(min, Math.min(max, val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462741,
                "title": "c-solution-using-if-else-control-statements",
                "content": "```\\n\\n\\nbool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2){\\n    int xParam = xCenter;\\n    int yParam = yCenter;\\n    \\n    if(xCenter<=x1){\\n        xParam = x1;\\n    }\\n    else if(xCenter>=x2){\\n        xParam = x2;\\n    }\\n    else{\\n        xParam = xCenter;\\n    }\\n    if(yCenter<=y1){\\n        yParam = y1;\\n    }\\n    else if(yCenter>=y2){\\n        yParam = y2;\\n    }\\n    else{\\n        yParam = yCenter;\\n    }\\n    \\n    int xDistance = xCenter-xParam;\\n    int yDistance = yCenter-yParam;\\n    \\n    int total = sqrt((xDistance*xDistance) + (yDistance*yDistance));\\n    \\n    return total<=radius;\\n    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nbool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2){\\n    int xParam = xCenter;\\n    int yParam = yCenter;\\n    \\n    if(xCenter<=x1){\\n        xParam = x1;\\n    }\\n    else if(xCenter>=x2){\\n        xParam = x2;\\n    }\\n    else{\\n        xParam = xCenter;\\n    }\\n    if(yCenter<=y1){\\n        yParam = y1;\\n    }\\n    else if(yCenter>=y2){\\n        yParam = y2;\\n    }\\n    else{\\n        yParam = yCenter;\\n    }\\n    \\n    int xDistance = xCenter-xParam;\\n    int yDistance = yCenter-yParam;\\n    \\n    int total = sqrt((xDistance*xDistance) + (yDistance*yDistance));\\n    \\n    return total<=radius;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2335399,
                "title": "intuitive-math-do-as-hints-say",
                "content": "```\\nclass Solution {\\n    \\n    int shortest_coor(int radius, int xCenter, int x1, int x2) {\\n        \\n        if (x1 <= xCenter and xCenter <= x2)\\n            return 0;\\n        \\n        int px = 0;\\n        if (xCenter + radius <= x1) {\\n            px = abs(x1 - xCenter);\\n        } else if (xCenter - radius >= x2) {\\n            px = abs(x2 - xCenter);\\n        } else {\\n            px = min(abs(x1 - xCenter), abs(x2 - xCenter));\\n        }\\n        \\n        return px;\\n    }\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        int px = shortest_coor(radius, xCenter, x1, x2);\\n        int py = shortest_coor(radius, yCenter, y1, y2);\\n        \\n        int dis = pow(px, 2) + pow(py, 2);\\n        int r_square = pow(radius, 2);\\n        return dis <= r_square;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int shortest_coor(int radius, int xCenter, int x1, int x2) {\\n        \\n        if (x1 <= xCenter and xCenter <= x2)\\n            return 0;\\n        \\n        int px = 0;\\n        if (xCenter + radius <= x1) {\\n            px = abs(x1 - xCenter);\\n        } else if (xCenter - radius >= x2) {\\n            px = abs(x2 - xCenter);\\n        } else {\\n            px = min(abs(x1 - xCenter), abs(x2 - xCenter));\\n        }\\n        \\n        return px;\\n    }\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        int px = shortest_coor(radius, xCenter, x1, x2);\\n        int py = shortest_coor(radius, yCenter, y1, y2);\\n        \\n        int dis = pow(px, 2) + pow(py, 2);\\n        int r_square = pow(radius, 2);\\n        return dis <= r_square;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207660,
                "title": "most-optimal-solution",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (xCenter - min(max(x1, xCenter), x2)) ** 2 + (yCenter - min(max(y1, yCenter), y2)) ** 2 <= radius ** 2\\n```",
                "solutionTags": [
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (xCenter - min(max(x1, xCenter), x2)) ** 2 + (yCenter - min(max(y1, yCenter), y2)) ** 2 <= radius ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146664,
                "title": "clean-javascript-solution-easy-to-understand",
                "content": "***Before Optimization***\\n\\n```\\nfunction compare(v, min, max) {\\n\\tif (v < min) return min\\n\\tif (max < v) return max\\n\\treturn v\\n}\\n\\nfunction checkOverlap(r, c1, c2, x1, y1, x2, y2) {\\n    const [b1, b2] = [compare(c1, x1, x2), compare(c2, y1, y2)]\\n    return (c1 - b1) ** 2 + (c2 - b2) ** 2 <= r ** 2\\n}\\n```\\n\\n***After Optimization***\\n\\n```\\nfunction checkOverlap(r, c1, c2, x1, y1, x2, y2) {\\n    const [d1, d2] = [c1 -  Math.max(x1, Math.min(x2, c1)), c2 - Math.max(y1, Math.min(y2, c2))]\\n    return (d1 ** 2) + (d2 ** 2) <= r ** 2\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction compare(v, min, max) {\\n\\tif (v < min) return min\\n\\tif (max < v) return max\\n\\treturn v\\n}\\n\\nfunction checkOverlap(r, c1, c2, x1, y1, x2, y2) {\\n    const [b1, b2] = [compare(c1, x1, x2), compare(c2, y1, y2)]\\n    return (c1 - b1) ** 2 + (c2 - b2) ** 2 <= r ** 2\\n}\\n```\n```\\nfunction checkOverlap(r, c1, c2, x1, y1, x2, y2) {\\n    const [d1, d2] = [c1 -  Math.max(x1, Math.min(x2, c1)), c2 - Math.max(y1, Math.min(y2, c2))]\\n    return (d1 ** 2) + (d2 ** 2) <= r ** 2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137686,
                "title": "brute-force-c-by-comparing-distance-runtime-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n \\n    // According to constraint or question x1 < x2 and y1 < y2\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        \\n        // for xc there are 3 cases:\\n        // 1. xc < (x1 < x2) : x-coordinate of Center less than both x1, x2\\n        // 2. (x1) < xc < (x2) : x-coordinate of Center lies between both x1, x2\\n        // 3. (x1 < x2) < xc : x-coordinate of Center greater than both x1, x2\\n        \\n        // for x\\n        int closest_x = xc; \\n        if (xc < x1)\\n            closest_x = x1;\\n        else \\n        {\\n            if (xc > x2)  \\n                closest_x = x2;\\n            else \\n                closest_x = xc;\\n        }\\n        \\n        // for y\\n        int closest_y = yc; \\n        if (yc < y1)\\n            closest_y = y1;\\n        else \\n        {\\n            if (yc > y2)  \\n                closest_y = y2;\\n            else \\n                closest_y = yc;\\n        }\\n    \\n        int dx = closest_x - xc;\\n        int dy = closest_y - yc;\\n        // compare distance\\n        return dx*dx + dy*dy <= r*r;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n \\n    // According to constraint or question x1 < x2 and y1 < y2\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        \\n        // for xc there are 3 cases:\\n        // 1. xc < (x1 < x2) : x-coordinate of Center less than both x1, x2\\n        // 2. (x1) < xc < (x2) : x-coordinate of Center lies between both x1, x2\\n        // 3. (x1 < x2) < xc : x-coordinate of Center greater than both x1, x2\\n        \\n        // for x\\n        int closest_x = xc; \\n        if (xc < x1)\\n            closest_x = x1;\\n        else \\n        {\\n            if (xc > x2)  \\n                closest_x = x2;\\n            else \\n                closest_x = xc;\\n        }\\n        \\n        // for y\\n        int closest_y = yc; \\n        if (yc < y1)\\n            closest_y = y1;\\n        else \\n        {\\n            if (yc > y2)  \\n                closest_y = y2;\\n            else \\n                closest_y = yc;\\n        }\\n    \\n        int dx = closest_x - xc;\\n        int dy = closest_y - yc;\\n        // compare distance\\n        return dx*dx + dy*dy <= r*r;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127404,
                "title": "c-maths-based-solution-with-explanation-o-1-time-o-1-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        //nearest_x = x1 when xCenter<x1<x2 (OR) x2 when x1<x2<xCenter (OR) xCenter when x1<xCenter<x2\\n        int nearest_x = (xCenter < x1) ? x1 : (xCenter > x2) ? x2 : xCenter;\\n        //same logic for nearest_y as in nearest_x\\n        int nearest_y = (yCenter < y1) ? y1 : (yCenter > y2) ? y2 : yCenter;\\n        int dist_x = xCenter - nearest_x, dist_y = yCenter - nearest_y;\\n        return dist_x * dist_x + dist_y * dist_y <= radius * radius;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        //nearest_x = x1 when xCenter<x1<x2 (OR) x2 when x1<x2<xCenter (OR) xCenter when x1<xCenter<x2\\n        int nearest_x = (xCenter < x1) ? x1 : (xCenter > x2) ? x2 : xCenter;\\n        //same logic for nearest_y as in nearest_x\\n        int nearest_y = (yCenter < y1) ? y1 : (yCenter > y2) ? y2 : yCenter;\\n        int dist_x = xCenter - nearest_x, dist_y = yCenter - nearest_y;\\n        return dist_x * dist_x + dist_y * dist_y <= radius * radius;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077638,
                "title": "java-100-faster-one-liner",
                "content": "```\\nclass Solution\\n{\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n    {\\n        return Math.pow(Math.max(x1,Math.min(x2,xCenter))-xCenter,2)\\n            + Math.pow(Math.max(y1,Math.min(y2,yCenter))-yCenter,2) <= radius*radius;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n    {\\n        return Math.pow(Math.max(x1,Math.min(x2,xCenter))-xCenter,2)\\n            + Math.pow(Math.max(y1,Math.min(y2,yCenter))-yCenter,2) <= radius*radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039160,
                "title": "python-following-the-hints",
                "content": "\\t\\t# offset x\\'s and y\\'s so that the center of the circle is (0,0)\\n        x1 -= xCenter\\n        x2 -= xCenter\\n        y1 -= yCenter\\n        y2 -= yCenter\\n        \\n        # find the point (xMin, yMin) that is closest to the origin:\\n        if x1 <= 0 and x2 >=0:\\n            xMin = 0\\n        elif x1 >= 0:\\n            xMin = min(x1, x2)     # = x1\\n        else:\\n            xMin = max(x1, x2)     # = x2\\n        \\n        if y1 <= 0 and y2 >= 0:\\n            yMin = 0        \\n        elif y1 >= 0:\\n            yMin = min(y1, y2)         # = y1\\n        else:\\n            yMin = max(y1, y2)      # = y2\\n            \\n        # return whether or not that point is inside a circle\\n        # of radius R:\\n        return(xMin**2 + yMin**2 <= radius**2)",
                "solutionTags": [],
                "code": "\\t\\t# offset x\\'s and y\\'s so that the center of the circle is (0,0)\\n        x1 -= xCenter\\n        x2 -= xCenter\\n        y1 -= yCenter\\n        y2 -= yCenter\\n        \\n        # find the point (xMin, yMin) that is closest to the origin:\\n        if x1 <= 0 and x2 >=0:\\n            xMin = 0\\n        elif x1 >= 0:\\n            xMin = min(x1, x2)     # = x1\\n        else:\\n            xMin = max(x1, x2)     # = x2\\n        \\n        if y1 <= 0 and y2 >= 0:\\n            yMin = 0        \\n        elif y1 >= 0:\\n            yMin = min(y1, y2)         # = y1\\n        else:\\n            yMin = max(y1, y2)      # = y2\\n            \\n        # return whether or not that point is inside a circle\\n        # of radius R:\\n        return(xMin**2 + yMin**2 <= radius**2)",
                "codeTag": "Unknown"
            },
            {
                "id": 1827454,
                "title": "c-100-faster-code",
                "content": "class Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        if(xCenter >= x1 && xCenter <= x2 || yCenter >= y1 && yCenter <= y2){\\n            if(xCenter < x1-radius || xCenter > x2+radius || yCenter < y1-radius || yCenter > y2+radius ) return false;\\n            else return true;\\n        } else{\\n            int xx1 = xCenter>x1?x2:xCenter;\\n            int xx2 = xCenter>x1?xCenter:x1;\\n            \\n            int yy1 = yCenter>y1?y2:yCenter;\\n            int yy2 = yCenter>y1?yCenter:y1;\\n            \\n            if(sqrt((xx2-xx1)*(xx2-xx1) + (yy2-yy1)*(yy2-yy1)) > radius) return false;\\n            else return true;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        if(xCenter >= x1 && xCenter <= x2 || yCenter >= y1 && yCenter <= y2){\\n            if(xCenter < x1-radius || xCenter > x2+radius || yCenter < y1-radius || yCenter > y2+radius ) return false;\\n            else return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1806644,
                "title": "katttttttttttt",
                "content": ".......//////////////////",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1781256,
                "title": "javascript-solution-math-geometry",
                "content": "In order to derive the closest x and y points of the square from the circle, we use what is called a `clamp` function. Afterwards, we calculate the Euclidan Distance. We can slightly optimize the calculation by using the Pythagorean Theorem.\\n\\n```\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    const closestX = clamp(xCenter, x1, x2);\\n    const closestY = clamp(yCenter, y1, y2);\\n    \\n    const dist = (xCenter - closestX)**2 + (yCenter - closestY)**2;\\n    \\n    return dist <= radius * radius ? true : false;\\n    \\n    \\n    function clamp(val, min, max) {\\n        if (val < min) return min;\\n        if (max < val) return max;\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    const closestX = clamp(xCenter, x1, x2);\\n    const closestY = clamp(yCenter, y1, y2);\\n    \\n    const dist = (xCenter - closestX)**2 + (yCenter - closestY)**2;\\n    \\n    return dist <= radius * radius ? true : false;\\n    \\n    \\n    function clamp(val, min, max) {\\n        if (val < min) return min;\\n        if (max < val) return max;\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682986,
                "title": "golang-o-1-time-mem-easy-to-understand",
                "content": "```\\nfunc checkOverlap(radius int, xCenter int, yCenter int, x1 int, y1 int, x2 int, y2 int) bool {\\n    if xCenter <= x1 {\\n        if yCenter <= y1 {\\n            return sqr(xCenter - x1) + sqr(yCenter - y1) <= sqr(radius)\\n        }\\n        \\n        if yCenter >= y2 {\\n            return sqr(xCenter - x1) + sqr(yCenter - y2) <= sqr(radius)\\n        }\\n        \\n        return x1 - xCenter <= radius\\n    }    \\n    \\n    if xCenter >= x2 {\\n        if yCenter <= y1 {\\n            return sqr(xCenter - x2) + sqr(yCenter - y1) <= sqr(radius)\\n        }\\n        \\n        if yCenter >= y2 {\\n            return sqr(xCenter - x2) + sqr(yCenter - y2) <= sqr(radius)\\n        }\\n        \\n        return xCenter - x2 <= radius\\n    }\\n    \\n    if yCenter <= y1 {\\n        return y1 - yCenter <= radius\\n    } \\n    \\n    if yCenter >= y2 {\\n        return yCenter - y2 <= radius\\n    }\\n    \\n    return true \\n}\\n\\nfunc sqr(a int) int {\\n    return a * a\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkOverlap(radius int, xCenter int, yCenter int, x1 int, y1 int, x2 int, y2 int) bool {\\n    if xCenter <= x1 {\\n        if yCenter <= y1 {\\n            return sqr(xCenter - x1) + sqr(yCenter - y1) <= sqr(radius)\\n        }\\n        \\n        if yCenter >= y2 {\\n            return sqr(xCenter - x1) + sqr(yCenter - y2) <= sqr(radius)\\n        }\\n        \\n        return x1 - xCenter <= radius\\n    }    \\n    \\n    if xCenter >= x2 {\\n        if yCenter <= y1 {\\n            return sqr(xCenter - x2) + sqr(yCenter - y1) <= sqr(radius)\\n        }\\n        \\n        if yCenter >= y2 {\\n            return sqr(xCenter - x2) + sqr(yCenter - y2) <= sqr(radius)\\n        }\\n        \\n        return xCenter - x2 <= radius\\n    }\\n    \\n    if yCenter <= y1 {\\n        return y1 - yCenter <= radius\\n    } \\n    \\n    if yCenter >= y2 {\\n        return yCenter - y2 <= radius\\n    }\\n    \\n    return true \\n}\\n\\nfunc sqr(a int) int {\\n    return a * a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640836,
                "title": "python-math-solution",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if x_center + radius < x1 or x_center - radius > x2 or y_center + radius < y1 or y_center - radius > y2:\\n            return False\\n        \\n        distance = ((x1 + x2) / 2 - x_center)**2 + ((y1 + y2) / 2 - y_center)**2\\n        d1 = radius**2\\n        d2 = ((x1 - x2)**2 + (y1 - y2)**2) / 4\\n        \\n        return sqrt(distance) <= sqrt(d1) + sqrt(d2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if x_center + radius < x1 or x_center - radius > x2 or y_center + radius < y1 or y_center - radius > y2:\\n            return False\\n        \\n        distance = ((x1 + x2) / 2 - x_center)**2 + ((y1 + y2) / 2 - y_center)**2\\n        d1 = radius**2\\n        d2 = ((x1 - x2)**2 + (y1 - y2)**2) / 4\\n        \\n        return sqrt(distance) <= sqrt(d1) + sqrt(d2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489055,
                "title": "partitioning-all-areas-in-9-cases",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        if xc >= x1 and xc <= x2 and yc >= y1 and yc <= y2:\\n            return True\\n        \\n        elif xc > x2:\\n            if yc > y2:\\n                return r**2 >= (xc-x2)**2 + (yc-y2)**2\\n            elif yc >= y1 and yc < y2:\\n                return r >= xc-x2\\n            else: # yc < y1\\n                return r**2 >= (xc-x2)**2 + (yc-y1)**2\\n        elif xc <= x1:\\n            if yc > y2:\\n                return r**2 >= (xc-x1)**2 + (yc-y2)**2\\n            elif yc >= y1 and yc < y2:\\n                return r >= x1-xc\\n            else: # yc < y1\\n                return r**2 >= (xc-x1)**2 + (yc-y1)**2\\n        elif xc > x1 and xc < x2 and yc > y2:\\n            \\n            return r >= yc -y2\\n        else: \\n            return r >= y1-yc\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        if xc >= x1 and xc <= x2 and yc >= y1 and yc <= y2:\\n            return True\\n        \\n        elif xc > x2:\\n            if yc > y2:\\n                return r**2 >= (xc-x2)**2 + (yc-y2)**2\\n            elif yc >= y1 and yc < y2:\\n                return r >= xc-x2\\n            else: # yc < y1\\n                return r**2 >= (xc-x2)**2 + (yc-y1)**2\\n        elif xc <= x1:\\n            if yc > y2:\\n                return r**2 >= (xc-x1)**2 + (yc-y2)**2\\n            elif yc >= y1 and yc < y2:\\n                return r >= x1-xc\\n            else: # yc < y1\\n                return r**2 >= (xc-x1)**2 + (yc-y1)**2\\n        elif xc > x1 and xc < x2 and yc > y2:\\n            \\n            return r >= yc -y2\\n        else: \\n            return r >= y1-yc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421857,
                "title": "c-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/79b43106-9254-4dc7-85b0-4e11db56e8f7_1629744775.83113.png)\\n<b>Idea</b> \\nThe center of our circle lies in rectange `r1` or rectange `r2` or any of the 4 circles. The radius of each of the 4 circles is `r` ( the radius of the circle given in question ). The bottom left corner of the red rectange is `(x1,y1)` and top right corner of red rectangle is `(x2,y2)`.\\n\\n```\\nclass Solution {\\npublic:\\nbool ok(int r,int x,int y,int x1,int y1){\\n    return (r*r>=(x-x1)*(x-x1)+(y-y1)*(y-y1));\\n}\\n\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) { \\n    int newX1=x1-r,newY1=y1-r,newX2=x2+r,newY2=y2+r;\\n    bool inR1 = (x>=x1 && x<=x2 && y>=newY1 && y<=newY2);\\n    bool inR2 = (x>=newX1 && x<=newX2 && y>=y1 && y<=y2); \\n    bool inCircle = ok(r,x,y,x1,y1) || ok(r,x,y,x1,y2) || ok(r,x,y,x2,y1) || ok(r,x,y,x2,y2);\\n    return inR1 || inR2 || inCircle;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nbool ok(int r,int x,int y,int x1,int y1){\\n    return (r*r>=(x-x1)*(x-x1)+(y-y1)*(y-y1));\\n}\\n\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) { \\n    int newX1=x1-r,newY1=y1-r,newX2=x2+r,newY2=y2+r;\\n    bool inR1 = (x>=x1 && x<=x2 && y>=newY1 && y<=newY2);\\n    bool inR2 = (x>=newX1 && x<=newX2 && y>=y1 && y<=y2); \\n    bool inCircle = ok(r,x,y,x1,y1) || ok(r,x,y,x1,y2) || ok(r,x,y,x2,y1) || ok(r,x,y,x2,y2);\\n    return inR1 || inR2 || inCircle;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178944,
                "title": "ugly-rust-solution-100-100",
                "content": "```\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        f(radius, x1 - x_center, y1 - y_center, x2 - x_center, y2 - y_center)\\n    }\\n}\\n\\nfn f(r: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n    in_circ(r, x1, y1) || in_circ(r, x1, y2) ||\\n      in_circ(r, x2, y1) || in_circ(r, x2, y2) || \\n    (x1 <= 0 && x2 >= 0 && y1 <= 0 && y2 >= 0) ||\\n    (x1.abs() <= r && y1 <= 0 && y2 >= 0) ||\\n    (x2.abs() <= r && y1 <= 0 && y2 >= 0) ||\\n    (y1.abs() <= r && x1 <= 0 && x2 >= 0) ||\\n    (y2.abs() <= r && x1 <= 0 && x2 >= 0)\\n}\\n\\nfn in_circ(r: i32, x: i32, y: i32) -> bool {\\n    x*x + y*y <= r*r\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        f(radius, x1 - x_center, y1 - y_center, x2 - x_center, y2 - y_center)\\n    }\\n}\\n\\nfn f(r: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n    in_circ(r, x1, y1) || in_circ(r, x1, y2) ||\\n      in_circ(r, x2, y1) || in_circ(r, x2, y2) || \\n    (x1 <= 0 && x2 >= 0 && y1 <= 0 && y2 >= 0) ||\\n    (x1.abs() <= r && y1 <= 0 && y2 >= 0) ||\\n    (x2.abs() <= r && y1 <= 0 && y2 >= 0) ||\\n    (y1.abs() <= r && x1 <= 0 && x2 >= 0) ||\\n    (y2.abs() <= r && x1 <= 0 && x2 >= 0)\\n}\\n\\nfn in_circ(r: i32, x: i32, y: i32) -> bool {\\n    x*x + y*y <= r*r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123495,
                "title": "python-solution-faster-than-100-intersect-circle-with-four-lines",
                "content": "Two cases when the circle touches the rectangle\\n* Circle is completely interior to the rectangle\\n* Or the rectangle has one side which interesect it\\n\\nFirst, recenter all coordinates with respect to circle center.\\n\\nThen if x1x2 <= 0 and y1y2 <= 0, the rectangle goes over the origin (which covers all cases when circle is interior).\\n\\nOtherwise for each edge check the closest point (will either be the projection of the center onto the edge, or the two end points).\\n\\nFinally, check for closest distance of remaining four points.\\n\\nKeep all arithmetic integral for speed.\\n\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        x1, x2 = x1-x_center, x2-x_center\\n        y1, y2 = y1-y_center, y2-y_center\\n\\n\\t\\tif (x1*x2 <= 0 and y1*y2 <= 0):\\n            return True\\n        \\n        line_list = [\\n            [y1, x2, y1, x1],\\n            [y2, x2, y2, x1],\\n            [x1, y1, x1, y2],\\n            [x2, y1, x2, y2],\\n        ]\\n        \\n        def proj(l):\\n            x1, y1, x2, y2 = l\\n            if y1 * y2 < 0:\\n                return (x1, 0)\\n            if abs(y1) < abs(y2):\\n                return (x1, y1)\\n            return (x1, y2)\\n        \\n        check_points = [proj(l) for l in line_list]\\n       \\n        r2 = radius**2\\n        for p in check_points:\\n            print(p[0]**2 + p[1]**2)\\n            if p[0]**2 + p[1]**2 <= r2:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        x1, x2 = x1-x_center, x2-x_center\\n        y1, y2 = y1-y_center, y2-y_center\\n\\n\\t\\tif (x1*x2 <= 0 and y1*y2 <= 0):\\n            return True\\n        \\n        line_list = [\\n            [y1, x2, y1, x1],\\n            [y2, x2, y2, x1],\\n            [x1, y1, x1, y2],\\n            [x2, y1, x2, y2],\\n        ]\\n        \\n        def proj(l):\\n            x1, y1, x2, y2 = l\\n            if y1 * y2 < 0:\\n                return (x1, 0)\\n            if abs(y1) < abs(y2):\\n                return (x1, y1)\\n            return (x1, y2)\\n        \\n        check_points = [proj(l) for l in line_list]\\n       \\n        r2 = radius**2\\n        for p in check_points:\\n            print(p[0]**2 + p[1]**2)\\n            if p[0]**2 + p[1]**2 <= r2:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121889,
                "title": "js-solution",
                "content": "```\\n/**\\n * @param {number} radius\\n * @param {number} x_center\\n * @param {number} y_center\\n * @param {number} x1\\n * @param {number} y1\\n * @param {number} x2\\n * @param {number} y2\\n * @return {boolean}\\n */\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    function getDistanceToHorizontal(xA, xB, y) {\\n        let distance3 = Infinity\\n        if (xA < xCenter && xCenter < xB) {\\n            distance3 = (yCenter - y) ** 2\\n            return distance3\\n        }\\n        \\n        const distance1 = (xCenter - xA) ** 2 + (yCenter - y) ** 2\\n        const distance2 = (xCenter - xB) ** 2 + (yCenter - y) ** 2\\n        \\n        let result = Math.min(distance1, distance2)\\n        return result\\n    }\\n    \\n    function getDistanceToVertical(yA, yB, x) {\\n        let distance3 = Infinity\\n        if (yA < yCenter && yCenter < yB) {\\n            distance3 = (xCenter - x) ** 2\\n            return distance3\\n        }\\n    \\n        const distance1 = (yCenter - yA) ** 2 + (xCenter - x) ** 2\\n        const distance2 = (yCenter - yB) ** 2 + (xCenter - x) ** 2\\n        \\n        let result = Math.min(distance1, distance2)\\n        return result\\n    }\\n    \\n    \\n    // check whether circle\\'s center is inside rectangle\\n    if ((x1 < xCenter && xCenter < x2) && (y1 < yCenter && yCenter < y2)) {\\n        return true\\n    }\\n    \\n    \\n    // check whether circle\\'s radius can reach rectangle\\n    const distanceValve = radius ** 2\\n    if (getDistanceToHorizontal(x1, x2, y1) <= distanceValve)   return true\\n    if (getDistanceToHorizontal(x1, x2, y2) <= distanceValve)   return true\\n    if (getDistanceToVertical(y1, y2, x1) <= distanceValve) return true\\n    if (getDistanceToVertical(y1, y2, x2) <= distanceValve) return true\\n    \\n    \\n    return false\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} radius\\n * @param {number} x_center\\n * @param {number} y_center\\n * @param {number} x1\\n * @param {number} y1\\n * @param {number} x2\\n * @param {number} y2\\n * @return {boolean}\\n */\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    function getDistanceToHorizontal(xA, xB, y) {\\n        let distance3 = Infinity\\n        if (xA < xCenter && xCenter < xB) {\\n            distance3 = (yCenter - y) ** 2\\n            return distance3\\n        }\\n        \\n        const distance1 = (xCenter - xA) ** 2 + (yCenter - y) ** 2\\n        const distance2 = (xCenter - xB) ** 2 + (yCenter - y) ** 2\\n        \\n        let result = Math.min(distance1, distance2)\\n        return result\\n    }\\n    \\n    function getDistanceToVertical(yA, yB, x) {\\n        let distance3 = Infinity\\n        if (yA < yCenter && yCenter < yB) {\\n            distance3 = (xCenter - x) ** 2\\n            return distance3\\n        }\\n    \\n        const distance1 = (yCenter - yA) ** 2 + (xCenter - x) ** 2\\n        const distance2 = (yCenter - yB) ** 2 + (xCenter - x) ** 2\\n        \\n        let result = Math.min(distance1, distance2)\\n        return result\\n    }\\n    \\n    \\n    // check whether circle\\'s center is inside rectangle\\n    if ((x1 < xCenter && xCenter < x2) && (y1 < yCenter && yCenter < y2)) {\\n        return true\\n    }\\n    \\n    \\n    // check whether circle\\'s radius can reach rectangle\\n    const distanceValve = radius ** 2\\n    if (getDistanceToHorizontal(x1, x2, y1) <= distanceValve)   return true\\n    if (getDistanceToHorizontal(x1, x2, y2) <= distanceValve)   return true\\n    if (getDistanceToVertical(y1, y2, x1) <= distanceValve) return true\\n    if (getDistanceToVertical(y1, y2, x2) <= distanceValve) return true\\n    \\n    \\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1083255,
                "title": "python3-faster-than-97-8-of-submissions",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        import math\\n        x_center_sq = x1 + (x2-x1)/2\\n        y_center_sq = y1 + (y2-y1)/2\\n        x3 = x2\\n        y3 = y1\\n        x4 = x1\\n        y4 = y2\\n        if y2-y1 <= 2*radius:\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == 0:\\n                if x1 -x_center <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > 0 and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < math.pi/2:\\n                if math.sqrt((x1-x_center)**2+(y1-y_center)**2) <= radius or (y1 - y_center <= radius and x1 - x_center <= radius):\\n                    return 1\\n                elif x_center_sq - x_center < radius:\\n                    if y1 - y_center <= radius:\\n                        return 1\\n                elif y_center_sq - y_center < radius:\\n                    if x1 - x_center <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == math.pi/2:\\n                if y1 - y_center <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > math.pi/2 and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < math.pi:\\n                if math.sqrt((x3-x_center)**2+(y3-y_center)**2) <= radius:\\n                    return 1\\n                elif x_center - x_center_sq < radius:\\n                    if y1 - y_center <= radius:\\n                        return 1\\n                elif y_center_sq - y_center < radius:\\n                    if x_center - x2 <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == math.pi:\\n                if x_center - x2 <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > -math.pi and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < -0.5*math.pi:\\n                if math.sqrt((x2-x_center)**2+(y2-y_center)**2) <= radius or (y_center - y4 <= radius and x_center - x2 <= radius):\\n                    return 1\\n                elif x_center - x_center_sq < radius:\\n                    if y_center - y2 <= radius:\\n                        return 1\\n                elif y_center - y2 < radius:\\n                    if x_center - x2 <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == -0.5*math.pi:\\n                if y_center -y2 <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > -0.5*math.pi and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < 0:\\n                if math.sqrt((x4-x_center)**2+(y4-y_center)**2) <= radius or (y_center - y4 <= radius and x4-x_center <= radius):\\n                    return 1\\n                elif x_center_sq - x_center < radius:\\n                    if y_center - y2 <= radius:\\n                        return 1\\n                elif y_center - y_center_sq < radius:\\n                    if x1 - x_center <= radius:\\n                        return 1\\n        else:\\n            x_right = x_center + radius\\n            y_top = y_center + radius\\n            if x_right >= x1 and x_right <= x2 + 2*radius and y_top >= y1 and y_top <= y2 +2*radius:\\n                return 1\\n        return 0\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        import math\\n        x_center_sq = x1 + (x2-x1)/2\\n        y_center_sq = y1 + (y2-y1)/2\\n        x3 = x2\\n        y3 = y1\\n        x4 = x1\\n        y4 = y2\\n        if y2-y1 <= 2*radius:\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == 0:\\n                if x1 -x_center <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > 0 and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < math.pi/2:\\n                if math.sqrt((x1-x_center)**2+(y1-y_center)**2) <= radius or (y1 - y_center <= radius and x1 - x_center <= radius):\\n                    return 1\\n                elif x_center_sq - x_center < radius:\\n                    if y1 - y_center <= radius:\\n                        return 1\\n                elif y_center_sq - y_center < radius:\\n                    if x1 - x_center <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == math.pi/2:\\n                if y1 - y_center <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > math.pi/2 and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < math.pi:\\n                if math.sqrt((x3-x_center)**2+(y3-y_center)**2) <= radius:\\n                    return 1\\n                elif x_center - x_center_sq < radius:\\n                    if y1 - y_center <= radius:\\n                        return 1\\n                elif y_center_sq - y_center < radius:\\n                    if x_center - x2 <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == math.pi:\\n                if x_center - x2 <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > -math.pi and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < -0.5*math.pi:\\n                if math.sqrt((x2-x_center)**2+(y2-y_center)**2) <= radius or (y_center - y4 <= radius and x_center - x2 <= radius):\\n                    return 1\\n                elif x_center - x_center_sq < radius:\\n                    if y_center - y2 <= radius:\\n                        return 1\\n                elif y_center - y2 < radius:\\n                    if x_center - x2 <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == -0.5*math.pi:\\n                if y_center -y2 <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > -0.5*math.pi and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < 0:\\n                if math.sqrt((x4-x_center)**2+(y4-y_center)**2) <= radius or (y_center - y4 <= radius and x4-x_center <= radius):\\n                    return 1\\n                elif x_center_sq - x_center < radius:\\n                    if y_center - y2 <= radius:\\n                        return 1\\n                elif y_center - y_center_sq < radius:\\n                    if x1 - x_center <= radius:\\n                        return 1\\n        else:\\n            x_right = x_center + radius\\n            y_top = y_center + radius\\n            if x_right >= x1 and x_right <= x2 + 2*radius and y_top >= y1 and y_top <= y2 +2*radius:\\n                return 1\\n        return 0\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1065275,
                "title": "solutions-written-in-javascript",
                "content": "There aren\\'t many JavaScript posts for this question so here are two solutions re-written in JavaScript found here on the discuss forums: \\n[Solution 1](https://leetcode.com/problems/circle-and-rectangle-overlapping/discuss/563341/4-lines-C%2B%2B-O(1)%3A-Test-shortest-distance-from-center-to-rect-(with-pics))\\n[Solution 2](https://leetcode.com/problems/circle-and-rectangle-overlapping/discuss/563441/JAVA-compare-distance-between-radius-and-closest-point-on-rectangle-to-circle)\\n\\nSolution 1:\\n```\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n    let edgeX = 0;\\n    let edgeY = 0;\\n    let distX = 0;\\n    let distY = 0;\\n    if(x_center < x1) {\\n        edgeX = x1;\\n    }\\n    else if(x_center > x2) {\\n        edgeX = x2;\\n    }\\n    else {\\n        edgeX = x_center;\\n    }\\n    if(y_center < y1) {\\n        edgeY = y1;\\n    }\\n    else if(y_center > y2) {\\n        edgeY = y2;\\n    }\\n    else {\\n        edgeY = y_center;\\n    }\\n    distX = x_center - edgeX;\\n    distY = y_center - edgeY;\\n    return (distX ** 2) + (distY ** 2) <= radius ** 2;\\n};\\n```\\n\\nSolution 2:\\n```\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n    let closestX = Math.max(x1, Math.min(x2, x_center));\\n    let closestY = Math.max(y1, Math.min(y2, y_center));\\n    \\n    let distX = x_center - closestX;\\n    let distY = y_center - closestY;\\n    \\n    return (distX ** 2) + (distY ** 2) <= radius ** 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n    let edgeX = 0;\\n    let edgeY = 0;\\n    let distX = 0;\\n    let distY = 0;\\n    if(x_center < x1) {\\n        edgeX = x1;\\n    }\\n    else if(x_center > x2) {\\n        edgeX = x2;\\n    }\\n    else {\\n        edgeX = x_center;\\n    }\\n    if(y_center < y1) {\\n        edgeY = y1;\\n    }\\n    else if(y_center > y2) {\\n        edgeY = y2;\\n    }\\n    else {\\n        edgeY = y_center;\\n    }\\n    distX = x_center - edgeX;\\n    distY = y_center - edgeY;\\n    return (distX ** 2) + (distY ** 2) <= radius ** 2;\\n};\\n```\n```\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n    let closestX = Math.max(x1, Math.min(x2, x_center));\\n    let closestY = Math.max(y1, Math.min(y2, y_center));\\n    \\n    let distX = x_center - closestX;\\n    let distY = y_center - closestY;\\n    \\n    return (distX ** 2) + (distY ** 2) <= radius ** 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1048109,
                "title": "java-solution-0ms-math",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if(x1<=xc && xc<=x2 && y1<=yc && yc<=y2) return true;\\n        int cx=Math.max(x1,Math.min(x2,xc)),cy=Math.max(y1,Math.min(y2,yc));\\n        int tx=xc-cx, ty=yc-cy;\\n        return ((tx*tx)+(ty*ty))<=(radius*radius);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if(x1<=xc && xc<=x2 && y1<=yc && yc<=y2) return true;\\n        int cx=Math.max(x1,Math.min(x2,xc)),cy=Math.max(y1,Math.min(y2,yc));\\n        int tx=xc-cx, ty=yc-cy;\\n        return ((tx*tx)+(ty*ty))<=(radius*radius);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006679,
                "title": "p23-5",
                "content": "Find point on rect closest to centre of cirl\\nThen if dis(point,centreOfCircl)-radius >0, then No intersec\\n\\nAnother solution of shifting origin\\nMove the center of the circle to the coordinate origin (0, 0), then this problem becomes \"is there a point (x, y) (x1 <= x <= x2, y1 <= y <= y2) satisfying x^2 + y^2 <= r^2\".\\n\\nSo just compute minimum values of x^2 and y^2, then compare the sum with r^2.",
                "solutionTags": [],
                "code": "Find point on rect closest to centre of cirl\\nThen if dis(point,centreOfCircl)-radius >0, then No intersec\\n\\nAnother solution of shifting origin\\nMove the center of the circle to the coordinate origin (0, 0), then this problem becomes \"is there a point (x, y) (x1 <= x <= x2, y1 <= y <= y2) satisfying x^2 + y^2 <= r^2\".\\n\\nSo just compute minimum values of x^2 and y^2, then compare the sum with r^2.",
                "codeTag": "Unknown"
            },
            {
                "id": 1006667,
                "title": "p23-5",
                "content": "Find point on rect closest to centre of cirl\\nThen if dis(point,centreOfCircl)-radius >0, then No intersec",
                "solutionTags": [],
                "code": "Find point on rect closest to centre of cirl\\nThen if dis(point,centreOfCircl)-radius >0, then No intersec",
                "codeTag": "Unknown"
            },
            {
                "id": 998708,
                "title": "java-geometry",
                "content": "Split into 3 cases when returning true\\n1. center of rectangle in circle\\n2. center of circle in rectangle\\n3. circle at least cut with one edge\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        double midx = (x1 + x2) / 2.0, midy = (y1 + y2) / 2.0;\\n        // center of rectangle in circle\\n        if ((midx - x_center) * (midx - x_center) + (midy - y_center) * (midy - y_center) <= radius * radius) return true;\\n        // center of circle in rectangle\\n        if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2) return true;\\n        // at least cut with one edge\\n        if (cut(x_center, x1, y1, y2, radius, y_center) || cut(x_center, x2, y1, y2, radius, y_center) || cut(y_center, y1, x1, x2, radius, x_center) || cut(y_center, y2, x1, x2, radius, x_center)) return true;\\n        return false;\\n    }\\n    private boolean cut(int xR, int xE, int lower, int upper, int radius, int center) {\\n        if (Math.abs(xR - xE) > radius) return false; \\n        int diff = Math.abs(xR - xE);\\n        double line = Math.sqrt(radius * radius - diff * diff);\\n        double start = center - line, end = center + line;\\n        return !(lower > end || start > upper);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        double midx = (x1 + x2) / 2.0, midy = (y1 + y2) / 2.0;\\n        // center of rectangle in circle\\n        if ((midx - x_center) * (midx - x_center) + (midy - y_center) * (midy - y_center) <= radius * radius) return true;\\n        // center of circle in rectangle\\n        if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2) return true;\\n        // at least cut with one edge\\n        if (cut(x_center, x1, y1, y2, radius, y_center) || cut(x_center, x2, y1, y2, radius, y_center) || cut(y_center, y1, x1, x2, radius, x_center) || cut(y_center, y2, x1, x2, radius, x_center)) return true;\\n        return false;\\n    }\\n    private boolean cut(int xR, int xE, int lower, int upper, int radius, int center) {\\n        if (Math.abs(xR - xE) > radius) return false; \\n        int diff = Math.abs(xR - xE);\\n        double line = Math.sqrt(radius * radius - diff * diff);\\n        double start = center - line, end = center + line;\\n        return !(lower > end || start > upper);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995484,
                "title": "intuition-with-live-demo-using-javascript-animation",
                "content": "Link to github: https://github.com/shreyanshsaha/leetcode-circle-and-rectangle-overlapping\\nLink to Demo: https://shreyanshsaha.github.io/leetcode-circle-and-rectangle-overlapping/\\n\\nI was confused with the intuition of the given solutions by other people so i decided to visualize it. Hope it helps!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 957749,
                "title": "java-0ms",
                "content": "public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int minsqr = 0;\\n        \\n        minsqr += x_center < x1 ? (x1 - x_center) * (x1 - x_center) : 0;\\n        minsqr += x_center > x2 ? (x_center - x2) * (x_center - x2) : 0;\\n        minsqr += y_center < y1 ? (y1 - y_center) * (y1 - y_center) : 0;\\n        minsqr += y_center > y2 ? (y_center - y2) * (y_center - y2) : 0;\\n        \\n        return minsqr <= radius * radius;\\n    }",
                "solutionTags": [],
                "code": "public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int minsqr = 0;\\n        \\n        minsqr += x_center < x1 ? (x1 - x_center) * (x1 - x_center) : 0;\\n        minsqr += x_center > x2 ? (x_center - x2) * (x_center - x2) : 0;\\n        minsqr += y_center < y1 ? (y1 - y_center) * (y1 - y_center) : 0;\\n        minsqr += y_center > y2 ? (y_center - y2) * (y_center - y2) : 0;\\n        \\n        return minsqr <= radius * radius;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 901818,
                "title": "c-check-three-cases-o-1",
                "content": "Case 1: Circle\\'s center is inside the rectangle.\\nCase 2: Circle\\'s center is outside the rectangle but at the same level: horizontally or vertically.\\nCase 3: Circle\\'s center is outside, we check distance to corners.\\n\\n```\\npublic class Solution\\n{\\n  public bool CheckOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2)\\n  {\\n    // circle center is inside\\n    if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)\\n      return true;\\n\\n    // vertically aligned\\n    if (x_center >= x1 && x_center <= x2)\\n    {\\n      var f1 = Math.Abs(y_center - y1) - radius;\\n      var f2 = Math.Abs(y_center - y2) - radius;\\n\\n      if (f1 <= 0 || f2 <= 0)\\n        return true;\\n    }\\n\\n    // horizontally aligned\\n    if (y_center >= y1 && y_center <= y2)\\n    {\\n      var f1 = Math.Abs(x_center - x1) - radius;\\n      var f2 = Math.Abs(x_center - x2) - radius;\\n\\n      if (f1 <= 0 || f2 <= 0)\\n        return true;\\n    }\\n\\n    // get distances to corners\\n    var d1 = GetDistance((x_center, y_center), (x1, y1));\\n    var d2 = GetDistance((x_center, y_center), (x2, y2));\\n    var d3 = GetDistance((x_center, y_center), (x2, y1));\\n    var d4 = GetDistance((x_center, y_center), (x1, y2));\\n\\n    if (d1 <= radius || d2 <= radius || d3 <= radius || d4 <= radius)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  private double GetDistance((int x, int y) p1, (int x, int y) p2)\\n  {\\n    return Math.Sqrt(Math.Pow(p2.x - p1.x, 2) + Math.Pow(p2.y - p1.y, 2));\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n  public bool CheckOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2)\\n  {\\n    // circle center is inside\\n    if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)\\n      return true;\\n\\n    // vertically aligned\\n    if (x_center >= x1 && x_center <= x2)\\n    {\\n      var f1 = Math.Abs(y_center - y1) - radius;\\n      var f2 = Math.Abs(y_center - y2) - radius;\\n\\n      if (f1 <= 0 || f2 <= 0)\\n        return true;\\n    }\\n\\n    // horizontally aligned\\n    if (y_center >= y1 && y_center <= y2)\\n    {\\n      var f1 = Math.Abs(x_center - x1) - radius;\\n      var f2 = Math.Abs(x_center - x2) - radius;\\n\\n      if (f1 <= 0 || f2 <= 0)\\n        return true;\\n    }\\n\\n    // get distances to corners\\n    var d1 = GetDistance((x_center, y_center), (x1, y1));\\n    var d2 = GetDistance((x_center, y_center), (x2, y2));\\n    var d3 = GetDistance((x_center, y_center), (x2, y1));\\n    var d4 = GetDistance((x_center, y_center), (x1, y2));\\n\\n    if (d1 <= radius || d2 <= radius || d3 <= radius || d4 <= radius)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  private double GetDistance((int x, int y) p1, (int x, int y) p2)\\n  {\\n    return Math.Sqrt(Math.Pow(p2.x - p1.x, 2) + Math.Pow(p2.y - p1.y, 2));\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858820,
                "title": "c-brute-forse",
                "content": "```\\nclass Solution {\\n public:\\n  bool checkOverlap(int radius,\\n                    int x_center,\\n                    int y_center,\\n                    int x1,\\n                    int y1,\\n                    int x2,\\n                    int y2) {\\n    for (int i = x1; i <= x2; ++i) {\\n      for (int j = y2; j >= y1; --j) {\\n        if (pow(abs(i - x_center), 2) + pow(abs(j - y_center), 2) <=\\n            radius * radius) {\\n          return true;\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  bool checkOverlap(int radius,\\n                    int x_center,\\n                    int y_center,\\n                    int x1,\\n                    int y1,\\n                    int x2,\\n                    int y2) {\\n    for (int i = x1; i <= x2; ++i) {\\n      for (int j = y2; j >= y1; --j) {\\n        if (pow(abs(i - x_center), 2) + pow(abs(j - y_center), 2) <=\\n            radius * radius) {\\n          return true;\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858633,
                "title": "easy-to-understand-java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int cx = getClosest(x_center, x1, x2);\\n        int cy = getClosest(y_center, y1, y2);\\n        double distance = calculateDistance(cx, cy, x_center, y_center);\\n        return distance <= (double) radius;\\n    }\\n    \\n    private int getClosest(int center, int first, int second) {\\n        if (center <= first && center < second) {\\n            return first;\\n        } else if (center > first && center <= second) {\\n            return center;\\n        } else {\\n            return second;\\n        }\\n    }\\n    \\n    private double calculateDistance(int x1, int y1, int x2, int y2) {\\n        long yDelta = Math.max(y1, y2) - Math.min(y1, y2);\\n        long xDelta = Math.max(x1, x2) - Math.min(x1, x2);\\n        return Math.sqrt(yDelta * yDelta + xDelta * xDelta);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int cx = getClosest(x_center, x1, x2);\\n        int cy = getClosest(y_center, y1, y2);\\n        double distance = calculateDistance(cx, cy, x_center, y_center);\\n        return distance <= (double) radius;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 855876,
                "title": "cpp14-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x = max(x1 , min(x2 , x_center));\\n        int y = max(y1 , min(y2 , y_center));\\n        int distance = (x-x_center)*(x-x_center) + (y-y_center)*(y-y_center); \\n        if(distance <= (radius * radius)) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x = max(x1 , min(x2 , x_center));\\n        int y = max(y1 , min(y2 , y_center));\\n        int distance = (x-x_center)*(x-x_center) + (y-y_center)*(y-y_center); \\n        if(distance <= (radius * radius)) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810073,
                "title": "java-solution-beats-100",
                "content": "Straightforward idea that divides the problem into different schenarios.\\nThere will be overlap if and only if the minimum distance between the circle center and any point of the rectanglular is less than or equal to the circle radius.\\n\\n```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if (xc >= x1 && xc <= x2 && yc >= y1 && yc <= y2) return true;\\n        else if (xc < x1){\\n            if (yc >= y1 && yc <= y2) return x1 - xc <= r;\\n            else if (yc < y1) return (x1-xc)*(x1-xc) + (y1-yc)*(y1-yc) <= r*r;\\n            else return (x1-xc)*(x1-xc) + (y2-yc)*(y2-yc) <= r*r;\\n        }\\n        else if (xc > x2) {\\n            if (yc >= y1 && yc <= y2) return xc - x2 <= r;\\n            else if (yc < y1) return (x2-xc)*(x2-xc) + (y1-yc)*(y1-yc) <= r*r;\\n            else return (x2-xc)*(x2-xc) + (y2-yc)*(y2-yc) <= r*r;\\n        }\\n        else if (yc < y1){\\n            return y1 - yc <= r;\\n        }\\n        else {\\n            return yc - y2 <= r;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if (xc >= x1 && xc <= x2 && yc >= y1 && yc <= y2) return true;\\n        else if (xc < x1){\\n            if (yc >= y1 && yc <= y2) return x1 - xc <= r;\\n            else if (yc < y1) return (x1-xc)*(x1-xc) + (y1-yc)*(y1-yc) <= r*r;\\n            else return (x1-xc)*(x1-xc) + (y2-yc)*(y2-yc) <= r*r;\\n        }\\n        else if (xc > x2) {\\n            if (yc >= y1 && yc <= y2) return xc - x2 <= r;\\n            else if (yc < y1) return (x2-xc)*(x2-xc) + (y1-yc)*(y1-yc) <= r*r;\\n            else return (x2-xc)*(x2-xc) + (y2-yc)*(y2-yc) <= r*r;\\n        }\\n        else if (yc < y1){\\n            return y1 - yc <= r;\\n        }\\n        else {\\n            return yc - y2 <= r;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781564,
                "title": "0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x= x_center;\\n        int y= y_center;\\n        if(x_center<x1)x=x1;\\n        else if(x_center>x2) x=x2;\\n         if(y_center<y1) y=y1;\\n        else if(y_center>y2) y=y2;\\n        int x_dist= x-x_center;\\n        int y_dist=y-y_center;\\n        return x_dist*x_dist + y_dist*y_dist <= radius*radius;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x= x_center;\\n        int y= y_center;\\n        if(x_center<x1)x=x1;\\n        else if(x_center>x2) x=x2;\\n         if(y_center<y1) y=y1;\\n        else if(y_center>y2) y=y2;\\n        int x_dist= x-x_center;\\n        int y_dist=y-y_center;\\n        return x_dist*x_dist + y_dist*y_dist <= radius*radius;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 766749,
                "title": "python-solution-simple-fast-easy-to-understand",
                "content": "```\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        Xn = max(x1, min(x_center, x2)) \\n        Yn = max(y1, min(y_center, y2)) \\n        Dx = Xn - x_center \\n        Dy = Yn - y_center \\n        return (Dx**2 + Dy**2) <= radius**2\\n```",
                "solutionTags": [],
                "code": "```\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        Xn = max(x1, min(x_center, x2)) \\n        Yn = max(y1, min(y_center, y2)) \\n        Dx = Xn - x_center \\n        Dy = Yn - y_center \\n        return (Dx**2 + Dy**2) <= radius**2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 742414,
                "title": "best-java-solution-so-far-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        // If center of circle is within the rectangle, return true.\\n        if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2) return true;\\n        // If center is aligned horizontally with the rect, check if distance from closest edge is less than radius.\\n        if (y_center >= y1 && y_center <= y2) {\\n            int nearestEdgeDistance = Math.min(Math.abs(x_center - x1), Math.abs(x_center - x2));\\n            if (nearestEdgeDistance <= radius) return true;\\n            else return false;\\n        }\\n        // If center is aligned vertically with the rect, check if distance from closest edge is less than radius.\\n        if (x_center >= x1 && x_center <= x2) {\\n            int nearestEdgeDistance = Math.min(Math.abs(y_center - y1), Math.abs(y_center - y2));\\n            if (nearestEdgeDistance <= radius) return true;\\n            else return false;\\n        }\\n        // Find out distance with the closest corner. Return true if less than radius.\\n        double nearestCornerDistance = Math.sqrt(Math.pow(Math.min(Math.abs(x_center - x1), Math.abs(x_center - x2)), 2) + Math.pow(Math.min(Math.abs(y_center - y1), Math.abs(y_center - y2)), 2));\\n        if (nearestCornerDistance <= radius) return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        // If center of circle is within the rectangle, return true.\\n        if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2) return true;\\n        // If center is aligned horizontally with the rect, check if distance from closest edge is less than radius.\\n        if (y_center >= y1 && y_center <= y2) {\\n            int nearestEdgeDistance = Math.min(Math.abs(x_center - x1), Math.abs(x_center - x2));\\n            if (nearestEdgeDistance <= radius) return true;\\n            else return false;\\n        }\\n        // If center is aligned vertically with the rect, check if distance from closest edge is less than radius.\\n        if (x_center >= x1 && x_center <= x2) {\\n            int nearestEdgeDistance = Math.min(Math.abs(y_center - y1), Math.abs(y_center - y2));\\n            if (nearestEdgeDistance <= radius) return true;\\n            else return false;\\n        }\\n        // Find out distance with the closest corner. Return true if less than radius.\\n        double nearestCornerDistance = Math.sqrt(Math.pow(Math.min(Math.abs(x_center - x1), Math.abs(x_center - x2)), 2) + Math.pow(Math.min(Math.abs(y_center - y1), Math.abs(y_center - y2)), 2));\\n        if (nearestCornerDistance <= radius) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734550,
                "title": "2-line-java-find-the-shortest-distance",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int dx = x_center >= x1 && x_center <= x2? x_center : x_center < x1? x1 : x2, dy = y_center >= y1 && y_center <= y2? y_center : y_center < y1? y1 : y2;\\n        return Math.sqrt((Math.pow((dx - x_center), 2) + Math.pow((dy - y_center), 2))) <= radius;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int dx = x_center >= x1 && x_center <= x2? x_center : x_center < x1? x1 : x2, dy = y_center >= y1 && y_center <= y2? y_center : y_center < y1? y1 : y2;\\n        return Math.sqrt((Math.pow((dx - x_center), 2) + Math.pow((dy - y_center), 2))) <= radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719015,
                "title": "cpp-solution-beats-100-time-and-91-space",
                "content": "pretty straight forward -  the idea is to find a point in the rectangle that is closest to the circle center. After the alogrithm aquired a candidate, the algorithm determines whether that point is inside the circle or not (inside is equivalent to distance is smaller than radius).\\nI computed the distances without taking the square root as it is a more complex and resource-consuming operation.\\n\\n```\\nclass Solution {\\nprivate:\\n    static inline int dist(int a1, int a2) {\\n        return (a1 - a2) * (a1 - a2);\\n    }\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x_closest, y_closest;\\n        if (x_center > x1 && x_center < x2)\\n            x_closest = x_center;\\n        else\\n            x_closest = abs(x1 - x_center) < abs(x2 - x_center) ? x1 : x2;\\n        \\n        if (y_center > y1 && y_center < y2)\\n            y_closest = y_center;\\n        else\\n            y_closest = abs(y1 - y_center) < abs(y2 - y_center) ? y1 : y2;\\n        \\n        return dist(x_closest, x_center) + dist(y_closest, y_center) <= radius * radius;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    static inline int dist(int a1, int a2) {\\n        return (a1 - a2) * (a1 - a2);\\n    }\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x_closest, y_closest;\\n        if (x_center > x1 && x_center < x2)\\n            x_closest = x_center;\\n        else\\n            x_closest = abs(x1 - x_center) < abs(x2 - x_center) ? x1 : x2;\\n        \\n        if (y_center > y1 && y_center < y2)\\n            y_closest = y_center;\\n        else\\n            y_closest = abs(y1 - y_center) < abs(y2 - y_center) ? y1 : y2;\\n        \\n        return dist(x_closest, x_center) + dist(y_closest, y_center) <= radius * radius;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706055,
                "title": "c-100-time-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x3 = x2;\\n        int y3 = y1;\\n        int x4 = x1;\\n        int y4 = y2;\\n        \\n        if(x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)\\n            return true;\\n        \\n        int d1 = pow(x1 - x_center, 2) + pow(y1 - y_center, 2);\\n        int d2 = pow(x2 - x_center, 2) + pow(y2 - y_center, 2);\\n        int d3 = pow(x3 - x_center, 2) + pow(y3 - y_center, 2);\\n        int d4 = pow(x4 - x_center, 2) + pow(y4 - y_center, 2);\\n        \\n        int r = pow(radius, 2);\\n        \\n        if(d1 <= r || d2 <= r || d3 <= r || d4 <= r)\\n            return true;\\n        \\n        int xx = x_center + radius;\\n        int yy = y_center;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center - radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center;\\n        yy = y_center + radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center;\\n        yy = y_center - radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        int xplus = x_center + radius;\\n        int xminus = x_center - radius;\\n        \\n        if(xplus >= x2 && xminus <= x1 && y_center <= y2 && y_center >= y1)\\n            return true;\\n        \\n        int yplus = y_center + radius;\\n        int yminus = y_center - radius;\\n        \\n        if(yplus >= y2 && yminus <= y1 && x_center <= x2 && x_center >= x1)\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x3 = x2;\\n        int y3 = y1;\\n        int x4 = x1;\\n        int y4 = y2;\\n        \\n        if(x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)\\n            return true;\\n        \\n        int d1 = pow(x1 - x_center, 2) + pow(y1 - y_center, 2);\\n        int d2 = pow(x2 - x_center, 2) + pow(y2 - y_center, 2);\\n        int d3 = pow(x3 - x_center, 2) + pow(y3 - y_center, 2);\\n        int d4 = pow(x4 - x_center, 2) + pow(y4 - y_center, 2);\\n        \\n        int r = pow(radius, 2);\\n        \\n        if(d1 <= r || d2 <= r || d3 <= r || d4 <= r)\\n            return true;\\n        \\n        int xx = x_center + radius;\\n        int yy = y_center;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center - radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center;\\n        yy = y_center + radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center;\\n        yy = y_center - radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        int xplus = x_center + radius;\\n        int xminus = x_center - radius;\\n        \\n        if(xplus >= x2 && xminus <= x1 && y_center <= y2 && y_center >= y1)\\n            return true;\\n        \\n        int yplus = y_center + radius;\\n        int yminus = y_center - radius;\\n        \\n        if(yplus >= y2 && yminus <= y1 && x_center <= x2 && x_center >= x1)\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660318,
                "title": "when-in-doubt-use-library",
                "content": "https://github.com/jaehyunp/stanfordacm/blob/master/code/Geometry.cc\\n```\\n// C++ routines for computational geometry.\\n\\n#include <iostream>\\n#include <vector>\\n#include <cmath>\\n#include <cassert>\\n\\nusing namespace std;\\n\\ndouble INF = 1e100;\\ndouble EPS = 1e-12;\\n\\nstruct PT { \\n  double x, y; \\n  PT() {}\\n  PT(double x, double y) : x(x), y(y) {}\\n  PT(const PT &p) : x(p.x), y(p.y)    {}\\n  PT operator + (const PT &p)  const { return PT(x+p.x, y+p.y); }\\n  PT operator - (const PT &p)  const { return PT(x-p.x, y-p.y); }\\n  PT operator * (double c)     const { return PT(x*c,   y*c  ); }\\n  PT operator / (double c)     const { return PT(x/c,   y/c  ); }\\n};\\n\\ndouble dot(PT p, PT q)     { return p.x*q.x+p.y*q.y; }\\ndouble dist2(PT p, PT q)   { return dot(p-q,p-q); }\\ndouble cross(PT p, PT q)   { return p.x*q.y-p.y*q.x; }\\nostream &operator<<(ostream &os, const PT &p) {\\n  return os << \"(\" << p.x << \",\" << p.y << \")\"; \\n}\\n\\n// rotate a point CCW or CW around the origin\\nPT RotateCCW90(PT p)   { return PT(-p.y,p.x); }\\nPT RotateCW90(PT p)    { return PT(p.y,-p.x); }\\nPT RotateCCW(PT p, double t) { \\n  return PT(p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)); \\n}\\n\\n// project point c onto line through a and b\\n// assuming a != b\\nPT ProjectPointLine(PT a, PT b, PT c) {\\n  return a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);\\n}\\n\\n// project point c onto line segment through a and b\\nPT ProjectPointSegment(PT a, PT b, PT c) {\\n  double r = dot(b-a,b-a);\\n  if (fabs(r) < EPS) return a;\\n  r = dot(c-a, b-a)/r;\\n  if (r < 0) return a;\\n  if (r > 1) return b;\\n  return a + (b-a)*r;\\n}\\n\\n// compute distance from c to segment between a and b\\ndouble DistancePointSegment(PT a, PT b, PT c) {\\n  return sqrt(dist2(c, ProjectPointSegment(a, b, c)));\\n}\\n\\n// compute distance between point (x,y,z) and plane ax+by+cz=d\\ndouble DistancePointPlane(double x, double y, double z,\\n                          double a, double b, double c, double d)\\n{\\n  return fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);\\n}\\n\\n// determine if lines from a to b and c to d are parallel or collinear\\nbool LinesParallel(PT a, PT b, PT c, PT d) { \\n  return fabs(cross(b-a, c-d)) < EPS; \\n}\\n\\nbool LinesCollinear(PT a, PT b, PT c, PT d) { \\n  return LinesParallel(a, b, c, d)\\n      && fabs(cross(a-b, a-c)) < EPS\\n      && fabs(cross(c-d, c-a)) < EPS; \\n}\\n\\n// determine if line segment from a to b intersects with \\n// line segment from c to d\\nbool SegmentsIntersect(PT a, PT b, PT c, PT d) {\\n  if (LinesCollinear(a, b, c, d)) {\\n    if (dist2(a, c) < EPS || dist2(a, d) < EPS ||\\n      dist2(b, c) < EPS || dist2(b, d) < EPS) return true;\\n    if (dot(c-a, c-b) > 0 && dot(d-a, d-b) > 0 && dot(c-b, d-b) > 0)\\n      return false;\\n    return true;\\n  }\\n  if (cross(d-a, b-a) * cross(c-a, b-a) > 0) return false;\\n  if (cross(a-c, d-c) * cross(b-c, d-c) > 0) return false;\\n  return true;\\n}\\n\\n// compute intersection of line passing through a and b\\n// with line passing through c and d, assuming that unique\\n// intersection exists; for segment intersection, check if\\n// segments intersect first\\nPT ComputeLineIntersection(PT a, PT b, PT c, PT d) {\\n  b=b-a; d=c-d; c=c-a;\\n  assert(dot(b, b) > EPS && dot(d, d) > EPS);\\n  return a + b*cross(c, d)/cross(b, d);\\n}\\n\\n// compute center of circle given three points\\nPT ComputeCircleCenter(PT a, PT b, PT c) {\\n  b=(a+b)/2;\\n  c=(a+c)/2;\\n  return ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));\\n}\\n\\n// determine if point is in a possibly non-convex polygon (by William\\n// Randolph Franklin); returns 1 for strictly interior points, 0 for\\n// strictly exterior points, and 0 or 1 for the remaining points.\\n// Note that it is possible to convert this into an *exact* test using\\n// integer arithmetic by taking care of the division appropriately\\n// (making sure to deal with signs properly) and then by writing exact\\n// tests for checking point on polygon boundary\\nbool PointInPolygon(const vector<PT> &p, PT q) {\\n  bool c = 0;\\n  for (int i = 0; i < p.size(); i++){\\n    int j = (i+1)%p.size();\\n    if ((p[i].y <= q.y && q.y < p[j].y || \\n      p[j].y <= q.y && q.y < p[i].y) &&\\n      q.x < p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))\\n      c = !c;\\n  }\\n  return c;\\n}\\n\\n// determine if point is on the boundary of a polygon\\nbool PointOnPolygon(const vector<PT> &p, PT q) {\\n  for (int i = 0; i < p.size(); i++)\\n    if (dist2(ProjectPointSegment(p[i], p[(i+1)%p.size()], q), q) < EPS)\\n      return true;\\n    return false;\\n}\\n\\n// compute intersection of line through points a and b with\\n// circle centered at c with radius r > 0\\nvector<PT> CircleLineIntersection(PT a, PT b, PT c, double r) {\\n  vector<PT> ret;\\n  b = b-a;\\n  a = a-c;\\n  double A = dot(b, b);\\n  double B = dot(a, b);\\n  double C = dot(a, a) - r*r;\\n  double D = B*B - A*C;\\n  if (D < -EPS) return ret;\\n  ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);\\n  if (D > EPS)\\n    ret.push_back(c+a+b*(-B-sqrt(D))/A);\\n  return ret;\\n}\\n\\n// compute intersection of circle centered at a with radius r\\n// with circle centered at b with radius R\\nvector<PT> CircleCircleIntersection(PT a, PT b, double r, double R) {\\n  vector<PT> ret;\\n  double d = sqrt(dist2(a, b));\\n  if (d > r+R || d+min(r, R) < max(r, R)) return ret;\\n  double x = (d*d-R*R+r*r)/(2*d);\\n  double y = sqrt(r*r-x*x);\\n  PT v = (b-a)/d;\\n  ret.push_back(a+v*x + RotateCCW90(v)*y);\\n  if (y > 0)\\n    ret.push_back(a+v*x - RotateCCW90(v)*y);\\n  return ret;\\n}\\n\\n// This code computes the area or centroid of a (possibly nonconvex)\\n// polygon, assuming that the coordinates are listed in a clockwise or\\n// counterclockwise fashion.  Note that the centroid is often known as\\n// the \"center of gravity\" or \"center of mass\".\\ndouble ComputeSignedArea(const vector<PT> &p) {\\n  double area = 0;\\n  for(int i = 0; i < p.size(); i++) {\\n    int j = (i+1) % p.size();\\n    area += p[i].x*p[j].y - p[j].x*p[i].y;\\n  }\\n  return area / 2.0;\\n}\\n\\ndouble ComputeArea(const vector<PT> &p) {\\n  return fabs(ComputeSignedArea(p));\\n}\\n\\nPT ComputeCentroid(const vector<PT> &p) {\\n  PT c(0,0);\\n  double scale = 6.0 * ComputeSignedArea(p);\\n  for (int i = 0; i < p.size(); i++){\\n    int j = (i+1) % p.size();\\n    c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);\\n  }\\n  return c / scale;\\n}\\n\\n// tests whether or not a given polygon (in CW or CCW order) is simple\\nbool IsSimple(const vector<PT> &p) {\\n  for (int i = 0; i < p.size(); i++) {\\n    for (int k = i+1; k < p.size(); k++) {\\n      int j = (i+1) % p.size();\\n      int l = (k+1) % p.size();\\n      if (i == l || j == k) continue;\\n      if (SegmentsIntersect(p[i], p[j], p[k], p[l])) \\n        return false;\\n    }\\n  }\\n  return true;\\n}\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        vector<PT> rect;\\n        rect.push_back(PT(x1,y1));\\n        rect.push_back(PT(x1,y2));\\n        rect.push_back(PT(x2,y2));\\n        rect.push_back(PT(x2,y1));\\n        PT center=PT(x_center,y_center);\\n       return  DistancePointSegment(rect[0],rect[1],center) <= radius\\n           ||  DistancePointSegment(rect[1],rect[2],center) <= radius \\n           ||  DistancePointSegment(rect[2],rect[3],center) <= radius\\n           ||  DistancePointSegment(rect[3],rect[0],center) <= radius\\n           ||  PointInPolygon(rect,center);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// C++ routines for computational geometry.\\n\\n#include <iostream>\\n#include <vector>\\n#include <cmath>\\n#include <cassert>\\n\\nusing namespace std;\\n\\ndouble INF = 1e100;\\ndouble EPS = 1e-12;\\n\\nstruct PT { \\n  double x, y; \\n  PT() {}\\n  PT(double x, double y) : x(x), y(y) {}\\n  PT(const PT &p) : x(p.x), y(p.y)    {}\\n  PT operator + (const PT &p)  const { return PT(x+p.x, y+p.y); }\\n  PT operator - (const PT &p)  const { return PT(x-p.x, y-p.y); }\\n  PT operator * (double c)     const { return PT(x*c,   y*c  ); }\\n  PT operator / (double c)     const { return PT(x/c,   y/c  ); }\\n};\\n\\ndouble dot(PT p, PT q)     { return p.x*q.x+p.y*q.y; }\\ndouble dist2(PT p, PT q)   { return dot(p-q,p-q); }\\ndouble cross(PT p, PT q)   { return p.x*q.y-p.y*q.x; }\\nostream &operator<<(ostream &os, const PT &p) {\\n  return os << \"(\" << p.x << \",\" << p.y << \")\"; \\n}\\n\\n// rotate a point CCW or CW around the origin\\nPT RotateCCW90(PT p)   { return PT(-p.y,p.x); }\\nPT RotateCW90(PT p)    { return PT(p.y,-p.x); }\\nPT RotateCCW(PT p, double t) { \\n  return PT(p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)); \\n}\\n\\n// project point c onto line through a and b\\n// assuming a != b\\nPT ProjectPointLine(PT a, PT b, PT c) {\\n  return a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);\\n}\\n\\n// project point c onto line segment through a and b\\nPT ProjectPointSegment(PT a, PT b, PT c) {\\n  double r = dot(b-a,b-a);\\n  if (fabs(r) < EPS) return a;\\n  r = dot(c-a, b-a)/r;\\n  if (r < 0) return a;\\n  if (r > 1) return b;\\n  return a + (b-a)*r;\\n}\\n\\n// compute distance from c to segment between a and b\\ndouble DistancePointSegment(PT a, PT b, PT c) {\\n  return sqrt(dist2(c, ProjectPointSegment(a, b, c)));\\n}\\n\\n// compute distance between point (x,y,z) and plane ax+by+cz=d\\ndouble DistancePointPlane(double x, double y, double z,\\n                          double a, double b, double c, double d)\\n{\\n  return fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);\\n}\\n\\n// determine if lines from a to b and c to d are parallel or collinear\\nbool LinesParallel(PT a, PT b, PT c, PT d) { \\n  return fabs(cross(b-a, c-d)) < EPS; \\n}\\n\\nbool LinesCollinear(PT a, PT b, PT c, PT d) { \\n  return LinesParallel(a, b, c, d)\\n      && fabs(cross(a-b, a-c)) < EPS\\n      && fabs(cross(c-d, c-a)) < EPS; \\n}\\n\\n// determine if line segment from a to b intersects with \\n// line segment from c to d\\nbool SegmentsIntersect(PT a, PT b, PT c, PT d) {\\n  if (LinesCollinear(a, b, c, d)) {\\n    if (dist2(a, c) < EPS || dist2(a, d) < EPS ||\\n      dist2(b, c) < EPS || dist2(b, d) < EPS) return true;\\n    if (dot(c-a, c-b) > 0 && dot(d-a, d-b) > 0 && dot(c-b, d-b) > 0)\\n      return false;\\n    return true;\\n  }\\n  if (cross(d-a, b-a) * cross(c-a, b-a) > 0) return false;\\n  if (cross(a-c, d-c) * cross(b-c, d-c) > 0) return false;\\n  return true;\\n}\\n\\n// compute intersection of line passing through a and b\\n// with line passing through c and d, assuming that unique\\n// intersection exists; for segment intersection, check if\\n// segments intersect first\\nPT ComputeLineIntersection(PT a, PT b, PT c, PT d) {\\n  b=b-a; d=c-d; c=c-a;\\n  assert(dot(b, b) > EPS && dot(d, d) > EPS);\\n  return a + b*cross(c, d)/cross(b, d);\\n}\\n\\n// compute center of circle given three points\\nPT ComputeCircleCenter(PT a, PT b, PT c) {\\n  b=(a+b)/2;\\n  c=(a+c)/2;\\n  return ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));\\n}\\n\\n// determine if point is in a possibly non-convex polygon (by William\\n// Randolph Franklin); returns 1 for strictly interior points, 0 for\\n// strictly exterior points, and 0 or 1 for the remaining points.\\n// Note that it is possible to convert this into an *exact* test using\\n// integer arithmetic by taking care of the division appropriately\\n// (making sure to deal with signs properly) and then by writing exact\\n// tests for checking point on polygon boundary\\nbool PointInPolygon(const vector<PT> &p, PT q) {\\n  bool c = 0;\\n  for (int i = 0; i < p.size(); i++){\\n    int j = (i+1)%p.size();\\n    if ((p[i].y <= q.y && q.y < p[j].y || \\n      p[j].y <= q.y && q.y < p[i].y) &&\\n      q.x < p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))\\n      c = !c;\\n  }\\n  return c;\\n}\\n\\n// determine if point is on the boundary of a polygon\\nbool PointOnPolygon(const vector<PT> &p, PT q) {\\n  for (int i = 0; i < p.size(); i++)\\n    if (dist2(ProjectPointSegment(p[i], p[(i+1)%p.size()], q), q) < EPS)\\n      return true;\\n    return false;\\n}\\n\\n// compute intersection of line through points a and b with\\n// circle centered at c with radius r > 0\\nvector<PT> CircleLineIntersection(PT a, PT b, PT c, double r) {\\n  vector<PT> ret;\\n  b = b-a;\\n  a = a-c;\\n  double A = dot(b, b);\\n  double B = dot(a, b);\\n  double C = dot(a, a) - r*r;\\n  double D = B*B - A*C;\\n  if (D < -EPS) return ret;\\n  ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);\\n  if (D > EPS)\\n    ret.push_back(c+a+b*(-B-sqrt(D))/A);\\n  return ret;\\n}\\n\\n// compute intersection of circle centered at a with radius r\\n// with circle centered at b with radius R\\nvector<PT> CircleCircleIntersection(PT a, PT b, double r, double R) {\\n  vector<PT> ret;\\n  double d = sqrt(dist2(a, b));\\n  if (d > r+R || d+min(r, R) < max(r, R)) return ret;\\n  double x = (d*d-R*R+r*r)/(2*d);\\n  double y = sqrt(r*r-x*x);\\n  PT v = (b-a)/d;\\n  ret.push_back(a+v*x + RotateCCW90(v)*y);\\n  if (y > 0)\\n    ret.push_back(a+v*x - RotateCCW90(v)*y);\\n  return ret;\\n}\\n\\n// This code computes the area or centroid of a (possibly nonconvex)\\n// polygon, assuming that the coordinates are listed in a clockwise or\\n// counterclockwise fashion.  Note that the centroid is often known as\\n// the \"center of gravity\" or \"center of mass\".\\ndouble ComputeSignedArea(const vector<PT> &p) {\\n  double area = 0;\\n  for(int i = 0; i < p.size(); i++) {\\n    int j = (i+1) % p.size();\\n    area += p[i].x*p[j].y - p[j].x*p[i].y;\\n  }\\n  return area / 2.0;\\n}\\n\\ndouble ComputeArea(const vector<PT> &p) {\\n  return fabs(ComputeSignedArea(p));\\n}\\n\\nPT ComputeCentroid(const vector<PT> &p) {\\n  PT c(0,0);\\n  double scale = 6.0 * ComputeSignedArea(p);\\n  for (int i = 0; i < p.size(); i++){\\n    int j = (i+1) % p.size();\\n    c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);\\n  }\\n  return c / scale;\\n}\\n\\n// tests whether or not a given polygon (in CW or CCW order) is simple\\nbool IsSimple(const vector<PT> &p) {\\n  for (int i = 0; i < p.size(); i++) {\\n    for (int k = i+1; k < p.size(); k++) {\\n      int j = (i+1) % p.size();\\n      int l = (k+1) % p.size();\\n      if (i == l || j == k) continue;\\n      if (SegmentsIntersect(p[i], p[j], p[k], p[l])) \\n        return false;\\n    }\\n  }\\n  return true;\\n}\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        vector<PT> rect;\\n        rect.push_back(PT(x1,y1));\\n        rect.push_back(PT(x1,y2));\\n        rect.push_back(PT(x2,y2));\\n        rect.push_back(PT(x2,y1));\\n        PT center=PT(x_center,y_center);\\n       return  DistancePointSegment(rect[0],rect[1],center) <= radius\\n           ||  DistancePointSegment(rect[1],rect[2],center) <= radius \\n           ||  DistancePointSegment(rect[2],rect[3],center) <= radius\\n           ||  DistancePointSegment(rect[3],rect[0],center) <= radius\\n           ||  PointInPolygon(rect,center);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 624143,
                "title": "go-straight-forward-beat-100",
                "content": "```\\nfunc checkOverlap(r, x, y, x1, y1, x2, y2 int) bool {\\n    if x >= x1 && x <= x2  && y >= y1 && y <= y2 {\\n        return true\\n    } else if x >= x1 && x <= x2 && (y < y1 || y > y2) {\\n        if (y1 - y > 0 && y1 - y <= r) || (y - y2 > 0 && y - y2 <= r) {\\n            return true\\n        }\\n    } else if (x < x1 || x > x2) && y >= y1 && y <= y2 {\\n        if (x1 - x > 0 && x1 - x <= r) || (x - x2 > 0 && x - x2 <= r) {\\n            return true\\n        }\\n    } else if ((x - x1) * (x - x1) + (y - y1) * (y - y1) <= r * r) ||\\n              ((x - x2) * (x - x2) + (y - y1) * (y - y1) <= r * r) ||\\n              ((x - x1) * (x - x1) + (y - y2) * (y - y2) <= r * r) ||\\n              ((x - x2) * (x - x2) + (y - y2) * (y - y2) <= r * r) {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc checkOverlap(r, x, y, x1, y1, x2, y2 int) bool {\\n    if x >= x1 && x <= x2  && y >= y1 && y <= y2 {\\n        return true\\n    } else if x >= x1 && x <= x2 && (y < y1 || y > y2) {\\n        if (y1 - y > 0 && y1 - y <= r) || (y - y2 > 0 && y - y2 <= r) {\\n            return true\\n        }\\n    } else if (x < x1 || x > x2) && y >= y1 && y <= y2 {\\n        if (x1 - x > 0 && x1 - x <= r) || (x - x2 > 0 && x - x2 <= r) {\\n            return true\\n        }\\n    } else if ((x - x1) * (x - x1) + (y - y1) * (y - y1) <= r * r) ||\\n              ((x - x2) * (x - x2) + (y - y1) * (y - y1) <= r * r) ||\\n              ((x - x1) * (x - x1) + (y - y2) * (y - y2) <= r * r) ||\\n              ((x - x2) * (x - x2) + (y - y2) * (y - y2) <= r * r) {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 617386,
                "title": "c-readable-commented-solution-still-100-faster",
                "content": "```\\n\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        //is the circle center within the left and right sides of the rectangle, and if not is it closer to the left edge or right edge of the rectangle?\\n        int rectSideX = 0;\\n        if(x1 > x_center) {\\n            //circle is to the left of the rectangle\\n            rectSideX = x1;\\n        } else if(x2 < x_center) {\\n            //circle is to the right of the rectangle\\n            rectSideX = x2;\\n        } else {\\n            //circle center is within the left and right bounds of the rect\\n            //(but not necessarily top and bottom)\\n            rectSideX = x_center;\\n        }\\n        \\n        int rectSideY = 0;\\n        if(y1 > y_center) {\\n            //circle is below the rectangle\\n            rectSideY = y1;\\n        } else if(y2 < y_center) {\\n            //circle is above the rectangle\\n            rectSideY = y2;\\n        } else {\\n            //circle center is within the top and bottom bounds of the rectangle\\n            rectSideY = y_center;\\n        }\\n        \\n        int dx = x_center - rectSideX;\\n        int dy = y_center - rectSideY;\\n        double distance = sqrt(dx * dx + dy * dy);\\n        \\n        return distance <= radius;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        //is the circle center within the left and right sides of the rectangle, and if not is it closer to the left edge or right edge of the rectangle?\\n        int rectSideX = 0;\\n        if(x1 > x_center) {\\n            //circle is to the left of the rectangle\\n            rectSideX = x1;\\n        } else if(x2 < x_center) {\\n            //circle is to the right of the rectangle\\n            rectSideX = x2;\\n        } else {\\n            //circle center is within the left and right bounds of the rect\\n            //(but not necessarily top and bottom)\\n            rectSideX = x_center;\\n        }\\n        \\n        int rectSideY = 0;\\n        if(y1 > y_center) {\\n            //circle is below the rectangle\\n            rectSideY = y1;\\n        } else if(y2 < y_center) {\\n            //circle is above the rectangle\\n            rectSideY = y2;\\n        } else {\\n            //circle center is within the top and bottom bounds of the rectangle\\n            rectSideY = y_center;\\n        }\\n        \\n        int dx = x_center - rectSideX;\\n        int dy = y_center - rectSideY;\\n        double distance = sqrt(dx * dx + dy * dy);\\n        \\n        return distance <= radius;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 610977,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607169,
                "title": "1401-circle-and-rectangle-overlapping-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Find the Closest Distance Between the Circle and the Rec**\\n| O(T): O() | O(S): O() | Rt: 24ms | \\n```python\\n    def checkOverlap(self, radius: int, x: int, y: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        closest_x = 0 if x1<=x<=x2 else min(abs(x-x1), abs(x2-x))\\n        closest_y = 0 if y1<=y<=y2 else min(abs(y-y1), abs(y2-y))\\n        return closest_x ** 2 + closest_y ** 2 <= radius ** 2\\n```\\nReferrence: https://leetcode.com/problems/circle-and-rectangle-overlapping/discuss/563391/Java-3-lines-super-easy-math-solution",
                "solutionTags": [],
                "code": "```python\\n    def checkOverlap(self, radius: int, x: int, y: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        closest_x = 0 if x1<=x<=x2 else min(abs(x-x1), abs(x2-x))\\n        closest_y = 0 if y1<=y<=y2 else min(abs(y-y1), abs(y2-y))\\n        return closest_x ** 2 + closest_y ** 2 <= radius ** 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 598164,
                "title": "python-scipy-optimization-solution-slow-but-something-different",
                "content": "We want to find the smallest distance from the centre of the circle, subject to being inside the rectangle. This is a constrained optimisation problem with smooth objective function, so we can just use scipy L-BFGS-B algrithm to get us the answer.\\n\\nThe answer to the question is then `True` if and only if the solution found by optimisation is smaller or equal than the radius squared.\\n\\n```python\\nimport numpy as np\\nfrom scipy.optimize import minimize\\n\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n\\n        l2norm = lambda x: (x[0] - x_center)**2 + (x[1] - y_center)**2  # objective function\\n        jacobian = lambda x: np.array([2*(x[0] - x_center), 2*(x[1] - y_center)])  # gradient\\n        min_r = minimize(\\n            l2norm, \\n            x0=[(x1 + x2) / 2., (y1 + y2) / 2.],\\n            jac=jacobian,\\n            method=\"L-BFGS-B\", \\n            bounds=[[x1, x2], [y1, y2]]\\n        ).fun\\n        \\n        return round(min_r, 10) <= radius**2\\n```",
                "solutionTags": [],
                "code": "```python\\nimport numpy as np\\nfrom scipy.optimize import minimize\\n\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n\\n        l2norm = lambda x: (x[0] - x_center)**2 + (x[1] - y_center)**2  # objective function\\n        jacobian = lambda x: np.array([2*(x[0] - x_center), 2*(x[1] - y_center)])  # gradient\\n        min_r = minimize(\\n            l2norm, \\n            x0=[(x1 + x2) / 2., (y1 + y2) / 2.],\\n            jac=jacobian,\\n            method=\"L-BFGS-B\", \\n            bounds=[[x1, x2], [y1, y2]]\\n        ).fun\\n        \\n        return round(min_r, 10) <= radius**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590737,
                "title": "simple-and-efficient-python-solution",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        rwidth, rheight = x2 - x1, y2 - y1\\n        rcx, rcy = x1 + rwidth / 2, y1 + rheight / 2\\n        \\n        if x1 <= x_center <= x2:\\n            return abs(y_center - rcy) <= radius + rheight / 2\\n        \\n        if y1 <= y_center <= y2:\\n            return abs(x_center - rcx) <= radius + rwidth / 2\\n        \\n        return any([(x - x_center) ** 2 + (y - y_center) ** 2 <= radius ** 2 for x in [x1, x2] for y in [y1, y2]])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        rwidth, rheight = x2 - x1, y2 - y1\\n        rcx, rcy = x1 + rwidth / 2, y1 + rheight / 2\\n        \\n        if x1 <= x_center <= x2:\\n            return abs(y_center - rcy) <= radius + rheight / 2\\n        \\n        if y1 <= y_center <= y2:\\n            return abs(x_center - rcx) <= radius + rwidth / 2\\n        \\n        return any([(x - x_center) ** 2 + (y - y_center) ** 2 <= radius ** 2 for x in [x1, x2] for y in [y1, y2]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590210,
                "title": "guys-doubt-if-the-test-cases-are-weak",
                "content": "\\'\\'\\'\\'\\nbool checkOverlap(int r, int x0, int y0, int x1, int y1, int x2, int y2) \\n    {\\n        int i=0,j=0;\\n        \\n        for(i=x1;i<=x2;i++)\\n        {\\n            for(j=y1;j<=y2;j++)\\n            {\\n                int d = (i-x0)*(i-x0) + (j-y0)*(j-y0) ;\\n                if(d<=r*r)\\n                    return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n\\t\\n\\tGuys, I have a doubt, ive done a Brute force by taking all the integer points in the rectangle, finding the distance from the circles centre and returning true if that distance is less than the circles radius,\\n\\tThis solution passed all the 90 test cases,\\n\\t\\n\\tbut what iff the circle and the rectangle intersect at a non integer coordinate?",
                "solutionTags": [],
                "code": "\\'\\'\\'\\'\\nbool checkOverlap(int r, int x0, int y0, int x1, int y1, int x2, int y2) \\n    {\\n        int i=0,j=0;\\n        \\n        for(i=x1;i<=x2;i++)\\n        {\\n            for(j=y1;j<=y2;j++)\\n            {\\n                int d = (i-x0)*(i-x0) + (j-y0)*(j-y0) ;\\n                if(d<=r*r)\\n                    return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n\\t\\n\\tGuys, I have a doubt, ive done a Brute force by taking all the integer points in the rectangle, finding the distance from the circles centre and returning true if that distance is less than the circles radius,\\n\\tThis solution passed all the 90 test cases,\\n\\t\\n\\tbut what iff the circle and the rectangle intersect at a non integer coordinate?",
                "codeTag": "Unknown"
            },
            {
                "id": 588315,
                "title": "java-solution-beats-both-t-and-s",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        double r2 = Math.pow(radius, 2);\\n        if (y_center >= y2) {\\n            return (x_center <= x2 && x_center >= x1 && y_center - y2 <= radius) ||\\n                    distance(x1, x_center, y2, y_center) <= r2 || distance(x2, x_center, y2, y_center) <= r2;\\n        } else if (y_center <= y1) {\\n            return (x_center <= x2 && x_center >= x1 && y1 - y_center <= radius) ||\\n                    distance(x1, x_center, y1, y_center) <= r2 || distance(x2, x_center, y1, y_center) <= r2;\\n        } else if (x_center <= x1) return x1-x_center <= radius;\\n        else if (x_center >= x2) return x_center-x2 <= radius;\\n        return true;\\n\\n\\n    }\\n\\n    public double distance(int x1, int x2, int y1, int y2) {\\n        return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        double r2 = Math.pow(radius, 2);\\n        if (y_center >= y2) {\\n            return (x_center <= x2 && x_center >= x1 && y_center - y2 <= radius) ||\\n                    distance(x1, x_center, y2, y_center) <= r2 || distance(x2, x_center, y2, y_center) <= r2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 581907,
                "title": "java-0ms-3-line-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int xres=Math.min(Math.max(x1,x2),Math.max(Math.min(x1,x2),x_center));\\n        int yres=Math.min(Math.max(y1,y2),Math.max(Math.min(y1,y2),y_center));\\n        return (x_center-xres)*(x_center-xres)+(y_center-yres)*(y_center-yres)-radius*radius<=0;\\n    }\\n}\\n```\\nExplaination: As the rectangle is axis aligned we can compare x, y coordinates to find the nearest point in rectangle to the circle. For eg:\\nfor x co ordinate- compare the least of the 2 rect abscissa with the abscissa of center to get the max of the two. Compare this with the max of the 2 rect abscissa to get the minimum. We do this to check the position and estimating nearest co-ordinate to the circle.\\n\\nNow we must check whether the distance between the calculated point and the center of radius less than or equal to the radius. if it is less than radius the circle and the rect overlap else they dont.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int xres=Math.min(Math.max(x1,x2),Math.max(Math.min(x1,x2),x_center));\\n        int yres=Math.min(Math.max(y1,y2),Math.max(Math.min(y1,y2),y_center));\\n        return (x_center-xres)*(x_center-xres)+(y_center-yres)*(y_center-yres)-radius*radius<=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575165,
                "title": "golang",
                "content": "```\\nimport (\\n    \"math\"\\n)\\ntype point struct {\\n    x int\\n    y int\\n}\\nfunc checkOverlap(r int, x_c int, y_c int, x1 int, y1 int, x2 int, y2 int) bool {\\n    corners := []point{point{x1, y1}, point{x2, y1}, point{x1, y2}, point{x2, y2}}\\n    for _, corner := range corners {\\n        if math.Pow(float64(corner.x - x_c), 2) + math.Pow(float64(corner.y - y_c), 2) <= math.Pow(float64(r), 2) {\\n            return true\\n        }\\n    }\\n    \\n    xs := []int{x1, x2}\\n    for _, x := range xs {\\n        if x_c - r <= x && x <= x_c + r && y1 <= y_c && y_c <= y2 {\\n            return true\\n        }\\n    }\\n    ys := []int{y1, y2}\\n    for _, y := range ys {\\n        if y_c - r <= y && y <= y_c + r && x1 <= x_c && x_c <= x2 {\\n            return true\\n        }\\n    }\\n    if x1 <= x_c && x_c <= x2 && y1 <= y_c && y_c <= y2 {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport (\\n    \"math\"\\n)\\ntype point struct {\\n    x int\\n    y int\\n}\\nfunc checkOverlap(r int, x_c int, y_c int, x1 int, y1 int, x2 int, y2 int) bool {\\n    corners := []point{point{x1, y1}, point{x2, y1}, point{x1, y2}, point{x2, y2}}\\n    for _, corner := range corners {\\n        if math.Pow(float64(corner.x - x_c), 2) + math.Pow(float64(corner.y - y_c), 2) <= math.Pow(float64(r), 2) {\\n            return true\\n        }\\n    }\\n    \\n    xs := []int{x1, x2}\\n    for _, x := range xs {\\n        if x_c - r <= x && x <= x_c + r && y1 <= y_c && y_c <= y2 {\\n            return true\\n        }\\n    }\\n    ys := []int{y1, y2}\\n    for _, y := range ys {\\n        if y_c - r <= y && y <= y_c + r && x1 <= x_c && x_c <= x2 {\\n            return true\\n        }\\n    }\\n    if x1 <= x_c && x_c <= x2 && y1 <= y_c && y_c <= y2 {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 571184,
                "title": "c-simple-solution-100-faster",
                "content": "This is basically a simple trick where we try to find the distance the between the center of circle and that of nearest side of rectangle.\\nAfter that we find if the answer from above is greater than the radius or not.\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570329,
                "title": "cpp-0ms-100-faster",
                "content": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n#define mod 1000000007\\nclass Solution \\n{\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) \\n    {\\n        //there are three cases in which a circle and a rectangle can overlap:\\n        //case 1: they overlap partially, hence circumference of circle and an edge of rectangle will intersect\\n        \\n        //left edge of rectangle\\n        int x=x1,y=y1;\\n        while(y<=y2)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true; \\n           y++; \\n        }\\n        \\n        //bottom edge of rectangle\\n        x=x1; y=y1;\\n        while(x<=x2)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true; \\n              x++;\\n        }\\n        \\n        //top edge of rectangle\\n        x=x2; y=y2;\\n        while(x>=x1)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true;\\n           x--; \\n        }\\n        \\n        //right edge of rectangle\\n        x=x2; y=y2;\\n        while(y>=y1)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true;\\n           y--; \\n        }\\n        \\n        //case 2 : circle lies in the rectangle\\n        if(x_center>=x1&&x_center<=x2&&y_center>=y1&&y_center<=y2)\\n           return true;\\n        \\n        //case 3 : rectangle lies in the circle\\n        x=x1; y=y1;\\n        int dist=dist=pow(x-x_center,2)+pow(y-y_center,2);\\n        if(dist<=pow(radius,2))\\n           return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n#define mod 1000000007\\nclass Solution \\n{\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) \\n    {\\n        //there are three cases in which a circle and a rectangle can overlap:\\n        //case 1: they overlap partially, hence circumference of circle and an edge of rectangle will intersect\\n        \\n        //left edge of rectangle\\n        int x=x1,y=y1;\\n        while(y<=y2)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true; \\n           y++; \\n        }\\n        \\n        //bottom edge of rectangle\\n        x=x1; y=y1;\\n        while(x<=x2)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true; \\n              x++;\\n        }\\n        \\n        //top edge of rectangle\\n        x=x2; y=y2;\\n        while(x>=x1)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true;\\n           x--; \\n        }\\n        \\n        //right edge of rectangle\\n        x=x2; y=y2;\\n        while(y>=y1)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true;\\n           y--; \\n        }\\n        \\n        //case 2 : circle lies in the rectangle\\n        if(x_center>=x1&&x_center<=x2&&y_center>=y1&&y_center<=y2)\\n           return true;\\n        \\n        //case 3 : rectangle lies in the circle\\n        x=x1; y=y1;\\n        int dist=dist=pow(x-x_center,2)+pow(y-y_center,2);\\n        if(dist<=pow(radius,2))\\n           return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569395,
                "title": "c-100-faster-100-less-memory-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        if(x_center+radius<x1||x_center-radius>x2||y_center+radius<y1||y_center-radius>y2){\\n            cout<<\"1\";\\n            return false;\\n        }\\n        if(x_center<x1){\\n            if(y_center<y1){\\n                if(pow((x1-x_center),2)+pow((y1-y_center),2)>radius*radius){\\n                    cout<<\"2\";\\n                    return false;\\n                }\\n            }\\n            if(y_center>y2){\\n                if(pow((x1-x_center),2)+pow((y_center-y2),2)>radius*radius){\\n                    cout<<\"3\";\\n                    return false;\\n                }\\n            }\\n        }\\n        if(x_center>x2){\\n            if(y_center<y1){\\n                if(pow((x_center-x2),2)+pow((y1-y_center),2)>radius*radius){\\n                    cout<<\"4\";\\n                    return false;\\n                }\\n            }\\n            if(y_center>y2){\\n                if(pow((x_center-x2),2)+pow((y_center-y2),2)>radius*radius){\\n                    cout<<\"5\";\\n                    return false;\\n                }\\n            }\\n        }\\n            \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        if(x_center+radius<x1||x_center-radius>x2||y_center+radius<y1||y_center-radius>y2){\\n            cout<<\"1\";\\n            return false;\\n        }\\n        if(x_center<x1){\\n            if(y_center<y1){\\n                if(pow((x1-x_center),2)+pow((y1-y_center),2)>radius*radius){\\n                    cout<<\"2\";\\n                    return false;\\n                }\\n            }\\n            if(y_center>y2){\\n                if(pow((x1-x_center),2)+pow((y_center-y2),2)>radius*radius){\\n                    cout<<\"3\";\\n                    return false;\\n                }\\n            }\\n        }\\n        if(x_center>x2){\\n            if(y_center<y1){\\n                if(pow((x_center-x2),2)+pow((y1-y_center),2)>radius*radius){\\n                    cout<<\"4\";\\n                    return false;\\n                }\\n            }\\n            if(y_center>y2){\\n                if(pow((x_center-x2),2)+pow((y_center-y2),2)>radius*radius){\\n                    cout<<\"5\";\\n                    return false;\\n                }\\n            }\\n        }\\n            \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 565428,
                "title": "python-100-fast-and-100-less-memory",
                "content": "```python\\nclass Solution:\\n    def checkOverlap(self, rad: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if xc + rad < x1: return False\\n        elif xc - rad > x2: return False\\n        elif yc + rad < y1: return False\\n        elif yc - rad > y2: return False\\n        xcc = (x1 + x2) // 2\\n        ycc = (y1 + y2) // 2\\n        return abs(xcc - xc) ** 2 + abs(ycc - yc) ** 2 <= (rad + (x2 - x1)) ** 2\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def checkOverlap(self, rad: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if xc + rad < x1: return False\\n        elif xc - rad > x2: return False\\n        elif yc + rad < y1: return False\\n        elif yc - rad > y2: return False\\n        xcc = (x1 + x2) // 2\\n        ycc = (y1 + y2) // 2\\n        return abs(xcc - xc) ** 2 + abs(ycc - yc) ** 2 <= (rad + (x2 - x1)) ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565179,
                "title": "beats-100-c",
                "content": "```\\nclass Solution {\\n    double dist(int x1, int y1, int x2, int y2) {\\n        return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\\n    }\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        double xsq = (x1+x2)/2;\\n        double ysq = (y1+y2)/2;\\n        \\n        double dist_sq = dist(x_center, y_center, xsq, ysq) - radius;\\n        double diag_half = (sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)))/2;\\n        \\n        if (dist_sq < 0)\\n            return true;\\n        \\n        return !(dist_sq > diag_half);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double dist(int x1, int y1, int x2, int y2) {\\n        return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\\n    }\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        double xsq = (x1+x2)/2;\\n        double ysq = (y1+y2)/2;\\n        \\n        double dist_sq = dist(x_center, y_center, xsq, ysq) - radius;\\n        double diag_half = (sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)))/2;\\n        \\n        if (dist_sq < 0)\\n            return true;\\n        \\n        return !(dist_sq > diag_half);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564570,
                "title": "python-3-check-8-direction",
                "content": "\\tclass Solution:\\n\\t\\tdef checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n\\t\\t\\tif x_center + radius < x1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x_center - radius > x2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif y_center + radius < y1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif y_center - radius > y2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x2 < x_center and y1 > y_center and (x2 - x_center) ** 2 + (y1 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x2 < x_center and y2 < y_center and (x2 - x_center) ** 2 + (y2 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x1 > x_center and y1 > y_center and (x1 - x_center) ** 2 + (y1 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x1 > x_center and y2 < y_center and (x1 - x_center) ** 2 + (y2 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n\\t\\t\\tif x_center + radius < x1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x_center - radius > x2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif y_center + radius < y1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif y_center - radius > y2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x2 < x_center and y1 > y_center and (x2 - x_center) ** 2 + (y1 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x2 < x_center and y2 < y_center and (x2 - x_center) ** 2 + (y2 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x1 > x_center and y1 > y_center and (x1 - x_center) ** 2 + (y1 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x1 > x_center and y2 < y_center and (x1 - x_center) ** 2 + (y2 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 564224,
                "title": "simple-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private bool CircleSegmentIntersection(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n        {\\n            checked\\n            {\\n\\n                if (x1 == x2)\\n                {\\n                    //y - aligned\\n\\n                    if (x1 > xCenter + radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    if (x1 < xCenter - radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    double r = radius;\\n                    var xDiff = (double) x1 - xCenter;\\n                    var sqYdiff = r * r - xDiff * xDiff;\\n\\n                    var sqr = Math.Sqrt(sqYdiff);\\n\\n                    var first = sqr + yCenter;\\n                    var second = -sqr + yCenter;\\n\\n                    if (first >= y1 && first <= y2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    if (second >= y1 && second <= y2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    return false;\\n                }\\n                else\\n                {\\n                    //x - aligned\\n\\n                    if (y1 > yCenter + radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    if (y1 < yCenter - radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    double r = radius;\\n                    var yDiff = (double) y1 - yCenter;\\n                    var sqXDiff = r * r - yDiff * yDiff;\\n\\n                    var sqr = Math.Sqrt(sqXDiff);\\n\\n                    var first = sqr + xCenter;\\n                    var second = -sqr + xCenter;\\n\\n                    if (first >= x1 && first <= x2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    if (second >= x1 && second <= x2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        public bool CheckOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n        {\\n            checked\\n            {\\n                //circle inside rect\\n                if (xCenter + radius <= x2 && xCenter - radius >= x1 && yCenter + radius <= y2 &&\\n                    yCenter - radius >= y1)\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y1, x2, y1))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y1, x1, y2))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y2, x2, y2))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x2, y1, x2, y2))\\n                {\\n                    return true;\\n                }\\n\\n                //rect inside circle\\n                double midX = (double) x1 + (double) (x2 - x1) / 2;\\n                double midY = (double) y1 + (double) (y2 - y1) / 2;\\n\\n                if (midX >= xCenter - radius && midX <= xCenter + radius && midY >= yCenter - radius &&\\n                    midY <= yCenter + radius)\\n                {\\n                    return true;\\n                }\\n\\n                return false;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private bool CircleSegmentIntersection(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n        {\\n            checked\\n            {\\n\\n                if (x1 == x2)\\n                {\\n                    //y - aligned\\n\\n                    if (x1 > xCenter + radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    if (x1 < xCenter - radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    double r = radius;\\n                    var xDiff = (double) x1 - xCenter;\\n                    var sqYdiff = r * r - xDiff * xDiff;\\n\\n                    var sqr = Math.Sqrt(sqYdiff);\\n\\n                    var first = sqr + yCenter;\\n                    var second = -sqr + yCenter;\\n\\n                    if (first >= y1 && first <= y2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    if (second >= y1 && second <= y2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    return false;\\n                }\\n                else\\n                {\\n                    //x - aligned\\n\\n                    if (y1 > yCenter + radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    if (y1 < yCenter - radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    double r = radius;\\n                    var yDiff = (double) y1 - yCenter;\\n                    var sqXDiff = r * r - yDiff * yDiff;\\n\\n                    var sqr = Math.Sqrt(sqXDiff);\\n\\n                    var first = sqr + xCenter;\\n                    var second = -sqr + xCenter;\\n\\n                    if (first >= x1 && first <= x2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    if (second >= x1 && second <= x2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        public bool CheckOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n        {\\n            checked\\n            {\\n                //circle inside rect\\n                if (xCenter + radius <= x2 && xCenter - radius >= x1 && yCenter + radius <= y2 &&\\n                    yCenter - radius >= y1)\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y1, x2, y1))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y1, x1, y2))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y2, x2, y2))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x2, y1, x2, y2))\\n                {\\n                    return true;\\n                }\\n\\n                //rect inside circle\\n                double midX = (double) x1 + (double) (x2 - x1) / 2;\\n                double midY = (double) y1 + (double) (y2 - y1) / 2;\\n\\n                if (midX >= xCenter - radius && midX <= xCenter + radius && midY >= yCenter - radius &&\\n                    midY <= yCenter + radius)\\n                {\\n                    return true;\\n                }\\n\\n                return false;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564163,
                "title": "python-simple-math",
                "content": "```\\n# Fix the rectangle and track the center of the circle\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (x1 <= x_center <= x2 and y1 - radius <= y_center <= y2 + radius) or (y1 <= y_center <= y2 and x1 - radius <= x_center <= x2 + radius) or ((x_center - x1)**2 + (y_center - y1)**2 <= radius ** 2) or ((x_center - x2)**2 + (y_center - y1)**2 <= radius ** 2) or ((x_center - x1)**2 + (y_center - y2)**2 <= radius ** 2) or ((x_center - x2)**2 + (y_center - y2)**2 <= radius ** 2)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Fix the rectangle and track the center of the circle\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (x1 <= x_center <= x2 and y1 - radius <= y_center <= y2 + radius) or (y1 <= y_center <= y2 and x1 - radius <= x_center <= x2 + radius) or ((x_center - x1)**2 + (y_center - y1)**2 <= radius ** 2) or ((x_center - x2)**2 + (y_center - y1)**2 <= radius ** 2) or ((x_center - x1)**2 + (y_center - y2)**2 <= radius ** 2) or ((x_center - x2)**2 + (y_center - y2)**2 <= radius ** 2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 564155,
                "title": "c-easy-to-understand",
                "content": "```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n            for(int j=y1;j<=y2;j++)\\n            {\\n                if(((i-x_center)*(i-x_center))+((j-y_center)*(j-y_center))<=radius*radius)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n            for(int j=y1;j<=y2;j++)\\n            {\\n                if(((i-x_center)*(i-x_center))+((j-y_center)*(j-y_center))<=radius*radius)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564131,
                "title": "a-c-python-3-solution-math-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        import math\\n        print(\"radius = \", radius)\\n\\n        if (x1 <= x_center <= x2 and y1 <= y_center <= y2):\\n            return True\\n\\n        x_dis = 0 - x_center\\n        y_dis = 0 - y_center\\n\\n        print(\"x_dis = \", x_dis, \" y_dis = \", y_dis)\\n\\n        x_center += x_dis\\n        y_center += y_dis\\n\\n        x1 += x_dis\\n        x2 += x_dis\\n\\n        y1 += y_dis\\n        y2 += y_dis\\n\\n        print(\"x1 = \", x1, \" y1 = \", y1)\\n        print(\"x2 = \", x2, \" y2 = \", y2)\\n\\n        x_mid = (x1+x2) / 2\\n        y_mid = (y1+y2) / 2\\n        print(\"x_mid = \", x_mid, \" y_mid = \", y_mid)\\n\\n        dis = (x_mid - x_center) ** 2 + (y_mid - y_center) ** 2\\n\\n        print(\"dis = \", dis)\\n\\n        x_touch, y_touch = 0, 0\\n\\n        c1_x, c1_y = x1, y1\\n        c2_x, c2_y = x1, y2\\n        c3_x, c3_y = x2, y1\\n        c4_x, c4_y = x2, y2\\n\\n        c5_x, c5_y = x1, (y1+y2)/2\\n        c6_x, c6_y = x2, (y1+y2)/2\\n\\n        print(\"c5_x = \", c5_x, \" c5_y = \", c5_y)\\n        print(\"c6_x = \", c6_x, \" c6_y = \", c6_y)\\n\\n        c7_x, c7_y = 0, y1\\n        c8_x, c8_y = 0, y2\\n\\n        dis_1 = math.sqrt(c1_x**2 + c1_y**2)\\n        print(\"dis_1 = \", dis_1)\\n        if (dis_1 <= radius):\\n            return True\\n\\n        dis_2 = math.sqrt(c2_x**2 + c2_y**2)\\n        print(\"dis_2 = \", dis_2)\\n        if (dis_2 <= radius):\\n            return True\\n\\n        dis_3 = math.sqrt(c3_x**2 + c3_y**2)\\n        print(\"dis_3 = \", dis_3)\\n        if (dis_3 <= radius):\\n            return True\\n\\n        dis_4 = math.sqrt(c4_x**2 + c4_y**2)\\n        print(\"dis_4 = \", dis_4)\\n        if (dis_4 <= radius):\\n            return True\\n\\n        dis_5 = math.sqrt(c5_x**2 + c5_y**2)\\n        print(\"dis_5 = \", dis_5)\\n        if (dis_5 <= radius):\\n            return True\\n\\n        dis_6 = math.sqrt(c6_x**2 + c6_y**2)\\n        print(\"dis_6 = \", dis_6)\\n        if (dis_6 <= radius):\\n            return True\\n\\n        if (x1*x2 < 0):\\n            dis_7 = math.sqrt(c7_x**2 + c7_y**2)\\n            print(\"dis_7 = \", dis_7)\\n            if (dis_7 <= radius):\\n                return True\\n\\n        if (x1*x2 < 0 and (y1 < 0 or y2 < 0)):\\n            dis_8 = math.sqrt(c8_x**2 + c8_y**2)\\n            print(\"dis_8 = \", dis_8)\\n            if (dis_8 <= radius):\\n                return True\\n\\n        if (y1*y2 < 0):\\n            c9_x, c9_y = x1, 0\\n            dis_9 = math.sqrt(c9_x**2 + c9_y**2)\\n            print(\"dis_9 = \", dis_9)\\n            if (dis_9 <= radius):\\n                return True\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        import math\\n        print(\"radius = \", radius)\\n\\n        if (x1 <= x_center <= x2 and y1 <= y_center <= y2):\\n            return True\\n\\n        x_dis = 0 - x_center\\n        y_dis = 0 - y_center\\n\\n        print(\"x_dis = \", x_dis, \" y_dis = \", y_dis)\\n\\n        x_center += x_dis\\n        y_center += y_dis\\n\\n        x1 += x_dis\\n        x2 += x_dis\\n\\n        y1 += y_dis\\n        y2 += y_dis\\n\\n        print(\"x1 = \", x1, \" y1 = \", y1)\\n        print(\"x2 = \", x2, \" y2 = \", y2)\\n\\n        x_mid = (x1+x2) / 2\\n        y_mid = (y1+y2) / 2\\n        print(\"x_mid = \", x_mid, \" y_mid = \", y_mid)\\n\\n        dis = (x_mid - x_center) ** 2 + (y_mid - y_center) ** 2\\n\\n        print(\"dis = \", dis)\\n\\n        x_touch, y_touch = 0, 0\\n\\n        c1_x, c1_y = x1, y1\\n        c2_x, c2_y = x1, y2\\n        c3_x, c3_y = x2, y1\\n        c4_x, c4_y = x2, y2\\n\\n        c5_x, c5_y = x1, (y1+y2)/2\\n        c6_x, c6_y = x2, (y1+y2)/2\\n\\n        print(\"c5_x = \", c5_x, \" c5_y = \", c5_y)\\n        print(\"c6_x = \", c6_x, \" c6_y = \", c6_y)\\n\\n        c7_x, c7_y = 0, y1\\n        c8_x, c8_y = 0, y2\\n\\n        dis_1 = math.sqrt(c1_x**2 + c1_y**2)\\n        print(\"dis_1 = \", dis_1)\\n        if (dis_1 <= radius):\\n            return True\\n\\n        dis_2 = math.sqrt(c2_x**2 + c2_y**2)\\n        print(\"dis_2 = \", dis_2)\\n        if (dis_2 <= radius):\\n            return True\\n\\n        dis_3 = math.sqrt(c3_x**2 + c3_y**2)\\n        print(\"dis_3 = \", dis_3)\\n        if (dis_3 <= radius):\\n            return True\\n\\n        dis_4 = math.sqrt(c4_x**2 + c4_y**2)\\n        print(\"dis_4 = \", dis_4)\\n        if (dis_4 <= radius):\\n            return True\\n\\n        dis_5 = math.sqrt(c5_x**2 + c5_y**2)\\n        print(\"dis_5 = \", dis_5)\\n        if (dis_5 <= radius):\\n            return True\\n\\n        dis_6 = math.sqrt(c6_x**2 + c6_y**2)\\n        print(\"dis_6 = \", dis_6)\\n        if (dis_6 <= radius):\\n            return True\\n\\n        if (x1*x2 < 0):\\n            dis_7 = math.sqrt(c7_x**2 + c7_y**2)\\n            print(\"dis_7 = \", dis_7)\\n            if (dis_7 <= radius):\\n                return True\\n\\n        if (x1*x2 < 0 and (y1 < 0 or y2 < 0)):\\n            dis_8 = math.sqrt(c8_x**2 + c8_y**2)\\n            print(\"dis_8 = \", dis_8)\\n            if (dis_8 <= radius):\\n                return True\\n\\n        if (y1*y2 < 0):\\n            c9_x, c9_y = x1, 0\\n            dis_9 = math.sqrt(c9_x**2 + c9_y**2)\\n            print(\"dis_9 = \", dis_9)\\n            if (dis_9 <= radius):\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564085,
                "title": "python-binary-search",
                "content": "O(NlgN)\\nAlthough math is awesome but it could be more computer science related\\n```\\n    def checkOverlap(self, r: int, x0: int, y0: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        def withinCircle(x,y):\\n            a=(x-x0)**2+(y-y0)**2\\n            b=r**2\\n            return a<=b or abs(a-b)<0.0001\\n        lx,rx=x1,x2\\n        while lx<=rx:\\n            mx=lx+(rx-lx)/2\\n            for y in range(y1,y2+1):\\n                if withinCircle(mx,y):return True\\n            if math.isclose(lx,rx):break\\n            if mx>x0:\\n                rx=mx\\n            else:\\n                lx=mx\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n    def checkOverlap(self, r: int, x0: int, y0: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        def withinCircle(x,y):\\n            a=(x-x0)**2+(y-y0)**2\\n            b=r**2\\n            return a<=b or abs(a-b)<0.0001\\n        lx,rx=x1,x2\\n        while lx<=rx:\\n            mx=lx+(rx-lx)/2\\n            for y in range(y1,y2+1):\\n                if withinCircle(mx,y):return True\\n            if math.isclose(lx,rx):break\\n            if mx>x0:\\n                rx=mx\\n            else:\\n                lx=mx\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 564029,
                "title": "closest-point-is-the-median",
                "content": "We only need to consider the closest point on the rectangle to the CENTER of the circle, ignoring the shape of the circle. There are 9 cases for the relative location between the center of the circle and the rectangle: the center of the circle can be on the (upper-left, upper, upper-right, right, lower-right, lower, lower-left, left) or inside of the rectangle (we here consider \"on a corner or edge\" as inside). Under whichever case, the aforementioned closest point is:\\n\\t(median(x_center, x1, x2), median(y_center, y1, y2))\\nThen we can check if this point is inside the circle.\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int x = xc < x1 ? x1 : xc < x2 ? xc : x2, y = yc < y1 ? y1 : yc < y2 ? yc : y2;\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int x = xc < x1 ? x1 : xc < x2 ? xc : x2, y = yc < y1 ? y1 : yc < y2 ? yc : y2;\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563979,
                "title": "python-check-closest-point-on-the-rectangle",
                "content": "\"\"\"\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n\\t\\t\\t#let\\'s make rec center as origin and convert circle center\\n        \\n\\t\\t\\tx_center = abs(x_center - (x1+x2)/2)\\n\\t\\t\\ty_center = abs(y_center - (y1+y2)/2)\\n        \\n\\t\\t\\t#half size\\n\\t\\t\\thalf_rx = abs(x1-x2) / 2\\n\\t\\t\\thalf_ry = abs(y1-y2) / 2\\n        \\n\\t\\t\\t#two center distance\\n        \\n\\t\\t\\td = (x_center**2 + y_center**2) ** 1/2\\n        \\n\\t\\t\\tx_p = abs(x1-x2)/2 if x_center >= half_rx else x_center\\n\\t\\t\\ty_p = abs(y1-y2)/2 if y_center >= half_ry else y_center\\n        \\n\\t\\t\\treturn (x_p-x_center)**2+(y_p-y_center)**2 <= radius ** 2\\n\\t\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n\\t\\t\\t#let\\'s make rec center as origin and convert circle center\\n        \\n\\t\\t\\tx_center = abs(x_center - (x1+x2)/2)\\n\\t\\t\\ty_center = abs(y_center - (y1+y2)/2)\\n        \\n\\t\\t\\t#half size\\n\\t\\t\\thalf_rx = abs(x1-x2) / 2\\n\\t\\t\\thalf_ry = abs(y1-y2) / 2\\n        \\n\\t\\t\\t#two center distance\\n        \\n\\t\\t\\td = (x_center**2 + y_center**2) ** 1/2\\n        \\n\\t\\t\\tx_p = abs(x1-x2)/2 if x_center >= half_rx else x_center\\n\\t\\t\\ty_p = abs(y1-y2)/2 if y_center >= half_ry else y_center\\n        \\n\\t\\t\\treturn (x_p-x_center)**2+(y_p-y_center)**2 <= radius ** 2\\n\\t\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 563776,
                "title": "c-visualizing-the-line-between-centroids-100-speed-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center,    int x1, int y1, int x2, int y2) {\\n        if ((x_center == x1 && y_center == y1) || (x_center == x2 && y_center == y2) || (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)) return true;\\n        \\n        double sqctrx = (x2+x1)/2;   //get square\\'s center coordinate\\n        double sqctry = (y2+y1)/2;\\n        double d = sqrt(pow((sqctrx-x_center),2)+pow((sqctry-y_center),2));        //direct distance between circle center and square center\\n        double sqrd = sqrt(pow((x2-x1),2)+pow((y2-y1),2))/2;    //worst case distance from square center to edge is to a corner\\n        return sqrd+radius >= d;                                //if square\\'s edge distance and the circle\\'s edge distance are greater than the euclidean distance between the centroids, overlap exists\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center,    int x1, int y1, int x2, int y2) {\\n        if ((x_center == x1 && y_center == y1) || (x_center == x2 && y_center == y2) || (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)) return true;\\n        \\n        double sqctrx = (x2+x1)/2;   //get square\\'s center coordinate\\n        double sqctry = (y2+y1)/2;\\n        double d = sqrt(pow((sqctrx-x_center),2)+pow((sqctry-y_center),2));        //direct distance between circle center and square center\\n        double sqrd = sqrt(pow((x2-x1),2)+pow((y2-y1),2))/2;    //worst case distance from square center to edge is to a corner\\n        return sqrd+radius >= d;                                //if square\\'s edge distance and the circle\\'s edge distance are greater than the euclidean distance between the centroids, overlap exists\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563725,
                "title": "easy-java-0ms-100-faster-with-explanation",
                "content": "```\\n//basic equation of circle is sq(x-h) + sq(y-k) = r2 where (h,k) is the center coordinates\\n//basically we can have 3 situation \\n//1)if any of the point of square lie inside the circle you can check all 4 points with equation sq(x-h) + sq(y-k) <= r2 if this is true then one point lie inside the circle.\\n//As per the circle definition if any point(x,y) if it lie inside circle then equation sq(x-h) + sq(y-k) <= r2\\n//Else if outside then sq(x-h) + sq(y-k) > r2\\n//2)check if any line of rectangle cuts the circle by simple pythagoras therom r2-d2>=0\\n//3)check if the circle is inside rectangle\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\t    int x_h1 = x1-x_center;\\n\\t    int y_h1 = y1-y_center;\\n\\t    int x_h2 = x2-x_center;\\n\\t    int y_h2 = y2-y_center;\\n\\t    int r2 = radius*radius;\\n\\t    \\n\\t    boolean insideRangeOfRectangleX= (x_center>=x1)&&(x_center<=x2);\\n\\t    boolean insideRangeOfRectangleY =(y_center>=y1) &&(y_center<=y2);\\n\\t    \\n\\t    //case1 check all four points lie inside circle\\n\\t    if(x_h1*x_h1+y_h1*y_h1<=r2 || x_h2*x_h2+y_h2*y_h2<=r2 || x_h1*x_h1+y_h2*y_h2<=r2 || x_h2*x_h2+y_h1*y_h1<=r2)\\n\\t    \\treturn true;\\n\\t    \\n\\t    if((r2-x_h1*x_h1>=0 &&insideRangeOfRectangleY) || (r2-x_h2*x_h2>=0 &&insideRangeOfRectangleY) || (r2-y_h1*y_h1>=0 &&insideRangeOfRectangleX)||(r2-y_h2*y_h2>=0 &&insideRangeOfRectangleX))\\n\\t       return true;\\n   \\n\\t    if((x_center + radius<=x2)&&(x_center -radius >=x1)&&(y_center+radius<=y2) &&(y_center-radius>=y1))\\n\\t    \\treturn true;\\n\\t    return false;\\n    \\n    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//basic equation of circle is sq(x-h) + sq(y-k) = r2 where (h,k) is the center coordinates\\n//basically we can have 3 situation \\n//1)if any of the point of square lie inside the circle you can check all 4 points with equation sq(x-h) + sq(y-k) <= r2 if this is true then one point lie inside the circle.\\n//As per the circle definition if any point(x,y) if it lie inside circle then equation sq(x-h) + sq(y-k) <= r2\\n//Else if outside then sq(x-h) + sq(y-k) > r2\\n//2)check if any line of rectangle cuts the circle by simple pythagoras therom r2-d2>=0\\n//3)check if the circle is inside rectangle\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\t    int x_h1 = x1-x_center;\\n\\t    int y_h1 = y1-y_center;\\n\\t    int x_h2 = x2-x_center;\\n\\t    int y_h2 = y2-y_center;\\n\\t    int r2 = radius*radius;\\n\\t    \\n\\t    boolean insideRangeOfRectangleX= (x_center>=x1)&&(x_center<=x2);\\n\\t    boolean insideRangeOfRectangleY =(y_center>=y1) &&(y_center<=y2);\\n\\t    \\n\\t    //case1 check all four points lie inside circle\\n\\t    if(x_h1*x_h1+y_h1*y_h1<=r2 || x_h2*x_h2+y_h2*y_h2<=r2 || x_h1*x_h1+y_h2*y_h2<=r2 || x_h2*x_h2+y_h1*y_h1<=r2)\\n\\t    \\treturn true;\\n\\t    \\n\\t    if((r2-x_h1*x_h1>=0 &&insideRangeOfRectangleY) || (r2-x_h2*x_h2>=0 &&insideRangeOfRectangleY) || (r2-y_h1*y_h1>=0 &&insideRangeOfRectangleX)||(r2-y_h2*y_h2>=0 &&insideRangeOfRectangleX))\\n\\t       return true;\\n   \\n\\t    if((x_center + radius<=x2)&&(x_center -radius >=x1)&&(y_center+radius<=y2) &&(y_center-radius>=y1))\\n\\t    \\treturn true;\\n\\t    return false;\\n    \\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563724,
                "title": "naive-ideas-analyzing-3-cases-python",
                "content": "```python\\nclass Solution(object):\\n    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):\\n        \\n        \"\"\"\\n        any of the following conditions \\n        1) the distance between the circle-center and one vertex of rect is smaller than the radius of sphere\\n        2) the circle center is inside the rect \\n        3) if 1) and 2) both Flase: compare circle-center and 4 edges of the rect. For each edge:\\n        3.1) any of the two endpoints of the edge is within the circle;\\n        3.2) both endpoints are outside the circle, but the distance from circle center point to the edge is less than or equal to radius.\\n       \\n        \"\"\"\\n        \\n\\t\\t# case 1) \\n\\t\\t\\n        d11 = self.distance(x_center, y_center, x1, y1)\\n        d12 = self.distance(x_center, y_center, x2, y2)\\n        d13 = self.distance(x_center, y_center, x1, y2)\\n        d14 = self.distance(x_center, y_center, x2, y1)\\n        \\n        b1 = any(d <= radius * radius for d in (d11, d12, d13, d14))\\n        \\n\\t\\t# case 2) \\n\\t\\t\\n        b2 = x1 <= x_center <= x2 and y1 <= y_center <= y2\\n        \\n        if b1 or b2:\\n            return True\\n    \\n\\t    # case 3) \\n\\t\\t\\n        b31 = self.check_edges(x_center, y_center, radius, x1, y1, x1, y2)\\n        b32 = self.check_edges(x_center, y_center, radius, x1, y2, x2, y2)\\n        b33 = self.check_edges(x_center, y_center, radius, x2, y2, x2, y1)\\n        b34 = self.check_edges(x_center, y_center, radius, x1, y1, x2, y1)\\n        \\n        return b31 or b32 or b33 or b34\\n        \\n    \\n    def distance(self, x1, y1, x2, y2):\\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2\\n    \\n    def check_edges(self, x_center, y_center, radius, x1, y1, x2, y2):\\n        if self.distance(x1, y1, x_center, y_center) <= radius ** 2:\\n            return True\\n        if self.distance(x2, y2, x_center, y_center) <= radius ** 2:\\n            return True\\n        \\n        if x1 == x2:\\n            if abs(x_center - x1) > radius:\\n                return False\\n            return y1 <= y_center <= y2 or y2 <= y_center <= y1\\n        \\n        if y1 == y2:\\n            if abs(y_center - y1) > radius:\\n                return False\\n            return x1 <= x_center <= x2 or x2 <= x_center <= x1\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):\\n        \\n        \"\"\"\\n        any of the following conditions \\n        1) the distance between the circle-center and one vertex of rect is smaller than the radius of sphere\\n        2) the circle center is inside the rect \\n        3) if 1) and 2) both Flase: compare circle-center and 4 edges of the rect. For each edge:\\n        3.1) any of the two endpoints of the edge is within the circle;\\n        3.2) both endpoints are outside the circle, but the distance from circle center point to the edge is less than or equal to radius.\\n       \\n        \"\"\"\\n        \\n\\t\\t# case 1) \\n\\t\\t\\n        d11 = self.distance(x_center, y_center, x1, y1)\\n        d12 = self.distance(x_center, y_center, x2, y2)\\n        d13 = self.distance(x_center, y_center, x1, y2)\\n        d14 = self.distance(x_center, y_center, x2, y1)\\n        \\n        b1 = any(d <= radius * radius for d in (d11, d12, d13, d14))\\n        \\n\\t\\t# case 2) \\n\\t\\t\\n        b2 = x1 <= x_center <= x2 and y1 <= y_center <= y2\\n        \\n        if b1 or b2:\\n            return True\\n    \\n\\t    # case 3) \\n\\t\\t\\n        b31 = self.check_edges(x_center, y_center, radius, x1, y1, x1, y2)\\n        b32 = self.check_edges(x_center, y_center, radius, x1, y2, x2, y2)\\n        b33 = self.check_edges(x_center, y_center, radius, x2, y2, x2, y1)\\n        b34 = self.check_edges(x_center, y_center, radius, x1, y1, x2, y1)\\n        \\n        return b31 or b32 or b33 or b34\\n        \\n    \\n    def distance(self, x1, y1, x2, y2):\\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2\\n    \\n    def check_edges(self, x_center, y_center, radius, x1, y1, x2, y2):\\n        if self.distance(x1, y1, x_center, y_center) <= radius ** 2:\\n            return True\\n        if self.distance(x2, y2, x_center, y_center) <= radius ** 2:\\n            return True\\n        \\n        if x1 == x2:\\n            if abs(x_center - x1) > radius:\\n                return False\\n            return y1 <= y_center <= y2 or y2 <= y_center <= y1\\n        \\n        if y1 == y2:\\n            if abs(y_center - y1) > radius:\\n                return False\\n            return x1 <= x_center <= x2 or x2 <= x_center <= x1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 563709,
                "title": "java-with-explanation",
                "content": "At first we check whether the circle is inside the rectangle.\\nIf not, we calculate min distance between rectangle and circle projectons on x / y.\\nIf circle center is between y1 and y2 than horizontal line which goes through circle center crosses rectangle -> closest path is on horizontal line. And it should be LTE radius. The same logic for x.\\nIf no, min distance does not lie neither on horizontal nor on vertical lines so we check using Pythagorean theorem\\n\\n```\\npublic boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        if (x1 <= x_center && x_center <= x2 && y1 <= y_center && y_center <= y2) {\\n            return true;\\n        }\\n\\n        int minDistX = Math.min(Math.abs(x1 - x_center), Math.abs(x2 - x_center));\\n        int minDistY = Math.min(Math.abs(y1 - y_center), Math.abs(y2 - y_center));\\n\\n        if (y1 <= y_center && y_center <= y2) {\\n            return minDistX <= radius;\\n        } else if (x1 <= x_center && x_center <= x2) {\\n            return minDistY <= radius;\\n        } else {\\n            return minDistX * minDistX + minDistY * minDistY <= radius * radius;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        if (x1 <= x_center && x_center <= x2 && y1 <= y_center && y_center <= y2) {\\n            return true;\\n        }\\n\\n        int minDistX = Math.min(Math.abs(x1 - x_center), Math.abs(x2 - x_center));\\n        int minDistY = Math.min(Math.abs(y1 - y_center), Math.abs(y2 - y_center));\\n\\n        if (y1 <= y_center && y_center <= y2) {\\n            return minDistX <= radius;\\n        } else if (x1 <= x_center && x_center <= x2) {\\n            return minDistY <= radius;\\n        } else {\\n            return minDistX * minDistX + minDistY * minDistY <= radius * radius;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563644,
                "title": "java-o-m-n",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for (int i = x1; i <= x2; i++) {\\n            for (int j = y1; j <= y2; j++) {\\n                int x = i - x_center;\\n                int y = j - y_center;\\n                if (x * x + y * y <= radius * radius) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for (int i = x1; i <= x2; i++) {\\n            for (int j = y1; j <= y2; j++) {\\n                int x = i - x_center;\\n                int y = j - y_center;\\n                if (x * x + y * y <= radius * radius) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563634,
                "title": "please-help-85-86-testcases-passed-java",
                "content": "Simply checking if the rec. is left of or right or it is upside or downside, if any condition satisfies return false.\\nNot getting whats wrong in my approach\\nOne testcase is not getting passed. Please help\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        return !(x1>x_center+radius ||\\n                x2<x_center-radius ||\\n                y1>y_center+radius ||\\n                y2<y_center-radius);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        return !(x1>x_center+radius ||\\n                x2<x_center-radius ||\\n                y1>y_center+radius ||\\n                y2<y_center-radius);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 563578,
                "title": "python-lots-of-checking",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def check_point_is_in_circle(i, j):\\n            diff_x = i - x_center\\n            diff_y = j - y_center\\n            \\n            return math.sqrt(diff_x ** 2 + diff_y ** 2) <= radius\\n            \\n        top_left_x, top_left_y = x1, y2\\n        bot_left_x, bot_left_y = x1, y1\\n        top_right_x, top_right_y = x2, y2\\n        bot_right_x, bot_right_y = x2, y1\\n        \\n        mid_x, mid_y = x1 + (x2 - x1) / 2, y1 + (y2 - y1) / 2\\n\\n        if check_point_is_in_circle(mid_x, mid_y):\\n            return True\\n        \\n        if check_point_is_in_circle(top_left_x, top_left_y) or check_point_is_in_circle(bot_left_x, bot_left_y) or check_point_is_in_circle(top_right_x, top_right_y) or check_point_is_in_circle(bot_right_x, bot_right_y):\\n            return True\\n\\n        # if circle is inside square\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2:\\n            return True\\n        \\n        # if circle petrudes square on one of the edges\\n        circle_north_x, circle_north_y = x_center, y_center + radius\\n        circle_west_x, circle_west_y = x_center - radius, y_center\\n        circle_south_x, circle_south_y = x_center, y_center - radius\\n        circle_east_x, circle_east_y = x_center + radius, y_center\\n        \\n        if x1 <= circle_east_x <= x2 and y1 <= circle_east_y <= y2:\\n            return True\\n\\n        if x1 <= circle_west_x <= x2 and y1 <= circle_east_y <= y2:\\n            return True\\n        \\n        if y1 <= circle_north_y <= y2 and x1 <= circle_north_x <= x2:\\n            return True\\n\\n        if y1 <= circle_south_y <= y2 and x1 <= circle_south_x <= x2:\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def check_point_is_in_circle(i, j):\\n            diff_x = i - x_center\\n            diff_y = j - y_center\\n            \\n            return math.sqrt(diff_x ** 2 + diff_y ** 2) <= radius\\n            \\n        top_left_x, top_left_y = x1, y2\\n        bot_left_x, bot_left_y = x1, y1\\n        top_right_x, top_right_y = x2, y2\\n        bot_right_x, bot_right_y = x2, y1\\n        \\n        mid_x, mid_y = x1 + (x2 - x1) / 2, y1 + (y2 - y1) / 2\\n\\n        if check_point_is_in_circle(mid_x, mid_y):\\n            return True\\n        \\n        if check_point_is_in_circle(top_left_x, top_left_y) or check_point_is_in_circle(bot_left_x, bot_left_y) or check_point_is_in_circle(top_right_x, top_right_y) or check_point_is_in_circle(bot_right_x, bot_right_y):\\n            return True\\n\\n        # if circle is inside square\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2:\\n            return True\\n        \\n        # if circle petrudes square on one of the edges\\n        circle_north_x, circle_north_y = x_center, y_center + radius\\n        circle_west_x, circle_west_y = x_center - radius, y_center\\n        circle_south_x, circle_south_y = x_center, y_center - radius\\n        circle_east_x, circle_east_y = x_center + radius, y_center\\n        \\n        if x1 <= circle_east_x <= x2 and y1 <= circle_east_y <= y2:\\n            return True\\n\\n        if x1 <= circle_west_x <= x2 and y1 <= circle_east_y <= y2:\\n            return True\\n        \\n        if y1 <= circle_north_y <= y2 and x1 <= circle_north_x <= x2:\\n            return True\\n\\n        if y1 <= circle_south_y <= y2 and x1 <= circle_south_x <= x2:\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574793,
                "content": [
                    {
                        "username": "cemozturan",
                        "content": "const closestX = (x_center, x1, x2) => {\\n  if (x_center < x1) return x1 - x_center\\n  if (x_center > x2) return x_center - x2\\n  return 0\\n}\\n\\nconst closestY = (y_center, y1, y2) => {\\n  if (y_center < y1) return y1 - y_center\\n  if (y_center > y2) return y_center - y2\\n  return 0\\n}\\n\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n  const xDistance = closestX(x_center, x1, x2)\\n  const yDistance = closestY(y_center, y1, y2)\\n  return (xDistance * xDistance + yDistance * yDistance <= radius * radius)\\n};"
                    },
                    {
                        "username": "longluo",
                        "content": "**3** Lines Code\\n\\n```java\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        double v_x = Math.abs(xCenter - (double) (x1 + x2) / 2) - (double) (x2 - x1) / 2;\\n        double v_y = Math.abs(yCenter - (double) (y1 + y2) / 2) - (double) (y2 - y1) / 2;\\n\\n        return Math.max(0, v_x) * Math.max(0, v_x) + Math.max(0, v_y) * Math.max(0, v_y) <= radius * radius; \\n    }\\n```\\n"
                    },
                    {
                        "username": "MaciejFicek",
                        "content": "That exercise should be removed from Leetcode or changed.\\nThere are test cases where disc and rectangle have only ONE common point.\\n\\nHow normal human does that exercise:\\n- first check if center of circle is inside rectangle - if yes, then we are finished\\n- if not, then if the objects overlap, the border of rectangle overlaps with circle. Therefore You go through whole border of rectangle and check FINITELY MANY points. You can\\'t check them all. And, You can\\'t win test with starting data (1, 0 , 0, 1, -1 ,3 ,1). This is the case when only one points is common.\\n\\nDon\\'t waste tiem on that exercise, check normal exercises."
                    }
                ]
            },
            {
                "id": 1943152,
                "content": [
                    {
                        "username": "cemozturan",
                        "content": "const closestX = (x_center, x1, x2) => {\\n  if (x_center < x1) return x1 - x_center\\n  if (x_center > x2) return x_center - x2\\n  return 0\\n}\\n\\nconst closestY = (y_center, y1, y2) => {\\n  if (y_center < y1) return y1 - y_center\\n  if (y_center > y2) return y_center - y2\\n  return 0\\n}\\n\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n  const xDistance = closestX(x_center, x1, x2)\\n  const yDistance = closestY(y_center, y1, y2)\\n  return (xDistance * xDistance + yDistance * yDistance <= radius * radius)\\n};"
                    },
                    {
                        "username": "longluo",
                        "content": "**3** Lines Code\\n\\n```java\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        double v_x = Math.abs(xCenter - (double) (x1 + x2) / 2) - (double) (x2 - x1) / 2;\\n        double v_y = Math.abs(yCenter - (double) (y1 + y2) / 2) - (double) (y2 - y1) / 2;\\n\\n        return Math.max(0, v_x) * Math.max(0, v_x) + Math.max(0, v_y) * Math.max(0, v_y) <= radius * radius; \\n    }\\n```\\n"
                    },
                    {
                        "username": "MaciejFicek",
                        "content": "That exercise should be removed from Leetcode or changed.\\nThere are test cases where disc and rectangle have only ONE common point.\\n\\nHow normal human does that exercise:\\n- first check if center of circle is inside rectangle - if yes, then we are finished\\n- if not, then if the objects overlap, the border of rectangle overlaps with circle. Therefore You go through whole border of rectangle and check FINITELY MANY points. You can\\'t check them all. And, You can\\'t win test with starting data (1, 0 , 0, 1, -1 ,3 ,1). This is the case when only one points is common.\\n\\nDon\\'t waste tiem on that exercise, check normal exercises."
                    }
                ]
            },
            {
                "id": 1574360,
                "content": [
                    {
                        "username": "cemozturan",
                        "content": "const closestX = (x_center, x1, x2) => {\\n  if (x_center < x1) return x1 - x_center\\n  if (x_center > x2) return x_center - x2\\n  return 0\\n}\\n\\nconst closestY = (y_center, y1, y2) => {\\n  if (y_center < y1) return y1 - y_center\\n  if (y_center > y2) return y_center - y2\\n  return 0\\n}\\n\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n  const xDistance = closestX(x_center, x1, x2)\\n  const yDistance = closestY(y_center, y1, y2)\\n  return (xDistance * xDistance + yDistance * yDistance <= radius * radius)\\n};"
                    },
                    {
                        "username": "longluo",
                        "content": "**3** Lines Code\\n\\n```java\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        double v_x = Math.abs(xCenter - (double) (x1 + x2) / 2) - (double) (x2 - x1) / 2;\\n        double v_y = Math.abs(yCenter - (double) (y1 + y2) / 2) - (double) (y2 - y1) / 2;\\n\\n        return Math.max(0, v_x) * Math.max(0, v_x) + Math.max(0, v_y) * Math.max(0, v_y) <= radius * radius; \\n    }\\n```\\n"
                    },
                    {
                        "username": "MaciejFicek",
                        "content": "That exercise should be removed from Leetcode or changed.\\nThere are test cases where disc and rectangle have only ONE common point.\\n\\nHow normal human does that exercise:\\n- first check if center of circle is inside rectangle - if yes, then we are finished\\n- if not, then if the objects overlap, the border of rectangle overlaps with circle. Therefore You go through whole border of rectangle and check FINITELY MANY points. You can\\'t check them all. And, You can\\'t win test with starting data (1, 0 , 0, 1, -1 ,3 ,1). This is the case when only one points is common.\\n\\nDon\\'t waste tiem on that exercise, check normal exercises."
                    }
                ]
            }
        ]
    },
    {
        "title": "Reducing Dishes",
        "question_content": "<p>A chef has collected data on the <code>satisfaction</code> level of his <code>n</code> dishes. Chef can cook any dish in 1 unit of time.</p>\n\n<p><strong>Like-time coefficient</strong> of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. <code>time[i] * satisfaction[i]</code>.</p>\n\n<p>Return <em>the maximum sum of <strong>like-time coefficient</strong> that the chef can obtain after dishes preparation</em>.</p>\n\n<p>Dishes can be prepared in <strong>any </strong>order and the chef can discard some dishes to get this maximum value.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> satisfaction = [-1,-8,0,5,-9]\n<strong>Output:</strong> 14\n<strong>Explanation:</strong> After Removing the second and last dish, the maximum total <strong>like-time coefficient</strong> will be equal to (-1*1 + 0*2 + 5*3 = 14).\nEach dish is prepared in one unit of time.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> satisfaction = [4,3,2]\n<strong>Output:</strong> 20\n<strong>Explanation:</strong> Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> satisfaction = [-1,-4,-5]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> People do not like the dishes. No dish is prepared.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == satisfaction.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= satisfaction[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 563384,
                "title": "java-c-python-easy-and-concise",
                "content": "## **Intuition**\\nIf we cook some dishes,\\nthey must be the most satisfied among all choices.\\n\\nAnother important observation is that,\\nwe will cook the dish with small satisfication,\\nand leave the most satisfied dish in the end.\\n\\n## **Explanation**\\nWe choose dishes from most satisfied.\\nEverytime we add a new dish to the menu list,\\nall dishes on the menu list will be cooked one time unit later,\\nso the `result += total satisfaction on the list`.\\nWe\\'ll keep doing this as long as `A[i] + total > 0`.\\n<br>\\n\\n## **Complexity**\\nTime `O(NlogN)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maxSatisfaction(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, total = 0, n = A.length;\\n        for (int i = n - 1; i >= 0 && A[i] > -total; --i) {\\n            total += A[i];\\n            res += total;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int maxSatisfaction(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, total = 0, n = A.size();\\n        for (int i = n - 1; i >= 0 && A[i] > -total; --i) {\\n            total += A[i];\\n            res += total;\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def maxSatisfaction(self, A):\\n        res = total = 0\\n        A.sort()\\n        while A and A[-1] + total > 0:\\n            total += A.pop()\\n            res += total\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxSatisfaction(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, total = 0, n = A.length;\\n        for (int i = n - 1; i >= 0 && A[i] > -total; --i) {\\n            total += A[i];\\n            res += total;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int maxSatisfaction(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, total = 0, n = A.size();\\n        for (int i = n - 1; i >= 0 && A[i] > -total; --i) {\\n            total += A[i];\\n            res += total;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def maxSatisfaction(self, A):\\n        res = total = 0\\n        A.sort()\\n        while A and A[-1] + total > 0:\\n            total += A.pop()\\n            res += total\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3353418,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n\\n# Video Solution\\n**Search \\uD83D\\uDC49 `Reducing Dishes by Tech Wired` on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (4).png](https://assets.leetcode.com/users/images/775f2659-d352-4eb7-9cfe-c225f498b76d_1680054457.331.png)\\n\\n\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\nThe problem can be solved using a greedy approach. First, we sort the input array in decreasing order. Then, we iterate over the array and calculate the prefix sums of the elements, adding each prefix sum to the result as long as it remains non-negative. If the prefix sum becomes negative at any point, we stop the iteration and return the current result.\\n\\n# Intuition:\\n\\n- The intuition behind the greedy approach is that the maximum satisfaction value is obtained by serving the most popular dishes first, and the least popular dishes last. By sorting the dishes in decreasing order of popularity, we can ensure that we serve the most popular dishes first, and thus maximize the satisfaction value.\\n\\n- Next, we calculate the prefix sums of the sorted dishes, starting from the most popular dish. The prefix sum at index i represents the total satisfaction value obtained by serving the i most popular dishes in decreasing order. If the prefix sum at any point becomes negative, it means that the remaining dishes have a net negative contribution to the total satisfaction value, and we can stop serving them.\\n\\n- By stopping the iteration as soon as the prefix sum becomes negative, we can ensure that we don\\'t serve any dishes that have a net negative contribution to the total satisfaction value. This allows us to obtain the maximum satisfaction value while minimizing the number of dishes served.\\n\\n\\n```Python []\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort(reverse=True)\\n        n = len(satisfaction)\\n        presum, res = 0, 0\\n        for i in range(n):\\n            presum += satisfaction[i]\\n            if presum < 0:\\n                break\\n            res += presum\\n        return res\\n\\n    \\n        # An Upvote will be encouraging\\n\\n```\\n```Java []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int n = satisfaction.length;\\n        int presum = 0, res = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            presum += satisfaction[i];\\n            if (presum < 0) {\\n                break;\\n            }\\n            res += presum;\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end(), greater<int>());\\n        int n = satisfaction.size();\\n        int presum = 0, res = 0;\\n        for (int i = 0; i < n; i++) {\\n            presum += satisfaction[i];\\n            if (presum < 0) {\\n                break;\\n            }\\n            res += presum;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```Python []\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort(reverse=True)\\n        n = len(satisfaction)\\n        presum, res = 0, 0\\n        for i in range(n):\\n            presum += satisfaction[i]\\n            if presum < 0:\\n                break\\n            res += presum\\n        return res\\n\\n    \\n        # An Upvote will be encouraging\\n\\n```\n```Java []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int n = satisfaction.length;\\n        int presum = 0, res = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            presum += satisfaction[i];\\n            if (presum < 0) {\\n                break;\\n            }\\n            res += presum;\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end(), greater<int>());\\n        int n = satisfaction.size();\\n        int presum = 0, res = 0;\\n        for (int i = 0; i < n; i++) {\\n            presum += satisfaction[i];\\n            if (presum < 0) {\\n                break;\\n            }\\n            res += presum;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564524,
                "title": "c-0-ms-beats-100-all-solutions-in-both-time-and-space-with-proper-explaination",
                "content": "```\\n// After sorting the array becomes - -9,-8,-1,0,5\\n// As we have sorted the array the bigger element will be at the end , so we start from the end of the array\\n// at i = n-1 i.e 4 -> Cumulative_sum = 0, and cur = 5 (5*1) = 5\\n// at i = 3 -> Cumulative-sum = 5, and cur = 5 + 5 + 0 (0*1 + 5*2) = 10\\n// at i = 2 -> Cumulative-sum = 5 (5 + 0), and cur = cur + Cumlative_sum + satis[i] = (10 + 5 + -1) = -1*1 + 0*2 + 5*3 = 14\\n// at i = 1 -> Cumulative-sum = 4 (5 + 0 + -1), and cur = cur + Cumlative_sum + satis[i] = (14 + 4 + -8) = -8*1 + -1*2 + 0*3 + 5*5= 14\\n// And similarly for i = 0 and and max of all currents is printed\\n\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        \\n        sort(satisfaction.begin(),satisfaction.end());\\n        int n = satisfaction.size();\\n        \\n        int Cumulative_sum = 0; // From back\\n        \\n        int ans = 0;\\n        int cur = 0;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            cur += Cumulative_sum + satisfaction[i];\\n            Cumulative_sum += satisfaction[i];\\n            \\n            ans = max(ans,cur);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\n// After sorting the array becomes - -9,-8,-1,0,5\\n// As we have sorted the array the bigger element will be at the end , so we start from the end of the array\\n// at i = n-1 i.e 4 -> Cumulative_sum = 0, and cur = 5 (5*1) = 5\\n// at i = 3 -> Cumulative-sum = 5, and cur = 5 + 5 + 0 (0*1 + 5*2) = 10\\n// at i = 2 -> Cumulative-sum = 5 (5 + 0), and cur = cur + Cumlative_sum + satis[i] = (10 + 5 + -1) = -1*1 + 0*2 + 5*3 = 14\\n// at i = 1 -> Cumulative-sum = 4 (5 + 0 + -1), and cur = cur + Cumlative_sum + satis[i] = (14 + 4 + -8) = -8*1 + -1*2 + 0*3 + 5*5= 14\\n// And similarly for i = 0 and and max of all currents is printed\\n\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        \\n        sort(satisfaction.begin(),satisfaction.end());\\n        int n = satisfaction.size();\\n        \\n        int Cumulative_sum = 0; // From back\\n        \\n        int ans = 0;\\n        int cur = 0;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            cur += Cumulative_sum + satisfaction[i];\\n            Cumulative_sum += satisfaction[i];\\n            \\n            ans = max(ans,cur);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353641,
                "title": "python3-and-c-beats-100-greedy-dp-easy-and-understandable",
                "content": "The algorithm used in this solution is based on sorting the satisfaction list in descending order and iterating over it. At each iteration, the satisfaction of the current dish is added to a running sum sum, and if this sum is positive, it is added to the answer ans. This guarantees that the algorithm always considers the best dishes to cook, which are the ones with higher satisfaction values.\\n\\nThe time complexity of this solution is O(nlogn), where n is the length of the input list satisfaction. This is because of the sorting operation performed at the beginning of the algorithm. However, this is an efficient solution for the problem, as there is no other way to get the optimal solution without iterating over all possible combinations of dishes, which would require an exponential time complexity.\\n\\n# Please Upvote \\uD83D\\uDE07\\n![image.png](https://assets.leetcode.com/users/images/4779ef79-d753-4f2a-b4fa-4dc595068b68_1680057214.5323102.png)\\n\\n## Python3\\n```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        v=sorted(satisfaction,reverse=True)\\n        sum=0\\n        ans=0\\n        for i in v:\\n            if(sum+i>0):\\n                ans+=sum+i\\n                sum+=i\\n        return ans\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        vector<int>v=satisfaction;\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        int sum=0,ans=0;\\n        for(int i=0;i<v.size();i++){\\n            if(sum+v[i]>0){\\n                ans+=sum+v[i];\\n                sum+=v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        v=sorted(satisfaction,reverse=True)\\n        sum=0\\n        ans=0\\n        for i in v:\\n            if(sum+i>0):\\n                ans+=sum+i\\n                sum+=i\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        vector<int>v=satisfaction;\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        int sum=0,ans=0;\\n        for(int i=0;i<v.size();i++){\\n            if(sum+v[i]>0){\\n                ans+=sum+v[i];\\n                sum+=v[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563284,
                "title": "c-ks-0-1-and-o-n-log-n",
                "content": "#### Approach 1: Knapsack 0-1\\nThis is just something that came to my mind initially. Just follow the DP pattern to pick or skip an item, and maximize the sum. Not very efficient for this problem though.\\n```cpp\\nint dp[501][501] = {};\\nint dfs(vector<int>& sat, int p, int t) {\\n    if (p >= sat.size())\\n        return 0;\\n    if (dp[p][t])\\n        return dp[p][t];       \\n    return dp[p][t] = max(dfs(sat, p + 1, t), sat[p] * t + dfs(sat, p + 1, t + 1));\\n}\\nint maxSatisfaction(vector<int>& sat) {\\n    sort(begin(sat), end(sat));\\n    return dfs(sat, 0, 1);\\n}\\n```\\n\\n#### Approach 2: O(n log n)\\nAll dishes with satisfaction >= 0 should be cooked, in the order of increasing the satisfaction. Now, we can also cook the dish with a smallest negative satisfaction, and see if a negative value is ofset by extra time bonus. If so, repeat with the next smallest negative satisfaction.\\n\\n```cpp\\nint maxSatisfaction(vector<int>& sat) {\\n    sort(begin(sat), end(sat));\\n    int run_sum = accumulate(begin(sat), end(sat), 0), total_sum = 0;\\n    for (auto i = 0; i < sat.size(); ++i)\\n        total_sum += (i + 1) * sat[i];\\n    for (auto i = 0; run_sum < 0 && i < sat.size(); ++i) {\\n        total_sum -= run_sum;\\n        run_sum -= sat[i];\\n    }\\n    return total_sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[501][501] = {};\\nint dfs(vector<int>& sat, int p, int t) {\\n    if (p >= sat.size())\\n        return 0;\\n    if (dp[p][t])\\n        return dp[p][t];       \\n    return dp[p][t] = max(dfs(sat, p + 1, t), sat[p] * t + dfs(sat, p + 1, t + 1));\\n}\\nint maxSatisfaction(vector<int>& sat) {\\n    sort(begin(sat), end(sat));\\n    return dfs(sat, 0, 1);\\n}\\n```\n```cpp\\nint maxSatisfaction(vector<int>& sat) {\\n    sort(begin(sat), end(sat));\\n    int run_sum = accumulate(begin(sat), end(sat), 0), total_sum = 0;\\n    for (auto i = 0; i < sat.size(); ++i)\\n        total_sum += (i + 1) * sat[i];\\n    for (auto i = 0; run_sum < 0 && i < sat.size(); ++i) {\\n        total_sum -= run_sum;\\n        run_sum -= sat[i];\\n    }\\n    return total_sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563291,
                "title": "java-sort-and-count-from-end-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int postSum=0,cur=0,res=0;\\n        for(int i=satisfaction.length-1; i>=0; i--){\\n            postSum += satisfaction[i];\\n            cur += postSum;\\n            res = Math.max(res, cur);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int postSum=0,cur=0,res=0;\\n        for(int i=satisfaction.length-1; i>=0; i--){\\n            postSum += satisfaction[i];\\n            cur += postSum;\\n            res = Math.max(res, cur);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353514,
                "title": "simple-and-detailed-explanation-which-beats-100",
                "content": "# Intuition\\n- The Final answer is composed of time * satisfaction values. To maximize the answer we would want the time value to be lower for small (or negative numbers) and higher for large numbers.\\n- So we can sort the array. If the array is all positive the answer should be `1* first_element + 2* second_element..` and so on.\\n- We might think that if the sorted array begins from negative values, then why use those values? Just start from the first positive value and use only those values `1* first_positive_element + 2*second_positive_element`. This is wrong as proved in following example\\n> For array [-1,-1,2,3] the answer with only positive elements considered is `1*2 + 2*3 = 8`. But with all elements the answer is `1*-1 + 2*-1 + 3*2 + 4*3 = 15`. This is because the initial numbers getting included means that the later numbers get a higher time multipler resulting in better overall result. \\n\\n# Approach\\n- We need to understand the basic concept that if an exra element is taken before the existing array, then the value of answer will increase by the value of element + sum of existing elements. The following example demonstrates this:\\n1 getting added before existing array means that `new value = old value + sum of elements`\\n![lci.PNG](https://assets.leetcode.com/users/images/3ea72f05-834c-4931-95e0-4cec28110c82_1680051966.9002726.png)\\n\\n- Hence we need to start from last elemnt taking sum and val both same, then move to last second element and so on. For each element we calculate possible value if the dishes considered start from that index and store the max value seen so far (see code for more clarity)\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n.log(n))$$ for sorting + $$O(n)$$ since we traverse the array once = $$O(n.log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$ since only two integer variables (sum and val) are maintained\\n\\n# Spread Some Love, Upvote if you liked the post\\n![p.PNG](https://assets.leetcode.com/users/images/3485de87-32d4-4f61-81fb-4a714935826b_1680052110.1773648.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n\\n        int sum = satisfaction[n-1];\\n        int val = satisfaction[n-1];\\n        int max = val;\\n        \\n        for(int i = n-2; i>=0; i--)\\n        {\\n            sum += satisfaction[i];\\n            val += sum;         // this sum is new sum since we have added current element in prev line\\n\\n            if(val > max)\\n                max = val;\\n        }\\n        return max < 0 ? 0 : max;   // if max less than zero, then no point in makng dishes\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n\\n        int sum = satisfaction[n-1];\\n        int val = satisfaction[n-1];\\n        int max = val;\\n        \\n        for(int i = n-2; i>=0; i--)\\n        {\\n            sum += satisfaction[i];\\n            val += sum;         // this sum is new sum since we have added current element in prev line\\n\\n            if(val > max)\\n                max = val;\\n        }\\n        return max < 0 ? 0 : max;   // if max less than zero, then no point in makng dishes\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760033,
                "title": "python-explanation-easy-simple-straightforward",
                "content": "The first thing to think about is how many dishes we want to serve. All dishes with a positive satisfaction score will increase the total satisfaction, as well as a dish with 0 satisfaction (coupled with at least one other positive dish - but it will never negatively impact our satisfaction score). Thus, we will serve all non-negative dishes.\\n\\nThere may also be some non-negative dishes that we want to serve. This is because that, yes, while there\\'s some negative impact on satisfaction, it may be outweighed by the cumulative effect of increasing the number of dishes served.\\n\\nFor instance, if you serve just an 8 and 9 dish and you have only one other dish you can serve, a -5 dish, you should do it. You\\'ll add an additional 8+9-5 = 12 > 0 for serving the -5 dish.\\n\\nSee what happened there? We just need to pay attention to the marginal increase with serving another dish.\\n\\nThe marginal increase is given by the cumulative sum of the sorted (largest to smallest) satisfaction scores up to a given dish, e.g. for [9,8,1,-3,-6, -10, -12], the cumulative sums by corresponding index would be \\n\\n```\\n# Dishes\\n# [009, 008, 001, -03, -06, -10, -12]\\n# Marginal benefits of adding each dish (you could think of this as the delta or discrete derivative)\\n# [009, 017, 018, 015, 009, -01, -13]\\n# given by \\n# [9, 9+8, 9+8+1, 9+8+1-3, 9+8+1-3-6, 9+8+1-3-6-10, 9+8+1-3-6-10-12].\\n```\\n\\nThus, we should serve the first five dishes, up to but not including the -10 dish, and then not serve the last two (-10 and -12).\\n\\nNotice that we don\\'t need to store this in an array. We can just keep this in a single variable, as we\\'re just updating the running sum at each index by adding the current element, watching for the marginal benefit to turn negative.\\n\\nOnce we know how many dishes we\\'re serving, it\\'s trivial to calculate the result.\\n\\nOne way to do just add the runningSum at each iteration for each dish you want to serve to an accumulating variable, e.g. the result.\\n\\nAnd you\\'re done!\\n\\nTo summarize:\\n\\n1) sort largest to smallest\\n2) track marginal benefit, the \"runningSum,\" as you iterate over each element, checking to see if it\\'s turned negative\\n3) compute your result given the (this can and ought to be done in conjunction with the above)\\n\\nHere\\'s the code, and please leave questions should you have any and thumbs up this if it helped you - or whatever the thumbs-up on this site is. :)\\n\\n```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        \\n\\t\\t# sort largest to smallest\\n        satisfaction.sort(reverse=True)\\n        \\n        runningSum = 0\\n        result = 0\\n        for val in satisfaction:\\n            runningSum += val\\n\\t\\t\\t# if it\\'s no longer beneficial to serve the next dish\\n            if runningSum < 0:\\n                break\\n            result += runningSum\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n# Dishes\\n# [009, 008, 001, -03, -06, -10, -12]\\n# Marginal benefits of adding each dish (you could think of this as the delta or discrete derivative)\\n# [009, 017, 018, 015, 009, -01, -13]\\n# given by \\n# [9, 9+8, 9+8+1, 9+8+1-3, 9+8+1-3-6, 9+8+1-3-6-10, 9+8+1-3-6-10-12].\\n```\n```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        \\n\\t\\t# sort largest to smallest\\n        satisfaction.sort(reverse=True)\\n        \\n        runningSum = 0\\n        result = 0\\n        for val in satisfaction:\\n            runningSum += val\\n\\t\\t\\t# if it\\'s no longer beneficial to serve the next dish\\n            if runningSum < 0:\\n                break\\n            result += runningSum\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353613,
                "title": "c-easiest-solution-prefix-sum-and-sorting-approach-94-faster",
                "content": "## **\\u2705\\u2705C++ || Easiest Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFPrefix Sum and Sorting Approach || 94% faster**\\n# **Please Upvote as it really motivates me**\\n**Approach:**\\nFirst observation is that we will have to assign maximum previous dish count to some positive number\\nso we will first sort it in desending order because we are going to take the max positive in our consideration always\\n\\nLets we have array now [5,2,-1,-2] now we have to basically find max of `(5*1,5*2+2*1,5*3+2*2+-1*1,5*4+2*3+-1*2+-2*1)` we can rewrite it as \\n```\\nprefixSum[0],prefixSum[1]+prefixSum[0],prefixSum[2]+prefixSum[1]+prefixSum[0]\\n,prefixSum[4]+prefixSum[2]+prefixSum[1]+prefixSum[0]\\n```\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& sat) {\\n        int n=sat.size();\\n        sort(sat.begin(),sat.end(),greater<int>());\\n        vector<int>sum=sat;\\n        for(int i=1;i<n;i++){\\n            sum[i]+=sum[i-1];\\n        }\\n        int mx=0,cur=0;\\n        for(int i=0;i<n;i++){\\n            cur+=sum[i];\\n            mx=max(cur,mx);\\n        }\\n        return mx;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/76553ed1-6ae2-43aa-9553-2e4ca0345955_1680055363.574511.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nprefixSum[0],prefixSum[1]+prefixSum[0],prefixSum[2]+prefixSum[1]+prefixSum[0]\\n,prefixSum[4]+prefixSum[2]+prefixSum[1]+prefixSum[0]\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& sat) {\\n        int n=sat.size();\\n        sort(sat.begin(),sat.end(),greater<int>());\\n        vector<int>sum=sat;\\n        for(int i=1;i<n;i++){\\n            sum[i]+=sum[i-1];\\n        }\\n        int mx=0,cur=0;\\n        for(int i=0;i<n;i++){\\n            cur+=sum[i];\\n            mx=max(cur,mx);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714561,
                "title": "c-simple-top-down-o-n2-slow-dp",
                "content": "This idea is such that, after sorting, you have two choices for a particular dish. Either make it or skip it. Sorting is so that, you don\\'t have to search the entire array for making the next best choice. Also, higher the satisfaction, the higher time we prefer.\\n```\\nvector<vector<int>> memo;\\nint dp(int i,int t,vector<int>& arr)\\n{\\n    if(i>=arr.size())\\n        return 0;\\n    if(memo[i][t]!=-1)\\n        return memo[i][t];\\n    int not_taken=dp(i+1,t,arr);\\n    int taken=arr[i]*t+dp(i+1,t+1,arr);\\n    return memo[i][t]=max(taken,not_taken);\\n}\\nint maxSatisfaction(vector<int>& arr) \\n{\\n    sort(arr.begin(),arr.end());\\n    int n=arr.size();\\n    memo.resize(n,vector<int>(n+1,-1));\\n    return dp(0,1,arr);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<vector<int>> memo;\\nint dp(int i,int t,vector<int>& arr)\\n{\\n    if(i>=arr.size())\\n        return 0;\\n    if(memo[i][t]!=-1)\\n        return memo[i][t];\\n    int not_taken=dp(i+1,t,arr);\\n    int taken=arr[i]*t+dp(i+1,t+1,arr);\\n    return memo[i][t]=max(taken,not_taken);\\n}\\nint maxSatisfaction(vector<int>& arr) \\n{\\n    sort(arr.begin(),arr.end());\\n    int n=arr.size();\\n    memo.resize(n,vector<int>(n+1,-1));\\n    return dp(0,1,arr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563357,
                "title": "python-o-n-log-n-stupid-one-liner",
                "content": "```\\nclass Solution:\\n    def maxSatisfaction(self, arr):\\n        return max(0, max(itertools.accumulate(itertools.accumulate(sorted(arr, reverse=True)))))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, arr):\\n        return max(0, max(itertools.accumulate(itertools.accumulate(sorted(arr, reverse=True)))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355849,
                "title": "image-explanation-complete-intuition-greedy-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Reducing Dishes` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/16cee439-e8ff-4a47-a29c-6b69302fd5d4_1680106803.238005.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/3d764847-32f6-4bfd-8b77-a3166d47a678_1680099977.1858284.png)\\n![image.png](https://assets.leetcode.com/users/images/90877ecc-13b2-4454-a244-c76646ac175a_1680099986.74994.png)\\n![image.png](https://assets.leetcode.com/users/images/564dc83e-08df-465e-b753-e027198133ce_1680099996.482031.png)\\n![image.png](https://assets.leetcode.com/users/images/16471efd-583d-4ea6-98cf-63ffe2351ff2_1680100011.0018373.png)\\n![image.png](https://assets.leetcode.com/users/images/bbda3395-29ae-4a60-b298-7b628e21e3af_1680100020.1158636.png)\\n![image.png](https://assets.leetcode.com/users/images/2f8106db-f2ee-492e-823e-73d2ac5d7e30_1680100028.5037134.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end(), greater<int>());\\n        \\n        int prefSum = 0, res = 0, n = satisfaction.size();\\n        for (int i = 0; i < n; i++) {\\n            prefSum += satisfaction[i];\\n            if (prefSum < 0) {\\n                break;\\n            }\\n            res += prefSum;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n\\n        int prefSum = 0, res = 0, n = satisfaction.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            prefSum += satisfaction[i];\\n            if (prefSum < 0) {\\n                break;\\n            }\\n            res += prefSum;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort(reverse=True)\\n\\n        prefSum, res, n = 0, 0, len(satisfaction)\\n        for i in range(n):\\n            prefSum += satisfaction[i]\\n            if prefSum < 0:\\n                break\\n            res += prefSum\\n\\n        return res\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end(), greater<int>());\\n        \\n        int prefSum = 0, res = 0, n = satisfaction.size();\\n        for (int i = 0; i < n; i++) {\\n            prefSum += satisfaction[i];\\n            if (prefSum < 0) {\\n                break;\\n            }\\n            res += prefSum;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n\\n        int prefSum = 0, res = 0, n = satisfaction.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            prefSum += satisfaction[i];\\n            if (prefSum < 0) {\\n                break;\\n            }\\n            res += prefSum;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort(reverse=True)\\n\\n        prefSum, res, n = 0, 0, len(satisfaction)\\n        for i in range(n):\\n            prefSum += satisfaction[i]\\n            if prefSum < 0:\\n                break\\n            res += prefSum\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563911,
                "title": "python-o-n-lg-n-peak-finding-with-drawing-explanation",
                "content": "Just notice that positive numbers can only make the sum bigger, and if a negative number is making the sum smaller, any negative number smaller than it can only make the sum smaller.\\n\\nI\\'m very bad at explaining so here\\'s a drawing.\\nTLDR is \"There can only be 1 peak, so let\\'s do a basic peak finding over the sorted array\"\\nTime complexity: O(nlgn) because of the sorting\\n![image](https://assets.leetcode.com/users/9nm3/image_1586035189.png)\\n\\n```\\ndef get_coef_sum(s, i):\\n    return sum((a+1)*b for a,b in enumerate(s[i:]))\\n\\nclass Solution:\\n    # Just a basic 1D peak finding algortihm\\n    def maxSatisfaction(self, satisfaction) -> int:\\n        n = len(satisfaction)\\n        s = sorted(satisfaction)\\n        \\n        l, r = 0, n\\n        while l < r:\\n            middle = l + (r-l)//2\\n            cur_sum = get_coef_sum(s, middle)\\n            left_bigger = middle == 0 or get_coef_sum(s, middle-1) >= cur_sum\\n            right_bigger = middle == n-1 or get_coef_sum(s, middle+1) >= cur_sum\\n\\n            if not left_bigger and not right_bigger:\\n                return get_coef_sum(s, middle)\\n\\n            elif left_bigger:\\n                r = middle\\n            else:\\n                l = middle+1\\n\\n        return get_coef_sum(s, l)\\n```\\n\\t\\nPlease let me know if that makes sense, and how it could be explained better, thanks!",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ndef get_coef_sum(s, i):\\n    return sum((a+1)*b for a,b in enumerate(s[i:]))\\n\\nclass Solution:\\n    # Just a basic 1D peak finding algortihm\\n    def maxSatisfaction(self, satisfaction) -> int:\\n        n = len(satisfaction)\\n        s = sorted(satisfaction)\\n        \\n        l, r = 0, n\\n        while l < r:\\n            middle = l + (r-l)//2\\n            cur_sum = get_coef_sum(s, middle)\\n            left_bigger = middle == 0 or get_coef_sum(s, middle-1) >= cur_sum\\n            right_bigger = middle == n-1 or get_coef_sum(s, middle+1) >= cur_sum\\n\\n            if not left_bigger and not right_bigger:\\n                return get_coef_sum(s, middle)\\n\\n            elif left_bigger:\\n                r = middle\\n            else:\\n                l = middle+1\\n\\n        return get_coef_sum(s, l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563367,
                "title": "python-greedy-sorting-and-prefix-sum-o-n-log-n",
                "content": "We want to maximize the like-time coefficient sum. Satisfaction levels are multiplied with their production time. Therefore it is always better to produce the dishes with the highest satisfation in the end as the product will be higher.\\nThere is no need to discard dishes with a positive satisfaction level. Dishes with a satisfaction level of 0 are also excellent fillers.\\nDishes with negative satisfaction levels can still contribute to the maximum result as they are increasing the time for the positive dishes. Therefore the most negative dishes should be discarded before the less negative dishes.\\nThat tells us that we should sort the satisfaction array.\\n\\nFor every dish added the prefix sum is increased by the dishes satisfaction level.\\nThen we can increase the current sum by the whole prefix sum as that will increase the time multiplicator for every previous dish by one.\\n```python\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        prefix_sum = 0\\n        cur_sum = 0\\n        max_sum = 0\\n        \\n        for num in sorted(satisfaction, reverse=True):\\n            prefix_sum += num\\n            cur_sum += prefix_sum\\n            max_sum = max(max_sum, cur_sum)\\n        \\n        return max_sum\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        prefix_sum = 0\\n        cur_sum = 0\\n        max_sum = 0\\n        \\n        for num in sorted(satisfaction, reverse=True):\\n            prefix_sum += num\\n            cur_sum += prefix_sum\\n            max_sum = max(max_sum, cur_sum)\\n        \\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563326,
                "title": "o-n-log-n-time-o-1-space-greedy-prefix-sum-explanation",
                "content": "1.) It\\'s easy to see we want to spend most time on highest number so we sort the satisfatction.\\n2.) We might like to stop at some point if a satisfaction becomes too negative.\\n3.) We can calculate in linear time that point using prefix sums as each time we consider the next satisfaction, increasing all previous times with 1 is the same as adding the prefix sum so far.\\n\\n```C++\\nint maxSatisfaction(vector<int>& s) {\\n    sort(s.rbegin(), s.rend()); // sort descending\\n    int best = 0; // best result\\n    int prefixSum = 0; // sum of all satisfaction from biggest to s[i]\\n    int cur = 0; //result after each iteration\\n    for (int i = 0; i < s.size(); i++) {\\n        prefixSum += s[i]; // add this to prefixSum\\n        cur += prefixSum; // cur so far (we add +1 time to all previous)\\n        best = max(best, cur); // is cur better?\\n    }\\n    return best;\\n}\\n```",
                "solutionTags": [],
                "code": "```C++\\nint maxSatisfaction(vector<int>& s) {\\n    sort(s.rbegin(), s.rend()); // sort descending\\n    int best = 0; // best result\\n    int prefixSum = 0; // sum of all satisfaction from biggest to s[i]\\n    int cur = 0; //result after each iteration\\n    for (int i = 0; i < s.size(); i++) {\\n        prefixSum += s[i]; // add this to prefixSum\\n        cur += prefixSum; // cur so far (we add +1 time to all previous)\\n        best = max(best, cur); // is cur better?\\n    }\\n    return best;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3354115,
                "title": "day-363-100-java-c-python-explained-intution-one-liner-o-1",
                "content": "# Please Upvote as it really motivates me\\n![image.png](https://assets.leetcode.com/users/images/fefe1ecc-4a50-414c-87cb-493f477b4ea6_1680053391.3087208.png)\\n\\n##### \\u2022\\tThere are multiple ways to solve this problem, Here are some other possible ways to solve the problem:\\n##### \\u2022\\tBrute force: Generate all possible subsets of the dishes and calculate the total satisfaction value for each subset. Return the maximum total satisfaction value among all subsets. This approach has a time complexity of O(2^n), where n is the number of dishes, which is not practical for large values of n.\\n##### \\u2022\\tDynamic programming: Use a dynamic programming approach to calculate the maximum total satisfaction value for each prefix of the sorted list of dishes. The maximum total satisfaction value for the entire list can be obtained by finding the prefix with the maximum total satisfaction value. This approach has a time complexity of O(n log n), which is better than the brute force approach but not as efficient as the algorithm shown in the code.\\n##### \\u2022\\tDivide and conquer: Divide the sorted list of dishes into two halves and recursively calculate the maximum total satisfaction value for each half. The maximum total satisfaction value for the entire list can be obtained by combining the maximum total satisfaction values of the two halves and the maximum total satisfaction value that includes dishes from both halves. This approach has a time complexity of O(n log n), which is the same as the dynamic programming approach but may require more memory.\\n\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tThe intuition behind this problem is that the chef should prioritize cooking dishes with higher satisfaction values first, as they contribute more to the like-time coefficient. Additionally, the chef should discard dishes with negative satisfaction values, as they decrease the total like-time coefficient.\\n\\n##### \\u2022\\tThe key observation is the greedy approach used to solve the problem. The problem involves selecting a set of dishes to cook from a list of dishes, where each dish has a satisfaction value and a cooking time. The goal is to maximize the total satisfaction value of the dishes cooked within a given time limit.\\n##### \\u2022\\tThe observation states that the dishes should be selected in order of decreasing satisfaction value, and the dishes with the smallest satisfaction value should be cooked first. This is because the most satisfied dishes should be saved for later, when the total satisfaction value of the dishes cooked so far is already high. This ensures that the most satisfied dishes are cooked when the total satisfaction value is already high, which maximizes the overall satisfaction value.\\n##### \\u2022\\tThe greedy approach used solve the problem involves selecting dishes in order of decreasing satisfaction value, and adding them to the menu list as long as the total satisfaction value of the dishes on the menu list plus the satisfaction value of the next dish is positive. This ensures that only dishes with a positive contribution to the total satisfaction value are added to the menu list.\\n##### \\u2022\\tOnce a dish is added to the menu list, all dishes on the menu list will be cooked one time unit later, and the total satisfaction value of the dishes on the menu list will be updated accordingly. This ensures that the cooking time of each dish is taken into account, and the total satisfaction value of the dishes cooked within the given time limit is maximized.\\n##### \\u2022\\tOverall, the observation and the greedy approach used to solve the problem are based on the intuition that the most satisfied dishes should be saved for later, and the dishes with the smallest satisfaction value should be cooked first. This ensures that the total satisfaction value of the dishes cooked within the given time limit is maximized.\\n\\n# Algorithm\\n##### \\u2022\\tThe algorithm works by iterating over the sorted list of dishes in reverse order, starting with the dish with the highest satisfaction value. For each dish, the algorithm adds its satisfaction value to the total satisfaction value of the dishes on the menu list and updates the maximum total satisfaction value of the dishes cooked so far. The algorithm stops iterating when it reaches a dish with a negative satisfaction value or when the total satisfaction value of the dishes on the menu list becomes negative.\\n##### \\u2022\\tThis algorithm sorts the satisfaction values in increasing order and then iterates over the sorted list of dishes in reverse order. The algorithm maintains two variables:   total satisfaction value of the dishes on the menu list and maximum total satisfaction value of the dishes cooked so far.\\n##### \\u2022\\tFor each dish in the sorted list, the algorithm adds the satisfaction value of the current dish to the total satisfaction value of the dishes on the menu list and updates the maximum total satisfaction value of the dishes cooked so far by adding the updated total satisfaction value of the dishes on the menu list. The loop continues as long as there are dishes in the list and the satisfaction value of the current dish plus the total satisfaction value of the dishes on the menu list is greater than 0.\\n\\nHERE MY POST LINK https://leetcode.com/problems/reducing-dishes/solutions/3354115/day-363-100-java-c-python-explained-intution-one-liner-o-1/\\n\\n# Explaination \\n\\n##### \\u2022\\twe are given a list of dishes, each with a satisfaction value and a cooking time. The goal is to select a subset of dishes to cook within a given time limit, such that the total satisfaction value of the cooked dishes is maximized. \\n##### \\u2022\\twe should cook the dishes with the smallest satisfaction value first, and only add dishes to the menu list if they have a positive contribution to the total satisfaction value. \\n##### \\u2022\\tThis ensures that we maximize the total satisfaction value of the dishes cooked within the given time limit. The approach used to solve the problem is a greedy approach that selects dishes in order of increasing satisfaction value and adds them to the menu list as long as they have a positive contribution to the total satisfaction value. \\n##### \\u2022\\tThis ensures that the total satisfaction value of the dishes cooked within the given time limit is maximized. \\n##### \\u2022\\tThe algorithm first sorts the list of dishes in increasing order of satisfaction value using the sort function from the STL library. \\n##### \\u2022\\tThis is because we want to cook the dishes with the smallest satisfaction value first, as explained in the intuition. The algorithm then initializes the variables res , total , and n . res is the total satisfaction value of the dishes cooked so far, total is the total satisfaction value of the dishes on the menu list, and n is the number of dishes in the list. The algorithm then iterates over the sorted list of dishes in reverse order using a for loop. \\n##### \\u2022\\tThe loop starts from the last dish in the list and goes backwards. The loop continues as long as there are dishes in the list and the satisfaction value of the current dish plus the total satisfaction value of the dishes on the menu list is greater than 0. For each dish in the loop, the algorithm adds the satisfaction value of the dish to the total satisfaction value of the dishes on the menu list using the += operator. \\n##### \\u2022\\tThe algorithm then adds the updated total satisfaction value of the dishes on the menu list to the total satisfaction value of the dishes cooked so far using the += operator. \\n##### \\u2022\\tThis ensures that only dishes with a positive contribution to the total satisfaction value are added to the menu list, and the total satisfaction value of the dishes cooked within the given time limit is maximized. \\n##### \\u2022\\tOnce the loop is complete, the algorithm returns the total satisfaction value of the dishes cooked so far, which is stored in the variable res . \\n##### \\u2022\\tOverall, the algorithm is a greedy approach that selects dishes in order of increasing satisfaction value and adds them to the menu list as long as they have a positive contribution to the total satisfaction value. This ensures that the total satisfaction value of the dishes cooked within the given time limit is maximized.\\n\\n\\n# Code\\n```c++ []\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n    // Sort the satisfaction values in increasing order\\n    sort(satisfaction.begin(), satisfaction.end());\\n\\n    int totalSatisfaction = 0; // Total satisfaction value of the dishes on the menu list\\n    int maxTotalSatisfaction = 0; // Maximum total satisfaction value of the dishes cooked so far\\n    int numDishes = satisfaction.size(); // Number of dishes in the list\\n\\n    // Iterate over the sorted list of dishes in reverse order\\n    for (int i = numDishes - 1; i >= 0 && satisfaction[i] > -totalSatisfaction; --i) {\\n        // Add the satisfaction value of the current dish to the total satisfaction value of the dishes on the menu list\\n        totalSatisfaction += satisfaction[i];\\n\\n        // Add the updated total satisfaction value of the dishes on the menu list to the maximum total satisfaction value of the dishes cooked so far\\n        maxTotalSatisfaction += totalSatisfaction;\\n    }\\n\\n    // Return the maximum total satisfaction value of the dishes cooked so far\\n    return maxTotalSatisfaction;\\n}\\n```\\n```java []\\npublic int maxSatisfaction(int[] satisfaction) {\\n    Arrays.sort(satisfaction);\\n\\n    int totalSatisfaction = 0;\\n    int maxTotalSatisfaction = 0;\\n    int numDishes = satisfaction.length;\\n\\n    for (int i = numDishes - 1; i >= 0 && satisfaction[i] > -totalSatisfaction; --i) {\\n        totalSatisfaction += satisfaction[i];\\n        maxTotalSatisfaction += totalSatisfaction;\\n    }\\n\\n    return maxTotalSatisfaction;\\n}\\n```\\n```python []\\ndef maxSatisfaction(satisfaction: List[int]) -> int:\\n    satisfaction.sort()\\n\\n    total_satisfaction = 0\\n    max_total_satisfaction = 0\\n    num_dishes = len(satisfaction)\\n\\n    for i in range(num_dishes - 1, -1, -1):\\n        if satisfaction[i] > -total_satisfaction:\\n            total_satisfaction += satisfaction[i]\\n            max_total_satisfaction += total_satisfaction\\n        else:\\n            break\\n\\n    return max_total_satisfaction\\n```\\n\\n\\n# Complexity\\n\\n##### \\u2022\\tThe time complexity (TC) of the given algorithm is O(n log n), where n is the size of the input vector A. \\n##### \\u2022\\tThis is because the algorithm first sorts the input vector using the sort function, which has a time complexity of O(n log n) in the average case. \\n##### \\u2022\\tThe algorithm then iterates over the sorted vector once, which has a time complexity of O(n). Therefore, the overall time complexity of the algorithm is O(n log n). \\n##### \\u2022\\tThe space complexity (SC) of the given algorithm is O(1), which means that the amount of memory used by the algorithm is constant and does not depend on the size of the input vector A. \\n##### \\u2022\\tThis is because the algorithm only uses a constant amount of memory to store the variables res , total , and n , and does not create any additional data structures or arrays. Therefore, the overall space complexity of the algorithm is O(1).\\n\\n# 2nd one-liner\\n\\n```python []\\ndef maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        return max([0]+list(accumulate(accumulate(sorted(satisfaction)[::-1]))))\\n```\\n```java []\\npublic int maxSatisfaction(int[] satisfaction) {\\n    Arrays.sort(satisfaction);\\n    return Math.max(0, IntStream.range(0, satisfaction.length).map(i -> IntStream.range(i, satisfaction.length).map(j -> satisfaction[j] * (j - i + 1)).sum()).max().orElse(0));\\n}\\n```\\n```c++ []\\nint maxSatisfaction(std::vector<int>& satisfaction) {\\n        std::sort(satisfaction.begin(), satisfaction.end());\\n        std::vector<int> cum_sum(satisfaction.size() + 1);\\n        std::partial_sum(satisfaction.rbegin(), satisfaction.rend(), cum_sum.rbegin() + 1);\\n        std::partial_sum(cum_sum.rbegin(), cum_sum.rend(), cum_sum.rbegin());\\n        return *std::max_element(cum_sum.begin(), cum_sum.end());\\n    }\\n```\\n\\n\\n# DRY RUN 1\\n\\n##### \\u2022\\tLet\\'s do a dry run of the algorithm with the given input: satisfaction = [-1, -8, 0, 5, -9] \\n##### \\u2022\\tFirst, the algorithm sorts the satisfaction values in increasing order: satisfaction = [-9, -8, -1, 0, 5] \\n##### \\u2022\\tNext, the algorithm initializes the variables totalSatisfaction , maxTotalSatisfaction , and numDishes : totalSatisfaction = 0 maxTotalSatisfaction = 0 numDishes = 5 \\n##### \\u2022\\tThe algorithm then enters a for loop that iterates over the sorted list of dishes in reverse order: for (int i = numDishes - 1; i >= 0 && satisfaction[i] > -totalSatisfaction; --i) { // ... } \\n##### \\u2022\\tThe loop starts with i equal to 4, which is the index of the last dish in the sorted list. The loop continues as long as there are dishes in the list and the satisfaction value of the current dish plus the total satisfaction value of the dishes on the menu list is greater than 0. \\n##### \\u2022\\tFor the first iteration of the loop, the current dish has a satisfaction value of 5 and the total satisfaction value of the dishes on the menu list is 0. \\n##### \\u2022\\tTherefore, the condition satisfaction[i] > -totalSatisfaction is true, and the algorithm enters the loop body. Inside the loop body, the algorithm adds the satisfaction value of the current dish to the total satisfaction value of the dishes on the menu list: totalSatisfaction += satisfaction[i] // totalSatisfaction = 5 \\n##### \\u2022\\tThe algorithm then adds the updated total satisfaction value of the dishes on the menu list to the maximum total satisfaction value of the dishes cooked so far: maxTotalSatisfaction += totalSatisfaction // maxTotalSatisfaction = 5 \\n##### \\u2022\\tThe loop then continues with i equal to 3, which is the index of the next dish in the sorted list. \\n##### \\u2022\\tThe current dish has a satisfaction value of 0 and the total satisfaction value of the dishes on the menu list is 5. Therefore, the condition satisfaction[i] > -totalSatisfaction is true, and the algorithm enters the loop body. Inside the loop body, the algorithm adds the satisfaction value of the current dish to the total satisfaction value of the dishes on the menu list: totalSatisfaction += satisfaction[i] // totalSatisfaction = 5 \\n##### \\u2022\\tThe algorithm then adds the updated total satisfaction value of the dishes on the menu list to the maximum total satisfaction value of the dishes cooked so far: maxTotalSatisfaction += totalSatisfaction // maxTotalSatisfaction = 10 \\n##### \\u2022\\tThe loop then continues with i equal to 2, which is the index of the next dish in the sorted list. The current dish has a satisfaction value of -1 and the total satisfaction value of the dishes on the menu list is 5. \\n##### \\u2022\\tTherefore, the condition satisfaction[i] > -totalSatisfaction is true, and the algorithm enters the loop body. Inside the loop body, the algorithm adds the satisfaction value of the current dish to the total satisfaction value of the dishes on the menu list: totalSatisfaction += satisfaction[i] // totalSatisfaction = 4 \\n##### \\u2022\\tThe algorithm then adds the updated total satisfaction value of the dishes on the menu list to the maximum total satisfaction value of the dishes cooked so far: maxTotalSatisfaction += totalSatisfaction // maxTotalSatisfaction = 14 \\n##### \\u2022\\tThe loop then continues with i equal to 1, which is the index of the next dish in the sorted list. The current dish has a satisfaction value of -8 and the total satisfaction value of the dishes on the menu list is 4. \\n##### \\u2022\\tTherefore, the condition satisfaction[i] > -totalSatisfaction is false, and the algorithm exits the loop. \\n##### \\u2022\\tFinally, the algorithm returns the maximum total satisfaction value of the dishes cooked so far, which is stored in the variable maxTotalSatisfaction : return maxTotalSatisfaction // 14 Therefore, the output of the algorithm for the given input is 14.\\n\\n# DRY RUN 2\\n\\n##### \\u2022\\tLet\\'s do a dry run of the algorithm with the given input: satisfaction = [4, 3, 2] First, the algorithm sorts the satisfaction values in increasing order: satisfaction = [2, 3, 4] \\n##### \\u2022\\tNext, the algorithm initializes the variables totalSatisfaction , maxTotalSatisfaction , and numDishes : totalSatisfaction = 0 maxTotalSatisfaction = 0 numDishes = 3 \\n##### \\u2022\\tThe algorithm then enters a for loop that iterates over the sorted list of dishes in reverse order: for (int i = numDishes - 1; i >= 0 && satisfaction[i] > -totalSatisfaction; --i) { // ... } \\n##### \\u2022\\tThe loop starts with i equal to 2, which is the index of the last dish in the sorted list. The loop continues as long as there are dishes in the list and the satisfaction value of the current dish plus the total satisfaction value of the dishes on the menu list is greater than 0.\\n##### \\u2022\\tFor the first iteration of the loop, the current dish has a satisfaction value of 4 and the total satisfaction value of the dishes on the menu list is 0. \\n##### \\u2022\\tTherefore, the condition satisfaction[i] > -totalSatisfaction is true, and the algorithm enters the loop body. Inside the loop body, the algorithm adds the satisfaction value of the current dish to the total satisfaction value of the dishes on the menu list: totalSatisfaction += satisfaction[i] // totalSatisfaction = 4 \\n##### \\u2022\\tThe algorithm then adds the updated total satisfaction value of the dishes on the menu list to the maximum total satisfaction value of the dishes cooked so far: maxTotalSatisfaction += totalSatisfaction // maxTotalSatisfaction = 4 \\n##### \\u2022\\tThe loop then continues with i equal to 1, which is the index of the next dish in the sorted list. The current dish has a satisfaction value of 3 and the total satisfaction value of the dishes on the menu list is 4. \\n##### \\u2022\\tTherefore, the condition satisfaction[i] > -totalSatisfaction is true, and the algorithm enters the loop body. Inside the loop body, the algorithm adds the satisfaction value of the current dish to the total satisfaction value of the dishes on the menu list: totalSatisfaction += satisfaction[i] // totalSatisfaction = 7 \\n##### \\u2022\\tThe algorithm then adds the updated total satisfaction value of the dishes on the menu list to the maximum total satisfaction value of the dishes cooked so far: maxTotalSatisfaction += totalSatisfaction // maxTotalSatisfaction = 11 \\n##### \\u2022\\tThe loop then continues with i equal to 0, which is the index of the next dish in the sorted list. The current dish has a satisfaction value of 2 and the total satisfaction value of the dishes on the menu list is 7. \\n##### \\u2022\\tTherefore, the condition satisfaction[i] > -totalSatisfaction is true, and the algorithm enters the loop body. Inside the loop body, the algorithm adds the satisfaction value of the current dish to the total satisfaction value of the dishes on the menu list: totalSatisfaction += satisfaction[i] // totalSatisfaction = 9 \\n##### \\u2022\\tThe algorithm then adds the updated total satisfaction value of the dishes on the menu list to the maximum total satisfaction value of the dishes cooked so far: maxTotalSatisfaction += totalSatisfaction // maxTotalSatisfaction = 20 \\n##### \\u2022\\tThe loop then continues with i equal to -1, which is out of bounds for the list. \\n##### \\u2022\\tTherefore, the loop exits. Finally, the algorithm returns the maximum total satisfaction value of the dishes cooked so far, which is stored in the variable maxTotalSatisfaction : return maxTotalSatisfaction // 20 \\n##### \\u2022\\tTherefore, the output of the algorithm for the given input is 20.\\n\\n# DRY RUN 3\\n\\n##### \\u2022\\tLet\\'s do a dry run of the algorithm with the given input: satisfaction = [-1, -4, -5] \\n##### \\u2022\\tFirst, the algorithm sorts the satisfaction values in increasing order: satisfaction = [-5, -4, -1] \\n##### \\u2022\\tNext, the algorithm initializes the variables totalSatisfaction , maxTotalSatisfaction , and numDishes : totalSatisfaction = 0 maxTotalSatisfaction = 0 numDishes = 3 \\n##### \\u2022\\tThe algorithm then enters a for loop that iterates over the sorted list of dishes in reverse order: for (int i = numDishes - 1; i >= 0 && satisfaction[i] > -totalSatisfaction; --i) { // ... } \\n##### \\u2022\\tThe loop starts with i equal to 2, which is the index of the last dish in the sorted list. The loop continues as long as there are dishes in the list and the satisfaction value of the current dish plus the total satisfaction value of the dishes on the menu list is greater than 0. \\n##### \\u2022\\tFor the first iteration of the loop, the current dish has a satisfaction value of -1 and the total satisfaction value of the dishes on the menu list is 0. \\n##### \\u2022\\tTherefore, the condition satisfaction[i] > -totalSatisfaction is false, and the algorithm exits the loop. \\n##### \\u2022\\tFinally, the algorithm returns the maximum total satisfaction value of the dishes cooked so far, which is stored in the variable maxTotalSatisfaction : return maxTotalSatisfaction // 0 \\n##### \\u2022\\tTherefore, the output of the algorithm for the given input is 0.\\n\\n\\n# DP (MEMO)\\n![image.png](https://assets.leetcode.com/users/images/0f6a31d9-d051-4849-a964-bef973b91f95_1680066107.9021032.png)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int findMaxSatisfaction(vector<int>& satisfaction, vector<vector<int>>& memo, int index, int time) {\\n        // Return 0 if we have iterated over all the dishes.\\n        if (index == satisfaction.size()) {\\n            return 0;\\n        }\\n\\n        // We have already calculated the answer, so no need to go into recursion.\\n        if (memo[index][time] != -1) {\\n            return memo[index][time];\\n        }\\n\\n        // Return the maximum of two choices:\\n        // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n        int cook = satisfaction[index] * time + findMaxSatisfaction(satisfaction, memo, index + 1, time + 1);\\n        // 2. Skip the current dish and move on to the next dish at the same time.\\n        int skip =findMaxSatisfaction(satisfaction, memo, index + 1, time);\\n        return memo[index][time] = max(cook,\\n                                        skip);\\n    }\\n\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n\\n        vector<vector<int>> memo(satisfaction.size() + 1, vector<int>(satisfaction.size() + 1, -1));\\n\\n        // Mark all the states as -1, denoting not yet calculated.\\n        for (int i = 0; i < satisfaction.size(); i++) {\\n            fill(memo[i].begin(), memo[i].end(), -1);\\n        }\\n\\n        return findMaxSatisfaction(satisfaction, memo, 0, 1);\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public int findMaxSatisfaction(int[] satisfaction, int[][] memo, int index, int time) {\\n        // Return 0 if we have iterated over all the dishes.\\n        if (index == satisfaction.length) {\\n            return 0;\\n        }\\n\\n        // We have already calculated the answer, so no need to go into recursion.\\n        if (memo[index][time] != -1) {\\n            return memo[index][time];\\n        }\\n\\n        // Return the maximum of two choices:\\n        // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n        int cook = satisfaction[index] * time + findMaxSatisfaction(satisfaction, memo, index + 1, time + 1);\\n        // 2. Skip the current dish and move on to the next dish at the same time.\\n        int skip = findMaxSatisfaction(satisfaction, memo, index + 1, time);\\n        return memo[index][time] = Math.max(cook, skip);\\n    }\\n\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n\\n        int[][] memo = new int[satisfaction.length + 1][satisfaction.length + 1];\\n\\n        // Mark all the states as -1, denoting not yet calculated.\\n        for (int i = 0; i < satisfaction.length; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n\\n        return findMaxSatisfaction(satisfaction, memo, 0, 1);\\n    }\\n}\\n```\\n```PYTHON []\\nclass Solution:\\n    def findMaxSatisfaction(self, satisfaction: List[int], memo: List[List[int]], index: int, time: int) -> int:\\n        # Return 0 if we have iterated over all the dishes.\\n        if index == len(satisfaction):\\n            return 0\\n\\n        # We have already calculated the answer, so no need to go into recursion.\\n        if memo[index][time] != -1:\\n            return memo[index][time]\\n\\n        # Return the maximum of two choices:\\n        # 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n        cook = satisfaction[index] * time + self.findMaxSatisfaction(satisfaction, memo, index + 1, time + 1)\\n        # 2. Skip the current dish and move on to the next dish at the same time.\\n        skip = self.findMaxSatisfaction(satisfaction, memo, index + 1, time)\\n        memo[index][time] = max(cook, skip)\\n        return memo[index][time]\\n\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n\\n        memo = [[-1] * (len(satisfaction) + 1) for _ in range(len(satisfaction) + 1)]\\n\\n        # Mark all the states as -1, denoting not yet calculated.\\n        for i in range(len(satisfaction)):\\n            memo[i] = [-1] * (len(satisfaction) + 1)\\n\\n        return self.findMaxSatisfaction(satisfaction, memo, 0, 1)\\n```\\n\\n# DP BOTTOM UP\\n\\n```PYTHON []\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n\\n        # Mark all the states initially as 0.\\n        dp = [[0] * (len(satisfaction) + 2) for _ in range(len(satisfaction) + 1)]\\n\\n        for index in range(len(satisfaction) - 1, -1, -1):\\n            for time in range(1, len(satisfaction) + 1):\\n                # Maximum of two choices:\\n                # 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                # 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[index][time] = max(satisfaction[index] * time + dp[index + 1][time + 1], dp[index + 1][time])\\n\\n        return dp[0][1]\\n```\\n```JAVA []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        \\n        int[][] dp = new int[satisfaction.length + 1][satisfaction.length + 2];\\n        // Mark all the states initially as 0.\\n        for (int i = 0; i <= satisfaction.length; i++) {\\n            Arrays.fill(dp[i], 0);\\n        }\\n        \\n        for (int i = satisfaction.length - 1; i >= 0; i--) {\\n            for (int j = 1; j <= satisfaction.length; j++) {\\n                // Maximum of two choices:\\n                // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                // 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[i][j] = Math.max(satisfaction[i] * j + dp[i + 1][j + 1], dp[i + 1][j]);\\n            }\\n        }\\n        \\n        return dp[0][1];\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        \\n        // Mark all the states initially as 0.\\n        vector<vector<int>> dp(satisfaction.size() + 1, vector<int>(satisfaction.size() + 2, 0));\\n        for (int index = satisfaction.size() - 1; index >= 0; index--) {\\n            for (int time = 1; time <= satisfaction.size(); time++) {\\n                // Maximum of two choices:\\n                // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                // 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[index][time] = max(satisfaction[index] * time + dp[index + 1][time + 1], dp[index + 1][time]);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\n# DP (SPACE OPTIMIZED)\\n```PYTHON []\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n\\n        # Array to keep the result for the previous iteration.\\n        prev = [0] * (len(satisfaction) + 2)\\n\\n        for index in range(len(satisfaction) - 1, -1, -1):\\n            # Array to keep the result for the current iteration.\\n            dp = [0] * (len(satisfaction) + 2)\\n\\n            for time in range(1, len(satisfaction) + 1):\\n                # Maximum of two choices:\\n                # 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                # 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[time] = max(satisfaction[index] * time + prev[time + 1], prev[time])\\n\\n            # Assign the current iteration result to prev to be used in the next iteration.\\n            prev = dp\\n\\n        # dp and prev have the same value here, but dp is not defined at this scope.\\n        return prev[1]\\n```\\n```JAVA []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        \\n        // Array to keep the result for the previous iteration.\\n        int[] prev = new int[satisfaction.length + 2];\\n        Arrays.fill(prev, 0);\\n        \\n        for (int index = satisfaction.length - 1; index >= 0; index--) {\\n            // Array to keep the result for the current iteration.\\n            int[] dp = new int[satisfaction.length + 2];\\n            \\n            for (int time = 1; time <= satisfaction.length; time++) {\\n                // Maximum of two choices:\\n                // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                // 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[time] = Math.max(satisfaction[index] * time + prev[time + 1], prev[time]);\\n            }\\n            // Assign the current iteration result to prev to be used in the next iteration.\\n            prev = dp;\\n        }\\n        // dp and prev have the same value here, but dp is not defined at this scope.\\n        return prev[1];\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        \\n        // Array to keep the result for the previous iteration.\\n        vector<int> prev(satisfaction.size() + 2, 0);\\n        for (int index = satisfaction.size() - 1; index >= 0; index--) {\\n            // Array to keep the result for the current iteration.\\n            vector<int> dp(satisfaction.size() + 2);\\n            \\n            for (int time = 1; time <= satisfaction.size(); time++) {\\n                // Maximum of two choices:\\n                // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                // 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[time] = max(satisfaction[index] * time + prev[time + 1], prev[time]);\\n            }\\n            // Assign the current iteration result to prev to be used in the next iteration.\\n            prev = dp;\\n        }\\n        // dp and prev have the same value here, but dp is not defined at this scope.\\n        return prev[1];\\n    }\\n};\\n```\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d588f492-3f95-45f6-8e4a-10d6069002a5_1680054021.7117147.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```c++ []\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n    // Sort the satisfaction values in increasing order\\n    sort(satisfaction.begin(), satisfaction.end());\\n\\n    int totalSatisfaction = 0; // Total satisfaction value of the dishes on the menu list\\n    int maxTotalSatisfaction = 0; // Maximum total satisfaction value of the dishes cooked so far\\n    int numDishes = satisfaction.size(); // Number of dishes in the list\\n\\n    // Iterate over the sorted list of dishes in reverse order\\n    for (int i = numDishes - 1; i >= 0 && satisfaction[i] > -totalSatisfaction; --i) {\\n        // Add the satisfaction value of the current dish to the total satisfaction value of the dishes on the menu list\\n        totalSatisfaction += satisfaction[i];\\n\\n        // Add the updated total satisfaction value of the dishes on the menu list to the maximum total satisfaction value of the dishes cooked so far\\n        maxTotalSatisfaction += totalSatisfaction;\\n    }\\n\\n    // Return the maximum total satisfaction value of the dishes cooked so far\\n    return maxTotalSatisfaction;\\n}\\n```\n```java []\\npublic int maxSatisfaction(int[] satisfaction) {\\n    Arrays.sort(satisfaction);\\n\\n    int totalSatisfaction = 0;\\n    int maxTotalSatisfaction = 0;\\n    int numDishes = satisfaction.length;\\n\\n    for (int i = numDishes - 1; i >= 0 && satisfaction[i] > -totalSatisfaction; --i) {\\n        totalSatisfaction += satisfaction[i];\\n        maxTotalSatisfaction += totalSatisfaction;\\n    }\\n\\n    return maxTotalSatisfaction;\\n}\\n```\n```python []\\ndef maxSatisfaction(satisfaction: List[int]) -> int:\\n    satisfaction.sort()\\n\\n    total_satisfaction = 0\\n    max_total_satisfaction = 0\\n    num_dishes = len(satisfaction)\\n\\n    for i in range(num_dishes - 1, -1, -1):\\n        if satisfaction[i] > -total_satisfaction:\\n            total_satisfaction += satisfaction[i]\\n            max_total_satisfaction += total_satisfaction\\n        else:\\n            break\\n\\n    return max_total_satisfaction\\n```\n```python []\\ndef maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        return max([0]+list(accumulate(accumulate(sorted(satisfaction)[::-1]))))\\n```\n```java []\\npublic int maxSatisfaction(int[] satisfaction) {\\n    Arrays.sort(satisfaction);\\n    return Math.max(0, IntStream.range(0, satisfaction.length).map(i -> IntStream.range(i, satisfaction.length).map(j -> satisfaction[j] * (j - i + 1)).sum()).max().orElse(0));\\n}\\n```\n```c++ []\\nint maxSatisfaction(std::vector<int>& satisfaction) {\\n        std::sort(satisfaction.begin(), satisfaction.end());\\n        std::vector<int> cum_sum(satisfaction.size() + 1);\\n        std::partial_sum(satisfaction.rbegin(), satisfaction.rend(), cum_sum.rbegin() + 1);\\n        std::partial_sum(cum_sum.rbegin(), cum_sum.rend(), cum_sum.rbegin());\\n        return *std::max_element(cum_sum.begin(), cum_sum.end());\\n    }\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findMaxSatisfaction(vector<int>& satisfaction, vector<vector<int>>& memo, int index, int time) {\\n        // Return 0 if we have iterated over all the dishes.\\n        if (index == satisfaction.size()) {\\n            return 0;\\n        }\\n\\n        // We have already calculated the answer, so no need to go into recursion.\\n        if (memo[index][time] != -1) {\\n            return memo[index][time];\\n        }\\n\\n        // Return the maximum of two choices:\\n        // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n        int cook = satisfaction[index] * time + findMaxSatisfaction(satisfaction, memo, index + 1, time + 1);\\n        // 2. Skip the current dish and move on to the next dish at the same time.\\n        int skip =findMaxSatisfaction(satisfaction, memo, index + 1, time);\\n        return memo[index][time] = max(cook,\\n                                        skip);\\n    }\\n\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n\\n        vector<vector<int>> memo(satisfaction.size() + 1, vector<int>(satisfaction.size() + 1, -1));\\n\\n        // Mark all the states as -1, denoting not yet calculated.\\n        for (int i = 0; i < satisfaction.size(); i++) {\\n            fill(memo[i].begin(), memo[i].end(), -1);\\n        }\\n\\n        return findMaxSatisfaction(satisfaction, memo, 0, 1);\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public int findMaxSatisfaction(int[] satisfaction, int[][] memo, int index, int time) {\\n        // Return 0 if we have iterated over all the dishes.\\n        if (index == satisfaction.length) {\\n            return 0;\\n        }\\n\\n        // We have already calculated the answer, so no need to go into recursion.\\n        if (memo[index][time] != -1) {\\n            return memo[index][time];\\n        }\\n\\n        // Return the maximum of two choices:\\n        // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n        int cook = satisfaction[index] * time + findMaxSatisfaction(satisfaction, memo, index + 1, time + 1);\\n        // 2. Skip the current dish and move on to the next dish at the same time.\\n        int skip = findMaxSatisfaction(satisfaction, memo, index + 1, time);\\n        return memo[index][time] = Math.max(cook, skip);\\n    }\\n\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n\\n        int[][] memo = new int[satisfaction.length + 1][satisfaction.length + 1];\\n\\n        // Mark all the states as -1, denoting not yet calculated.\\n        for (int i = 0; i < satisfaction.length; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n\\n        return findMaxSatisfaction(satisfaction, memo, 0, 1);\\n    }\\n}\\n```\n```PYTHON []\\nclass Solution:\\n    def findMaxSatisfaction(self, satisfaction: List[int], memo: List[List[int]], index: int, time: int) -> int:\\n        # Return 0 if we have iterated over all the dishes.\\n        if index == len(satisfaction):\\n            return 0\\n\\n        # We have already calculated the answer, so no need to go into recursion.\\n        if memo[index][time] != -1:\\n            return memo[index][time]\\n\\n        # Return the maximum of two choices:\\n        # 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n        cook = satisfaction[index] * time + self.findMaxSatisfaction(satisfaction, memo, index + 1, time + 1)\\n        # 2. Skip the current dish and move on to the next dish at the same time.\\n        skip = self.findMaxSatisfaction(satisfaction, memo, index + 1, time)\\n        memo[index][time] = max(cook, skip)\\n        return memo[index][time]\\n\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n\\n        memo = [[-1] * (len(satisfaction) + 1) for _ in range(len(satisfaction) + 1)]\\n\\n        # Mark all the states as -1, denoting not yet calculated.\\n        for i in range(len(satisfaction)):\\n            memo[i] = [-1] * (len(satisfaction) + 1)\\n\\n        return self.findMaxSatisfaction(satisfaction, memo, 0, 1)\\n```\n```PYTHON []\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n\\n        # Mark all the states initially as 0.\\n        dp = [[0] * (len(satisfaction) + 2) for _ in range(len(satisfaction) + 1)]\\n\\n        for index in range(len(satisfaction) - 1, -1, -1):\\n            for time in range(1, len(satisfaction) + 1):\\n                # Maximum of two choices:\\n                # 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                # 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[index][time] = max(satisfaction[index] * time + dp[index + 1][time + 1], dp[index + 1][time])\\n\\n        return dp[0][1]\\n```\n```JAVA []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        \\n        int[][] dp = new int[satisfaction.length + 1][satisfaction.length + 2];\\n        // Mark all the states initially as 0.\\n        for (int i = 0; i <= satisfaction.length; i++) {\\n            Arrays.fill(dp[i], 0);\\n        }\\n        \\n        for (int i = satisfaction.length - 1; i >= 0; i--) {\\n            for (int j = 1; j <= satisfaction.length; j++) {\\n                // Maximum of two choices:\\n                // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                // 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[i][j] = Math.max(satisfaction[i] * j + dp[i + 1][j + 1], dp[i + 1][j]);\\n            }\\n        }\\n        \\n        return dp[0][1];\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        \\n        // Mark all the states initially as 0.\\n        vector<vector<int>> dp(satisfaction.size() + 1, vector<int>(satisfaction.size() + 2, 0));\\n        for (int index = satisfaction.size() - 1; index >= 0; index--) {\\n            for (int time = 1; time <= satisfaction.size(); time++) {\\n                // Maximum of two choices:\\n                // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                // 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[index][time] = max(satisfaction[index] * time + dp[index + 1][time + 1], dp[index + 1][time]);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```PYTHON []\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n\\n        # Array to keep the result for the previous iteration.\\n        prev = [0] * (len(satisfaction) + 2)\\n\\n        for index in range(len(satisfaction) - 1, -1, -1):\\n            # Array to keep the result for the current iteration.\\n            dp = [0] * (len(satisfaction) + 2)\\n\\n            for time in range(1, len(satisfaction) + 1):\\n                # Maximum of two choices:\\n                # 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                # 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[time] = max(satisfaction[index] * time + prev[time + 1], prev[time])\\n\\n            # Assign the current iteration result to prev to be used in the next iteration.\\n            prev = dp\\n\\n        # dp and prev have the same value here, but dp is not defined at this scope.\\n        return prev[1]\\n```\n```JAVA []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        \\n        // Array to keep the result for the previous iteration.\\n        int[] prev = new int[satisfaction.length + 2];\\n        Arrays.fill(prev, 0);\\n        \\n        for (int index = satisfaction.length - 1; index >= 0; index--) {\\n            // Array to keep the result for the current iteration.\\n            int[] dp = new int[satisfaction.length + 2];\\n            \\n            for (int time = 1; time <= satisfaction.length; time++) {\\n                // Maximum of two choices:\\n                // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                // 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[time] = Math.max(satisfaction[index] * time + prev[time + 1], prev[time]);\\n            }\\n            // Assign the current iteration result to prev to be used in the next iteration.\\n            prev = dp;\\n        }\\n        // dp and prev have the same value here, but dp is not defined at this scope.\\n        return prev[1];\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        \\n        // Array to keep the result for the previous iteration.\\n        vector<int> prev(satisfaction.size() + 2, 0);\\n        for (int index = satisfaction.size() - 1; index >= 0; index--) {\\n            // Array to keep the result for the current iteration.\\n            vector<int> dp(satisfaction.size() + 2);\\n            \\n            for (int time = 1; time <= satisfaction.size(); time++) {\\n                // Maximum of two choices:\\n                // 1. Cook the dish at `index` with the time taken as `time` and move on to the next dish with time as time + 1.\\n                // 2. Skip the current dish and move on to the next dish at the same time.\\n                dp[time] = max(satisfaction[index] * time + prev[time + 1], prev[time]);\\n            }\\n            // Assign the current iteration result to prev to be used in the next iteration.\\n            prev = dp;\\n        }\\n        // dp and prev have the same value here, but dp is not defined at this scope.\\n        return prev[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354091,
                "title": "3-diffrent-way-recurtion-memoization-sort-prefix-sum-c-tle-to-90-beat",
                "content": "\\n# Recursive\\n\\n# Intuition\\nThe position of element doesnot matter we can sort it\\nwe are simply going to perform taking that element in our final array or not\\n\\n# Approach\\nIf element is taken Add their value and increase the size of our final array\\nOtherwise just move to next element without taking\\n\\nBASE CONDITION:\\nif index get out of range of array return 0 , can\\'t get any value.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nO(N) stack space\\n```\\n  int fun(vector<int> &sat , int i , int c ){\\n      if(i==sat.size()) return 0;\\n      return max(fun(sat,i+1,c) , sat[i]*(c) + fun(sat,i+1,c+1));\\n  }\\n\\n  int maxSatisfaction(vector<int>& sat) {\\n      sort(sat.begin() , sat.end()); \\n      int n = sat.size();\\n      return fun(sat , 0,1);\\n  }\\n```\\n# Memoization\\nRead recursive intition and approch....\\nsince in a single call of our recursive fuction there are two parameter are changing so our DP matrix will be of 2D.\\n\\n# Approach\\nStore each value in DP matrix and return if value already exixt.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N) stack space\\n\\n```\\n  int fun(vector<int> &sat , int i , int c , vector<vector<int>> &dp ){\\n      if(i==sat.size()) return 0;\\n      if(dp[i][c] != -1) return dp[i][c];\\n      return dp[i][c] = max(fun(sat,i+1,c , dp) , sat[i]*(c) + fun(sat,i+1,c+1,dp));\\n  }\\n\\n  int maxSatisfaction(vector<int>& sat) {\\n      sort(sat.begin() , sat.end()); \\n      int n = sat.size();\\n      vector<vector<int>> dp(n , vector<int>(n+1,-1));\\n      return fun(sat , 0,1 , dp);\\n  }\\n```\\n# SORT + PRESUM\\nThis is diffrent aprroch ... \\n# Approach\\nWe need to understand the basic concept that if an exra element is taken before the existing array, then the value of answer will increase by the value of element + sum of existing answer. The following example demonstrates this:\\n1 getting added before existing array means that new value = old value + sum of elements\\n\\nConsider the example`[-1,-8,0,5,-9]` Since we want to maximize the satisfaction, therefore we would want largest number (5) to have the largest coefficient(served late) and smallest number (-9) to have the smallest coefficient (served first or not at all ). So lets start with sorting the array\\n`\\n[-1,-8,0,5,9] --> [5,0,-1,-8,-9].\\n`\\n\\nThe prefix sum of the sorted array gets us the following:\\n```\\n[5, --> [5,\\n 0, -->  5 + 0,\\n-1,-->   5 + 0 + (-1),\\n-8,-->   5 + 0 + (-1) + (-8),\\n-9] -->  5 + 0 + (-1) + (-8) + (-9)]\\n```\\nTaking another prefix sum we get the following:\\n```\\n [5,                      ----> [ 5,                            = [ 5\\n 5+0,                     ----> {5} + (5 + 0),                  =   2*5 + 1*0, \\n 5+0+(-1),                ----> {5 + (5 + 0)} + 5 + 0 +(-1)     =   3*5 + 2*0 + 1*(-1),\\n 5+0 + (-1) +(-8),        ----> .....                           =   4*5 + 3*0 + 2*(-1) + 1*(-8), \\n 5+0 + (-1) +(-8) + (-9)] -----> .....]                         = ....]\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(Nlog(N))\\n\\n- Space complexity:\\nO(N)\\n\\n```\\n    int maxSatisfaction(vector<int>& sat) {\\n        sort(sat.begin(),sat.end());     // sort no matter the place of elements\\n        reverse(sat.begin(), sat.end()); // make it to non increasing \\n        int n=sat.size();\\n        vector<int>sum;\\n        sum = sat;                      // we need a vector for storing prefix sum\\n        for(int i=1;i<n;i++){\\n            sum[i]+=sum[i-1];              // storing prefix sum in sum array\\n        }\\n        int mx=0,cs=0;              // intislise maximum possible sum and current possible sum\\n        for(int i=0;i<n;i++){\\n            cs+=sum[i];             // storing in current sum \\n            mx=max(cs,mx);             // comparing \\n        }\\n        return mx;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\n  int fun(vector<int> &sat , int i , int c ){\\n      if(i==sat.size()) return 0;\\n      return max(fun(sat,i+1,c) , sat[i]*(c) + fun(sat,i+1,c+1));\\n  }\\n\\n  int maxSatisfaction(vector<int>& sat) {\\n      sort(sat.begin() , sat.end()); \\n      int n = sat.size();\\n      return fun(sat , 0,1);\\n  }\\n```\n```\\n  int fun(vector<int> &sat , int i , int c , vector<vector<int>> &dp ){\\n      if(i==sat.size()) return 0;\\n      if(dp[i][c] != -1) return dp[i][c];\\n      return dp[i][c] = max(fun(sat,i+1,c , dp) , sat[i]*(c) + fun(sat,i+1,c+1,dp));\\n  }\\n\\n  int maxSatisfaction(vector<int>& sat) {\\n      sort(sat.begin() , sat.end()); \\n      int n = sat.size();\\n      vector<vector<int>> dp(n , vector<int>(n+1,-1));\\n      return fun(sat , 0,1 , dp);\\n  }\\n```\n```\\n[5, --> [5,\\n 0, -->  5 + 0,\\n-1,-->   5 + 0 + (-1),\\n-8,-->   5 + 0 + (-1) + (-8),\\n-9] -->  5 + 0 + (-1) + (-8) + (-9)]\\n```\n```\\n [5,                      ----> [ 5,                            = [ 5\\n 5+0,                     ----> {5} + (5 + 0),                  =   2*5 + 1*0, \\n 5+0+(-1),                ----> {5 + (5 + 0)} + 5 + 0 +(-1)     =   3*5 + 2*0 + 1*(-1),\\n 5+0 + (-1) +(-8),        ----> .....                           =   4*5 + 3*0 + 2*(-1) + 1*(-8), \\n 5+0 + (-1) +(-8) + (-9)] -----> .....]                         = ....]\\n```\n```\\n    int maxSatisfaction(vector<int>& sat) {\\n        sort(sat.begin(),sat.end());     // sort no matter the place of elements\\n        reverse(sat.begin(), sat.end()); // make it to non increasing \\n        int n=sat.size();\\n        vector<int>sum;\\n        sum = sat;                      // we need a vector for storing prefix sum\\n        for(int i=1;i<n;i++){\\n            sum[i]+=sum[i-1];              // storing prefix sum in sum array\\n        }\\n        int mx=0,cs=0;              // intislise maximum possible sum and current possible sum\\n        for(int i=0;i<n;i++){\\n            cs+=sum[i];             // storing in current sum \\n            mx=max(cs,mx);             // comparing \\n        }\\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3354463,
                "title": "easy-solution-with-detailed-comments",
                "content": "# JavaScript Code\\n```\\nvar maxSatisfaction = function (satisfactions) {\\n  // Sort the satisfactions array in descending order, \\n  // so that we process the highest satisfaction dishes first.\\n  satisfactions.sort((a, b) => b - a);\\n\\n  // Initialize two variables to 0. \\'max\\' holds \\n  // the maximum satisfaction score we can obtain, \\n  // and \\'sum\\' holds the sum of the satisfaction scores of \\n  // the dishes we have processed so far.\\n  let max = 0;\\n  let sum = 0;\\n\\n  // Loop through the satisfactions array.\\n  for (const satisfaction of satisfactions) {\\n    // Add the satisfaction score of the current dish to the \\'sum\\' variable.\\n    sum += satisfaction;\\n\\n    // If the \\'sum\\' variable becomes negative or zero, \\n    // it means that the current dish and all the previous dishes \\n    // cannot contribute to a positive satisfaction score, \\n    // so we break out of the loop.\\n    if (sum <= 0) break;\\n\\n    // If the \\'sum\\' variable is positive, it means that \\n    // the current dish and the previous dishes can contribute \\n    // to a positive satisfaction score, so we update \\'max\\' by \\n    // adding the current value of \\'sum\\' to it.\\n    max += sum;\\n  }\\n\\n  // After the loop finishes, the final value of \\'max\\' \\n  // represents the maximum satisfaction score we can obtain \\n  // from the given \\'satisfactions\\' array.\\n  return max;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nvar maxSatisfaction = function (satisfactions) {\\n  // Sort the satisfactions array in descending order, \\n  // so that we process the highest satisfaction dishes first.\\n  satisfactions.sort((a, b) => b - a);\\n\\n  // Initialize two variables to 0. \\'max\\' holds \\n  // the maximum satisfaction score we can obtain, \\n  // and \\'sum\\' holds the sum of the satisfaction scores of \\n  // the dishes we have processed so far.\\n  let max = 0;\\n  let sum = 0;\\n\\n  // Loop through the satisfactions array.\\n  for (const satisfaction of satisfactions) {\\n    // Add the satisfaction score of the current dish to the \\'sum\\' variable.\\n    sum += satisfaction;\\n\\n    // If the \\'sum\\' variable becomes negative or zero, \\n    // it means that the current dish and all the previous dishes \\n    // cannot contribute to a positive satisfaction score, \\n    // so we break out of the loop.\\n    if (sum <= 0) break;\\n\\n    // If the \\'sum\\' variable is positive, it means that \\n    // the current dish and the previous dishes can contribute \\n    // to a positive satisfaction score, so we update \\'max\\' by \\n    // adding the current value of \\'sum\\' to it.\\n    max += sum;\\n  }\\n\\n  // After the loop finishes, the final value of \\'max\\' \\n  // represents the maximum satisfaction score we can obtain \\n  // from the given \\'satisfactions\\' array.\\n  return max;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3353617,
                "title": "java-python-and-c-easy-solutions-with-exaplanation-look-at-once",
                "content": "# Intuition\\nThe like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level. Therefore, the chef would want to cook the most satisfying dishes first and minimize the time taken to cook them. Additionally, since the chef can discard some dishes to maximize the total like-time coefficient, we can discard dishes with negative satisfaction levels to avoid decreasing the overall satisfaction.\\n\\n# Approach\\nThe first step is to sort the array A in ascending order, so that we consider the most satisfying dishes first.\\n\\nThen, we initialize res to 0, which will store the maximum sum of like-time coefficients, and total to 0, which will store the sum of satisfactions for the dishes we have chosen so far.\\n\\nNext, we iterate over the sorted array A in reverse order, starting from the last element (i.e., the least satisfying dish). We stop iterating if we reach the beginning of the array or if the satisfaction level of the current dish is negative and would result in a negative total satisfaction.\\n\\nFor each dish, we add its satisfaction level to the total satisfaction, and update res by adding the product of the time taken to cook the dish (which is the position of the dish in the sorted array, starting from 1) and its satisfaction level.\\n\\nFinally, we return res, which contains the maximum sum of like-time coefficients that the chef can obtain after preparing some dishes (in any order).\\n\\nOverall, this code uses a greedy approach to solve the problem, by choosing the most satisfying dishes first and discarding dishes with negative satisfaction levels.\\n\\n\\n# Complexity\\n- Time complexity:\\n\\nThe time complexity of this approach is $$O(nlogn)$$, where n is the number of dishes, due to the sorting operation. The iteration over the sorted array takes $$O(n)$$ time. Therefore, the overall time complexity is dominated by the sorting operation.\\n\\n- Space complexity:  \\n\\nThe space complexity of this approach is $$O(1)$$, since we only use constant extra space to store some variables `(res, total, and n)`. Therefore, the space complexity is independent of the input size.\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int res = 0, total = 0, n = satisfaction.length;\\n        for (int i = n - 1; i >= 0 && satisfaction[i] > -total; --i) {\\n            total += satisfaction[i];\\n            res += total;\\n        }\\n        return res;\\n    \\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n        int maxSatisfaction(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, total = 0, n = A.size();\\n        for (int i = n - 1; i >= 0 && A[i] > -total; --i) {\\n            total += A[i];\\n            res += total;\\n        }\\n        return res;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution(object):\\n    def maxSatisfaction(self, satisfaction):\\n        \"\"\"\\n        :type satisfaction: List[int]\\n        :rtype: int\\n        \"\"\"    \\n        res = total = 0\\n        satisfaction.sort()\\n        while satisfaction and satisfaction[-1] + total > 0:\\n            total += satisfaction.pop()\\n            res += total\\n        return res\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int res = 0, total = 0, n = satisfaction.length;\\n        for (int i = n - 1; i >= 0 && satisfaction[i] > -total; --i) {\\n            total += satisfaction[i];\\n            res += total;\\n        }\\n        return res;\\n    \\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n        int maxSatisfaction(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, total = 0, n = A.size();\\n        for (int i = n - 1; i >= 0 && A[i] > -total; --i) {\\n            total += A[i];\\n            res += total;\\n        }\\n        return res;\\n    }\\n};\\n```\n``` Python []\\nclass Solution(object):\\n    def maxSatisfaction(self, satisfaction):\\n        \"\"\"\\n        :type satisfaction: List[int]\\n        :rtype: int\\n        \"\"\"    \\n        res = total = 0\\n        satisfaction.sort()\\n        while satisfaction and satisfaction[-1] + total > 0:\\n            total += satisfaction.pop()\\n            res += total\\n        return res\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355402,
                "title": "greedy-solution-anyone-can-understand",
                "content": "# Intuition\\nFor maximizing the coefficient we need to give the most time to cook the most satisfied dish.\\n\\n# Approach\\nKeep cooking the dishes until you find one worst dish that make all of our dishes absolute worst.\\nAdded Comments in code to help you understand better.\\n\\n# Complexity\\n- Time complexity:\\n $$O(NlogN)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        // Sorting for identifying which is most satisfied dish.\\n        sort(satisfaction.begin(),satisfaction.end());\\n        // We will keep cooking all most satisfied dishes until \\n        // we find a dish that is so worst that it will make all of our\\n        // total satisfaction of dishes cooked till now negative \\n        // i.e worst satisfaction will be achieved if we took that dish so break out.\\n        int result=0,total=0;\\n        for(int dish=n-1;dish>=0;--dish){\\n            if(satisfaction[dish]+total<0){\\n                // Worst dish encountered.\\n                break;\\n            }else{\\n                total+=satisfaction[dish];\\n                result+=total;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        // Sorting for identifying which is most satisfied dish.\\n        sort(satisfaction.begin(),satisfaction.end());\\n        // We will keep cooking all most satisfied dishes until \\n        // we find a dish that is so worst that it will make all of our\\n        // total satisfaction of dishes cooked till now negative \\n        // i.e worst satisfaction will be achieved if we took that dish so break out.\\n        int result=0,total=0;\\n        for(int dish=n-1;dish>=0;--dish){\\n            if(satisfaction[dish]+total<0){\\n                // Worst dish encountered.\\n                break;\\n            }else{\\n                total+=satisfaction[dish];\\n                result+=total;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354845,
                "title": "4-best-java-approaches-recursion-memorization-tabulation-most-optimized",
                "content": "# Please Upvote if you like these approaches\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to knapsack\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursion\\n\\n# Complexity\\n- Time complexity: O(2^n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int maxSatisfaction(int[] satisfaction) {\\n         Arrays.sort(satisfaction);\\n         return maxSatisfactionRec(satisfaction, 0, 0);\\n     }\\n\\n     private int maxSatisfactionRec(int [] satisfaction, int index, int time){\\n         if(index == satisfaction.length)\\n             return 0;\\n        \\n         int includeDish = (satisfaction[index] * (time + 1)) + maxSatisfactionRec(satisfaction, index + 1, time + 1);\\n         int excludeDish = maxSatisfactionRec(satisfaction, index + 1, time);\\n\\n         return Math.max(includeDish, excludeDish);\\n     }\\n}\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to knapsack\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMemorization\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\n     public int maxSatisfaction(int[] satisfaction) {\\n         Arrays.sort(satisfaction);\\n         int n = satisfaction.length;\\n         int [][] dp = new int[n + 1][n + 1];\\n         for(int [] a : dp){\\n             Arrays.fill(a, -1);\\n         }\\n\\n         return maxSatisfactionMemo(satisfaction, 0, 0, dp);\\n     }\\n\\n     private int maxSatisfactionMemo(int [] satisfaction, int index, int time, int [][] dp){\\n         if(index == satisfaction.length)\\n             return 0;\\n        \\n         if(dp[index][time] != -1)\\n             return dp[index][time];\\n        \\n         int includeDish = (satisfaction[index] * (time + 1)) + maxSatisfactionMemo(satisfaction, index + 1, time + 1, dp);\\n         int excludeDish = maxSatisfactionMemo(satisfaction, index + 1, time, dp);\\n\\n         return dp[index][time] = Math.max(includeDish, excludeDish);\\n     }\\n}\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to knapsack\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTabulation\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\n     public int maxSatisfaction(int[] satisfaction) {\\n         Arrays.sort(satisfaction);\\n         int n = satisfaction.length;\\n         int [][] dp = new int[n + 1][n + 1];\\n        \\n         return maxSatisfactionTab(satisfaction, 0, 0, dp);\\n     }\\n\\n     private int maxSatisfactionTab(int [] satisfaction, int index, int time, int [][] dp){\\n         for(index = satisfaction.length; index >= 0; index--){\\n             for(time = index; time >=0; time--){\\n                 if(index == satisfaction.length)\\n                     continue;\\n            \\n                 int includeDish = (satisfaction[index] * (time + 1)) + dp[index + 1][time + 1];\\n                 int excludeDish = dp[index + 1][time];\\n\\n                 dp[index][time] = Math.max(includeDish, excludeDish);\\n             }\\n         }\\n        \\n         return dp[0][0];\\n     }\\n}\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSorting and Prefix Sum\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix Sum\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn) for sorting\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int prefix = 0, currAns = 0, result = 0;\\n\\n        for(int i = satisfaction.length - 1; i>= 0; i--){\\n            prefix += satisfaction[i];\\n            currAns += prefix;\\n            result = Math.max(result, currAns);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n     public int maxSatisfaction(int[] satisfaction) {\\n         Arrays.sort(satisfaction);\\n         return maxSatisfactionRec(satisfaction, 0, 0);\\n     }\\n\\n     private int maxSatisfactionRec(int [] satisfaction, int index, int time){\\n         if(index == satisfaction.length)\\n             return 0;\\n        \\n         int includeDish = (satisfaction[index] * (time + 1)) + maxSatisfactionRec(satisfaction, index + 1, time + 1);\\n         int excludeDish = maxSatisfactionRec(satisfaction, index + 1, time);\\n\\n         return Math.max(includeDish, excludeDish);\\n     }\\n}\\n```\n```\\nclass Solution {\\n     public int maxSatisfaction(int[] satisfaction) {\\n         Arrays.sort(satisfaction);\\n         int n = satisfaction.length;\\n         int [][] dp = new int[n + 1][n + 1];\\n         for(int [] a : dp){\\n             Arrays.fill(a, -1);\\n         }\\n\\n         return maxSatisfactionMemo(satisfaction, 0, 0, dp);\\n     }\\n\\n     private int maxSatisfactionMemo(int [] satisfaction, int index, int time, int [][] dp){\\n         if(index == satisfaction.length)\\n             return 0;\\n        \\n         if(dp[index][time] != -1)\\n             return dp[index][time];\\n        \\n         int includeDish = (satisfaction[index] * (time + 1)) + maxSatisfactionMemo(satisfaction, index + 1, time + 1, dp);\\n         int excludeDish = maxSatisfactionMemo(satisfaction, index + 1, time, dp);\\n\\n         return dp[index][time] = Math.max(includeDish, excludeDish);\\n     }\\n}\\n```\n```\\nclass Solution {\\n     public int maxSatisfaction(int[] satisfaction) {\\n         Arrays.sort(satisfaction);\\n         int n = satisfaction.length;\\n         int [][] dp = new int[n + 1][n + 1];\\n        \\n         return maxSatisfactionTab(satisfaction, 0, 0, dp);\\n     }\\n\\n     private int maxSatisfactionTab(int [] satisfaction, int index, int time, int [][] dp){\\n         for(index = satisfaction.length; index >= 0; index--){\\n             for(time = index; time >=0; time--){\\n                 if(index == satisfaction.length)\\n                     continue;\\n            \\n                 int includeDish = (satisfaction[index] * (time + 1)) + dp[index + 1][time + 1];\\n                 int excludeDish = dp[index + 1][time];\\n\\n                 dp[index][time] = Math.max(includeDish, excludeDish);\\n             }\\n         }\\n        \\n         return dp[0][0];\\n     }\\n}\\n```\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int prefix = 0, currAns = 0, result = 0;\\n\\n        for(int i = satisfaction.length - 1; i>= 0; i--){\\n            prefix += satisfaction[i];\\n            currAns += prefix;\\n            result = Math.max(result, currAns);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354057,
                "title": "day-88-greedy-o-nlogn-time-and-o-1-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThe main idea behind this code is to use a greedy approach to maximize the sum of the like-time coefficients for the given dishes.\\n\\nWe start by sorting the satisfaction array in ascending order. This is because the satisfaction value for a dish multiplied by its cooking time will always be maximized if we cook the dish with the least satisfaction value first, followed by the dish with the next least satisfaction value, and so on. This way, the total cooking time for each dish increases gradually, resulting in higher like-time coefficients.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Sort the given satisfaction array in ascending order.\\n2. Initialize ans to 0 and preSum to 0.\\n3. Traverse the satisfaction array from right to left:\\n    - a. If the preSum + satisfaction[i] is less than or equal to 0, break the loop.\\n    - b. Add the current element to preSum.\\n    - c. Add preSum to the timeCoefficient using the formula i*preSum, where i is the index of the current element (0-based).\\n    - d. Update ans to be the maximum of ans and timeCoefficient.\\n1. Return ans as the maximum sum of like-time coefficients.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size(), ans = 0, preSum = 0, timeCoefficient = 0;\\n        for (int i = n-1; i >= 0; i--) {\\n            if (preSum + satisfaction[i] <= 0) {\\n                break;\\n            }\\n            preSum += satisfaction[i];\\n            timeCoefficient += preSum;\\n            ans = max(ans, timeCoefficient);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int n = satisfaction.length, ans = 0, preSum = 0, timeCoefficient = 0;\\n        for (int i = n-1; i >= 0; i--) {\\n            if (preSum + satisfaction[i] <= 0) {\\n                break;\\n            }\\n            preSum += satisfaction[i];\\n            timeCoefficient += preSum;\\n            ans = Math.max(ans, timeCoefficient);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n        n = len(satisfaction)\\n        ans, preSum, timeCoefficient = 0, 0, 0\\n        for i in range(n-1, -1, -1):\\n            if preSum + satisfaction[i] <= 0:\\n                break\\n            preSum += satisfaction[i]\\n            timeCoefficient += preSum\\n            ans = max(ans, timeCoefficient)\\n        return ans\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O(nlogn)**, where n is the size of the input array. The main reason for this time complexity is the sorting operation that takes O(nlogn) time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(1)**, as we are not using any extra space apart from the input array and a few constant variables used for bookkeeping.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size(), ans = 0, preSum = 0, timeCoefficient = 0;\\n        for (int i = n-1; i >= 0; i--) {\\n            if (preSum + satisfaction[i] <= 0) {\\n                break;\\n            }\\n            preSum += satisfaction[i];\\n            timeCoefficient += preSum;\\n            ans = max(ans, timeCoefficient);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int n = satisfaction.length, ans = 0, preSum = 0, timeCoefficient = 0;\\n        for (int i = n-1; i >= 0; i--) {\\n            if (preSum + satisfaction[i] <= 0) {\\n                break;\\n            }\\n            preSum += satisfaction[i];\\n            timeCoefficient += preSum;\\n            ans = Math.max(ans, timeCoefficient);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n        n = len(satisfaction)\\n        ans, preSum, timeCoefficient = 0, 0, 0\\n        for i in range(n-1, -1, -1):\\n            if preSum + satisfaction[i] <= 0:\\n                break\\n            preSum += satisfaction[i]\\n            timeCoefficient += preSum\\n            ans = max(ans, timeCoefficient)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197819,
                "title": "clean-code-easy-to-understand-suffix-sum-array-c",
                "content": "\\n    int maxSatisfaction(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        int n = s.size(),sum=0;\\n        for(int i=n-1;i>0;i--)\\n            s[i-1]+=s[i];\\n        int i=0;\\n        while(i<n){\\n            if(s[i]>=0) sum+=s[i];\\n            i++;\\n        }\\n        return sum;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    int maxSatisfaction(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        int n = s.size(),sum=0;\\n        for(int i=n-1;i>0;i--)\\n            s[i-1]+=s[i];\\n        int i=0;\\n        while(i<n){\\n            if(s[i]>=0) sum+=s[i];\\n            i++;\\n        }\\n        return sum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 679171,
                "title": "java-simple-greedy",
                "content": "1, easy to think as you need to put higher satisfaction dish later\\n2, for the first dish, after you removed the dish, overral score will be decreased\\nss[0] + ss[1] + .. + ss[n - 1] = sum of array.\\ncheck and repeat while sum is negative;\\n```\\npublic int maxSatisfaction(int[] ss) {\\n        Arrays.sort(ss);\\n        int sum = 0, n = ss.length, res = 0, j = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += ss[i];\\n            res += ss[i] * (i + 1);\\n        }\\n        \\n        while (sum < 0) {\\n            res -= sum;\\n            sum -= ss[j++];\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxSatisfaction(int[] ss) {\\n        Arrays.sort(ss);\\n        int sum = 0, n = ss.length, res = 0, j = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += ss[i];\\n            res += ss[i] * (i + 1);\\n        }\\n        \\n        while (sum < 0) {\\n            res -= sum;\\n            sum -= ss[j++];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563332,
                "title": "python-o-n-log-n",
                "content": "Answer must be of the form `k * arr[0] + (k - 1) * arr[1] + ...` where `arr` is sorted decreasingly.\\n\\n```\\nclass Solution(object):\\n    def maxSatisfaction(self, arr):\\n        arr.sort(reverse=True)\\n        ans = cur = s = 0\\n        for x in arr:\\n            s += x\\n            cur += s\\n            ans = max(ans, cur)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSatisfaction(self, arr):\\n        arr.sort(reverse=True)\\n        ans = cur = s = 0\\n        for x in arr:\\n            s += x\\n            cur += s\\n            ans = max(ans, cur)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353667,
                "title": "c-just-sort-and-find-start-shouldn-t-be-hard",
                "content": "# Intuition\\n-> sort as to take the maximum satisfaction at the end whole time \\n-> just to find from where we have to start the time \\n-> firstly check for whole array\\n-> let i is starting point and from j=i take sum of Like-time coefficient \\n-> just to compare the till maximum sum and temp sum that start from i\\n# Approach\\nSorting + two for loop and maintain max sum\\n\\n# Complexity\\n- Time complexity:\\n  O(NlogN) +O(N^2) => O(N^2)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& s) \\n    {\\n        int n=s.size();\\n        // sort to take maximum satisfaction at the end whole time \\n        sort(s.begin(),s.end());\\n        // just to find from where we have to start the time \\n        int sum=0,temp=0,cnt=0;\\n        //check for whole array\\n        for(auto e:s)\\n        {\\n            temp+=e*(cnt++);\\n        }\\n        \\n        sum=max(sum,temp);\\n        // let i is starting point and from j=i take sum of Like-time coefficient \\n        for(int i=0;i<n;i++)\\n        {\\n            cnt=1;\\n            temp=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                temp+=(s[j])*(cnt++);\\n            }\\n            // just to compare the till maximum sum and temp sum start from i\\n            sum=max(sum,temp);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& s) \\n    {\\n        int n=s.size();\\n        // sort to take maximum satisfaction at the end whole time \\n        sort(s.begin(),s.end());\\n        // just to find from where we have to start the time \\n        int sum=0,temp=0,cnt=0;\\n        //check for whole array\\n        for(auto e:s)\\n        {\\n            temp+=e*(cnt++);\\n        }\\n        \\n        sum=max(sum,temp);\\n        // let i is starting point and from j=i take sum of Like-time coefficient \\n        for(int i=0;i<n;i++)\\n        {\\n            cnt=1;\\n            temp=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                temp+=(s[j])*(cnt++);\\n            }\\n            // just to compare the till maximum sum and temp sum start from i\\n            sum=max(sum,temp);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353602,
                "title": "c-solution-beats-100",
                "content": "# Approach\\nTo maximize the total like-time coefficient, we need to prioritize dishes with positive satisfaction values. Therefore, we first sort the array in ascending order, allowing us to assign larger coefficients to dishes with higher satisfaction values. Next, we add negative satisfaction values from largest to smallest, stopping when the total like-time coefficient begins to decrease.\\n\\nTo calculate the total like-time coefficient, we need two variables:\\n\\ntotal_satisfaction: used to store the answer\\nsum: the sum of the array elements added to total_satisfaction\\nTo calculate the total like-time coefficient, we can simply add the sum in each loop iteration.\\n```\\n    sum += satisfaction[i];\\n    total_satisfaction += sum;\\n``` \\nAs we increase the coefficient, we need to add each previously used element in the total like-time coefficient one more time. Essentially, we are adding the sum of the elements already used in the total like-time coefficient, so we use a variable to track this sum and avoid recalculating it each time.\\n\\nLet\\'s look at an example with a sorted array:\\n[-9,-8,-1,0,5] already sorted\\n\\nWe going from largest element to smallest:\\n1) total_satisfaction = 1 * 5 = 5     \\nsum of all elements is 5 = 1 * 5\\n2) total_satisfaction = total_satisfaction + 1*0 + 5 = 10\\nsum of all elements is 5 = 1 * 0 + 5\\n3) total_satisfaction = total_satisfaction + 1 * (-1) + 0 + 5 = 14\\nsum of all elements is 4 = 1 * (-1) + 0 + 5\\n4) total_satisfaction = total_satisfaction + 1 * (-8) + (-1) + 0 + 5 = 10\\nsum of all elements is -4 = 1 * (-8) + (-1) + 0 + 5\\n\\nSo because 4 step less than 3 step we stop and answer is 14.\\n```\\nif (total_satisfaction > total_satisfaction + sum + satisfaction[i])\\n    break;\\n```\\n# Complexity\\n- Time complexity: O(nLogn)\\n\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxSatisfaction(int[] satisfaction) {\\n        Array.Sort(satisfaction);\\n        int total_satisfaction = 0;\\n        int sum = 0;\\n        for (int i = satisfaction.Length - 1; i >= 0; i--)\\n        {\\n            if (total_satisfaction > total_satisfaction + sum + satisfaction[i])\\n                break;\\n            sum += satisfaction[i];\\n            total_satisfaction += sum;\\n        }\\n\\n        return total_satisfaction;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    sum += satisfaction[i];\\n    total_satisfaction += sum;\\n```\n```\\nif (total_satisfaction > total_satisfaction + sum + satisfaction[i])\\n    break;\\n```\n```\\npublic class Solution {\\n    public int MaxSatisfaction(int[] satisfaction) {\\n        Array.Sort(satisfaction);\\n        int total_satisfaction = 0;\\n        int sum = 0;\\n        for (int i = satisfaction.Length - 1; i >= 0; i--)\\n        {\\n            if (total_satisfaction > total_satisfaction + sum + satisfaction[i])\\n                break;\\n            sum += satisfaction[i];\\n            total_satisfaction += sum;\\n        }\\n\\n        return total_satisfaction;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353511,
                "title": "java-easy-solution-95-faster-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\npublic int maxSatisfaction(int[] satisfaction) {\\nArrays.sort(satisfaction);\\n\\n    int maxVlaue=0;\\n    for(int i=0;i<satisfaction.length;i++){\\n        int cook=1;\\n        int sum=0;\\n        for(int j=i;j<satisfaction.length;j++){\\n        sum+=satisfaction[j]*cook;\\n        cook++;\\n        }\\n        maxVlaue=Math.max(sum,maxVlaue);\\n    }\\n    return  maxVlaue;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int maxSatisfaction(int[] satisfaction) {\\nArrays.sort(satisfaction);\\n\\n    int maxVlaue=0;\\n    for(int i=0;i<satisfaction.length;i++){\\n        int cook=1;\\n        int sum=0;\\n        for(int j=i;j<satisfaction.length;j++){\\n        sum+=satisfaction[j]*cook;\\n        cook++;\\n        }\\n        maxVlaue=Math.max(sum,maxVlaue);\\n    }\\n    return  maxVlaue;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719181,
                "title": "simple-dp-solution-with-explanation-c",
                "content": "first we sort the satisfaction array. Reason is we want to multiply bigger number with bigger time. Now let dp[i][j] = max satisfaction that I ll get, it I process the ith digit at time interval t. I now have 2 choices, take the ith dish or not take the ith dish. Thus we write:\\n```\\n dp[i][t] = max(satisfaction[i] * t + dp[i + 1][t + 1], dp[i + 1][t]);\\n ```\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int maxT = satisfaction.size();\\n        int t, i;\\n        int dp[maxT + 2][maxT + 2];\\n        memset(dp, 0, sizeof dp);\\n        for(i = maxT - 1; i >= 0; --i) {\\n            for(t = 1; t <= maxT; ++t) {\\n                if(i == maxT - 1) {\\n                    dp[i][t] = satisfaction[i] * t;\\n                } else {\\n                    dp[i][t] = max(satisfaction[i] * t + dp[i + 1][t + 1], dp[i + 1][t]);\\n                }\\n            }\\n        }\\n        return max(0, dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n dp[i][t] = max(satisfaction[i] * t + dp[i + 1][t + 1], dp[i + 1][t]);\\n ```\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int maxT = satisfaction.size();\\n        int t, i;\\n        int dp[maxT + 2][maxT + 2];\\n        memset(dp, 0, sizeof dp);\\n        for(i = maxT - 1; i >= 0; --i) {\\n            for(t = 1; t <= maxT; ++t) {\\n                if(i == maxT - 1) {\\n                    dp[i][t] = satisfaction[i] * t;\\n                } else {\\n                    dp[i][t] = max(satisfaction[i] * t + dp[i + 1][t + 1], dp[i + 1][t]);\\n                }\\n            }\\n        }\\n        return max(0, dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353732,
                "title": "easy-solution-with-explanation-in-java-greedy",
                "content": "# Intuition\\nSince we need to make a choice according to satisfaction level, approach that comes to mind is greedy approach.\\n\\nClearly chef would want to cook the most satifying dish first and try to avoid the dishes that contribute -vely to the overall satification. Hence we will need to sort the array\\n\\n\\n---\\n\\n\\n# Approach\\n1) Sort the array\\n2) Start traversing the array in reverse and maitain a running sum(prefix sum)\\n3) *We keep adding the prefixSum to our overall satisaction as long as the prefixSum + satisfaction at that index is. +ve that is prefixSum + satisdaction[i] > 0, by doing this we make sure that we donot cook dishes that contribute -vely*\\n4) Since we have sorted array, we know that once the prefixSum becomes -ver following dishes after that would also contribute -vely.\\n5) Return the answer\\n\\n\\n---\\n\\nDry run the code for a better undestanding\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) sorting + O(n) = O(nlogn) as sorting contributes more to the complexity\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int runningSum=0;\\n        int result=0;\\n        int size = satisfaction.length;\\n        for(int i=size-1 ;i>=0 && satisfaction[i]+runningSum>0;i--){\\n            runningSum+=satisfaction[i];\\n            result+=runningSum;\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging.\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/4532c3f8-9970-4333-9cc8-6db04d2fdce3_1680057711.8359313.png)\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int runningSum=0;\\n        int result=0;\\n        int size = satisfaction.length;\\n        for(int i=size-1 ;i>=0 && satisfaction[i]+runningSum>0;i--){\\n            runningSum+=satisfaction[i];\\n            result+=runningSum;\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353508,
                "title": "easy-standard-dynamic-programming-c-solution",
                "content": "# Intuition\\nAs the question has clearly stated that the order is not fixed on how to prepare dishes so we have choices on prepare or not to prepare the dish so clearly its a knapsack type dynamic programming problem.\\n# Approach\\nStandard choose or not choose recursive + memoization dynamic programming solution\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) as we have to check for every possible time and every index of the dish.\\n\\n- Space complexity:\\nO(n^2) as a 2-D matrix for memoization.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n  int helper(vector<int>&v,vector<vector<int>>&dp,int n,int i,int t){\\n      if(i==n){\\n          return 0;\\n      }\\n      if(dp[i][t]!=-1){\\n          return dp[i][t];\\n      }\\n// we choose to prepare this dish\\n      int poss1 = helper(v,dp,n,i+1,t+1);\\n// we choose not to prepare the dish;\\n      int poss2 = helper(v,dp,n,i+1,t);\\n//if we prepare this dish then satisfaction*time must be added to the poss1 as it was for the dish to be chosen.\\n      int ans=max(v[i]*t+poss1,poss2);\\n// take max of both poss1,poss2 and return;\\n      return dp[i][t] = ans;\\n  }\\n \\n  int maxSatisfaction(vector<int>& v) {\\n    sort(v);\\n    int n=v.size();\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return helper(v,dp,n,0,1);\\n  }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n  int helper(vector<int>&v,vector<vector<int>>&dp,int n,int i,int t){\\n      if(i==n){\\n          return 0;\\n      }\\n      if(dp[i][t]!=-1){\\n          return dp[i][t];\\n      }\\n// we choose to prepare this dish\\n      int poss1 = helper(v,dp,n,i+1,t+1);\\n// we choose not to prepare the dish;\\n      int poss2 = helper(v,dp,n,i+1,t);\\n//if we prepare this dish then satisfaction*time must be added to the poss1 as it was for the dish to be chosen.\\n      int ans=max(v[i]*t+poss1,poss2);\\n// take max of both poss1,poss2 and return;\\n      return dp[i][t] = ans;\\n  }\\n \\n  int maxSatisfaction(vector<int>& v) {\\n    sort(v);\\n    int n=v.size();\\n    vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n    return helper(v,dp,n,0,1);\\n  }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353406,
                "title": "daily-leetcoding-challenge-march-day-29",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reducing-dishes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Bottom-Up Dynamic Programming (Space Optimized)\n\n  \n**Approach 4:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reducing-dishes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 3:** Bottom-Up Dynamic Programming (Space Optimized)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2683038,
                "title": "c-recursion-rec-memo-bottom-up-space-optimization",
                "content": "**Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& sat,int pos,int mult,int sum){\\n        if(pos==sat.size())return sum;\\n        \\n        int in=solve(sat,pos+1,mult+1,sum+mult*sat[pos]);\\n        int ex=solve(sat,pos+1,mult,sum);\\n        \\n        return max(in,ex);\\n    }\\n    int maxSatisfaction(vector<int>& sat) {\\n        sort(sat.begin(),sat.end());\\n        return solve(sat,0,1,0);\\n    }\\n};\\n```\\n\\n**Recu + Memo**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& sat,int pos,int mult,vector<vector<int>>& dp){\\n        if(pos==sat.size())return 0;\\n        if(dp[pos][mult]!=-1)return dp[pos][mult];\\n        \\n        int in=solve(sat,pos+1,mult+1,dp)+mult*sat[pos];\\n        int ex=solve(sat,pos+1,mult,dp);\\n        \\n        return dp[pos][mult]=max(in,ex);\\n    }\\n    int maxSatisfaction(vector<int>& sat) {\\n        sort(sat.begin(),sat.end());\\n        \\n        int n=sat.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        \\n        return solve(sat,0,1,dp);\\n    }\\n};\\n```\\n\\n**Bottom-Up**\\n\\n```\\nclass Solution {\\npublic:\\n    int solveTab(vector<int>& sat){\\n        int n=sat.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        \\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int mult=pos;mult>=0;mult--){\\n\\n                int in=dp[pos+1][mult+1]+(mult+1)*sat[pos];\\n                int ex=dp[pos+1][mult];\\n\\n                dp[pos][mult]=max(in,ex);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n    int maxSatisfaction(vector<int>& sat) {\\n        sort(sat.begin(),sat.end());\\n        return solveTab(sat);\\n    }\\n};\\n```\\n\\n**Space-optimization**\\n\\n```\\nclass Solution {\\npublic:\\n    int solveTab(vector<int>& sat){\\n        int n=sat.size();\\n        vector<int> curr(n+1,0);\\n        vector<int> next(n+1,0);\\n                \\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int mult=pos;mult>=0;mult--){\\n\\n                int in=next[mult+1]+(mult+1)*sat[pos];\\n                int ex=next[mult];\\n\\n                curr[mult]=max(in,ex);\\n            }\\n            next=curr;\\n        }\\n        \\n        return next[0];\\n    }\\n    int maxSatisfaction(vector<int>& sat) {\\n        sort(sat.begin(),sat.end());\\n        return solveTab(sat);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& sat,int pos,int mult,int sum){\\n        if(pos==sat.size())return sum;\\n        \\n        int in=solve(sat,pos+1,mult+1,sum+mult*sat[pos]);\\n        int ex=solve(sat,pos+1,mult,sum);\\n        \\n        return max(in,ex);\\n    }\\n    int maxSatisfaction(vector<int>& sat) {\\n        sort(sat.begin(),sat.end());\\n        return solve(sat,0,1,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& sat,int pos,int mult,vector<vector<int>>& dp){\\n        if(pos==sat.size())return 0;\\n        if(dp[pos][mult]!=-1)return dp[pos][mult];\\n        \\n        int in=solve(sat,pos+1,mult+1,dp)+mult*sat[pos];\\n        int ex=solve(sat,pos+1,mult,dp);\\n        \\n        return dp[pos][mult]=max(in,ex);\\n    }\\n    int maxSatisfaction(vector<int>& sat) {\\n        sort(sat.begin(),sat.end());\\n        \\n        int n=sat.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        \\n        return solve(sat,0,1,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solveTab(vector<int>& sat){\\n        int n=sat.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        \\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int mult=pos;mult>=0;mult--){\\n\\n                int in=dp[pos+1][mult+1]+(mult+1)*sat[pos];\\n                int ex=dp[pos+1][mult];\\n\\n                dp[pos][mult]=max(in,ex);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n    int maxSatisfaction(vector<int>& sat) {\\n        sort(sat.begin(),sat.end());\\n        return solveTab(sat);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solveTab(vector<int>& sat){\\n        int n=sat.size();\\n        vector<int> curr(n+1,0);\\n        vector<int> next(n+1,0);\\n                \\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int mult=pos;mult>=0;mult--){\\n\\n                int in=next[mult+1]+(mult+1)*sat[pos];\\n                int ex=next[mult];\\n\\n                curr[mult]=max(in,ex);\\n            }\\n            next=curr;\\n        }\\n        \\n        return next[0];\\n    }\\n    int maxSatisfaction(vector<int>& sat) {\\n        sort(sat.begin(),sat.end());\\n        return solveTab(sat);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336742,
                "title": "c-easiest-memoization-solution-explained-with-comments-dp",
                "content": "\\tint solve(vector<int>&sat , int index , int time,vector<vector<int>>&dp){\\n        int n=sat.size();\\n        // checking base conditon , if index has reached the end point the no need to calc further\\n        if(index==n) return 0;\\n        \\n        //if dp has already valued stored  in it\\n        if(dp[index][time]!=-1){\\n            return dp[index][time];\\n        }\\n        \\n        // including the dish to cook , therefore index+1 and time+1\\n        int incl = sat[index]*(time+1) + solve(sat , index+1 , time+1,dp);\\n        \\n        //dont include this dish to cook and move further, therefore index+1 and time remain same \\n        int excl = 0+ solve(sat , index+1 , time,dp);\\n        \\n        //storing the maximum ans in dp \\n        dp[index][time]=max(incl , excl);\\n        \\n        //\\n        return dp[index][time];\\n        \\n        \\n    }\\n    \\n    \\n    int maxSatisfaction(vector<int>& sat) {\\n        \\n        //sort the array to get the maximum result\\n        sort(sat.begin() , sat.end());\\n        \\n        //formation of 2D dp vector\\n        vector<vector<int>> dp(sat.size()+1 , vector<int>(sat.size()+1 ,-1));\\n        \\n        return solve(sat , 0 , 0,dp);\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "\\tint solve(vector<int>&sat , int index , int time,vector<vector<int>>&dp){\\n        int n=sat.size();\\n        // checking base conditon , if index has reached the end point the no need to calc further\\n        if(index==n) return 0;\\n        \\n        //if dp has already valued stored  in it\\n        if(dp[index][time]!=-1){\\n            return dp[index][time];\\n        }\\n        \\n        // including the dish to cook , therefore index+1 and time+1\\n        int incl = sat[index]*(time+1) + solve(sat , index+1 , time+1,dp);\\n        \\n        //dont include this dish to cook and move further, therefore index+1 and time remain same \\n        int excl = 0+ solve(sat , index+1 , time,dp);\\n        \\n        //storing the maximum ans in dp \\n        dp[index][time]=max(incl , excl);\\n        \\n        //\\n        return dp[index][time];\\n        \\n        \\n    }\\n    \\n    \\n    int maxSatisfaction(vector<int>& sat) {\\n        \\n        //sort the array to get the maximum result\\n        sort(sat.begin() , sat.end());\\n        \\n        //formation of 2D dp vector\\n        vector<vector<int>> dp(sat.size()+1 , vector<int>(sat.size()+1 ,-1));\\n        \\n        return solve(sat , 0 , 0,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1681145,
                "title": "a-bit-long-but-easy-to-understand",
                "content": "Step 1: check if all the elements are negative and return zero in this case\\nStep 2:sort the list. if all the elements are positive, all must be included in the solution. calculate solution using calc func(see in code).\\nStep 3: if it is a mixture of positive negative and zero values, first find solution for all positive values.\\nStep 4: Keep adding new negative/zero value at beginning and calculate solution for same. if new solution is less than previously calculated solution, stop and return previous solution. else, add new value at beginning and repeat step4 until every element is added.\\n\\n```\\n\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        def calc(ls):\\n            res=0\\n            for idx,l in enumerate(ls):\\n                res+=(idx+1)*l\\n            return res\\n        \\n        z=0\\n        for s in satisfaction:\\n            if s<=0:\\n                z+=1\\n        if z==len(satisfaction):\\n            return 0\\n        \\n        satisfaction.sort() \\n        if z==0:\\n            ltc=calc(satisfaction) \\n            return ltc\\n        \\n        for s in range(len(satisfaction)):\\n            if satisfaction[s]>0:\\n                ind=s\\n                \\n        pos=satisfaction[ind:]\\n        ltc=calc(pos)\\n        \\n        newi=ind-1 \\n        while satisfaction:\\n            pos.insert(0,satisfaction[newi]) \\n            templtc=calc(pos) \\n            if templtc<ltc:\\n                return ltc\\n            else:\\n                ltc=templtc\\n                newi-=1\\n                if newi<0:\\n                    return ltc\\n\\n                \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Step 1: check if all the elements are negative and return zero in this case\\nStep 2:sort the list. if all the elements are positive, all must be included in the solution. calculate solution using calc func(see in code).\\nStep 3: if it is a mixture of positive negative and zero values, first find solution for all positive values.\\nStep 4: Keep adding new negative/zero value at beginning and calculate solution for same. if new solution is less than previously calculated solution, stop and return previous solution. else, add new value at beginning and repeat step4 until every element is added.\\n\\n```\\n\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        def calc(ls):\\n            res=0\\n            for idx,l in enumerate(ls):\\n                res+=(idx+1)*l\\n            return res\\n        \\n        z=0\\n        for s in satisfaction:\\n            if s<=0:\\n                z+=1\\n        if z==len(satisfaction):\\n            return 0\\n        \\n        satisfaction.sort() \\n        if z==0:\\n            ltc=calc(satisfaction) \\n            return ltc\\n        \\n        for s in range(len(satisfaction)):\\n            if satisfaction[s]>0:\\n                ind=s\\n                \\n        pos=satisfaction[ind:]\\n        ltc=calc(pos)\\n        \\n        newi=ind-1 \\n        while satisfaction:\\n            pos.insert(0,satisfaction[newi]) \\n            templtc=calc(pos) \\n            if templtc<ltc:\\n                return ltc\\n            else:\\n                ltc=templtc\\n                newi-=1\\n                if newi<0:\\n                    return ltc\\n\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1554544,
                "title": "easy-to-understand-0ms-c-solution",
                "content": "After sorting list \\'satisfaction\\' in increasing order.\\nWe will traverse the list from back.\\nConcept behind this is a simple formula ...\\n\\nindexed sum = cumulative sum + prev. indexed sum\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        \\n        int cumulativeSum=0,indexedSum=0;\\n        \\n        for(int i=satisfaction.size()-1;i>=0;i--){\\n            cumulativeSum+=satisfaction[i];\\n            \\n            if(cumulativeSum<0){\\n                //Since, indexedSum value cannot be further increased, let\\'s breakup\\n                break;\\n            }\\n            \\n            //indexedSum will be added with cumulative Sum\\n            indexedSum+=cumulativeSum;\\n        }\\n        return indexedSum;\\n    }\\n};\\n```\\n\\nLet\\'s understand it by an example.\\n\\na,b,c,d\\n\\ni=3\\ncumulative sum = d\\nindexed sum =d\\n\\ni=2\\ncumulative sum =c+d\\nindexed sum=c+2*d = (c+d) + d = cumulative sum + previous indexed sum \\n\\ni=1\\ncumulative sum = b+c+d\\nindexed sum = b+2*c+3*d = (b+c+d) + (c+2*d) =cumulative sum + previous indexed sum\\n\\ni=0\\ncumulative sum = a+b+c+d\\nindexed sum = a+2*b+3*c+4*d = (a+b+c+d) + (b+2*c+3*d)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        \\n        int cumulativeSum=0,indexedSum=0;\\n        \\n        for(int i=satisfaction.size()-1;i>=0;i--){\\n            cumulativeSum+=satisfaction[i];\\n            \\n            if(cumulativeSum<0){\\n                //Since, indexedSum value cannot be further increased, let\\'s breakup\\n                break;\\n            }\\n            \\n            //indexedSum will be added with cumulative Sum\\n            indexedSum+=cumulativeSum;\\n        }\\n        return indexedSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294469,
                "title": "c-easy-to-understand-rec-memo",
                "content": "class Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxSatisfaction(vector<int>& s) {\\n        if(s.size()==1)\\n        {\\n          if(s[0]>0)\\n            return s[0];\\n          else\\n            return 0;\\n        }\\n        sort(s.begin(),s.end());\\n        memset(dp,-1,sizeof dp);\\n        return solve(s,0,1);\\n    }\\n\\tint solve(vector<int>&s,int st,int time){\\n     if(st==s.size()-1)\\n       return time*s[st];\\n     if(st>s.size())\\n       return 0;\\n     if(dp[st][time]!=-1)\\n       return dp[st][time];\\n     int ans1=time*s[st]+solve(s,st+1,time+1);\\n     int ans2=solve(s,st+1,time);\\n     return dp[st][time]=max(0,max(ans1,ans2));\\n\\t }\\n};",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int maxSatisfaction(vector<int>& s) {\\n        if(s.size()==1)\\n        {\\n          if(s[0]>0)\\n            return s[0];\\n          else\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 839064,
                "title": "simple-python-with-one-trick-beats-99",
                "content": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort(reverse=True)\\n        while sum(satisfaction)<0:\\n            satisfaction.pop()\\n        total=0\\n        l=len(satisfaction)\\n        for i in range(l):\\n            total+=satisfaction[i]*(l-i)\\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort(reverse=True)\\n        while sum(satisfaction)<0:\\n            satisfaction.pop()\\n        total=0\\n        l=len(satisfaction)\\n        for i in range(l):\\n            total+=satisfaction[i]*(l-i)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563334,
                "title": "screencast-leetcode-biweekly-contest-23-rank-9",
                "content": "https://www.youtube.com/watch?v=qWA_C4nGuts",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=qWA_C4nGuts",
                "codeTag": "Unknown"
            },
            {
                "id": 3564970,
                "title": "c-sort-prefix-sum",
                "content": "sort in decreasing order.\\nconvert v into prefix sum array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& v) {\\n        sort(v.begin(),v.end(),[&](int &a,int &b){return a>b;});\\n        int x = 0,i = 0, n = v.size(),ans=0;\\n        for(i = 1; i < n; i++)v[i] += v[i-1];\\n        for(auto &i: v){\\n            x += i;\\n            ans = max(ans,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& v) {\\n        sort(v.begin(),v.end(),[&](int &a,int &b){return a>b;});\\n        int x = 0,i = 0, n = v.size(),ans=0;\\n        for(i = 1; i < n; i++)v[i] += v[i-1];\\n        for(auto &i: v){\\n            x += i;\\n            ans = max(ans,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367156,
                "title": "easy-approach-beginners-explained-c",
                "content": "# Intuition\\nTo get some insight on which dishes need to be discarded, we should sort the array in ascending order. Sorting the vectors will keep the dish with maximum satisfaction at end which will provide a greater Life Time Coeffcient.\\n\\n# Approach\\nWe loop over and and find the sum of sub-arrays and find the sub-array with maximum sum. \\nThe sum or **Life Time Coefficient** will be calculated by keeping another variable `x` initailized as1 which will be multiplied with `satisfaction[j]`  \\n\\n# Complexity\\n- **Time complexity**: O(N*N)\\n- **Space complexity**: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        for(auto i: satisfaction) cout<<i<<\" \";\\n        int sum=0;\\n        for(int i=0;i<satisfaction.size();i++){\\n            int x=1,s=0;\\n            for(int j=i;j<satisfaction.size();j++){\\n                s+=satisfaction[j]*(x++);\\n            }\\n            sum=max(s,sum);\\n        }\\n        return sum;\\n    }\\n};\\n```\\n> Please consider upvoting if it helped \\u270C\\nAlso comment and ask if I can help with anything.\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        for(auto i: satisfaction) cout<<i<<\" \";\\n        int sum=0;\\n        for(int i=0;i<satisfaction.size();i++){\\n            int x=1,s=0;\\n            for(int j=i;j<satisfaction.size();j++){\\n                s+=satisfaction[j]*(x++);\\n            }\\n            sum=max(s,sum);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3355656,
                "title": "simple-solution-explained-at-beginner-level",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is a straight forward DP queston but let\\'s see if we can do better by a greedy approach.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImagine dish at 0th index i.e. the first dist to be served at last and 2nd dish at last second then the answer will look something like :\\n\\nsatisfacton[0]*n + satisfaction[1]*(n-1) ...satisfactin[n-1]*1\\n\\nbut what if we eleminate some dishes and let say we use K number of dishes for optimal answer :\\n\\nsatisfaction[0]*(K) + satisfacton[1](K-1) + ....\\n\\nbut now the question is how will we know how many dishes to consider i.e. K at the beginning of traversal (at i==0)\\n\\nthe answer lies in the equaton itself\\ninstead of multiplying with K in the beginning think of it as satisfacton[0] added K times:\\n\\nsatisfaction[0] + satisfacton[0]...K times + (satisfacton[1]...k-1 times)....\\n\\nthe point is to keeping adding the previous values at every iteraton in that case there won\\'t be any need of prior knowledge of K.\\nwe can do this simply by using a presum variable and adding it at every iteraton.\\n\\nand ofcourse the answer will be maximum when we use the highest satisfaction dish at first as it getting added the most.\\n\\nSort satisfaction array in decreasing order.\\n\\nBreak the loop when presum precede 0 (negative presum will reduce the answer and futher presums will also be negative as array is sorted in decreasing order).\\n\\nUpvote if you understood my explanation :)\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N) where N is the number of dishes.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) ie constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int presum = 0;\\n\\n        sort(satisfaction.begin(),satisfaction.end(),greater<int>());\\n        int ans = 0;\\n        for(int i=0;i<satisfaction.size();i++)\\n        {\\n            presum += satisfaction[i];\\n            if(presum<0) break;\\n            ans += presum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int presum = 0;\\n\\n        sort(satisfaction.begin(),satisfaction.end(),greater<int>());\\n        int ans = 0;\\n        for(int i=0;i<satisfaction.size();i++)\\n        {\\n            presum += satisfaction[i];\\n            if(presum<0) break;\\n            ans += presum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354973,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/30d45c1e-f37a-411f-be30-deded277087a_1680082476.582937.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& nums) {\\n        int sum=0;\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                ans+=sum;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& nums) {\\n        int sum=0;\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                ans+=sum;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354362,
                "title": "c-iterative-recursive-memoization-approaches-explained",
                "content": "\\n\\n# Approach\\n\\n- The first approach is a brute-force method where we try all possible starting points and calculate the satisfaction of each subarray. This approach is simple and easy to understand, but it is very slow and inefficient for large input arrays.\\n\\n- The second approach is a recursive algorithm that computes the maximum satisfaction by including or excluding each element of the input array. This approach is more efficient than the brute-force method.\\n- The third approach uses memoization to optimize the recursive algorithm by caching the results of the computed subproblems. This approach is faster than the second approach because it avoids recomputing the same subproblems multiple times. It is also easier to implement because we only need to add a memoization table to store the results of the computed subproblems.\\n\\n# Complexity\\n- **Time complexity:** O(N^2), for all approaches.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** \\n1. O(1) for iterative approach\\n2. O(N) for recursion \\n3. O(N^2) for Memoization\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n### 1. Brute Force (iterative)\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        int max_sat=0;\\n        int st=0; // to test all starting points\\n        while(st<satisfaction.size()){\\n            int temp=0;\\n            for(int i=st;i<satisfaction.size();++i){\\n                temp+=satisfaction[i]*(i-st+1);\\n            }\\n            max_sat=max(max_sat,temp);\\n            ++st;\\n        }\\n        return max_sat;\\n    }\\n};\\n```\\n### 2. Recursive\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& sat, int curr){\\n        if(curr==sat.size()) return 0; \\n        int coeff=0; // store the results when we include current index\\n        for(int i=curr;i<sat.size();++i){\\n            coeff+=sat[i]*(i-curr+1);\\n        }\\n        return max(coeff,helper(sat,curr+1)); // recursion to check for next indexes\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        return helper(satisfaction,0);\\n    }\\n};\\n```\\n### 3. Memoization\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& sat, vector<vector<int>>& memo, int curr,int t){\\n        if(curr==sat.size()) return 0;\\n        if(memo[curr][t]!=-1) return memo[curr][t]; // if the value is already computed\\n        \\n        int excluded = helper(sat,memo,curr+1,t); // when we don\\'t include the current index\\n        int included = sat[curr]*t + helper(sat,memo,curr+1,t+1); // when we include the current index\\n        return memo[curr][t]=max(included,excluded);\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        int n=satisfaction.size();\\n        vector<vector<int>>memo(n+1,vector<int>(n+1,-1));\\n        return helper(satisfaction,memo,0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        int max_sat=0;\\n        int st=0; // to test all starting points\\n        while(st<satisfaction.size()){\\n            int temp=0;\\n            for(int i=st;i<satisfaction.size();++i){\\n                temp+=satisfaction[i]*(i-st+1);\\n            }\\n            max_sat=max(max_sat,temp);\\n            ++st;\\n        }\\n        return max_sat;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& sat, int curr){\\n        if(curr==sat.size()) return 0; \\n        int coeff=0; // store the results when we include current index\\n        for(int i=curr;i<sat.size();++i){\\n            coeff+=sat[i]*(i-curr+1);\\n        }\\n        return max(coeff,helper(sat,curr+1)); // recursion to check for next indexes\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        return helper(satisfaction,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& sat, vector<vector<int>>& memo, int curr,int t){\\n        if(curr==sat.size()) return 0;\\n        if(memo[curr][t]!=-1) return memo[curr][t]; // if the value is already computed\\n        \\n        int excluded = helper(sat,memo,curr+1,t); // when we don\\'t include the current index\\n        int included = sat[curr]*t + helper(sat,memo,curr+1,t+1); // when we include the current index\\n        return memo[curr][t]=max(included,excluded);\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        int n=satisfaction.size();\\n        vector<vector<int>>memo(n+1,vector<int>(n+1,-1));\\n        return helper(satisfaction,memo,0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354158,
                "title": "c-dynamic-programming-recursive-iterative-memory-reduction",
                "content": "Hi Leetcode Heros, Ramadan Kreem \\n\\nAs the problem is asked, we must take a subset of items from the list **satisfaction** it can be an empty subset\\n\\nSay we have taken items **item[i], item[j], item[k], item[a]** \\xA0\\nsuch that: min (i, j, k, a) >= 0, max (i, j, k, a) list size, and of course different indices\\n\\nIf we take the items in this order, our sum like-time coefficient will be\\xA0\\n\\n** 1 * item[i] + 2 * item[j] + 3 * item[k] + 4 * item[a] **\\xA0\\n\\nSince order doesn\\'t matter and we can take the last item before the first,\\nIt\\'s better to take the maximum item value at the end.\\n\\nso that led us to sort the initial list for solving the problem.\\n\\nLet\\'s solve the problem when the list size is 1 and extend an item and calculate the best for it.\\n\\ndeclare a list **maxLikeTime[N][N]**\\xA0\\nsuch that maxLikeTime[i][j] = max sum like-time coefficient if I take **j+1** items\\xA0\\nfrom subarray [0:i].\\nsuch that **(j <= i)** because we take **j+1** and subarray[0:i] contains **i+1\"\" elements \\xA0\\n\\n**n = size of satisfaction list**\\xA0\\nlets calculate If we have only one element\\xA0\\n**maxLikeTime[0][0] = satisfaction[0]**\\n**maxLikeTime[0][1] = -inf** to not consider its value as it is invalid **(j <= i)**\\xA0\\n\\nto calculate the next value:\\n**maxLikeTime[1][0] == max(satisfaction[1], maxLikeTime[0][0])**\\n\\nEither we take this item or the previous one\\xA0\\nWe can keep doing that for the rest values, **j <= i**\\n**maxLikeTime[i][j] = max (maxLikeTime[i][j], maxLikeTime[i-1][j-1] * (j+1))**\\xA0\\n\\nThat\\'s it, and as we can see when we calculate for **item[i]** we only need the calculated values for\\xA0\\nitem **item[i-1]**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxLikeTime[2][501];\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size();\\n        maxLikeTime[0][0] = satisfaction[0];\\n        maxLikeTime[0][1] = -1e9;\\n        int mx = 0;\\n        int p = 1;\\n        for (int i = 1; i < n; i++){\\n            maxLikeTime[p][0] = max(satisfaction[i], maxLikeTime[p^1][0]);\\n            for (int j = 1; j <= i; j++){\\n                maxLikeTime[p][j] = maxLikeTime[p^1][j];\\n                maxLikeTime[p][j] = max(maxLikeTime[p][j], \\n                                       maxLikeTime[p^1][j-1] + \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   satisfaction[i] * (j+1));\\n            }\\n\\t\\t\\t// to not consider the value in our solution as we didn\\'t calcualte it yet\\n            maxLikeTime[p][i+1] = -1e9;\\n            p ^= 1;\\n        }\\n        for (int i = 0; i < n; i++)\\n            mx = max(mx, maxLikeTime[p^1][i]);\\n        return mx;\\n        \\n    }\\n};\\n```\\nI believe if you understand the iterative code, the recusive will be easy for you, so I will only give you the code.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(vector<int>& a, int tk, int idx)\\n    {\\n        if (idx == a.size()) return 0;\\n        int& ret = dp[tk][idx];\\n        if (~ret) return ret;\\n        return ret = max(solve(a, tk, idx + 1), tk * a[idx] + solve(a, tk + 1, idx + 1));\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        memset(dp, -1, sizeof dp);\\n        return solve(satisfaction, 1, 0);\\n    }\\n};\\n```\\n\\nIf you have any question about the solution, please comment and if you understand the solution, please upvote.\\n\\nThank You.\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLikeTime[2][501];\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size();\\n        maxLikeTime[0][0] = satisfaction[0];\\n        maxLikeTime[0][1] = -1e9;\\n        int mx = 0;\\n        int p = 1;\\n        for (int i = 1; i < n; i++){\\n            maxLikeTime[p][0] = max(satisfaction[i], maxLikeTime[p^1][0]);\\n            for (int j = 1; j <= i; j++){\\n                maxLikeTime[p][j] = maxLikeTime[p^1][j];\\n                maxLikeTime[p][j] = max(maxLikeTime[p][j], \\n                                       maxLikeTime[p^1][j-1] + \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   satisfaction[i] * (j+1));\\n            }\\n\\t\\t\\t// to not consider the value in our solution as we didn\\'t calcualte it yet\\n            maxLikeTime[p][i+1] = -1e9;\\n            p ^= 1;\\n        }\\n        for (int i = 0; i < n; i++)\\n            mx = max(mx, maxLikeTime[p^1][i]);\\n        return mx;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(vector<int>& a, int tk, int idx)\\n    {\\n        if (idx == a.size()) return 0;\\n        int& ret = dp[tk][idx];\\n        if (~ret) return ret;\\n        return ret = max(solve(a, tk, idx + 1), tk * a[idx] + solve(a, tk + 1, idx + 1));\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        memset(dp, -1, sizeof dp);\\n        return solve(satisfaction, 1, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353477,
                "title": "0-1-knapsack-problem-recursive-to-optimised",
                "content": "PLEASE UPVOTE ME IF POSSIBLE \\uD83E\\uDD79!!!!!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// SOLUTION 1 : RECURSIVE SOLUTION \\n    int solve(vector<int>&satisfaction, int index, int time){\\n        if(index == satisfaction.size()){\\n            return 0;\\n        }\\n\\n        // current dish koh include kr diya\\n        int include = satisfaction[index]*time + solve(satisfaction, index+1, time+1);\\n\\n        // exclude ki call , cur dish koh include nhi kiya\\n        int exclude = 0 + solve(satisfaction, index+1, time);\\n\\n        return max(include, exclude);\\n    }\\n\\n\\n// SOLUTION 2 : RECURSION + MEMOIZATION\\n    int solve2(vector<int>&satisfaction, int index, int time,  vector<vector<int>>&dp){\\n        // base case\\n        if(index == satisfaction.size()){\\n            return 0;\\n        }\\n\\n        if(dp[index][time] != -1){\\n            return dp[index][time];\\n        } \\n\\n        // include call, curr dish koh include kr diya\\n        int include = satisfaction[index]*time + solve2(satisfaction, index+1, time+1, dp);\\n\\n        // exclude ki call , curr dish koh include nhi kiya\\n        int exclude = 0 + solve2(satisfaction, index+1, time, dp);\\n\\n        return dp[index][time] = max(include, exclude);\\n    }\\n\\n\\n\\n\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        // This is a simple problem based on 0/1 knapsack\\n\\n        // Approach 1 :- recursive function\\n        // sort(satisfaction.begin(), satisfaction.end());\\n        // int index = 0;\\n        // int time = 1;\\n        // return solve(satisfaction, index, time);\\n\\n        // Approach 2 :- recursion + memoization\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int index = 0;\\n        int time = 1;\\n        int n = satisfaction.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n+1, -1));\\n        return solve2(satisfaction, index, time, dp);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// SOLUTION 1 : RECURSIVE SOLUTION \\n    int solve(vector<int>&satisfaction, int index, int time){\\n        if(index == satisfaction.size()){\\n            return 0;\\n        }\\n\\n        // current dish koh include kr diya\\n        int include = satisfaction[index]*time + solve(satisfaction, index+1, time+1);\\n\\n        // exclude ki call , cur dish koh include nhi kiya\\n        int exclude = 0 + solve(satisfaction, index+1, time);\\n\\n        return max(include, exclude);\\n    }\\n\\n\\n// SOLUTION 2 : RECURSION + MEMOIZATION\\n    int solve2(vector<int>&satisfaction, int index, int time,  vector<vector<int>>&dp){\\n        // base case\\n        if(index == satisfaction.size()){\\n            return 0;\\n        }\\n\\n        if(dp[index][time] != -1){\\n            return dp[index][time];\\n        } \\n\\n        // include call, curr dish koh include kr diya\\n        int include = satisfaction[index]*time + solve2(satisfaction, index+1, time+1, dp);\\n\\n        // exclude ki call , curr dish koh include nhi kiya\\n        int exclude = 0 + solve2(satisfaction, index+1, time, dp);\\n\\n        return dp[index][time] = max(include, exclude);\\n    }\\n\\n\\n\\n\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        // This is a simple problem based on 0/1 knapsack\\n\\n        // Approach 1 :- recursive function\\n        // sort(satisfaction.begin(), satisfaction.end());\\n        // int index = 0;\\n        // int time = 1;\\n        // return solve(satisfaction, index, time);\\n\\n        // Approach 2 :- recursion + memoization\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int index = 0;\\n        int time = 1;\\n        int n = satisfaction.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n+1, -1));\\n        return solve2(satisfaction, index, time, dp);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272355,
                "title": "best-explanation-of-5-methods-dp-and-greedy",
                "content": "PLEASE READ FULL SOLUTION AND UPVOTE IF YOU LIKE AND UNDERSTAND\\n# Intuition\\nGiven that chef can discard some dishes so we will try to implement pick don\\'t pick method\\n# Approach 1 Recursion\\n1. first of all , sort the array\\n2. use incl and excl concept and return maximum\\n# Complexity\\n- Time complexity:\\nO(n!)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& satisfaction,int ind,int time){\\n        if(ind == satisfaction.size()) return 0;\\n\\n        int incl = satisfaction[ind]*(time+1) + solve(satisfaction,ind+1,time+1);\\n        int excl = solve(satisfaction,ind+1,time);\\n\\n        return max(incl,excl);\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        return solve(satisfaction,0,0);\\n    }\\n};\\n```\\n# Approach 2 Recursion + memoization or Top down dp\\n1. first of all , sort the array\\n2. create 2d Dp array of size n+1 * n+1 and initialize with -1\\n3. store ans in dp and return\\n4. after base case check if ans is already stored or \\n5. if stored return it else call recursion\\n# Complexity\\n- Time complexity:\\n    O(n^2)\\n- Space complexity:\\n    O(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& satisfaction,int ind,int time,vector<vector<int>> &dp){\\n        if(ind == satisfaction.size()) return 0;\\n\\n        if(dp[ind][time] != -1) return dp[ind][time];\\n\\n        int incl = satisfaction[ind]*(time+1) + solve(satisfaction,ind+1,time+1,dp);\\n        int excl = solve(satisfaction,ind+1,time,dp);\\n\\n        dp[ind][time] = max(incl,excl);\\n        return dp[ind][time];\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n\\n        sort(satisfaction.begin(),satisfaction.end());\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n\\n        return solve(satisfaction,0,0,dp);\\n    }\\n};\\n```\\n# Approach 3 bottom up dp\\n1. first of all , sort the array\\n2. create 2d Dp array of size n+1 * n+1 and initialize with 0\\n3. Traverse through nested for loops form n-1 to 0 for ind and ind to 0 for time\\n4. do incl excl thing and store max to dp  \\n5. return dp[0][0] since it is bottom up ans will store in the first element of dp array\\n# Complexity\\n- Time complexity:\\n    O(n^2)\\n- Space complexity:\\n    O(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(),satisfaction.end());\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n\\n        for(int ind = n-1; ind >= 0; ind--){\\n            for(int time = ind; time >= 0; time--){\\n\\n                int incl = satisfaction[ind]*(time+1) + dp[ind+1][time+1];\\n                int excl = dp[ind+1][time];\\n\\n                dp[ind][time] = max(incl,excl);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```\\n# Approach 4 Space Optimization without dp\\n1. first of all , sort the array\\n2. since in the above solution a row of dp array depend upon the row coming next to curr row so we can simply reduce whole dp array to 2 single arrays\\n3. Create 2 arrays curr and next of size n+1 and initialize with 0\\n4. traverse with same nested loop as in above solution\\n5. Replace dp[ind+1][time+1] to next[time+1]\\n6. Replace dp[ind+1][time] to next[time+1] \\n7. Replace dp[ind][time] to curr[time]\\n8. don\\'t forget to assign curr to next after ending of loop\\n8. return next[0]\\n# Complexity\\n- Time complexity:\\n    O(n^2)\\n- Space complexity:\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(),satisfaction.end());\\n\\n        vector<int> curr(n+1,0);\\n        vector<int> next(n+1,0);\\n\\n        for(int ind = n-1; ind >= 0; ind--){\\n            for(int time = ind; time >= 0; time--){\\n\\n                int incl = satisfaction[ind]*(time+1) + next[time+1];\\n                int excl = next[time];\\n\\n                curr[time] = max(incl,excl);\\n            }\\n            next = curr;\\n        }\\n\\n        return next[0];\\n    }\\n};\\n```\\n# Approach 5 Greedy Most optimal\\n1. first of all , sort the array\\n2. use to nested loop \\n3. i = 0 to n-1\\n4. j = i to n\\n5. calculate Like-time coefficient in sum variable and when loop ends update ans\\n6. if ans <= 0 that means you have to discard all dishes so return 0\\n7. return ans otherwise\\n# Complexity\\n- Time complexity:\\n    O(n^2)\\n- Space complexity:\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(),satisfaction.end());\\n        \\n        int ans = INT_MIN;\\n        for(int i = 0; i < n-1; i++){\\n            int t = 0, sum = 0;\\n            for(int j = i; j < n; j++){\\n                t++;\\n                sum += satisfaction[j]*t;\\n            }\\n            ans = max(ans,sum);\\n        }\\n        return (ans <= 0) ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& satisfaction,int ind,int time){\\n        if(ind == satisfaction.size()) return 0;\\n\\n        int incl = satisfaction[ind]*(time+1) + solve(satisfaction,ind+1,time+1);\\n        int excl = solve(satisfaction,ind+1,time);\\n\\n        return max(incl,excl);\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        return solve(satisfaction,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& satisfaction,int ind,int time,vector<vector<int>> &dp){\\n        if(ind == satisfaction.size()) return 0;\\n\\n        if(dp[ind][time] != -1) return dp[ind][time];\\n\\n        int incl = satisfaction[ind]*(time+1) + solve(satisfaction,ind+1,time+1,dp);\\n        int excl = solve(satisfaction,ind+1,time,dp);\\n\\n        dp[ind][time] = max(incl,excl);\\n        return dp[ind][time];\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n\\n        sort(satisfaction.begin(),satisfaction.end());\\n\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n\\n        return solve(satisfaction,0,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(),satisfaction.end());\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n\\n        for(int ind = n-1; ind >= 0; ind--){\\n            for(int time = ind; time >= 0; time--){\\n\\n                int incl = satisfaction[ind]*(time+1) + dp[ind+1][time+1];\\n                int excl = dp[ind+1][time];\\n\\n                dp[ind][time] = max(incl,excl);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(),satisfaction.end());\\n\\n        vector<int> curr(n+1,0);\\n        vector<int> next(n+1,0);\\n\\n        for(int ind = n-1; ind >= 0; ind--){\\n            for(int time = ind; time >= 0; time--){\\n\\n                int incl = satisfaction[ind]*(time+1) + next[time+1];\\n                int excl = next[time];\\n\\n                curr[time] = max(incl,excl);\\n            }\\n            next = curr;\\n        }\\n\\n        return next[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(),satisfaction.end());\\n        \\n        int ans = INT_MIN;\\n        for(int i = 0; i < n-1; i++){\\n            int t = 0, sum = 0;\\n            for(int j = i; j < n; j++){\\n                t++;\\n                sum += satisfaction[j]*t;\\n            }\\n            ans = max(ans,sum);\\n        }\\n        return (ans <= 0) ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822806,
                "title": "javascript-binary-search-find-peak-element",
                "content": "```\\nvar maxSatisfaction = function(satisfaction) {\\n    let answer = -Infinity\\n    const len = satisfaction.length\\n    satisfaction.sort((a,b) => a-b)\\n    \\n    let left = 0, right = len\\n    \\n    while(left < right) {\\n        const mid = (right + left) >>> 1\\n        \\n        const l = getpoint(mid)\\n        const r = getpoint(mid + 1)\\n\\n        if (l > r) {\\n            answer = Math.max(answer, l)\\n            right = mid\\n        } else {\\n            answer = Math.max(answer, r)\\n            left = mid + 1 \\n        }\\n\\n    }\\n    function getpoint(mid) {\\n        let res = 0\\n        let j = 1\\n        for (let i = mid; i < len; i++) {\\n            res += (satisfaction[i] * j)\\n            j += 1\\n        }\\n        return res\\n    }\\n    return answer < 0 ? 0 : answer\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar maxSatisfaction = function(satisfaction) {\\n    let answer = -Infinity\\n    const len = satisfaction.length\\n    satisfaction.sort((a,b) => a-b)\\n    \\n    let left = 0, right = len\\n    \\n    while(left < right) {\\n        const mid = (right + left) >>> 1\\n        \\n        const l = getpoint(mid)\\n        const r = getpoint(mid + 1)\\n\\n        if (l > r) {\\n            answer = Math.max(answer, l)\\n            right = mid\\n        } else {\\n            answer = Math.max(answer, r)\\n            left = mid + 1 \\n        }\\n\\n    }\\n    function getpoint(mid) {\\n        let res = 0\\n        let j = 1\\n        for (let i = mid; i < len; i++) {\\n            res += (satisfaction[i] * j)\\n            j += 1\\n        }\\n        return res\\n    }\\n    return answer < 0 ? 0 : answer\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2113571,
                "title": "it-is-easy-problem-explained-python-code",
                "content": "Sort the array .\\nPerform the operation ```time[i] * satisfaction[i]```over array by taking starting index from 0 to length of array.\\n```\\nfor (int i=0 to n)\\n\\tfor (int j = i to n)\\n\\t\\tapply the operation\\n\\tStore the maximum value\\n```\\nIt will be eliminating the least satisfying value in each operation\\n\\nOperating once on array takes **O ( N )** and it will be done N times so **N^2** complexity which is good for **n=500**\\n\\n```\\nclass Solution:\\n    def maxSatisfaction(self, a: List[int]) -> int:\\n        a.sort()\\n        k=0\\n        \\n        for i in range(len(a)):\\n            v=0\\n            for j in range(i,len(a)):\\n                v+=((j+1-i)*a[j])\\n            k=max(k,v)\\n        \\n        return k\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```time[i] * satisfaction[i]```\n```\\nfor (int i=0 to n)\\n\\tfor (int j = i to n)\\n\\t\\tapply the operation\\n\\tStore the maximum value\\n```\n```\\nclass Solution:\\n    def maxSatisfaction(self, a: List[int]) -> int:\\n        a.sort()\\n        k=0\\n        \\n        for i in range(len(a)):\\n            v=0\\n            for j in range(i,len(a)):\\n                v+=((j+1-i)*a[j])\\n            k=max(k,v)\\n        \\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772750,
                "title": "easy-cpp-code-o-nlog-n-time-o-1-space",
                "content": "``` class Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& sat) {\\n        \\n        sort(sat.begin(),sat.end());\\n        \\n        int n=sat.size();\\n        \\n        int final_sum=0;\\n       int cur_sum=0;\\n        \\n        for(int i=n-1; i>=0;i--){\\n            \\n            cur_sum+=sat[i];\\n            if(cur_sum>=0 ){\\n             \\n                final_sum+=cur_sum;\\n                }\\n            else{\\n             \\n                break;\\n            }   \\n        }\\n        return final_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "``` class Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& sat) {\\n        \\n        sort(sat.begin(),sat.end());\\n        \\n        int n=sat.size();\\n        \\n        int final_sum=0;\\n       int cur_sum=0;\\n        \\n        for(int i=n-1; i>=0;i--){\\n            \\n            cur_sum+=sat[i];\\n            if(cur_sum>=0 ){\\n             \\n                final_sum+=cur_sum;\\n                }\\n            else{\\n             \\n                break;\\n            }   \\n        }\\n        return final_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538502,
                "title": "plain-bottom-up-dp",
                "content": "Clean bottom up DP:\\nThe idea is simple like any other bottom up approach, for the ith dish what\\'s the best satisfaction I can get with total no. of dishes L.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& v) {\\n        int n = v.size();\\n        sort(v.begin(), v.end());\\n        \\n        long long dp[501][501];\\n        \\n        // filling with mininum value because there\\'s a possibility to grab a negative value with\\n        // l length and later on pick a positive value, comparioson should be made with INT_MIN\\n        \\n        for(int i=0;i<501;i++)\\n            for(int j=0;j<501;j++)\\n                dp[i][j] = INT_MIN;\\n        \\n        for(int i=0;i<501;i++) dp[i][0] = 0;\\n        \\n        dp[0][1] = v[0];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int l=1;l<=n;l++){\\n                dp[i][l] = max(dp[i-1][l-1]+l*v[i], dp[i-1][l]);\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(int l=0;l<=n;l++){\\n            ans = max(ans, dp[n-1][l]);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& v) {\\n        int n = v.size();\\n        sort(v.begin(), v.end());\\n        \\n        long long dp[501][501];\\n        \\n        // filling with mininum value because there\\'s a possibility to grab a negative value with\\n        // l length and later on pick a positive value, comparioson should be made with INT_MIN\\n        \\n        for(int i=0;i<501;i++)\\n            for(int j=0;j<501;j++)\\n                dp[i][j] = INT_MIN;\\n        \\n        for(int i=0;i<501;i++) dp[i][0] = 0;\\n        \\n        dp[0][1] = v[0];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int l=1;l<=n;l++){\\n                dp[i][l] = max(dp[i-1][l-1]+l*v[i], dp[i-1][l]);\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(int l=0;l<=n;l++){\\n            ans = max(ans, dp[n-1][l]);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530900,
                "title": "javascript-solutions-2-56-69-80ms-also-a-1-liner",
                "content": "**Answer 1: 56%/69% 80ms**\\n\\nTo solve this problem we must sort the given array so that the larger values are at the end. Each number in the array represents a satisfaction coefficient which will be multiplied by a time coefficent, the time coefficent increases by 1 after every iteration so we want our larger satisfaction coeffecients at the end of the array thus optimally giving us larger numbers.\\n\\nThe first thing we want to do is sort the given array in an ascending order so we start with the smallest values first.  Do NOT use `.sort()` as this will return an incorrect sort (it will sort by the first numeral in a number ex: 1, 10, 2, 3, 434, 5...) and lead to a wrong answer submission.\\n- `s.sort((a, b) => { return a - b })`\\n\\nNext we want to instantiate the `result` value as 0 and it will also be helpful to save the length of the given array as a variable.\\n- `let result = 0, len = s.length`\\n\\nTo solve this problem we will need a nested loop. Start the outer for loop by setting the variable `i` = 0, iterate while `i` < `len`, and increase `i` by 1 for every iteration.\\n- `for(let i = 0; i < len; i++){ ... }`\\n\\nInside the first for loop we must instantiate the variable `current` so we can keep a running value inside the second for loop. Next we want to start the inner for loop by setting the variable `j` = `i`, iterate while `j` < `len`, and increase `j` by 1 for every iteration. We want to start at `j` = `i` because as we continue to iterate through the outer loop the value of `i` will increase and the inner loop will start excluding the smaller (possibly negative) values at the begining of the sorted array.\\n- `let current = 0`\\n- `for(let j = i; j < len; j++){ ... }`\\n\\nInside the inner for loop we want the `j` indexed value of the array multiplied by (`j` - `i` + 1) added to the `current` variable. `s[j]` represents the satisfaction coefficient and `(j - i + 1)` will equal our time coefficient.\\n- `current += (s[j] * (j - i + 1))`\\n\\nAfter the inner for loop has completed we want to check if the current value is greater than the result value, if so then we will set the result value tothe current value.\\n- `if (current > result) { result = current }`\\n\\nReturn the result variable as our answer.\\n\\n**Solution:**\\n\\n```\\nvar maxSatisfaction = function(s) {\\n\\ts.sort((a, b) => { return a - b })\\n    let result = 0, len = s.length\\n    for(let i = 0; i < len; i++){\\n        let current = 0\\n        for(let j = i; j < len; j++){\\n            current += (s[j] * (j - i + 1))\\n        }\\n        if (current > result) { result = current }\\n    }\\n    return result\\n};\\n```\\n\\n---\\n\\n**One-Liner: 21%/8% 124ms**\\n\\nThe 1-line solution is significantly slower and uses more memory, but 1 line tho..\\n\\nStart by sorting the array\\n- `s.sort((a, b) => { return a - b })`\\n\\nChain a map method that includes the value `x`, iteration `i`, and array `arr`.\\n- `.map((x, i, arr) => ... )`\\n\\nInside the map method slice the array at the `i` index\\n- `arr.slice(i)`\\n\\nOn the sliced array run a reduce method that includes the previous value `p`, current value `c`, iteration `i`, array `r`, and an initial value of 0.\\n- `.reduce((p, c, i, r) =>  ..., 0)`\\n\\nInside the reduce method we want to return the current value (satisfaction coefficient) multiplied by the iteration + 1 (time coefficient) added on to the previous value .\\n- `(p + (c * (i + 1)))`\\n\\nAs of now, we have a newly mapped array of possible *like-time coefficient* solutions. In order to return the largest value we must use the spread operator on the array, include a 0 at the end of the spread array, and then run the Math.max function on the group of numbers. We include a 0 at the end because if the largest *like-time coefficient* is less than 0 then we will simply return 0 (as explained in example 3: \"People don\\'t like the dishes. No dish is prepared.\").\\n- `...s`\\n- `Math.max(...s, 0)`\\n\\n**Solution:**\\n\\n```\\nvar maxSatisfaction = (s) => Math.max(...s.sort((a, b) => { return a - b }).map((x, i, arr) => arr.slice(i).reduce((p, c, i, r) => (p + (c * (i + 1))), 0)), 0) \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSatisfaction = function(s) {\\n\\ts.sort((a, b) => { return a - b })\\n    let result = 0, len = s.length\\n    for(let i = 0; i < len; i++){\\n        let current = 0\\n        for(let j = i; j < len; j++){\\n            current += (s[j] * (j - i + 1))\\n        }\\n        if (current > result) { result = current }\\n    }\\n    return result\\n};\\n```\n```\\nvar maxSatisfaction = (s) => Math.max(...s.sort((a, b) => { return a - b }).map((x, i, arr) => arr.slice(i).reduce((p, c, i, r) => (p + (c * (i + 1))), 0)), 0) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690645,
                "title": "java-beats-100",
                "content": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        final int size = satisfaction.length;\\n        Arrays.sort(satisfaction, 0, size);\\n        int maxSatisfaction = 0;\\n        int accumulator     = 0;\\n        for (int i = size - 1; i > -1; --i) {\\n            accumulator     += satisfaction[i];\\n            if (accumulator <= 0) break;\\n            maxSatisfaction += accumulator;\\n        }\\n        return maxSatisfaction;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        final int size = satisfaction.length;\\n        Arrays.sort(satisfaction, 0, size);\\n        int maxSatisfaction = 0;\\n        int accumulator     = 0;\\n        for (int i = size - 1; i > -1; --i) {\\n            accumulator     += satisfaction[i];\\n            if (accumulator <= 0) break;\\n            maxSatisfaction += accumulator;\\n        }\\n        return maxSatisfaction;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357348,
                "title": "java-greedy-o-n-log-n-time-9-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to maximize the satisfaction we should pick the dish with the highest value as late as possible. It makes sense to sort the array, then iterate over it from max value to min value and keep adding dishes in a greedy manner as long as the max satisfaction value keeps increasing.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$ used by the sorting algorithm\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxSatisfaction(int[] satisfaction) {\\n    Arrays.sort(satisfaction);\\n    var sum = 0;\\n    var ans = 0;\\n\\n    for (var i = satisfaction.length - 1; i >= 0; i--) {\\n      if (sum + satisfaction[i] > 0) {\\n        sum += satisfaction[i];\\n        ans += sum;\\n      } else break;\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n  public int maxSatisfaction(int[] satisfaction) {\\n    Arrays.sort(satisfaction);\\n    var sum = 0;\\n    var ans = 0;\\n\\n    for (var i = satisfaction.length - 1; i >= 0; i--) {\\n      if (sum + satisfaction[i] > 0) {\\n        sum += satisfaction[i];\\n        ans += sum;\\n      } else break;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356019,
                "title": "a-simple-approach-c-please-upvote",
                "content": "# Intuition\\nThe answer requires to see all possible cases to find max\\n\\n# Approach\\nA vector \"sum\" would store all possible values of (costs*satisfaction)\\nand return the maximum at last.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2 log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        int x=satisfaction.size();\\n        vector<int> sum(x);\\n        for(int i=x;i>0;i--){\\n            for(int j=1;j<=i;j++){\\n            sum[x-i]=sum[x-i]+j*satisfaction[j-1];\\n            if(j==i){\\n               satisfaction.erase(satisfaction.begin());\\n            }\\n            }\\n        }\\n        int max=sum[0];\\n          for(int k=0;k<sum.size();k++) {\\n        if(max < sum[k]) {\\n            max = sum[k];\\n        }\\n    }\\n    if(max<1){\\n        return 0;\\n    }\\n    else\\n          return max;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        int x=satisfaction.size();\\n        vector<int> sum(x);\\n        for(int i=x;i>0;i--){\\n            for(int j=1;j<=i;j++){\\n            sum[x-i]=sum[x-i]+j*satisfaction[j-1];\\n            if(j==i){\\n               satisfaction.erase(satisfaction.begin());\\n            }\\n            }\\n        }\\n        int max=sum[0];\\n          for(int k=0;k<sum.size();k++) {\\n        if(max < sum[k]) {\\n            max = sum[k];\\n        }\\n    }\\n    if(max<1){\\n        return 0;\\n    }\\n    else\\n          return max;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355478,
                "title": "python-easy-to-understand-top-down-dp-solution",
                "content": "# Intuition\\nKey things to note is if a dish has a lower satisfaction rating you want to wash earlier since it would have a lower multiple. Once you sort the dishes by satisfaction the problem becomes straightforward\\n\\nThen the problem breaks down into iterating thorugh the dishes from least to greatest satisfaction and choosing whether to pick that dish or skip it\\n\\n# Approach\\nThe DP subproblem is DP(dishIndex, timeMultiple) = max((satisfaction[dishIndex] * timeMult) + dp(dishIndex+1, timeMult+1),\\ndp(dishIndex+1, timeMult))\\n\\n# Complexity\\n- Time complexity:\\nO(nxn) where n is lenght of satisfaction since there can be a total of n x n states to choose from\\n\\n- Space complexity:\\nsame as time\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        \\'\\'\\'\\n\\n        algo:\\n        1. sort dishes lowest -> greatest\\n        2. Top down DP looking ofr max satisfaction (dishIndex, timeMult)\\n            max(choosing this dish, skipping this dish)\\n            \\n        Time+ Space Complexity: O(nxn) where n is number of dishes\\n        \\n        \\'\\'\\'\\n        satisfaction.sort()\\n        @cache\\n        def dp(dishIndex, timeMult):\\n            if dishIndex == len(satisfaction):\\n                return 0\\n            # choose to pick or not pick\\n            return max((satisfaction[dishIndex] * timeMult) + dp(dishIndex+1, timeMult+1),\\n                      dp(dishIndex+1, timeMult))\\n            \\n        \\n        return dp(0, 1)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        \\'\\'\\'\\n\\n        algo:\\n        1. sort dishes lowest -> greatest\\n        2. Top down DP looking ofr max satisfaction (dishIndex, timeMult)\\n            max(choosing this dish, skipping this dish)\\n            \\n        Time+ Space Complexity: O(nxn) where n is number of dishes\\n        \\n        \\'\\'\\'\\n        satisfaction.sort()\\n        @cache\\n        def dp(dishIndex, timeMult):\\n            if dishIndex == len(satisfaction):\\n                return 0\\n            # choose to pick or not pick\\n            return max((satisfaction[dishIndex] * timeMult) + dp(dishIndex+1, timeMult+1),\\n                      dp(dishIndex+1, timeMult))\\n            \\n        \\n        return dp(0, 1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355269,
                "title": "c-easiest-solution-without-extra-space-94-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNot cooking the -ve value dishes can increase our answer (maxSatisfaction)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the array first\\n2. If the largest element is negative return 0 as ans (as it is max value)\\n3. Else run a for loop considering all the dishes and excluding least one every time.\\n4. Compare the max value and return it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& arr) {\\n        int n=arr.size(),sum=0,maxv=INT_MIN,level;\\n        sort(arr.begin(),arr.end());\\n\\n        if(arr[n-1]<=0){\\n            return sum;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            sum=0;\\n            level=1;\\n            for(int j=i;j<n;j++){\\n                sum+=(arr[j]*level);\\n                level++;\\n            }\\n            maxv=max(sum,maxv);\\n        }\\n\\n        return maxv;\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& arr) {\\n        int n=arr.size(),sum=0,maxv=INT_MIN,level;\\n        sort(arr.begin(),arr.end());\\n\\n        if(arr[n-1]<=0){\\n            return sum;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            sum=0;\\n            level=1;\\n            for(int j=i;j<n;j++){\\n                sum+=(arr[j]*level);\\n                level++;\\n            }\\n            maxv=max(sum,maxv);\\n        }\\n\\n        return maxv;\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354361,
                "title": "scala-greedy-sorting-prefix-sum",
                "content": "# Intuition\\nIt always needs to take the highest dish to maximize satisfaction. So, we sort the score first. And then, the formula of score, which is sum of $$time[i] * sat[i]$$, can be break down to $$sat[i] + (sat[i] + sat[i-1]) + (sat[i] + sat[i-1] + sat[i-2])...$$. Since we have sorted the data, we can calculate prefix sum for it 2 times.\\n\\n# Approach\\n1. Sort data from the highest to the lowest.\\n2. Calculate first prefix sum to find $$sat[i]$$, $$sat[i] + sat[i-1]$$, $$sat[i] + sat[i-1] + sat[i-2]$$ and so on.\\n3. Calculate second prefix sum to find $$sat[i]$$, $$sat[i] + (sat[i] + sat[i-1])$$, $$sat[i] + (sat[i] + sat[i-1]) + (sat[i] + sat[i-1] + sat[i-2])$$ and so on.\\n4. Find maximum of 3. (and need to add 0 in case no dishes are chosen).\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nobject Solution {\\n    def maxSatisfaction(satisfaction: Array[Int]): Int = {\\n        val sortedSat = satisfaction.sortBy(-_)\\n        val pSum = sortedSat.scanLeft(0)(_ + _).tail\\n        val ppSum = pSum.scanLeft(0)(_ + _)\\n        ppSum.max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nobject Solution {\\n    def maxSatisfaction(satisfaction: Array[Int]): Int = {\\n        val sortedSat = satisfaction.sortBy(-_)\\n        val pSum = sortedSat.scanLeft(0)(_ + _).tail\\n        val ppSum = pSum.scanLeft(0)(_ + _)\\n        ppSum.max\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3354072,
                "title": "c-easy-to-understand-simple-iteration-and-sorting-greedy",
                "content": "# Complexity\\n- Time complexity:\\no(n^2) using 2 nested for loops\\n\\n- Space complexity:\\no(n) for time vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size();\\n        int cnt = 1;\\n        vector<int> time;\\n        for(int i=0;i<n;i++) {\\n            time.push_back(cnt);\\n            cnt++;\\n        }\\n        int maxi = 0;\\n        for(int i=0;i<n;i++) {\\n            int sum = 0;\\n            for(int j=i;j<n;j++) {\\n                if(time[j] < 0) return maxi;\\n                sum += time[j]*satisfaction[j];\\n            }\\n\\n            maxi = max(maxi, sum);\\n\\n            for(int k=i;k<n;k++) {\\n                time[k] -= 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size();\\n        int cnt = 1;\\n        vector<int> time;\\n        for(int i=0;i<n;i++) {\\n            time.push_back(cnt);\\n            cnt++;\\n        }\\n        int maxi = 0;\\n        for(int i=0;i<n;i++) {\\n            int sum = 0;\\n            for(int j=i;j<n;j++) {\\n                if(time[j] < 0) return maxi;\\n                sum += time[j]*satisfaction[j];\\n            }\\n\\n            maxi = max(maxi, sum);\\n\\n            for(int k=i;k<n;k++) {\\n                time[k] -= 1;\\n            }\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353916,
                "title": "easiest-solution",
                "content": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for (int i : satisfaction) {\\n            pq.offer(i);\\n        }\\n        int ans = 0, curr = 0;\\n        while (!pq.isEmpty() && pq.peek() + curr > 0) {\\n            curr += pq.poll();\\n            ans += curr;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Upvoting is much appreciated",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for (int i : satisfaction) {\\n            pq.offer(i);\\n        }\\n        int ans = 0, curr = 0;\\n        while (!pq.isEmpty() && pq.peek() + curr > 0) {\\n            curr += pq.poll();\\n            ans += curr;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353556,
                "title": "3-ways-understandable-very-easy-recursive-memoization-tabulation-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to either pick a index or not pick a index.Simple\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to first sort the array because:\\na) we need to find the maximum sum so we need to keep the maximum value at the end of array and lower at the starting index;\\n\\nfor Example: [-1,-8,0,5,-9] ==> [-9,-8,-1,0,5] here 5 reaches at the end to it will take maximum time if previous element are picked.\\nHere in the example given: -1 is picked with time 1, 0 with time 2 , 5 with time 3-- which will give ans as 14 which is maximum\\n\\n1.First try to find all possibilities using recursion\\n2. Then optimize it using dp\\n\\n# Code Recursive\\n\\nclass Solution {\\n\\n    public int findMaxSum(int index,int time,int n,int satisfaction[]){\\n\\n        if(index>=n) return 0;\\n\\n       \\n        // if you pick a index simply tell the recursion hey go to next index and do the same stuff by taking time+1;\\n        int pick = satisfaction[index]*time+findMaxSum(index+1,time+1,n,satisfaction);\\n       \\n        // if you don\\'t pick it then go to the next index with the same time;**Bold**\\n        int notpick = 0+findMaxSum(index+1,time,n,satisfaction);\\n\\n        return  Math.max(pick,notpick);\\n    }\\n    public int maxSatisfaction(int[] satisfaction) {\\n        int n = satisfaction.length;\\n        \\n        Arrays.sort(satisfaction);\\n\\n       \\n        return findMaxSum(0,1,n,satisfaction);\\n    }\\n}\\n\\n\\nMEMOIZATION SOLUTION using 2D Dp\\n# Code Memoization\\n```\\nclass Solution {\\n\\n    public int findMaxSum(int index,int time,int n,int satisfaction[],int dp[][]){\\n\\n        if(index>=n) return 0;\\n\\n        if(dp[index][time]!=-1) return dp[index][time];\\n\\n        int pick = satisfaction[index]*time+findMaxSum(index+1,time+1,n,satisfaction,dp);\\n        int notpick = 0+findMaxSum(index+1,time,n,satisfaction,dp);\\n\\n        return dp[index][time] = Math.max(pick,notpick);\\n    }\\n    public int maxSatisfaction(int[] satisfaction) {\\n        int n = satisfaction.length;\\n        \\n        Arrays.sort(satisfaction);\\n\\n        int dp[][] = new int[n][n+1];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n+1;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n\\n        return findMaxSum(0,1,n,satisfaction,dp);\\n    }\\n}\\n```\\n\\n\\n\\n# Code Tabulation\\n\\n\\n\\n\\n\\nclass Solution {\\n\\n    \\n    public int maxSatisfaction(int[] satisfaction) {\\n        int n = satisfaction.length;\\n        \\n        Arrays.sort(satisfaction);\\n\\n        int dp[][] = new int[n+1][n+1];\\n\\n       \\n        for(int index=n-1;index>=0;index--){\\n          \\n          for(int time = index;time>=0;time--){\\n                int pick = satisfaction[index]*(time+1)+dp[index+1][time+1];\\n                int notpick = 0+dp[index+1][time];\\n\\n                dp[index][time] = Math.max(pick,notpick);\\n\\n          }\\n         \\n        }\\n        \\n\\n        return dp[0][0];\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int findMaxSum(int index,int time,int n,int satisfaction[],int dp[][]){\\n\\n        if(index>=n) return 0;\\n\\n        if(dp[index][time]!=-1) return dp[index][time];\\n\\n        int pick = satisfaction[index]*time+findMaxSum(index+1,time+1,n,satisfaction,dp);\\n        int notpick = 0+findMaxSum(index+1,time,n,satisfaction,dp);\\n\\n        return dp[index][time] = Math.max(pick,notpick);\\n    }\\n    public int maxSatisfaction(int[] satisfaction) {\\n        int n = satisfaction.length;\\n        \\n        Arrays.sort(satisfaction);\\n\\n        int dp[][] = new int[n][n+1];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n+1;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n\\n        return findMaxSum(0,1,n,satisfaction,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702024,
                "title": "doubt-getting-wrong-answer",
                "content": "\\n**One of them is working other one is not**\\n```\\n// solution 1 :- adding while having pick \\n\\n\\n// class Solution {\\n// public:\\n    \\n//     int dp[1001][1001];\\n//     int solve(int i , vector<int>&satisfaction , int total , int count)\\n//     {\\n//         if(i==satisfaction.size())\\n//             return 0 ;\\n//         if(dp[i][count]!=-1)\\n//             return dp[i][count];\\n//         int pick= satisfaction[i]*count + solve(i+1 , satisfaction , total + count*satisfaction[i] , count+1);\\n//         int notpick= solve(i+1 , satisfaction , total , count);\\n//         return dp[i][count]=max(pick,notpick);\\n//     }\\n    \\n//     int maxSatisfaction(vector<int>& satisfaction) {\\n//         sort(satisfaction.begin(),satisfaction.end());\\n//         memset(dp,-1,sizeof(dp));\\n//         return solve(0 , satisfaction , 0 , 1);\\n//     }\\n// };\\n\\n\\n\\n\\n// solution 2 :- adding in parameter for pick \\n\\n// class Solution {\\n// public:\\n    \\n//     int dp[1001][1001];\\n//     int solve(int i , vector<int>&satisfaction , int total , int count)\\n//     {\\n//         if(i==satisfaction.size())\\n//             return total;\\n//         if(dp[i][count]!=-1)\\n//             return dp[i][count];\\n//         int pick=  solve(i+1 , satisfaction , total + count*satisfaction[i] , count+1);\\n//         int notpick= solve(i+1 , satisfaction , total , count);\\n//         return dp[i][count]=max(pick,notpick);\\n//     }\\n    \\n//     int maxSatisfaction(vector<int>& satisfaction) {\\n//         sort(satisfaction.begin(),satisfaction.end());\\n//         memset(dp,-1,sizeof(dp));\\n//         return solve(0 , satisfaction , 0 , 1);\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// solution 1 :- adding while having pick \\n\\n\\n// class Solution {\\n// public:\\n    \\n//     int dp[1001][1001];\\n//     int solve(int i , vector<int>&satisfaction , int total , int count)\\n//     {\\n//         if(i==satisfaction.size())\\n//             return 0 ;\\n//         if(dp[i][count]!=-1)\\n//             return dp[i][count];\\n//         int pick= satisfaction[i]*count + solve(i+1 , satisfaction , total + count*satisfaction[i] , count+1);\\n//         int notpick= solve(i+1 , satisfaction , total , count);\\n//         return dp[i][count]=max(pick,notpick);\\n//     }\\n    \\n//     int maxSatisfaction(vector<int>& satisfaction) {\\n//         sort(satisfaction.begin(),satisfaction.end());\\n//         memset(dp,-1,sizeof(dp));\\n//         return solve(0 , satisfaction , 0 , 1);\\n//     }\\n// };\\n\\n\\n\\n\\n// solution 2 :- adding in parameter for pick \\n\\n// class Solution {\\n// public:\\n    \\n//     int dp[1001][1001];\\n//     int solve(int i , vector<int>&satisfaction , int total , int count)\\n//     {\\n//         if(i==satisfaction.size())\\n//             return total;\\n//         if(dp[i][count]!=-1)\\n//             return dp[i][count];\\n//         int pick=  solve(i+1 , satisfaction , total + count*satisfaction[i] , count+1);\\n//         int notpick= solve(i+1 , satisfaction , total , count);\\n//         return dp[i][count]=max(pick,notpick);\\n//     }\\n    \\n//     int maxSatisfaction(vector<int>& satisfaction) {\\n//         sort(satisfaction.begin(),satisfaction.end());\\n//         memset(dp,-1,sizeof(dp));\\n//         return solve(0 , satisfaction , 0 , 1);\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577761,
                "title": "java-2ms-94-sort-and-two-loops-with-suffix-sums-well-explained",
                "content": "**Intuition**: Save the best dishes for last to maximize the time by which we multiply them.  Cook the least popular dishes first, minimizing the time by which we multiply them.  This will require an O(n log n) sort.  Then, we can remove the worst dishes from the beginning, and if we can compute the impact to the total score in O(1) time, we can find the maximum score in O(n) time, meaning the overall approach will remain O(n log n).  We can note that when we remove a dish from the t=1 position, each remaining dish shifts left in time by 1.  That means, shifting left removes the sum of the satisfactions of the remaining dishes from the total score.  This could use some explaining, so let\\'s use an example.\\n```\\nSorted Satisfactions: -9, -8, -1, 0, 5\\nTime Coefficients:     1,  2,  3, 4, 5\\nScore Terms:          -9,-16, -3, 0,25    (Score: -3)\\nRemove -9, then we have:\\nSorted Satisfactions:  X, -8, -1, 0, 5\\nTime Coefficients:     X,  1,  2, 3, 4\\nScore Terms:           X, -8, -2, 0,20    (Score: 10)\\n```\\nNotice how the time coefficients of all the values right of -9 (which was removed) are reduced by 1?  This means shifting these values right reduces the score by `sum(-8, -1, 0, 5)`.  The total impact on score is to remove the `-9` term and to also reduce the score by `sum(-8, -1, 0, 5)`.  That is:\\n```\\nscore(-8, -1, 0, 5) = score(-9, -8, -1, 0, 5) - (-9) - sum(-8, -1, 0, 5).\\n                    = -3 + 9 - (-4)\\n                    = 10\\n```\\nWe can do this in general by keeping a \"suffix sum\" of all the scores.  That way, if we know the score from removing items 0 through i-1 (call it score s{i}), when we remove the ith item, we determine the corresponding score s{i+1} as:\\n```\\nscore{i+1} = score{i} - satisfaction[i] - suffixSum[i + 1]\\n```\\nThis is the general form of what we have done above.  That is:\\n```\\nscore{1} = score{0} - satisfaction[0] - suffixSum[1]\\n```\\nwhere:\\n```\\nscore{1} = score(-8, -1, 0, 5)\\nscore{0} = score(-9, -8, -1, 0, 5)\\nsatisfaction[0] = -9\\nsuffixSum[1] = sum(-8, -1, 0, 5)\\n```\\nStill not convinced?  Let\\'s do it again and remove the `-8` dish.\\n```\\nRemove -8, then we have:\\nSorted Satisfactions:  X, X, -1, 0, 5\\nTime Coefficients:     X, X,  1, 2, 3\\nScore Terms:           X, X, -1, 0,15    (Score: 14)\\nSuffix Sums: { -13, -4, 4, 5, 5, 0 }\\n\\nFormula:\\nscore{2} = score{1} - satisfaction[1] - suffixSum[2]\\n         = 10 - (-8) - 4\\n\\t\\t = 14\\n```\\n\\n**Exercise for the reader:** verify the following are correct:\\n\\n```\\nscore{3} = score{2} - satisfaction[2] - suffixSum[3]\\n         = 14 - (-1) - 5\\n\\t\\t = 10\\nscore{4} = score{3} - satisfaction[3] - suffixSum[4]\\n         = 10 - 0 - 5\\n\\t\\t = 5\\nscore{5} = score{4} - satisfaction[4] - suffixSum[5]\\n         = 5 - 5 - 0\\n\\t\\t = 0\\n```\\n\\nWith this formula and the suffix sum, we can efficiently try removing the worst dish and check the effect on the score, and find the maximum.  We define suffixSum[k] = the sum of the remaining satisfactions if the first (worst) k elements are removed.  We will compute it right-to-left, and it must have length n + 1, so that suffixSum[n] = 0 (the sum of the remaining satisfactions if we remove all n elements is suffixSum[n] and it must be 0).\\n\\n**Java Code**:\\n```\\nclass Solution {\\n\\n    public int maxSatisfaction(int[] satisfaction) {\\n        final int n = satisfaction.length;\\n        Arrays.sort(satisfaction);\\n\\t\\t// Now that we have sorted, we build a suffix sum and compute the starting score.\\n\\t\\t// The suffix sum has n + 1 elements because suffixSums[n] will be 0.  That is, if\\n\\t\\t// we remove n elements (0 through n-1), inclusive, we check suffixSum[n] and it\\n\\t\\t// must be 0 because no dishes remain.  Then we can compute the other suffix sums\\n\\t\\t// right-to-left by adding satisfaction[i] to suffixSums[i + 1].  In the same loop,\\n\\t\\t// we compute the starting score, the sum of each term of (i + 1) * satisfaction[i].\\n        final int[] suffixSums = new int[n + 1];\\n        int score = 0;\\n        for (int i = (n - 1); i >= 0; --i) {\\n            suffixSums[i] = suffixSums[i + 1] + satisfaction[i];\\n            score += ((i + 1) * satisfaction[i]);\\n        }\\n        int maxScore = (score > 0 ? score : 0);\\n        for (int i = 0; i < n; ++i) {\\n            score -= satisfaction[i];   // remove the dish at t=1\\n            score -= suffixSums[i + 1]; // shift each remaining dish left in time\\n            if (score > maxScore) {\\n                maxScore = score;\\n            }\\n        }\\n        return maxScore;\\n    }\\n\\n}\\n```\\n\\n**Complexity**: O(n log n) time, for the sort (the remainder is O(n) so the sort is responsible for the O(n log n) time complexity).  O(n) space for the suffix sums array.\\n\\n**Optimization Note**: It is generally faster when repeatedly updating a maximum to use an if check than to make a call to `maxFoo = Math.max(maxFoo, foo)`.  So there are two places in the above code where I use a condition instead of Math.max.  If you prefer Math.max for readability, feel free!  Runtime as-is was 2-4ms as of September, 2022.\\n\\n**Non-Optimization Note**: We could stop early, after we reach a positive maximum and see a decrease for the next dish removal.  We could also stop immediately if all dishes are negative.  This code does not do that, but you could if you wanted it to be even faster.\\n\\n**Standard Plea**: If you found this solution useful, interesting or generally not a waste of your time, I\\'d **appreciate your upvote**.  If you didn\\'t like it, **I\\'d love to hear why in the comments, so I can write better solutions**.  Thanks for your time, and happy coding!\\n\\n----\\n\\nP.S.  Dislike comments?  Here\\'s the uncommented version:\\n\\n```\\nclass Solution {\\n\\n    public int maxSatisfaction(int[] satisfaction) {\\n        final int n = satisfaction.length;\\n        Arrays.sort(satisfaction);\\n        final int[] suffixSums = new int[n + 1];\\n        int score = 0;\\n        for (int i = (n - 1); i >= 0; --i) {\\n            suffixSums[i] = suffixSums[i + 1] + satisfaction[i];\\n            score += ((i + 1) * satisfaction[i]);\\n        }\\n        int maxScore = (score > 0 ? score : 0);\\n        for (int i = 0; i < n; ++i) {\\n            score -= satisfaction[i];\\n            score -= suffixSums[i + 1];\\n            if (score > maxScore) {\\n                maxScore = score;\\n            }\\n        }\\n        return maxScore;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nSorted Satisfactions: -9, -8, -1, 0, 5\\nTime Coefficients:     1,  2,  3, 4, 5\\nScore Terms:          -9,-16, -3, 0,25    (Score: -3)\\nRemove -9, then we have:\\nSorted Satisfactions:  X, -8, -1, 0, 5\\nTime Coefficients:     X,  1,  2, 3, 4\\nScore Terms:           X, -8, -2, 0,20    (Score: 10)\\n```\n```\\nscore(-8, -1, 0, 5) = score(-9, -8, -1, 0, 5) - (-9) - sum(-8, -1, 0, 5).\\n                    = -3 + 9 - (-4)\\n                    = 10\\n```\n```\\nscore{i+1} = score{i} - satisfaction[i] - suffixSum[i + 1]\\n```\n```\\nscore{1} = score{0} - satisfaction[0] - suffixSum[1]\\n```\n```\\nscore{1} = score(-8, -1, 0, 5)\\nscore{0} = score(-9, -8, -1, 0, 5)\\nsatisfaction[0] = -9\\nsuffixSum[1] = sum(-8, -1, 0, 5)\\n```\n```\\nRemove -8, then we have:\\nSorted Satisfactions:  X, X, -1, 0, 5\\nTime Coefficients:     X, X,  1, 2, 3\\nScore Terms:           X, X, -1, 0,15    (Score: 14)\\nSuffix Sums: { -13, -4, 4, 5, 5, 0 }\\n\\nFormula:\\nscore{2} = score{1} - satisfaction[1] - suffixSum[2]\\n         = 10 - (-8) - 4\\n\\t\\t = 14\\n```\n```\\nscore{3} = score{2} - satisfaction[2] - suffixSum[3]\\n         = 14 - (-1) - 5\\n\\t\\t = 10\\nscore{4} = score{3} - satisfaction[3] - suffixSum[4]\\n         = 10 - 0 - 5\\n\\t\\t = 5\\nscore{5} = score{4} - satisfaction[4] - suffixSum[5]\\n         = 5 - 5 - 0\\n\\t\\t = 0\\n```\n```\\nclass Solution {\\n\\n    public int maxSatisfaction(int[] satisfaction) {\\n        final int n = satisfaction.length;\\n        Arrays.sort(satisfaction);\\n\\t\\t// Now that we have sorted, we build a suffix sum and compute the starting score.\\n\\t\\t// The suffix sum has n + 1 elements because suffixSums[n] will be 0.  That is, if\\n\\t\\t// we remove n elements (0 through n-1), inclusive, we check suffixSum[n] and it\\n\\t\\t// must be 0 because no dishes remain.  Then we can compute the other suffix sums\\n\\t\\t// right-to-left by adding satisfaction[i] to suffixSums[i + 1].  In the same loop,\\n\\t\\t// we compute the starting score, the sum of each term of (i + 1) * satisfaction[i].\\n        final int[] suffixSums = new int[n + 1];\\n        int score = 0;\\n        for (int i = (n - 1); i >= 0; --i) {\\n            suffixSums[i] = suffixSums[i + 1] + satisfaction[i];\\n            score += ((i + 1) * satisfaction[i]);\\n        }\\n        int maxScore = (score > 0 ? score : 0);\\n        for (int i = 0; i < n; ++i) {\\n            score -= satisfaction[i];   // remove the dish at t=1\\n            score -= suffixSums[i + 1]; // shift each remaining dish left in time\\n            if (score > maxScore) {\\n                maxScore = score;\\n            }\\n        }\\n        return maxScore;\\n    }\\n\\n}\\n```\n```\\nclass Solution {\\n\\n    public int maxSatisfaction(int[] satisfaction) {\\n        final int n = satisfaction.length;\\n        Arrays.sort(satisfaction);\\n        final int[] suffixSums = new int[n + 1];\\n        int score = 0;\\n        for (int i = (n - 1); i >= 0; --i) {\\n            suffixSums[i] = suffixSums[i + 1] + satisfaction[i];\\n            score += ((i + 1) * satisfaction[i]);\\n        }\\n        int maxScore = (score > 0 ? score : 0);\\n        for (int i = 0; i < n; ++i) {\\n            score -= satisfaction[i];\\n            score -= suffixSums[i + 1];\\n            if (score > maxScore) {\\n                maxScore = score;\\n            }\\n        }\\n        return maxScore;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152786,
                "title": "python-3-simple-sorting-solution",
                "content": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort(reverse=True)\\n        maxSatisfaction = dishSum = 0\\n\\n        for dish in satisfaction:\\n            dishSum += dish\\n            if dishSum <= 0:\\n                break\\n            maxSatisfaction += dishSum\\n        \\n        return maxSatisfaction",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort(reverse=True)\\n        maxSatisfaction = dishSum = 0\\n\\n        for dish in satisfaction:\\n            dishSum += dish\\n            if dishSum <= 0:\\n                break\\n            maxSatisfaction += dishSum\\n        \\n        return maxSatisfaction",
                "codeTag": "Java"
            },
            {
                "id": 1433277,
                "title": "java-easy-concise-o-nlogn-time-o-1-space",
                "content": "**Runtime: 1 ms, faster than 99.33% of Java online submissions for Reducing Dishes.\\nMemory Usage: 37.4 MB, less than 41.07% of Java online submissions for Reducing Dishes.**\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        int total = 0,res = 0;\\n        Arrays.sort(satisfaction);\\n        for(int i = satisfaction.length-1;i >= 0 && satisfaction[i] > -total;i--){\\n            total += satisfaction[i];\\n            res += total;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        int total = 0,res = 0;\\n        Arrays.sort(satisfaction);\\n        for(int i = satisfaction.length-1;i >= 0 && satisfaction[i] > -total;i--){\\n            total += satisfaction[i];\\n            res += total;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175953,
                "title": "javascript-99",
                "content": "hy, guys ! it\\'s my first topic in leetcode\\n```\\nvar maxSatisfaction = function(arr) {\\n    arr.sort((a,b)=>a-b);\\n    let max = arr.reduce((a,b,i)=>a+b*(i+1));\\n    let sum = arr.reduce((a,b)=>a+b,0);\\n    for(let i=0;i<arr.length;i++){\\n        if(max>max-sum)\\n            return max;\\n        max-=sum;\\n        sum-=arr[i];\\n    }\\n    return 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSatisfaction = function(arr) {\\n    arr.sort((a,b)=>a-b);\\n    let max = arr.reduce((a,b,i)=>a+b*(i+1));\\n    let sum = arr.reduce((a,b)=>a+b,0);\\n    for(let i=0;i<arr.length;i++){\\n        if(max>max-sum)\\n            return max;\\n        max-=sum;\\n        sum-=arr[i];\\n    }\\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136818,
                "title": "100-fast-greedy-and-dp-easy-solution",
                "content": "**GREEDY SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end(), greater <int> () );\\n        if (satisfaction[0] <=  0) return 0; \\n        int ans = 0;\\n        int total = 0;\\n        for (int i = 0; i < satisfaction.size(); i++) {\\n            if (total + ans + satisfaction[i] > total) {\\n                ans = ans + satisfaction[i];\\n                total = total + ans;\\n                continue;\\n                \\n            } \\n            return total;\\n        }\\n        return total;\\n    }\\n};\\n```\\n**DYNAMIC PROGRAMMING SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    vector < vector <int> > dp;\\n    int recur(vector <int>& a, int n, int m) {\\n        if (n >= a.size()) {\\n            return 0;\\n        }\\n        if (dp[n][m] != -1) {\\n            return dp[n][m];\\n        }\\n        return dp[n][m] = max(recur(a, n + 1, m + 1) + m*a[n], recur(a, n + 1, m));\\n    }\\n    int maxSatisfaction(vector<int>& a) {\\n        sort(a.begin(), a.end());\\n        dp.assign(a.size() + 1, vector <int> (a.size() + 1, -1) );\\n        return recur(a, 0, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end(), greater <int> () );\\n        if (satisfaction[0] <=  0) return 0; \\n        int ans = 0;\\n        int total = 0;\\n        for (int i = 0; i < satisfaction.size(); i++) {\\n            if (total + ans + satisfaction[i] > total) {\\n                ans = ans + satisfaction[i];\\n                total = total + ans;\\n                continue;\\n                \\n            } \\n            return total;\\n        }\\n        return total;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector < vector <int> > dp;\\n    int recur(vector <int>& a, int n, int m) {\\n        if (n >= a.size()) {\\n            return 0;\\n        }\\n        if (dp[n][m] != -1) {\\n            return dp[n][m];\\n        }\\n        return dp[n][m] = max(recur(a, n + 1, m + 1) + m*a[n], recur(a, n + 1, m));\\n    }\\n    int maxSatisfaction(vector<int>& a) {\\n        sort(a.begin(), a.end());\\n        dp.assign(a.size() + 1, vector <int> (a.size() + 1, -1) );\\n        return recur(a, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050367,
                "title": "recursive-dp-solution-in-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[700][700];\\n\\t\\t\\n\\t\\tint fun(vector<int>& a,int i,int c){\\n\\t\\t\\tif(i==a.size()) return 0;\\n\\t\\t\\tif(dp[i][c]!=-1) return dp[i][c];\\n\\t\\t\\treturn dp[i][c]=max(a[i]*c+fun(a,i+1,c+1),fun(a,i+1,c)); \\n\\t\\t}\\n\\n\\t\\tint maxSatisfaction(vector<int>& a) {\\n\\t\\t\\tmemset(dp,-1,sizeof(dp));\\n\\t\\t\\tsort(a.begin(),a.end());\\n\\t\\t\\treturn fun(a,0,1);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[700][700];\\n\\t\\t\\n\\t\\tint fun(vector<int>& a,int i,int c){\\n\\t\\t\\tif(i==a.size()) return 0;\\n\\t\\t\\tif(dp[i][c]!=-1) return dp[i][c];\\n\\t\\t\\treturn dp[i][c]=max(a[i]*c+fun(a,i+1,c+1),fun(a,i+1,c)); \\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 804795,
                "title": "java-beat-100-by-sorting-then-starting-from-the-end",
                "content": "After the satisfactions are sorted in `O(nlog(n))`, the goal is to have the highest satisfaction to have the highest index. To check all possibilities in `O(n)`, the trick is that you assume that you only prepare the most satisfactory meal, then prepend all the other meals one by one. At each iteration, you add the `increment` to the currentSum. You then add the current value to the `increment`. \\nFinally you return the maximum of all n `currentSum` that you saw. The time complexity is `O(nlog(n))`.\\n\\n```java\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        \\n        Arrays.sort(satisfaction);\\n        \\n        int currentSum = 0;\\n        int maxSum = 0;\\n        int increment = 0;\\n        int i = satisfaction.length - 1;\\n        \\n        while (i >= 0) {\\n            increment += satisfaction[i];\\n            currentSum += increment;\\n            maxSum = Math.max(currentSum, maxSum);\\n            --i;\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        \\n        Arrays.sort(satisfaction);\\n        \\n        int currentSum = 0;\\n        int maxSum = 0;\\n        int increment = 0;\\n        int i = satisfaction.length - 1;\\n        \\n        while (i >= 0) {\\n            increment += satisfaction[i];\\n            currentSum += increment;\\n            maxSum = Math.max(currentSum, maxSum);\\n            --i;\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615879,
                "title": "dp-solution-c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int> sat,int k,int in,int n,vector<vector<int> > &dp){\\n        if(in==n) return 0;\\n        if(dp[in][k]!=-1) return dp[in][k];\\n        int ans=sat[in]*k+fun(sat,k+1,in+1,n,dp);\\n        int ans1=fun(sat,k,in+1,n,dp);\\n        return dp[in][k]=max(ans,ans1);\\n    }\\n    int maxSatisfaction(vector<int>& sat) {\\n        int n=sat.size();\\n        vector<vector<int> > dp(n+1,vector<int>(n+4));\\n        sort(sat.begin(),sat.end());\\n        for(int i=n;i>=0;i--){\\n            for(int k=n;k>=1;k--){\\n                if(i==n){\\n                    dp[i][k]=0;\\n                }\\n                else{\\n                    int ans=sat[i]*k+dp[i+1][k+1];\\n                    int ans2=dp[i+1][k];\\n                    dp[i][k]=max(ans,ans2);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][1];\\n        //return fun(satisfaction,1,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int> sat,int k,int in,int n,vector<vector<int> > &dp){\\n        if(in==n) return 0;\\n        if(dp[in][k]!=-1) return dp[in][k];\\n        int ans=sat[in]*k+fun(sat,k+1,in+1,n,dp);\\n        int ans1=fun(sat,k,in+1,n,dp);\\n        return dp[in][k]=max(ans,ans1);\\n    }\\n    int maxSatisfaction(vector<int>& sat) {\\n        int n=sat.size();\\n        vector<vector<int> > dp(n+1,vector<int>(n+4));\\n        sort(sat.begin(),sat.end());\\n        for(int i=n;i>=0;i--){\\n            for(int k=n;k>=1;k--){\\n                if(i==n){\\n                    dp[i][k]=0;\\n                }\\n                else{\\n                    int ans=sat[i]*k+dp[i+1][k+1];\\n                    int ans2=dp[i+1][k];\\n                    dp[i][k]=max(ans,ans2);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][1];\\n        //return fun(satisfaction,1,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588401,
                "title": "python-recursive-and-dp-solution-100-in-memory",
                "content": "Both solutions use memory less than 100% submission.\\n\\nTo solve the problem, it is obvious that if you want to make a dish with a negative value, make it as early as you can, vice versa. So the `satisfaction` array is sorted at first.\\n\\nThe recursive solution is to try all the combinations of `(i, time)` which means in `time` to cook dish `i` or not, corresponding to `A` and `B`, `B` doesn\\'t increase `time`.\\n```\\ndef maxSatisfaction(self, satisfaction: List[int]) -> int:\\n\\tsatisfaction.sort()\\n\\tlength = len(satisfaction)\\n\\tmem = defaultdict(int)\\n\\tdef func(i, time, satis):\\n\\t\\tif i >= length:\\n\\t\\t\\treturn 0\\n\\t\\telif (i, time) in mem:\\n\\t\\t\\treturn mem[(i, time)]\\n\\t\\telse:\\n\\t\\t\\tA = func(i+1, time+1, satis) + time*satis[i]\\n\\t\\t\\tB = func(i+1, time, satis)\\n\\t\\t\\tmem[(i, time)] = max(A, B)\\n\\t\\t\\treturn mem[(i, time)]\\n\\n\\treturn func(0, 1, satisfaction)\\n```\\n\\nIn the DP solution, a `dp` matrix of NxN size is initialized to represent whether cook dish `d` (column) in time `t` (row).\\nIt could be seen that it\\'s meaningless to cook `d` when `t > d` as the smaller scores should be adopted as early as it can. So only O(NxN/2) calculation is needed.\\nFinally, find the maximum in the whole `dp` matrix. The `0` case is added to the final statement in case all the dishes are negative and just not to cook them all.\\n\\n```\\ndef maxSatisfaction(self, satisfaction: List[int]) -> int:\\n\\tsatisfaction.sort()\\n\\tlength = len(satisfaction)\\n\\tdp = [[0 for _ in range(length)] for _ in range(length)]\\n\\tfor d in range(length):\\n\\t\\tdp[0][d] = satisfaction[d]\\n\\tfor t in range(1, length):\\n\\t\\tfor d in range(t, length):\\n\\t\\t\\tdp[t][d] = dp[t-1][d-1] + satisfaction[d] * (t+1)\\n\\treturn max([ele for row in dp for ele in row]+[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\ndef maxSatisfaction(self, satisfaction: List[int]) -> int:\\n\\tsatisfaction.sort()\\n\\tlength = len(satisfaction)\\n\\tmem = defaultdict(int)\\n\\tdef func(i, time, satis):\\n\\t\\tif i >= length:\\n\\t\\t\\treturn 0\\n\\t\\telif (i, time) in mem:\\n\\t\\t\\treturn mem[(i, time)]\\n\\t\\telse:\\n\\t\\t\\tA = func(i+1, time+1, satis) + time*satis[i]\\n\\t\\t\\tB = func(i+1, time, satis)\\n\\t\\t\\tmem[(i, time)] = max(A, B)\\n\\t\\t\\treturn mem[(i, time)]\\n\\n\\treturn func(0, 1, satisfaction)\\n```\n```\\ndef maxSatisfaction(self, satisfaction: List[int]) -> int:\\n\\tsatisfaction.sort()\\n\\tlength = len(satisfaction)\\n\\tdp = [[0 for _ in range(length)] for _ in range(length)]\\n\\tfor d in range(length):\\n\\t\\tdp[0][d] = satisfaction[d]\\n\\tfor t in range(1, length):\\n\\t\\tfor d in range(t, length):\\n\\t\\t\\tdp[t][d] = dp[t-1][d-1] + satisfaction[d] * (t+1)\\n\\treturn max([ele for row in dp for ele in row]+[0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 563638,
                "title": "recursive-memoization-solution",
                "content": "You basically have 2 choices to be made, either select 1 or skip it. When you skip, the coefficient shouldn\\'t increment\\n\\n```\\nT.C => 2^n without memoization\\nT.C => n^2 with memoization\\n```\\n\\n```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:     \\n\\t\\tsatisfaction.sort()\\n        cache = [[float(\\'inf\\')] * (len(satisfaction) + 1) for _ in range(len(satisfaction))]\\n        \\n        def rec_helper(idx, coef):\\n            if idx == len(satisfaction):\\n                return 0\\n            \\n            if cache[idx][coef] != float(\\'inf\\'):\\n                return cache[idx][coef]\\n            \\n            v1 = satisfaction[idx] * coef + rec_helper(idx + 1, coef + 1) # select\\n            v2 = rec_helper(idx + 1, coef) # dont select\\n            cache[idx][coef] = max(v1, v2)\\n            return cache[idx][coef]\\n\\n        return rec_helper(0, 1)\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nT.C => 2^n without memoization\\nT.C => n^2 with memoization\\n```\n```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:     \\n\\t\\tsatisfaction.sort()\\n        cache = [[float(\\'inf\\')] * (len(satisfaction) + 1) for _ in range(len(satisfaction))]\\n        \\n        def rec_helper(idx, coef):\\n            if idx == len(satisfaction):\\n                return 0\\n            \\n            if cache[idx][coef] != float(\\'inf\\'):\\n                return cache[idx][coef]\\n            \\n            v1 = satisfaction[idx] * coef + rec_helper(idx + 1, coef + 1) # select\\n            v2 = rec_helper(idx + 1, coef) # dont select\\n            cache[idx][coef] = max(v1, v2)\\n            return cache[idx][coef]\\n\\n        return rec_helper(0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913414,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        if(v[v.size()-1]<0) return 0;\\n        int ind=-1,sum=0,mx=0;\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]>=0){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        while(ind!=-1){\\n        int j=1;\\n        for(int i=ind;i<v.size();i++){\\n                sum+= v[i]*j;\\n                j++;\\n        }\\n        mx=max(mx,sum);\\n        if(sum>=mx){\\n            ind--;\\n            sum=0;\\n        }\\n        else {\\n            break;\\n        }\\n            }\\n            return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        if(v[v.size()-1]<0) return 0;\\n        int ind=-1,sum=0,mx=0;\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]>=0){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        while(ind!=-1){\\n        int j=1;\\n        for(int i=ind;i<v.size();i++){\\n                sum+= v[i]*j;\\n                j++;\\n        }\\n        mx=max(mx,sum);\\n        if(sum>=mx){\\n            ind--;\\n            sum=0;\\n        }\\n        else {\\n            break;\\n        }\\n            }\\n            return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705417,
                "title": "easy-cpp-solution-100-beats-detailed-stepwise-explanation-no-dynamic-programing-no-dp-no-greedy",
                "content": "# Intuition\\nWhen I tried some testcases in my notebook i found a pattern that uptill the sum of satisfaction is positive, we get the sum value as maximum just before we get our satisfaction sum negative(after sorting).\\n\\n# Approach\\n\\n1. Sort the `satisfaction` vector in non-decreasing order using `sort(satisfaction.begin(), satisfaction.end())`. This step ensures that the elements are arranged in ascending order.\\n\\n2. Initialize variables `n` as the size of the `satisfaction` vector, `start` as 0, `sum` as 0, `result` as 0, and `k` as 1. These variables will be used to keep track of the starting index, the cumulative satisfaction sum, the final result, and the multiplier for each satisfaction value, respectively.\\n\\n3. Iterate through the `satisfaction` vector in reverse order, starting from `i = n - 1` down to 0:\\n   - Add the current element `satisfaction[i]` to the `sum` variable.\\n   - Check if the `sum` is less than 0. If it is, set `start` as `i + 1` and break out of the loop. This step identifies the index from where we can start including elements in the result.\\n\\n4. Iterate through the `satisfaction` vector starting from index `start` up to `n - 1`:\\n   - Add `satisfaction[i]` multiplied by `k` to the `result` variable.\\n   - Increment `k` by 1 in each iteration to increase the multiplier for each subsequent satisfaction value.\\n\\n5. Return the final `result`, which represents the maximum satisfaction achievable.\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        int n=satisfaction.size();\\n        int start=0;\\n        int sum=0;\\n        int result=0;\\n        int k=1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            sum+=satisfaction[i];\\n            if(sum<0)\\n            {\\n                start=i+1;\\n                break;\\n            }\\n        }\\n        for(int i=start;i<n;i++)\\n        {\\n            result+=satisfaction[i]*(k++);\\n        }\\n        return result;\\n    }\\n};\\n```\\n# Please upvote for better reach.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        int n=satisfaction.size();\\n        int start=0;\\n        int sum=0;\\n        int result=0;\\n        int k=1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            sum+=satisfaction[i];\\n            if(sum<0)\\n            {\\n                start=i+1;\\n                break;\\n            }\\n        }\\n        for(int i=start;i<n;i++)\\n        {\\n            result+=satisfaction[i]*(k++);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618178,
                "title": "c-sorting-and-reverse-prefix-sum-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n = s.size(), i = 0;\\n        sort(s.begin(), s.end());\\n        \\n        int ans = 0, sum = 0;\\n        \\n        for(int i = 0;i<n;i++) sum+= s[i]*(i+1); // find initail cofficient by taking each dish\\n        for(int i = n-2;i>=0;i--) s[i]+=s[i+1];  // take reverse prefix sum\\n        \\n        i = 0;\\n        \\n\\t\\t// this is similar to removing commulative sum from original until it increases if the number are -ve.\\n        while(i<n){\\n            ans = sum;\\n            sum-=s[i++];\\n            if(sum>ans) ans = sum;\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n = s.size(), i = 0;\\n        sort(s.begin(), s.end());\\n        \\n        int ans = 0, sum = 0;\\n        \\n        for(int i = 0;i<n;i++) sum+= s[i]*(i+1); // find initail cofficient by taking each dish\\n        for(int i = n-2;i>=0;i--) s[i]+=s[i+1];  // take reverse prefix sum\\n        \\n        i = 0;\\n        \\n\\t\\t// this is similar to removing commulative sum from original until it increases if the number are -ve.\\n        while(i<n){\\n            ans = sum;\\n            sum-=s[i++];\\n            if(sum>ans) ans = sum;\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357932,
                "title": "c-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& a) {\\n        sort(a.rbegin(),a.rend());\\n        int n = a.size();\\n\\n        long long total=0;\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            if(total+ sum+a[i] >=total){\\n                total+= (sum+a[i]);\\n            }\\n            else break;\\n            sum+=a[i];\\n        }\\n    return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& a) {\\n        sort(a.rbegin(),a.rend());\\n        int n = a.size();\\n\\n        long long total=0;\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            if(total+ sum+a[i] >=total){\\n                total+= (sum+a[i]);\\n            }\\n            else break;\\n            sum+=a[i];\\n        }\\n    return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357154,
                "title": "c-solution-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int ind, int time , vector<int>&stf,vector<vector<int>>&dp){\\n        if(ind<0){\\n            return 0;\\n        }\\n        if(dp[ind][time]!=-1){\\n            return dp[ind][time];\\n        }\\n        int take = stf[ind]*time+solve(ind-1,time+1,stf,dp);\\n        int notTake = solve(ind-1,time,stf,dp);\\n        return dp[ind][time] = max(take,notTake);\\n\\n    }\\n    int maxSatisfaction(vector<int>& stf) {\\n        int n = stf.size();\\n        sort(stf.begin(),stf.end(),greater<int>());\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return max(0,solve(n-1,1,stf,dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int ind, int time , vector<int>&stf,vector<vector<int>>&dp){\\n        if(ind<0){\\n            return 0;\\n        }\\n        if(dp[ind][time]!=-1){\\n            return dp[ind][time];\\n        }\\n        int take = stf[ind]*time+solve(ind-1,time+1,stf,dp);\\n        int notTake = solve(ind-1,time,stf,dp);\\n        return dp[ind][time] = max(take,notTake);\\n\\n    }\\n    int maxSatisfaction(vector<int>& stf) {\\n        int n = stf.size();\\n        sort(stf.begin(),stf.end(),greater<int>());\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return max(0,solve(n-1,1,stf,dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357081,
                "title": "python-shortest-1-liner-greedy-o-n-log-n-functional-programming",
                "content": "# Approach\\nTL;DR, Same as the [Official solution. Approach 4](https://leetcode.com/problems/reducing-dishes/editorial/) but written using functional programming.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n\\n- Space complexity: $$O(1)$$ for inplace sort else $$O(n)$$\\n\\nwhere, `n is length of satisfaction array`.\\n\\n# Code\\n1-liner:\\n```python\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: list[int]) -> int:\\n        return sum(takewhile(lambda x: x >= 0, accumulate(sorted(satisfaction, reverse=True))))\\n\\n\\n```\\n\\nMulti-liner for readability:\\n```python\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: list[int]) -> int:\\n        sorted_satisfaction = sorted(satisfaction, reverse=True)\\n        suffix_sums         = accumulate(sorted_satisfactions)\\n        non_neg_suffix_sums = takewhile(lambda x: x >= 0, suffix_sums)\\n        max_like_time_coeff = sum(non_neg_suffix_sums)\\n        return max_like_time_coeff\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: list[int]) -> int:\\n        return sum(takewhile(lambda x: x >= 0, accumulate(sorted(satisfaction, reverse=True))))\\n\\n\\n```\n```python\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: list[int]) -> int:\\n        sorted_satisfaction = sorted(satisfaction, reverse=True)\\n        suffix_sums         = accumulate(sorted_satisfactions)\\n        non_neg_suffix_sums = takewhile(lambda x: x >= 0, suffix_sums)\\n        max_like_time_coeff = sum(non_neg_suffix_sums)\\n        return max_like_time_coeff\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356540,
                "title": "java-solution-easy-understanding-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to multiple negative number with smallest number and the negative number should be neglected too.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the array\\n2. Now start calculating the sum of array element from last and do this till the sum > 0\\n3. As sum < 0 we need to break the loop and store the value of i at which we break the loop.\\n4. Now starting from that ith position till the end of array start doing the final sum as k*arr[j].\\n5. At last return the final sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int n=satisfaction.length;\\n        int sum=0,point=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            sum+=satisfaction[i];\\n            if(sum<0)\\n                break;\\n            \\n            point-=1;\\n        }\\n        point+=1;\\n        int ans=0,k=1;\\n        for(int i=point;i<n;i++){\\n            ans+=(k++ * satisfaction[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int n=satisfaction.length;\\n        int sum=0,point=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            sum+=satisfaction[i];\\n            if(sum<0)\\n                break;\\n            \\n            point-=1;\\n        }\\n        point+=1;\\n        int ans=0,k=1;\\n        for(int i=point;i<n;i++){\\n            ans+=(k++ * satisfaction[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356358,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int ans = 0;\\n        for(int i=0; i<satisfaction.size(); i++) {\\n            int sum = 0, cnt = 1;\\n            for(int j=i; j<satisfaction.size(); j++) {\\n                sum += satisfaction[j] * cnt;\\n                cnt++;\\n            }\\n            ans = max(ans, sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int ans = 0;\\n        for(int i=0; i<satisfaction.size(); i++) {\\n            int sum = 0, cnt = 1;\\n            for(int j=i; j<satisfaction.size(); j++) {\\n                sum += satisfaction[j] * cnt;\\n                cnt++;\\n            }\\n            ans = max(ans, sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356255,
                "title": "1402-reducing-dishes",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        vector<int>t=satisfaction;\\n        sort(t.begin(),t.end());\\n        reverse(t.begin(),t.end());\\n        int sum=0,ans=0;\\n        for(int i=0;i<t.size();i++){\\n            if(sum+t[i]>0){\\n                ans+=sum+t[i];\\n                sum+=t[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        vector<int>t=satisfaction;\\n        sort(t.begin(),t.end());\\n        reverse(t.begin(),t.end());\\n        int sum=0,ans=0;\\n        for(int i=0;i<t.size();i++){\\n            if(sum+t[i]>0){\\n                ans+=sum+t[i];\\n                sum+=t[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356137,
                "title": "java-easy-sort-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxSatisfaction(int[] satisfaction) {\\n    Arrays.sort(satisfaction);\\n    int sum = 0, tot = 0, maxi = 0;\\n    \\n    for(int i = satisfaction.length - 1; i >= 0 && sum >= 0; --i){\\n      tot += sum + satisfaction[i];\\n      sum += satisfaction[i];\\n      if( tot > maxi) maxi = tot;\\n    }\\n    \\n    return maxi;      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxSatisfaction(int[] satisfaction) {\\n    Arrays.sort(satisfaction);\\n    int sum = 0, tot = 0, maxi = 0;\\n    \\n    for(int i = satisfaction.length - 1; i >= 0 && sum >= 0; --i){\\n      tot += sum + satisfaction[i];\\n      sum += satisfaction[i];\\n      if( tot > maxi) maxi = tot;\\n    }\\n    \\n    return maxi;      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355568,
                "title": "c-10-lines-of-code-very-easy-understanding",
                "content": "# Approach :\\nStep 1: sort the given array\\nStep 2: we have to make a decision to take the element or not such that result we get is maximised.\\n2.1 if we take , we need to perform arr[i]*time + solve(i+1,time+1)\\n2.2. if we dont take , we need to perform solve(i+1,time).\\n\\nreturn the max(arr[i]*time + solve(i+1,time+1),solve(i+1,time))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<int>& arr,int time,vector<vector<int>>&dp)\\n    {\\n        if(i==j)\\n        return 0;\\n        if(dp[i][time]!=-1)\\n        return dp[i][time];\\n\\n        return dp[i][time]=max(arr[i]*time+solve(i+1,j,arr,time+1,dp),solve(i+1,j,arr,time,dp));\\n    }\\n    int maxSatisfaction(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n        sort(arr.begin(),arr.end());\\n        \\n        return solve(0,n,arr,1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<int>& arr,int time,vector<vector<int>>&dp)\\n    {\\n        if(i==j)\\n        return 0;\\n        if(dp[i][time]!=-1)\\n        return dp[i][time];\\n\\n        return dp[i][time]=max(arr[i]*time+solve(i+1,j,arr,time+1,dp),solve(i+1,j,arr,time,dp));\\n    }\\n    int maxSatisfaction(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n        sort(arr.begin(),arr.end());\\n        \\n        return solve(0,n,arr,1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355369,
                "title": "time-space-100-beats-easy-to-understand-c",
                "content": "![image](https://assets.leetcode.com/users/images/c20b4481-51c5-4bd3-a0b2-9bd5b52f4555_1680090904.113372.png)\\n````\\nclass Solution {\\npublic:\\n    bool static cmp(int &a,int &b){\\n        return a>b;\\n    }\\n    int maxSatisfaction(vector<int>& v) {\\n        int ans = 0;\\n        sort(v.begin(),v.end(),cmp);\\n        for(int i = 1; i < v.size(); i++){\\n            v[i] += v[i-1];\\n        }\\n        int sum = 0;\\n        for(auto &i: v){\\n            sum += i;\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    bool static cmp(int &a,int &b){\\n        return a>b;\\n    }\\n    int maxSatisfaction(vector<int>& v) {\\n        int ans = 0;\\n        sort(v.begin(),v.end(),cmp);\\n        for(int i = 1; i < v.size(); i++){\\n            v[i] += v[i-1];\\n        }\\n        int sum = 0;\\n        for(auto &i: v){\\n            sum += i;\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355099,
                "title": "python3-easy-and-understandable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe algorithm used in this solution is based on sorting the satisfaction list in descending order and iterating over it. At each iteration, the satisfaction of the current dish is added to a running sum sum, and if this sum is positive, it is added to the answer ans. This guarantees that the algorithm always considers the best dishes to cook, which are the ones with higher satisfaction values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThe time complexity of this solution is O(nlogn), where n is the length of the input list satisfaction. This is because of the sorting operation performed at the beginning of the algorithm. However, this is an efficient solution for the problem, as there is no other way to get the optimal solution without iterating over all possible combinations of dishes, which would require an exponential time complexity.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        dishes=sorted(satisfaction, reverse=True)\\n        ans=0\\n        flag=0\\n\\n        for i in dishes:\\n            if(flag+i>0):\\n                ans+=flag+i\\n                flag+=i\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        dishes=sorted(satisfaction, reverse=True)\\n        ans=0\\n        flag=0\\n\\n        for i in dishes:\\n            if(flag+i>0):\\n                ans+=flag+i\\n                flag+=i\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354978,
                "title": "java-easy-understanding-simple-recursion-sorting-dp-memoization",
                "content": "RECURSION APPROACH,IT WILL GIVE A TLE\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] s) {\\n        Arrays.sort(s);\\n        return check(s,0,1);\\n    }\\n    public static int check(int s[],int ind,int t){\\n        if(ind>=s.length) return 0;\\n        int pick=(s[ind]*t)+check(s,ind+1,t+1);\\n        int not=check(s,ind+1,t);\\n        return Math.max(pick,not);\\n    }\\n}\\n```\\n\\nMEMOIZATION APPROACH,FULLY WORKING\\n\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] s) {\\n        Arrays.sort(s);\\n        int dp[][]=new int[s.length+1][s.length+1];\\n        return check(s,0,1,dp);\\n        \\n    }\\n    public static int check(int s[],int ind,int t,int dp[][]){\\n        if(ind>=s.length) return 0;\\n        if(dp[ind][t]!=0) return dp[ind][t];\\n        int pick=(s[ind]*t)+check(s,ind+1,t+1,dp);\\n        int not=check(s,ind+1,t,dp);\\n        return dp[ind][t]=Math.max(pick,not);\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE IDEA",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] s) {\\n        Arrays.sort(s);\\n        return check(s,0,1);\\n    }\\n    public static int check(int s[],int ind,int t){\\n        if(ind>=s.length) return 0;\\n        int pick=(s[ind]*t)+check(s,ind+1,t+1);\\n        int not=check(s,ind+1,t);\\n        return Math.max(pick,not);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] s) {\\n        Arrays.sort(s);\\n        int dp[][]=new int[s.length+1][s.length+1];\\n        return check(s,0,1,dp);\\n        \\n    }\\n    public static int check(int s[],int ind,int t,int dp[][]){\\n        if(ind>=s.length) return 0;\\n        if(dp[ind][t]!=0) return dp[ind][t];\\n        int pick=(s[ind]*t)+check(s,ind+1,t+1,dp);\\n        int not=check(s,ind+1,t,dp);\\n        return dp[ind][t]=Math.max(pick,not);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354925,
                "title": "easy-solution-with-explanation",
                "content": "# Approach\\nApproach is very simple. Just think greedily that how you can maximise your *like-time coefficient*(time*satisfaction_value). What i can think is i should assign more time to dishes which has more satisfaction value. Hence, sort the given vector and start assigning time from 0th index. \\nProblem arises when values are negative which will decrease our required value, for that we can take decision whether a particular dish(which has negative value) we should make or not.\\nNow, calculate sum of *like-time coefficient* from 0th index then iterate a nested loop which will calculate ans from 1st index till we reach last index and return maximum out of all.\\nTake a look at Code written below, i hope it will help you.\\n/\\n/\\n-   upVote if you understand my solution, Thanks !\\n- Think more, Code less !!\\n# Complexity\\n- Time complexity:  O(n*n)\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& v) {\\n        int i=0,ans=0,n=v.size();\\n        sort(v.begin(),v.end());\\n        while(i<n){\\n            int cnt=1;\\n            int res=0,j=i;\\n            while(j<n){\\n                res+=cnt*v[j];\\n                cnt++;\\n                j++;\\n            }\\n            ans=max(ans,res);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& v) {\\n        int i=0,ans=0,n=v.size();\\n        sort(v.begin(),v.end());\\n        while(i<n){\\n            int cnt=1;\\n            int res=0,j=i;\\n            while(j<n){\\n                res+=cnt*v[j];\\n                cnt++;\\n                j++;\\n            }\\n            ans=max(ans,res);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354455,
                "title": "recursion-memoization-slow-dp-solution-top-down",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int> & a, int ind,int cnt,vector<vector<int>>& dp){\\n        if(ind >= a.size()){\\n            return 0;\\n        }\\n        if(dp[ind][cnt]!=-1){\\n            return dp[ind][cnt];\\n        }\\n        int take = (a[ind]*cnt) + solve(a,ind+1,cnt+1,dp);\\n        int notTake = solve(a,ind+1,cnt,dp);\\n        return dp[ind][cnt] = max(take,notTake);\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(),satisfaction.end());\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n        return solve(satisfaction,0,1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(vector<int> & a, int ind,int cnt,vector<vector<int>>& dp){\\n        if(ind >= a.size()){\\n            return 0;\\n        }\\n        if(dp[ind][cnt]!=-1){\\n            return dp[ind][cnt];\\n        }\\n        int take = (a[ind]*cnt) + solve(a,ind+1,cnt+1,dp);\\n        int notTake = solve(a,ind+1,cnt,dp);\\n        return dp[ind][cnt] = max(take,notTake);\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(),satisfaction.end());\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n        return solve(satisfaction,0,1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354234,
                "title": "python-o-nlogn-solution-for-reference",
                "content": "```\\nclass Solution:\\n    def maxSatisfaction(self, sat: List[int]) -> int:\\n        sat = sorted(sat)\\n        \\n        sm, res , idx , nend = 0,0,1,-1\\n        for i in range(0,len(sat)):\\n            if(sat[i] >= 0 ):\\n                sm += sat[i]\\n                res += sat[i]*idx \\n                idx += 1\\n            if(i>0 and sat[i] >= 0 and sat[i-1] < 0 ):\\n                nend = i-1 ; \\n        \\n        while nend >=0 :\\n            if( res+sm+sat[nend] > res ):\\n                res = res+sm+sat[nend]\\n                sm = sm + sat[nend]\\n                nend -= 1\\n            else:\\n                break;\\n        return res\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, sat: List[int]) -> int:\\n        sat = sorted(sat)\\n        \\n        sm, res , idx , nend = 0,0,1,-1\\n        for i in range(0,len(sat)):\\n            if(sat[i] >= 0 ):\\n                sm += sat[i]\\n                res += sat[i]*idx \\n                idx += 1\\n            if(i>0 and sat[i] >= 0 and sat[i-1] < 0 ):\\n                nend = i-1 ; \\n        \\n        while nend >=0 :\\n            if( res+sm+sat[nend] > res ):\\n                res = res+sm+sat[nend]\\n                sm = sm + sat[nend]\\n                nend -= 1\\n            else:\\n                break;\\n        return res\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354127,
                "title": "dp-using-memorization-c-simple-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want lower values of satisfaction to be selected at smaller value fo time to maximize the answer, so we sort it. Then, we can either pick a dish to cook it or else notpick it. Now for memorization part we found many same recursion calls made for some index at same value of time. Memorize it accordingly. \\nTHAT\\'S IT, you got what you needed.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)+O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp(int in,vector<int>& s,int time,vector<vector<int>>& dpA){\\n        if(in==s.size())return 0;\\n        if(dpA[in][time]!=-1)return dpA[in][time];\\n        // pick\\n        int pick=INT_MIN,notPick=INT_MIN;\\n        pick=(time*s[in])+dp(in+1,s,time+1,dpA);\\n        // not pick\\n        notPick=dp(in+1,s,time,dpA);\\n        return dpA[in][time]=max(pick,notPick);\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        vector<vector<int>> dpA(satisfaction.size(),vector<int>(satisfaction.size()+1,-1));\\n        sort(satisfaction.begin(),satisfaction.end());\\n        return dp(0,satisfaction,1,dpA);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp(int in,vector<int>& s,int time,vector<vector<int>>& dpA){\\n        if(in==s.size())return 0;\\n        if(dpA[in][time]!=-1)return dpA[in][time];\\n        // pick\\n        int pick=INT_MIN,notPick=INT_MIN;\\n        pick=(time*s[in])+dp(in+1,s,time+1,dpA);\\n        // not pick\\n        notPick=dp(in+1,s,time,dpA);\\n        return dpA[in][time]=max(pick,notPick);\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        vector<vector<int>> dpA(satisfaction.size(),vector<int>(satisfaction.size()+1,-1));\\n        sort(satisfaction.begin(),satisfaction.end());\\n        return dp(0,satisfaction,1,dpA);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353860,
                "title": "c-30ms-9-3-mb",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int help(vector<int>& satis,int i,int time){\\n        if(i>=satis.size()){\\n            return 0;\\n        }\\n        if(dp[i][time]!=-1){\\n            return dp[i][time];\\n        }\\n        int take=help(satis,i+1,time+1)+satis[i]*time;\\n        int notake=help(satis,i+1,time);\\n        return dp[i][time]=max(take,notake);\\n    }\\n    int maxSatisfaction(vector<int>& satis) {\\n        sort(satis.begin(),satis.end());\\n        memset(dp,-1,sizeof(dp));\\n        return help(satis,0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int help(vector<int>& satis,int i,int time){\\n        if(i>=satis.size()){\\n            return 0;\\n        }\\n        if(dp[i][time]!=-1){\\n            return dp[i][time];\\n        }\\n        int take=help(satis,i+1,time+1)+satis[i]*time;\\n        int notake=help(satis,i+1,time);\\n        return dp[i][time]=max(take,notake);\\n    }\\n    int maxSatisfaction(vector<int>& satis) {\\n        sort(satis.begin(),satis.end());\\n        memset(dp,-1,sizeof(dp));\\n        return help(satis,0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353699,
                "title": "easy-dp-solution-based-on-the-concept-of-knapsack",
                "content": "# Intuition\\nLooking at the problem carefully it looks like a typical 0/1 knapsack problem where we have 2 choices - either take the element or don\\'t take it.\\n\\n# Approach\\nBefore doing anything just sort the array in ascending order. Then check if the last element of the array is negative. \\n**If** the last element is negative, then return 0, since all the elements are negative the ```time * satisfaction[i]``` will result in negative which is definitely less than 0.\\n\\n**Else**\\nWe will be using top down DP to solve this problem. Before declaring the dp vector, we must look at transition states and they are- ```index``` of the given array and ```time```. Therefore, declare an dp array of size ```n * (n+1)```. ```index``` ranges from 0 to n-1 and ```time``` ranges from **1 to n**.\\nThe code is exactly same as that of the 0/1 knapsack with a subtle change\\n```cpp\\nint skipDish = f(i+1, time, satisfaction, dp);\\nint cookDish = time * satisfaction[i] + f(i+1, time+1, satisfaction, dp);\\nreturn dp[i][time] = max(skipDish, cookDish);\\n```\\n\\nReturn the maximum of 2 choices.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int f(int i, int time, vector<int>& satisfaction, vector<vector<int>>& dp) {\\n        if(i == satisfaction.size()) return 0;\\n        if(dp[i][time] != -1) return dp[i][time];\\n\\n        int skipDish = f(i+1, time, satisfaction, dp);\\n        int cookDish = time * satisfaction[i] + f(i+1, time+1, satisfaction, dp);\\n\\n        return dp[i][time] = max(skipDish, cookDish);\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n\\n        // if all the elements are negative return 0\\n        if(satisfaction[n-1] < 0) return 0;\\n\\n        // dp transition states  - index and time\\n        // time can range from 1 to n\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n        int startTime = 1;\\n        return f(0, startTime, satisfaction, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```time * satisfaction[i]```\n```index```\n```time```\n```n * (n+1)```\n```index```\n```time```\n```cpp\\nint skipDish = f(i+1, time, satisfaction, dp);\\nint cookDish = time * satisfaction[i] + f(i+1, time+1, satisfaction, dp);\\nreturn dp[i][time] = max(skipDish, cookDish);\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int f(int i, int time, vector<int>& satisfaction, vector<vector<int>>& dp) {\\n        if(i == satisfaction.size()) return 0;\\n        if(dp[i][time] != -1) return dp[i][time];\\n\\n        int skipDish = f(i+1, time, satisfaction, dp);\\n        int cookDish = time * satisfaction[i] + f(i+1, time+1, satisfaction, dp);\\n\\n        return dp[i][time] = max(skipDish, cookDish);\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n\\n        // if all the elements are negative return 0\\n        if(satisfaction[n-1] < 0) return 0;\\n\\n        // dp transition states  - index and time\\n        // time can range from 1 to n\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n        int startTime = 1;\\n        return f(0, startTime, satisfaction, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353586,
                "title": "memoization-tabulation-dp-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int cnt, int n, vector<int> &nums, vector<vector<int>> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i][cnt] != -1) return dp[i][cnt];\\n\\n        int notpick = 0 + dfs(i + 1, cnt, n, nums, dp);\\n        int pick = nums[i] * cnt + dfs(i + 1, cnt + 1, n, nums, dp);\\n        return dp[i][cnt] = max(pick, notpick);\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n        \\n        vector<vector<int>> dp(n, vector<int>(n + 1, -1));\\n        return dfs(0, 1, n, satisfaction, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2));\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int cnt=1; cnt<=n; cnt++) {\\n                int notpick = 0 + dp[i + 1][cnt];\\n                int pick = satisfaction[i] * cnt + dp[i + 1][cnt + 1];\\n                dp[i][cnt] = max(pick, notpick);\\n            } \\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int cnt, int n, vector<int> &nums, vector<vector<int>> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i][cnt] != -1) return dp[i][cnt];\\n\\n        int notpick = 0 + dfs(i + 1, cnt, n, nums, dp);\\n        int pick = nums[i] * cnt + dfs(i + 1, cnt + 1, n, nums, dp);\\n        return dp[i][cnt] = max(pick, notpick);\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n        \\n        vector<vector<int>> dp(n, vector<int>(n + 1, -1));\\n        return dfs(0, 1, n, satisfaction, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 2));\\n\\n        for(int i=n-1; i>=0; i--) {\\n            for(int cnt=1; cnt<=n; cnt++) {\\n                int notpick = 0 + dp[i + 1][cnt];\\n                int pick = satisfaction[i] * cnt + dp[i + 1][cnt + 1];\\n                dp[i][cnt] = max(pick, notpick);\\n            } \\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353503,
                "title": "easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the Given Vector.\\n2. make each element as sum of product of distance from curr to that element.\\n3. find max among them and return.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        for(int j=0;j<s.size();j++){\\n            for(int i=j+1;i<s.size();i++) s[j]+=s[i]*(i-j+1);\\n            s[0]=max(s[0],s[j]);\\n        }\\n        return s[0]<0?0:s[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        for(int j=0;j<s.size();j++){\\n            for(int i=j+1;i<s.size();i++) s[j]+=s[i]*(i-j+1);\\n            s[0]=max(s[0],s[j]);\\n        }\\n        return s[0]<0?0:s[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221819,
                "title": "sorting-and-dp-pick-notpick-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int ind,vector<int>&nums,int curr,vector<vector<int>>& dp){\\n        if(ind == nums.size()) return 0;\\n        if(dp[ind][curr] != -1) return dp[ind][curr];\\n        \\n        int pick = nums[ind] * curr + solve(ind+1, nums, curr + 1, dp);\\n        int notPick = solve(ind + 1, nums, curr, dp);\\n        \\n        return dp[ind][curr] = max(pick,notPick);\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n=satisfaction.size();\\n        vector <vector <int>> dp (n,vector <int> (n + 1,-1));\\n        sort(satisfaction.begin(),satisfaction.end());\\n        return solve(0, satisfaction, 1, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int ind,vector<int>&nums,int curr,vector<vector<int>>& dp){\\n        if(ind == nums.size()) return 0;\\n        if(dp[ind][curr] != -1) return dp[ind][curr];\\n        \\n        int pick = nums[ind] * curr + solve(ind+1, nums, curr + 1, dp);\\n        int notPick = solve(ind + 1, nums, curr, dp);\\n        \\n        return dp[ind][curr] = max(pick,notPick);\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n=satisfaction.size();\\n        vector <vector <int>> dp (n,vector <int> (n + 1,-1));\\n        sort(satisfaction.begin(),satisfaction.end());\\n        return solve(0, satisfaction, 1, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979402,
                "title": "reducing-dishes-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int startIndex = -1;\\n        int length = satisfaction.length;\\n        for (int i = 0; i < length; i++) {\\n            if (satisfaction[i] >= 0) {\\n                startIndex = i;\\n                break;\\n            }\\n        }\\n        if (startIndex < 0)\\n            return 0;\\n        int sum = 0;\\n        int totalSatisfaction = 0;\\n        int time = 1;\\n        for (int i = startIndex, j = 1; i < length; i++, j++) {\\n            sum += satisfaction[i];\\n            totalSatisfaction += satisfaction[i] * j;\\n        }\\n        int maxSatisfaction = totalSatisfaction;\\n        for (int i = startIndex - 1; i >= 0; i--) {\\n            sum += satisfaction[i];\\n            if (sum < 0)\\n                break;\\n            totalSatisfaction += sum;\\n            maxSatisfaction = Math.max(maxSatisfaction, totalSatisfaction);\\n        }\\n        return maxSatisfaction;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int startIndex = -1;\\n        int length = satisfaction.length;\\n        for (int i = 0; i < length; i++) {\\n            if (satisfaction[i] >= 0) {\\n                startIndex = i;\\n                break;\\n            }\\n        }\\n        if (startIndex < 0)\\n            return 0;\\n        int sum = 0;\\n        int totalSatisfaction = 0;\\n        int time = 1;\\n        for (int i = startIndex, j = 1; i < length; i++, j++) {\\n            sum += satisfaction[i];\\n            totalSatisfaction += satisfaction[i] * j;\\n        }\\n        int maxSatisfaction = totalSatisfaction;\\n        for (int i = startIndex - 1; i >= 0; i--) {\\n            sum += satisfaction[i];\\n            if (sum < 0)\\n                break;\\n            totalSatisfaction += sum;\\n            maxSatisfaction = Math.max(maxSatisfaction, totalSatisfaction);\\n        }\\n        return maxSatisfaction;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920585,
                "title": "java-o-n-log-n-n-n-3ms-solution",
                "content": "# Approach\\nO(N * log(N)) - for sorting\\nO(N * N) - for calculation\\n\\n# Complexity\\n- Time complexity: O(N * log(N) + N * N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] s) {\\n        Arrays.sort(s);\\n        int max = 0, sum = 0, count = 1;\\n        for (int i = 0; i < s.length; i++) {\\n            for (int j = i; j < s.length; j++) {\\n                sum += s[j] * count++;\\n            }\\n            max = Math.max(max, sum);\\n            sum = 0;\\n            count = 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] s) {\\n        Arrays.sort(s);\\n        int max = 0, sum = 0, count = 1;\\n        for (int i = 0; i < s.length; i++) {\\n            for (int j = i; j < s.length; j++) {\\n                sum += s[j] * count++;\\n            }\\n            max = Math.max(max, sum);\\n            sum = 0;\\n            count = 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643447,
                "title": "c-dp-memoization-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int idx, int time, vector<int> &satisfaction, vector<vector<int>> &dp){\\n        if(idx == satisfaction.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][time] != -1){\\n            return dp[idx][time];\\n        }\\n        \\n        int take = INT_MIN;\\n        int not_take = INT_MIN;\\n        \\n        take = (satisfaction[idx] * time) + solve(idx+1, time+1, satisfaction, dp);\\n        not_take = 0 + solve(idx+1, time, satisfaction, dp);\\n        \\n        return dp[idx][time] = max(take, not_take);\\n    }\\n    \\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(begin(satisfaction),end(satisfaction));\\n        int n = satisfaction.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(0,1,satisfaction,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int idx, int time, vector<int> &satisfaction, vector<vector<int>> &dp){\\n        if(idx == satisfaction.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][time] != -1){\\n            return dp[idx][time];\\n        }\\n        \\n        int take = INT_MIN;\\n        int not_take = INT_MIN;\\n        \\n        take = (satisfaction[idx] * time) + solve(idx+1, time+1, satisfaction, dp);\\n        not_take = 0 + solve(idx+1, time, satisfaction, dp);\\n        \\n        return dp[idx][time] = max(take, not_take);\\n    }\\n    \\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(begin(satisfaction),end(satisfaction));\\n        int n = satisfaction.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(0,1,satisfaction,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531504,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/1f14d575-371f-404f-88ed-bb5a4b5daf8c_1662319900.4946213.png)\\n\\n**T->O(2^n) && S->O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int count,vector<int>& sat,int n){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tint pick=count*sat[i]+f(i+1,count+1,sat,n);\\n\\t\\t\\tint notpick=f(i+1,count,sat,n);\\n\\t\\t\\treturn max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint maxSatisfaction(vector<int>& sat) {\\n\\t\\t\\tint n=sat.size();\\n\\t\\t\\tsort(sat.begin(),sat.end());\\n\\t\\t\\treturn f(0,1,sat,n);\\n\\t\\t}\\n\\t};\\n\\n# Method - 2 [Memoization]\\n![image](https://assets.leetcode.com/users/images/49aad775-9da6-4572-9dee-fe5289f0e400_1662319832.1744685.png)\\n\\n**T->O(n^2) && S->O(n^2) + O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,int count,vector<int>& sat,int n,vector<vector<int>>& dp){\\n\\t\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\t\\tif(dp[i][count]!=-1) return dp[i][count];\\n\\t\\t\\t\\tint pick=count*sat[i]+f(i+1,count+1,sat,n,dp);\\n\\t\\t\\t\\tint notpick=f(i+1,count,sat,n,dp);\\n\\t\\t\\t\\treturn dp[i][count]=max(pick,notpick);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint maxSatisfaction(vector<int>& sat) {\\n\\t\\t\\t\\tint n=sat.size();\\n\\t\\t\\t\\tsort(sat.begin(),sat.end());\\n\\t\\t\\t\\tvector<vector<int>> dp(n,vector<int>(n+1,-1));\\n\\t\\t\\t\\treturn f(0,1,sat,n,dp);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n# Method - 3 [Tabulation]\\t\\n\\n![image](https://assets.leetcode.com/users/images/c0ba1855-225e-4290-8da9-6a38c41b7f66_1662320864.8209212.png)\\n\\n**T->O(n^2) && S->O(n^2) **\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSatisfaction(vector<int>& sat) {\\n\\t\\t\\tint n=sat.size();\\n\\t\\t\\tsort(sat.begin(),sat.end());\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(n+2,0));\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int count=n;count>=1;count--){\\n\\t\\t\\t\\t\\tint pick=count*sat[i]+dp[i+1][count+1];\\n\\t\\t\\t\\t\\tint notpick=dp[i+1][count];\\n\\t\\t\\t\\t\\tdp[i][count]=max(pick,notpick);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][1];\\n\\t\\t}\\n\\t};\\n\\n# Method - 4 [SpaceOptimization]\\n![image](https://assets.leetcode.com/users/images/4d83d9ce-ca11-4777-96cf-161ab779d244_1662321020.3483918.png)\\n\\n**T->O(n^2) && S->O(n) **\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSatisfaction(vector<int>& sat) {\\n\\t\\t\\tint n=sat.size();\\n\\t\\t\\tsort(sat.begin(),sat.end());\\n\\t\\t\\tvector<int> prev(n+2,0),curr(n+2,0);\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int count=n;count>=1;count--){\\n\\t\\t\\t\\t\\tint pick=count*sat[i]+prev[count+1];\\n\\t\\t\\t\\t\\tint notpick=prev[count];\\n\\t\\t\\t\\t\\tcurr[count]=max(pick,notpick);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev[1];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int count,vector<int>& sat,int n){\\n\\t\\t\\tif(i==n) return 0;\\n\\t\\t\\tint pick=count*sat[i]+f(i+1,count+1,sat,n);\\n\\t\\t\\tint notpick=f(i+1,count,sat,n);\\n\\t\\t\\treturn max(pick,notpick);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2477488,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int func(int i,int ptr,vector<int>&satisf,vector<vector<int>>&dp){\\n        if(i==satisf.size())return 0;\\n        \\n        if(dp[i][ptr]!=-1)return dp[i][ptr];\\n        \\n        int a=0,b=0;\\n        a=satisf[i]*ptr+func(i+1,ptr+1,satisf,dp);\\n        b=func(i+1,ptr,satisf,dp);\\n        \\n        return dp[i][ptr]=max(a,b);\\n    }\\n    \\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end());\\n        \\n        int n=satisfaction.size();\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n        \\n        return func(0,1,satisfaction,dp);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int func(int i,int ptr,vector<int>&satisf,vector<vector<int>>&dp){\\n        if(i==satisf.size())return 0;\\n        \\n        if(dp[i][ptr]!=-1)return dp[i][ptr];\\n        \\n        int a=0,b=0;\\n        a=satisf[i]*ptr+func(i+1,ptr+1,satisf,dp);\\n        b=func(i+1,ptr,satisf,dp);\\n        \\n        return dp[i][ptr]=max(a,b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2326775,
                "title": "c-three-approaches-brute-memoization-tabulation-easy-solution",
                "content": "```\\n//Recursion\\n    int solve(vector<int>& satisfaction, int index, int time)\\n    {\\n        if(index == satisfaction.size())\\n            return 0;\\n        int include = satisfaction[index]*(time+1) + solve(satisfaction, index+1, time+1);\\n        int nonInclude = 0+ solve(satisfaction, index+1, time);\\n        return max(include, nonInclude);\\n    }\\n\\t\\n\\t\\n\\t// Memoization\\n     int solveMem(vector<int>& satisfaction, int index, int time, vector<vector<int>>&dp )\\n    {\\n        if(index == satisfaction.size())\\n            return 0;\\n         if(dp[index][time]!=-1)\\n             return dp[index][time];\\n        int include = satisfaction[index]*(time+1) + solveMem(satisfaction, index+1, time+1, dp);\\n        int nonInclude = 0+ solveMem(satisfaction, index+1, time, dp);\\n         \\n         dp[index][time] = max(include, nonInclude);\\n        return dp[index][time];\\n    }\\n    \\n    \\n\\t//Tabulation\\n    int solveTab(vector<int>& satisfaction)\\n    {\\n        int n = satisfaction.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n+1, 0));\\n        \\n        for(int index = n-1; index>=0; index--)\\n        {\\n            for(int time = index; time>=0; time--)\\n            {\\n                 int include = satisfaction[index]*(time+1) + dp[index+1][time+1];\\n                int nonInclude = 0+ dp[index+1][time];\\n         \\n         dp[index][time] = max(include, nonInclude);\\n       \\n            }\\n        }\\n         return dp[0][0];\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        \\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size();\\n        // vector<vector<int>>dp(n+1, vector<int>(n+1, -1));\\n        return solveTab(satisfaction);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//Recursion\\n    int solve(vector<int>& satisfaction, int index, int time)\\n    {\\n        if(index == satisfaction.size())\\n            return 0;\\n        int include = satisfaction[index]*(time+1) + solve(satisfaction, index+1, time+1);\\n        int nonInclude = 0+ solve(satisfaction, index+1, time);\\n        return max(include, nonInclude);\\n    }\\n\\t\\n\\t\\n\\t// Memoization\\n     int solveMem(vector<int>& satisfaction, int index, int time, vector<vector<int>>&dp )\\n    {\\n        if(index == satisfaction.size())\\n            return 0;\\n         if(dp[index][time]!=-1)\\n             return dp[index][time];\\n        int include = satisfaction[index]*(time+1) + solveMem(satisfaction, index+1, time+1, dp);\\n        int nonInclude = 0+ solveMem(satisfaction, index+1, time, dp);\\n         \\n         dp[index][time] = max(include, nonInclude);\\n        return dp[index][time];\\n    }\\n    \\n    \\n\\t//Tabulation\\n    int solveTab(vector<int>& satisfaction)\\n    {\\n        int n = satisfaction.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n+1, 0));\\n        \\n        for(int index = n-1; index>=0; index--)\\n        {\\n            for(int time = index; time>=0; time--)\\n            {\\n                 int include = satisfaction[index]*(time+1) + dp[index+1][time+1];\\n                int nonInclude = 0+ dp[index+1][time];\\n         \\n         dp[index][time] = max(include, nonInclude);\\n       \\n            }\\n        }\\n         return dp[0][0];\\n    }\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        \\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size();\\n        // vector<vector<int>>dp(n+1, vector<int>(n+1, -1));\\n        return solveTab(satisfaction);\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2206938,
                "title": "java-beginner-friendly-code",
                "content": "**** If you do like the code,plz upvote.\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] nums) {\\n        Arrays.sort(nums);\\n        int res=0;\\n        int n=nums.length;\\n      for(int i=0;i<n;i++)\\n      {\\n         int temp=0; \\n         int k=1;\\n          for(int j=i;j<n;j++)\\n          {\\n              temp+=nums[j]*k; \\n              k++;\\n          }\\n          if(temp>res) \\n          {\\n              res=temp;\\n          }\\n      }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] nums) {\\n        Arrays.sort(nums);\\n        int res=0;\\n        int n=nums.length;\\n      for(int i=0;i<n;i++)\\n      {\\n         int temp=0; \\n         int k=1;\\n          for(int j=i;j<n;j++)\\n          {\\n              temp+=nums[j]*k; \\n              k++;\\n          }\\n          if(temp>res) \\n          {\\n              res=temp;\\n          }\\n      }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205773,
                "title": "dp-simple-approach-c",
                "content": "For each element, you have two decision to make, \\neither include that element into the sum and increase time and index (looking diagonally on the tabulation matrix)\\nor do not include the element so time remains same and index is increased (looking to the bottom in tabulation matrix)\\n\\nYou have to choose the maximum of both the choices and will get your answer.\\n\\n```\\nint maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size();\\n        vector<vector<int>> dp(n+1, vector<int> (n+1, 0));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j = 0;j<=i;j++){\\n                dp[i][j] = max((j+1)*satisfaction[i]+dp[i+1][j+1], dp[i+1][j]);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n\\t\\n```\\n\\t\\nHere,  we are filling the tabulation matrix from bottom to up.\\n\\nHope this approach helps you, \\nHappy Coding!\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size();\\n        vector<vector<int>> dp(n+1, vector<int> (n+1, 0));\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j = 0;j<=i;j++){\\n                dp[i][j] = max((j+1)*satisfaction[i]+dp[i+1][j+1], dp[i+1][j]);\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195679,
                "title": "c-dp-0-1-knapsack-easy",
                "content": "```\\nclass Solution {\\npublic:\\n   int solve(int i,vector<int>& s,int p,vector<vector<int>>&t){\\n        int n=s.size();\\n        if(i==n) return 0;\\n        \\n        if(t[i][p]!=-1) return t[i][p];\\n        \\n        int select=(p+1)*s[i]+solve(i+1,s,p+1,t);\\n        int notselect=solve(i+1,s,p,t);\\n        \\n        return t[i][p]= max(select,notselect);\\n    }\\n    int maxSatisfaction(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        int n=s.size();\\n        vector<vector<int>>t(n+1,vector<int>(n+1,-1));\\n        return solve(0,s,0,t); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int solve(int i,vector<int>& s,int p,vector<vector<int>>&t){\\n        int n=s.size();\\n        if(i==n) return 0;\\n        \\n        if(t[i][p]!=-1) return t[i][p];\\n        \\n        int select=(p+1)*s[i]+solve(i+1,s,p+1,t);\\n        int notselect=solve(i+1,s,p,t);\\n        \\n        return t[i][p]= max(select,notselect);\\n    }\\n    int maxSatisfaction(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        int n=s.size();\\n        vector<vector<int>>t(n+1,vector<int>(n+1,-1));\\n        return solve(0,s,0,t); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185769,
                "title": "javascript-memorization-simple",
                "content": "```\\n\\nvar maxSatisfaction = function(satsifaction) {\\n      let cache = {};\\n    satsifaction.sort((a, b) => a - b);\\n    function dP(index, multiplier, satsifaction, val, cache) {\\n        let key = index + \"-\" + multiplier;\\n        if (index >= satsifaction.length) {\\n            return 0;\\n        }\\n        if (cache[key] != undefined) {\\n            return cache[key];\\n        }\\n        let valIfPicked = (satsifaction[index] * multiplier);\\n        let ifPicked = valIfPicked + dP(index + 1, multiplier + 1, satsifaction, val + valIfPicked, cache);\\n        let notPicked = 0 + dP(index + 1, multiplier, satsifaction, val, cache);\\n        cache[key] = Math.max(ifPicked, notPicked);\\n        return cache[key];\\n    }\\n    let maxCoeff = dP(0, 1, satsifaction, 0, cache);\\n    return maxCoeff;  \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nvar maxSatisfaction = function(satsifaction) {\\n      let cache = {};\\n    satsifaction.sort((a, b) => a - b);\\n    function dP(index, multiplier, satsifaction, val, cache) {\\n        let key = index + \"-\" + multiplier;\\n        if (index >= satsifaction.length) {\\n            return 0;\\n        }\\n        if (cache[key] != undefined) {\\n            return cache[key];\\n        }\\n        let valIfPicked = (satsifaction[index] * multiplier);\\n        let ifPicked = valIfPicked + dP(index + 1, multiplier + 1, satsifaction, val + valIfPicked, cache);\\n        let notPicked = 0 + dP(index + 1, multiplier, satsifaction, val, cache);\\n        cache[key] = Math.max(ifPicked, notPicked);\\n        return cache[key];\\n    }\\n    let maxCoeff = dP(0, 1, satsifaction, 0, cache);\\n    return maxCoeff;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933154,
                "title": "0-nlogn-easy-to-understand",
                "content": "```\\n//greedy approach\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int prefix_sum=0;\\n        int sum=0;\\n        \\n        for(int i=satisfaction.length-1;i>=0;i--){\\n                prefix_sum +=satisfaction[i];\\n                 \\n                if(sum + prefix_sum < sum)\\n                    return sum;\\n                 \\n               sum +=prefix_sum;\\n        }\\n        return sum;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n//greedy approach\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int prefix_sum=0;\\n        int sum=0;\\n        \\n        for(int i=satisfaction.length-1;i>=0;i--){\\n                prefix_sum +=satisfaction[i];\\n                 \\n                if(sum + prefix_sum < sum)\\n                    return sum;\\n                 \\n               sum +=prefix_sum;\\n        }\\n        return sum;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860778,
                "title": "reducing-dishes-c-memoizaton",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int help(vector<int> &s, int time, int idx, int n){\\n        if(idx == n)  return 0;  // BASE CASE\\n        if(dp[time][idx] != 0)  return dp[time][idx];\\n        int ans = max((time*s[idx]) + help(s,time+1,idx+1,n), help(s,time,idx+1,n));  // max from including and not including\\n        return (dp[time][idx] = ans);\\n        \\n    }\\n    \\n    int maxSatisfaction(vector<int>& s) {\\n        sort(s.begin(), s.end()); // sort so that we can take time in increasing order\\n        int ans = help(s,1,0,s.size());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int help(vector<int> &s, int time, int idx, int n){\\n        if(idx == n)  return 0;  // BASE CASE\\n        if(dp[time][idx] != 0)  return dp[time][idx];\\n        int ans = max((time*s[idx]) + help(s,time+1,idx+1,n), help(s,time,idx+1,n));  // max from including and not including\\n        return (dp[time][idx] = ans);\\n        \\n    }\\n    \\n    int maxSatisfaction(vector<int>& s) {\\n        sort(s.begin(), s.end()); // sort so that we can take time in increasing order\\n        int ans = help(s,1,0,s.size());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827699,
                "title": "clean-and-simple-c-code-0-ms-beats-100-of-cpp-submissions",
                "content": "**Runtime**: 0 ms\\n**Memory Usage**: 7.9 MB\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) \\n    {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size();\\n        int total = 0;\\n        int start = n - 1;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            total += satisfaction[i];\\n            if(total<0) break;\\n            start--;\\n        }\\n        start++;\\n        int time = 1;\\n        total = 0;\\n        for(int i=start; i<n; i++) \\n        {\\n            total += (time++) * satisfaction[i];\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) \\n    {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int n = satisfaction.size();\\n        int total = 0;\\n        int start = n - 1;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            total += satisfaction[i];\\n            if(total<0) break;\\n            start--;\\n        }\\n        start++;\\n        int time = 1;\\n        total = 0;\\n        for(int i=start; i<n; i++) \\n        {\\n            total += (time++) * satisfaction[i];\\n        }\\n        \\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775122,
                "title": "easy",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    int maxSatisfaction(vector<int>& sa) {\\n        sort(sa.begin(),sa.end());\\n        int n=sa.size();\\n        vector<int> x(n);\\n        int maxi=0;\\n        int tsum=maxi;\\n        for(int i=0;i<n;i++){\\n            maxi += sa[i]*(i+1);\\n            tsum +=sa[i];\\n        }\\n        \\n        int lsum=0;\\n        for(int i=0;i<n;i++){\\n            //cout<<maxi-tsum+sa[i]+lsum<<\" \";\\n            maxi = max(maxi,maxi-(tsum-lsum));\\n            \\n            lsum += sa[i];\\n        }\\n        return maxi;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int maxSatisfaction(vector<int>& sa) {\\n        sort(sa.begin(),sa.end());\\n        int n=sa.size();\\n        vector<int> x(n);\\n        int maxi=0;\\n        int tsum=maxi;\\n        for(int i=0;i<n;i++){\\n            maxi += sa[i]*(i+1);\\n            tsum +=sa[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1697321,
                "title": "python-80ms-solution",
                "content": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        res = total = 0\\n        satisfaction.sort()\\n        while satisfaction and satisfaction[-1] + total > 0:\\n            total += satisfaction.pop()\\n            res += total\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        res = total = 0\\n        satisfaction.sort()\\n        while satisfaction and satisfaction[-1] + total > 0:\\n            total += satisfaction.pop()\\n            res += total\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647799,
                "title": "understandable",
                "content": "```\\ndef maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n        if satisfaction[0]<0 and satisfaction[-1] <= 0: #if array values are completely <= 0:\\n            return 0\\n        n = len(satisfaction)+1\\n        dp = [[0 for i in range(n)] for j in range(n)]\\n        for i in range(1,n):\\n            for j in range(1,n):\\n                if j>=i:\\n                    dp[i][j] = dp[i][j-1] + satisfaction[j-1]*((j-i)+1)\\n                    if(j == n-1):\\n                        dp[i][-1] = max(dp[i-1][-1],dp[i][-1])\\n        return dp[-1][-1]\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/44b3193b-b7ad-4cf8-8596-986e80880e35_1640497686.1144586.png)\\n\\nthank you :)\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n        if satisfaction[0]<0 and satisfaction[-1] <= 0: #if array values are completely <= 0:\\n            return 0\\n        n = len(satisfaction)+1\\n        dp = [[0 for i in range(n)] for j in range(n)]\\n        for i in range(1,n):\\n            for j in range(1,n):\\n                if j>=i:\\n                    dp[i][j] = dp[i][j-1] + satisfaction[j-1]*((j-i)+1)\\n                    if(j == n-1):\\n                        dp[i][-1] = max(dp[i-1][-1],dp[i][-1])\\n        return dp[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1631821,
                "title": "c-beats-100-solution-with-only-two-more-integer-needed",
                "content": "The approach is first sort the array into descending order. \\n\\nSince the dishes with highest satisfaction level should spend more time, so we do dp from the dish with higher satisfaction. \\n\\nEverytime we include a new coming dish, all the previous dishes will increase its like-time coefficient by their own satisfaction. Thus we need a variable ```sum``` to store the total satisfaction of the included dish.\\n\\nHowever, if the dish got a negative satisfaction, we need to decide rather we should remove it. So we need to see the effect of this comming dishes ``` sum + i```, if it is smaller than zero, we should remove this dishes, and keep it otherwise. \\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& n) {\\n        sort(n.begin(), n.end(), [] (int& a, int& b) {return a > b;});\\n        \\n        int sum=0;\\n        int maxSat=0;\\n        \\n        for (auto& i: n){\\n\\t\\t\\t// reduce it \\n            if (0 > sum + i) maxSat = maxSat;\\n            // keep it\\n\\t\\t\\telse maxSat += sum += i;\\n        }\\n        return maxSat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```sum```\n``` sum + i```\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& n) {\\n        sort(n.begin(), n.end(), [] (int& a, int& b) {return a > b;});\\n        \\n        int sum=0;\\n        int maxSat=0;\\n        \\n        for (auto& i: n){\\n\\t\\t\\t// reduce it \\n            if (0 > sum + i) maxSat = maxSat;\\n            // keep it\\n\\t\\t\\telse maxSat += sum += i;\\n        }\\n        return maxSat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543707,
                "title": "python-4-line",
                "content": "```\\ndef maxSatisfaction(self, arr: List[int]) -> int:\\n        arr.sort()\\n        @lru_cache(None)\\n        def rec(i, c):return 0 if i == len(arr) else max(arr[i]*c + rec(i+1,c+1),rec(i+1,c))\\n        return rec(0, 1)",
                "solutionTags": [],
                "code": "```\\ndef maxSatisfaction(self, arr: List[int]) -> int:\\n        arr.sort()\\n        @lru_cache(None)\\n        def rec(i, c):return 0 if i == len(arr) else max(arr[i]*c + rec(i+1,c+1),rec(i+1,c))\\n        return rec(0, 1)",
                "codeTag": "Python3"
            },
            {
                "id": 1405043,
                "title": "simplest-java-2ms-solution-without-dp",
                "content": "* **Alogorithm**\\n-> Sort the array first\\n-> travese array from start to end and add the element multiplied by count\\n-> save the sum in max only if sum > max\\n-> repeat process starting from second postion then third position\\n-> When all the elements are traversed we will get the maximum sum of Like-Time coeffecient\\n-> return max if >= 0 else return 0\\n\\n\\nclass Solution {\\n    public int maxSatisfaction(int[] s) {\\n        \\n        Arrays.sort(s);\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<s.length;i++){\\n            int count = 1;\\n            int sum = 0;\\n            for(int j=i;j<s.length;j++){\\n                sum += (s[j]*count);\\n                count++;\\n            }\\n            if(sum > max)max = sum;\\n        }\\n        \\n        if(max >=0 )return max;\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int maxSatisfaction(int[] s) {\\n        \\n        Arrays.sort(s);\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<s.length;i++){\\n            int count = 1;\\n            int sum = 0;\\n            for(int j=i;j<s.length;j++){\\n                sum += (s[j]*count);\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1390934,
                "title": "two-java-simple-solution-most-easy-logic-100-faster",
                "content": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] s) {\\n        int max=0,ans=0,sum=0,k=1;\\n        Arrays.sort(s);\\n        int n=s.length;\\n        int i=n-1;\\n        while(i>=0){\\n            for(int m=i;m<n;m++){\\n                sum+=s[m]*k;\\n                k++;\\n            }\\n            max=Math.max(sum,max);\\n            i--;\\n            sum=0;\\n            k=1;\\n        }\\n        return max;\\n\\t\\t}\\n\\t}\\n-----------\\t---\\t------------------------------------------------------------------------------\\n\\t\\t\\nclass Solution {\\n     public int maxSatisfaction(int[] s) {\\n\\t\\tint sum=0,res=0,i=0;\\n        Arrays.sort(s);\\n        int n=s.length;\\n        for(i=n-1;i>=0;i--){\\n            sum+=s[i];\\n            if(sum<0) break;\\n        }\\n        int k=1;\\n        for(int m=i+1;m<n;m++){\\n            res+=s[m]*k++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] s) {\\n        int max=0,ans=0,sum=0,k=1;\\n        Arrays.sort(s);\\n        int n=s.length;\\n        int i=n-1;\\n        while(i>=0){\\n            for(int m=i;m<n;m++){\\n                sum+=s[m]*k;\\n                k++;\\n            }\\n            max=Math.max(sum,max);\\n            i--;\\n            sum=0;\\n            k=1;\\n        }\\n        return max;\\n\\t\\t}\\n\\t}\\n-----------\\t---\\t------------------------------------------------------------------------------\\n\\t\\t\\nclass Solution {\\n     public int maxSatisfaction(int[] s) {\\n\\t\\tint sum=0,res=0,i=0;\\n        Arrays.sort(s);\\n        int n=s.length;\\n        for(i=n-1;i>=0;i--){\\n            sum+=s[i];\\n            if(sum<0) break;\\n        }\\n        int k=1;\\n        for(int m=i+1;m<n;m++){\\n            res+=s[m]*k++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266639,
                "title": "faster-than-100-fastest-brute-force-solution-without-dp-o-n",
                "content": "int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int ans = 0,cs = 0;\\n        for(int i=n-1;i>=0;i--){\\n            if(satisfaction[i]+cs>=0){\\n                cs+=satisfaction[i];\\n                ans+=cs;\\n            }else break;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int ans = 0,cs = 0;\\n        for(int i=n-1;i>=0;i--){\\n            if(satisfaction[i]+cs>=0){\\n                cs+=satisfaction[i];\\n                ans+=cs;\\n            }else break;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1214961,
                "title": "python-3-one-line",
                "content": "# Explanation\\n\\nOnce we realize that the best order of dishes is the sorted order, and the only removed dishes are the most unliked ones, it\\'s just a matter of figuring out how many of the worst dishes to remove.\\n\\nLet\\'s look at this example:\\n```\\n-2,5,-1,0,3,-6\\n```\\nFirst sort it, in reverse order:\\n```\\n5 3 0 -1 -2 -6\\n```\\nWe will need to get rid of nothing, or `-6`, or `-2,-6`, or `-1,-2,-6`, or `0,-1,-2,-6`, or `3,0,-1,-2,-6` or `5,3,0,-1,-2,-6`.\\n\\nSo we need to try:\\n```\\n1*5\\n1*3 + 2*5\\n1*0 + 2*3 + 3*5\\n1*-1 + 2*0 + 3*3 + 4*5\\n1*-2 + 2*-1 + 3*0 + 4*3 + 5*5\\n1*-6 + 2*-2 + 3*-1 + 4*0 + 5*3 + 6*5\\n```\\nIf you write this a slightly different way, you\\'ll notice there\\'s a pattern:\\n```\\n5\\n5 + 3+5\\n5 + 3+5 + 0+3+5\\n5 + 3+5 + 0+3+5 + -1+0+3+5\\n5 + 3+5 + 0+3+5 + -1+0+3+5 + -2+-1+0+3+5 + -6+-2+-1+0+3+5\\n```\\nUsing [accumulate](https://docs.python.org/3/library/itertools.html#itertools.accumulate), this list is actually the result of calling accumulate twice:  `accumulate(accumulate(A))`.\\n\\nWe need to apply that on the reversed sorted list.\\n\\nFinally, in order to deal with the default case, we can throw `0` into the beginning of the sorted list. There might be more efficient ways to do this, but this is pretty short.\\n\\n# One line:\\n```python\\nclass Solution:\\n  def maxSatisfaction(self, A: List[int]) -> int:\\n    return max(accumulate(accumulate([0] + sorted(A, reverse=True))))\\n```\\n\\n# True one-liner:\\n```python\\nclass Solution: maxSatisfaction = lambda _,A: max(accumulate(accumulate([0] + sorted(A, reverse=True))))\\n```",
                "solutionTags": [],
                "code": "```\\n-2,5,-1,0,3,-6\\n```\n```\\n5 3 0 -1 -2 -6\\n```\n```\\n1*5\\n1*3 + 2*5\\n1*0 + 2*3 + 3*5\\n1*-1 + 2*0 + 3*3 + 4*5\\n1*-2 + 2*-1 + 3*0 + 4*3 + 5*5\\n1*-6 + 2*-2 + 3*-1 + 4*0 + 5*3 + 6*5\\n```\n```\\n5\\n5 + 3+5\\n5 + 3+5 + 0+3+5\\n5 + 3+5 + 0+3+5 + -1+0+3+5\\n5 + 3+5 + 0+3+5 + -1+0+3+5 + -2+-1+0+3+5 + -6+-2+-1+0+3+5\\n```\n```python\\nclass Solution:\\n  def maxSatisfaction(self, A: List[int]) -> int:\\n    return max(accumulate(accumulate([0] + sorted(A, reverse=True))))\\n```\n```python\\nclass Solution: maxSatisfaction = lambda _,A: max(accumulate(accumulate([0] + sorted(A, reverse=True))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169990,
                "title": "c-solution-without-dp-p",
                "content": "I am not good at dp, so here is simple iterative solution.\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int ans = INT_MIN;\\n        int num = satisfaction.size();\\n         sort(satisfaction.begin(),satisfaction.end());\\n        for(int i=0;i<num;i++){\\n            int k = 1;\\n            int cnt = 0;\\n               for(int j=i ; j <num;j++){\\n                   cnt += (satisfaction[j]*(k++));\\n               }\\n            ans = max(cnt,ans);\\n        }\\n        return max(ans,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int ans = INT_MIN;\\n        int num = satisfaction.size();\\n         sort(satisfaction.begin(),satisfaction.end());\\n        for(int i=0;i<num;i++){\\n            int k = 1;\\n            int cnt = 0;\\n               for(int j=i ; j <num;j++){\\n                   cnt += (satisfaction[j]*(k++));\\n               }\\n            ans = max(cnt,ans);\\n        }\\n        return max(ans,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112445,
                "title": "o-nlogn-c-easy-solution",
                "content": "**Logic : We need the samllest number to be mulitplied by 1 to the greatest by max idx. We will remove the smallest number one-by-one and check for max LikeTime**\\n\\nLet\\'s check with an example:\\nA = [-1,-8,0,5,-9]\\n**Step 1: We need to sort the array**\\nnewA = [-9, -8, -1, 0, 5]\\nFor this array, \\nsumOfArray = -13\\nLikeTime = (1)(-9)+(2)(-8)+(3)(-1)+(4)(0)+(5)(5) = -3\\n\\n**Step 2 (Recursive): We need to maximize the LikeTime by removing smallest terms from the array**\\nremoving -9 from the array\\nnewA = [-8, -1, 0, 5]\\nsumOfArray = -4\\nLikeTime = (1)(-8)+(2)(-1)+(3)(0)+(4)(5) = 10\\n\\nHere Note One thing, the LikeTime = Prev.LikeTime - Prev.sumOfArray and sumOfArray = Prev.sumOfArray - firstElement (This could save us a little time, as we won\\'t need to calculate LikeTime and sumOfArray again by traversing the array)\\nHow? \\nequation: \\nLikeTime = 1*A[1] + 2*A[2] + ...... n*A[n] ---------(1)\\nsumOfArray = A[1] + A[2] +.....A[n] ---------------(2)\\nAfter removing A[1] from Array, our LikeTime should be 1*[A2] + 2*A[3] +...(n-1)*A[n] --------(3)\\nSubtracting (2) from (1), we will get:\\n1*A[1] + 2*A[2] +...............+n*A[n]\\n( - )A[1]-    A[2] -...............-     A[n]\\n**=======================\\n       0  +  1*A[2] +.........(n-1)*A[n] -------------------->Same as (3)**\\n\\n\\n**going back again to step 2**\\nNow remove -8\\nnewA = [-1,0,5]\\nsumOfArray = 4\\nLikeTime = 14\\n\\n**Note : Here as sumOfArray becomes +ve, hence as per our above dedution (LikeTime = Prev.LikeTime - Prev.sumOfArray), LikeTime will only decrease further onwards.**\\n\\n**Hence, we will return the max LikeTime we got, we have 3 LikeTimes(-3,10,14) -> max is 14\\nanswer is 14.**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int sumOfNos = 0;\\n        for(int i = 0; i < satisfaction.size(); i++){\\n            sumOfNos += satisfaction[i];\\n        }\\n        int likeTime = 0;\\n        for(int i = 0; i < satisfaction.size(); i++){\\n            likeTime += (i+1)*(satisfaction[i]);\\n        }\\n        int maxLikeTime = max(0, likeTime);\\n        int i = 0;\\n        while(i < satisfaction.size() && sumOfNos < 0){\\n            likeTime = likeTime - sumOfNos;\\n            sumOfNos = sumOfNos - satisfaction[i];\\n            i++;\\n            if(maxLikeTime < likeTime)\\n                maxLikeTime = likeTime;\\n        }\\n        return maxLikeTime;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(), satisfaction.end());\\n        int sumOfNos = 0;\\n        for(int i = 0; i < satisfaction.size(); i++){\\n            sumOfNos += satisfaction[i];\\n        }\\n        int likeTime = 0;\\n        for(int i = 0; i < satisfaction.size(); i++){\\n            likeTime += (i+1)*(satisfaction[i]);\\n        }\\n        int maxLikeTime = max(0, likeTime);\\n        int i = 0;\\n        while(i < satisfaction.size() && sumOfNos < 0){\\n            likeTime = likeTime - sumOfNos;\\n            sumOfNos = sumOfNos - satisfaction[i];\\n            i++;\\n            if(maxLikeTime < likeTime)\\n                maxLikeTime = likeTime;\\n        }\\n        return maxLikeTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069964,
                "title": "java-easy-and-efficient-way",
                "content": "class Solution {\\n    public int maxSatisfaction(int[] arr) {\\n       \\n        Arrays.sort(arr);\\n\\n        for(int i : arr){\\n            System.out.print(i + \" \");\\n        }\\n\\n        int total = 0;\\n        int count = arr.length -1 ;\\n\\n        for(int i= arr.length-1; i>=0; i--){\\n           total = total + arr[i];\\n\\n           if(total < 0){\\n               break; //as soon as sum turns to be negative , break;\\n           }\\n           count--;\\n        }\\n\\n        //start from index till where we have positive sum\\n        count++;\\n        int sum = 0;\\n        int k = 1;\\n\\n        for(int i= count; i<= arr.length -1; i++){\\n            sum = sum + arr[i]* (k++);\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSatisfaction(int[] arr) {\\n       \\n        Arrays.sort(arr);\\n\\n        for(int i : arr){\\n            System.out.print(i + \" \");\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 990977,
                "title": "c-o-nlogn-solution",
                "content": "Greater numbers with bigger coefficients is preferred. Since we can choose in any order, let us sort the array in ascending order in *arr[]*.\\nWe also make an auxiliary array *cum[]* which stores cumulative sum, but from right to left i.e.\\n*cum<sub>i</sub> = arr<sub>i</sub> + arr<sub>i+1</sub> + ... + arr<sub>n-1</sub>*\\n\\nWe compute the preliminary sum in *s = 1\\\\*arr<sub>0</sub> +2\\\\*arr<sub>1</sub>+...+n\\\\*arr<sub>n-1</sub>* .\\nThe candidates which need to be examined are, by the logic that greater numbers should have bigger coefficients.\\n\\n* *1\\\\*arr<sub>0</sub> +2\\\\*arr<sub>1</sub>+...+n\\\\*arr<sub>n-1</sub>*\\n* *1\\\\*arr<sub>1</sub> +2\\\\*arr<sub>2</sub>+...+(n-1)\\\\*arr<sub>n-1</sub>*\\n* ...\\n* *1\\\\*arr<sub>n-2</sub> + 2\\\\*arr<sub>n-1</sub>*\\n* *1\\\\*arr<sub>n-1</sub>*\\n* 0\\n\\nObserve that *s* is the first element of this list. Doing * s = s - cum<sub>i</sub>* progressively yields each element of this list. We do that and store the maximum of these values. The maximum thus obtained is the required answer. \\n\\nHere is the C++ code to do the same.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxSatisfaction(vector<int>& sat)\\n    {\\n        int n,i,s,ans;\\n        n = sat.size();\\n        vector<int> arr(sat);\\n        vector<int> cum(n);\\n        sort(arr.begin(), arr.end());\\n        for (i=n-1; i>=0; i--)\\n        {\\n            cum[i] = arr[i];\\n            if (i != n-1)\\n                cum[i] += cum[i+1];\\n        }\\n        s = 0;\\n        for (i=0; i<n; i++)\\n            s += (i+1)*arr[i];\\n        ans = max(0, s);\\n        for (i=0; i<n; i++)\\n        {\\n            s -= cum[i];\\n            ans = max(ans, s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxSatisfaction(vector<int>& sat)\\n    {\\n        int n,i,s,ans;\\n        n = sat.size();\\n        vector<int> arr(sat);\\n        vector<int> cum(n);\\n        sort(arr.begin(), arr.end());\\n        for (i=n-1; i>=0; i--)\\n        {\\n            cum[i] = arr[i];\\n            if (i != n-1)\\n                cum[i] += cum[i+1];\\n        }\\n        s = 0;\\n        for (i=0; i<n; i++)\\n            s += (i+1)*arr[i];\\n        ans = max(0, s);\\n        for (i=0; i<n; i++)\\n        {\\n            s -= cum[i];\\n            ans = max(ans, s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985409,
                "title": "java-6-lines-faster-than-99-77-and-o-1-space",
                "content": "The idea is that we want the most liked dish multipled by the highest time, the second most liked dish multiplied by the second highest time, etc. \\n\\n**Reasoning (and informal proof) of algorithm**\\nWe know this method works because if we consider some combination that doesn\\'t follow this rule (e.g. 5 * 1 + 3 * 2) and assume it is the maximum possible, then we can quickly arrive at a contradiction because transforming the above expression into one that follows our rule (i.e. 5 * 2 + 3 * 1) requires us to add 5 and subtract 3 from the expression. Since 5 > 3, the new expression is greater and therefore contradicts the premise that the initial form was optimal.\\n\\n**Implementation**\\nConsider the given example, [-1, -8, 0, 5, -9]. To implement our algorithm, we must sort the array to get [-9, -8, -1, 0, 5]. We have to start with the most liked dish and work our way backwards. At each iteration, we add a dish and update all coefficients. We can update all of the coefficients in O(1) time by keeping a sum of all dishes so far (i.e. ```currSum```). We try considering every dish and keep track of the maximum score so far.\\n\\n**Stepping through example**\\nKeep in mind we\\'re going backwards through the sorted array.\\n*First iteration*: ```currSum = 5```. 5 > 0 therefore ```max = 5```\\n\\n*Second iteration*: ```currSum = 5 + 0```. ```currSum + max = (5 + 0) + (5) = 2 * 5 + 1 * 0 = 10```. 10 > 5 therefore ```max = 10```\\n\\n*Third iteration*: ```currSum = 5 + 0 + -1```. ```currSum + max = (5 + 0 + -1) + (2 * 5 + 1 * 0) = 3 * 5 + 2 * 0 + 1 * -1 = 14```. 14 > 10 therefore ```max = 14```.\\n\\n*Fourth iteration*: ```currSum = 5 + 0 + -1 + -8```. ```currSum + max = (5 + 0 + -1 + -8) + (3 * 5 + 2 * 0 + 1 * -1) = 4 * 5 + 3 * 0 + 2 * -1 + 1 * -8 = 10```. 10 < 14 therefore ```max``` is unchanged.\\n\\n*Fifth iteration*: ```currSum = 5 + 0 + -1 + -8 + -9```. ```currSum + max = (5 + 0 + -1 + -8 + -9) + (4 * 5 + 3 * 0 + 2 * -1 + 1 * -8) = 5 * 5 + 4 * 0 + 3 * -1 + 2 * -8 + 1 * -9 = -3```. -3 < 14 therefore ```max``` is unchanged.\\n\\n**Coming up with solution**\\nI was just looking at the given test cases and was trying to notice a pattern. After some time, I eventually noticed the pattern used by this algorithm. I tried it out, and to my surprise the solution was accepted. I then began looking for a proof that the pattern always holds and was able to come up with one by going through the different proof techniques I learned in school. \\n\\n```\\npublic int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        \\n        int max = 0, currSum = 0;\\n        for (int i = satisfaction.length - 1; i >= 0; i--) {\\n            max = Math.max(max + (currSum += satisfaction[i]), max);\\n        }\\n        \\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```currSum```\n```currSum = 5```\n```max = 5```\n```currSum = 5 + 0```\n```currSum + max = (5 + 0) + (5) = 2 * 5 + 1 * 0 = 10```\n```max = 10```\n```currSum = 5 + 0 + -1```\n```currSum + max = (5 + 0 + -1) + (2 * 5 + 1 * 0) = 3 * 5 + 2 * 0 + 1 * -1 = 14```\n```max = 14```\n```currSum = 5 + 0 + -1 + -8```\n```currSum + max = (5 + 0 + -1 + -8) + (3 * 5 + 2 * 0 + 1 * -1) = 4 * 5 + 3 * 0 + 2 * -1 + 1 * -8 = 10```\n```max```\n```currSum = 5 + 0 + -1 + -8 + -9```\n```currSum + max = (5 + 0 + -1 + -8 + -9) + (4 * 5 + 3 * 0 + 2 * -1 + 1 * -8) = 5 * 5 + 4 * 0 + 3 * -1 + 2 * -8 + 1 * -9 = -3```\n```max```\n```\\npublic int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        \\n        int max = 0, currSum = 0;\\n        for (int i = satisfaction.length - 1; i >= 0; i--) {\\n            max = Math.max(max + (currSum += satisfaction[i]), max);\\n        }\\n        \\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947029,
                "title": "c-0ms-100-time",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end(), [](int &a, int&b){return a>b;});\\n        int ret = 0;\\n        int pre=0;\\n        for(auto s: satisfaction) {\\n            if(pre+s>0) {\\n                pre +=s;\\n                ret +=pre; \\n            } else\\n                break;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        sort(satisfaction.begin(),satisfaction.end(), [](int &a, int&b){return a>b;});\\n        int ret = 0;\\n        int pre=0;\\n        for(auto s: satisfaction) {\\n            if(pre+s>0) {\\n                pre +=s;\\n                ret +=pre; \\n            } else\\n                break;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900672,
                "title": "argument-for-termination-condition-with-recurrence-rust-o-n-log-n",
                "content": "We want to cook the most satisfying dishes last. Otherwise, we\\'d rearrange the sum of products and get a higher maximum value.\\n\\nDefinitions:\\n\\nS(i) : the satisfaction at index i\\nP(i): the prefix sum of satisfaction up to and including i\\nT(i): the total value from cooking dishes through index i\\n\\nNotice that T(i) = T(i-1) + P(i). Direct proof:\\n\\nT(i) = S(0) * i + S(1) * (i-1) .. + S(i) = [S(0) * (i-1) + S(1) * (i-2) + ... S(i-1)] + [S(0) + S(1) + .. S(i-1)] + S(i) = T(i-1) + P(i-1) + S(i) = T(i-1) + P(i)\\n\\nIf P(i) < 0, then T(i) < T(i-1). Since the dishes are sorted in descending order, P(j) for j > i will become increasingly negative. So T(j) is decreasing.\\n\\n```\\nimpl Solution {\\n    pub fn max_satisfaction(mut satisfaction: Vec<i32>) -> i32 {\\n        satisfaction.sort_by(|a, b| b.cmp(a));\\n        let mut prefixSum = 0;\\n        let mut res = 0;\\n        for s in satisfaction {\\n            prefixSum += s;\\n            if prefixSum < 0 {\\n                break;\\n            }\\n            res += prefixSum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn max_satisfaction(mut satisfaction: Vec<i32>) -> i32 {\\n        satisfaction.sort_by(|a, b| b.cmp(a));\\n        let mut prefixSum = 0;\\n        let mut res = 0;\\n        for s in satisfaction {\\n            prefixSum += s;\\n            if prefixSum < 0 {\\n                break;\\n            }\\n            res += prefixSum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891033,
                "title": "very-simple-solution-explained-in-detail",
                "content": "\\tclass Solution(object):\\n\\t\\tdef maxSatisfaction(self,arr):\\n\\n\\t\\t\\t\\'\\'\\'We will have maximum sum only if we have maximum \\n\\t\\t\\tvalues at the end and also we need to multiply values \\n\\t\\t\\twith index so we need to maximise (index*maximum_value) thing\\'\\'\\'\\n\\n\\t\\t\\t\\'\\'\\' For example in [-2,5,-1,3,-3] after sorting we get [-3,-2,-1,3,5] \\n\\t\\t\\tbut if we only include [3,5] then we get [3*1+5*2]=13 but if \\n\\t\\t\\twe include -1 we get [-1*1+3*2+5*3]=20,again if we include -2 \\n\\t\\t\\twe get [-2*1+-1*2+3*3+5*4]=25 and so on.. we increase maximum \\n\\t\\t\\tvalue as we increase index\\'\\'\\'\\n\\n\\t\\t\\tarr.sort()\\n\\t\\t\\tmaxi=0\\n\\n\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\ta= arr[i:]\\n\\t\\t\\t\\t#print(a)\\n\\t\\t\\t\\tt = 0\\n\\t\\t\\t\\tfor j in range(len(a)):\\n\\t\\t\\t\\t\\tt += a[j]*(j+1)\\n\\t\\t\\t\\tmaxi =max(maxi,t)\\n\\t\\t\\treturn maxi",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef maxSatisfaction(self,arr):\\n\\n\\t\\t\\t\\'\\'\\'We will have maximum sum only if we have maximum \\n\\t\\t\\tvalues at the end and also we need to multiply values \\n\\t\\t\\twith index so we need to maximise (index*maximum_value) thing\\'\\'\\'\\n\\n\\t\\t\\t\\'\\'\\' For example in [-2,5,-1,3,-3] after sorting we get [-3,-2,-1,3,5] \\n\\t\\t\\tbut if we only include [3,5] then we get [3*1+5*2]=13 but if \\n\\t\\t\\twe include -1 we get [-1*1+3*2+5*3]=20,again if we include -2 \\n\\t\\t\\twe get [-2*1+-1*2+3*3+5*4]=25 and so on.. we increase maximum \\n\\t\\t\\tvalue as we increase index\\'\\'\\'\\n\\n\\t\\t\\tarr.sort()\\n\\t\\t\\tmaxi=0\\n\\n\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\ta= arr[i:]\\n\\t\\t\\t\\t#print(a)\\n\\t\\t\\t\\tt = 0\\n\\t\\t\\t\\tfor j in range(len(a)):\\n\\t\\t\\t\\t\\tt += a[j]*(j+1)\\n\\t\\t\\t\\tmaxi =max(maxi,t)\\n\\t\\t\\treturn maxi",
                "codeTag": "Java"
            },
            {
                "id": 857413,
                "title": "c-2-solutions-o-n-2-and-o-nlogn-intuition-explained-easy-and-short",
                "content": "* First thought that should come up in one\\'s head is that I should sort the array. Because in case you need to remove some elements they\\'ll surely be the negative ones. So you might or might not have to remove some elements from the beginning of the sorted array.\\n* First solution is O(n^2) which would easily pass. But not much fast. It came out to be faster than 75% solutions only.\\n* Next thought, can I optimize it further? Let\\'s try to write down the sum if I start to take elements from the ith index. How would it look like?\\n`ai + 2*ai+1 + 3*ai+2...` We can further open it up and write it down as: S = `(ai + ai+1 + ai+2 +. .. +) + (ai+1 + ai+2 + .. +) + .. + (an-1)`\\n* Wait, this looks something familiar. We can write each bracket as suffix sums. Right?\\n* `S = suff_i + suff_i+1 + suff_i+2 +.. + suff_n-1`\\n* You just need to find `i` such that this S is maximum. Which is pretty trivial I guess? You just have to maintain suffix of suffix array. And return the max of 0 and the maximum element in that array . This runs in O(n) and faster than 100% C++ solutions.\\n\\nSolution 1:\\n```\\nint maxSatisfaction(vector<int>& satisfaction) {\\n\\tint n = satisfaction.size(), ans = 0;\\n\\n\\tsort(satisfaction.begin(), satisfaction.end());\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tint curr = 1, currAns = 0;\\n\\n\\t\\tfor (int j = i; j < n; ++j) {\\n\\t\\t\\tcurrAns += curr * satisfaction[j];\\n\\t\\t\\tcurr++;\\n\\t\\t}\\n\\t\\tans = max(ans, currAns);\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nSolution 2:\\n```\\nint maxSatisfaction(vector<int>& satisfaction) {\\n\\tint n = satisfaction.size(), ans = 0;\\n\\tsort(satisfaction.begin(), satisfaction.end());\\n\\tvector<int> suff(n, 0), ssuff(n, 0);\\n\\n\\tfor (int i = n - 1; i >= 0; --i) {\\n\\t\\tsuff[i] = satisfaction[i];\\n\\t\\tif (i != n - 1) suff[i] += suff[i + 1];\\n\\t}\\n\\n\\tfor (int i = n - 1; i >= 0; --i) {\\n\\t\\tssuff[i] = suff[i];\\n\\t\\tif (i != n - 1) ssuff[i] += ssuff[i + 1];\\n\\t\\tans = max(ans, ssuff[i]);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint maxSatisfaction(vector<int>& satisfaction) {\\n\\tint n = satisfaction.size(), ans = 0;\\n\\n\\tsort(satisfaction.begin(), satisfaction.end());\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tint curr = 1, currAns = 0;\\n\\n\\t\\tfor (int j = i; j < n; ++j) {\\n\\t\\t\\tcurrAns += curr * satisfaction[j];\\n\\t\\t\\tcurr++;\\n\\t\\t}\\n\\t\\tans = max(ans, currAns);\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nint maxSatisfaction(vector<int>& satisfaction) {\\n\\tint n = satisfaction.size(), ans = 0;\\n\\tsort(satisfaction.begin(), satisfaction.end());\\n\\tvector<int> suff(n, 0), ssuff(n, 0);\\n\\n\\tfor (int i = n - 1; i >= 0; --i) {\\n\\t\\tsuff[i] = satisfaction[i];\\n\\t\\tif (i != n - 1) suff[i] += suff[i + 1];\\n\\t}\\n\\n\\tfor (int i = n - 1; i >= 0; --i) {\\n\\t\\tssuff[i] = suff[i];\\n\\t\\tif (i != n - 1) ssuff[i] += ssuff[i + 1];\\n\\t\\tans = max(ans, ssuff[i]);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 821350,
                "title": "clear-python-3-solution-faster-than-83",
                "content": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n        length = len(satisfaction)\\n        if satisfaction[-1] <= 0:\\n            return 0\\n        ind = -1\\n        for i in range(length):\\n            if satisfaction[i] >= 0:\\n                ind = i\\n                break\\n        diff, res = 0, 0\\n        for i in range(ind, length):\\n            diff += satisfaction[i]\\n            res += (i - ind + 1) * satisfaction[i]\\n        pos = ind - 1\\n        while pos >= 0:\\n            res = max(res, res + diff + satisfaction[pos])\\n            diff += satisfaction[pos]\\n            pos -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort()\\n        length = len(satisfaction)\\n        if satisfaction[-1] <= 0:\\n            return 0\\n        ind = -1\\n        for i in range(length):\\n            if satisfaction[i] >= 0:\\n                ind = i\\n                break\\n        diff, res = 0, 0\\n        for i in range(ind, length):\\n            diff += satisfaction[i]\\n            res += (i - ind + 1) * satisfaction[i]\\n        pos = ind - 1\\n        while pos >= 0:\\n            res = max(res, res + diff + satisfaction[pos])\\n            diff += satisfaction[pos]\\n            pos -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813012,
                "title": "c-7line-4ms",
                "content": "```\\n    //f(0) = v[0]*1 + v[1]*2 + ... + v[k]*(k+1)\\n    //f(1) = v[1]*1 + v[2]*2 + ... + v[k]*k\\n    // delta(0) = f1-f0 = - (v[0] + v[1] + ...v[k]) = -sum(0:k)\\n    // delta(1) = -sum(1:k)\\n    int maxSatisfaction(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int res = 0, n=v.size(), sum = accumulate(v.begin(), v.end(), 0);\\n        for(int i=0;i<n;i++) res += v[i]*(i+1);\\n        for(int i=0;i<n && sum<0;i++){\\n                res -= sum;\\n                sum -= v[i];\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    //f(0) = v[0]*1 + v[1]*2 + ... + v[k]*(k+1)\\n    //f(1) = v[1]*1 + v[2]*2 + ... + v[k]*k\\n    // delta(0) = f1-f0 = - (v[0] + v[1] + ...v[k]) = -sum(0:k)\\n    // delta(1) = -sum(1:k)\\n    int maxSatisfaction(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int res = 0, n=v.size(), sum = accumulate(v.begin(), v.end(), 0);\\n        for(int i=0;i<n;i++) res += v[i]*(i+1);\\n        for(int i=0;i<n && sum<0;i++){\\n                res -= sum;\\n                sum -= v[i];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 793142,
                "title": "python-not-dp-90-w-hints-explanation",
                "content": "**Hints and oservations:**\\n\\n* In the final array, we multiply the satisfaction with the index. Hence, to maximize it, we need to keep the larger numbers towards the end of the array and the smaller numbers towards the beginning.\\n* We should never delete the positive numbers, as including them always leads to a larger *like-time coefficient*.\\n\\nKeeping these in mind, we should include all non-negative numbers (including zero) and order them in increasing order. \\n\\nIncluding a negative number may lead to a greater overall *like-time coefficient* as all satisfaction values that come after it will be now have an even larger multiplier. Whenever we include a negative number before the positive numbers - \\n\\n1. The *like-time coefficient* is reduced by the value of the negative number, and \\n2.  The *like-time coefficient* increases by the sum of all the satisfaction values that come after it\\n\\nSo our overall strategy is - \\n* Include all positive numbers in sorted order. \\n* Iterate over all negative values in descending order. If placing a negative number at the beginning of the sequence leads to an increase in the *like-time coefficient*, we include it. If it leads to a decrease, we do not include it and we break the iteration loop.\\n* Now that we have our final answer, we simply calculate the *like-time coefficient* and return it.\\n\\n\\n```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        \\n        \\n        pos_nums = sorted([positive for positive in satisfaction if positive >= 0])\\n        neg_nums = sorted([negative for negative in satisfaction if negative < 0])[::-1]\\n        \\n        \\n        current = sum(pos_nums)\\n        \\n        for i, v in enumerate(neg_nums):\\n            if abs(v) < current:\\n                pos_nums = [v] + pos_nums\\n                current += v\\n            else:\\n                break\\n\\n                \\n        answer = 0\\n\\n        for i,v in enumerate(pos_nums):\\n            answer += ((i+1)*v)\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        \\n        \\n        pos_nums = sorted([positive for positive in satisfaction if positive >= 0])\\n        neg_nums = sorted([negative for negative in satisfaction if negative < 0])[::-1]\\n        \\n        \\n        current = sum(pos_nums)\\n        \\n        for i, v in enumerate(neg_nums):\\n            if abs(v) < current:\\n                pos_nums = [v] + pos_nums\\n                current += v\\n            else:\\n                break\\n\\n                \\n        answer = 0\\n\\n        for i,v in enumerate(pos_nums):\\n            answer += ((i+1)*v)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717720,
                "title": "c-sort-and-then-recursive-memoization-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n    int ff(vector<int>& arr, int i, int time) {\\n        if (i >= arr.size()) return 0;\\n        \\n        if (dp[i][time] != -1) return dp[i][time];\\n        \\n        int ans1 = arr[i] * time + ff(arr, i + 1, time + 1);\\n        int ans2 = ff(arr, i + 1, time);\\n        \\n        return dp[i][time] = max(0, max(ans1, ans2));\\n    }\\n    \\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        memset(dp, -1, sizeof dp);\\n        sort(satisfaction.begin(), satisfaction.end());\\n        return ff(satisfaction, 0, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    \\n    int ff(vector<int>& arr, int i, int time) {\\n        if (i >= arr.size()) return 0;\\n        \\n        if (dp[i][time] != -1) return dp[i][time];\\n        \\n        int ans1 = arr[i] * time + ff(arr, i + 1, time + 1);\\n        int ans2 = ff(arr, i + 1, time);\\n        \\n        return dp[i][time] = max(0, max(ans1, ans2));\\n    }\\n    \\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        memset(dp, -1, sizeof dp);\\n        sort(satisfaction.begin(), satisfaction.end());\\n        return ff(satisfaction, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683469,
                "title": "sorting-well-commented-and-explained-idea-95-speed-68-space",
                "content": "The idea behind this is to include all positive dishes first,\\nthen check for all negative dishes and removing one negative dish one by one ( from lowest to highest )\\n\\nMultiplication ReWork is avoided by storing sum of Positive (to add) and negative (to subtract)\\nComments are given where required. \\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        \\n        // Sort in increasing order\\n        sort(satisfaction.begin(), satisfaction.end());\\n        \\n        // find first positive number \\n        int sep = 0;\\n        for(int i = 0; i < satisfaction.size(); i++) {\\n            if(satisfaction[i] < 0) {\\n                sep = i+1;\\n            }\\n        }\\n        \\n        // if no positive dish exists reject all and return 0\\n        if(sep == satisfaction.size()) return 0;\\n        \\n        // Now calculate the total of ONLY POSITIVE RATED DISHES because all positive rated dishes should be included so as to increase\\n        // Like-time coefficient\\n        int ans = 0;\\n        int mult = 1;\\n        int sum = 0;\\n        for(int i = sep; i < satisfaction.size(); i++) {\\n            ans += mult * satisfaction[i];\\n            sum += satisfaction[i];                 // this will be used later - 1\\n            mult++;\\n        }\\n        \\n        // if no negative dish exists no need to go further, return calculated ans\\n        if(sep == 0) return ans;\\n        \\n        // Now we calculate all the negative Like-time coefficient and also count how many negative numbers are there (using mult variable) \\n        int negSum = 0;        \\n        int negAns = 0;\\n        mult = 0;\\n        for(int i = 0; i < sep; i++) {\\n            mult++;\\n            negSum += satisfaction[i];              // this will be used later - 2\\n            negAns += mult * satisfaction[i];\\n        }\\n        \\n        int start = mult;\\n        int posAns = ans;                          \\n\\n//store positive answer as other greater answer(using negative dishes and updated positions of positive dishes) can change the ans variable \\n\\n        // Now include all negative numbers at start and keep decreasing the negative numbers sum using (2) also update positiveAns using (1)\\n        while(mult != 0) {\\n            \\n            // mult*sum + posAns = Like-coefficent of positive dishes at new positions\\n            ans = max(ans, (posAns + (mult*sum) + negAns));\\n            \\n            // negAns is updated after we remove the Lowest negative number \\n            \\n            negAns -= negSum;\\n            \\n            // the lowest negative number is also removed from the sum for next loop\\n            negSum -= satisfaction[start - mult];\\n            \\n            // decrease one negative number\\n            mult--;\\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        \\n        // Sort in increasing order\\n        sort(satisfaction.begin(), satisfaction.end());\\n        \\n        // find first positive number \\n        int sep = 0;\\n        for(int i = 0; i < satisfaction.size(); i++) {\\n            if(satisfaction[i] < 0) {\\n                sep = i+1;\\n            }\\n        }\\n        \\n        // if no positive dish exists reject all and return 0\\n        if(sep == satisfaction.size()) return 0;\\n        \\n        // Now calculate the total of ONLY POSITIVE RATED DISHES because all positive rated dishes should be included so as to increase\\n        // Like-time coefficient\\n        int ans = 0;\\n        int mult = 1;\\n        int sum = 0;\\n        for(int i = sep; i < satisfaction.size(); i++) {\\n            ans += mult * satisfaction[i];\\n            sum += satisfaction[i];                 // this will be used later - 1\\n            mult++;\\n        }\\n        \\n        // if no negative dish exists no need to go further, return calculated ans\\n        if(sep == 0) return ans;\\n        \\n        // Now we calculate all the negative Like-time coefficient and also count how many negative numbers are there (using mult variable) \\n        int negSum = 0;        \\n        int negAns = 0;\\n        mult = 0;\\n        for(int i = 0; i < sep; i++) {\\n            mult++;\\n            negSum += satisfaction[i];              // this will be used later - 2\\n            negAns += mult * satisfaction[i];\\n        }\\n        \\n        int start = mult;\\n        int posAns = ans;                          \\n\\n//store positive answer as other greater answer(using negative dishes and updated positions of positive dishes) can change the ans variable \\n\\n        // Now include all negative numbers at start and keep decreasing the negative numbers sum using (2) also update positiveAns using (1)\\n        while(mult != 0) {\\n            \\n            // mult*sum + posAns = Like-coefficent of positive dishes at new positions\\n            ans = max(ans, (posAns + (mult*sum) + negAns));\\n            \\n            // negAns is updated after we remove the Lowest negative number \\n            \\n            negAns -= negSum;\\n            \\n            // the lowest negative number is also removed from the sum for next loop\\n            negSum -= satisfaction[start - mult];\\n            \\n            // decrease one negative number\\n            mult--;\\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613840,
                "title": "97-100-python3-one-pass-after-sorting",
                "content": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort(reverse=True)\\n        if satisfaction[0] <= 0:\\n            return 0\\n        running_sum = 0\\n        ans = 0\\n        for s in satisfaction:\\n            if s < -running_sum:\\n                break\\n            running_sum += s\\n            ans += running_sum\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        satisfaction.sort(reverse=True)\\n        if satisfaction[0] <= 0:\\n            return 0\\n        running_sum = 0\\n        ans = 0\\n        for s in satisfaction:\\n            if s < -running_sum:\\n                break\\n            running_sum += s\\n            ans += running_sum\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592310,
                "title": "python-dp-solution-o-nlogn-with-example",
                "content": "```\\ndef maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        \\n        # Example case (sorted):\\n        # [-8, -7, -1, 0,  5]\\n        \\n        # Possible cooks:\\n        # -8*1 -7*2 -1*3 + 0*4 + 5*5 =  0\\n        #      -7*1 -1*2 + 0*3 + 5*4 = 11\\n        #           -1*1 + 0*2 + 5*3 = 14\\n        \\n        # We observe the following pattern:\\n        # s1 = a*1 + b*2 + c*3\\n        # s2 = b*1 + c*2\\n        # s3 = c*1\\n        \\n        # We can express the terms recursively:\\n        # s2 = s1 - (a + b + c)\\n        # s3 = s2 - (b + c)\\n        \\n        # The solution follows from there:\\n        \\n        satisfaction = sorted(satisfaction)\\n        t = sum(satisfaction)\\n        n = len(satisfaction)\\n        dp = [0] * n\\n        \\n        dp[0] = sum([(i+1)*sat for i, sat in enumerate(satisfaction)])\\n        \\n        ans = max(dp[0], 0)\\n        \\n        for i in range(1, n):\\n            dp[i] = dp[i-1] - t\\n            t -= satisfaction[i-1]\\n            ans = max(ans, dp[i])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        \\n        # Example case (sorted):\\n        # [-8, -7, -1, 0,  5]\\n        \\n        # Possible cooks:\\n        # -8*1 -7*2 -1*3 + 0*4 + 5*5 =  0\\n        #      -7*1 -1*2 + 0*3 + 5*4 = 11\\n        #           -1*1 + 0*2 + 5*3 = 14\\n        \\n        # We observe the following pattern:\\n        # s1 = a*1 + b*2 + c*3\\n        # s2 = b*1 + c*2\\n        # s3 = c*1\\n        \\n        # We can express the terms recursively:\\n        # s2 = s1 - (a + b + c)\\n        # s3 = s2 - (b + c)\\n        \\n        # The solution follows from there:\\n        \\n        satisfaction = sorted(satisfaction)\\n        t = sum(satisfaction)\\n        n = len(satisfaction)\\n        dp = [0] * n\\n        \\n        dp[0] = sum([(i+1)*sat for i, sat in enumerate(satisfaction)])\\n        \\n        ans = max(dp[0], 0)\\n        \\n        for i in range(1, n):\\n            dp[i] = dp[i-1] - t\\n            t -= satisfaction[i-1]\\n            ans = max(ans, dp[i])\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 570186,
                "title": "python3-o-nlog-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        \"\"\"\\n        After sorting satisfaction from highest satifaction to lowest it looks like:\\n        \\n        a,    b,    c,     d, ...\\n        \\n        We then progress thru the array and a build up a running sum.\\n        After the first time thru the top loop the array looks like this, where element is the sum of the values in the column \\n        \\n        \\n                           d\\n                    c      c\\n              b     b      b\\n        a,    a,    a,     a, ...\\n     \\n        and after one more pass of the same loop, the array now looks like the following, \\n        where each element is  the sum of the \\'triangle\\' of values\\n     \\n                           d   \\n                    c     cc\\n              b    bb    bbb\\n        a,   aa,  aaa,  aaaa, ...\\n        \\n        and then just find the max element in the array. It may not be the last one, since at some point in the\\n        array negative satifactions may start to decrease the sum\\n        \\n        \"\"\"    \\n        \\n        satisfaction.sort(reverse=True) # most to least\\n        for times in range(2):\\n            for i in range(len(satisfaction) - 1):\\n                satisfaction[i+1] += satisfaction[i]\\n        return max(max(satisfaction), 0)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        \"\"\"\\n        After sorting satisfaction from highest satifaction to lowest it looks like:\\n        \\n        a,    b,    c,     d, ...\\n        \\n        We then progress thru the array and a build up a running sum.\\n        After the first time thru the top loop the array looks like this, where element is the sum of the values in the column \\n        \\n        \\n                           d\\n                    c      c\\n              b     b      b\\n        a,    a,    a,     a, ...\\n     \\n        and after one more pass of the same loop, the array now looks like the following, \\n        where each element is  the sum of the \\'triangle\\' of values\\n     \\n                           d   \\n                    c     cc\\n              b    bb    bbb\\n        a,   aa,  aaa,  aaaa, ...\\n        \\n        and then just find the max element in the array. It may not be the last one, since at some point in the\\n        array negative satifactions may start to decrease the sum\\n        \\n        \"\"\"    \\n        \\n        satisfaction.sort(reverse=True) # most to least\\n        for times in range(2):\\n            for i in range(len(satisfaction) - 1):\\n                satisfaction[i+1] += satisfaction[i]\\n        return max(max(satisfaction), 0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 563338,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] nums) {\\n        Arrays.sort(nums);\\n        int res=0;\\n        int prefix[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            prefix[i]=sum;\\n        }\\n        sum=0;\\n        for(int i=0;i<nums.length;i++)sum+=(nums[i]*(i+1));\\n        res=Math.max(res,sum);\\n        for(int i=0;i<nums.length;i++){\\n            int tosub=0;\\n            if(i==0)tosub=prefix[nums.length-1];\\n            else tosub=prefix[nums.length-1]-prefix[i-1];\\n            sum-=tosub;\\n            res=Math.max(res,sum);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] nums) {\\n        Arrays.sort(nums);\\n        int res=0;\\n        int prefix[]=new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            prefix[i]=sum;\\n        }\\n        sum=0;\\n        for(int i=0;i<nums.length;i++)sum+=(nums[i]*(i+1));\\n        res=Math.max(res,sum);\\n        for(int i=0;i<nums.length;i++){\\n            int tosub=0;\\n            if(i==0)tosub=prefix[nums.length-1];\\n            else tosub=prefix[nums.length-1]-prefix[i-1];\\n            sum-=tosub;\\n            res=Math.max(res,sum);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563285,
                "title": "java-simple-concise",
                "content": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        int n = satisfaction.length;\\n        int ans = 0;\\n        Arrays.sort(satisfaction);\\n        for(int i = 0; i < n; i++) {\\n            int k = 1, curr = 0;\\n            for(int j = i; j < n; j++) curr += satisfaction[j] * (k++);\\n            ans = Math.max(ans, curr);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        int n = satisfaction.length;\\n        int ans = 0;\\n        Arrays.sort(satisfaction);\\n        for(int i = 0; i < n; i++) {\\n            int k = 1, curr = 0;\\n            for(int j = i; j < n; j++) curr += satisfaction[j] * (k++);\\n            ans = Math.max(ans, curr);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4009914,
                "title": "java-easiest-solution-2ms-simple-approach-after-sorting",
                "content": "# PLEASE UPVOTE\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int output=0;\\n        int sum=0;\\n        int max=0;\\n        for(int i=satisfaction.length-1;i>=0&&sum>=0;i--){\\n            output+=satisfaction[i]+sum;\\n            sum+=satisfaction[i];\\n            max=Math.max(output,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n        Arrays.sort(satisfaction);\\n        int output=0;\\n        int sum=0;\\n        int max=0;\\n        for(int i=satisfaction.length-1;i>=0&&sum>=0;i--){\\n            output+=satisfaction[i]+sum;\\n            sum+=satisfaction[i];\\n            max=Math.max(output,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822144,
                "title": "easy-to-understand-beats-93-60-in-runtime",
                "content": "# Please UPVOTE\\n    Be greedy, be greedy, be greedy!\\n\\n# Approach\\n    The algorithm follows a greedy approach, where it picks the current best option at each step (highest satisfaction value) and makes decisions based on that. It effectively finds the optimal combination of satisfaction values for maximum total satisfaction.\\n\\n# Complexity\\n- Time complexity:\\n    Worst case time complexity is O(log(n)*n) because of the sorting\\n\\n- Space complexity:\\n    The space complexity is O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    /*\\n    Suppose that vector = {1,2,-3,-5,8,5,3};\\n    1) First, sort the vector in decresing order\\n        {8, 5, 3, 2, 1, -3, -5}\\n    2) Then, Algorithm sums all terms up to \\'i\\'\\n      1-> localTotal = 8, 2-> localTotal = 8+5 = 13 ...\\n    3) If localTotal is positive, then its effect is positive\\n    4) If it is positive, then add it to total\\n        1 -> total = [8], 2 -> total = [8] + [8 + 5] ...\\n    5) In this situtation, 8 is multiplied by \\'i\\' and 5 is multiplied by \\'i-1\\' ... \\n        and the last term multiplied by \\'1\\'\\n    */\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        \\n        std::sort(satisfaction.begin(),satisfaction.end());\\n        std::reverse(satisfaction.begin(), satisfaction.end());\\n\\n        int len = satisfaction.size();\\n        int total = 0;\\n        int localTotal = 0;\\n        for(int i=0; i < len; i++){\\n            localTotal += satisfaction[i];\\n\\n            if(localTotal < 0){ \\n                break;\\n            }\\n            total += localTotal;\\n        }\\n\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    /*\\n    Suppose that vector = {1,2,-3,-5,8,5,3};\\n    1) First, sort the vector in decresing order\\n        {8, 5, 3, 2, 1, -3, -5}\\n    2) Then, Algorithm sums all terms up to \\'i\\'\\n      1-> localTotal = 8, 2-> localTotal = 8+5 = 13 ...\\n    3) If localTotal is positive, then its effect is positive\\n    4) If it is positive, then add it to total\\n        1 -> total = [8], 2 -> total = [8] + [8 + 5] ...\\n    5) In this situtation, 8 is multiplied by \\'i\\' and 5 is multiplied by \\'i-1\\' ... \\n        and the last term multiplied by \\'1\\'\\n    */\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        \\n        std::sort(satisfaction.begin(),satisfaction.end());\\n        std::reverse(satisfaction.begin(), satisfaction.end());\\n\\n        int len = satisfaction.size();\\n        int total = 0;\\n        int localTotal = 0;\\n        for(int i=0; i < len; i++){\\n            localTotal += satisfaction[i];\\n\\n            if(localTotal < 0){ \\n                break;\\n            }\\n            total += localTotal;\\n        }\\n\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754537,
                "title": "o-n-space-solution-using-tabulation-and-memoization",
                "content": "\\n# Approach\\nThe solve_space_opti function takes a vector satisfaction as input and returns the maximum satisfaction value.\\n\\nThe variable n is initialized with the size of the satisfaction vector.\\n\\nTwo vectors, curr and next, are created with sizes n + 1 and initialized with zeros. These vectors will be used to store the maximum satisfaction values.\\n\\nThe outer loop iterates from n - 1 to 0, iterating over each index of the satisfaction vector in reverse order.\\n\\nThe inner loop iterates from the current index (index) to 0, iterating over each time value from the current index to the beginning of the vector.\\n\\nInside the inner loop, two variables, include and exclude, are calculated.\\n\\ninclude represents the maximum satisfaction value if the current element is included in the subarray. It is calculated by multiplying the current satisfaction value (satisfaction[index]) with the time value incremented by 1 (time + 1), and adding it to the maximum satisfaction value obtained from the next index (next[time + 1]).\\n\\nexclude represents the maximum satisfaction value if the current element is excluded from the subarray. It is calculated by adding 0 to the maximum satisfaction value obtained from the next index (next[time]).\\n\\nThe curr[time] value is updated to the maximum of include and exclude.\\n\\nAfter the inner loop finishes, the next array is updated with the values of the curr array.\\n\\nThe outer loop continues until all indices of the satisfaction vector have been processed.\\n\\nFinally, the maximum satisfaction value is returned, which is stored in next[0].\\n\\nThe maxSatisfaction function takes the input vector satisfaction, sorts it in ascending order, and then calls the solve_space_opti function to calculate the maximum satisfaction value using the space-optimized approach.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:9(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve_space_opti(vector<int>& satisfaction)\\n    {\\n        int n = satisfaction.size();\\n       vector<int>curr(n+1,0);\\n       vector<int>next(n+1,0);\\n       for(int index = n-1;index>=0;index--)\\n       {\\n           for(int time = index;time>=0;time--)\\n           {\\n               int include = satisfaction[index] * (time + 1) + next[time+1];\\n               int exclude = 0 + next[time];\\n               curr[time]= max(include,exclude);\\n           }\\n           next=curr;\\n       }\\n       return next[0];\\n    }\\n\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n        return solve_space_opti(satisfaction);\\n    }\\n};\\n\\n```\\n\\n\\n# Approach\\nThe solve function takes a vector satisfaction, a 2D vector dp for memoization, the current index, and the current time as input. It returns the maximum satisfaction value.\\n\\nThe base case is defined when the index reaches the size of the satisfaction vector. In this case, there are no more elements to consider, so the function returns 0.\\n\\nThe function checks if the result for the current index and time has already been computed and stored in the dp array. If it has, the function returns the stored result.\\n\\nIf the result has not been computed, the function calculates two values: include and exclude.\\n\\ninclude represents the maximum satisfaction value if the current element is included in the subarray. It is calculated by multiplying the current satisfaction value (satisfaction[index]) with the time value incremented by 1 (time + 1), and adding it to the result of recursively calling the solve function for the next index and incremented time (solve(satisfaction, dp, index + 1, time + 1)).\\n\\nexclude represents the maximum satisfaction value if the current element is excluded from the subarray. It is calculated by adding 0 to the result of recursively calling the solve function for the next index and the same time (solve(satisfaction, dp, index + 1, time)).\\n\\nThe maximum value between include and exclude is stored in the variable ans.\\n\\nThe ans value is stored in the dp array for the current index and time to avoid recomputation in future calls.\\n\\nThe function returns the ans value.\\n\\nThe maxSatisfaction function takes the input vector satisfaction, creates a 2D vector dp with dimensions (n + 1) x (n + 1), initialized with -1 to indicate that no values have been computed yet.\\n\\nThe satisfaction vector is sorted in ascending order.\\n\\nThe solve function is called with the initial parameters satisfaction, dp, 0 as the initial index, and 0 as the initial time.\\n\\nThe result of the solve function is returned, which represents the maximum satisfaction value.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& satisfaction, vector<vector<int>>& dp, int index, int time) {\\n        if (index == satisfaction.size())\\n            return 0;\\n        if (dp[index][time] != -1)\\n            return dp[index][time];\\n        int include = satisfaction[index] * (time + 1) + solve(satisfaction, dp, index + 1, time + 1);\\n        int exclude = 0 + solve(satisfaction, dp, index + 1, time);\\n        int ans = max(include, exclude);\\n        dp[index][time] = ans;\\n        return dp[index][time];\\n    }\\n\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        sort(satisfaction.begin(), satisfaction.end());\\n        return solve(satisfaction, dp, 0, 0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve_space_opti(vector<int>& satisfaction)\\n    {\\n        int n = satisfaction.size();\\n       vector<int>curr(n+1,0);\\n       vector<int>next(n+1,0);\\n       for(int index = n-1;index>=0;index--)\\n       {\\n           for(int time = index;time>=0;time--)\\n           {\\n               int include = satisfaction[index] * (time + 1) + next[time+1];\\n               int exclude = 0 + next[time];\\n               curr[time]= max(include,exclude);\\n           }\\n           next=curr;\\n       }\\n       return next[0];\\n    }\\n\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        sort(satisfaction.begin(), satisfaction.end());\\n        return solve_space_opti(satisfaction);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& satisfaction, vector<vector<int>>& dp, int index, int time) {\\n        if (index == satisfaction.size())\\n            return 0;\\n        if (dp[index][time] != -1)\\n            return dp[index][time];\\n        int include = satisfaction[index] * (time + 1) + solve(satisfaction, dp, index + 1, time + 1);\\n        int exclude = 0 + solve(satisfaction, dp, index + 1, time);\\n        int ans = max(include, exclude);\\n        dp[index][time] = ans;\\n        return dp[index][time];\\n    }\\n\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        sort(satisfaction.begin(), satisfaction.end());\\n        return solve(satisfaction, dp, 0, 0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685350,
                "title": "1402-reducing-dishes-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n\\n        for(int i=0; i<satisfaction.length; i++){\\n            for(int j=i+1; j<satisfaction.length; j++){\\n                if(satisfaction[i] > satisfaction[j]){\\n                    int temp = satisfaction[i];\\n                    satisfaction[i] = satisfaction[j];\\n                    satisfaction[j] = temp;\\n                }\\n            }\\n        }\\n        int n = satisfaction.length - 1;\\n        int sum =0;\\n        int temp_sum = 0;\\n\\n        while(n>=0){\\n            temp_sum+=satisfaction[n];\\n            n--;\\n            if(temp_sum <0){\\n                break;\\n            }\\n            sum+=temp_sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] satisfaction) {\\n\\n        for(int i=0; i<satisfaction.length; i++){\\n            for(int j=i+1; j<satisfaction.length; j++){\\n                if(satisfaction[i] > satisfaction[j]){\\n                    int temp = satisfaction[i];\\n                    satisfaction[i] = satisfaction[j];\\n                    satisfaction[j] = temp;\\n                }\\n            }\\n        }\\n        int n = satisfaction.length - 1;\\n        int sum =0;\\n        int temp_sum = 0;\\n\\n        while(n>=0){\\n            temp_sum+=satisfaction[n];\\n            n--;\\n            if(temp_sum <0){\\n                break;\\n            }\\n            sum+=temp_sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620663,
                "title": "c-space-optimization-dp",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int solveTab(vector<int> &satisfaction)\\n    {\\n\\n        int n = satisfaction.size();\\n        // here there is no need to create a 2d vector \\n        // just we need only two 1 d vector\\n\\n        vector<int> curr(n+1 , 0);\\n        vector<int> next(n+1, 0);\\n\\n        for (int index = n - 1; index >= 0; index--)\\n        {\\n            for (int time = index; time >= 0; time--)\\n            {\\n                // similar to knapsack\\n                // include that dishes // so time is increseed // life time coefficient is also added //\\n\\n                int incl = satisfaction[index] * (time + 1)+ next[time+1];\\n                // exclude that dishes // so time is not increseed // life time coefficient is not added // index + 1\\n                int excl = 0 +next[time];\\n\\n                curr[time] =  max(incl , excl);\\n            }\\n            next= curr ;\\n           \\n        }\\n         return next[0];\\n    }\\n\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n\\n        \\n        sort(satisfaction.begin() , satisfaction.end() ) ;\\n        return solveTab(satisfaction);\\n\\n        \\n    }\\n};d\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int solveTab(vector<int> &satisfaction)\\n    {\\n\\n        int n = satisfaction.size();\\n        // here there is no need to create a 2d vector \\n        // just we need only two 1 d vector\\n\\n        vector<int> curr(n+1 , 0);\\n        vector<int> next(n+1, 0);\\n\\n        for (int index = n - 1; index >= 0; index--)\\n        {\\n            for (int time = index; time >= 0; time--)\\n            {\\n                // similar to knapsack\\n                // include that dishes // so time is increseed // life time coefficient is also added //\\n\\n                int incl = satisfaction[index] * (time + 1)+ next[time+1];\\n                // exclude that dishes // so time is not increseed // life time coefficient is not added // index + 1\\n                int excl = 0 +next[time];\\n\\n                curr[time] =  max(incl , excl);\\n            }\\n            next= curr ;\\n           \\n        }\\n         return next[0];\\n    }\\n\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n\\n        \\n        sort(satisfaction.begin() , satisfaction.end() ) ;\\n        return solveTab(satisfaction);\\n\\n        \\n    }\\n};d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357415,
                "title": "java-binary-search",
                "content": "Hi, I just wanted to post this because I didn\\'t see this solution being used or talked about at all (maybe someone did though, idk lol).\\n\\nInitially, my approach in solving the problem was by using brute force after I sorted the array as shown below.\\n\\n# Initial Code\\n```\\nclass Solution {\\n    // Overall Time: O(N^2)\\n    // Overall Space: O(log(N)) from sorting\\n    public int maxSatisfaction(int[] satisfaction) {\\n        // Time: O(N*log(N))\\n        Arrays.sort(satisfaction);\\n\\n        // Time: O(N)\\n        int i = 0;\\n        while (i < satisfaction.length && satisfaction[i] < 0)\\n            i++;\\n\\n        if (i == satisfaction.length)\\n            return 0;\\n\\n        // Time: O(N^2)\\n        int res = 0;\\n        while (i >= 0) {\\n            int curr_sum = 0;\\n            for (int j = i; j < satisfaction.length; j++)\\n                curr_sum += satisfaction[j] * (j-i+1);\\n\\n            if (curr_sum > res)\\n                res = curr_sum;\\n            else\\n                break;\\n\\n            i--;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\nHowever, as I knew that I was looking for a subarray in the sorted array where its end position is fixed (at the very end), I realized that I could try and find its starting position in a more optimized fashion. This is where binary search comes in.\\n\\nBut how exactly would we go about it? More specifically, what are the conditions that allow us to move our left and right pointers?\\n\\nWhat do we know from the initial code?\\n1. The subarray will include all zeros and positive numbers. So, the starting point of that subarray is the (inclusive) upper limit or where the right pointer should start. Although admittedly, the binary search idea should still work even if you just had the right pointer at the last index. But optimization, am I right?\\n2. There is a chance that going into the negative territory will net you a larger sum. But, the further you go in past the optimal starting point, there will be more losses than gains.\\n\\nThese facts tell us that we are essentially working with a sort of upside-down parabola, where the optimal starting point is at the peak. So, how do we get to the peak? We know we are at some point on the parabola, so why not look at our neighboring starting points to decide where to move next? One neighbor is enough to know where to move though, so I just chose the right neighbor. This gave way to the optimized code below.\\n\\n# Optimized Code\\n```\\nclass Solution {\\n    // Overall Time: O(N*log(N))\\n    // Overall Space: O(log(N)) from sorting\\n    public int maxSatisfaction(int[] satisfaction) {\\n        // Time: O(N*log(N))\\n        Arrays.sort(satisfaction);\\n\\n        // Time: O(N)\\n        int i = 0;\\n        while (i < satisfaction.length && satisfaction[i] < 0)\\n            i++;\\n\\n        if (i == satisfaction.length)\\n            return 0;\\n\\n        // Time: O([work inside loop] * [# of iterations of loop]) => \\n        //       O([2*N] * [log(r-l)]) => O(N*log(N))\\n        int l = 0, r = i;\\n        int res = 0;\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n\\n            // Time: O(N)\\n            int curr_sum = 0;\\n            for (int j = mid; j < satisfaction.length; j++)\\n                curr_sum += satisfaction[j] * (j-mid+1);\\n            \\n            // Time: O(N)\\n            mid++;\\n            int right_sum = 0;\\n            for (int j = mid; j < satisfaction.length; j++)\\n                right_sum += satisfaction[j] * (j-mid+1);\\n            mid--;\\n\\n            res = Math.max(res, curr_sum);\\n\\n            if (curr_sum < right_sum)\\n                l = mid + 1;\\n            else if (curr_sum > right_sum)\\n                r = mid-1;\\n            else\\n                break;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\nAs a quick note, the space complexities for both my initial and optimized code is determined by the Java sorting algorithm. As the editorial for this problem says, \"...in Java, the `Arrays.sort()` for primitives is implemented as a variant of the quicksort algorithm whose space complexity is $O(\\\\log N)$.\"\\n\\nIn any case, I feel like this is a very natural progression that eventually gives the same time and space complexities as the greedy solution in the editorial (although of course, the greedy solution is still quicker than my binary search solution). Some problems that have similar optimal solutions using binary search are listed below:\\n\\n- [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n- [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\\n\\nTell me what ya\\'ll think, and feel free to give any feedback for my post because it was my first one. Thanks!\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    // Overall Time: O(N^2)\\n    // Overall Space: O(log(N)) from sorting\\n    public int maxSatisfaction(int[] satisfaction) {\\n        // Time: O(N*log(N))\\n        Arrays.sort(satisfaction);\\n\\n        // Time: O(N)\\n        int i = 0;\\n        while (i < satisfaction.length && satisfaction[i] < 0)\\n            i++;\\n\\n        if (i == satisfaction.length)\\n            return 0;\\n\\n        // Time: O(N^2)\\n        int res = 0;\\n        while (i >= 0) {\\n            int curr_sum = 0;\\n            for (int j = i; j < satisfaction.length; j++)\\n                curr_sum += satisfaction[j] * (j-i+1);\\n\\n            if (curr_sum > res)\\n                res = curr_sum;\\n            else\\n                break;\\n\\n            i--;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // Overall Time: O(N*log(N))\\n    // Overall Space: O(log(N)) from sorting\\n    public int maxSatisfaction(int[] satisfaction) {\\n        // Time: O(N*log(N))\\n        Arrays.sort(satisfaction);\\n\\n        // Time: O(N)\\n        int i = 0;\\n        while (i < satisfaction.length && satisfaction[i] < 0)\\n            i++;\\n\\n        if (i == satisfaction.length)\\n            return 0;\\n\\n        // Time: O([work inside loop] * [# of iterations of loop]) => \\n        //       O([2*N] * [log(r-l)]) => O(N*log(N))\\n        int l = 0, r = i;\\n        int res = 0;\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n\\n            // Time: O(N)\\n            int curr_sum = 0;\\n            for (int j = mid; j < satisfaction.length; j++)\\n                curr_sum += satisfaction[j] * (j-mid+1);\\n            \\n            // Time: O(N)\\n            mid++;\\n            int right_sum = 0;\\n            for (int j = mid; j < satisfaction.length; j++)\\n                right_sum += satisfaction[j] * (j-mid+1);\\n            mid--;\\n\\n            res = Math.max(res, curr_sum);\\n\\n            if (curr_sum < right_sum)\\n                l = mid + 1;\\n            else if (curr_sum > right_sum)\\n                r = mid-1;\\n            else\\n                break;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357247,
                "title": "recursion-python-5-line-code",
                "content": "# Intuition\\nYou need find the max tastiness level you can have.\\n`Why not only all positive integer? `\\neg -> -9, -8, -1, 0, 5\\nconsidering only positive = (0 * 1) + (5 * 2) = 10\\nbest ans -> (-1 * 1) +(0 * 2) + (5 * 3) = 14\\nThis is a basic DP problem where choosing certain combinations of numbers give you max output.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        @cache\\n        def recur(i, multi):\\n            if i == len(satisfaction):\\n                return 0\\n            \\n            pick = (satisfaction[i] * multi) + recur(i+1, multi+1)\\n            notPick = 0 + recur(i+1, multi)\\n            return max(pick, notPick)\\n        return(recur(0, 1))\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        @cache\\n        def recur(i, multi):\\n            if i == len(satisfaction):\\n                return 0\\n            \\n            pick = (satisfaction[i] * multi) + recur(i+1, multi+1)\\n            notPick = 0 + recur(i+1, multi)\\n            return max(pick, notPick)\\n        return(recur(0, 1))\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357137,
                "title": "easy-c-sol",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        int lol = n;\\n        int val =0;\\n        int ans = 0;\\n        sort(satisfaction.begin(),satisfaction.end());\\n        while(lol--){\\n            int sum =0;\\n            for(int i=val;i<n;i++){\\n                sum += satisfaction[i] * (i-val+1);\\n            }\\n            ans = max(ans,sum);\\n            val++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n        int n = satisfaction.size();\\n        int lol = n;\\n        int val =0;\\n        int ans = 0;\\n        sort(satisfaction.begin(),satisfaction.end());\\n        while(lol--){\\n            int sum =0;\\n            for(int i=val;i<n;i++){\\n                sum += satisfaction[i] * (i-val+1);\\n            }\\n            ans = max(ans,sum);\\n            val++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357004,
                "title": "reducing-dishes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int l=INT_MIN;\\n        sort(s.begin(),s.end());\\n        for(int i=1;i<=s.size();i++)\\n        {\\n            int f=0,h=1;\\n            for(int j=i-1;j<s.size();j++)\\n                f+=(s[j]*(h++));\\n            l=max(l,f);\\n        }\\n        if(l<=0)\\n            return 0;\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int l=INT_MIN;\\n        sort(s.begin(),s.end());\\n        for(int i=1;i<=s.size();i++)\\n        {\\n            int f=0,h=1;\\n            for(int j=i-1;j<s.size();j++)\\n                f+=(s[j]*(h++));\\n            l=max(l,f);\\n        }\\n        if(l<=0)\\n            return 0;\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356681,
                "title": "memeoization-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int helper(vector<int>& s,vector<vector<int>>& dp,int ind,int cnt,int n)\\n   {\\n       if(ind==n-1){return s[n-1]*cnt;}\\n       \\n       if(dp[ind][cnt]!= -1) return dp[ind][cnt];\\n       \\n       int take=s[ind]*cnt+helper(s,dp,ind+1,cnt+1,n);\\n       int nottake=helper(s,dp,ind+1,cnt,n);\\n\\n       return dp[ind][cnt]=max(take,nottake);\\n   }\\n    int maxSatisfaction(vector<int>& s) {\\n        int n = s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        sort(s.begin(),s.end());\\n        int ltc= helper(s,dp,0,1,n);\\n\\n        return max(0,ltc);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int helper(vector<int>& s,vector<vector<int>>& dp,int ind,int cnt,int n)\\n   {\\n       if(ind==n-1){return s[n-1]*cnt;}\\n       \\n       if(dp[ind][cnt]!= -1) return dp[ind][cnt];\\n       \\n       int take=s[ind]*cnt+helper(s,dp,ind+1,cnt+1,n);\\n       int nottake=helper(s,dp,ind+1,cnt,n);\\n\\n       return dp[ind][cnt]=max(take,nottake);\\n   }\\n    int maxSatisfaction(vector<int>& s) {\\n        int n = s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        sort(s.begin(),s.end());\\n        int ltc= helper(s,dp,0,1,n);\\n\\n        return max(0,ltc);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356627,
                "title": "dp-solution",
                "content": "# Intuition\\nsort the array in decending order. and then calculate LTC for earch index, keep track of max\\n\\n# Approach\\ndp[i] = dp[i-1] + (sum till ith element) + satisfaction[i]\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func maxSatisfaction(_ satisfaction: [Int]) -> Int {\\n        var satisfaction = satisfaction\\n        satisfaction.sort(by: {$0>$1})\\n        var sum = 0 // sum till ith element\\n        var maxm = 0 // to track max \\n        var dp = [Int]()\\n        for i in 0...satisfaction.count-1 {\\n            sum += satisfaction[i]\\n            if i == 0 {\\n                maxm = max(satisfaction[i], maxm)\\n                dp.append(satisfaction[i])\\n            } else {\\n                let a = sum + dp[i-1] // dp[i] = dp[i-1] + (sum till i-1) + satisfaction[i]\\n                maxm = max(a,maxm)\\n                dp.append(a)\\n            }\\n            \\n        }\\n        return maxm\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxSatisfaction(_ satisfaction: [Int]) -> Int {\\n        var satisfaction = satisfaction\\n        satisfaction.sort(by: {$0>$1})\\n        var sum = 0 // sum till ith element\\n        var maxm = 0 // to track max \\n        var dp = [Int]()\\n        for i in 0...satisfaction.count-1 {\\n            sum += satisfaction[i]\\n            if i == 0 {\\n                maxm = max(satisfaction[i], maxm)\\n                dp.append(satisfaction[i])\\n            } else {\\n                let a = sum + dp[i-1] // dp[i] = dp[i-1] + (sum till i-1) + satisfaction[i]\\n                maxm = max(a,maxm)\\n                dp.append(a)\\n            }\\n            \\n        }\\n        return maxm\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356615,
                "title": "c-using-dp-and-brute-force",
                "content": "$$O(n)$$# Intuition\\nfirst solution is without DP and second one is with Dp\\n\\n# Approach\\ndp[i] =dp[i-1]+sum(sum till  i  after sorting in decending order)\\n\\n# Complexity\\n- Time complexity:\\n1.O(nlogn)\\n\\n- Space complexity:\\n1.O(n)\\n\\n# Code\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n\\n        int N =satisfaction.size();\\n        sort(satisfaction.begin(),satisfaction.end());\\n        reverse(satisfaction.begin(),satisfaction.end());\\n        int maxx = 0;\\n        for(int i=0;i<N;i++){\\n             int LCT=0;\\n             int k=i+1;\\n             for(int j=0;j<=i;j++){\\n                \\n                 LCT+= (k)*satisfaction[j];\\n                 k--;\\n             }\\n             maxx= max(maxx,LCT);\\n        }\\n     return maxx;   \\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n\\n        int N =satisfaction.size();\\n        sort(satisfaction.begin(),satisfaction.end());\\n        reverse(satisfaction.begin(),satisfaction.end());\\n        int maxx = 0;\\n         int sum=0;\\n         int dp[N+1];\\n         dp[0]=satisfaction[0];\\n         sum+=satisfaction[0];\\n        maxx= max(maxx,dp[0]);\\n        for(int i=1;i<N;i++){\\n           \\n            sum+=satisfaction[i];\\n            dp[i]=dp[i-1]+sum;\\n\\n           \\n             maxx= max(maxx,dp[i]);\\n        }\\n     return maxx;   \\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSatisfaction(vector<int>& satisfaction) {\\n\\n        int N =satisfaction.size();\\n        sort(satisfaction.begin(),satisfaction.end());\\n        reverse(satisfaction.begin(),satisfaction.end());\\n        int maxx = 0;\\n        for(int i=0;i<N;i++){\\n             int LCT=0;\\n             int k=i+1;\\n             for(int j=0;j<=i;j++){\\n                \\n                 LCT+= (k)*satisfaction[j];\\n                 k--;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 3356577,
                "title": "beats-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfaction(int[] s) {\\n        int currSum = 0;\\n        int maxScore = 0;\\n        Arrays.sort(s);\\n        for(int i = s.length - 1; i >= 0; i--) {\\n            int delta = s[i] + currSum;\\n            if(delta <= 0) break;\\n            maxScore += delta;\\n            currSum += s[i];\\n        }\\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfaction(int[] s) {\\n        int currSum = 0;\\n        int maxScore = 0;\\n        Arrays.sort(s);\\n        for(int i = s.length - 1; i >= 0; i--) {\\n            int delta = s[i] + currSum;\\n            if(delta <= 0) break;\\n            maxScore += delta;\\n            currSum += s[i];\\n        }\\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356572,
                "title": "clean-swift-solution",
                "content": "# Intuition\\nSort array in decreasing order.\\nIterate through elements.\\n\\nKeep a prefix sum inside `elementsSum`.\\nAdd its value to the `sum` variable.\\nStop when `elementsSum` is negative.\\n\\n# Performance\\n5ms, 13.8MB\\n\\n# Complexity\\n- Time complexity: O(n * log(n))\\n\\n- Space complexity: O(n) \\u2014 since we are creating a sorted copy of input array (thanks @dfomin)\\n\\n# Code\\n```\\nclass Solution {\\n    func maxSatisfaction(_ satisfaction: [Int]) -> Int {\\n        let sorted = satisfaction.sorted(by: >)\\n\\n        var sum = 0\\n        var elementsSum = 0\\n        for element in sorted {\\n            elementsSum += element\\n            guard elementsSum > 0 else { return sum }\\n\\n            sum += elementsSum\\n        }\\n\\n        return sum\\n    }\\n}\\n```\\n---\\n\\nIf my LeetCode solution was helpful, kindly upvote it to support my contributions and aid others in their coding journey! \\uD83D\\uDE0A\\uD83D\\uDC4D",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxSatisfaction(_ satisfaction: [Int]) -> Int {\\n        let sorted = satisfaction.sorted(by: >)\\n\\n        var sum = 0\\n        var elementsSum = 0\\n        for element in sorted {\\n            elementsSum += element\\n            guard elementsSum > 0 else { return sum }\\n\\n            sum += elementsSum\\n        }\\n\\n        return sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1846743,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1846663,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1573591,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1846703,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1789922,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1846698,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1564821,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1846711,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1814390,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1847186,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1846743,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1846663,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1573591,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1846703,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1789922,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1846698,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1564821,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1846711,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1814390,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1847186,
                "content": [
                    {
                        "username": "acohen31",
                        "content": "If I can do it, it is not hard."
                    },
                    {
                        "username": "f20170164",
                        "content": "If self-doubt had a face"
                    },
                    {
                        "username": "DanielBarrera",
                        "content": "You get an upvote"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "thats what came in my mind as well "
                    },
                    {
                        "username": "rajkamal10",
                        "content": "This should be on a shirt"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can you do it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This medium problem disguised as hard provides **cheap thrills** to those of us who wanted to solve HARD problems easily. "
                    },
                    {
                        "username": "vicky72878",
                        "content": "[@ugurabbasov65](/ugurabbasov65)  Even i thought the same thing. but think for  a while if you decide that we don\\'t have to add negative numbers then the number of dishes count won\\'t increase bcz of which we might loose the chance to multiply the +ve number with a higher number which stops us from getting the maximum score"
                    },
                    {
                        "username": "klaca",
                        "content": "[@ugurabbasov65](/ugurabbasov65) Because that way the positive numbers get higher multipliers, so the overall sum _can_ be higher. See the first example. If you do only the one with satisfaction 5, you will get 5x1 = 5 points. If you do the 0 and the 5, in this order, you'll get 0x1 + 5x2 = 10 points. If you do -1, 0, 5, you will get -1x1+0x2+5x3 = 14 points. However, you'll have to stop there, as it's not worth to do the ones with  -8 and -9 satisfaction, the sum will be lower.\n(It can be easily proved that whatever subset of dishes you choose the highest score on that subset will be achieved if you do the dishes in non-descending order.)"
                    },
                    {
                        "username": "ugurabbasov65",
                        "content": "bro, I don\\'t understand one thing about this problem. If the negative values \\u200B\\u200B\\u200B\\u200Bof the dishes reduce the amount of satisfaction, then why does he add them at all if the number of satisfactions will be less"
                    },
                    {
                        "username": "katalma",
                        "content": "medium? easy. I don\\'t get why is this hard..."
                    },
                    {
                        "username": "sk03167",
                        "content": "[@klaca](/klaca) whoever wrote the examples was way too into it. \"People do not like the dishes. No dish is prepared.\" lmao"
                    },
                    {
                        "username": "klaca",
                        "content": "tbh it\\'s hard to understand :) I had to analyze the examples"
                    },
                    {
                        "username": "andersona02",
                        "content": "medium is generous,  easy more likely.  finished this faster than some easy ones"
                    },
                    {
                        "username": "rajkamal10",
                        "content": "Please don\\'t demotivate vro \\uD83D\\uDE2D, I was so happy till I read this "
                    },
                    {
                        "username": "arghyadas",
                        "content": "True bhai"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "tru hey bhay lol"
                    },
                    {
                        "username": "user5400vw",
                        "content": "total ego boost"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "when i saw problem i was like these tags are misleading"
                    },
                    {
                        "username": "IveGot12Months",
                        "content": "Input: satisfaction = [-1,-8,0,5,-9]\\nOutput: 14\\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\\n\\nIf we are allowed to exclude dishes, why do we include the dish with satisfaction -1? \\n\\nFrom my persepective, we could only use dish with satisfaction 5 and have a result of 15 instead of 14. \\n\\nThank you"
                    },
                    {
                        "username": "sanskar10092009",
                        "content": "[@shinewanna97](/shinewanna97) if you remove the -1 dish too then while preparing dish of satisfaction 5, time =2. therefore the answer will be 10 in that case which is less than the max value(14);\\nHOPE THAT HELPS."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "See we can start from either 0 or -1 or -8 or -9 or 5\\nbut we need to maximize the like time(output)\\nhence we can successfully remove bigger negative numbers like -8 and -9\\nSo now we are left with 0 and -1 and 5\\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\\nhence we are left with 0 and -1 now.\\nLets check for all the cases \\n- Case 1\\nIf we remove -1 and get the output from the remaining elements\\n -- we will get output as 0*1 + 5*2 = 10\\n- Case 2\\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as 0*1 +(-1*2)+ 5*3 = -2+15=13\\n- Case 3\\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\\n-- we will get output as (-1*1) +0*2+ 5*3 = -1+15=14\\n\\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\\n\\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\\n# Please upvote if I added some value."
                    },
                    {
                        "username": "jcsrtrading",
                        "content": "I think that if you prepare only two dishes the coefficient does not give 15, it would be 10 => (0*1 + 5*2 = 10), the coefficient thakes in account the waiting as a factor, if you wait a long time even if recive a bad dish in the waiting and at the end have a very good dish will give you more value. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "that is what i also taught bro"
                    },
                    {
                        "username": "arya_1234",
                        "content": "If we exclude -1, then we have a total of 2 dishes -> 0 and 5. These two dishes will be multiplied by 1 and 2 which corresponds to their count. The like-time coefficient will be 0 * 1 + 5 * 2 = 10 which is less than 14. If we have just 5, then we will multiply it by 1 which will give answer as 5 only. So they have included -1"
                    },
                    {
                        "username": "shinewanna97",
                        "content": "I also had the same question why he is taking -1 for no reason!! Thanks for ur thought."
                    },
                    {
                        "username": "devanshbatra",
                        "content": "[@erbenpeter](/erbenpeter) correct...thanks for explaining."
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "[@erbenpeter](/erbenpeter) yess sirrr agreed"
                    },
                    {
                        "username": "erbenpeter",
                        "content": "If you only use dish with satisfaction equals 5 then the multiplier will be only 1 and 5 * 1 = 5. So using negative satisfactions can make sense since it can increase the multipliers of positive satisfactions."
                    },
                    {
                        "username": "MayuD",
                        "content": "Damn chef moved on to leetcode from codechef\\n"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "I came here betting the first comment would be: \"how is this hard?!!\" . It is now :D , you\\'re welcome :))."
                    },
                    {
                        "username": "alexbonasera",
                        "content": "This definitely should not be Hard, solved in about 2 minutes in O(n*log(n)) time and O(1) space with a sort and simple loop."
                    },
                    {
                        "username": "dansilveira",
                        "content": "We have some way more elaborated (and by elaborated I mean hard) problems rated Medium in here that will take you way more time to even come up with an initial idea.\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The **greedy** solution is much more easy and efficient than DP one. Easy explanation that beats 100% : https://leetcode.com/problems/reducing-dishes/solutions/3353514/simple-and-detailed-explanation-which-beats-100/"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "The aim of sorting is if we want to take some negative satisfaction then we must take it as early as possible. Less the satisfaction earlier we must take it. And the rest is basic DP."
                    },
                    {
                        "username": "jga111",
                        "content": "I\\'m feeling the greedy solution is nicest and comes more naturally for most people which is why they feel this is easy/medium. For me, this problem is about being able to do it in DP and recognising the transition function / state required which will hold you in good stead for more difficult DP problems."
                    }
                ]
            },
            {
                "id": 1709886,
                "content": [
                    {
                        "username": "thinker_08",
                        "content": "This is relatively a very easy problem compared to the other HARD problems on leetcode.\\nThey should at least change the difficulty of this question to EASY or MEDIUM"
                    },
                    {
                        "username": "Pravartya",
                        "content": "i think its not that easy to think that this could be solved by greedy approach - i needed time to prove myself about the greedy approach "
                    },
                    {
                        "username": "GD18",
                        "content": "definitely not easy, i feel this is an upper med level problem, not hard tho i agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, it should be changed to medium, not to easy, it\\'s not that easy"
                    },
                    {
                        "username": "omaewamou",
                        "content": "I don't think \"easy\" tag makes any logical sense here. In any case, you would first need to sort the array, and then come up with a 0/1 DP solution or figure out the greedy pattern. Neither of these solutions are trivial. "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "# For those who are wondering why -1 is taken in Example 1.\nSee we can start from either 0 or -1 or -8 or -9 or 5\nbut we need to maximize the like time(output)\nhence we can successfully remove bigger negative numbers like -8 and -9\nSo now we are left with 0 and -1 and 5\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\nhence we are left with 0 and -1 now.\nLets check for all the cases \n- Case 1\nIf we remove -1 and get the output from the remaining elements\n -- we will get output as 0 * 1 + 5 * 2 = 10\n- Case 2\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as 0 * 1 +(-1 * 2)+ 5*3 = -2+15=13\n- Case 3\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as (-1 * 1) +0 * 2+ 5*3 = -1+15=14\n\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\n\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\n# Please upvote if I added some value."
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "Thanks Mate"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n**- The problem asks us to find the maximum satisfaction we can get from serving dishes at a restaurant. Each dish has a satisfaction value associated with it. However, serving a dish takes time, and the time taken for serving increases with the number of dishes served.**\\n\\n**- To maximize satisfaction, we need to serve dishes in a way that takes minimum time and gives maximum satisfaction. One way to do this is to serve dishes with higher satisfaction values first, so that we can accumulate more satisfaction early on.**\\n\\n**- The solution to this problem involves sorting the dishes in decreasing order of satisfaction values and then serving them in that order. We can use a priority queue to keep track of the dishes we serve, as we want to serve the dishes with the highest satisfaction values first.**\\n\\n**- We can start serving dishes from the highest satisfaction value and keep track of the total satisfaction value and the time taken for serving. We keep serving dishes until either there are no more dishes left or the total satisfaction value becomes negative. Once we stop serving, we return the total satisfaction value obtained.**\\n\\n- This solution has a time complexity of O(nlogn), as it involves sorting the array, and a space complexity of O(n), as we use a priority queue to keep track of the dishes."
                    },
                    {
                        "username": "meteogish",
                        "content": "Nice solution!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3353916/easiest-solution/"
                    },
                    {
                        "username": "odinlake",
                        "content": "The problem description is utter nonsense. This ought to be expunged together with whoever posted it."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "This should be tagged easy. Most medium questions are harder."
                    },
                    {
                        "username": "supervaka",
                        "content": "What\\'s up with the explanation for example 2?\\n\"Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\"\\n\\nIf you chose dishes in the given order of the array wouldn\\'t you get\\n(4*1 + 3*2 + 2*3 = 16)?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"*Dishes can be prepared in any order*\""
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Simple O(n^2) passes all the test cases :)\\nDefinitely needs better constraints or shift to easy category"
                    },
                    {
                        "username": "Hasan_Al-quoders",
                        "content": "Solve in NLOGN using some logic not brute force or shift to easy problems and stop demotivating people"
                    },
                    {
                        "username": "user2324E",
                        "content": "I think moving it to easy is a bit much. Medium would be appropriate."
                    },
                    {
                        "username": "MertErdem",
                        "content": "My first hard problem...\\nMost likely this is just a medium disguised as a hard"
                    },
                    {
                        "username": "MertErdem",
                        "content": "[@Mister_CK](/Mister_CK) we all have to start somewhere :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "still counts ;-) "
                    },
                    {
                        "username": "Lainaaa",
                        "content": "I beg you to help me with understanding this task\\uD83D\\uDE4F\\n\\n`class Solution {\\n  int maxSatisfaction(List<int> satisfaction) {\\n    var array = satisfaction;\\n    array.sort();\\n    while(!array.isEmpty && array[0].abs() > array.last){\\n      array.removeAt(0);\\n    }\\n    var sum = 0;\\n    for (var i = 0; i < array.length; i++) {\\n      sum += array[i] * (i + 1);\\n    }\\n    return sum;\\n  }\\n}`\\n\\nThis is my solution, written in Dart, that similar to java and it is wrong. In my opinion all of the logic is right, help me to understand what I missed. "
                    },
                    {
                        "username": "sushi27",
                        "content": "As you choose your first dish, the time will be 1, and each time you choose a new dish, the time will increase by 1. I hope this helps you understand the question."
                    }
                ]
            },
            {
                "id": 1940247,
                "content": [
                    {
                        "username": "thinker_08",
                        "content": "This is relatively a very easy problem compared to the other HARD problems on leetcode.\\nThey should at least change the difficulty of this question to EASY or MEDIUM"
                    },
                    {
                        "username": "Pravartya",
                        "content": "i think its not that easy to think that this could be solved by greedy approach - i needed time to prove myself about the greedy approach "
                    },
                    {
                        "username": "GD18",
                        "content": "definitely not easy, i feel this is an upper med level problem, not hard tho i agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, it should be changed to medium, not to easy, it\\'s not that easy"
                    },
                    {
                        "username": "omaewamou",
                        "content": "I don't think \"easy\" tag makes any logical sense here. In any case, you would first need to sort the array, and then come up with a 0/1 DP solution or figure out the greedy pattern. Neither of these solutions are trivial. "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "# For those who are wondering why -1 is taken in Example 1.\nSee we can start from either 0 or -1 or -8 or -9 or 5\nbut we need to maximize the like time(output)\nhence we can successfully remove bigger negative numbers like -8 and -9\nSo now we are left with 0 and -1 and 5\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\nhence we are left with 0 and -1 now.\nLets check for all the cases \n- Case 1\nIf we remove -1 and get the output from the remaining elements\n -- we will get output as 0 * 1 + 5 * 2 = 10\n- Case 2\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as 0 * 1 +(-1 * 2)+ 5*3 = -2+15=13\n- Case 3\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as (-1 * 1) +0 * 2+ 5*3 = -1+15=14\n\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\n\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\n# Please upvote if I added some value."
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "Thanks Mate"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n**- The problem asks us to find the maximum satisfaction we can get from serving dishes at a restaurant. Each dish has a satisfaction value associated with it. However, serving a dish takes time, and the time taken for serving increases with the number of dishes served.**\\n\\n**- To maximize satisfaction, we need to serve dishes in a way that takes minimum time and gives maximum satisfaction. One way to do this is to serve dishes with higher satisfaction values first, so that we can accumulate more satisfaction early on.**\\n\\n**- The solution to this problem involves sorting the dishes in decreasing order of satisfaction values and then serving them in that order. We can use a priority queue to keep track of the dishes we serve, as we want to serve the dishes with the highest satisfaction values first.**\\n\\n**- We can start serving dishes from the highest satisfaction value and keep track of the total satisfaction value and the time taken for serving. We keep serving dishes until either there are no more dishes left or the total satisfaction value becomes negative. Once we stop serving, we return the total satisfaction value obtained.**\\n\\n- This solution has a time complexity of O(nlogn), as it involves sorting the array, and a space complexity of O(n), as we use a priority queue to keep track of the dishes."
                    },
                    {
                        "username": "meteogish",
                        "content": "Nice solution!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3353916/easiest-solution/"
                    },
                    {
                        "username": "odinlake",
                        "content": "The problem description is utter nonsense. This ought to be expunged together with whoever posted it."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "This should be tagged easy. Most medium questions are harder."
                    },
                    {
                        "username": "supervaka",
                        "content": "What\\'s up with the explanation for example 2?\\n\"Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\"\\n\\nIf you chose dishes in the given order of the array wouldn\\'t you get\\n(4*1 + 3*2 + 2*3 = 16)?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"*Dishes can be prepared in any order*\""
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Simple O(n^2) passes all the test cases :)\\nDefinitely needs better constraints or shift to easy category"
                    },
                    {
                        "username": "Hasan_Al-quoders",
                        "content": "Solve in NLOGN using some logic not brute force or shift to easy problems and stop demotivating people"
                    },
                    {
                        "username": "user2324E",
                        "content": "I think moving it to easy is a bit much. Medium would be appropriate."
                    },
                    {
                        "username": "MertErdem",
                        "content": "My first hard problem...\\nMost likely this is just a medium disguised as a hard"
                    },
                    {
                        "username": "MertErdem",
                        "content": "[@Mister_CK](/Mister_CK) we all have to start somewhere :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "still counts ;-) "
                    },
                    {
                        "username": "Lainaaa",
                        "content": "I beg you to help me with understanding this task\\uD83D\\uDE4F\\n\\n`class Solution {\\n  int maxSatisfaction(List<int> satisfaction) {\\n    var array = satisfaction;\\n    array.sort();\\n    while(!array.isEmpty && array[0].abs() > array.last){\\n      array.removeAt(0);\\n    }\\n    var sum = 0;\\n    for (var i = 0; i < array.length; i++) {\\n      sum += array[i] * (i + 1);\\n    }\\n    return sum;\\n  }\\n}`\\n\\nThis is my solution, written in Dart, that similar to java and it is wrong. In my opinion all of the logic is right, help me to understand what I missed. "
                    },
                    {
                        "username": "sushi27",
                        "content": "As you choose your first dish, the time will be 1, and each time you choose a new dish, the time will increase by 1. I hope this helps you understand the question."
                    }
                ]
            },
            {
                "id": 1846850,
                "content": [
                    {
                        "username": "thinker_08",
                        "content": "This is relatively a very easy problem compared to the other HARD problems on leetcode.\\nThey should at least change the difficulty of this question to EASY or MEDIUM"
                    },
                    {
                        "username": "Pravartya",
                        "content": "i think its not that easy to think that this could be solved by greedy approach - i needed time to prove myself about the greedy approach "
                    },
                    {
                        "username": "GD18",
                        "content": "definitely not easy, i feel this is an upper med level problem, not hard tho i agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, it should be changed to medium, not to easy, it\\'s not that easy"
                    },
                    {
                        "username": "omaewamou",
                        "content": "I don't think \"easy\" tag makes any logical sense here. In any case, you would first need to sort the array, and then come up with a 0/1 DP solution or figure out the greedy pattern. Neither of these solutions are trivial. "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "# For those who are wondering why -1 is taken in Example 1.\nSee we can start from either 0 or -1 or -8 or -9 or 5\nbut we need to maximize the like time(output)\nhence we can successfully remove bigger negative numbers like -8 and -9\nSo now we are left with 0 and -1 and 5\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\nhence we are left with 0 and -1 now.\nLets check for all the cases \n- Case 1\nIf we remove -1 and get the output from the remaining elements\n -- we will get output as 0 * 1 + 5 * 2 = 10\n- Case 2\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as 0 * 1 +(-1 * 2)+ 5*3 = -2+15=13\n- Case 3\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as (-1 * 1) +0 * 2+ 5*3 = -1+15=14\n\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\n\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\n# Please upvote if I added some value."
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "Thanks Mate"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n**- The problem asks us to find the maximum satisfaction we can get from serving dishes at a restaurant. Each dish has a satisfaction value associated with it. However, serving a dish takes time, and the time taken for serving increases with the number of dishes served.**\\n\\n**- To maximize satisfaction, we need to serve dishes in a way that takes minimum time and gives maximum satisfaction. One way to do this is to serve dishes with higher satisfaction values first, so that we can accumulate more satisfaction early on.**\\n\\n**- The solution to this problem involves sorting the dishes in decreasing order of satisfaction values and then serving them in that order. We can use a priority queue to keep track of the dishes we serve, as we want to serve the dishes with the highest satisfaction values first.**\\n\\n**- We can start serving dishes from the highest satisfaction value and keep track of the total satisfaction value and the time taken for serving. We keep serving dishes until either there are no more dishes left or the total satisfaction value becomes negative. Once we stop serving, we return the total satisfaction value obtained.**\\n\\n- This solution has a time complexity of O(nlogn), as it involves sorting the array, and a space complexity of O(n), as we use a priority queue to keep track of the dishes."
                    },
                    {
                        "username": "meteogish",
                        "content": "Nice solution!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3353916/easiest-solution/"
                    },
                    {
                        "username": "odinlake",
                        "content": "The problem description is utter nonsense. This ought to be expunged together with whoever posted it."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "This should be tagged easy. Most medium questions are harder."
                    },
                    {
                        "username": "supervaka",
                        "content": "What\\'s up with the explanation for example 2?\\n\"Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\"\\n\\nIf you chose dishes in the given order of the array wouldn\\'t you get\\n(4*1 + 3*2 + 2*3 = 16)?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"*Dishes can be prepared in any order*\""
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Simple O(n^2) passes all the test cases :)\\nDefinitely needs better constraints or shift to easy category"
                    },
                    {
                        "username": "Hasan_Al-quoders",
                        "content": "Solve in NLOGN using some logic not brute force or shift to easy problems and stop demotivating people"
                    },
                    {
                        "username": "user2324E",
                        "content": "I think moving it to easy is a bit much. Medium would be appropriate."
                    },
                    {
                        "username": "MertErdem",
                        "content": "My first hard problem...\\nMost likely this is just a medium disguised as a hard"
                    },
                    {
                        "username": "MertErdem",
                        "content": "[@Mister_CK](/Mister_CK) we all have to start somewhere :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "still counts ;-) "
                    },
                    {
                        "username": "Lainaaa",
                        "content": "I beg you to help me with understanding this task\\uD83D\\uDE4F\\n\\n`class Solution {\\n  int maxSatisfaction(List<int> satisfaction) {\\n    var array = satisfaction;\\n    array.sort();\\n    while(!array.isEmpty && array[0].abs() > array.last){\\n      array.removeAt(0);\\n    }\\n    var sum = 0;\\n    for (var i = 0; i < array.length; i++) {\\n      sum += array[i] * (i + 1);\\n    }\\n    return sum;\\n  }\\n}`\\n\\nThis is my solution, written in Dart, that similar to java and it is wrong. In my opinion all of the logic is right, help me to understand what I missed. "
                    },
                    {
                        "username": "sushi27",
                        "content": "As you choose your first dish, the time will be 1, and each time you choose a new dish, the time will increase by 1. I hope this helps you understand the question."
                    }
                ]
            },
            {
                "id": 1847103,
                "content": [
                    {
                        "username": "thinker_08",
                        "content": "This is relatively a very easy problem compared to the other HARD problems on leetcode.\\nThey should at least change the difficulty of this question to EASY or MEDIUM"
                    },
                    {
                        "username": "Pravartya",
                        "content": "i think its not that easy to think that this could be solved by greedy approach - i needed time to prove myself about the greedy approach "
                    },
                    {
                        "username": "GD18",
                        "content": "definitely not easy, i feel this is an upper med level problem, not hard tho i agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, it should be changed to medium, not to easy, it\\'s not that easy"
                    },
                    {
                        "username": "omaewamou",
                        "content": "I don't think \"easy\" tag makes any logical sense here. In any case, you would first need to sort the array, and then come up with a 0/1 DP solution or figure out the greedy pattern. Neither of these solutions are trivial. "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "# For those who are wondering why -1 is taken in Example 1.\nSee we can start from either 0 or -1 or -8 or -9 or 5\nbut we need to maximize the like time(output)\nhence we can successfully remove bigger negative numbers like -8 and -9\nSo now we are left with 0 and -1 and 5\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\nhence we are left with 0 and -1 now.\nLets check for all the cases \n- Case 1\nIf we remove -1 and get the output from the remaining elements\n -- we will get output as 0 * 1 + 5 * 2 = 10\n- Case 2\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as 0 * 1 +(-1 * 2)+ 5*3 = -2+15=13\n- Case 3\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as (-1 * 1) +0 * 2+ 5*3 = -1+15=14\n\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\n\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\n# Please upvote if I added some value."
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "Thanks Mate"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n**- The problem asks us to find the maximum satisfaction we can get from serving dishes at a restaurant. Each dish has a satisfaction value associated with it. However, serving a dish takes time, and the time taken for serving increases with the number of dishes served.**\\n\\n**- To maximize satisfaction, we need to serve dishes in a way that takes minimum time and gives maximum satisfaction. One way to do this is to serve dishes with higher satisfaction values first, so that we can accumulate more satisfaction early on.**\\n\\n**- The solution to this problem involves sorting the dishes in decreasing order of satisfaction values and then serving them in that order. We can use a priority queue to keep track of the dishes we serve, as we want to serve the dishes with the highest satisfaction values first.**\\n\\n**- We can start serving dishes from the highest satisfaction value and keep track of the total satisfaction value and the time taken for serving. We keep serving dishes until either there are no more dishes left or the total satisfaction value becomes negative. Once we stop serving, we return the total satisfaction value obtained.**\\n\\n- This solution has a time complexity of O(nlogn), as it involves sorting the array, and a space complexity of O(n), as we use a priority queue to keep track of the dishes."
                    },
                    {
                        "username": "meteogish",
                        "content": "Nice solution!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3353916/easiest-solution/"
                    },
                    {
                        "username": "odinlake",
                        "content": "The problem description is utter nonsense. This ought to be expunged together with whoever posted it."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "This should be tagged easy. Most medium questions are harder."
                    },
                    {
                        "username": "supervaka",
                        "content": "What\\'s up with the explanation for example 2?\\n\"Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\"\\n\\nIf you chose dishes in the given order of the array wouldn\\'t you get\\n(4*1 + 3*2 + 2*3 = 16)?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"*Dishes can be prepared in any order*\""
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Simple O(n^2) passes all the test cases :)\\nDefinitely needs better constraints or shift to easy category"
                    },
                    {
                        "username": "Hasan_Al-quoders",
                        "content": "Solve in NLOGN using some logic not brute force or shift to easy problems and stop demotivating people"
                    },
                    {
                        "username": "user2324E",
                        "content": "I think moving it to easy is a bit much. Medium would be appropriate."
                    },
                    {
                        "username": "MertErdem",
                        "content": "My first hard problem...\\nMost likely this is just a medium disguised as a hard"
                    },
                    {
                        "username": "MertErdem",
                        "content": "[@Mister_CK](/Mister_CK) we all have to start somewhere :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "still counts ;-) "
                    },
                    {
                        "username": "Lainaaa",
                        "content": "I beg you to help me with understanding this task\\uD83D\\uDE4F\\n\\n`class Solution {\\n  int maxSatisfaction(List<int> satisfaction) {\\n    var array = satisfaction;\\n    array.sort();\\n    while(!array.isEmpty && array[0].abs() > array.last){\\n      array.removeAt(0);\\n    }\\n    var sum = 0;\\n    for (var i = 0; i < array.length; i++) {\\n      sum += array[i] * (i + 1);\\n    }\\n    return sum;\\n  }\\n}`\\n\\nThis is my solution, written in Dart, that similar to java and it is wrong. In my opinion all of the logic is right, help me to understand what I missed. "
                    },
                    {
                        "username": "sushi27",
                        "content": "As you choose your first dish, the time will be 1, and each time you choose a new dish, the time will increase by 1. I hope this helps you understand the question."
                    }
                ]
            },
            {
                "id": 1846909,
                "content": [
                    {
                        "username": "thinker_08",
                        "content": "This is relatively a very easy problem compared to the other HARD problems on leetcode.\\nThey should at least change the difficulty of this question to EASY or MEDIUM"
                    },
                    {
                        "username": "Pravartya",
                        "content": "i think its not that easy to think that this could be solved by greedy approach - i needed time to prove myself about the greedy approach "
                    },
                    {
                        "username": "GD18",
                        "content": "definitely not easy, i feel this is an upper med level problem, not hard tho i agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, it should be changed to medium, not to easy, it\\'s not that easy"
                    },
                    {
                        "username": "omaewamou",
                        "content": "I don't think \"easy\" tag makes any logical sense here. In any case, you would first need to sort the array, and then come up with a 0/1 DP solution or figure out the greedy pattern. Neither of these solutions are trivial. "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "# For those who are wondering why -1 is taken in Example 1.\nSee we can start from either 0 or -1 or -8 or -9 or 5\nbut we need to maximize the like time(output)\nhence we can successfully remove bigger negative numbers like -8 and -9\nSo now we are left with 0 and -1 and 5\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\nhence we are left with 0 and -1 now.\nLets check for all the cases \n- Case 1\nIf we remove -1 and get the output from the remaining elements\n -- we will get output as 0 * 1 + 5 * 2 = 10\n- Case 2\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as 0 * 1 +(-1 * 2)+ 5*3 = -2+15=13\n- Case 3\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as (-1 * 1) +0 * 2+ 5*3 = -1+15=14\n\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\n\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\n# Please upvote if I added some value."
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "Thanks Mate"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n**- The problem asks us to find the maximum satisfaction we can get from serving dishes at a restaurant. Each dish has a satisfaction value associated with it. However, serving a dish takes time, and the time taken for serving increases with the number of dishes served.**\\n\\n**- To maximize satisfaction, we need to serve dishes in a way that takes minimum time and gives maximum satisfaction. One way to do this is to serve dishes with higher satisfaction values first, so that we can accumulate more satisfaction early on.**\\n\\n**- The solution to this problem involves sorting the dishes in decreasing order of satisfaction values and then serving them in that order. We can use a priority queue to keep track of the dishes we serve, as we want to serve the dishes with the highest satisfaction values first.**\\n\\n**- We can start serving dishes from the highest satisfaction value and keep track of the total satisfaction value and the time taken for serving. We keep serving dishes until either there are no more dishes left or the total satisfaction value becomes negative. Once we stop serving, we return the total satisfaction value obtained.**\\n\\n- This solution has a time complexity of O(nlogn), as it involves sorting the array, and a space complexity of O(n), as we use a priority queue to keep track of the dishes."
                    },
                    {
                        "username": "meteogish",
                        "content": "Nice solution!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3353916/easiest-solution/"
                    },
                    {
                        "username": "odinlake",
                        "content": "The problem description is utter nonsense. This ought to be expunged together with whoever posted it."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "This should be tagged easy. Most medium questions are harder."
                    },
                    {
                        "username": "supervaka",
                        "content": "What\\'s up with the explanation for example 2?\\n\"Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\"\\n\\nIf you chose dishes in the given order of the array wouldn\\'t you get\\n(4*1 + 3*2 + 2*3 = 16)?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"*Dishes can be prepared in any order*\""
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Simple O(n^2) passes all the test cases :)\\nDefinitely needs better constraints or shift to easy category"
                    },
                    {
                        "username": "Hasan_Al-quoders",
                        "content": "Solve in NLOGN using some logic not brute force or shift to easy problems and stop demotivating people"
                    },
                    {
                        "username": "user2324E",
                        "content": "I think moving it to easy is a bit much. Medium would be appropriate."
                    },
                    {
                        "username": "MertErdem",
                        "content": "My first hard problem...\\nMost likely this is just a medium disguised as a hard"
                    },
                    {
                        "username": "MertErdem",
                        "content": "[@Mister_CK](/Mister_CK) we all have to start somewhere :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "still counts ;-) "
                    },
                    {
                        "username": "Lainaaa",
                        "content": "I beg you to help me with understanding this task\\uD83D\\uDE4F\\n\\n`class Solution {\\n  int maxSatisfaction(List<int> satisfaction) {\\n    var array = satisfaction;\\n    array.sort();\\n    while(!array.isEmpty && array[0].abs() > array.last){\\n      array.removeAt(0);\\n    }\\n    var sum = 0;\\n    for (var i = 0; i < array.length; i++) {\\n      sum += array[i] * (i + 1);\\n    }\\n    return sum;\\n  }\\n}`\\n\\nThis is my solution, written in Dart, that similar to java and it is wrong. In my opinion all of the logic is right, help me to understand what I missed. "
                    },
                    {
                        "username": "sushi27",
                        "content": "As you choose your first dish, the time will be 1, and each time you choose a new dish, the time will increase by 1. I hope this helps you understand the question."
                    }
                ]
            },
            {
                "id": 1846695,
                "content": [
                    {
                        "username": "thinker_08",
                        "content": "This is relatively a very easy problem compared to the other HARD problems on leetcode.\\nThey should at least change the difficulty of this question to EASY or MEDIUM"
                    },
                    {
                        "username": "Pravartya",
                        "content": "i think its not that easy to think that this could be solved by greedy approach - i needed time to prove myself about the greedy approach "
                    },
                    {
                        "username": "GD18",
                        "content": "definitely not easy, i feel this is an upper med level problem, not hard tho i agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, it should be changed to medium, not to easy, it\\'s not that easy"
                    },
                    {
                        "username": "omaewamou",
                        "content": "I don't think \"easy\" tag makes any logical sense here. In any case, you would first need to sort the array, and then come up with a 0/1 DP solution or figure out the greedy pattern. Neither of these solutions are trivial. "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "# For those who are wondering why -1 is taken in Example 1.\nSee we can start from either 0 or -1 or -8 or -9 or 5\nbut we need to maximize the like time(output)\nhence we can successfully remove bigger negative numbers like -8 and -9\nSo now we are left with 0 and -1 and 5\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\nhence we are left with 0 and -1 now.\nLets check for all the cases \n- Case 1\nIf we remove -1 and get the output from the remaining elements\n -- we will get output as 0 * 1 + 5 * 2 = 10\n- Case 2\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as 0 * 1 +(-1 * 2)+ 5*3 = -2+15=13\n- Case 3\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as (-1 * 1) +0 * 2+ 5*3 = -1+15=14\n\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\n\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\n# Please upvote if I added some value."
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "Thanks Mate"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n**- The problem asks us to find the maximum satisfaction we can get from serving dishes at a restaurant. Each dish has a satisfaction value associated with it. However, serving a dish takes time, and the time taken for serving increases with the number of dishes served.**\\n\\n**- To maximize satisfaction, we need to serve dishes in a way that takes minimum time and gives maximum satisfaction. One way to do this is to serve dishes with higher satisfaction values first, so that we can accumulate more satisfaction early on.**\\n\\n**- The solution to this problem involves sorting the dishes in decreasing order of satisfaction values and then serving them in that order. We can use a priority queue to keep track of the dishes we serve, as we want to serve the dishes with the highest satisfaction values first.**\\n\\n**- We can start serving dishes from the highest satisfaction value and keep track of the total satisfaction value and the time taken for serving. We keep serving dishes until either there are no more dishes left or the total satisfaction value becomes negative. Once we stop serving, we return the total satisfaction value obtained.**\\n\\n- This solution has a time complexity of O(nlogn), as it involves sorting the array, and a space complexity of O(n), as we use a priority queue to keep track of the dishes."
                    },
                    {
                        "username": "meteogish",
                        "content": "Nice solution!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3353916/easiest-solution/"
                    },
                    {
                        "username": "odinlake",
                        "content": "The problem description is utter nonsense. This ought to be expunged together with whoever posted it."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "This should be tagged easy. Most medium questions are harder."
                    },
                    {
                        "username": "supervaka",
                        "content": "What\\'s up with the explanation for example 2?\\n\"Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\"\\n\\nIf you chose dishes in the given order of the array wouldn\\'t you get\\n(4*1 + 3*2 + 2*3 = 16)?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"*Dishes can be prepared in any order*\""
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Simple O(n^2) passes all the test cases :)\\nDefinitely needs better constraints or shift to easy category"
                    },
                    {
                        "username": "Hasan_Al-quoders",
                        "content": "Solve in NLOGN using some logic not brute force or shift to easy problems and stop demotivating people"
                    },
                    {
                        "username": "user2324E",
                        "content": "I think moving it to easy is a bit much. Medium would be appropriate."
                    },
                    {
                        "username": "MertErdem",
                        "content": "My first hard problem...\\nMost likely this is just a medium disguised as a hard"
                    },
                    {
                        "username": "MertErdem",
                        "content": "[@Mister_CK](/Mister_CK) we all have to start somewhere :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "still counts ;-) "
                    },
                    {
                        "username": "Lainaaa",
                        "content": "I beg you to help me with understanding this task\\uD83D\\uDE4F\\n\\n`class Solution {\\n  int maxSatisfaction(List<int> satisfaction) {\\n    var array = satisfaction;\\n    array.sort();\\n    while(!array.isEmpty && array[0].abs() > array.last){\\n      array.removeAt(0);\\n    }\\n    var sum = 0;\\n    for (var i = 0; i < array.length; i++) {\\n      sum += array[i] * (i + 1);\\n    }\\n    return sum;\\n  }\\n}`\\n\\nThis is my solution, written in Dart, that similar to java and it is wrong. In my opinion all of the logic is right, help me to understand what I missed. "
                    },
                    {
                        "username": "sushi27",
                        "content": "As you choose your first dish, the time will be 1, and each time you choose a new dish, the time will increase by 1. I hope this helps you understand the question."
                    }
                ]
            },
            {
                "id": 1846675,
                "content": [
                    {
                        "username": "thinker_08",
                        "content": "This is relatively a very easy problem compared to the other HARD problems on leetcode.\\nThey should at least change the difficulty of this question to EASY or MEDIUM"
                    },
                    {
                        "username": "Pravartya",
                        "content": "i think its not that easy to think that this could be solved by greedy approach - i needed time to prove myself about the greedy approach "
                    },
                    {
                        "username": "GD18",
                        "content": "definitely not easy, i feel this is an upper med level problem, not hard tho i agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, it should be changed to medium, not to easy, it\\'s not that easy"
                    },
                    {
                        "username": "omaewamou",
                        "content": "I don't think \"easy\" tag makes any logical sense here. In any case, you would first need to sort the array, and then come up with a 0/1 DP solution or figure out the greedy pattern. Neither of these solutions are trivial. "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "# For those who are wondering why -1 is taken in Example 1.\nSee we can start from either 0 or -1 or -8 or -9 or 5\nbut we need to maximize the like time(output)\nhence we can successfully remove bigger negative numbers like -8 and -9\nSo now we are left with 0 and -1 and 5\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\nhence we are left with 0 and -1 now.\nLets check for all the cases \n- Case 1\nIf we remove -1 and get the output from the remaining elements\n -- we will get output as 0 * 1 + 5 * 2 = 10\n- Case 2\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as 0 * 1 +(-1 * 2)+ 5*3 = -2+15=13\n- Case 3\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as (-1 * 1) +0 * 2+ 5*3 = -1+15=14\n\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\n\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\n# Please upvote if I added some value."
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "Thanks Mate"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n**- The problem asks us to find the maximum satisfaction we can get from serving dishes at a restaurant. Each dish has a satisfaction value associated with it. However, serving a dish takes time, and the time taken for serving increases with the number of dishes served.**\\n\\n**- To maximize satisfaction, we need to serve dishes in a way that takes minimum time and gives maximum satisfaction. One way to do this is to serve dishes with higher satisfaction values first, so that we can accumulate more satisfaction early on.**\\n\\n**- The solution to this problem involves sorting the dishes in decreasing order of satisfaction values and then serving them in that order. We can use a priority queue to keep track of the dishes we serve, as we want to serve the dishes with the highest satisfaction values first.**\\n\\n**- We can start serving dishes from the highest satisfaction value and keep track of the total satisfaction value and the time taken for serving. We keep serving dishes until either there are no more dishes left or the total satisfaction value becomes negative. Once we stop serving, we return the total satisfaction value obtained.**\\n\\n- This solution has a time complexity of O(nlogn), as it involves sorting the array, and a space complexity of O(n), as we use a priority queue to keep track of the dishes."
                    },
                    {
                        "username": "meteogish",
                        "content": "Nice solution!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3353916/easiest-solution/"
                    },
                    {
                        "username": "odinlake",
                        "content": "The problem description is utter nonsense. This ought to be expunged together with whoever posted it."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "This should be tagged easy. Most medium questions are harder."
                    },
                    {
                        "username": "supervaka",
                        "content": "What\\'s up with the explanation for example 2?\\n\"Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\"\\n\\nIf you chose dishes in the given order of the array wouldn\\'t you get\\n(4*1 + 3*2 + 2*3 = 16)?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"*Dishes can be prepared in any order*\""
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Simple O(n^2) passes all the test cases :)\\nDefinitely needs better constraints or shift to easy category"
                    },
                    {
                        "username": "Hasan_Al-quoders",
                        "content": "Solve in NLOGN using some logic not brute force or shift to easy problems and stop demotivating people"
                    },
                    {
                        "username": "user2324E",
                        "content": "I think moving it to easy is a bit much. Medium would be appropriate."
                    },
                    {
                        "username": "MertErdem",
                        "content": "My first hard problem...\\nMost likely this is just a medium disguised as a hard"
                    },
                    {
                        "username": "MertErdem",
                        "content": "[@Mister_CK](/Mister_CK) we all have to start somewhere :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "still counts ;-) "
                    },
                    {
                        "username": "Lainaaa",
                        "content": "I beg you to help me with understanding this task\\uD83D\\uDE4F\\n\\n`class Solution {\\n  int maxSatisfaction(List<int> satisfaction) {\\n    var array = satisfaction;\\n    array.sort();\\n    while(!array.isEmpty && array[0].abs() > array.last){\\n      array.removeAt(0);\\n    }\\n    var sum = 0;\\n    for (var i = 0; i < array.length; i++) {\\n      sum += array[i] * (i + 1);\\n    }\\n    return sum;\\n  }\\n}`\\n\\nThis is my solution, written in Dart, that similar to java and it is wrong. In my opinion all of the logic is right, help me to understand what I missed. "
                    },
                    {
                        "username": "sushi27",
                        "content": "As you choose your first dish, the time will be 1, and each time you choose a new dish, the time will increase by 1. I hope this helps you understand the question."
                    }
                ]
            },
            {
                "id": 2015339,
                "content": [
                    {
                        "username": "thinker_08",
                        "content": "This is relatively a very easy problem compared to the other HARD problems on leetcode.\\nThey should at least change the difficulty of this question to EASY or MEDIUM"
                    },
                    {
                        "username": "Pravartya",
                        "content": "i think its not that easy to think that this could be solved by greedy approach - i needed time to prove myself about the greedy approach "
                    },
                    {
                        "username": "GD18",
                        "content": "definitely not easy, i feel this is an upper med level problem, not hard tho i agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, it should be changed to medium, not to easy, it\\'s not that easy"
                    },
                    {
                        "username": "omaewamou",
                        "content": "I don't think \"easy\" tag makes any logical sense here. In any case, you would first need to sort the array, and then come up with a 0/1 DP solution or figure out the greedy pattern. Neither of these solutions are trivial. "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "# For those who are wondering why -1 is taken in Example 1.\nSee we can start from either 0 or -1 or -8 or -9 or 5\nbut we need to maximize the like time(output)\nhence we can successfully remove bigger negative numbers like -8 and -9\nSo now we are left with 0 and -1 and 5\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\nhence we are left with 0 and -1 now.\nLets check for all the cases \n- Case 1\nIf we remove -1 and get the output from the remaining elements\n -- we will get output as 0 * 1 + 5 * 2 = 10\n- Case 2\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as 0 * 1 +(-1 * 2)+ 5*3 = -2+15=13\n- Case 3\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as (-1 * 1) +0 * 2+ 5*3 = -1+15=14\n\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\n\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\n# Please upvote if I added some value."
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "Thanks Mate"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n**- The problem asks us to find the maximum satisfaction we can get from serving dishes at a restaurant. Each dish has a satisfaction value associated with it. However, serving a dish takes time, and the time taken for serving increases with the number of dishes served.**\\n\\n**- To maximize satisfaction, we need to serve dishes in a way that takes minimum time and gives maximum satisfaction. One way to do this is to serve dishes with higher satisfaction values first, so that we can accumulate more satisfaction early on.**\\n\\n**- The solution to this problem involves sorting the dishes in decreasing order of satisfaction values and then serving them in that order. We can use a priority queue to keep track of the dishes we serve, as we want to serve the dishes with the highest satisfaction values first.**\\n\\n**- We can start serving dishes from the highest satisfaction value and keep track of the total satisfaction value and the time taken for serving. We keep serving dishes until either there are no more dishes left or the total satisfaction value becomes negative. Once we stop serving, we return the total satisfaction value obtained.**\\n\\n- This solution has a time complexity of O(nlogn), as it involves sorting the array, and a space complexity of O(n), as we use a priority queue to keep track of the dishes."
                    },
                    {
                        "username": "meteogish",
                        "content": "Nice solution!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3353916/easiest-solution/"
                    },
                    {
                        "username": "odinlake",
                        "content": "The problem description is utter nonsense. This ought to be expunged together with whoever posted it."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "This should be tagged easy. Most medium questions are harder."
                    },
                    {
                        "username": "supervaka",
                        "content": "What\\'s up with the explanation for example 2?\\n\"Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\"\\n\\nIf you chose dishes in the given order of the array wouldn\\'t you get\\n(4*1 + 3*2 + 2*3 = 16)?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"*Dishes can be prepared in any order*\""
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Simple O(n^2) passes all the test cases :)\\nDefinitely needs better constraints or shift to easy category"
                    },
                    {
                        "username": "Hasan_Al-quoders",
                        "content": "Solve in NLOGN using some logic not brute force or shift to easy problems and stop demotivating people"
                    },
                    {
                        "username": "user2324E",
                        "content": "I think moving it to easy is a bit much. Medium would be appropriate."
                    },
                    {
                        "username": "MertErdem",
                        "content": "My first hard problem...\\nMost likely this is just a medium disguised as a hard"
                    },
                    {
                        "username": "MertErdem",
                        "content": "[@Mister_CK](/Mister_CK) we all have to start somewhere :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "still counts ;-) "
                    },
                    {
                        "username": "Lainaaa",
                        "content": "I beg you to help me with understanding this task\\uD83D\\uDE4F\\n\\n`class Solution {\\n  int maxSatisfaction(List<int> satisfaction) {\\n    var array = satisfaction;\\n    array.sort();\\n    while(!array.isEmpty && array[0].abs() > array.last){\\n      array.removeAt(0);\\n    }\\n    var sum = 0;\\n    for (var i = 0; i < array.length; i++) {\\n      sum += array[i] * (i + 1);\\n    }\\n    return sum;\\n  }\\n}`\\n\\nThis is my solution, written in Dart, that similar to java and it is wrong. In my opinion all of the logic is right, help me to understand what I missed. "
                    },
                    {
                        "username": "sushi27",
                        "content": "As you choose your first dish, the time will be 1, and each time you choose a new dish, the time will increase by 1. I hope this helps you understand the question."
                    }
                ]
            },
            {
                "id": 1847596,
                "content": [
                    {
                        "username": "thinker_08",
                        "content": "This is relatively a very easy problem compared to the other HARD problems on leetcode.\\nThey should at least change the difficulty of this question to EASY or MEDIUM"
                    },
                    {
                        "username": "Pravartya",
                        "content": "i think its not that easy to think that this could be solved by greedy approach - i needed time to prove myself about the greedy approach "
                    },
                    {
                        "username": "GD18",
                        "content": "definitely not easy, i feel this is an upper med level problem, not hard tho i agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, it should be changed to medium, not to easy, it\\'s not that easy"
                    },
                    {
                        "username": "omaewamou",
                        "content": "I don't think \"easy\" tag makes any logical sense here. In any case, you would first need to sort the array, and then come up with a 0/1 DP solution or figure out the greedy pattern. Neither of these solutions are trivial. "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "# For those who are wondering why -1 is taken in Example 1.\nSee we can start from either 0 or -1 or -8 or -9 or 5\nbut we need to maximize the like time(output)\nhence we can successfully remove bigger negative numbers like -8 and -9\nSo now we are left with 0 and -1 and 5\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\nhence we are left with 0 and -1 now.\nLets check for all the cases \n- Case 1\nIf we remove -1 and get the output from the remaining elements\n -- we will get output as 0 * 1 + 5 * 2 = 10\n- Case 2\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as 0 * 1 +(-1 * 2)+ 5*3 = -2+15=13\n- Case 3\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as (-1 * 1) +0 * 2+ 5*3 = -1+15=14\n\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\n\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\n# Please upvote if I added some value."
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "Thanks Mate"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n**- The problem asks us to find the maximum satisfaction we can get from serving dishes at a restaurant. Each dish has a satisfaction value associated with it. However, serving a dish takes time, and the time taken for serving increases with the number of dishes served.**\\n\\n**- To maximize satisfaction, we need to serve dishes in a way that takes minimum time and gives maximum satisfaction. One way to do this is to serve dishes with higher satisfaction values first, so that we can accumulate more satisfaction early on.**\\n\\n**- The solution to this problem involves sorting the dishes in decreasing order of satisfaction values and then serving them in that order. We can use a priority queue to keep track of the dishes we serve, as we want to serve the dishes with the highest satisfaction values first.**\\n\\n**- We can start serving dishes from the highest satisfaction value and keep track of the total satisfaction value and the time taken for serving. We keep serving dishes until either there are no more dishes left or the total satisfaction value becomes negative. Once we stop serving, we return the total satisfaction value obtained.**\\n\\n- This solution has a time complexity of O(nlogn), as it involves sorting the array, and a space complexity of O(n), as we use a priority queue to keep track of the dishes."
                    },
                    {
                        "username": "meteogish",
                        "content": "Nice solution!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3353916/easiest-solution/"
                    },
                    {
                        "username": "odinlake",
                        "content": "The problem description is utter nonsense. This ought to be expunged together with whoever posted it."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "This should be tagged easy. Most medium questions are harder."
                    },
                    {
                        "username": "supervaka",
                        "content": "What\\'s up with the explanation for example 2?\\n\"Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\"\\n\\nIf you chose dishes in the given order of the array wouldn\\'t you get\\n(4*1 + 3*2 + 2*3 = 16)?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"*Dishes can be prepared in any order*\""
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Simple O(n^2) passes all the test cases :)\\nDefinitely needs better constraints or shift to easy category"
                    },
                    {
                        "username": "Hasan_Al-quoders",
                        "content": "Solve in NLOGN using some logic not brute force or shift to easy problems and stop demotivating people"
                    },
                    {
                        "username": "user2324E",
                        "content": "I think moving it to easy is a bit much. Medium would be appropriate."
                    },
                    {
                        "username": "MertErdem",
                        "content": "My first hard problem...\\nMost likely this is just a medium disguised as a hard"
                    },
                    {
                        "username": "MertErdem",
                        "content": "[@Mister_CK](/Mister_CK) we all have to start somewhere :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "still counts ;-) "
                    },
                    {
                        "username": "Lainaaa",
                        "content": "I beg you to help me with understanding this task\\uD83D\\uDE4F\\n\\n`class Solution {\\n  int maxSatisfaction(List<int> satisfaction) {\\n    var array = satisfaction;\\n    array.sort();\\n    while(!array.isEmpty && array[0].abs() > array.last){\\n      array.removeAt(0);\\n    }\\n    var sum = 0;\\n    for (var i = 0; i < array.length; i++) {\\n      sum += array[i] * (i + 1);\\n    }\\n    return sum;\\n  }\\n}`\\n\\nThis is my solution, written in Dart, that similar to java and it is wrong. In my opinion all of the logic is right, help me to understand what I missed. "
                    },
                    {
                        "username": "sushi27",
                        "content": "As you choose your first dish, the time will be 1, and each time you choose a new dish, the time will increase by 1. I hope this helps you understand the question."
                    }
                ]
            },
            {
                "id": 1846693,
                "content": [
                    {
                        "username": "thinker_08",
                        "content": "This is relatively a very easy problem compared to the other HARD problems on leetcode.\\nThey should at least change the difficulty of this question to EASY or MEDIUM"
                    },
                    {
                        "username": "Pravartya",
                        "content": "i think its not that easy to think that this could be solved by greedy approach - i needed time to prove myself about the greedy approach "
                    },
                    {
                        "username": "GD18",
                        "content": "definitely not easy, i feel this is an upper med level problem, not hard tho i agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, it should be changed to medium, not to easy, it\\'s not that easy"
                    },
                    {
                        "username": "omaewamou",
                        "content": "I don't think \"easy\" tag makes any logical sense here. In any case, you would first need to sort the array, and then come up with a 0/1 DP solution or figure out the greedy pattern. Neither of these solutions are trivial. "
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "# For those who are wondering why -1 is taken in Example 1.\nSee we can start from either 0 or -1 or -8 or -9 or 5\nbut we need to maximize the like time(output)\nhence we can successfully remove bigger negative numbers like -8 and -9\nSo now we are left with 0 and -1 and 5\nsince 5 is the maximum element from the leftover elements, we would like to arrange it at the last to increase the output\nhence we are left with 0 and -1 now.\nLets check for all the cases \n- Case 1\nIf we remove -1 and get the output from the remaining elements\n -- we will get output as 0 * 1 + 5 * 2 = 10\n- Case 2\nIf we go with 0 at first and -1 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as 0 * 1 +(-1 * 2)+ 5*3 = -2+15=13\n- Case 3\nIf we go with -1 at first and 0 at second and 5 at third(obviously we will keep 5 at last so as to maximize the output)\n-- we will get output as (-1 * 1) +0 * 2+ 5*3 = -1+15=14\n\nSo clearly Case 3 gives the maximum output, hence we will take -1 then 0 then 5\n\nTo conclude i can say, we added -1 just to increase the unit time to multiply with 5(increased to 3 from 2)\n# Please upvote if I added some value."
                    },
                    {
                        "username": "Aalone_wolf",
                        "content": "Thanks Mate"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n**- The problem asks us to find the maximum satisfaction we can get from serving dishes at a restaurant. Each dish has a satisfaction value associated with it. However, serving a dish takes time, and the time taken for serving increases with the number of dishes served.**\\n\\n**- To maximize satisfaction, we need to serve dishes in a way that takes minimum time and gives maximum satisfaction. One way to do this is to serve dishes with higher satisfaction values first, so that we can accumulate more satisfaction early on.**\\n\\n**- The solution to this problem involves sorting the dishes in decreasing order of satisfaction values and then serving them in that order. We can use a priority queue to keep track of the dishes we serve, as we want to serve the dishes with the highest satisfaction values first.**\\n\\n**- We can start serving dishes from the highest satisfaction value and keep track of the total satisfaction value and the time taken for serving. We keep serving dishes until either there are no more dishes left or the total satisfaction value becomes negative. Once we stop serving, we return the total satisfaction value obtained.**\\n\\n- This solution has a time complexity of O(nlogn), as it involves sorting the array, and a space complexity of O(n), as we use a priority queue to keep track of the dishes."
                    },
                    {
                        "username": "meteogish",
                        "content": "Nice solution!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3353916/easiest-solution/"
                    },
                    {
                        "username": "odinlake",
                        "content": "The problem description is utter nonsense. This ought to be expunged together with whoever posted it."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "This should be tagged easy. Most medium questions are harder."
                    },
                    {
                        "username": "supervaka",
                        "content": "What\\'s up with the explanation for example 2?\\n\"Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\"\\n\\nIf you chose dishes in the given order of the array wouldn\\'t you get\\n(4*1 + 3*2 + 2*3 = 16)?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"*Dishes can be prepared in any order*\""
                    },
                    {
                        "username": "manifold1985",
                        "content": "\"Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Simple O(n^2) passes all the test cases :)\\nDefinitely needs better constraints or shift to easy category"
                    },
                    {
                        "username": "Hasan_Al-quoders",
                        "content": "Solve in NLOGN using some logic not brute force or shift to easy problems and stop demotivating people"
                    },
                    {
                        "username": "user2324E",
                        "content": "I think moving it to easy is a bit much. Medium would be appropriate."
                    },
                    {
                        "username": "MertErdem",
                        "content": "My first hard problem...\\nMost likely this is just a medium disguised as a hard"
                    },
                    {
                        "username": "MertErdem",
                        "content": "[@Mister_CK](/Mister_CK) we all have to start somewhere :)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "still counts ;-) "
                    },
                    {
                        "username": "Lainaaa",
                        "content": "I beg you to help me with understanding this task\\uD83D\\uDE4F\\n\\n`class Solution {\\n  int maxSatisfaction(List<int> satisfaction) {\\n    var array = satisfaction;\\n    array.sort();\\n    while(!array.isEmpty && array[0].abs() > array.last){\\n      array.removeAt(0);\\n    }\\n    var sum = 0;\\n    for (var i = 0; i < array.length; i++) {\\n      sum += array[i] * (i + 1);\\n    }\\n    return sum;\\n  }\\n}`\\n\\nThis is my solution, written in Dart, that similar to java and it is wrong. In my opinion all of the logic is right, help me to understand what I missed. "
                    },
                    {
                        "username": "sushi27",
                        "content": "As you choose your first dish, the time will be 1, and each time you choose a new dish, the time will increase by 1. I hope this helps you understand the question."
                    }
                ]
            },
            {
                "id": 1846692,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "This is more like a medium one."
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Leetcode really wants us to learn DP"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t want to downvote this problem, cause it was fun! But this should be medium in my opinion, there are no complex techniques you need to use, nor are there strict time constraints. I solved it within half an hour, which is less time than I spend on some easy and almost all medium problems. "
                    },
                    {
                        "username": "user4488fC",
                        "content": "took 2hrs just to understand the problem :(("
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "It was my first attempt to solve a HARD problem, and it felt really good to solve it though it took me few hints but I was able to solve it.\\nBasic implementation and greedy approach is all you need!"
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "Hello to 0\\uFE0F\\u20E3/1\\uFE0F\\u20E3 knapsack!"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Probably the easiest hard problem I have ever solved !!"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Sort, then loops, all cases passed, too easy to be hard."
                    },
                    {
                        "username": "RohanRPM",
                        "content": "Got TLE in recursive method. Will try in DP."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "Easy solution without DP\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3702832/very-easy-greedy-solution-without-dp/"
                    }
                ]
            },
            {
                "id": 1846690,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "This is more like a medium one."
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Leetcode really wants us to learn DP"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t want to downvote this problem, cause it was fun! But this should be medium in my opinion, there are no complex techniques you need to use, nor are there strict time constraints. I solved it within half an hour, which is less time than I spend on some easy and almost all medium problems. "
                    },
                    {
                        "username": "user4488fC",
                        "content": "took 2hrs just to understand the problem :(("
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "It was my first attempt to solve a HARD problem, and it felt really good to solve it though it took me few hints but I was able to solve it.\\nBasic implementation and greedy approach is all you need!"
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "Hello to 0\\uFE0F\\u20E3/1\\uFE0F\\u20E3 knapsack!"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Probably the easiest hard problem I have ever solved !!"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Sort, then loops, all cases passed, too easy to be hard."
                    },
                    {
                        "username": "RohanRPM",
                        "content": "Got TLE in recursive method. Will try in DP."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "Easy solution without DP\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3702832/very-easy-greedy-solution-without-dp/"
                    }
                ]
            },
            {
                "id": 1793649,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "This is more like a medium one."
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Leetcode really wants us to learn DP"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t want to downvote this problem, cause it was fun! But this should be medium in my opinion, there are no complex techniques you need to use, nor are there strict time constraints. I solved it within half an hour, which is less time than I spend on some easy and almost all medium problems. "
                    },
                    {
                        "username": "user4488fC",
                        "content": "took 2hrs just to understand the problem :(("
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "It was my first attempt to solve a HARD problem, and it felt really good to solve it though it took me few hints but I was able to solve it.\\nBasic implementation and greedy approach is all you need!"
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "Hello to 0\\uFE0F\\u20E3/1\\uFE0F\\u20E3 knapsack!"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Probably the easiest hard problem I have ever solved !!"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Sort, then loops, all cases passed, too easy to be hard."
                    },
                    {
                        "username": "RohanRPM",
                        "content": "Got TLE in recursive method. Will try in DP."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "Easy solution without DP\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3702832/very-easy-greedy-solution-without-dp/"
                    }
                ]
            },
            {
                "id": 2054631,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "This is more like a medium one."
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Leetcode really wants us to learn DP"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t want to downvote this problem, cause it was fun! But this should be medium in my opinion, there are no complex techniques you need to use, nor are there strict time constraints. I solved it within half an hour, which is less time than I spend on some easy and almost all medium problems. "
                    },
                    {
                        "username": "user4488fC",
                        "content": "took 2hrs just to understand the problem :(("
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "It was my first attempt to solve a HARD problem, and it felt really good to solve it though it took me few hints but I was able to solve it.\\nBasic implementation and greedy approach is all you need!"
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "Hello to 0\\uFE0F\\u20E3/1\\uFE0F\\u20E3 knapsack!"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Probably the easiest hard problem I have ever solved !!"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Sort, then loops, all cases passed, too easy to be hard."
                    },
                    {
                        "username": "RohanRPM",
                        "content": "Got TLE in recursive method. Will try in DP."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "Easy solution without DP\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3702832/very-easy-greedy-solution-without-dp/"
                    }
                ]
            },
            {
                "id": 2043485,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "This is more like a medium one."
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Leetcode really wants us to learn DP"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t want to downvote this problem, cause it was fun! But this should be medium in my opinion, there are no complex techniques you need to use, nor are there strict time constraints. I solved it within half an hour, which is less time than I spend on some easy and almost all medium problems. "
                    },
                    {
                        "username": "user4488fC",
                        "content": "took 2hrs just to understand the problem :(("
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "It was my first attempt to solve a HARD problem, and it felt really good to solve it though it took me few hints but I was able to solve it.\\nBasic implementation and greedy approach is all you need!"
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "Hello to 0\\uFE0F\\u20E3/1\\uFE0F\\u20E3 knapsack!"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Probably the easiest hard problem I have ever solved !!"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Sort, then loops, all cases passed, too easy to be hard."
                    },
                    {
                        "username": "RohanRPM",
                        "content": "Got TLE in recursive method. Will try in DP."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "Easy solution without DP\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3702832/very-easy-greedy-solution-without-dp/"
                    }
                ]
            },
            {
                "id": 2034504,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "This is more like a medium one."
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Leetcode really wants us to learn DP"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t want to downvote this problem, cause it was fun! But this should be medium in my opinion, there are no complex techniques you need to use, nor are there strict time constraints. I solved it within half an hour, which is less time than I spend on some easy and almost all medium problems. "
                    },
                    {
                        "username": "user4488fC",
                        "content": "took 2hrs just to understand the problem :(("
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "It was my first attempt to solve a HARD problem, and it felt really good to solve it though it took me few hints but I was able to solve it.\\nBasic implementation and greedy approach is all you need!"
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "Hello to 0\\uFE0F\\u20E3/1\\uFE0F\\u20E3 knapsack!"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Probably the easiest hard problem I have ever solved !!"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Sort, then loops, all cases passed, too easy to be hard."
                    },
                    {
                        "username": "RohanRPM",
                        "content": "Got TLE in recursive method. Will try in DP."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "Easy solution without DP\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3702832/very-easy-greedy-solution-without-dp/"
                    }
                ]
            },
            {
                "id": 2019253,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "This is more like a medium one."
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Leetcode really wants us to learn DP"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t want to downvote this problem, cause it was fun! But this should be medium in my opinion, there are no complex techniques you need to use, nor are there strict time constraints. I solved it within half an hour, which is less time than I spend on some easy and almost all medium problems. "
                    },
                    {
                        "username": "user4488fC",
                        "content": "took 2hrs just to understand the problem :(("
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "It was my first attempt to solve a HARD problem, and it felt really good to solve it though it took me few hints but I was able to solve it.\\nBasic implementation and greedy approach is all you need!"
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "Hello to 0\\uFE0F\\u20E3/1\\uFE0F\\u20E3 knapsack!"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Probably the easiest hard problem I have ever solved !!"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Sort, then loops, all cases passed, too easy to be hard."
                    },
                    {
                        "username": "RohanRPM",
                        "content": "Got TLE in recursive method. Will try in DP."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "Easy solution without DP\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3702832/very-easy-greedy-solution-without-dp/"
                    }
                ]
            },
            {
                "id": 2001609,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "This is more like a medium one."
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Leetcode really wants us to learn DP"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t want to downvote this problem, cause it was fun! But this should be medium in my opinion, there are no complex techniques you need to use, nor are there strict time constraints. I solved it within half an hour, which is less time than I spend on some easy and almost all medium problems. "
                    },
                    {
                        "username": "user4488fC",
                        "content": "took 2hrs just to understand the problem :(("
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "It was my first attempt to solve a HARD problem, and it felt really good to solve it though it took me few hints but I was able to solve it.\\nBasic implementation and greedy approach is all you need!"
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "Hello to 0\\uFE0F\\u20E3/1\\uFE0F\\u20E3 knapsack!"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Probably the easiest hard problem I have ever solved !!"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Sort, then loops, all cases passed, too easy to be hard."
                    },
                    {
                        "username": "RohanRPM",
                        "content": "Got TLE in recursive method. Will try in DP."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "Easy solution without DP\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3702832/very-easy-greedy-solution-without-dp/"
                    }
                ]
            },
            {
                "id": 1952630,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "This is more like a medium one."
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Leetcode really wants us to learn DP"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t want to downvote this problem, cause it was fun! But this should be medium in my opinion, there are no complex techniques you need to use, nor are there strict time constraints. I solved it within half an hour, which is less time than I spend on some easy and almost all medium problems. "
                    },
                    {
                        "username": "user4488fC",
                        "content": "took 2hrs just to understand the problem :(("
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "It was my first attempt to solve a HARD problem, and it felt really good to solve it though it took me few hints but I was able to solve it.\\nBasic implementation and greedy approach is all you need!"
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "Hello to 0\\uFE0F\\u20E3/1\\uFE0F\\u20E3 knapsack!"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Probably the easiest hard problem I have ever solved !!"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Sort, then loops, all cases passed, too easy to be hard."
                    },
                    {
                        "username": "RohanRPM",
                        "content": "Got TLE in recursive method. Will try in DP."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "Easy solution without DP\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3702832/very-easy-greedy-solution-without-dp/"
                    }
                ]
            },
            {
                "id": 1951250,
                "content": [
                    {
                        "username": "czjnbb",
                        "content": "This is more like a medium one."
                    },
                    {
                        "username": "bohdanlopatkin",
                        "content": "Leetcode really wants us to learn DP"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t want to downvote this problem, cause it was fun! But this should be medium in my opinion, there are no complex techniques you need to use, nor are there strict time constraints. I solved it within half an hour, which is less time than I spend on some easy and almost all medium problems. "
                    },
                    {
                        "username": "user4488fC",
                        "content": "took 2hrs just to understand the problem :(("
                    },
                    {
                        "username": "mohitxroxx",
                        "content": "It was my first attempt to solve a HARD problem, and it felt really good to solve it though it took me few hints but I was able to solve it.\\nBasic implementation and greedy approach is all you need!"
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "Hello to 0\\uFE0F\\u20E3/1\\uFE0F\\u20E3 knapsack!"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Probably the easiest hard problem I have ever solved !!"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Sort, then loops, all cases passed, too easy to be hard."
                    },
                    {
                        "username": "RohanRPM",
                        "content": "Got TLE in recursive method. Will try in DP."
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "Easy solution without DP\\nhttps://leetcode.com/problems/reducing-dishes/solutions/3702832/very-easy-greedy-solution-without-dp/"
                    }
                ]
            },
            {
                "id": 1945953,
                "content": [
                    {
                        "username": "geekyshark",
                        "content": "Don\\'t get demotivated by reading comments, its simple knapsack but with a twist, see my solution to find out the twist."
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\nQ W E R T\\nsum = Q * 1\\nsum = Q * 2 + W * 1 = previous sum + prefix sum (Q+W)\\nsum = Q * 3 + W * 2 + E = previos sum + prefix sum (Q+W+E)\\n...\\n...\\n```\\n\\nHence, accumulate prefix sum will get the result."
                    },
                    {
                        "username": "JOON1234",
                        "content": "Can someone help me why my solution is timing out? My DP solution seems to work but is cubic polynomial time.  \\n`class Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        #Since we want to prioritize multiplying time it takes to prepare a given\\n        #dish at much later time for dishes having greater satisfaction vals,\\n        #we will sort input satisfaction array in ascending order of sat.\\n        n = len(satisfaction)\\n        satisfaction.sort() \\n\\n        #Then, we realize that we could solve this using DP! \\n\\n        #1)Subproblem: Max_Sum[i][k] = max \"like-time\" coeff sum using considering dishes in sorted\\n        #input from dish i onwards, given that the next prepared dish will take time k. \\n\\n        #2)Recurrence:\\n        #Max_Sum[i][k] = max {Max_Sum[i+1][k], (satisfaction[i]*k) + max{Max_Sum[a][k+1]}} for all existing\\n        # a s.t. i < a <= n (last dish).\\n        #First term: Case where we don\\'t prepare dish i, which reduces to subproblem of considering \\n        #i+1th dish onwards and the next chosen dish in this subset of dishes takes time k.\\n        #Second term: Case where we do prepare dish i and contribute the satisfaction[i] * k to sum.\\n        #Then, we also maximize over subproblems that consider dish a onwards for all a, where next chosen\\n        #dish takes time k+1.\\n\\n        #3) Base cases:\\n        #1:Max_Sum[n][k] = satisfaction[n] * k\\n        #2: Max_Sum[i][k], where k > i = NEG_INF. \\n\\n        #The original problem can be tackeled using subproblem Max_Sum[1][1]\\n\\n        #Ok... Let\\'s initialize DP table and fil in base cases. \\n\\n        DP = [[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        for a in range(1, n+1):\\n            DP[n][a] = satisfaction[n-1] * a\\n        \\n        for c in range(1, n):\\n            for d in range(c+1, n+1):\\n                DP[c][d] = float(-inf)\\n        #Then, solve bottom-up by filling in DP table bottom to up and left to right! \\n        for i in range(n-1, 0, -1):\\n            for j in range(1, i+1, 1):\\n                #discard dish i! \\n                DP[i][j] = DP[i+1][j]\\n                #prepare dish i! \\n                contrib_sum = satisfaction[i-1] * j\\n                for a in range(i+1, n+1, 1):\\n                    DP[i][j] = max(DP[i][j], contrib_sum + DP[a][j+1])\\n        #we need this max since best we could do may not be better than simply not preparing any dishes!\\n        return max(0, DP[1][1])`"
                    },
                    {
                        "username": "najwer23",
                        "content": "The problem with this question is to figure out what time[i] stands for it and why -8 and -9 vanish in first example."
                    },
                    {
                        "username": "victorSDK",
                        "content": "I was expecting a TLE for a $$O(n^2)$$ solution, but surprisingly it passed all tests."
                    },
                    {
                        "username": "ShuyangZheng",
                        "content": "Can anyone explain the practicality of this problem? Why don\\'t we just not make dishes with 0 or negative satisfaction level altogether. Is it because that some negative dishes plus a longer wait time before a satisfying dish can make the overall experience more satisfying? It sounds so weird to me."
                    },
                    {
                        "username": "najwer23",
                        "content": "Why is it always confusion?"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Time constraint is so less that even O(n^2) is getting accepted. Don\\'t know how it is a hard problem"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "If you really understand the requirements of the problem you can come up with a simple \"EASY\" level solution.\n\nThere also exists a O(2*n) where `n == satisfaction.length` solution.\n\nPOINTER for O(2*n) Solution;\n1. You can sort the array in descending order first.\n2. then Iterate through the array and progressively increase variable `total` and `temp` but within each iteration add temp to total [`total+=temp`] before adding current element to temp. \n          You end up with the like-time coefficient for i-dishes [where `i` is iteration variable] \n3. Return the total when it starts to decrease while iteration."
                    },
                    {
                        "username": "Fangzhou233",
                        "content": "If this question is asked in real interview, the \"hard\" part is to understand what exactly is the  \"like time coefficient\" thing.. Algorithm itself is just medium level difficulty "
                    }
                ]
            },
            {
                "id": 1912646,
                "content": [
                    {
                        "username": "geekyshark",
                        "content": "Don\\'t get demotivated by reading comments, its simple knapsack but with a twist, see my solution to find out the twist."
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\nQ W E R T\\nsum = Q * 1\\nsum = Q * 2 + W * 1 = previous sum + prefix sum (Q+W)\\nsum = Q * 3 + W * 2 + E = previos sum + prefix sum (Q+W+E)\\n...\\n...\\n```\\n\\nHence, accumulate prefix sum will get the result."
                    },
                    {
                        "username": "JOON1234",
                        "content": "Can someone help me why my solution is timing out? My DP solution seems to work but is cubic polynomial time.  \\n`class Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        #Since we want to prioritize multiplying time it takes to prepare a given\\n        #dish at much later time for dishes having greater satisfaction vals,\\n        #we will sort input satisfaction array in ascending order of sat.\\n        n = len(satisfaction)\\n        satisfaction.sort() \\n\\n        #Then, we realize that we could solve this using DP! \\n\\n        #1)Subproblem: Max_Sum[i][k] = max \"like-time\" coeff sum using considering dishes in sorted\\n        #input from dish i onwards, given that the next prepared dish will take time k. \\n\\n        #2)Recurrence:\\n        #Max_Sum[i][k] = max {Max_Sum[i+1][k], (satisfaction[i]*k) + max{Max_Sum[a][k+1]}} for all existing\\n        # a s.t. i < a <= n (last dish).\\n        #First term: Case where we don\\'t prepare dish i, which reduces to subproblem of considering \\n        #i+1th dish onwards and the next chosen dish in this subset of dishes takes time k.\\n        #Second term: Case where we do prepare dish i and contribute the satisfaction[i] * k to sum.\\n        #Then, we also maximize over subproblems that consider dish a onwards for all a, where next chosen\\n        #dish takes time k+1.\\n\\n        #3) Base cases:\\n        #1:Max_Sum[n][k] = satisfaction[n] * k\\n        #2: Max_Sum[i][k], where k > i = NEG_INF. \\n\\n        #The original problem can be tackeled using subproblem Max_Sum[1][1]\\n\\n        #Ok... Let\\'s initialize DP table and fil in base cases. \\n\\n        DP = [[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        for a in range(1, n+1):\\n            DP[n][a] = satisfaction[n-1] * a\\n        \\n        for c in range(1, n):\\n            for d in range(c+1, n+1):\\n                DP[c][d] = float(-inf)\\n        #Then, solve bottom-up by filling in DP table bottom to up and left to right! \\n        for i in range(n-1, 0, -1):\\n            for j in range(1, i+1, 1):\\n                #discard dish i! \\n                DP[i][j] = DP[i+1][j]\\n                #prepare dish i! \\n                contrib_sum = satisfaction[i-1] * j\\n                for a in range(i+1, n+1, 1):\\n                    DP[i][j] = max(DP[i][j], contrib_sum + DP[a][j+1])\\n        #we need this max since best we could do may not be better than simply not preparing any dishes!\\n        return max(0, DP[1][1])`"
                    },
                    {
                        "username": "najwer23",
                        "content": "The problem with this question is to figure out what time[i] stands for it and why -8 and -9 vanish in first example."
                    },
                    {
                        "username": "victorSDK",
                        "content": "I was expecting a TLE for a $$O(n^2)$$ solution, but surprisingly it passed all tests."
                    },
                    {
                        "username": "ShuyangZheng",
                        "content": "Can anyone explain the practicality of this problem? Why don\\'t we just not make dishes with 0 or negative satisfaction level altogether. Is it because that some negative dishes plus a longer wait time before a satisfying dish can make the overall experience more satisfying? It sounds so weird to me."
                    },
                    {
                        "username": "najwer23",
                        "content": "Why is it always confusion?"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Time constraint is so less that even O(n^2) is getting accepted. Don\\'t know how it is a hard problem"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "If you really understand the requirements of the problem you can come up with a simple \"EASY\" level solution.\n\nThere also exists a O(2*n) where `n == satisfaction.length` solution.\n\nPOINTER for O(2*n) Solution;\n1. You can sort the array in descending order first.\n2. then Iterate through the array and progressively increase variable `total` and `temp` but within each iteration add temp to total [`total+=temp`] before adding current element to temp. \n          You end up with the like-time coefficient for i-dishes [where `i` is iteration variable] \n3. Return the total when it starts to decrease while iteration."
                    },
                    {
                        "username": "Fangzhou233",
                        "content": "If this question is asked in real interview, the \"hard\" part is to understand what exactly is the  \"like time coefficient\" thing.. Algorithm itself is just medium level difficulty "
                    }
                ]
            },
            {
                "id": 1907765,
                "content": [
                    {
                        "username": "geekyshark",
                        "content": "Don\\'t get demotivated by reading comments, its simple knapsack but with a twist, see my solution to find out the twist."
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\nQ W E R T\\nsum = Q * 1\\nsum = Q * 2 + W * 1 = previous sum + prefix sum (Q+W)\\nsum = Q * 3 + W * 2 + E = previos sum + prefix sum (Q+W+E)\\n...\\n...\\n```\\n\\nHence, accumulate prefix sum will get the result."
                    },
                    {
                        "username": "JOON1234",
                        "content": "Can someone help me why my solution is timing out? My DP solution seems to work but is cubic polynomial time.  \\n`class Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        #Since we want to prioritize multiplying time it takes to prepare a given\\n        #dish at much later time for dishes having greater satisfaction vals,\\n        #we will sort input satisfaction array in ascending order of sat.\\n        n = len(satisfaction)\\n        satisfaction.sort() \\n\\n        #Then, we realize that we could solve this using DP! \\n\\n        #1)Subproblem: Max_Sum[i][k] = max \"like-time\" coeff sum using considering dishes in sorted\\n        #input from dish i onwards, given that the next prepared dish will take time k. \\n\\n        #2)Recurrence:\\n        #Max_Sum[i][k] = max {Max_Sum[i+1][k], (satisfaction[i]*k) + max{Max_Sum[a][k+1]}} for all existing\\n        # a s.t. i < a <= n (last dish).\\n        #First term: Case where we don\\'t prepare dish i, which reduces to subproblem of considering \\n        #i+1th dish onwards and the next chosen dish in this subset of dishes takes time k.\\n        #Second term: Case where we do prepare dish i and contribute the satisfaction[i] * k to sum.\\n        #Then, we also maximize over subproblems that consider dish a onwards for all a, where next chosen\\n        #dish takes time k+1.\\n\\n        #3) Base cases:\\n        #1:Max_Sum[n][k] = satisfaction[n] * k\\n        #2: Max_Sum[i][k], where k > i = NEG_INF. \\n\\n        #The original problem can be tackeled using subproblem Max_Sum[1][1]\\n\\n        #Ok... Let\\'s initialize DP table and fil in base cases. \\n\\n        DP = [[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        for a in range(1, n+1):\\n            DP[n][a] = satisfaction[n-1] * a\\n        \\n        for c in range(1, n):\\n            for d in range(c+1, n+1):\\n                DP[c][d] = float(-inf)\\n        #Then, solve bottom-up by filling in DP table bottom to up and left to right! \\n        for i in range(n-1, 0, -1):\\n            for j in range(1, i+1, 1):\\n                #discard dish i! \\n                DP[i][j] = DP[i+1][j]\\n                #prepare dish i! \\n                contrib_sum = satisfaction[i-1] * j\\n                for a in range(i+1, n+1, 1):\\n                    DP[i][j] = max(DP[i][j], contrib_sum + DP[a][j+1])\\n        #we need this max since best we could do may not be better than simply not preparing any dishes!\\n        return max(0, DP[1][1])`"
                    },
                    {
                        "username": "najwer23",
                        "content": "The problem with this question is to figure out what time[i] stands for it and why -8 and -9 vanish in first example."
                    },
                    {
                        "username": "victorSDK",
                        "content": "I was expecting a TLE for a $$O(n^2)$$ solution, but surprisingly it passed all tests."
                    },
                    {
                        "username": "ShuyangZheng",
                        "content": "Can anyone explain the practicality of this problem? Why don\\'t we just not make dishes with 0 or negative satisfaction level altogether. Is it because that some negative dishes plus a longer wait time before a satisfying dish can make the overall experience more satisfying? It sounds so weird to me."
                    },
                    {
                        "username": "najwer23",
                        "content": "Why is it always confusion?"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Time constraint is so less that even O(n^2) is getting accepted. Don\\'t know how it is a hard problem"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "If you really understand the requirements of the problem you can come up with a simple \"EASY\" level solution.\n\nThere also exists a O(2*n) where `n == satisfaction.length` solution.\n\nPOINTER for O(2*n) Solution;\n1. You can sort the array in descending order first.\n2. then Iterate through the array and progressively increase variable `total` and `temp` but within each iteration add temp to total [`total+=temp`] before adding current element to temp. \n          You end up with the like-time coefficient for i-dishes [where `i` is iteration variable] \n3. Return the total when it starts to decrease while iteration."
                    },
                    {
                        "username": "Fangzhou233",
                        "content": "If this question is asked in real interview, the \"hard\" part is to understand what exactly is the  \"like time coefficient\" thing.. Algorithm itself is just medium level difficulty "
                    }
                ]
            },
            {
                "id": 1848766,
                "content": [
                    {
                        "username": "geekyshark",
                        "content": "Don\\'t get demotivated by reading comments, its simple knapsack but with a twist, see my solution to find out the twist."
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\nQ W E R T\\nsum = Q * 1\\nsum = Q * 2 + W * 1 = previous sum + prefix sum (Q+W)\\nsum = Q * 3 + W * 2 + E = previos sum + prefix sum (Q+W+E)\\n...\\n...\\n```\\n\\nHence, accumulate prefix sum will get the result."
                    },
                    {
                        "username": "JOON1234",
                        "content": "Can someone help me why my solution is timing out? My DP solution seems to work but is cubic polynomial time.  \\n`class Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        #Since we want to prioritize multiplying time it takes to prepare a given\\n        #dish at much later time for dishes having greater satisfaction vals,\\n        #we will sort input satisfaction array in ascending order of sat.\\n        n = len(satisfaction)\\n        satisfaction.sort() \\n\\n        #Then, we realize that we could solve this using DP! \\n\\n        #1)Subproblem: Max_Sum[i][k] = max \"like-time\" coeff sum using considering dishes in sorted\\n        #input from dish i onwards, given that the next prepared dish will take time k. \\n\\n        #2)Recurrence:\\n        #Max_Sum[i][k] = max {Max_Sum[i+1][k], (satisfaction[i]*k) + max{Max_Sum[a][k+1]}} for all existing\\n        # a s.t. i < a <= n (last dish).\\n        #First term: Case where we don\\'t prepare dish i, which reduces to subproblem of considering \\n        #i+1th dish onwards and the next chosen dish in this subset of dishes takes time k.\\n        #Second term: Case where we do prepare dish i and contribute the satisfaction[i] * k to sum.\\n        #Then, we also maximize over subproblems that consider dish a onwards for all a, where next chosen\\n        #dish takes time k+1.\\n\\n        #3) Base cases:\\n        #1:Max_Sum[n][k] = satisfaction[n] * k\\n        #2: Max_Sum[i][k], where k > i = NEG_INF. \\n\\n        #The original problem can be tackeled using subproblem Max_Sum[1][1]\\n\\n        #Ok... Let\\'s initialize DP table and fil in base cases. \\n\\n        DP = [[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        for a in range(1, n+1):\\n            DP[n][a] = satisfaction[n-1] * a\\n        \\n        for c in range(1, n):\\n            for d in range(c+1, n+1):\\n                DP[c][d] = float(-inf)\\n        #Then, solve bottom-up by filling in DP table bottom to up and left to right! \\n        for i in range(n-1, 0, -1):\\n            for j in range(1, i+1, 1):\\n                #discard dish i! \\n                DP[i][j] = DP[i+1][j]\\n                #prepare dish i! \\n                contrib_sum = satisfaction[i-1] * j\\n                for a in range(i+1, n+1, 1):\\n                    DP[i][j] = max(DP[i][j], contrib_sum + DP[a][j+1])\\n        #we need this max since best we could do may not be better than simply not preparing any dishes!\\n        return max(0, DP[1][1])`"
                    },
                    {
                        "username": "najwer23",
                        "content": "The problem with this question is to figure out what time[i] stands for it and why -8 and -9 vanish in first example."
                    },
                    {
                        "username": "victorSDK",
                        "content": "I was expecting a TLE for a $$O(n^2)$$ solution, but surprisingly it passed all tests."
                    },
                    {
                        "username": "ShuyangZheng",
                        "content": "Can anyone explain the practicality of this problem? Why don\\'t we just not make dishes with 0 or negative satisfaction level altogether. Is it because that some negative dishes plus a longer wait time before a satisfying dish can make the overall experience more satisfying? It sounds so weird to me."
                    },
                    {
                        "username": "najwer23",
                        "content": "Why is it always confusion?"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Time constraint is so less that even O(n^2) is getting accepted. Don\\'t know how it is a hard problem"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "If you really understand the requirements of the problem you can come up with a simple \"EASY\" level solution.\n\nThere also exists a O(2*n) where `n == satisfaction.length` solution.\n\nPOINTER for O(2*n) Solution;\n1. You can sort the array in descending order first.\n2. then Iterate through the array and progressively increase variable `total` and `temp` but within each iteration add temp to total [`total+=temp`] before adding current element to temp. \n          You end up with the like-time coefficient for i-dishes [where `i` is iteration variable] \n3. Return the total when it starts to decrease while iteration."
                    },
                    {
                        "username": "Fangzhou233",
                        "content": "If this question is asked in real interview, the \"hard\" part is to understand what exactly is the  \"like time coefficient\" thing.. Algorithm itself is just medium level difficulty "
                    }
                ]
            },
            {
                "id": 1847637,
                "content": [
                    {
                        "username": "geekyshark",
                        "content": "Don\\'t get demotivated by reading comments, its simple knapsack but with a twist, see my solution to find out the twist."
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\nQ W E R T\\nsum = Q * 1\\nsum = Q * 2 + W * 1 = previous sum + prefix sum (Q+W)\\nsum = Q * 3 + W * 2 + E = previos sum + prefix sum (Q+W+E)\\n...\\n...\\n```\\n\\nHence, accumulate prefix sum will get the result."
                    },
                    {
                        "username": "JOON1234",
                        "content": "Can someone help me why my solution is timing out? My DP solution seems to work but is cubic polynomial time.  \\n`class Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        #Since we want to prioritize multiplying time it takes to prepare a given\\n        #dish at much later time for dishes having greater satisfaction vals,\\n        #we will sort input satisfaction array in ascending order of sat.\\n        n = len(satisfaction)\\n        satisfaction.sort() \\n\\n        #Then, we realize that we could solve this using DP! \\n\\n        #1)Subproblem: Max_Sum[i][k] = max \"like-time\" coeff sum using considering dishes in sorted\\n        #input from dish i onwards, given that the next prepared dish will take time k. \\n\\n        #2)Recurrence:\\n        #Max_Sum[i][k] = max {Max_Sum[i+1][k], (satisfaction[i]*k) + max{Max_Sum[a][k+1]}} for all existing\\n        # a s.t. i < a <= n (last dish).\\n        #First term: Case where we don\\'t prepare dish i, which reduces to subproblem of considering \\n        #i+1th dish onwards and the next chosen dish in this subset of dishes takes time k.\\n        #Second term: Case where we do prepare dish i and contribute the satisfaction[i] * k to sum.\\n        #Then, we also maximize over subproblems that consider dish a onwards for all a, where next chosen\\n        #dish takes time k+1.\\n\\n        #3) Base cases:\\n        #1:Max_Sum[n][k] = satisfaction[n] * k\\n        #2: Max_Sum[i][k], where k > i = NEG_INF. \\n\\n        #The original problem can be tackeled using subproblem Max_Sum[1][1]\\n\\n        #Ok... Let\\'s initialize DP table and fil in base cases. \\n\\n        DP = [[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        for a in range(1, n+1):\\n            DP[n][a] = satisfaction[n-1] * a\\n        \\n        for c in range(1, n):\\n            for d in range(c+1, n+1):\\n                DP[c][d] = float(-inf)\\n        #Then, solve bottom-up by filling in DP table bottom to up and left to right! \\n        for i in range(n-1, 0, -1):\\n            for j in range(1, i+1, 1):\\n                #discard dish i! \\n                DP[i][j] = DP[i+1][j]\\n                #prepare dish i! \\n                contrib_sum = satisfaction[i-1] * j\\n                for a in range(i+1, n+1, 1):\\n                    DP[i][j] = max(DP[i][j], contrib_sum + DP[a][j+1])\\n        #we need this max since best we could do may not be better than simply not preparing any dishes!\\n        return max(0, DP[1][1])`"
                    },
                    {
                        "username": "najwer23",
                        "content": "The problem with this question is to figure out what time[i] stands for it and why -8 and -9 vanish in first example."
                    },
                    {
                        "username": "victorSDK",
                        "content": "I was expecting a TLE for a $$O(n^2)$$ solution, but surprisingly it passed all tests."
                    },
                    {
                        "username": "ShuyangZheng",
                        "content": "Can anyone explain the practicality of this problem? Why don\\'t we just not make dishes with 0 or negative satisfaction level altogether. Is it because that some negative dishes plus a longer wait time before a satisfying dish can make the overall experience more satisfying? It sounds so weird to me."
                    },
                    {
                        "username": "najwer23",
                        "content": "Why is it always confusion?"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Time constraint is so less that even O(n^2) is getting accepted. Don\\'t know how it is a hard problem"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "If you really understand the requirements of the problem you can come up with a simple \"EASY\" level solution.\n\nThere also exists a O(2*n) where `n == satisfaction.length` solution.\n\nPOINTER for O(2*n) Solution;\n1. You can sort the array in descending order first.\n2. then Iterate through the array and progressively increase variable `total` and `temp` but within each iteration add temp to total [`total+=temp`] before adding current element to temp. \n          You end up with the like-time coefficient for i-dishes [where `i` is iteration variable] \n3. Return the total when it starts to decrease while iteration."
                    },
                    {
                        "username": "Fangzhou233",
                        "content": "If this question is asked in real interview, the \"hard\" part is to understand what exactly is the  \"like time coefficient\" thing.. Algorithm itself is just medium level difficulty "
                    }
                ]
            },
            {
                "id": 1847611,
                "content": [
                    {
                        "username": "geekyshark",
                        "content": "Don\\'t get demotivated by reading comments, its simple knapsack but with a twist, see my solution to find out the twist."
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\nQ W E R T\\nsum = Q * 1\\nsum = Q * 2 + W * 1 = previous sum + prefix sum (Q+W)\\nsum = Q * 3 + W * 2 + E = previos sum + prefix sum (Q+W+E)\\n...\\n...\\n```\\n\\nHence, accumulate prefix sum will get the result."
                    },
                    {
                        "username": "JOON1234",
                        "content": "Can someone help me why my solution is timing out? My DP solution seems to work but is cubic polynomial time.  \\n`class Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        #Since we want to prioritize multiplying time it takes to prepare a given\\n        #dish at much later time for dishes having greater satisfaction vals,\\n        #we will sort input satisfaction array in ascending order of sat.\\n        n = len(satisfaction)\\n        satisfaction.sort() \\n\\n        #Then, we realize that we could solve this using DP! \\n\\n        #1)Subproblem: Max_Sum[i][k] = max \"like-time\" coeff sum using considering dishes in sorted\\n        #input from dish i onwards, given that the next prepared dish will take time k. \\n\\n        #2)Recurrence:\\n        #Max_Sum[i][k] = max {Max_Sum[i+1][k], (satisfaction[i]*k) + max{Max_Sum[a][k+1]}} for all existing\\n        # a s.t. i < a <= n (last dish).\\n        #First term: Case where we don\\'t prepare dish i, which reduces to subproblem of considering \\n        #i+1th dish onwards and the next chosen dish in this subset of dishes takes time k.\\n        #Second term: Case where we do prepare dish i and contribute the satisfaction[i] * k to sum.\\n        #Then, we also maximize over subproblems that consider dish a onwards for all a, where next chosen\\n        #dish takes time k+1.\\n\\n        #3) Base cases:\\n        #1:Max_Sum[n][k] = satisfaction[n] * k\\n        #2: Max_Sum[i][k], where k > i = NEG_INF. \\n\\n        #The original problem can be tackeled using subproblem Max_Sum[1][1]\\n\\n        #Ok... Let\\'s initialize DP table and fil in base cases. \\n\\n        DP = [[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        for a in range(1, n+1):\\n            DP[n][a] = satisfaction[n-1] * a\\n        \\n        for c in range(1, n):\\n            for d in range(c+1, n+1):\\n                DP[c][d] = float(-inf)\\n        #Then, solve bottom-up by filling in DP table bottom to up and left to right! \\n        for i in range(n-1, 0, -1):\\n            for j in range(1, i+1, 1):\\n                #discard dish i! \\n                DP[i][j] = DP[i+1][j]\\n                #prepare dish i! \\n                contrib_sum = satisfaction[i-1] * j\\n                for a in range(i+1, n+1, 1):\\n                    DP[i][j] = max(DP[i][j], contrib_sum + DP[a][j+1])\\n        #we need this max since best we could do may not be better than simply not preparing any dishes!\\n        return max(0, DP[1][1])`"
                    },
                    {
                        "username": "najwer23",
                        "content": "The problem with this question is to figure out what time[i] stands for it and why -8 and -9 vanish in first example."
                    },
                    {
                        "username": "victorSDK",
                        "content": "I was expecting a TLE for a $$O(n^2)$$ solution, but surprisingly it passed all tests."
                    },
                    {
                        "username": "ShuyangZheng",
                        "content": "Can anyone explain the practicality of this problem? Why don\\'t we just not make dishes with 0 or negative satisfaction level altogether. Is it because that some negative dishes plus a longer wait time before a satisfying dish can make the overall experience more satisfying? It sounds so weird to me."
                    },
                    {
                        "username": "najwer23",
                        "content": "Why is it always confusion?"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Time constraint is so less that even O(n^2) is getting accepted. Don\\'t know how it is a hard problem"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "If you really understand the requirements of the problem you can come up with a simple \"EASY\" level solution.\n\nThere also exists a O(2*n) where `n == satisfaction.length` solution.\n\nPOINTER for O(2*n) Solution;\n1. You can sort the array in descending order first.\n2. then Iterate through the array and progressively increase variable `total` and `temp` but within each iteration add temp to total [`total+=temp`] before adding current element to temp. \n          You end up with the like-time coefficient for i-dishes [where `i` is iteration variable] \n3. Return the total when it starts to decrease while iteration."
                    },
                    {
                        "username": "Fangzhou233",
                        "content": "If this question is asked in real interview, the \"hard\" part is to understand what exactly is the  \"like time coefficient\" thing.. Algorithm itself is just medium level difficulty "
                    }
                ]
            },
            {
                "id": 1847540,
                "content": [
                    {
                        "username": "geekyshark",
                        "content": "Don\\'t get demotivated by reading comments, its simple knapsack but with a twist, see my solution to find out the twist."
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\nQ W E R T\\nsum = Q * 1\\nsum = Q * 2 + W * 1 = previous sum + prefix sum (Q+W)\\nsum = Q * 3 + W * 2 + E = previos sum + prefix sum (Q+W+E)\\n...\\n...\\n```\\n\\nHence, accumulate prefix sum will get the result."
                    },
                    {
                        "username": "JOON1234",
                        "content": "Can someone help me why my solution is timing out? My DP solution seems to work but is cubic polynomial time.  \\n`class Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        #Since we want to prioritize multiplying time it takes to prepare a given\\n        #dish at much later time for dishes having greater satisfaction vals,\\n        #we will sort input satisfaction array in ascending order of sat.\\n        n = len(satisfaction)\\n        satisfaction.sort() \\n\\n        #Then, we realize that we could solve this using DP! \\n\\n        #1)Subproblem: Max_Sum[i][k] = max \"like-time\" coeff sum using considering dishes in sorted\\n        #input from dish i onwards, given that the next prepared dish will take time k. \\n\\n        #2)Recurrence:\\n        #Max_Sum[i][k] = max {Max_Sum[i+1][k], (satisfaction[i]*k) + max{Max_Sum[a][k+1]}} for all existing\\n        # a s.t. i < a <= n (last dish).\\n        #First term: Case where we don\\'t prepare dish i, which reduces to subproblem of considering \\n        #i+1th dish onwards and the next chosen dish in this subset of dishes takes time k.\\n        #Second term: Case where we do prepare dish i and contribute the satisfaction[i] * k to sum.\\n        #Then, we also maximize over subproblems that consider dish a onwards for all a, where next chosen\\n        #dish takes time k+1.\\n\\n        #3) Base cases:\\n        #1:Max_Sum[n][k] = satisfaction[n] * k\\n        #2: Max_Sum[i][k], where k > i = NEG_INF. \\n\\n        #The original problem can be tackeled using subproblem Max_Sum[1][1]\\n\\n        #Ok... Let\\'s initialize DP table and fil in base cases. \\n\\n        DP = [[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        for a in range(1, n+1):\\n            DP[n][a] = satisfaction[n-1] * a\\n        \\n        for c in range(1, n):\\n            for d in range(c+1, n+1):\\n                DP[c][d] = float(-inf)\\n        #Then, solve bottom-up by filling in DP table bottom to up and left to right! \\n        for i in range(n-1, 0, -1):\\n            for j in range(1, i+1, 1):\\n                #discard dish i! \\n                DP[i][j] = DP[i+1][j]\\n                #prepare dish i! \\n                contrib_sum = satisfaction[i-1] * j\\n                for a in range(i+1, n+1, 1):\\n                    DP[i][j] = max(DP[i][j], contrib_sum + DP[a][j+1])\\n        #we need this max since best we could do may not be better than simply not preparing any dishes!\\n        return max(0, DP[1][1])`"
                    },
                    {
                        "username": "najwer23",
                        "content": "The problem with this question is to figure out what time[i] stands for it and why -8 and -9 vanish in first example."
                    },
                    {
                        "username": "victorSDK",
                        "content": "I was expecting a TLE for a $$O(n^2)$$ solution, but surprisingly it passed all tests."
                    },
                    {
                        "username": "ShuyangZheng",
                        "content": "Can anyone explain the practicality of this problem? Why don\\'t we just not make dishes with 0 or negative satisfaction level altogether. Is it because that some negative dishes plus a longer wait time before a satisfying dish can make the overall experience more satisfying? It sounds so weird to me."
                    },
                    {
                        "username": "najwer23",
                        "content": "Why is it always confusion?"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Time constraint is so less that even O(n^2) is getting accepted. Don\\'t know how it is a hard problem"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "If you really understand the requirements of the problem you can come up with a simple \"EASY\" level solution.\n\nThere also exists a O(2*n) where `n == satisfaction.length` solution.\n\nPOINTER for O(2*n) Solution;\n1. You can sort the array in descending order first.\n2. then Iterate through the array and progressively increase variable `total` and `temp` but within each iteration add temp to total [`total+=temp`] before adding current element to temp. \n          You end up with the like-time coefficient for i-dishes [where `i` is iteration variable] \n3. Return the total when it starts to decrease while iteration."
                    },
                    {
                        "username": "Fangzhou233",
                        "content": "If this question is asked in real interview, the \"hard\" part is to understand what exactly is the  \"like time coefficient\" thing.. Algorithm itself is just medium level difficulty "
                    }
                ]
            },
            {
                "id": 1847471,
                "content": [
                    {
                        "username": "geekyshark",
                        "content": "Don\\'t get demotivated by reading comments, its simple knapsack but with a twist, see my solution to find out the twist."
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\nQ W E R T\\nsum = Q * 1\\nsum = Q * 2 + W * 1 = previous sum + prefix sum (Q+W)\\nsum = Q * 3 + W * 2 + E = previos sum + prefix sum (Q+W+E)\\n...\\n...\\n```\\n\\nHence, accumulate prefix sum will get the result."
                    },
                    {
                        "username": "JOON1234",
                        "content": "Can someone help me why my solution is timing out? My DP solution seems to work but is cubic polynomial time.  \\n`class Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        #Since we want to prioritize multiplying time it takes to prepare a given\\n        #dish at much later time for dishes having greater satisfaction vals,\\n        #we will sort input satisfaction array in ascending order of sat.\\n        n = len(satisfaction)\\n        satisfaction.sort() \\n\\n        #Then, we realize that we could solve this using DP! \\n\\n        #1)Subproblem: Max_Sum[i][k] = max \"like-time\" coeff sum using considering dishes in sorted\\n        #input from dish i onwards, given that the next prepared dish will take time k. \\n\\n        #2)Recurrence:\\n        #Max_Sum[i][k] = max {Max_Sum[i+1][k], (satisfaction[i]*k) + max{Max_Sum[a][k+1]}} for all existing\\n        # a s.t. i < a <= n (last dish).\\n        #First term: Case where we don\\'t prepare dish i, which reduces to subproblem of considering \\n        #i+1th dish onwards and the next chosen dish in this subset of dishes takes time k.\\n        #Second term: Case where we do prepare dish i and contribute the satisfaction[i] * k to sum.\\n        #Then, we also maximize over subproblems that consider dish a onwards for all a, where next chosen\\n        #dish takes time k+1.\\n\\n        #3) Base cases:\\n        #1:Max_Sum[n][k] = satisfaction[n] * k\\n        #2: Max_Sum[i][k], where k > i = NEG_INF. \\n\\n        #The original problem can be tackeled using subproblem Max_Sum[1][1]\\n\\n        #Ok... Let\\'s initialize DP table and fil in base cases. \\n\\n        DP = [[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        for a in range(1, n+1):\\n            DP[n][a] = satisfaction[n-1] * a\\n        \\n        for c in range(1, n):\\n            for d in range(c+1, n+1):\\n                DP[c][d] = float(-inf)\\n        #Then, solve bottom-up by filling in DP table bottom to up and left to right! \\n        for i in range(n-1, 0, -1):\\n            for j in range(1, i+1, 1):\\n                #discard dish i! \\n                DP[i][j] = DP[i+1][j]\\n                #prepare dish i! \\n                contrib_sum = satisfaction[i-1] * j\\n                for a in range(i+1, n+1, 1):\\n                    DP[i][j] = max(DP[i][j], contrib_sum + DP[a][j+1])\\n        #we need this max since best we could do may not be better than simply not preparing any dishes!\\n        return max(0, DP[1][1])`"
                    },
                    {
                        "username": "najwer23",
                        "content": "The problem with this question is to figure out what time[i] stands for it and why -8 and -9 vanish in first example."
                    },
                    {
                        "username": "victorSDK",
                        "content": "I was expecting a TLE for a $$O(n^2)$$ solution, but surprisingly it passed all tests."
                    },
                    {
                        "username": "ShuyangZheng",
                        "content": "Can anyone explain the practicality of this problem? Why don\\'t we just not make dishes with 0 or negative satisfaction level altogether. Is it because that some negative dishes plus a longer wait time before a satisfying dish can make the overall experience more satisfying? It sounds so weird to me."
                    },
                    {
                        "username": "najwer23",
                        "content": "Why is it always confusion?"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Time constraint is so less that even O(n^2) is getting accepted. Don\\'t know how it is a hard problem"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "If you really understand the requirements of the problem you can come up with a simple \"EASY\" level solution.\n\nThere also exists a O(2*n) where `n == satisfaction.length` solution.\n\nPOINTER for O(2*n) Solution;\n1. You can sort the array in descending order first.\n2. then Iterate through the array and progressively increase variable `total` and `temp` but within each iteration add temp to total [`total+=temp`] before adding current element to temp. \n          You end up with the like-time coefficient for i-dishes [where `i` is iteration variable] \n3. Return the total when it starts to decrease while iteration."
                    },
                    {
                        "username": "Fangzhou233",
                        "content": "If this question is asked in real interview, the \"hard\" part is to understand what exactly is the  \"like time coefficient\" thing.. Algorithm itself is just medium level difficulty "
                    }
                ]
            },
            {
                "id": 1847380,
                "content": [
                    {
                        "username": "geekyshark",
                        "content": "Don\\'t get demotivated by reading comments, its simple knapsack but with a twist, see my solution to find out the twist."
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\nQ W E R T\\nsum = Q * 1\\nsum = Q * 2 + W * 1 = previous sum + prefix sum (Q+W)\\nsum = Q * 3 + W * 2 + E = previos sum + prefix sum (Q+W+E)\\n...\\n...\\n```\\n\\nHence, accumulate prefix sum will get the result."
                    },
                    {
                        "username": "JOON1234",
                        "content": "Can someone help me why my solution is timing out? My DP solution seems to work but is cubic polynomial time.  \\n`class Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        #Since we want to prioritize multiplying time it takes to prepare a given\\n        #dish at much later time for dishes having greater satisfaction vals,\\n        #we will sort input satisfaction array in ascending order of sat.\\n        n = len(satisfaction)\\n        satisfaction.sort() \\n\\n        #Then, we realize that we could solve this using DP! \\n\\n        #1)Subproblem: Max_Sum[i][k] = max \"like-time\" coeff sum using considering dishes in sorted\\n        #input from dish i onwards, given that the next prepared dish will take time k. \\n\\n        #2)Recurrence:\\n        #Max_Sum[i][k] = max {Max_Sum[i+1][k], (satisfaction[i]*k) + max{Max_Sum[a][k+1]}} for all existing\\n        # a s.t. i < a <= n (last dish).\\n        #First term: Case where we don\\'t prepare dish i, which reduces to subproblem of considering \\n        #i+1th dish onwards and the next chosen dish in this subset of dishes takes time k.\\n        #Second term: Case where we do prepare dish i and contribute the satisfaction[i] * k to sum.\\n        #Then, we also maximize over subproblems that consider dish a onwards for all a, where next chosen\\n        #dish takes time k+1.\\n\\n        #3) Base cases:\\n        #1:Max_Sum[n][k] = satisfaction[n] * k\\n        #2: Max_Sum[i][k], where k > i = NEG_INF. \\n\\n        #The original problem can be tackeled using subproblem Max_Sum[1][1]\\n\\n        #Ok... Let\\'s initialize DP table and fil in base cases. \\n\\n        DP = [[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        for a in range(1, n+1):\\n            DP[n][a] = satisfaction[n-1] * a\\n        \\n        for c in range(1, n):\\n            for d in range(c+1, n+1):\\n                DP[c][d] = float(-inf)\\n        #Then, solve bottom-up by filling in DP table bottom to up and left to right! \\n        for i in range(n-1, 0, -1):\\n            for j in range(1, i+1, 1):\\n                #discard dish i! \\n                DP[i][j] = DP[i+1][j]\\n                #prepare dish i! \\n                contrib_sum = satisfaction[i-1] * j\\n                for a in range(i+1, n+1, 1):\\n                    DP[i][j] = max(DP[i][j], contrib_sum + DP[a][j+1])\\n        #we need this max since best we could do may not be better than simply not preparing any dishes!\\n        return max(0, DP[1][1])`"
                    },
                    {
                        "username": "najwer23",
                        "content": "The problem with this question is to figure out what time[i] stands for it and why -8 and -9 vanish in first example."
                    },
                    {
                        "username": "victorSDK",
                        "content": "I was expecting a TLE for a $$O(n^2)$$ solution, but surprisingly it passed all tests."
                    },
                    {
                        "username": "ShuyangZheng",
                        "content": "Can anyone explain the practicality of this problem? Why don\\'t we just not make dishes with 0 or negative satisfaction level altogether. Is it because that some negative dishes plus a longer wait time before a satisfying dish can make the overall experience more satisfying? It sounds so weird to me."
                    },
                    {
                        "username": "najwer23",
                        "content": "Why is it always confusion?"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Time constraint is so less that even O(n^2) is getting accepted. Don\\'t know how it is a hard problem"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "If you really understand the requirements of the problem you can come up with a simple \"EASY\" level solution.\n\nThere also exists a O(2*n) where `n == satisfaction.length` solution.\n\nPOINTER for O(2*n) Solution;\n1. You can sort the array in descending order first.\n2. then Iterate through the array and progressively increase variable `total` and `temp` but within each iteration add temp to total [`total+=temp`] before adding current element to temp. \n          You end up with the like-time coefficient for i-dishes [where `i` is iteration variable] \n3. Return the total when it starts to decrease while iteration."
                    },
                    {
                        "username": "Fangzhou233",
                        "content": "If this question is asked in real interview, the \"hard\" part is to understand what exactly is the  \"like time coefficient\" thing.. Algorithm itself is just medium level difficulty "
                    }
                ]
            },
            {
                "id": 1847102,
                "content": [
                    {
                        "username": "geekyshark",
                        "content": "Don\\'t get demotivated by reading comments, its simple knapsack but with a twist, see my solution to find out the twist."
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\nQ W E R T\\nsum = Q * 1\\nsum = Q * 2 + W * 1 = previous sum + prefix sum (Q+W)\\nsum = Q * 3 + W * 2 + E = previos sum + prefix sum (Q+W+E)\\n...\\n...\\n```\\n\\nHence, accumulate prefix sum will get the result."
                    },
                    {
                        "username": "JOON1234",
                        "content": "Can someone help me why my solution is timing out? My DP solution seems to work but is cubic polynomial time.  \\n`class Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        #Since we want to prioritize multiplying time it takes to prepare a given\\n        #dish at much later time for dishes having greater satisfaction vals,\\n        #we will sort input satisfaction array in ascending order of sat.\\n        n = len(satisfaction)\\n        satisfaction.sort() \\n\\n        #Then, we realize that we could solve this using DP! \\n\\n        #1)Subproblem: Max_Sum[i][k] = max \"like-time\" coeff sum using considering dishes in sorted\\n        #input from dish i onwards, given that the next prepared dish will take time k. \\n\\n        #2)Recurrence:\\n        #Max_Sum[i][k] = max {Max_Sum[i+1][k], (satisfaction[i]*k) + max{Max_Sum[a][k+1]}} for all existing\\n        # a s.t. i < a <= n (last dish).\\n        #First term: Case where we don\\'t prepare dish i, which reduces to subproblem of considering \\n        #i+1th dish onwards and the next chosen dish in this subset of dishes takes time k.\\n        #Second term: Case where we do prepare dish i and contribute the satisfaction[i] * k to sum.\\n        #Then, we also maximize over subproblems that consider dish a onwards for all a, where next chosen\\n        #dish takes time k+1.\\n\\n        #3) Base cases:\\n        #1:Max_Sum[n][k] = satisfaction[n] * k\\n        #2: Max_Sum[i][k], where k > i = NEG_INF. \\n\\n        #The original problem can be tackeled using subproblem Max_Sum[1][1]\\n\\n        #Ok... Let\\'s initialize DP table and fil in base cases. \\n\\n        DP = [[-1 for _ in range(n+1)] for _ in range(n+1)]\\n        for a in range(1, n+1):\\n            DP[n][a] = satisfaction[n-1] * a\\n        \\n        for c in range(1, n):\\n            for d in range(c+1, n+1):\\n                DP[c][d] = float(-inf)\\n        #Then, solve bottom-up by filling in DP table bottom to up and left to right! \\n        for i in range(n-1, 0, -1):\\n            for j in range(1, i+1, 1):\\n                #discard dish i! \\n                DP[i][j] = DP[i+1][j]\\n                #prepare dish i! \\n                contrib_sum = satisfaction[i-1] * j\\n                for a in range(i+1, n+1, 1):\\n                    DP[i][j] = max(DP[i][j], contrib_sum + DP[a][j+1])\\n        #we need this max since best we could do may not be better than simply not preparing any dishes!\\n        return max(0, DP[1][1])`"
                    },
                    {
                        "username": "najwer23",
                        "content": "The problem with this question is to figure out what time[i] stands for it and why -8 and -9 vanish in first example."
                    },
                    {
                        "username": "victorSDK",
                        "content": "I was expecting a TLE for a $$O(n^2)$$ solution, but surprisingly it passed all tests."
                    },
                    {
                        "username": "ShuyangZheng",
                        "content": "Can anyone explain the practicality of this problem? Why don\\'t we just not make dishes with 0 or negative satisfaction level altogether. Is it because that some negative dishes plus a longer wait time before a satisfying dish can make the overall experience more satisfying? It sounds so weird to me."
                    },
                    {
                        "username": "najwer23",
                        "content": "Why is it always confusion?"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Time constraint is so less that even O(n^2) is getting accepted. Don\\'t know how it is a hard problem"
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "If you really understand the requirements of the problem you can come up with a simple \"EASY\" level solution.\n\nThere also exists a O(2*n) where `n == satisfaction.length` solution.\n\nPOINTER for O(2*n) Solution;\n1. You can sort the array in descending order first.\n2. then Iterate through the array and progressively increase variable `total` and `temp` but within each iteration add temp to total [`total+=temp`] before adding current element to temp. \n          You end up with the like-time coefficient for i-dishes [where `i` is iteration variable] \n3. Return the total when it starts to decrease while iteration."
                    },
                    {
                        "username": "Fangzhou233",
                        "content": "If this question is asked in real interview, the \"hard\" part is to understand what exactly is the  \"like time coefficient\" thing.. Algorithm itself is just medium level difficulty "
                    }
                ]
            },
            {
                "id": 1847077,
                "content": [
                    {
                        "username": "cenjian",
                        "content": "hint: discard the most negative dishes until the sum of negative dishes is smaller than sum of positive ones. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Wow , easiest hard problem I ever solved !!"
                    },
                    {
                        "username": "zkamil",
                        "content": "Tips:\\n1. When deciding whether to include or not dish with negative rate, solve simple math inequality - max sum including negative dish should be more or equal to sum not including that dish. Once you solve that inequality, you will find a simple condition helping you with decision on including negative number. \\n2. Higher rated dishes deserve bigger multipliers."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "after sort `satisfaction`, the maximum sum of like-time coefficient `f[i]` that the chef can obtain if he prepares all dishes correspond to all satisfaction from `satisfaction[i]` to `satisfaction[n-1]` will be:\n$f[i]=satisfaction[i]+cumulativeSumFrom[i+1]+f[i+1]$\nor\n$f[i]=f[i+1]+cumulativeSumFrom[i]$\nAnd you don't need to use any array to memorise, instead, use 2 variables eg. `maxSumSatisfaction`  and `cumulativeSum` to track the previous result. Don't forget to return the answer whenever the current result is smaller than the previous one."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip if you are confused:-\\n\\n\\nThe only thing to think here is that you have to sort the array before passing to get the maximum possible outcome, as we want to multiply the largest satisfaction with the largest time. Other than that, it\\'s a basic dp problem, medium at best."
                    },
                    {
                        "username": "anwendeng",
                        "content": "After sorting the array, this problem becomes much easier."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well Easy Hard question is here !"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m not the first to say it, and I wont be the last: this was extremely easy for a hard problem. I\\'ve only been coding for 3 1/2 months and I finished this in 10-15 minutes"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Think about the logical extreme, if you could pick any single dish you wanted and serve it any time you want, what would you pick to maximize the \"like-time coefficient\"? The obvious answer is the most popular dish (highest satisfaction value) and serve it as late as possible since [big number] * [big number] = [bigger number].\\n\\nHow can you use this idea to maximize the sum of all like-time coefficients when one dish must be served after the other?"
                    },
                    {
                        "username": "user8228j",
                        "content": "everyone here saying its super easy meanwhile i wasted 30 minutes trying to get it working with binary search just to realize it doesn't work\nEdit: it is possible to solve with \"gradient ascent\" (check mid and mid+1 and change low and high boundaries based on which one is bigger)\nbut I don't think it is a sound solution because of \"ties\" (if mid and mid+1 give same number, dont know which direction to go). But as of this date no test case had this (if its even possible for one to exist) I guess so it passed"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Don\\'t overthink it. You can do it! This problem makes itself look harder than it actually is."
                    }
                ]
            },
            {
                "id": 1847063,
                "content": [
                    {
                        "username": "cenjian",
                        "content": "hint: discard the most negative dishes until the sum of negative dishes is smaller than sum of positive ones. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Wow , easiest hard problem I ever solved !!"
                    },
                    {
                        "username": "zkamil",
                        "content": "Tips:\\n1. When deciding whether to include or not dish with negative rate, solve simple math inequality - max sum including negative dish should be more or equal to sum not including that dish. Once you solve that inequality, you will find a simple condition helping you with decision on including negative number. \\n2. Higher rated dishes deserve bigger multipliers."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "after sort `satisfaction`, the maximum sum of like-time coefficient `f[i]` that the chef can obtain if he prepares all dishes correspond to all satisfaction from `satisfaction[i]` to `satisfaction[n-1]` will be:\n$f[i]=satisfaction[i]+cumulativeSumFrom[i+1]+f[i+1]$\nor\n$f[i]=f[i+1]+cumulativeSumFrom[i]$\nAnd you don't need to use any array to memorise, instead, use 2 variables eg. `maxSumSatisfaction`  and `cumulativeSum` to track the previous result. Don't forget to return the answer whenever the current result is smaller than the previous one."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip if you are confused:-\\n\\n\\nThe only thing to think here is that you have to sort the array before passing to get the maximum possible outcome, as we want to multiply the largest satisfaction with the largest time. Other than that, it\\'s a basic dp problem, medium at best."
                    },
                    {
                        "username": "anwendeng",
                        "content": "After sorting the array, this problem becomes much easier."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well Easy Hard question is here !"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m not the first to say it, and I wont be the last: this was extremely easy for a hard problem. I\\'ve only been coding for 3 1/2 months and I finished this in 10-15 minutes"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Think about the logical extreme, if you could pick any single dish you wanted and serve it any time you want, what would you pick to maximize the \"like-time coefficient\"? The obvious answer is the most popular dish (highest satisfaction value) and serve it as late as possible since [big number] * [big number] = [bigger number].\\n\\nHow can you use this idea to maximize the sum of all like-time coefficients when one dish must be served after the other?"
                    },
                    {
                        "username": "user8228j",
                        "content": "everyone here saying its super easy meanwhile i wasted 30 minutes trying to get it working with binary search just to realize it doesn't work\nEdit: it is possible to solve with \"gradient ascent\" (check mid and mid+1 and change low and high boundaries based on which one is bigger)\nbut I don't think it is a sound solution because of \"ties\" (if mid and mid+1 give same number, dont know which direction to go). But as of this date no test case had this (if its even possible for one to exist) I guess so it passed"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Don\\'t overthink it. You can do it! This problem makes itself look harder than it actually is."
                    }
                ]
            },
            {
                "id": 1847002,
                "content": [
                    {
                        "username": "cenjian",
                        "content": "hint: discard the most negative dishes until the sum of negative dishes is smaller than sum of positive ones. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Wow , easiest hard problem I ever solved !!"
                    },
                    {
                        "username": "zkamil",
                        "content": "Tips:\\n1. When deciding whether to include or not dish with negative rate, solve simple math inequality - max sum including negative dish should be more or equal to sum not including that dish. Once you solve that inequality, you will find a simple condition helping you with decision on including negative number. \\n2. Higher rated dishes deserve bigger multipliers."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "after sort `satisfaction`, the maximum sum of like-time coefficient `f[i]` that the chef can obtain if he prepares all dishes correspond to all satisfaction from `satisfaction[i]` to `satisfaction[n-1]` will be:\n$f[i]=satisfaction[i]+cumulativeSumFrom[i+1]+f[i+1]$\nor\n$f[i]=f[i+1]+cumulativeSumFrom[i]$\nAnd you don't need to use any array to memorise, instead, use 2 variables eg. `maxSumSatisfaction`  and `cumulativeSum` to track the previous result. Don't forget to return the answer whenever the current result is smaller than the previous one."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip if you are confused:-\\n\\n\\nThe only thing to think here is that you have to sort the array before passing to get the maximum possible outcome, as we want to multiply the largest satisfaction with the largest time. Other than that, it\\'s a basic dp problem, medium at best."
                    },
                    {
                        "username": "anwendeng",
                        "content": "After sorting the array, this problem becomes much easier."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well Easy Hard question is here !"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m not the first to say it, and I wont be the last: this was extremely easy for a hard problem. I\\'ve only been coding for 3 1/2 months and I finished this in 10-15 minutes"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Think about the logical extreme, if you could pick any single dish you wanted and serve it any time you want, what would you pick to maximize the \"like-time coefficient\"? The obvious answer is the most popular dish (highest satisfaction value) and serve it as late as possible since [big number] * [big number] = [bigger number].\\n\\nHow can you use this idea to maximize the sum of all like-time coefficients when one dish must be served after the other?"
                    },
                    {
                        "username": "user8228j",
                        "content": "everyone here saying its super easy meanwhile i wasted 30 minutes trying to get it working with binary search just to realize it doesn't work\nEdit: it is possible to solve with \"gradient ascent\" (check mid and mid+1 and change low and high boundaries based on which one is bigger)\nbut I don't think it is a sound solution because of \"ties\" (if mid and mid+1 give same number, dont know which direction to go). But as of this date no test case had this (if its even possible for one to exist) I guess so it passed"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Don\\'t overthink it. You can do it! This problem makes itself look harder than it actually is."
                    }
                ]
            },
            {
                "id": 1846994,
                "content": [
                    {
                        "username": "cenjian",
                        "content": "hint: discard the most negative dishes until the sum of negative dishes is smaller than sum of positive ones. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Wow , easiest hard problem I ever solved !!"
                    },
                    {
                        "username": "zkamil",
                        "content": "Tips:\\n1. When deciding whether to include or not dish with negative rate, solve simple math inequality - max sum including negative dish should be more or equal to sum not including that dish. Once you solve that inequality, you will find a simple condition helping you with decision on including negative number. \\n2. Higher rated dishes deserve bigger multipliers."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "after sort `satisfaction`, the maximum sum of like-time coefficient `f[i]` that the chef can obtain if he prepares all dishes correspond to all satisfaction from `satisfaction[i]` to `satisfaction[n-1]` will be:\n$f[i]=satisfaction[i]+cumulativeSumFrom[i+1]+f[i+1]$\nor\n$f[i]=f[i+1]+cumulativeSumFrom[i]$\nAnd you don't need to use any array to memorise, instead, use 2 variables eg. `maxSumSatisfaction`  and `cumulativeSum` to track the previous result. Don't forget to return the answer whenever the current result is smaller than the previous one."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip if you are confused:-\\n\\n\\nThe only thing to think here is that you have to sort the array before passing to get the maximum possible outcome, as we want to multiply the largest satisfaction with the largest time. Other than that, it\\'s a basic dp problem, medium at best."
                    },
                    {
                        "username": "anwendeng",
                        "content": "After sorting the array, this problem becomes much easier."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well Easy Hard question is here !"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m not the first to say it, and I wont be the last: this was extremely easy for a hard problem. I\\'ve only been coding for 3 1/2 months and I finished this in 10-15 minutes"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Think about the logical extreme, if you could pick any single dish you wanted and serve it any time you want, what would you pick to maximize the \"like-time coefficient\"? The obvious answer is the most popular dish (highest satisfaction value) and serve it as late as possible since [big number] * [big number] = [bigger number].\\n\\nHow can you use this idea to maximize the sum of all like-time coefficients when one dish must be served after the other?"
                    },
                    {
                        "username": "user8228j",
                        "content": "everyone here saying its super easy meanwhile i wasted 30 minutes trying to get it working with binary search just to realize it doesn't work\nEdit: it is possible to solve with \"gradient ascent\" (check mid and mid+1 and change low and high boundaries based on which one is bigger)\nbut I don't think it is a sound solution because of \"ties\" (if mid and mid+1 give same number, dont know which direction to go). But as of this date no test case had this (if its even possible for one to exist) I guess so it passed"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Don\\'t overthink it. You can do it! This problem makes itself look harder than it actually is."
                    }
                ]
            },
            {
                "id": 1846888,
                "content": [
                    {
                        "username": "cenjian",
                        "content": "hint: discard the most negative dishes until the sum of negative dishes is smaller than sum of positive ones. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Wow , easiest hard problem I ever solved !!"
                    },
                    {
                        "username": "zkamil",
                        "content": "Tips:\\n1. When deciding whether to include or not dish with negative rate, solve simple math inequality - max sum including negative dish should be more or equal to sum not including that dish. Once you solve that inequality, you will find a simple condition helping you with decision on including negative number. \\n2. Higher rated dishes deserve bigger multipliers."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "after sort `satisfaction`, the maximum sum of like-time coefficient `f[i]` that the chef can obtain if he prepares all dishes correspond to all satisfaction from `satisfaction[i]` to `satisfaction[n-1]` will be:\n$f[i]=satisfaction[i]+cumulativeSumFrom[i+1]+f[i+1]$\nor\n$f[i]=f[i+1]+cumulativeSumFrom[i]$\nAnd you don't need to use any array to memorise, instead, use 2 variables eg. `maxSumSatisfaction`  and `cumulativeSum` to track the previous result. Don't forget to return the answer whenever the current result is smaller than the previous one."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip if you are confused:-\\n\\n\\nThe only thing to think here is that you have to sort the array before passing to get the maximum possible outcome, as we want to multiply the largest satisfaction with the largest time. Other than that, it\\'s a basic dp problem, medium at best."
                    },
                    {
                        "username": "anwendeng",
                        "content": "After sorting the array, this problem becomes much easier."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well Easy Hard question is here !"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m not the first to say it, and I wont be the last: this was extremely easy for a hard problem. I\\'ve only been coding for 3 1/2 months and I finished this in 10-15 minutes"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Think about the logical extreme, if you could pick any single dish you wanted and serve it any time you want, what would you pick to maximize the \"like-time coefficient\"? The obvious answer is the most popular dish (highest satisfaction value) and serve it as late as possible since [big number] * [big number] = [bigger number].\\n\\nHow can you use this idea to maximize the sum of all like-time coefficients when one dish must be served after the other?"
                    },
                    {
                        "username": "user8228j",
                        "content": "everyone here saying its super easy meanwhile i wasted 30 minutes trying to get it working with binary search just to realize it doesn't work\nEdit: it is possible to solve with \"gradient ascent\" (check mid and mid+1 and change low and high boundaries based on which one is bigger)\nbut I don't think it is a sound solution because of \"ties\" (if mid and mid+1 give same number, dont know which direction to go). But as of this date no test case had this (if its even possible for one to exist) I guess so it passed"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Don\\'t overthink it. You can do it! This problem makes itself look harder than it actually is."
                    }
                ]
            },
            {
                "id": 1846883,
                "content": [
                    {
                        "username": "cenjian",
                        "content": "hint: discard the most negative dishes until the sum of negative dishes is smaller than sum of positive ones. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Wow , easiest hard problem I ever solved !!"
                    },
                    {
                        "username": "zkamil",
                        "content": "Tips:\\n1. When deciding whether to include or not dish with negative rate, solve simple math inequality - max sum including negative dish should be more or equal to sum not including that dish. Once you solve that inequality, you will find a simple condition helping you with decision on including negative number. \\n2. Higher rated dishes deserve bigger multipliers."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "after sort `satisfaction`, the maximum sum of like-time coefficient `f[i]` that the chef can obtain if he prepares all dishes correspond to all satisfaction from `satisfaction[i]` to `satisfaction[n-1]` will be:\n$f[i]=satisfaction[i]+cumulativeSumFrom[i+1]+f[i+1]$\nor\n$f[i]=f[i+1]+cumulativeSumFrom[i]$\nAnd you don't need to use any array to memorise, instead, use 2 variables eg. `maxSumSatisfaction`  and `cumulativeSum` to track the previous result. Don't forget to return the answer whenever the current result is smaller than the previous one."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip if you are confused:-\\n\\n\\nThe only thing to think here is that you have to sort the array before passing to get the maximum possible outcome, as we want to multiply the largest satisfaction with the largest time. Other than that, it\\'s a basic dp problem, medium at best."
                    },
                    {
                        "username": "anwendeng",
                        "content": "After sorting the array, this problem becomes much easier."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well Easy Hard question is here !"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m not the first to say it, and I wont be the last: this was extremely easy for a hard problem. I\\'ve only been coding for 3 1/2 months and I finished this in 10-15 minutes"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Think about the logical extreme, if you could pick any single dish you wanted and serve it any time you want, what would you pick to maximize the \"like-time coefficient\"? The obvious answer is the most popular dish (highest satisfaction value) and serve it as late as possible since [big number] * [big number] = [bigger number].\\n\\nHow can you use this idea to maximize the sum of all like-time coefficients when one dish must be served after the other?"
                    },
                    {
                        "username": "user8228j",
                        "content": "everyone here saying its super easy meanwhile i wasted 30 minutes trying to get it working with binary search just to realize it doesn't work\nEdit: it is possible to solve with \"gradient ascent\" (check mid and mid+1 and change low and high boundaries based on which one is bigger)\nbut I don't think it is a sound solution because of \"ties\" (if mid and mid+1 give same number, dont know which direction to go). But as of this date no test case had this (if its even possible for one to exist) I guess so it passed"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Don\\'t overthink it. You can do it! This problem makes itself look harder than it actually is."
                    }
                ]
            },
            {
                "id": 1846871,
                "content": [
                    {
                        "username": "cenjian",
                        "content": "hint: discard the most negative dishes until the sum of negative dishes is smaller than sum of positive ones. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Wow , easiest hard problem I ever solved !!"
                    },
                    {
                        "username": "zkamil",
                        "content": "Tips:\\n1. When deciding whether to include or not dish with negative rate, solve simple math inequality - max sum including negative dish should be more or equal to sum not including that dish. Once you solve that inequality, you will find a simple condition helping you with decision on including negative number. \\n2. Higher rated dishes deserve bigger multipliers."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "after sort `satisfaction`, the maximum sum of like-time coefficient `f[i]` that the chef can obtain if he prepares all dishes correspond to all satisfaction from `satisfaction[i]` to `satisfaction[n-1]` will be:\n$f[i]=satisfaction[i]+cumulativeSumFrom[i+1]+f[i+1]$\nor\n$f[i]=f[i+1]+cumulativeSumFrom[i]$\nAnd you don't need to use any array to memorise, instead, use 2 variables eg. `maxSumSatisfaction`  and `cumulativeSum` to track the previous result. Don't forget to return the answer whenever the current result is smaller than the previous one."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip if you are confused:-\\n\\n\\nThe only thing to think here is that you have to sort the array before passing to get the maximum possible outcome, as we want to multiply the largest satisfaction with the largest time. Other than that, it\\'s a basic dp problem, medium at best."
                    },
                    {
                        "username": "anwendeng",
                        "content": "After sorting the array, this problem becomes much easier."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well Easy Hard question is here !"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m not the first to say it, and I wont be the last: this was extremely easy for a hard problem. I\\'ve only been coding for 3 1/2 months and I finished this in 10-15 minutes"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Think about the logical extreme, if you could pick any single dish you wanted and serve it any time you want, what would you pick to maximize the \"like-time coefficient\"? The obvious answer is the most popular dish (highest satisfaction value) and serve it as late as possible since [big number] * [big number] = [bigger number].\\n\\nHow can you use this idea to maximize the sum of all like-time coefficients when one dish must be served after the other?"
                    },
                    {
                        "username": "user8228j",
                        "content": "everyone here saying its super easy meanwhile i wasted 30 minutes trying to get it working with binary search just to realize it doesn't work\nEdit: it is possible to solve with \"gradient ascent\" (check mid and mid+1 and change low and high boundaries based on which one is bigger)\nbut I don't think it is a sound solution because of \"ties\" (if mid and mid+1 give same number, dont know which direction to go). But as of this date no test case had this (if its even possible for one to exist) I guess so it passed"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Don\\'t overthink it. You can do it! This problem makes itself look harder than it actually is."
                    }
                ]
            },
            {
                "id": 1846839,
                "content": [
                    {
                        "username": "cenjian",
                        "content": "hint: discard the most negative dishes until the sum of negative dishes is smaller than sum of positive ones. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Wow , easiest hard problem I ever solved !!"
                    },
                    {
                        "username": "zkamil",
                        "content": "Tips:\\n1. When deciding whether to include or not dish with negative rate, solve simple math inequality - max sum including negative dish should be more or equal to sum not including that dish. Once you solve that inequality, you will find a simple condition helping you with decision on including negative number. \\n2. Higher rated dishes deserve bigger multipliers."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "after sort `satisfaction`, the maximum sum of like-time coefficient `f[i]` that the chef can obtain if he prepares all dishes correspond to all satisfaction from `satisfaction[i]` to `satisfaction[n-1]` will be:\n$f[i]=satisfaction[i]+cumulativeSumFrom[i+1]+f[i+1]$\nor\n$f[i]=f[i+1]+cumulativeSumFrom[i]$\nAnd you don't need to use any array to memorise, instead, use 2 variables eg. `maxSumSatisfaction`  and `cumulativeSum` to track the previous result. Don't forget to return the answer whenever the current result is smaller than the previous one."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip if you are confused:-\\n\\n\\nThe only thing to think here is that you have to sort the array before passing to get the maximum possible outcome, as we want to multiply the largest satisfaction with the largest time. Other than that, it\\'s a basic dp problem, medium at best."
                    },
                    {
                        "username": "anwendeng",
                        "content": "After sorting the array, this problem becomes much easier."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well Easy Hard question is here !"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m not the first to say it, and I wont be the last: this was extremely easy for a hard problem. I\\'ve only been coding for 3 1/2 months and I finished this in 10-15 minutes"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Think about the logical extreme, if you could pick any single dish you wanted and serve it any time you want, what would you pick to maximize the \"like-time coefficient\"? The obvious answer is the most popular dish (highest satisfaction value) and serve it as late as possible since [big number] * [big number] = [bigger number].\\n\\nHow can you use this idea to maximize the sum of all like-time coefficients when one dish must be served after the other?"
                    },
                    {
                        "username": "user8228j",
                        "content": "everyone here saying its super easy meanwhile i wasted 30 minutes trying to get it working with binary search just to realize it doesn't work\nEdit: it is possible to solve with \"gradient ascent\" (check mid and mid+1 and change low and high boundaries based on which one is bigger)\nbut I don't think it is a sound solution because of \"ties\" (if mid and mid+1 give same number, dont know which direction to go). But as of this date no test case had this (if its even possible for one to exist) I guess so it passed"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Don\\'t overthink it. You can do it! This problem makes itself look harder than it actually is."
                    }
                ]
            },
            {
                "id": 1846838,
                "content": [
                    {
                        "username": "cenjian",
                        "content": "hint: discard the most negative dishes until the sum of negative dishes is smaller than sum of positive ones. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Wow , easiest hard problem I ever solved !!"
                    },
                    {
                        "username": "zkamil",
                        "content": "Tips:\\n1. When deciding whether to include or not dish with negative rate, solve simple math inequality - max sum including negative dish should be more or equal to sum not including that dish. Once you solve that inequality, you will find a simple condition helping you with decision on including negative number. \\n2. Higher rated dishes deserve bigger multipliers."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "after sort `satisfaction`, the maximum sum of like-time coefficient `f[i]` that the chef can obtain if he prepares all dishes correspond to all satisfaction from `satisfaction[i]` to `satisfaction[n-1]` will be:\n$f[i]=satisfaction[i]+cumulativeSumFrom[i+1]+f[i+1]$\nor\n$f[i]=f[i+1]+cumulativeSumFrom[i]$\nAnd you don't need to use any array to memorise, instead, use 2 variables eg. `maxSumSatisfaction`  and `cumulativeSum` to track the previous result. Don't forget to return the answer whenever the current result is smaller than the previous one."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip if you are confused:-\\n\\n\\nThe only thing to think here is that you have to sort the array before passing to get the maximum possible outcome, as we want to multiply the largest satisfaction with the largest time. Other than that, it\\'s a basic dp problem, medium at best."
                    },
                    {
                        "username": "anwendeng",
                        "content": "After sorting the array, this problem becomes much easier."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well Easy Hard question is here !"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m not the first to say it, and I wont be the last: this was extremely easy for a hard problem. I\\'ve only been coding for 3 1/2 months and I finished this in 10-15 minutes"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Think about the logical extreme, if you could pick any single dish you wanted and serve it any time you want, what would you pick to maximize the \"like-time coefficient\"? The obvious answer is the most popular dish (highest satisfaction value) and serve it as late as possible since [big number] * [big number] = [bigger number].\\n\\nHow can you use this idea to maximize the sum of all like-time coefficients when one dish must be served after the other?"
                    },
                    {
                        "username": "user8228j",
                        "content": "everyone here saying its super easy meanwhile i wasted 30 minutes trying to get it working with binary search just to realize it doesn't work\nEdit: it is possible to solve with \"gradient ascent\" (check mid and mid+1 and change low and high boundaries based on which one is bigger)\nbut I don't think it is a sound solution because of \"ties\" (if mid and mid+1 give same number, dont know which direction to go). But as of this date no test case had this (if its even possible for one to exist) I guess so it passed"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Don\\'t overthink it. You can do it! This problem makes itself look harder than it actually is."
                    }
                ]
            },
            {
                "id": 1846822,
                "content": [
                    {
                        "username": "cenjian",
                        "content": "hint: discard the most negative dishes until the sum of negative dishes is smaller than sum of positive ones. "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Wow , easiest hard problem I ever solved !!"
                    },
                    {
                        "username": "zkamil",
                        "content": "Tips:\\n1. When deciding whether to include or not dish with negative rate, solve simple math inequality - max sum including negative dish should be more or equal to sum not including that dish. Once you solve that inequality, you will find a simple condition helping you with decision on including negative number. \\n2. Higher rated dishes deserve bigger multipliers."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "after sort `satisfaction`, the maximum sum of like-time coefficient `f[i]` that the chef can obtain if he prepares all dishes correspond to all satisfaction from `satisfaction[i]` to `satisfaction[n-1]` will be:\n$f[i]=satisfaction[i]+cumulativeSumFrom[i+1]+f[i+1]$\nor\n$f[i]=f[i+1]+cumulativeSumFrom[i]$\nAnd you don't need to use any array to memorise, instead, use 2 variables eg. `maxSumSatisfaction`  and `cumulativeSum` to track the previous result. Don't forget to return the answer whenever the current result is smaller than the previous one."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip if you are confused:-\\n\\n\\nThe only thing to think here is that you have to sort the array before passing to get the maximum possible outcome, as we want to multiply the largest satisfaction with the largest time. Other than that, it\\'s a basic dp problem, medium at best."
                    },
                    {
                        "username": "anwendeng",
                        "content": "After sorting the array, this problem becomes much easier."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Well Easy Hard question is here !"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m not the first to say it, and I wont be the last: this was extremely easy for a hard problem. I\\'ve only been coding for 3 1/2 months and I finished this in 10-15 minutes"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Think about the logical extreme, if you could pick any single dish you wanted and serve it any time you want, what would you pick to maximize the \"like-time coefficient\"? The obvious answer is the most popular dish (highest satisfaction value) and serve it as late as possible since [big number] * [big number] = [bigger number].\\n\\nHow can you use this idea to maximize the sum of all like-time coefficients when one dish must be served after the other?"
                    },
                    {
                        "username": "user8228j",
                        "content": "everyone here saying its super easy meanwhile i wasted 30 minutes trying to get it working with binary search just to realize it doesn't work\nEdit: it is possible to solve with \"gradient ascent\" (check mid and mid+1 and change low and high boundaries based on which one is bigger)\nbut I don't think it is a sound solution because of \"ties\" (if mid and mid+1 give same number, dont know which direction to go). But as of this date no test case had this (if its even possible for one to exist) I guess so it passed"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Don\\'t overthink it. You can do it! This problem makes itself look harder than it actually is."
                    }
                ]
            },
            {
                "id": 1846820,
                "content": [
                    {
                        "username": "2106_ayush_2003",
                        "content": "**EASY APPROACH ! KEEP CODING!**\\n\\nclass Solution {\\n    private:\\n    int f(int ind,int cnt,vector<int>& s,vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size()) return 0;\\n        if(dp[ind][cnt]!=-1) return dp[ind][cnt];\\n        int l=0;\\n        l=f(ind+1,cnt,s,dp);\\n        return dp[ind][cnt]=max(l,f(ind+1,cnt+1,s,dp)+(s[ind]*cnt));\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        vector<vector<int>>dp(505,vector<int>(505,-1));\\n        return f(0,1,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is \"HARD\" to read, but easy to solve!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I am maximally satisfied by breezing through this \"hard\" problem when I struggle with most mediums :)"
                    },
                    {
                        "username": "woundweavr",
                        "content": "If you\\'re asking yourself \"this is hard, it can\\'t be that simple right?\" go with your gut.  "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is hard?"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You don't even need explicit sorting. O(N) time, O(1) space solution [here](https://leetcode.com/problems/reducing-dishes/solutions/3353522/python-o-n-time-o-1-space-counting-sort/). This problem certainly isn't hard. It's strange that this approach is not described in Editorial tab."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The task today: More Actions -> Feedback -> Difficulty is inaccurate."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A+ for realism\\n\\n\"For our first course, a pretty disappointing salad. Trust me, its going to make the rest of the dinner seem awesome by comparison\""
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I'm a bit confused as to why LeetCode labeled this question as hard. The constraints aren't that big and a brute force approach works just fine. Anyone else feel the same? \nBTW, I solved that question in just 5 minutes. Usually it takes me all day to tackle a hard problem."
                    },
                    {
                        "username": "c4tdog",
                        "content": "better way to find out if the problem is hard is to check the Acceptance rate. "
                    },
                    {
                        "username": "equocredite",
                        "content": "You could at least set harder constraints on input size."
                    }
                ]
            },
            {
                "id": 1846815,
                "content": [
                    {
                        "username": "2106_ayush_2003",
                        "content": "**EASY APPROACH ! KEEP CODING!**\\n\\nclass Solution {\\n    private:\\n    int f(int ind,int cnt,vector<int>& s,vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size()) return 0;\\n        if(dp[ind][cnt]!=-1) return dp[ind][cnt];\\n        int l=0;\\n        l=f(ind+1,cnt,s,dp);\\n        return dp[ind][cnt]=max(l,f(ind+1,cnt+1,s,dp)+(s[ind]*cnt));\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        vector<vector<int>>dp(505,vector<int>(505,-1));\\n        return f(0,1,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is \"HARD\" to read, but easy to solve!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I am maximally satisfied by breezing through this \"hard\" problem when I struggle with most mediums :)"
                    },
                    {
                        "username": "woundweavr",
                        "content": "If you\\'re asking yourself \"this is hard, it can\\'t be that simple right?\" go with your gut.  "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is hard?"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You don't even need explicit sorting. O(N) time, O(1) space solution [here](https://leetcode.com/problems/reducing-dishes/solutions/3353522/python-o-n-time-o-1-space-counting-sort/). This problem certainly isn't hard. It's strange that this approach is not described in Editorial tab."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The task today: More Actions -> Feedback -> Difficulty is inaccurate."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A+ for realism\\n\\n\"For our first course, a pretty disappointing salad. Trust me, its going to make the rest of the dinner seem awesome by comparison\""
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I'm a bit confused as to why LeetCode labeled this question as hard. The constraints aren't that big and a brute force approach works just fine. Anyone else feel the same? \nBTW, I solved that question in just 5 minutes. Usually it takes me all day to tackle a hard problem."
                    },
                    {
                        "username": "c4tdog",
                        "content": "better way to find out if the problem is hard is to check the Acceptance rate. "
                    },
                    {
                        "username": "equocredite",
                        "content": "You could at least set harder constraints on input size."
                    }
                ]
            },
            {
                "id": 1846735,
                "content": [
                    {
                        "username": "2106_ayush_2003",
                        "content": "**EASY APPROACH ! KEEP CODING!**\\n\\nclass Solution {\\n    private:\\n    int f(int ind,int cnt,vector<int>& s,vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size()) return 0;\\n        if(dp[ind][cnt]!=-1) return dp[ind][cnt];\\n        int l=0;\\n        l=f(ind+1,cnt,s,dp);\\n        return dp[ind][cnt]=max(l,f(ind+1,cnt+1,s,dp)+(s[ind]*cnt));\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        vector<vector<int>>dp(505,vector<int>(505,-1));\\n        return f(0,1,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is \"HARD\" to read, but easy to solve!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I am maximally satisfied by breezing through this \"hard\" problem when I struggle with most mediums :)"
                    },
                    {
                        "username": "woundweavr",
                        "content": "If you\\'re asking yourself \"this is hard, it can\\'t be that simple right?\" go with your gut.  "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is hard?"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You don't even need explicit sorting. O(N) time, O(1) space solution [here](https://leetcode.com/problems/reducing-dishes/solutions/3353522/python-o-n-time-o-1-space-counting-sort/). This problem certainly isn't hard. It's strange that this approach is not described in Editorial tab."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The task today: More Actions -> Feedback -> Difficulty is inaccurate."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A+ for realism\\n\\n\"For our first course, a pretty disappointing salad. Trust me, its going to make the rest of the dinner seem awesome by comparison\""
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I'm a bit confused as to why LeetCode labeled this question as hard. The constraints aren't that big and a brute force approach works just fine. Anyone else feel the same? \nBTW, I solved that question in just 5 minutes. Usually it takes me all day to tackle a hard problem."
                    },
                    {
                        "username": "c4tdog",
                        "content": "better way to find out if the problem is hard is to check the Acceptance rate. "
                    },
                    {
                        "username": "equocredite",
                        "content": "You could at least set harder constraints on input size."
                    }
                ]
            },
            {
                "id": 1846734,
                "content": [
                    {
                        "username": "2106_ayush_2003",
                        "content": "**EASY APPROACH ! KEEP CODING!**\\n\\nclass Solution {\\n    private:\\n    int f(int ind,int cnt,vector<int>& s,vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size()) return 0;\\n        if(dp[ind][cnt]!=-1) return dp[ind][cnt];\\n        int l=0;\\n        l=f(ind+1,cnt,s,dp);\\n        return dp[ind][cnt]=max(l,f(ind+1,cnt+1,s,dp)+(s[ind]*cnt));\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        vector<vector<int>>dp(505,vector<int>(505,-1));\\n        return f(0,1,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is \"HARD\" to read, but easy to solve!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I am maximally satisfied by breezing through this \"hard\" problem when I struggle with most mediums :)"
                    },
                    {
                        "username": "woundweavr",
                        "content": "If you\\'re asking yourself \"this is hard, it can\\'t be that simple right?\" go with your gut.  "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is hard?"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You don't even need explicit sorting. O(N) time, O(1) space solution [here](https://leetcode.com/problems/reducing-dishes/solutions/3353522/python-o-n-time-o-1-space-counting-sort/). This problem certainly isn't hard. It's strange that this approach is not described in Editorial tab."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The task today: More Actions -> Feedback -> Difficulty is inaccurate."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A+ for realism\\n\\n\"For our first course, a pretty disappointing salad. Trust me, its going to make the rest of the dinner seem awesome by comparison\""
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I'm a bit confused as to why LeetCode labeled this question as hard. The constraints aren't that big and a brute force approach works just fine. Anyone else feel the same? \nBTW, I solved that question in just 5 minutes. Usually it takes me all day to tackle a hard problem."
                    },
                    {
                        "username": "c4tdog",
                        "content": "better way to find out if the problem is hard is to check the Acceptance rate. "
                    },
                    {
                        "username": "equocredite",
                        "content": "You could at least set harder constraints on input size."
                    }
                ]
            },
            {
                "id": 1846731,
                "content": [
                    {
                        "username": "2106_ayush_2003",
                        "content": "**EASY APPROACH ! KEEP CODING!**\\n\\nclass Solution {\\n    private:\\n    int f(int ind,int cnt,vector<int>& s,vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size()) return 0;\\n        if(dp[ind][cnt]!=-1) return dp[ind][cnt];\\n        int l=0;\\n        l=f(ind+1,cnt,s,dp);\\n        return dp[ind][cnt]=max(l,f(ind+1,cnt+1,s,dp)+(s[ind]*cnt));\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        vector<vector<int>>dp(505,vector<int>(505,-1));\\n        return f(0,1,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is \"HARD\" to read, but easy to solve!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I am maximally satisfied by breezing through this \"hard\" problem when I struggle with most mediums :)"
                    },
                    {
                        "username": "woundweavr",
                        "content": "If you\\'re asking yourself \"this is hard, it can\\'t be that simple right?\" go with your gut.  "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is hard?"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You don't even need explicit sorting. O(N) time, O(1) space solution [here](https://leetcode.com/problems/reducing-dishes/solutions/3353522/python-o-n-time-o-1-space-counting-sort/). This problem certainly isn't hard. It's strange that this approach is not described in Editorial tab."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The task today: More Actions -> Feedback -> Difficulty is inaccurate."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A+ for realism\\n\\n\"For our first course, a pretty disappointing salad. Trust me, its going to make the rest of the dinner seem awesome by comparison\""
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I'm a bit confused as to why LeetCode labeled this question as hard. The constraints aren't that big and a brute force approach works just fine. Anyone else feel the same? \nBTW, I solved that question in just 5 minutes. Usually it takes me all day to tackle a hard problem."
                    },
                    {
                        "username": "c4tdog",
                        "content": "better way to find out if the problem is hard is to check the Acceptance rate. "
                    },
                    {
                        "username": "equocredite",
                        "content": "You could at least set harder constraints on input size."
                    }
                ]
            },
            {
                "id": 1846723,
                "content": [
                    {
                        "username": "2106_ayush_2003",
                        "content": "**EASY APPROACH ! KEEP CODING!**\\n\\nclass Solution {\\n    private:\\n    int f(int ind,int cnt,vector<int>& s,vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size()) return 0;\\n        if(dp[ind][cnt]!=-1) return dp[ind][cnt];\\n        int l=0;\\n        l=f(ind+1,cnt,s,dp);\\n        return dp[ind][cnt]=max(l,f(ind+1,cnt+1,s,dp)+(s[ind]*cnt));\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        vector<vector<int>>dp(505,vector<int>(505,-1));\\n        return f(0,1,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is \"HARD\" to read, but easy to solve!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I am maximally satisfied by breezing through this \"hard\" problem when I struggle with most mediums :)"
                    },
                    {
                        "username": "woundweavr",
                        "content": "If you\\'re asking yourself \"this is hard, it can\\'t be that simple right?\" go with your gut.  "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is hard?"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You don't even need explicit sorting. O(N) time, O(1) space solution [here](https://leetcode.com/problems/reducing-dishes/solutions/3353522/python-o-n-time-o-1-space-counting-sort/). This problem certainly isn't hard. It's strange that this approach is not described in Editorial tab."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The task today: More Actions -> Feedback -> Difficulty is inaccurate."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A+ for realism\\n\\n\"For our first course, a pretty disappointing salad. Trust me, its going to make the rest of the dinner seem awesome by comparison\""
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I'm a bit confused as to why LeetCode labeled this question as hard. The constraints aren't that big and a brute force approach works just fine. Anyone else feel the same? \nBTW, I solved that question in just 5 minutes. Usually it takes me all day to tackle a hard problem."
                    },
                    {
                        "username": "c4tdog",
                        "content": "better way to find out if the problem is hard is to check the Acceptance rate. "
                    },
                    {
                        "username": "equocredite",
                        "content": "You could at least set harder constraints on input size."
                    }
                ]
            },
            {
                "id": 1846720,
                "content": [
                    {
                        "username": "2106_ayush_2003",
                        "content": "**EASY APPROACH ! KEEP CODING!**\\n\\nclass Solution {\\n    private:\\n    int f(int ind,int cnt,vector<int>& s,vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size()) return 0;\\n        if(dp[ind][cnt]!=-1) return dp[ind][cnt];\\n        int l=0;\\n        l=f(ind+1,cnt,s,dp);\\n        return dp[ind][cnt]=max(l,f(ind+1,cnt+1,s,dp)+(s[ind]*cnt));\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        vector<vector<int>>dp(505,vector<int>(505,-1));\\n        return f(0,1,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is \"HARD\" to read, but easy to solve!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I am maximally satisfied by breezing through this \"hard\" problem when I struggle with most mediums :)"
                    },
                    {
                        "username": "woundweavr",
                        "content": "If you\\'re asking yourself \"this is hard, it can\\'t be that simple right?\" go with your gut.  "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is hard?"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You don't even need explicit sorting. O(N) time, O(1) space solution [here](https://leetcode.com/problems/reducing-dishes/solutions/3353522/python-o-n-time-o-1-space-counting-sort/). This problem certainly isn't hard. It's strange that this approach is not described in Editorial tab."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The task today: More Actions -> Feedback -> Difficulty is inaccurate."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A+ for realism\\n\\n\"For our first course, a pretty disappointing salad. Trust me, its going to make the rest of the dinner seem awesome by comparison\""
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I'm a bit confused as to why LeetCode labeled this question as hard. The constraints aren't that big and a brute force approach works just fine. Anyone else feel the same? \nBTW, I solved that question in just 5 minutes. Usually it takes me all day to tackle a hard problem."
                    },
                    {
                        "username": "c4tdog",
                        "content": "better way to find out if the problem is hard is to check the Acceptance rate. "
                    },
                    {
                        "username": "equocredite",
                        "content": "You could at least set harder constraints on input size."
                    }
                ]
            },
            {
                "id": 1846714,
                "content": [
                    {
                        "username": "2106_ayush_2003",
                        "content": "**EASY APPROACH ! KEEP CODING!**\\n\\nclass Solution {\\n    private:\\n    int f(int ind,int cnt,vector<int>& s,vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size()) return 0;\\n        if(dp[ind][cnt]!=-1) return dp[ind][cnt];\\n        int l=0;\\n        l=f(ind+1,cnt,s,dp);\\n        return dp[ind][cnt]=max(l,f(ind+1,cnt+1,s,dp)+(s[ind]*cnt));\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        vector<vector<int>>dp(505,vector<int>(505,-1));\\n        return f(0,1,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is \"HARD\" to read, but easy to solve!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I am maximally satisfied by breezing through this \"hard\" problem when I struggle with most mediums :)"
                    },
                    {
                        "username": "woundweavr",
                        "content": "If you\\'re asking yourself \"this is hard, it can\\'t be that simple right?\" go with your gut.  "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is hard?"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You don't even need explicit sorting. O(N) time, O(1) space solution [here](https://leetcode.com/problems/reducing-dishes/solutions/3353522/python-o-n-time-o-1-space-counting-sort/). This problem certainly isn't hard. It's strange that this approach is not described in Editorial tab."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The task today: More Actions -> Feedback -> Difficulty is inaccurate."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A+ for realism\\n\\n\"For our first course, a pretty disappointing salad. Trust me, its going to make the rest of the dinner seem awesome by comparison\""
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I'm a bit confused as to why LeetCode labeled this question as hard. The constraints aren't that big and a brute force approach works just fine. Anyone else feel the same? \nBTW, I solved that question in just 5 minutes. Usually it takes me all day to tackle a hard problem."
                    },
                    {
                        "username": "c4tdog",
                        "content": "better way to find out if the problem is hard is to check the Acceptance rate. "
                    },
                    {
                        "username": "equocredite",
                        "content": "You could at least set harder constraints on input size."
                    }
                ]
            },
            {
                "id": 1846674,
                "content": [
                    {
                        "username": "2106_ayush_2003",
                        "content": "**EASY APPROACH ! KEEP CODING!**\\n\\nclass Solution {\\n    private:\\n    int f(int ind,int cnt,vector<int>& s,vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size()) return 0;\\n        if(dp[ind][cnt]!=-1) return dp[ind][cnt];\\n        int l=0;\\n        l=f(ind+1,cnt,s,dp);\\n        return dp[ind][cnt]=max(l,f(ind+1,cnt+1,s,dp)+(s[ind]*cnt));\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        vector<vector<int>>dp(505,vector<int>(505,-1));\\n        return f(0,1,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is \"HARD\" to read, but easy to solve!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I am maximally satisfied by breezing through this \"hard\" problem when I struggle with most mediums :)"
                    },
                    {
                        "username": "woundweavr",
                        "content": "If you\\'re asking yourself \"this is hard, it can\\'t be that simple right?\" go with your gut.  "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is hard?"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You don't even need explicit sorting. O(N) time, O(1) space solution [here](https://leetcode.com/problems/reducing-dishes/solutions/3353522/python-o-n-time-o-1-space-counting-sort/). This problem certainly isn't hard. It's strange that this approach is not described in Editorial tab."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The task today: More Actions -> Feedback -> Difficulty is inaccurate."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A+ for realism\\n\\n\"For our first course, a pretty disappointing salad. Trust me, its going to make the rest of the dinner seem awesome by comparison\""
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I'm a bit confused as to why LeetCode labeled this question as hard. The constraints aren't that big and a brute force approach works just fine. Anyone else feel the same? \nBTW, I solved that question in just 5 minutes. Usually it takes me all day to tackle a hard problem."
                    },
                    {
                        "username": "c4tdog",
                        "content": "better way to find out if the problem is hard is to check the Acceptance rate. "
                    },
                    {
                        "username": "equocredite",
                        "content": "You could at least set harder constraints on input size."
                    }
                ]
            },
            {
                "id": 1846668,
                "content": [
                    {
                        "username": "2106_ayush_2003",
                        "content": "**EASY APPROACH ! KEEP CODING!**\\n\\nclass Solution {\\n    private:\\n    int f(int ind,int cnt,vector<int>& s,vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size()) return 0;\\n        if(dp[ind][cnt]!=-1) return dp[ind][cnt];\\n        int l=0;\\n        l=f(ind+1,cnt,s,dp);\\n        return dp[ind][cnt]=max(l,f(ind+1,cnt+1,s,dp)+(s[ind]*cnt));\\n    }\\npublic:\\n    int maxSatisfaction(vector<int>& s) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        vector<vector<int>>dp(505,vector<int>(505,-1));\\n        return f(0,1,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is \"HARD\" to read, but easy to solve!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I am maximally satisfied by breezing through this \"hard\" problem when I struggle with most mediums :)"
                    },
                    {
                        "username": "woundweavr",
                        "content": "If you\\'re asking yourself \"this is hard, it can\\'t be that simple right?\" go with your gut.  "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is hard?"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You don't even need explicit sorting. O(N) time, O(1) space solution [here](https://leetcode.com/problems/reducing-dishes/solutions/3353522/python-o-n-time-o-1-space-counting-sort/). This problem certainly isn't hard. It's strange that this approach is not described in Editorial tab."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The task today: More Actions -> Feedback -> Difficulty is inaccurate."
                    },
                    {
                        "username": "cswartzell",
                        "content": "A+ for realism\\n\\n\"For our first course, a pretty disappointing salad. Trust me, its going to make the rest of the dinner seem awesome by comparison\""
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I'm a bit confused as to why LeetCode labeled this question as hard. The constraints aren't that big and a brute force approach works just fine. Anyone else feel the same? \nBTW, I solved that question in just 5 minutes. Usually it takes me all day to tackle a hard problem."
                    },
                    {
                        "username": "c4tdog",
                        "content": "better way to find out if the problem is hard is to check the Acceptance rate. "
                    },
                    {
                        "username": "equocredite",
                        "content": "You could at least set harder constraints on input size."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Subsequence in Non-Increasing Order",
        "question_content": "<p>Given the array <code>nums</code>, obtain a subsequence of the array whose sum of elements is <strong>strictly greater</strong> than the sum of the non&nbsp;included elements in such subsequence.&nbsp;</p>\n\n<p>If there are multiple solutions, return the subsequence with <strong>minimum size</strong> and if there still exist multiple solutions, return the subsequence with the <strong>maximum total sum</strong> of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.&nbsp;</p>\n\n<p>Note that the solution with the given constraints is guaranteed to be&nbsp;<strong>unique</strong>. Also return the answer sorted in <strong>non-increasing</strong> order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,3,10,9,8]\n<strong>Output:</strong> [10,9] \n<strong>Explanation:</strong> The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements.&nbsp;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,4,7,6,7]\n<strong>Output:</strong> [7,7,6] \n<strong>Explanation:</strong> The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-decreasing order.  \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 564289,
                "title": "c-java-priority-queue",
                "content": "**Intuition:** pick the largest number from the array and add it to subsequence. Repeat till the subsequence sum `sub_sum` is greater than the half of the total sum `half_sum`. Priority queue is the natural choice to pull largest numbers.\\n\\n**C++**\\n```cpp\\nvector<int> minSubsequence(vector<int>& nums) {\\n    vector<int> res;\\n    auto sub_sum = 0, half_sum = accumulate(begin(nums), end(nums), 0) / 2;\\n    priority_queue<int> pq(begin(nums), end(nums));\\n    while (sub_sum <= half_sum) {\\n        res.push_back(pq.top());\\n        sub_sum += res.back();\\n        pq.pop();\\n    }\\n    return res;\\n}\\n```\\n\\n**Java**\\n```java\\npublic List<Integer> minSubsequence(int[] nums) {\\n    List<Integer> res = new ArrayList<>();\\n    var pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n    pq.addAll(IntStream.of(nums).boxed().collect(Collectors.toList()));\\n    int sub_sum = 0, half_sum = IntStream.of(nums).sum() / 2;\\n    while (sub_sum <= half_sum) {\\n        res.add(pq.peek());\\n        sub_sum += pq.poll();\\n    }    \\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> minSubsequence(vector<int>& nums) {\\n    vector<int> res;\\n    auto sub_sum = 0, half_sum = accumulate(begin(nums), end(nums), 0) / 2;\\n    priority_queue<int> pq(begin(nums), end(nums));\\n    while (sub_sum <= half_sum) {\\n        res.push_back(pq.top());\\n        sub_sum += res.back();\\n        pq.pop();\\n    }\\n    return res;\\n}\\n```\n```java\\npublic List<Integer> minSubsequence(int[] nums) {\\n    List<Integer> res = new ArrayList<>();\\n    var pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n    pq.addAll(IntStream.of(nums).boxed().collect(Collectors.toList()));\\n    int sub_sum = 0, half_sum = IntStream.of(nums).sum() / 2;\\n    while (sub_sum <= half_sum) {\\n        res.add(pq.peek());\\n        sub_sum += pq.poll();\\n    }    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564305,
                "title": "python3-easy-solution-with-sort",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        res = []\\n        while sum(res) <= sum(nums):\\n            res.append(nums.pop())\\n        return res    \\n```\\n\\n##### Without summing every iteration\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        res = []\\n        numSum = sum(nums)\\n        resSum = 0 \\n        while resSum <= numSum:\\n            v = nums.pop()\\n            res.append(v)\\n            resSum += v\\n            numSum -= v \\n        return res   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        res = []\\n        while sum(res) <= sum(nums):\\n            res.append(nums.pop())\\n        return res    \\n```\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        res = []\\n        numSum = sum(nums)\\n        resSum = 0 \\n        while resSum <= numSum:\\n            v = nums.pop()\\n            res.append(v)\\n            resSum += v\\n            numSum -= v \\n        return res   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 620502,
                "title": "easy-c-solution-with-explaination",
                "content": "**Explaination**:\\n\\n1)Find the sum of all the elements of the vector.\\n2)Sort the vector in descending order.\\n3)Keep on subtracting the elements from the highest to lowest until the sum of highest elements is greater than the remaining. Also,add the elements to the answer vector.\\n4)The required elements till the condition meets is the final answer.\\n5)Return them in non decreasing order\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int sum=0,newsum=0;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        sort(nums.begin(),nums.end(),std::greater<>());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            newsum+=nums[i];\\n            sum=sum-nums[i];\\n            ans.push_back(nums[i]);\\n            if(newsum>sum)\\n                break;\\n        }\\n        sort(ans.begin(),ans.end(),std::greater<>());\\n        return ans;\\n    }\\n};\\n```\\n\\nI think leetcode should rename the question to **SEQUENCE** instead of subsequence. Its really misleading.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int sum=0,newsum=0;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        sort(nums.begin(),nums.end(),std::greater<>());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            newsum+=nums[i];\\n            sum=sum-nums[i];\\n            ans.push_back(nums[i]);\\n            if(newsum>sum)\\n                break;\\n        }\\n        sort(ans.begin(),ans.end(),std::greater<>());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671507,
                "title": "java-simple-sort-and-keep-adding-from-large-side",
                "content": "```\\npublic List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, sum = 0, rSum = 0;\\n        for (int i : nums) sum += i;\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            rSum += nums[i];\\n            res.add(nums[i]);\\n            if (rSum > sum - rSum) return res;\\n        }\\n        return new ArrayList<>();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length, sum = 0, rSum = 0;\\n        for (int i : nums) sum += i;\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            rSum += nums[i];\\n            res.add(nums[i]);\\n            if (rSum > sum - rSum) return res;\\n        }\\n        return new ArrayList<>();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041468,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        l = []\\n        while sum(l) <= sum(nums):\\n            l.append(nums.pop())\\n        return l\\n```\\nIf you like the solution, please vote for this.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        l = []\\n        while sum(l) <= sum(nums):\\n            l.append(nums.pop())\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572182,
                "title": "easy-java-o-n-time-beats-100-100",
                "content": "We sort in order to have quick access to the greatest available value. We keep putting the greatest available value into the subsequence and return the subsequence as soon as its sum is greater than the rest. We guarantee that the resulting subsequence has minimal size and maximal sum by always choosing the greatest available value which increases the subsequence sum as much as possible with as few values as possible.  \\n\\t\\n\\t\\n\\t// Counting sort since the values are in [1, 100]\\n    // O(n) time\\n    // O(n) space\\n    public List<Integer> minSubsequence(int[] nums) {\\n        \\n        int[] count = new int[101];     // count[i] is the number of occurrences of i in nums\\n        int totalSum = 0;\\n        for (int currInt : nums) {\\n            totalSum += currInt;\\n            count[currInt]++;\\n        }\\n        \\n        List<Integer> currSubseq = new ArrayList<>();\\n        int currSum = 0;\\n        \\n        // Keep putting the greatest available value into the subsequence and return the subsequence as soon as its sum is greater than the rest.\\n        for (int i = count.length - 1; i >= 0; --i) {\\n            \\n            while (count[i] > 0) {\\n                \\n                currSubseq.add(i);\\n                currSum += i;\\n                count[i]--;\\n                \\n                if (currSum > totalSum - currSum) {\\n                    i = -1;   \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return currSubseq;\\n    }",
                "solutionTags": [],
                "code": "We sort in order to have quick access to the greatest available value. We keep putting the greatest available value into the subsequence and return the subsequence as soon as its sum is greater than the rest. We guarantee that the resulting subsequence has minimal size and maximal sum by always choosing the greatest available value which increases the subsequence sum as much as possible with as few values as possible.  \\n\\t\\n\\t\\n\\t// Counting sort since the values are in [1, 100]\\n    // O(n) time\\n    // O(n) space\\n    public List<Integer> minSubsequence(int[] nums) {\\n        \\n        int[] count = new int[101];     // count[i] is the number of occurrences of i in nums\\n        int totalSum = 0;\\n        for (int currInt : nums) {\\n            totalSum += currInt;\\n            count[currInt]++;\\n        }\\n        \\n        List<Integer> currSubseq = new ArrayList<>();\\n        int currSum = 0;\\n        \\n        // Keep putting the greatest available value into the subsequence and return the subsequence as soon as its sum is greater than the rest.\\n        for (int i = count.length - 1; i >= 0; --i) {\\n            \\n            while (count[i] > 0) {\\n                \\n                currSubseq.add(i);\\n                currSum += i;\\n                count[i]--;\\n                \\n                if (currSum > totalSum - currSum) {\\n                    i = -1;   \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return currSubseq;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 774009,
                "title": "c-o-n-without-sorting",
                "content": "Solution with sort is easy.\\nNow here\\'s the obvious follow-up question from the interviewer: Can you make time complexity linear?\\n\\n```\\nvector<int> minSubsequence(vector<int>& nums) {\\n\\tvector<int> res, freq(101, 0);\\n\\tint sumres=0, sumleft=accumulate(begin(nums), end(nums), 0);\\n\\n\\tfor(auto n: nums)\\n\\t\\tfreq[n]++;\\n\\n\\tfor(int n=100; n>=1; n--){\\n\\t\\twhile(freq[n]-->0 && sumres<=sumleft){\\n\\t\\t\\tsumres+=n;\\n\\t\\t\\tsumleft-=n;\\n\\t\\t\\tres.push_back(n);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> minSubsequence(vector<int>& nums) {\\n\\tvector<int> res, freq(101, 0);\\n\\tint sumres=0, sumleft=accumulate(begin(nums), end(nums), 0);\\n\\n\\tfor(auto n: nums)\\n\\t\\tfreq[n]++;\\n\\n\\tfor(int n=100; n>=1; n--){\\n\\t\\twhile(freq[n]-->0 && sumres<=sumleft){\\n\\t\\t\\tsumres+=n;\\n\\t\\t\\tsumleft-=n;\\n\\t\\t\\tres.push_back(n);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594209,
                "title": "javascript-simple-w-comments",
                "content": "```\\nfunction minSubsequence(nums) {\\n    // result array\\n    const res = [];\\n\\t\\n    // first, sort nums decreasing\\n    nums.sort((a, b) => b - a);\\n\\t\\n    // get sum of elements\\n    let sum = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n    }\\n\\t\\n    // get current sum\\n    let current_sum = 0;\\n\\t\\n    // keep picking elements until it\\'s greater than non included elements\\n    for (let i = 0; i < nums.length; i++) {\\n        // add to current sum and add number to res\\n        current_sum += nums[i];\\n        res.push(nums[i]);\\n        // if current sum is greater than non included elements, return res\\n        if (current_sum > sum - current_sum) {\\n            // break loop, we found our subsequence we need\\n            break;\\n        }\\n    }\\n\\t\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction minSubsequence(nums) {\\n    // result array\\n    const res = [];\\n\\t\\n    // first, sort nums decreasing\\n    nums.sort((a, b) => b - a);\\n\\t\\n    // get sum of elements\\n    let sum = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n    }\\n\\t\\n    // get current sum\\n    let current_sum = 0;\\n\\t\\n    // keep picking elements until it\\'s greater than non included elements\\n    for (let i = 0; i < nums.length; i++) {\\n        // add to current sum and add number to res\\n        current_sum += nums[i];\\n        res.push(nums[i]);\\n        // if current sum is greater than non included elements, return res\\n        if (current_sum > sum - current_sum) {\\n            // break loop, we found our subsequence we need\\n            break;\\n        }\\n    }\\n\\t\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2838443,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        l = []\\n        while sum(l) <= sum(nums):\\n            l.append(nums.pop())\\n        return l\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        l = []\\n        while sum(l) <= sum(nums):\\n            l.append(nums.pop())\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564317,
                "title": "java-easy-solution-o-nlogn-time-and-o-n-space",
                "content": "Concept: Let, the sum of all the elements of the array be \\'Sum\\'. Sort the array and start collecting the maximum elements one by one in a list and keeping track of the sum \\'s\\'  of the integers collected. If total sum minus sum of elements collected  (Sum-s)  is less than s, then return the list of integers collected.\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> arr=new ArrayList<>();\\n        long sum=0;\\n        for(int i:nums)\\n            sum+=i;\\n        long ans=0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            arr.add(nums[i]);\\n            ans+=nums[i];\\n            if(ans>sum-ans)\\n                return arr;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> arr=new ArrayList<>();\\n        long sum=0;\\n        for(int i:nums)\\n            sum+=i;\\n        long ans=0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            arr.add(nums[i]);\\n            ans+=nums[i];\\n            if(ans>sum-ans)\\n                return arr;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377047,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int total = 0;\\n        for(int i=0;i<nums.length;i++){\\n            total += nums[i];\\n        }\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        for(int i=nums.length-1;i>=0;i--){\\n            ans.add(nums[i]);\\n            sum += nums[i];\\n            if(sum>total-sum){\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int total = 0;\\n        for(int i=0;i<nums.length;i++){\\n            total += nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2340423,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n        total = sum(nums)\\n        curr = 0\\n        ans = []\\n        \\n        for i in range(len(nums)):\\n            curr += nums[i]\\n            total -= nums[i]\\n            ans.append(nums[i])\\n            if curr > total:\\n                return ans\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n        total = sum(nums)\\n        curr = 0\\n        ans = []\\n        \\n        for i in range(len(nums)):\\n            curr += nums[i]\\n            total -= nums[i]\\n            ans.append(nums[i])\\n            if curr > total:\\n                return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297570,
                "title": "simplified-c-solution-easy-to-understand",
                "content": "* The title of the question is not accurate, it should be **SEQUENCE** instead of **SUBSEQUENCE**.\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums)\\n    {\\n        vector<int>ans;\\n        int totalSum = 0;\\n        int currentSum = 0;\\n        \\n        for(int i:nums)\\n        {\\n            totalSum += i;\\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            currentSum += nums[i];\\n            totalSum -= nums[i];\\n            ans.push_back(nums[i]);\\n            if(currentSum > totalSum)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums)\\n    {\\n        vector<int>ans;\\n        int totalSum = 0;\\n        int currentSum = 0;\\n        \\n        for(int i:nums)\\n        {\\n            totalSum += i;\\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            currentSum += nums[i];\\n            totalSum -= nums[i];\\n            ans.push_back(nums[i]);\\n            if(currentSum > totalSum)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564361,
                "title": "clean-python-3-counting-sort-o-n",
                "content": "Counting sort and get sum of them first.\\nThen take number from largest until it meets the condition\\n\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nimport collections\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        curr, result, s = 0, [], sum(nums)\\n        counter = collections.Counter(nums)\\n        for i in reversed(range(1, 101)):\\n            while counter[i] > 0:\\n                if curr > s: return result\\n                s -= i\\n                curr += i\\n                result.append(i)\\n                counter[i] -= 1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        curr, result, s = 0, [], sum(nums)\\n        counter = collections.Counter(nums)\\n        for i in reversed(range(1, 101)):\\n            while counter[i] > 0:\\n                if curr > s: return result\\n                s -= i\\n                curr += i\\n                result.append(i)\\n                counter[i] -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682423,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n       int n = nums.length;\\n       Arrays.sort(nums);\\n       int sum=0,s=0;\\n       List<Integer> list = new ArrayList<>();\\n       for(int i=0;i<n;i++){\\n           sum+=nums[i];\\n       }\\n       for(int j=n-1;j>=0;j--){\\n           s+=nums[j];\\n           sum=sum-nums[j];\\n           list.add(nums[j]);\\n           if(s>sum){\\n               break;\\n           }\\n       }\\n       return list; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n       int n = nums.length;\\n       Arrays.sort(nums);\\n       int sum=0,s=0;\\n       List<Integer> list = new ArrayList<>();\\n       for(int i=0;i<n;i++){\\n           sum+=nums[i];\\n       }\\n       for(int j=n-1;j>=0;j--){\\n           s+=nums[j];\\n           sum=sum-nums[j];\\n           list.add(nums[j]);\\n           if(s>sum){\\n               break;\\n           }\\n       }\\n       return list; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330490,
                "title": "c-solution-sorting-and-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        \\n        int tot_sum=accumulate(nums.begin(),nums.end(),0);\\n        vector<int> ans;\\n        int currsum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n            currsum+=nums[i];\\n            \\n            if(currsum > tot_sum-currsum )\\n                return ans;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        \\n        int tot_sum=accumulate(nums.begin(),nums.end(),0);\\n        vector<int> ans;\\n        int currsum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(nums[i]);\\n            currsum+=nums[i];\\n            \\n            if(currsum > tot_sum-currsum )\\n                return ans;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069172,
                "title": "easy-python3-codes",
                "content": "# Code1\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums=sorted(nums)[::-1]\\n        sum1,sum2=0,sum(nums)\\n        for i in range(len(nums)):\\n            sum1+=nums[i]\\n            sum2-=nums[i]            \\n            if sum1>sum2:\\n                return nums[0:i+1]\\n```\\n# Code2\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums=sorted(nums)[::-1]\\n        for i in range(len(nums)+1):\\n            if sum(nums[0:i])>sum(nums[i:]):\\n                return nums[0:i]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums=sorted(nums)[::-1]\\n        sum1,sum2=0,sum(nums)\\n        for i in range(len(nums)):\\n            sum1+=nums[i]\\n            sum2-=nums[i]            \\n            if sum1>sum2:\\n                return nums[0:i+1]\\n```\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums=sorted(nums)[::-1]\\n        for i in range(len(nums)+1):\\n            if sum(nums[0:i])>sum(nums[i:]):\\n                return nums[0:i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249291,
                "title": "golang-solution-with-explanation",
                "content": "The idea of this solution is pretty simple, we first sort `nums` in non-increasing order and then find the sum of `nums`. After that, we can loop through `nums` and subtract the greatest numbers in `nums` from the total sum and add the greatest numbers in `nums` to a different sum. And then, we append the `num` to `res` (the resulting function). If the other sum is greater than the total sum, we can break out of the loop and return `res`.\\n\\n``` go\\nfunc minSubsequence(nums []int) []int {\\n\\tres := []int{}\\n\\tsum := 0\\n\\tresSum := 0\\n\\tsort.Slice(nums, func(i, j int) bool { return nums[i] > nums[j] })\\n\\tfor _, num := range nums { sum += num }\\n\\t\\n\\tfor _, num := range nums {\\n\\t\\tsum -= num\\n\\t\\tresSum += num\\n\\t\\tres = append(res, num)\\n\\t\\tif resSum > sum { break }\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc minSubsequence(nums []int) []int {\\n\\tres := []int{}\\n\\tsum := 0\\n\\tresSum := 0\\n\\tsort.Slice(nums, func(i, j int) bool { return nums[i] > nums[j] })\\n\\tfor _, num := range nums { sum += num }\\n\\t\\n\\tfor _, num := range nums {\\n\\t\\tsum -= num\\n\\t\\tresSum += num\\n\\t\\tres = append(res, num)\\n\\t\\tif resSum > sum { break }\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 986620,
                "title": "java-counting-sort-1ms-beats-100-time-o-n-space-o-1",
                "content": "**Algorithm**\\n* This approach is using the counting sort option since `nums[i]` is in range of `1` to `100`\\n* we can start with creating bins for `100` numbers by having `int[]` array for `100` elements, (101 upper bound for zero based index)\\n* Loop through and store the numbers in the assigned bins and increasing the frequency of the number on the specfic index if there is a duplicate found\\n* while looping comput the `sum` of the values which will help us in finding the `offset` limits later\\n* `offset` here is the half sum of the total sum\\n* Now we can loop from backwards and keep reducing the sum and see if the `sum` is less than the `offset`, if so return the `result` \\n* Time is `O(n)` because the frequency limit for a number is `500` (inner while loop worst case), Space is `O(1)` as the bucket is for `100` elements.\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int[] c = new int[101];\\n        \\n        int sum = 0;\\n        //counting the frequency of each of the elements\\n        for (int i = 0;i<nums.length;i++){\\n            sum += nums[i];\\n            c[nums[i]]++;\\n        }\\n        \\n\\t\\t// if odd then add 1 to the offset, if even get the mid\\n\\t\\tint offset = sum % 2 == 0 ? sum / 2 : (sum / 2) + 1;\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for (int i = c.length-1;i>=0;i--){\\n            // if we find the element more than once then we have to run upto the frequency to account that\\n\\t\\t\\twhile (c[i] > 0){\\n                result.add(i);\\n                sum -= i;\\n                if (sum < offset){\\n                    i = 0;         //setting i=0 because we have to exit the outside for loop also here\\n                    break;\\n                }    \\n                c[i]--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int[] c = new int[101];\\n        \\n        int sum = 0;\\n        //counting the frequency of each of the elements\\n        for (int i = 0;i<nums.length;i++){\\n            sum += nums[i];\\n            c[nums[i]]++;\\n        }\\n        \\n\\t\\t// if odd then add 1 to the offset, if even get the mid\\n\\t\\tint offset = sum % 2 == 0 ? sum / 2 : (sum / 2) + 1;\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for (int i = c.length-1;i>=0;i--){\\n            // if we find the element more than once then we have to run upto the frequency to account that\\n\\t\\t\\twhile (c[i] > 0){\\n                result.add(i);\\n                sum -= i;\\n                if (sum < offset){\\n                    i = 0;         //setting i=0 because we have to exit the outside for loop also here\\n                    break;\\n                }    \\n                c[i]--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915520,
                "title": "python-counting-sort-time-o-n-space-o-k",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        counts = [0] * 101\\n        for n in nums:\\n            counts[n] += 1\\n        \\n        sum_ = sum(nums)\\n        result = []\\n        sub_sum = 0        \\n        for n in range(100, 0, -1):\\n            if sub_sum > sum_ - sub_sum:\\n                break\\n                \\n            while counts[n] and sub_sum <= sum_ - sub_sum:\\n                counts[n] -= 1\\n                sub_sum += n\\n                result.append(n)\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        counts = [0] * 101\\n        for n in nums:\\n            counts[n] += 1\\n        \\n        sum_ = sum(nums)\\n        result = []\\n        sub_sum = 0        \\n        for n in range(100, 0, -1):\\n            if sub_sum > sum_ - sub_sum:\\n                break\\n                \\n            while counts[n] and sub_sum <= sum_ - sub_sum:\\n                counts[n] -= 1\\n                sub_sum += n\\n                result.append(n)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892036,
                "title": "sort-reverse-python",
                "content": "Keep running totals of the numbers you have already examined in `left`, and the numbers you have left to examine in `right`. Since we want the smallest possible subsequence with maximum value, we know a \"safe move\" is to continually add the max value of what is left in the array until `left` is greater than `right`.\\n\\n\\n```\\ndef minSubsequence(self, nums: List[int]) -> List[int]:\\n\\t\\tnums.sort(reverse=True)\\n        right = sum(nums)\\n        left = 0\\n        for i in range(len(nums)):\\n            left += nums[i]\\n            right -= nums[i]\\n            if left > right:\\n                return nums[0:i + 1]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minSubsequence(self, nums: List[int]) -> List[int]:\\n\\t\\tnums.sort(reverse=True)\\n        right = sum(nums)\\n        left = 0\\n        for i in range(len(nums)):\\n            left += nums[i]\\n            right -= nums[i]\\n            if left > right:\\n                return nums[0:i + 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 662565,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        result = [nums.pop()]\\n        while sum(result) <= sum(nums):\\n            result.append(nums.pop())\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        result = [nums.pop()]\\n        while sum(result) <= sum(nums):\\n            result.append(nums.pop())\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674264,
                "title": "easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUpvote if you like it vro ;)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int sum = 0, temp = 0; sort(nums.begin(), nums.end()); \\n        vector<int> res; int k = nums.size()-1; \\n        for(int i=0; i<nums.size(); i++) sum += nums[i]; \\n        while(temp <= sum - temp) {temp += nums[k];  res.push_back(nums[k]); k--;}\\n        return res; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int sum = 0, temp = 0; sort(nums.begin(), nums.end()); \\n        vector<int> res; int k = nums.size()-1; \\n        for(int i=0; i<nums.size(); i++) sum += nums[i]; \\n        while(temp <= sum - temp) {temp += nums[k];  res.push_back(nums[k]); k--;}\\n        return res; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307463,
                "title": "python-solution-runtime-40ms-beats-92",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        total = sum(nums)\\n        nums.sort(reverse = True)\\n        sub_sum, sub_seq = 0, []\\n        for x in nums:\\n            sub_sum += x\\n            total -= x\\n            sub_seq.append(x)\\n            if sub_sum > total:\\n                return sub_seq\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        total = sum(nums)\\n        nums.sort(reverse = True)\\n        sub_sum, sub_seq = 0, []\\n        for x in nums:\\n            sub_sum += x\\n            total -= x\\n            sub_seq.append(x)\\n            if sub_sum > total:\\n                return sub_seq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502922,
                "title": "3-ms-t-c-easy-short-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```   \\n        Arrays.sort(nums);\\n        int sum = 0, temp = 0;\\n        for (int i: nums) sum += i;\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            sum -= nums[i];\\n            temp += nums[i];\\n            ans.add(nums[i]);\\n            if (temp > sum) break;\\n        }\\n\\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330458,
                "title": "solution",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        if (len(nums) == 1):\\n            return nums\\n        nums.sort()\\n        count = 0\\n        num = []\\n        l = len(nums)\\n        for i in range(1,l+1):\\n            count += nums[-i]\\n            num.append(nums[-i])\\n            if count > sum(nums[:l-i]):\\n                return (num)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        if (len(nums) == 1):\\n            return nums\\n        nums.sort()\\n        count = 0\\n        num = []\\n        l = len(nums)\\n        for i in range(1,l+1):\\n            count += nums[-i]\\n            num.append(nums[-i])\\n            if count > sum(nums[:l-i]):\\n                return (num)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068203,
                "title": "simple-fast-java-solution-faster-than-73-87",
                "content": "```\\npublic List<Integer> minSubsequence(int[] nums) {\\n    var sumResultElements = 0;\\n    var sumElements = 0;\\n    for(int i=0; i<nums.length; i++) { // get the sum of all the elements\\n        sumElements+=nums[i];\\n    }\\n    Arrays.sort(nums); // sort the array\\n    var result = new ArrayList<Integer>();\\n    var index=nums.length-1;\\n    while(sumResultElements<= sumElements-sumResultElements) { \\n        result.add(nums[index]); // add the number to result\\n        sumResultElements+=nums[index]; // keep track of the sum of the elements in result\\n        index--;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic List<Integer> minSubsequence(int[] nums) {\\n    var sumResultElements = 0;\\n    var sumElements = 0;\\n    for(int i=0; i<nums.length; i++) { // get the sum of all the elements\\n        sumElements+=nums[i];\\n    }\\n    Arrays.sort(nums); // sort the array\\n    var result = new ArrayList<Integer>();\\n    var index=nums.length-1;\\n    while(sumResultElements<= sumElements-sumResultElements) { \\n        result.add(nums[index]); // add the number to result\\n        sumResultElements+=nums[index]; // keep track of the sum of the elements in result\\n        index--;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1793846,
                "title": "python3-priority-queue-max-heap-easy-understanding",
                "content": "TC: O(nlogk)\\nSC: O(n)\\n\\n```\\ndef minSubsequence(self, nums: List[int]) -> List[int]:\\n        s = 0\\n        heap = []\\n        for num in nums:\\n            s += num\\n            heappush(heap, -num)\\n        \\n        res, cur = [], 0\\n        while cur <= s:\\n            largest = -heappop(heap)\\n            cur += largest\\n            res.append(largest)\\n            s -= largest\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef minSubsequence(self, nums: List[int]) -> List[int]:\\n        s = 0\\n        heap = []\\n        for num in nums:\\n            s += num\\n            heappush(heap, -num)\\n        \\n        res, cur = [], 0\\n        while cur <= s:\\n            largest = -heappop(heap)\\n            cur += largest\\n            res.append(largest)\\n            s -= largest\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1696670,
                "title": "cpp-soln",
                "content": "lass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n      vector<int> v;\\n      int sum=0,i;\\n      for(i=0;i<nums.size();i++)\\n      {\\n        sum=sum+nums[i];\\n      }\\n      \\n      int add=0;\\n      for(i=nums.size()-1;i>=0;i--)\\n      {\\n       if(sum>=add)\\n       {\\n         add=add+nums[i];\\n         sum=sum-nums[i];\\n         v.push_back(nums[i]);\\n       }\\n        else\\n          break;\\n      }\\n      \\n      return v;\\n    }\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "lass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n      vector<int> v;\\n      int sum=0,i;\\n      for(i=0;i<nums.size();i++)\\n      {\\n        sum=sum+nums[i];\\n      }\\n      \\n      int add=0;\\n      for(i=nums.size()-1;i>=0;i--)\\n      {\\n       if(sum>=add)\\n       {\\n         add=add+nums[i];\\n         sum=sum-nums[i];\\n         v.push_back(nums[i]);\\n       }\\n        else\\n          break;\\n      }\\n      \\n      return v;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1571967,
                "title": "sorting-java-solution",
                "content": "```\\n public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> subSequence = new ArrayList<>();\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++) {\\n          sum +=nums[i];\\n        }\\n        Arrays.sort(nums);\\n        int curr=0;\\n        for(int i=nums.length-1;i>-1;i--) {\\n           curr +=nums[i];\\n           subSequence.add(nums[i]);\\n           if(curr>sum-curr) {\\n             break;\\n           }\\n        }\\n      return subSequence;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> subSequence = new ArrayList<>();\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++) {\\n          sum +=nums[i];\\n        }\\n        Arrays.sort(nums);\\n        int curr=0;\\n        for(int i=nums.length-1;i>-1;i--) {\\n           curr +=nums[i];\\n           subSequence.add(nums[i]);\\n           if(curr>sum-curr) {\\n             break;\\n           }\\n        }\\n      return subSequence;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1545084,
                "title": "easy-c-beginner-s-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int total_sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            total_sum+=nums[i];\\n        int curr_sum=0;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(curr_sum<=total_sum)\\n            {\\n                ans.push_back(nums[i]);\\n                curr_sum+=nums[i];\\n            }\\n                \\n            total_sum-=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int total_sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            total_sum+=nums[i];\\n        int curr_sum=0;\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(curr_sum<=total_sum)\\n            {\\n                ans.push_back(nums[i]);\\n                curr_sum+=nums[i];\\n            }\\n                \\n            total_sum-=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237286,
                "title": "python-for-beginners",
                "content": "If you like my simple solution, up-vote! THANKS!!\\n\\n\\n    class Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n        a=0\\n        b=sum(nums)\\n        i=0\\n        while a<=b:\\n            a=a+nums[i]\\n            b=b-nums[i]\\n            i=i+1\\n        ans=nums[:i]\\n        return ans",
                "solutionTags": [],
                "code": "If you like my simple solution, up-vote! THANKS!!\\n\\n\\n    class Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n        a=0\\n        b=sum(nums)\\n        i=0\\n        while a<=b:\\n            a=a+nums[i]\\n            b=b-nums[i]\\n            i=i+1\\n        ans=nums[:i]\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1162619,
                "title": "java-o-n-faster-than-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int sum = 0, currSum = 0;\\n        List<Integer> list = new LinkedList<>();\\n        int[] count = new int[101];\\n        \\n        for(int num : nums){\\n            sum += num;\\n            count[num]++;\\n        }\\n        \\n        int i=100;\\n        while(currSum <= sum){\\n            while(i>1 && count[i]==0){\\n                i--;\\n            }\\n            if(i>=1){\\n                currSum += i;\\n                sum -= i;\\n                count[i]--;\\n                list.add(i);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int sum = 0, currSum = 0;\\n        List<Integer> list = new LinkedList<>();\\n        int[] count = new int[101];\\n        \\n        for(int num : nums){\\n            sum += num;\\n            count[num]++;\\n        }\\n        \\n        int i=100;\\n        while(currSum <= sum){\\n            while(i>1 && count[i]==0){\\n                i--;\\n            }\\n            if(i>=1){\\n                currSum += i;\\n                sum -= i;\\n                count[i]--;\\n                list.add(i);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151513,
                "title": "java-simple-o-nlogn-solution",
                "content": "```\\n\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int totalSum = 0;\\n        List<Integer> result = new ArrayList();\\n        \\n        //Find the sum of all the elements\\n        for(int num: nums) {\\n            totalSum += num;                          //TC of this step : O(n)\\n        }\\n        \\n        //Sort array in asc. order\\n        Arrays.sort(nums);                            //Average case TC of sorting: O(nlogn)\\n        \\n        int inclSum = 0;                   //maintain inclusive sum of numbers included in result\\n        int exclSum = totalSum;     //maintain exclusive sum of numbers being left out of result\\n        int i=nums.length-1;\\n        \\n        while(inclSum <= exclSum) {            //keep appending the result until inclSum > exclSum\\n            result.add(nums[i]);                          //TC for these steps would always be less than n\\n            inclSum += nums[i--];\\n            exclSum = totalSum - inclSum;\\n        }\\n        \\n        return result;                    //Hence total TC: O(nlogn) + O(n) ~= O(nlogn)\\n    }\\n}\\n\\n```\\n\\n``` TC: O(NLogN)  SC: O(1) ```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int totalSum = 0;\\n        List<Integer> result = new ArrayList();\\n        \\n        //Find the sum of all the elements\\n        for(int num: nums) {\\n            totalSum += num;                          //TC of this step : O(n)\\n        }\\n        \\n        //Sort array in asc. order\\n        Arrays.sort(nums);                            //Average case TC of sorting: O(nlogn)\\n        \\n        int inclSum = 0;                   //maintain inclusive sum of numbers included in result\\n        int exclSum = totalSum;     //maintain exclusive sum of numbers being left out of result\\n        int i=nums.length-1;\\n        \\n        while(inclSum <= exclSum) {            //keep appending the result until inclSum > exclSum\\n            result.add(nums[i]);                          //TC for these steps would always be less than n\\n            inclSum += nums[i--];\\n            exclSum = totalSum - inclSum;\\n        }\\n        \\n        return result;                    //Hence total TC: O(nlogn) + O(n) ~= O(nlogn)\\n    }\\n}\\n\\n```\n``` TC: O(NLogN)  SC: O(1) ```",
                "codeTag": "Java"
            },
            {
                "id": 871567,
                "title": "simple-python-solution-commented",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        # Sort order: Desc\\n        nums.sort(reverse=True)\\n        # Subset A starts as sum of all elements\\n        subset_A = sum(nums)\\n        # Subset B is our target\\n        subset_B = 0\\n        # Record the list of elements\\n        B = []\\n        for n in nums:\\n            # remove from subset_A\\n            subset_A -= n\\n            #\\xA0add to subset_B\\n            subset_B += n\\n            # Append to B\\n            B.append(n)\\n            #\\xA0Stop when subset_B first becomes > subset_A\\n            if subset_B > subset_A:\\n                break\\n        return B\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        # Sort order: Desc\\n        nums.sort(reverse=True)\\n        # Subset A starts as sum of all elements\\n        subset_A = sum(nums)\\n        # Subset B is our target\\n        subset_B = 0\\n        # Record the list of elements\\n        B = []\\n        for n in nums:\\n            # remove from subset_A\\n            subset_A -= n\\n            #\\xA0add to subset_B\\n            subset_B += n\\n            # Append to B\\n            B.append(n)\\n            #\\xA0Stop when subset_B first becomes > subset_A\\n            if subset_B > subset_A:\\n                break\\n        return B\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806128,
                "title": "c-8ms-faster-than-100-quick-sort",
                "content": "```\\nint cmpfunc (const void * a, const void * b) {\\n   return ( *(int*)b - *(int*)a );\\n}\\nint* minSubsequence(int* nums, int numsSize, int* returnSize){\\n    qsort(nums, numsSize, sizeof(int), cmpfunc);\\n    int i,rSum=0,lSum=0;\\n    for(i=0; i<numsSize; i++)\\n        rSum += nums[i];\\n    i=0;\\n    *returnSize = 0;\\n    while(rSum>=lSum){\\n        lSum += nums[i];\\n        rSum -= nums[i];\\n        *returnSize += 1;\\n        i++;\\n    }\\n    return nums;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmpfunc (const void * a, const void * b) {\\n   return ( *(int*)b - *(int*)a );\\n}\\nint* minSubsequence(int* nums, int numsSize, int* returnSize){\\n    qsort(nums, numsSize, sizeof(int), cmpfunc);\\n    int i,rSum=0,lSum=0;\\n    for(i=0; i<numsSize; i++)\\n        rSum += nums[i];\\n    i=0;\\n    *returnSize = 0;\\n    while(rSum>=lSum){\\n        lSum += nums[i];\\n        rSum -= nums[i];\\n        *returnSize += 1;\\n        i++;\\n    }\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 758882,
                "title": "java-o-n-prefix-sum-count-sort-2ms",
                "content": "```\\nclass Solution {\\n    \\n    int[] countSort(int arr[], int n){\\n        int count[] = new int[101];\\n        int output[] = new int[n];\\n        for(int val : arr) count[val]++;\\n        for(int i=1;i<101;i++) count[i] += count[i-1]; //prefix sum\\n        for(int i=n-1;i>=0;i--) output[--count[arr[i]]] = arr[i]; // placing the values in output array\\n        return output;\\n    }\\n    \\n    public List<Integer> minSubsequence(int[] nums) {\\n        int n = nums.length;\\n        nums = countSort(nums,n); //since input range is small count sort is preferable\\n        int prefixSum[] = new int[n];\\n        prefixSum[0] = nums[0];\\n        for(int i=1;i<n;i++) prefixSum[i] = prefixSum[i-1] + nums[i];\\n        int sum = 0;\\n        List<Integer> v = new ArrayList<>();\\n        for(int i=n-1;i>=0;i--){\\n            sum += nums[i];\\n            v.add(nums[i]);\\n            if(i>0 && prefixSum[i-1] < sum) break;\\n        }\\n        return v;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] countSort(int arr[], int n){\\n        int count[] = new int[101];\\n        int output[] = new int[n];\\n        for(int val : arr) count[val]++;\\n        for(int i=1;i<101;i++) count[i] += count[i-1]; //prefix sum\\n        for(int i=n-1;i>=0;i--) output[--count[arr[i]]] = arr[i]; // placing the values in output array\\n        return output;\\n    }\\n    \\n    public List<Integer> minSubsequence(int[] nums) {\\n        int n = nums.length;\\n        nums = countSort(nums,n); //since input range is small count sort is preferable\\n        int prefixSum[] = new int[n];\\n        prefixSum[0] = nums[0];\\n        for(int i=1;i<n;i++) prefixSum[i] = prefixSum[i-1] + nums[i];\\n        int sum = 0;\\n        List<Integer> v = new ArrayList<>();\\n        for(int i=n-1;i>=0;i--){\\n            sum += nums[i];\\n            v.add(nums[i]);\\n            if(i>0 && prefixSum[i-1] < sum) break;\\n        }\\n        return v;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652512,
                "title": "python-easy-solution-100-mem",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        new_list=[]\\n        nums.sort()\\n        while sum(new_list)<=sum(nums):\\n            new_list.append(nums.pop()) \\n        return new_list\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        new_list=[]\\n        nums.sort()\\n        while sum(new_list)<=sum(nums):\\n            new_list.append(nums.pop()) \\n        return new_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641655,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int totalSum = Arrays.stream(nums).sum();\\n        int accumSum = 0;\\n        int decrement = nums.length - 1;\\n        Arrays.sort(nums);\\n        while (accumSum <= totalSum) {\\n            accumSum += nums[decrement];\\n            totalSum -= nums[decrement];\\n            res.add(nums[decrement]);\\n            decrement--;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int totalSum = Arrays.stream(nums).sum();\\n        int accumSum = 0;\\n        int decrement = nums.length - 1;\\n        Arrays.sort(nums);\\n        while (accumSum <= totalSum) {\\n            accumSum += nums[decrement];\\n            totalSum -= nums[decrement];\\n            res.add(nums[decrement]);\\n            decrement--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 565130,
                "title": "java-solution-beats-100-time-space-heap-or-sort",
                "content": "Solution uses PriorityQueue\\n```\\nclass Solution {\\n\\tpublic List<Integer> minSubsequence(int[] nums) {\\n\\t\\tint sum = 0;\\n\\t\\tPriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> b - a); // max heap\\n\\t\\tfor (int x : nums) {\\n\\t\\t\\tsum += x;\\n\\t\\t\\tqueue.add(x);\\n\\t\\t}\\n\\n\\t\\tList<Integer> res = new ArrayList<>();\\n\\t\\tint seqSum = 0;\\n\\t\\twhile (2 * seqSum <= sum) {\\n\\t\\t\\tseqSum += queue.peek();\\n\\t\\t\\tres.add(queue.poll());\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```\\nTime: O(n)  (4ms)\\nSpace: O(n)\\n\\nSolution uses sort\\n```\\nclass Solution {\\n\\tpublic List<Integer> minSubsequence(int[] nums) {\\n\\t\\tint sum = 0;\\n\\t\\tArrays.sort(nums);\\n\\t\\tfor (int x : nums) sum += x;\\n\\n\\t\\tList<Integer> res = new ArrayList<>();\\n\\t\\tint seqSum = 0, idx = nums.length - 1;\\n\\t\\twhile (2 * seqSum <= sum) {\\n\\t\\t\\tseqSum += nums[idx];\\n\\t\\t\\tres.add(nums[idx--]);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```\\nTime: O(nlogn)  (3ms)\\nSpace: O(1)\\n\\nBoth solutions beat 100% time & space.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic List<Integer> minSubsequence(int[] nums) {\\n\\t\\tint sum = 0;\\n\\t\\tPriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> b - a); // max heap\\n\\t\\tfor (int x : nums) {\\n\\t\\t\\tsum += x;\\n\\t\\t\\tqueue.add(x);\\n\\t\\t}\\n\\n\\t\\tList<Integer> res = new ArrayList<>();\\n\\t\\tint seqSum = 0;\\n\\t\\twhile (2 * seqSum <= sum) {\\n\\t\\t\\tseqSum += queue.peek();\\n\\t\\t\\tres.add(queue.poll());\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n\\tpublic List<Integer> minSubsequence(int[] nums) {\\n\\t\\tint sum = 0;\\n\\t\\tArrays.sort(nums);\\n\\t\\tfor (int x : nums) sum += x;\\n\\n\\t\\tList<Integer> res = new ArrayList<>();\\n\\t\\tint seqSum = 0, idx = nums.length - 1;\\n\\t\\twhile (2 * seqSum <= sum) {\\n\\t\\t\\tseqSum += nums[idx];\\n\\t\\t\\tres.add(nums[idx--]);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564515,
                "title": "very-easy-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public IList<int> MinSubsequence(int[] nums)\\n        {\\n            int sum = nums.Sum();\\n            Array.Sort(nums, (n1, n2) => n2.CompareTo(n1));\\n            int subSum = 0;\\n\\n            IList<int> res = new List<int>();\\n\\n            foreach (var num in nums)\\n            {\\n                subSum += num;\\n                res.Add(num);\\n                int remains = sum - subSum;\\n\\n                if (subSum > remains)\\n                {\\n                    break;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public IList<int> MinSubsequence(int[] nums)\\n        {\\n            int sum = nums.Sum();\\n            Array.Sort(nums, (n1, n2) => n2.CompareTo(n1));\\n            int subSum = 0;\\n\\n            IList<int> res = new List<int>();\\n\\n            foreach (var num in nums)\\n            {\\n                subSum += num;\\n                res.Add(num);\\n                int remains = sum - subSum;\\n\\n                if (subSum > remains)\\n                {\\n                    break;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564311,
                "title": "c-array-sort-o-nlogn-counting-sort-o-n",
                "content": "**Array.Sort solution**\\n```\\npublic class Solution {\\n    public IList<int> MinSubsequence(int[] nums) {\\n        \\n        int sum = 0, substrate = 0;\\n        List<int> res = new List<int>();\\n        foreach(int num in nums)\\n            sum += num;\\n        \\n        Array.Sort(nums);\\n        for(int i = nums.Length - 1; i >=0; i--)\\n        {\\n            res.Add(nums[i]);\\n            substrate += nums[i];          \\n            if(substrate > sum - substrate)\\n                break;\\n        }\\n        \\n        return res.ToArray();       \\n    }\\n}\\n```\\n\\n**Counting sort solution**\\n```\\n    public IList<int> MinSubsequence(int[] nums) {\\n        \\n        int[] arr = new int[101];\\n        int sum = 0;\\n        List<int> res = new List<int>();\\n        \\n        foreach(int n in nums)\\n        {\\n            sum += n;\\n            arr[n]++;\\n        }\\n            \\n        int currSum = 0;\\n        for(int i = arr.Length - 1; i >= 0 ; i--)\\n        {\\n            while(arr[i] > 0)\\n            {\\n                res.Add(i);\\n                currSum += i;\\n                if(currSum > sum - currSum)\\n                    return res;\\n                arr[i]--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> MinSubsequence(int[] nums) {\\n        \\n        int sum = 0, substrate = 0;\\n        List<int> res = new List<int>();\\n        foreach(int num in nums)\\n            sum += num;\\n        \\n        Array.Sort(nums);\\n        for(int i = nums.Length - 1; i >=0; i--)\\n        {\\n            res.Add(nums[i]);\\n            substrate += nums[i];          \\n            if(substrate > sum - substrate)\\n                break;\\n        }\\n        \\n        return res.ToArray();       \\n    }\\n}\\n```\n```\\n    public IList<int> MinSubsequence(int[] nums) {\\n        \\n        int[] arr = new int[101];\\n        int sum = 0;\\n        List<int> res = new List<int>();\\n        \\n        foreach(int n in nums)\\n        {\\n            sum += n;\\n            arr[n]++;\\n        }\\n            \\n        int currSum = 0;\\n        for(int i = arr.Length - 1; i >= 0 ; i--)\\n        {\\n            while(arr[i] > 0)\\n            {\\n                res.Add(i);\\n                currSum += i;\\n                if(currSum > sum - currSum)\\n                    return res;\\n                arr[i]--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321257,
                "title": "easy-solution-c-sort",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = 0;\\n        for (auto n : nums){\\n            sum += n;\\n        }\\n        sort(nums.begin(), nums.end(), [&](auto a,auto b){\\n            return a>b ;\\n        });\\n        vector<int> ans;\\n        int partial = 0;\\n        for(auto n: nums) {\\n            partial += n;\\n            ans.push_back(n);\\n            if (partial > sum - partial){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = 0;\\n        for (auto n : nums){\\n            sum += n;\\n        }\\n        sort(nums.begin(), nums.end(), [&](auto a,auto b){\\n            return a>b ;\\n        });\\n        vector<int> ans;\\n        int partial = 0;\\n        for(auto n: nums) {\\n            partial += n;\\n            ans.push_back(n);\\n            if (partial > sum - partial){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304642,
                "title": "minimum-subsequence-in-non-increasing-order-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int i, j, sum=0, sum2=0;\\n        sum = accumulate(nums.begin(), nums.end(), 0);\\n        sort(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.end());\\n\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            sum = sum - nums[i];\\n            sum2 = sum2 + nums[i];\\n            if(sum2>sum)\\n            {\\n                nums.resize(i+1);\\n                return nums;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int i, j, sum=0, sum2=0;\\n        sum = accumulate(nums.begin(), nums.end(), 0);\\n        sort(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.end());\\n\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            sum = sum - nums[i];\\n            sum2 = sum2 + nums[i];\\n            if(sum2>sum)\\n            {\\n                nums.resize(i+1);\\n                return nums;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689737,
                "title": "js-easy-solution-with-sorting",
                "content": "```\\nvar minSubsequence = function(nums) {\\n    nums = nums.sort((a, b) => a - b);\\n    const sum = nums.reduce((prev, current) => prev + current, 0);\\n    const output = [];\\n    let subSum = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        subSum += nums[i];\\n        output.push(nums[i]);\\n        if (subSum > sum - subSum) return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar minSubsequence = function(nums) {\\n    nums = nums.sort((a, b) => a - b);\\n    const sum = nums.reduce((prev, current) => prev + current, 0);\\n    const output = [];\\n    let subSum = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        subSum += nums[i];\\n        output.push(nums[i]);\\n        if (subSum > sum - subSum) return output;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2641422,
                "title": "python-solution",
                "content": "# Intuition \\n                   JUET\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n     EASY UNDERSTANDING \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n-        o(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n-            O(n)\\n- \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        nums.sort()\\n        while sum(nums)>sum(ans):\\n            ans.append(nums.pop())\\n        if sum(nums)==sum(ans):\\n            ans.append(nums.pop())\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        nums.sort()\\n        while sum(nums)>sum(ans):\\n            ans.append(nums.pop())\\n        if sum(nums)==sum(ans):\\n            ans.append(nums.pop())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443400,
                "title": "using-do-while-loop-java-solution",
                "content": "class Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int sum1=0;\\n        int sum2=0;\\n        ArrayList<Integer>list=new ArrayList<Integer>();\\n        do{\\n            int max=Integer.MIN_VALUE;\\n            int k=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]>max){\\n                    max=nums[j];\\n                    k=j;\\n                }\\n            }\\n            list.add(max);\\n            nums[k]=0;\\n             sum1=0;\\n            for(int i=0;i<nums.length;i++){\\n                sum1+=nums[i];\\n            }\\n             sum2=0;\\n            for(int i=0;i<list.size();i++){\\n                sum2+=list.get(i);\\n            }\\n            \\n        }\\n        while(sum1>=sum2);\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int sum1=0;\\n        int sum2=0;\\n        ArrayList<Integer>list=new ArrayList<Integer>();\\n        do{\\n            int max=Integer.MIN_VALUE;\\n            int k=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]>max){\\n                    max=nums[j];\\n                    k=j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2441355,
                "title": "c-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) \\n    {\\n        vector<int> ans;\\n        int s=0;\\n        sort(nums.begin(),nums.end());\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            ans.push_back(nums[i]);\\n            s+=nums[i];\\n            if(sum-s<s)\\n                break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you find the solution useful plz upvote",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) \\n    {\\n        vector<int> ans;\\n        int s=0;\\n        sort(nums.begin(),nums.end());\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            ans.push_back(nums[i]);\\n            s+=nums[i];\\n            if(sum-s<s)\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2359612,
                "title": "python-o-n-solution-easily-understandable",
                "content": "This solution might not be the fastest but the code is simple enough to understand the underlying concept. Further optimization can be done to make it faster.\\n\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        \\n        nums.sort()\\n        totalSum=sum(nums)\\n        currSum=0\\n        seq=[]\\n        \\n        for i in range(len(nums)-1,-1,-1):\\n            currSum+=nums[i]\\n            seq.append(nums[i])\\n            \\n            if(currSum>totalSum-currSum):\\n                return seq\\n        \\n        return seq\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        \\n        nums.sort()\\n        totalSum=sum(nums)\\n        currSum=0\\n        seq=[]\\n        \\n        for i in range(len(nums)-1,-1,-1):\\n            currSum+=nums[i]\\n            seq.append(nums[i])\\n            \\n            if(currSum>totalSum-currSum):\\n                return seq\\n        \\n        return seq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323819,
                "title": "simple-c-solution-reverse-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end(),greater<int>());\\n        vector<int> res;\\n        int sum = 0;\\n        for(int i: nums)\\n            sum += i;\\n        \\n        int x=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            x += nums[i];\\n            sum -= nums[i];\\n            res.push_back(nums[i]);\\n            if(x>sum)\\n                break;\\n            \\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end(),greater<int>());\\n        vector<int> res;\\n        int sum = 0;\\n        for(int i: nums)\\n            sum += i;\\n        \\n        int x=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            x += nums[i];\\n            sum -= nums[i];\\n            res.push_back(nums[i]);\\n            if(x>sum)\\n                break;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2126258,
                "title": "python3",
                "content": "```\\ndef minSubsequence(self, nums: List[int]) -> List[int]:\\n        s=[]\\n        for i in range(len(nums)):\\n            if sum(s)<=sum(nums):\\n                s.append(max(nums))\\n                nums.remove(max(nums))\\n        return(sorted(s, key=None, reverse=True))\\n```",
                "solutionTags": [],
                "code": "```\\ndef minSubsequence(self, nums: List[int]) -> List[int]:\\n        s=[]\\n        for i in range(len(nums)):\\n            if sum(s)<=sum(nums):\\n                s.append(max(nums))\\n                nums.remove(max(nums))\\n        return(sorted(s, key=None, reverse=True))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2052641,
                "title": "easy-java-greedy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int num : nums){\\n            sum+=num;\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        int curSum = 0;\\n        int index = nums.length-1;\\n        while(curSum <= sum && index >= 0){\\n            curSum+=nums[index];\\n            sum-=nums[index];\\n            result.add(nums[index]);\\n            index--;\\n        }\\n        Collections.sort(result,(n1,n2)->n2-n1);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int num : nums){\\n            sum+=num;\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        int curSum = 0;\\n        int index = nums.length-1;\\n        while(curSum <= sum && index >= 0){\\n            curSum+=nums[index];\\n            sum-=nums[index];\\n            result.add(nums[index]);\\n            index--;\\n        }\\n        Collections.sort(result,(n1,n2)->n2-n1);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914480,
                "title": "c-two-pointer-greedy-sort-then-compare-sum-of-left-right-sides",
                "content": "```cpp\\nvector<int> minSubsequence(vector<int>& nums) {\\n    vector<int> ans;\\n    int i, j, suml = 0, sumr = 0;\\n\\n    // Sort in increasing order.\\n    sort(nums.begin(), nums.end());\\n\\n    // i <-> j make the right side (larger elements).\\n    for(i = 0, j = 0; j < nums.size(); ++j) {\\n        // Add new element to right side sum.\\n        sumr += nums[j];\\n\\n        // Check if right side sum is still greater if i\\'th element is moved\\n        // to the left side. If so, do that.\\n        if(sumr - nums[i] > suml + nums[i])\\n            sumr -= nums[i], suml += nums[i], ++i;\\n    }\\n\\n    // right side in decreasing order\\n    for(--j; j >= i; --j)\\n        ans.push_back(nums[j]);\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> minSubsequence(vector<int>& nums) {\\n    vector<int> ans;\\n    int i, j, suml = 0, sumr = 0;\\n\\n    // Sort in increasing order.\\n    sort(nums.begin(), nums.end());\\n\\n    // i <-> j make the right side (larger elements).\\n    for(i = 0, j = 0; j < nums.size(); ++j) {\\n        // Add new element to right side sum.\\n        sumr += nums[j];\\n\\n        // Check if right side sum is still greater if i\\'th element is moved\\n        // to the left side. If so, do that.\\n        if(sumr - nums[i] > suml + nums[i])\\n            sumr -= nums[i], suml += nums[i], ++i;\\n    }\\n\\n    // right side in decreasing order\\n    for(--j; j >= i; --j)\\n        ans.push_back(nums[j]);\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841379,
                "title": "beginner-friendly-python-solution",
                "content": "**Time Complexity : O(n)**\\n```\\nclass Solution(object):\\n    def minSubsequence(self, nums):\\n        nums.sort(reverse = True)\\n        Sum = sum(nums)\\n        rSum = 0\\n        res = []\\n        for i in range(len(nums)):\\n            rSum += nums[i]\\n            res.append(nums[i])\\n            if(rSum > Sum - rSum):\\n                return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minSubsequence(self, nums):\\n        nums.sort(reverse = True)\\n        Sum = sum(nums)\\n        rSum = 0\\n        res = []\\n        for i in range(len(nums)):\\n            rSum += nums[i]\\n            res.append(nums[i])\\n            if(rSum > Sum - rSum):\\n                return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841364,
                "title": "beginner-friendly-javascript-solution",
                "content": "**Time Complexity : O(n)**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar minSubsequence = function(nums) {\\n    nums.sort((a,b) => b-a)\\n    sum = 0\\n    for(let i of nums)  sum += i\\n    var res = []\\n    let rSum = 0\\n    for(let i=0; i<nums.length; i++){\\n        rSum += nums[i]\\n        res.push(nums[i])\\n        if(rSum > sum - rSum)   return res\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar minSubsequence = function(nums) {\\n    nums.sort((a,b) => b-a)\\n    sum = 0\\n    for(let i of nums)  sum += i\\n    var res = []\\n    let rSum = 0\\n    for(let i=0; i<nums.length; i++){\\n        rSum += nums[i]\\n        res.push(nums[i])\\n        if(rSum > sum - rSum)   return res\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841363,
                "title": "beginner-friendly-java-solution",
                "content": "**Time Complexity : O(n*logn)**\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int i: nums)    sum += i;\\n        List<Integer> res = new ArrayList<>();\\n        int rSum = 0;\\n        for(int i=nums.length-1; i>=0; i--){\\n            rSum += nums[i];\\n            res.add(nums[i]);\\n            if(rSum > sum - rSum)   return res;\\n        }\\n        return new ArrayList<>();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int i: nums)    sum += i;\\n        List<Integer> res = new ArrayList<>();\\n        int rSum = 0;\\n        for(int i=nums.length-1; i>=0; i--){\\n            rSum += nums[i];\\n            res.add(nums[i]);\\n            if(rSum > sum - rSum)   return res;\\n        }\\n        return new ArrayList<>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805451,
                "title": "easy-fucking-solution-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        vector<int>ans;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=sum+nums[i];\\n        }\\n        int x=0;\\n        sort(nums.begin(),nums.end());\\n        int p;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            x=x+nums[i];\\n            if(x<sum-x)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                p=i;\\n                break;\\n            }\\n        }\\n        for(int i=nums.size()-1;i>=p;i--)\\n        {\\n            ans.push_back(nums[i]);\\n        }\\n        return ans; \\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796340,
                "title": "c-4ms-short-intuitive-solution",
                "content": "**Please upvote if you liked my code. It is always great motivation to write more of such solution :)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) \\n    {\\n        int sum = 0, temp = 0;\\n        vector<int> ans;\\n        \\n        for(auto num: nums)\\n            sum += num;\\n        \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        for(auto num: nums)\\n            if(temp <= sum)\\n            {\\n                ans.push_back(num);\\n                sum -= num;\\n                temp += num;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) \\n    {\\n        int sum = 0, temp = 0;\\n        vector<int> ans;\\n        \\n        for(auto num: nums)\\n            sum += num;\\n        \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        for(auto num: nums)\\n            if(temp <= sum)\\n            {\\n                ans.push_back(num);\\n                sum -= num;\\n                temp += num;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674358,
                "title": "c-easy-solution-o-nlog-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        if(nums.size()==1)return nums;\\n        \\n        int total=accumulate(nums.begin(), nums.end(),0);\\n        \\n        sort(nums.begin(), nums.end(),greater());\\n        vector<int>ans;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(nums[i]);\\n            sum+=nums[i];\\n            if(sum>total-sum)break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        if(nums.size()==1)return nums;\\n        \\n        int total=accumulate(nums.begin(), nums.end(),0);\\n        \\n        sort(nums.begin(), nums.end(),greater());\\n        vector<int>ans;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(nums[i]);\\n            sum+=nums[i];\\n            if(sum>total-sum)break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639807,
                "title": "minimum-subsequence-in-non-increasing-order-java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> list=new ArrayList<>();\\n        Arrays.sort(nums);\\n        int sum=0,sum1=0;\\n        for(int i:nums)\\n            sum+=i;\\n        int n=nums.length;\\n        for(int i=n-1;i>=0;i--){\\n            sum1+=nums[i];\\n            list.add(nums[i]);\\n            if(sum1>sum-sum1)\\n                return list;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> list=new ArrayList<>();\\n        Arrays.sort(nums);\\n        int sum=0,sum1=0;\\n        for(int i:nums)\\n            sum+=i;\\n        int n=nums.length;\\n        for(int i=n-1;i>=0;i--){\\n            sum1+=nums[i];\\n            list.add(nums[i]);\\n            if(sum1>sum-sum1)\\n                return list;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623029,
                "title": "indexing-based-100-fast-solution",
                "content": "```golang\\nfunc minSubsequence(nums []int) (sequence []int) {\\n\\tremaining := 0\\n\\tfreqs := make([]int, 101 /*0..nums[i]*/)\\n\\tfor _, x := range nums {\\n\\t\\tfreqs[x]++\\n\\t\\tremaining += x\\n\\t}\\n\\n\\tfor i, sum := len(freqs)-1, 0; i >= 1 && remaining >= sum; i-- {\\n\\t\\tfor freq := freqs[i]; freq > 0 && remaining >= sum; freq-- {\\n\\t\\t\\tsum += i\\n\\t\\t\\tremaining -= i\\n\\t\\t\\tsequence = append(sequence, i)\\n\\t\\t}\\n\\t}\\n\\treturn\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc minSubsequence(nums []int) (sequence []int) {\\n\\tremaining := 0\\n\\tfreqs := make([]int, 101 /*0..nums[i]*/)\\n\\tfor _, x := range nums {\\n\\t\\tfreqs[x]++\\n\\t\\tremaining += x\\n\\t}\\n\\n\\tfor i, sum := len(freqs)-1, 0; i >= 1 && remaining >= sum; i-- {\\n\\t\\tfor freq := freqs[i]; freq > 0 && remaining >= sum; freq-- {\\n\\t\\t\\tsum += i\\n\\t\\t\\tremaining -= i\\n\\t\\t\\tsequence = append(sequence, i)\\n\\t\\t}\\n\\t}\\n\\treturn\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592525,
                "title": "c-simple-and-clean-solution-beginners-friendly",
                "content": "**Please Upvote if it helped You !!!\\nHappy Coding :)**\\n```\\nvector<int> minSubsequence(vector<int>& nums) \\n    {\\n        int sum=0,newsum=0;\\n        vector<int>answer;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        sort(nums.begin(),nums.end(),std::greater<>());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            newsum+=nums[i];\\n            sum=sum-nums[i];\\n            answer.push_back(nums[i]);\\n            if(newsum>sum)\\n                break;\\n        }\\n        return answer;\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> minSubsequence(vector<int>& nums) \\n    {\\n        int sum=0,newsum=0;\\n        vector<int>answer;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        sort(nums.begin(),nums.end(),std::greater<>());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            newsum+=nums[i];\\n            sum=sum-nums[i];\\n            answer.push_back(nums[i]);\\n            if(newsum>sum)\\n                break;\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577144,
                "title": "c-93-time-64-space-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return  nums;\\n        int sum=0,res=0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n         sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=0;i--){\\n            res+=nums[i];\\n            if(res>(sum-res)){\\n                v.push_back(nums[i]);\\n                return v;\\n            }\\n            else{\\n                v.push_back(nums[i]);\\n            }  \\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return  nums;\\n        int sum=0,res=0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n         sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=0;i--){\\n            res+=nums[i];\\n            if(res>(sum-res)){\\n                v.push_back(nums[i]);\\n                return v;\\n            }\\n            else{\\n                v.push_back(nums[i]);\\n            }  \\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557739,
                "title": "ez-java-90-speed-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int sum = 0;\\n        for(int n : nums)\\n            sum += n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        int temp_sum = 0;\\n        for(int i = nums.length - 1; i >= 0; i--)\\n        {\\n            temp_sum += nums[i];\\n            list.add(nums[i]);\\n            if(temp_sum > sum - temp_sum)\\n            {\\n                return list;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int sum = 0;\\n        for(int n : nums)\\n            sum += n;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        int temp_sum = 0;\\n        for(int i = nums.length - 1; i >= 0; i--)\\n        {\\n            temp_sum += nums[i];\\n            list.add(nums[i]);\\n            if(temp_sum > sum - temp_sum)\\n            {\\n                return list;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530245,
                "title": "java-sorting-two-pointers",
                "content": "```\\npublic List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int startIndex = 0;\\n        int endIndex = nums.length-1;\\n        int sumOfNonIncludedElements = nums[0];\\n        int sumOfIncludedElements = nums[endIndex];\\n        \\n        List<Integer> result = new ArrayList<>();\\n        \\n        while(startIndex < endIndex) {\\n            if(sumOfNonIncludedElements < sumOfIncludedElements) {\\n                sumOfNonIncludedElements+=nums[++startIndex];\\n            } else {\\n                result.add(nums[endIndex]);\\n                sumOfIncludedElements+=nums[--endIndex];\\n            }\\n        }\\n        \\n        result.add(nums[startIndex]);       \\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\npublic List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int startIndex = 0;\\n        int endIndex = nums.length-1;\\n        int sumOfNonIncludedElements = nums[0];\\n        int sumOfIncludedElements = nums[endIndex];\\n        \\n        List<Integer> result = new ArrayList<>();\\n        \\n        while(startIndex < endIndex) {\\n            if(sumOfNonIncludedElements < sumOfIncludedElements) {\\n                sumOfNonIncludedElements+=nums[++startIndex];\\n            } else {\\n                result.add(nums[endIndex]);\\n                sumOfIncludedElements+=nums[--endIndex];\\n            }\\n        }\\n        \\n        result.add(nums[startIndex]);       \\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529994,
                "title": "2-easy-c-solutions-using-stl-4ms-beats-space-and-time-90",
                "content": "Approach 1 : without using any extra space\\n```\\nclass Solution {\\n   public:\\n    vector<int> minSubsequence(vector<int>& nums)\\n    {\\n        // * accumulate and then linear search\\n        // * time:- O(nlogn) to sort, O(n) to accumulate, O(n) to search\\n        // * extra space:- O(1)\\n        sort(nums.begin(), nums.end(), greater());\\n        const auto target_sum = accumulate(nums.begin(), nums.end(), 0) / 2;\\n        const auto it = find_if(\\n            nums.begin(), nums.end(),\\n            [sum = 0, &target_sum](const auto& num) mutable {\\n                return target_sum < (sum += num);\\n            });\\n        nums.erase(it + 1, nums.end());\\n        return nums;\\n    }\\n};\\n```\\nApproach 2 : using an auxiliary array to store prefix sums and for binary search\\n```\\nclass Solution {\\n   public:\\n    vector<int> minSubsequence(vector<int>& nums)\\n    {\\n        // * partial_sum and then binary search\\n        // * time:-  O(nlogn) to sort, O(n) to partial_sum, O(logn) to search\\n        // * extra space:-  O(n) for partial_sum\\n        sort(nums.begin(), nums.end(), greater());\\n        vector<int> prefix_sums = {0};\\n        partial_sum(nums.begin(), nums.end(), back_inserter(prefix_sums));\\n        const auto target_sum = prefix_sums.back() / 2;\\n        const auto ub = upper_bound(\\n                            prefix_sums.begin(),\\n                            prefix_sums.end(),\\n                            target_sum) -\\n                        prefix_sums.begin();\\n        // ! needs extra space for construction\\n        // return vector<int>(nums.begin(), nums.begin() + ub); \\n        nums.erase(nums.begin() + ub, nums.end());\\n        return nums;\\n    }\\n};\\n```\\n\\nIf you have any doubts or suggestions, please feel free to comment.\\nIf you find this solution useful, you know where the upvote is :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    vector<int> minSubsequence(vector<int>& nums)\\n    {\\n        // * accumulate and then linear search\\n        // * time:- O(nlogn) to sort, O(n) to accumulate, O(n) to search\\n        // * extra space:- O(1)\\n        sort(nums.begin(), nums.end(), greater());\\n        const auto target_sum = accumulate(nums.begin(), nums.end(), 0) / 2;\\n        const auto it = find_if(\\n            nums.begin(), nums.end(),\\n            [sum = 0, &target_sum](const auto& num) mutable {\\n                return target_sum < (sum += num);\\n            });\\n        nums.erase(it + 1, nums.end());\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\n   public:\\n    vector<int> minSubsequence(vector<int>& nums)\\n    {\\n        // * partial_sum and then binary search\\n        // * time:-  O(nlogn) to sort, O(n) to partial_sum, O(logn) to search\\n        // * extra space:-  O(n) for partial_sum\\n        sort(nums.begin(), nums.end(), greater());\\n        vector<int> prefix_sums = {0};\\n        partial_sum(nums.begin(), nums.end(), back_inserter(prefix_sums));\\n        const auto target_sum = prefix_sums.back() / 2;\\n        const auto ub = upper_bound(\\n                            prefix_sums.begin(),\\n                            prefix_sums.end(),\\n                            target_sum) -\\n                        prefix_sums.begin();\\n        // ! needs extra space for construction\\n        // return vector<int>(nums.begin(), nums.begin() + ub); \\n        nums.erase(nums.begin() + ub, nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526095,
                "title": "sort-and-compute-sub-sum-94-speed",
                "content": "![image](https://assets.leetcode.com/users/images/c394840e-cd2f-4fbd-98d0-abbcb87404c4_1634470888.4830647.png)\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        total, sub_sum = sum(nums), 0\\n        nums.sort(reverse=True)\\n        for i, n in enumerate(nums):\\n            sub_sum += n\\n            if 2 * sub_sum > total:\\n                return nums[:i + 1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        total, sub_sum = sum(nums), 0\\n        nums.sort(reverse=True)\\n        for i, n in enumerate(nums):\\n            sub_sum += n\\n            if 2 * sub_sum > total:\\n                return nums[:i + 1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438072,
                "title": "c-easy-solution-algo-easy-to-understand-greedy-approch-c",
                "content": "algorithum\\n1->sort the vector\\n2->total sum of the vector\\n3->loop from n-1 to 0\\n4->sum current element\\n5->substract the current element from totalsum\\npush into the vector the current\\n6->check if totalsum<sum break;\\n7->return ans\\n\\ncode\\n**class Solution {\\npublic:\\nvector minSubsequence(vector& nums) {\\n//firstly sort the vector or array\\nsort(nums.begin(),nums.end());\\nint n=nums.size();\\nint totalsum=0;\\nvector< int >ans;\\ntotalsum=accumulate(nums.begin(),nums.end(),0);\\nint sum=0;\\n//greedy approch\\nfor(int i=n-1;i>=0;i--)\\n{\\nsum+=nums[i];\\ntotalsum-=nums[i];\\nans.pushback(nums[i]);\\nif(sum>totalsum)\\n{\\nbreak;\\n}\\n}\\nreturn ans;\\n}\\n};**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\nvector minSubsequence(vector& nums) {\\n//firstly sort the vector or array\\nsort(nums.begin(),nums.end());\\nint n=nums.size();\\nint totalsum=0;\\nvector< int >ans;\\ntotalsum=accumulate(nums.begin(),nums.end(),0);\\nint sum=0;\\n//greedy approch\\nfor(int i=n-1;i>=0;i--)\\n{\\nsum+=nums[i];\\ntotalsum-=nums[i];\\nans.pushback(nums[i]);\\nif(sum>totalsum)\\n{\\nbreak;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1414016,
                "title": "c-easy-explained-sorting-runtime-4-ms-faster-than-92-92",
                "content": "Code has been commented below:\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int sum=0, end=0,cur_sum=0;\\n        vector<int> ans;  //vector to store the final ans elements\\n        sum = accumulate(nums.begin(), nums.end(), sum); //get the sum of all elements\\n       \\n        sort(nums.rbegin(), nums.rend());  //sort the nums in descending order\\n//Now we loop the nums vector and go on adding the elements to cur_sum and check if it becomes \\n//greater thann remaining sum if yes break and return the sum\\n        for(int i=0;i<nums.size();i++){\\n            cur_sum+=nums[i];    //the the current element\\n            ans.push_back(nums[i]);  //also insert it in ans vector\\n            int rem_sum= sum - cur_sum;  //get the remaining sum \\n            if(cur_sum>rem_sum)  //if cur_sum becomes strictly greater than remaining sum break;\\n                break;\\n           \\n        }\\n       return ans; //return the ans vector\\n    }\\n};\\n```\\n**Do upvote if explanation was useful and you liked the code :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int sum=0, end=0,cur_sum=0;\\n        vector<int> ans;  //vector to store the final ans elements\\n        sum = accumulate(nums.begin(), nums.end(), sum); //get the sum of all elements\\n       \\n        sort(nums.rbegin(), nums.rend());  //sort the nums in descending order\\n//Now we loop the nums vector and go on adding the elements to cur_sum and check if it becomes \\n//greater thann remaining sum if yes break and return the sum\\n        for(int i=0;i<nums.size();i++){\\n            cur_sum+=nums[i];    //the the current element\\n            ans.push_back(nums[i]);  //also insert it in ans vector\\n            int rem_sum= sum - cur_sum;  //get the remaining sum \\n            if(cur_sum>rem_sum)  //if cur_sum becomes strictly greater than remaining sum break;\\n                break;\\n           \\n        }\\n       return ans; //return the ans vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397397,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    static int a[];\\n    public List<Integer> minSubsequence(int[] n) {\\n        a=new int[n.length];\\n        int i,k,c=0,m=1;\\n        List<Integer> nm=new ArrayList<>();\\n        for(i=0;i<n.length;i++)\\n        {\\n            a[i]=n[i];\\n        }\\n        task(a,0,n.length-1);\\n        nm.add(a[a.length-1]);\\n        k=a[a.length-1];\\n        for(i=0;i<a.length-m;i++)\\n        {\\n            c=c+a[i];\\n        }\\n        while(k<=c)\\n        {\\n            m++;\\n            c=0;\\n            for(i=0;i<a.length-m;i++)\\n            {\\n                c=c+a[i];\\n            }\\n            k=k+a[i];\\n            nm.add(a[i]);\\n        }\\n        return nm;\\n    }\\n    void task(int n[] , int i , int j)\\n    {\\n        if(i<j)\\n        {\\n            int m=(i+j)/2;\\n            task(n,i,m);\\n            task(n,m+1,j);\\n            task1(n,i,m,j);\\n        }\\n    }\\n    void task1(int n[] , int s , int m , int e)\\n    {\\n        int i=s,j=m+1,k=0;\\n        int b[]=new int[e-s+1];\\n        while(i<=m&&j<=e)\\n        {\\n            if(n[j]>=n[i])\\n                b[k++]=n[i++];\\n            else\\n                b[k++]=n[j++];\\n        }\\n        while(i<=m)\\n            b[k++]=n[i++];\\n        while(j<=e)\\n            b[k++]=n[j++];\\n        for(i=s;i<=e;i++)\\n        {\\n            a[i]=b[i-s];\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    static int a[];\\n    public List<Integer> minSubsequence(int[] n) {\\n        a=new int[n.length];\\n        int i,k,c=0,m=1;\\n        List<Integer> nm=new ArrayList<>();\\n        for(i=0;i<n.length;i++)\\n        {\\n            a[i]=n[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1394443,
                "title": "python3-very-easy-o-nlogn",
                "content": "\\tclass Solution:\\n\\t\\tdef minSubsequence(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tnums.sort(reverse=True)\\n\\t\\t\\ttotal=sum(nums)\\n\\t\\t\\tleftSum=0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\ttotal-=nums[i]\\n\\t\\t\\t\\tleftSum+=nums[i]\\n\\t\\t\\t\\tif leftSum>total:\\n\\t\\t\\t\\t\\treturn nums[0:i+1]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minSubsequence(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tnums.sort(reverse=True)\\n\\t\\t\\ttotal=sum(nums)\\n\\t\\t\\tleftSum=0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\ttotal-=nums[i]\\n\\t\\t\\t\\tleftSum+=nums[i]\\n\\t\\t\\t\\tif leftSum>total:\\n\\t\\t\\t\\t\\treturn nums[0:i+1]",
                "codeTag": "Java"
            },
            {
                "id": 1375348,
                "title": "c-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n  std::vector<int> minSubsequence(std::vector<int>& nums) {\\n    std::sort(nums.begin(), nums.end(), std::greater<int>());\\n    int sum = std::accumulate(nums.begin(), nums.end(), 0);\\n\\n    auto l_it = nums.begin();\\n    int l_sum = *l_it;\\n    int r_sum = sum - l_sum;\\n\\n    while (l_sum <= r_sum) {\\n      ++l_it;\\n      int i = *l_it;\\n      l_sum += i;\\n      r_sum -= i;\\n    }\\n    return std::vector(nums.begin(), l_it + 1);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  std::vector<int> minSubsequence(std::vector<int>& nums) {\\n    std::sort(nums.begin(), nums.end(), std::greater<int>());\\n    int sum = std::accumulate(nums.begin(), nums.end(), 0);\\n\\n    auto l_it = nums.begin();\\n    int l_sum = *l_it;\\n    int r_sum = sum - l_sum;\\n\\n    while (l_sum <= r_sum) {\\n      ++l_it;\\n      int i = *l_it;\\n      l_sum += i;\\n      r_sum -= i;\\n    }\\n    return std::vector(nums.begin(), l_it + 1);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363747,
                "title": "c-simple-greedy-approach-using-stl-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        int n = nums.size();\\n        vector<int> ans;\\n        int sum1=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(sum<sum1){\\n                return ans;\\n            }\\n            ans.push_back(nums[i]);\\n            sum1 += nums[i];\\n            sum -= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        int n = nums.size();\\n        vector<int> ans;\\n        int sum1=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(sum<sum1){\\n                return ans;\\n            }\\n            ans.push_back(nums[i]);\\n            sum1 += nums[i];\\n            sum -= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336944,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn min_subsequence(mut nums: Vec<i32>) -> Vec<i32> {\\n        let all_sum: i32 = nums.iter().sum();\\n        let mut cur_sum = 0;\\n        let mut result = Vec::with_capacity(nums.len());\\n\\n        nums.sort_unstable_by_key(|&x| -x);\\n\\n        for x in nums {\\n            cur_sum += x;\\n            result.push(x);\\n            if cur_sum > all_sum - cur_sum {\\n                break;\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_subsequence(mut nums: Vec<i32>) -> Vec<i32> {\\n        let all_sum: i32 = nums.iter().sum();\\n        let mut cur_sum = 0;\\n        let mut result = Vec::with_capacity(nums.len());\\n\\n        nums.sort_unstable_by_key(|&x| -x);\\n\\n        for x in nums {\\n            cur_sum += x;\\n            result.push(x);\\n            if cur_sum > all_sum - cur_sum {\\n                break;\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1334287,
                "title": "python-solution-in-o-n",
                "content": "class Solution:\\n*     def minSubsequence(self, nums: List[int]) -> List[int]:\\n\\t\\tnums.sort(reverse=True)\\n        n=len(nums)\\n        sum1=sum(nums)\\n        summ=0\\n        i=0\\n        while(i<n):\\n            summ+=nums[i]\\n            sum1-=nums[i]\\n            if(summ>sum1):\\n                break\\n            i+=1\\n        return nums[:i+1]",
                "solutionTags": [],
                "code": "class Solution:\\n*     def minSubsequence(self, nums: List[int]) -> List[int]:\\n\\t\\tnums.sort(reverse=True)\\n        n=len(nums)\\n        sum1=sum(nums)\\n        summ=0\\n        i=0\\n        while(i<n):\\n            summ+=nums[i]\\n            sum1-=nums[i]\\n            if(summ>sum1):\\n                break\\n            i+=1\\n        return nums[:i+1]",
                "codeTag": "Java"
            },
            {
                "id": 1283633,
                "title": "fast-javascript-solution-w-explanation-o-nlogn",
                "content": "1. if we are given an array, i.e. [3, 4, 10, 9, 8], then we can first sort it in descending order to get [10, 9, 8, 4, 3] - O(nlogn) operation\\n2. then we can get the total sum of the array which is 34 - O(n) operation\\n3. then we keep track of a rollingSum (starting at 0) with which we start adding all the largest numbers to it\\n4. while the rollingSum is less than the total sum of the input array, we add every subsequent element to the rollingSum and at the same time, push each element into our return array\\n5. our return array will already be in descending order because we sorted the input array from step 1.\\n\\n\\n```\\nvar minSubsequence = function(nums) {\\n    nums.sort((a, b) => b-a);\\n    let total = nums.reduce((a, b) => a+b, 0);\\n    let rollingSum = 0;\\n    const ans = [];\\n    let i = 0;\\n    while (rollingSum <= total && i < nums.length) {\\n        rollingSum += nums[i];\\n        total -= nums[i];\\n        ans.push(nums[i]);\\n        i++;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minSubsequence = function(nums) {\\n    nums.sort((a, b) => b-a);\\n    let total = nums.reduce((a, b) => a+b, 0);\\n    let rollingSum = 0;\\n    const ans = [];\\n    let i = 0;\\n    while (rollingSum <= total && i < nums.length) {\\n        rollingSum += nums[i];\\n        total -= nums[i];\\n        ans.push(nums[i]);\\n        i++;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1279147,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums)\\n    {\\n        // sort the elements so that we can pick large elements first\\n        sort(nums.begin(),nums.end());\\n        int total=0,sum=0;\\n        \\n        // calculate the total sum\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total+=nums[i];\\n        }\\n        \\n        // ans will store the result \\n        vector<int>ans;\\n        \\n        // Now iterate from the last so that we can pick large elements first and also keep track whether the sum of the currently formed subsequence is greater than sum of the rest. If it is then break the loop ans return the ans.\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            sum+=nums[i];\\n            ans.push_back(nums[i]);\\n            if(sum>total-sum)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code/explanation. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums)\\n    {\\n        // sort the elements so that we can pick large elements first\\n        sort(nums.begin(),nums.end());\\n        int total=0,sum=0;\\n        \\n        // calculate the total sum\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total+=nums[i];\\n        }\\n        \\n        // ans will store the result \\n        vector<int>ans;\\n        \\n        // Now iterate from the last so that we can pick large elements first and also keep track whether the sum of the currently formed subsequence is greater than sum of the rest. If it is then break the loop ans return the ans.\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            sum+=nums[i];\\n            ans.push_back(nums[i]);\\n            if(sum>total-sum)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194055,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        List<Integer> res = new ArrayList<>();\\n        if(nums.length==1){\\n            res.add(nums[0]);\\n            return res;\\n        }\\n        res.clear();\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            sum = sum + nums[i];\\n        }\\n        int resSum = 0;\\n        for(int i=n-1;i>=0;i--){\\n            if(sum >= resSum){\\n                res.add(nums[i]);\\n            }\\n            sum = sum - nums[i];\\n            resSum = resSum + nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        List<Integer> res = new ArrayList<>();\\n        if(nums.length==1){\\n            res.add(nums[0]);\\n            return res;\\n        }\\n        res.clear();\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            sum = sum + nums[i];\\n        }\\n        int resSum = 0;\\n        for(int i=n-1;i>=0;i--){\\n            if(sum >= resSum){\\n                res.add(nums[i]);\\n            }\\n            sum = sum - nums[i];\\n            resSum = resSum + nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185542,
                "title": "python-9-line-code-sorting",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        nums_sum = sum(nums)\\n        ans_sum , ans = 0, []\\n        while ans_sum <= nums_sum:\\n            new_element = nums.pop()\\n            ans.append(new_element)\\n            ans_sum += new_element\\n            nums_sum -= new_element\\n        return ans\\n ```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        nums_sum = sum(nums)\\n        ans_sum , ans = 0, []\\n        while ans_sum <= nums_sum:\\n            new_element = nums.pop()\\n            ans.append(new_element)\\n            ans_sum += new_element\\n            nums_sum -= new_element\\n        return ans\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1162576,
                "title": "4-ms-faster-than-93-08-of-c-online-submissions",
                "content": "```\\nvector<int> minSubsequence(vector<int>& nums) {\\n        vector<int>v;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int curr=0;\\n        for(int i=0;i<nums.size();i++){\\n            curr+=nums[i];\\n            v.push_back(nums[i]);\\n            if(curr>sum-curr){\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> minSubsequence(vector<int>& nums) {\\n        vector<int>v;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int curr=0;\\n        for(int i=0;i<nums.size();i++){\\n            curr+=nums[i];\\n            v.push_back(nums[i]);\\n            if(curr>sum-curr){\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153361,
                "title": "python-using-sort",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n        total_sum = sum(nums)\\n        new_sum = 0\\n        for i in range(len(nums)):\\n            new_sum += nums[i]\\n            total_sum -= nums[i]\\n            if new_sum > total_sum:\\n                ans = nums[:i+1]\\n                return ans \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse=True)\\n        total_sum = sum(nums)\\n        new_sum = 0\\n        for i in range(len(nums)):\\n            new_sum += nums[i]\\n            total_sum -= nums[i]\\n            if new_sum > total_sum:\\n                ans = nums[:i+1]\\n                return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148138,
                "title": "python3-brute-force-solution-4-lines",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        sumi = []\\n        while sum(sumi) <= sum(nums):\\n            sumi.append(nums.pop(nums.index(max(nums))))\\n        return sumi\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        sumi = []\\n        while sum(sumi) <= sum(nums):\\n            sumi.append(nums.pop(nums.index(max(nums))))\\n        return sumi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140702,
                "title": "c-solution-runtime-4-ms-faster-than-94-14",
                "content": "\\tvector<int> minSubsequence(vector<int>& nums) {\\n        \\n        if(nums.size()<2)\\n            return nums;\\n        \\n     sort(nums.begin(),nums.end(), greater<int>());\\n          int i, sum=accumulate(nums.begin(), nums.end(), 0),sm{};\\n            vector<int>ans;\\n        for(i=0;i<nums.size();i++)\\n          {\\n              sm+=nums[i];\\n              if(sm>sum-sm)\\n                  break;\\n          }\\n          \\n          for(int j=0;j<=i;j++)\\n          {\\n              ans.push_back(nums[j]);\\n          }\\n          return ans;",
                "solutionTags": [],
                "code": "\\tvector<int> minSubsequence(vector<int>& nums) {\\n        \\n        if(nums.size()<2)\\n            return nums;\\n        \\n     sort(nums.begin(),nums.end(), greater<int>());\\n          int i, sum=accumulate(nums.begin(), nums.end(), 0),sm{};\\n            vector<int>ans;\\n        for(i=0;i<nums.size();i++)\\n          {\\n              sm+=nums[i];\\n              if(sm>sum-sm)\\n                  break;\\n          }\\n          \\n          for(int j=0;j<=i;j++)\\n          {\\n              ans.push_back(nums[j]);\\n          }\\n          return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1099961,
                "title": "simple-fast-intuitive-javascript-solution-sort-reduce-while-loop",
                "content": "```\\nvar minSubsequence = function (nums) {\\n  if (nums.length === 1) return nums;\\n  let sorted = nums.sort((a, b) => a - b);\\n  let pulledSum = 0;\\n  let remainingSum = sorted.reduce((acc, el) => (acc += el), 0);\\n  let res = [];\\n  while (pulledSum <= remainingSum) {\\n    let val = sorted.pop();\\n    res.push(val);\\n    pulledSum += val;\\n    remainingSum -= val\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSubsequence = function (nums) {\\n  if (nums.length === 1) return nums;\\n  let sorted = nums.sort((a, b) => a - b);\\n  let pulledSum = 0;\\n  let remainingSum = sorted.reduce((acc, el) => (acc += el), 0);\\n  let res = [];\\n  while (pulledSum <= remainingSum) {\\n    let val = sorted.pop();\\n    res.push(val);\\n    pulledSum += val;\\n    remainingSum -= val\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099041,
                "title": "java-simple-intuitive-approach-with-explanation",
                "content": "Approach :- Just pick the element in the sorted Array which makes more then half. Once reached there, return the result.\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int total_sum = 0;\\n        List<Integer> result = new ArrayList<>();\\n        int local_sum = 0;\\n        int length = nums.length;\\n        for (int i : nums) {\\n            total_sum += i;\\n        }\\n        Arrays.sort(nums);\\n        for (int i = nums.length-1;i>=0;i--) {\\n            if (local_sum > (total_sum / 2))\\n                break;\\n            else {\\n                result.add(nums[i]);\\n                local_sum += nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int total_sum = 0;\\n        List<Integer> result = new ArrayList<>();\\n        int local_sum = 0;\\n        int length = nums.length;\\n        for (int i : nums) {\\n            total_sum += i;\\n        }\\n        Arrays.sort(nums);\\n        for (int i = nums.length-1;i>=0;i--) {\\n            if (local_sum > (total_sum / 2))\\n                break;\\n            else {\\n                result.add(nums[i]);\\n                local_sum += nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1097306,
                "title": "python-better-than-93",
                "content": "```\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        s=sum(nums)\\n        new=0\\n        for i in range(len(nums)-1,-1,-1):\\n            new+=nums[i]\\n            s-=nums[i]\\n            if new>s:\\n                ans=nums[i:]\\n                ans.reverse()\\n                return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        s=sum(nums)\\n        new=0\\n        for i in range(len(nums)-1,-1,-1):\\n            new+=nums[i]\\n            s-=nums[i]\\n            if new>s:\\n                ans=nums[i:]\\n                ans.reverse()\\n                return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1077592,
                "title": "java-o-n-solution-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        int sum = 0, curr = 0;\\n        int[] count = new int[101];\\n        for(int num : nums){\\n            sum += num;\\n            ++count[num];\\n        }\\n        for(int num = 100; num > 0 && curr <= sum / 2; --num){\\n            while(curr <= sum / 2 && count[num] > 0){\\n                curr += num;\\n                ans.add(num);\\n                --count[num];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> ans = new ArrayList<>();\\n        int sum = 0, curr = 0;\\n        int[] count = new int[101];\\n        for(int num : nums){\\n            sum += num;\\n            ++count[num];\\n        }\\n        for(int num = 100; num > 0 && curr <= sum / 2; --num){\\n            while(curr <= sum / 2 && count[num] > 0){\\n                curr += num;\\n                ans.add(num);\\n                --count[num];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071247,
                "title": "python-solution-got-faster-than-100-44ms-during-one-run-but-it-s-probably-luck-lol",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 1:\\n            return nums\\n        \\n        nums.sort()\\n        total_sum = sum(nums)\\n        greater_sum = nums[-1]\\n        remaining_sum = total_sum - nums[-1]\\n        index = len(nums) - 2\\n        result = [greater_sum]\\n        \\n        while remaining_sum >= greater_sum:\\n            greater_sum += nums[index]\\n            remaining_sum = total_sum - greater_sum\\n            result.append(nums[index])\\n            index += -1\\n            \\n\\n        return result\\n            \\n```\\n\\n![image](https://assets.leetcode.com/users/images/32aa8691-b063-45ef-9fb8-0386e356bbb2_1613649757.3878796.png)\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 1:\\n            return nums\\n        \\n        nums.sort()\\n        total_sum = sum(nums)\\n        greater_sum = nums[-1]\\n        remaining_sum = total_sum - nums[-1]\\n        index = len(nums) - 2\\n        result = [greater_sum]\\n        \\n        while remaining_sum >= greater_sum:\\n            greater_sum += nums[index]\\n            remaining_sum = total_sum - greater_sum\\n            result.append(nums[index])\\n            index += -1\\n            \\n\\n        return result\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067815,
                "title": "python3-o-n-solution-faster-than-99-63-solutions",
                "content": "- using hash table to count elements in nums and make output sorted\\n- If currVal goes under zero, the sum of answer is greater than the half-sum of nums(strictly greater condition)\\n\\n```\\nclass Solution:\\n    def minSubsequence(self, nums):\\n        hashTable = [0] * 101\\n        sumVal, hashIndex = 0, 100\\n        ans = []\\n        for val in nums:\\n            sumVal += val\\n            hashTable[val] += 1\\n            \\n        currVal = sumVal // 2\\n        \\n        while(hashIndex > 0):\\n            if hashTable[hashIndex] == 0:\\n                hashIndex -= 1\\n                continue\\n            if currVal >= 0:\\n                ans.append(hashIndex)\\n                currVal -= hashIndex\\n                hashTable[hashIndex] -= 1\\n            if currVal < 0:\\n                return ans\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fe0a2f0f-5ae4-4bf1-ab9e-49f0660c76a1_1613450738.911788.png)",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums):\\n        hashTable = [0] * 101\\n        sumVal, hashIndex = 0, 100\\n        ans = []\\n        for val in nums:\\n            sumVal += val\\n            hashTable[val] += 1\\n            \\n        currVal = sumVal // 2\\n        \\n        while(hashIndex > 0):\\n            if hashTable[hashIndex] == 0:\\n                hashIndex -= 1\\n                continue\\n            if currVal >= 0:\\n                ans.append(hashIndex)\\n                currVal -= hashIndex\\n                hashTable[hashIndex] -= 1\\n            if currVal < 0:\\n                return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059868,
                "title": "java-o-n-faster-than-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        var total = 0;\\n        var count = new int[101];\\n        for (var n : nums) {\\n            count[n]++;\\n            total += n;\\n        }\\n        var result = new ArrayList<Integer>();\\n        var localSum = 0;\\n        for (int i = 100; i >= 0; i--) {\\n            if (count[i] > 0) {\\n                for (int j = 0; j < count[i]; j++) {\\n                    result.add(i);\\n                    total -= i;\\n                    localSum += i;\\n                    if (total < localSum) {\\n                        return result;\\n                    }\\n                }                \\n            }\\n        }\\n        return Collections.emptyList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        var total = 0;\\n        var count = new int[101];\\n        for (var n : nums) {\\n            count[n]++;\\n            total += n;\\n        }\\n        var result = new ArrayList<Integer>();\\n        var localSum = 0;\\n        for (int i = 100; i >= 0; i--) {\\n            if (count[i] > 0) {\\n                for (int j = 0; j < count[i]; j++) {\\n                    result.add(i);\\n                    total -= i;\\n                    localSum += i;\\n                    if (total < localSum) {\\n                        return result;\\n                    }\\n                }                \\n            }\\n        }\\n        return Collections.emptyList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059590,
                "title": "java-easy-solution-2ms-beats-95-and-space-80",
                "content": "```\\n public List<Integer> minSubsequence(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n        Arrays.sort(nums);\\n        int sum2=0;\\n        List<Integer> ar=new ArrayList<>();\\n        for(int i=nums.length-1;sum2<=sum;i--){\\n            sum2+=nums[i];\\n            sum-=nums[i];\\n            ar.add(nums[i]);\\n        }\\n        return ar;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public List<Integer> minSubsequence(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n        Arrays.sort(nums);\\n        int sum2=0;\\n        List<Integer> ar=new ArrayList<>();\\n        for(int i=nums.length-1;sum2<=sum;i--){\\n            sum2+=nums[i];\\n            sum-=nums[i];\\n            ar.add(nums[i]);\\n        }\\n        return ar;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036233,
                "title": "python-solution",
                "content": "\\ts = float(sum(nums)) / 2\\n\\tnums.sort()\\n\\tresult = []\\n\\tt = 0\\n\\tfor i in range(len(nums) - 1, -1, -1):\\n\\t\\tresult.append(nums[i])\\n\\t\\tt += nums[i]\\n\\t\\tif t > s:\\n\\t\\t\\treturn result",
                "solutionTags": [],
                "code": "\\ts = float(sum(nums)) / 2\\n\\tnums.sort()\\n\\tresult = []\\n\\tt = 0\\n\\tfor i in range(len(nums) - 1, -1, -1):\\n\\t\\tresult.append(nums[i])\\n\\t\\tt += nums[i]\\n\\t\\tif t > s:\\n\\t\\t\\treturn result",
                "codeTag": "Unknown"
            },
            {
                "id": 1019611,
                "title": "java-solution-using-recursion",
                "content": "class Solution {\\n    List<Integer> finalList=new ArrayList<>();\\n    public List<Integer> minSubsequence(int[] nums) {\\n        if(nums.length==1){\\n        finalList.add(nums[0]);\\n            return finalList;\\n        }\\n        Arrays.sort(nums);\\n        int len=nums.length;\\n        int target=0;\\n        for(int e:nums){\\n            target+=e;\\n        }\\n        finalList.add(nums[len-1]);\\n        getSub(nums,target,len-1,nums[len-1]);\\n        return finalList;\\n    }\\n    \\n    public void getSub(int[] nums,int target,int index,int curSum){\\n        if(curSum>target-curSum){\\n            return;\\n        }else{\\n            finalList.add(nums[index-1]);\\n             getSub(nums,target,index-1,curSum+nums[index-1]);\\n        }\\n       \\n        \\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    List<Integer> finalList=new ArrayList<>();\\n    public List<Integer> minSubsequence(int[] nums) {\\n        if(nums.length==1){\\n        finalList.add(nums[0]);\\n            return finalList;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1010474,
                "title": "c-clean-code-with-quicksort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int r = nums.size() - 1;\\n        QuickSort(nums, 0, r);\\n        vector<int> ans;\\n        int sumL = 0, sumR = 0, l = 0;\\n        while(l <= r) {\\n           if(sumL + nums[l] >= sumR) {\\n               ans.push_back(nums[r]);\\n               sumR += nums[r--];\\n           }\\n           else {\\n               sumL += nums[l++];\\n           }\\n        }\\n        return ans; \\n    }\\n    void QuickSort(vector<int>& nums, int l, int r) {\\n        if(l < r) {\\n            int p = Partition(nums, l, r);\\n            QuickSort(nums, l, p -1);\\n            QuickSort(nums, p + 1, r);\\n        }\\n    }\\n    int Partition(vector<int>& nums, int l, int r) {\\n        int p = nums[l];\\n        while(l < r) {\\n            while(l < r && nums[r] >= p) {\\n                --r;\\n            }\\n            swap(nums[l], nums[r]);\\n            while(l < r && nums[l] <= p) {\\n                ++l;\\n            }\\n            swap(nums[l], nums[r]);\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int r = nums.size() - 1;\\n        QuickSort(nums, 0, r);\\n        vector<int> ans;\\n        int sumL = 0, sumR = 0, l = 0;\\n        while(l <= r) {\\n           if(sumL + nums[l] >= sumR) {\\n               ans.push_back(nums[r]);\\n               sumR += nums[r--];\\n           }\\n           else {\\n               sumL += nums[l++];\\n           }\\n        }\\n        return ans; \\n    }\\n    void QuickSort(vector<int>& nums, int l, int r) {\\n        if(l < r) {\\n            int p = Partition(nums, l, r);\\n            QuickSort(nums, l, p -1);\\n            QuickSort(nums, p + 1, r);\\n        }\\n    }\\n    int Partition(vector<int>& nums, int l, int r) {\\n        int p = nums[l];\\n        while(l < r) {\\n            while(l < r && nums[r] >= p) {\\n                --r;\\n            }\\n            swap(nums[l], nums[r]);\\n            while(l < r && nums[l] <= p) {\\n                ++l;\\n            }\\n            swap(nums[l], nums[r]);\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994957,
                "title": "java-90-55-time-and-99-19-space",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> outputList = new ArrayList<Integer>();\\n        Arrays.sort(nums);\\n        int index = nums.length - 1;\\n        int sumArray = 0;\\n        for(int i : nums)\\n            sumArray += i;\\n        int currSum = 0;\\n        while(currSum <= sumArray){\\n            currSum += nums[index];\\n            sumArray -= nums[index];\\n            outputList.add(nums[index--]);\\n        }\\n        return outputList;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> outputList = new ArrayList<Integer>();\\n        Arrays.sort(nums);\\n        int index = nums.length - 1;\\n        int sumArray = 0;\\n        for(int i : nums)\\n            sumArray += i;\\n        int currSum = 0;\\n        while(currSum <= sumArray){\\n            currSum += nums[index];\\n            sumArray -= nums[index];\\n            outputList.add(nums[index--]);\\n        }\\n        return outputList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952617,
                "title": "go-golang-faster-than-97-44-memory-less-than-100-00",
                "content": "```\\nfunc minSubsequence(nums []int) []int {\\n\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(nums)))\\n\\tsum := 0\\n\\tsumEnd := 0\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tsum += nums[i]\\n\\t}\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tsumEnd += nums[i]\\n\\t\\tif sumEnd > sum-sumEnd {\\n\\t\\t\\treturn nums[:i+1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn []int{}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minSubsequence(nums []int) []int {\\n\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(nums)))\\n\\tsum := 0\\n\\tsumEnd := 0\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tsum += nums[i]\\n\\t}\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tsumEnd += nums[i]\\n\\t\\tif sumEnd > sum-sumEnd {\\n\\t\\t\\treturn nums[:i+1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn []int{}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 924408,
                "title": "java-o-n-1ms-time-array-map",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        \\n        int map[] = new int[101];\\n        int sum = 0, resultSum = 0;\\n\\n        List<Integer> result = new ArrayList<>(nums.length);\\n        \\n        for(int num : nums){\\n            sum += num;\\n            map[num]++;\\n        }\\n        \\n        for(int i = 100 ; i >=0 ; i--){\\n            if(map[i] <= 0 ) continue;\\n            \\n            while(map[i]-- > 0) {\\n                result.add(i);\\n                resultSum += i;\\n                sum -= i;\\n                if(resultSum > sum) break;\\n            }\\n            if(resultSum > sum) break;\\n        }\\n        return result;\\n    }\\n}``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        \\n        int map[] = new int[101];\\n        int sum = 0, resultSum = 0;\\n\\n        List<Integer> result = new ArrayList<>(nums.length);\\n        \\n        for(int num : nums){\\n            sum += num;\\n            map[num]++;\\n        }\\n        \\n        for(int i = 100 ; i >=0 ; i--){\\n            if(map[i] <= 0 ) continue;\\n            \\n            while(map[i]-- > 0) {\\n                result.add(i);\\n                resultSum += i;\\n                sum -= i;\\n                if(resultSum > sum) break;\\n            }\\n            if(resultSum > sum) break;\\n        }\\n        return result;\\n    }\\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920342,
                "title": "java-solution-priority-queue",
                "content": "Java\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        \\n        List<Integer> res=new LinkedList<>();\\n        PriorityQueue<Integer>pq=new PriorityQueue<>(Collections.reverseOrder());\\n        int totalsum=0,subsum=0;;\\n        for(int num : nums)\\n        {\\n            pq.add(num);\\n            totalsum+=num;\\n        }\\n        while(subsum<=totalsum-subsum)\\n        {\\n            res.add(pq.peek());\\n            subsum+=pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        \\n        List<Integer> res=new LinkedList<>();\\n        PriorityQueue<Integer>pq=new PriorityQueue<>(Collections.reverseOrder());\\n        int totalsum=0,subsum=0;;\\n        for(int num : nums)\\n        {\\n            pq.add(num);\\n            totalsum+=num;\\n        }\\n        while(subsum<=totalsum-subsum)\\n        {\\n            res.add(pq.peek());\\n            subsum+=pq.poll();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886735,
                "title": "ruby-find-sum-sort-in-decreasing-order-count-sub-sum-in-a-loop",
                "content": "##### Leetcode: 1403. Minimum Subsequence in Non-Increasing Order.\\n\\nCalculate total sum of the array first, than sort array in decreasing order. Create variable sub_sum and increase it by an element on every iteration of a loop.  When sub_sum become greater than sum of rest of the array, return slice of sorted array from 0 till current index inclusively. Sum of a rest of the array calculated as a deduction of sub_sum from a total sum.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1403. Minimum Subsequence in Non-Increasing Order.\\n# https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/\\n# Runtime: 64 ms, faster than 21.05% of Ruby online submissions for Minimum Subsequence in Non-Increasing Order.\\n# Memory Usage: 210.4 MB, less than 10.53% of Ruby online submissions for Minimum Subsequence in Non-Increasing Order.\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef min_subsequence(nums)\\n    sum = nums.sum\\n    nums.sort_by!{|x| -x}\\n    sub_sum = 0\\n    nums.each_with_index do |x,i|\\n        sub_sum += x\\n        return nums[0..i] if sub_sum > sum - sub_sum\\n    end\\n    raise \"Can not find an answer!\"\\n    \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1403. Minimum Subsequence in Non-Increasing Order.\\n# https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/\\n# Runtime: 64 ms, faster than 21.05% of Ruby online submissions for Minimum Subsequence in Non-Increasing Order.\\n# Memory Usage: 210.4 MB, less than 10.53% of Ruby online submissions for Minimum Subsequence in Non-Increasing Order.\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef min_subsequence(nums)\\n    sum = nums.sum\\n    nums.sort_by!{|x| -x}\\n    sub_sum = 0\\n    nums.each_with_index do |x,i|\\n        sub_sum += x\\n        return nums[0..i] if sub_sum > sum - sub_sum\\n    end\\n    raise \"Can not find an answer!\"\\n    \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 886676,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        output = []\\n        def finding(nums):\\n            max_nums = max(nums)\\n            output.append(max_nums)\\n            nums.remove(max_nums)\\n            if sum(output) > sum(nums):\\n                return output\\n            else:\\n                finding(nums)\\n        finding(nums)\\n        return output\\n```\\nFOR MORE SOLUTIONS, CHECHOUT MY GITHUB:https://github.com/Kushagrabainsla/Leetcode_DSA",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        output = []\\n        def finding(nums):\\n            max_nums = max(nums)\\n            output.append(max_nums)\\n            nums.remove(max_nums)\\n            if sum(output) > sum(nums):\\n                return output\\n            else:\\n                finding(nums)\\n        finding(nums)\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873676,
                "title": "c-explained-solution",
                "content": "**DO LIKE IF U FOUND IT HELPFULL**\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        vector<int> ans;\\n        int total=0;\\n        for(int i=0;i<nums.size();i++)\\n            total+=nums[i];                  //adding all elements for total\\n        sort(nums.begin(),nums.end(),greater<>());  //sorting in decrasing order\\n        int val=0;\\n        for(int i=0;i<nums.size();i++){     //here we are taking sum of elements and pushing them into an vector\\n            val+=nums[i];\\n           // cout<<nums[i]<<\" \"<<val<<\" \"<<total<<\" \"<<total-val<<\" \";\\n            ans.push_back(nums[i]);\\n            if(val>(total-val))   //when the val becomes more than total-val basically if these elements are removed then left subsequence has less sum we break from the loop\\n                break;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        vector<int> ans;\\n        int total=0;\\n        for(int i=0;i<nums.size();i++)\\n            total+=nums[i];                  //adding all elements for total\\n        sort(nums.begin(),nums.end(),greater<>());  //sorting in decrasing order\\n        int val=0;\\n        for(int i=0;i<nums.size();i++){     //here we are taking sum of elements and pushing them into an vector\\n            val+=nums[i];\\n           // cout<<nums[i]<<\" \"<<val<<\" \"<<total<<\" \"<<total-val<<\" \";\\n            ans.push_back(nums[i]);\\n            if(val>(total-val))   //when the val becomes more than total-val basically if these elements are removed then left subsequence has less sum we break from the loop\\n                break;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 869800,
                "title": "c-solution-using-sorting-12-ms",
                "content": "The question can be solved by greedy approach. Here its said that we have to find the minimum subsequence such that its sum is greater than rest of the sum of non included elements in the subsequence.\\nUpon thinking you can find out if we choose the maximum elements of the vector only then our work will be done.\\n\\nSo firstly I sorted my vector in descending order. Then I took out the sum of all elements using first for loop.\\nThen in the second for loop I am storing the sum of maximum elements in one variable(nsum) and subtracting that element value from variable sum.\\nIf nsum becomes greater than sum then return v.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        if(nums.size() == 0) return {};\\n        vector <int> v;\\n        int i, sum=0, nsum=0;\\n        for(i=0; i<nums.size(); i++) \\n            sum += nums[i];\\n        for(i=0; i<nums.size(); i++) {\\n            nsum += nums[i];\\n            sum -= nums[i];\\n            v.push_back(nums[i]);\\n            if(nsum>sum) {\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        if(nums.size() == 0) return {};\\n        vector <int> v;\\n        int i, sum=0, nsum=0;\\n        for(i=0; i<nums.size(); i++) \\n            sum += nums[i];\\n        for(i=0; i<nums.size(); i++) {\\n            nsum += nums[i];\\n            sum -= nums[i];\\n            v.push_back(nums[i]);\\n            if(nsum>sum) {\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868674,
                "title": "using-prefix-sum-array-and-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        if(nums.size()==1) return nums ;\\n\\t\\t\\n        vector<int> result ;\\n        sort(nums.begin(),nums.end()) ;\\n\\t\\tint pSum[nums.size()] ;\\n\\t\\t\\n        //prefix sum array\\n\\t\\tpSum[0] = nums[0] ;\\n\\t\\tfor(int i = 1;i<nums.size();i++){\\n\\t\\t\\tpSum[i] = pSum[i-1]+nums[i] ;\\n\\t\\t}\\n\\t\\t\\n        int  i = nums.size()-1 ;\\n\\t\\tint sum =  0 ;\\n\\t\\twhile (i>=0 && !(sum > pSum[i]))\\n\\t\\t{\\t\\n\\t\\t\\tresult.push_back(nums[i]);\\n\\t\\t\\tsum+=nums[i] ;\\n            i-- ;\\n\\t\\t}\\n\\t\\treturn result ;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        if(nums.size()==1) return nums ;\\n\\t\\t\\n        vector<int> result ;\\n        sort(nums.begin(),nums.end()) ;\\n\\t\\tint pSum[nums.size()] ;\\n\\t\\t\\n        //prefix sum array\\n\\t\\tpSum[0] = nums[0] ;\\n\\t\\tfor(int i = 1;i<nums.size();i++){\\n\\t\\t\\tpSum[i] = pSum[i-1]+nums[i] ;\\n\\t\\t}\\n\\t\\t\\n        int  i = nums.size()-1 ;\\n\\t\\tint sum =  0 ;\\n\\t\\twhile (i>=0 && !(sum > pSum[i]))\\n\\t\\t{\\t\\n\\t\\t\\tresult.push_back(nums[i]);\\n\\t\\t\\tsum+=nums[i] ;\\n            i-- ;\\n\\t\\t}\\n\\t\\treturn result ;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850837,
                "title": "my-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic List<Integer> minSubsequence(int[] arr) {\\n        List<Integer> ll = new ArrayList<>();\\n\\t\\tArrays.sort(arr);\\n\\t\\t\\n\\t\\tint sum = 0, c = 0;\\n\\t\\tfor(int val:arr) sum += val;\\n\\t\\t\\n\\t\\tfor(int i=arr.length-1;i>=0;i--) {\\n\\t\\t\\tc += arr[i];\\n\\t\\t\\tsum -= arr[i];\\n\\t\\t\\tll.add(arr[i]);\\n\\t\\t\\tif(c>sum) return ll;\\n\\t\\t}\\t\\t\\n\\t\\treturn ll;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic List<Integer> minSubsequence(int[] arr) {\\n        List<Integer> ll = new ArrayList<>();\\n\\t\\tArrays.sort(arr);\\n\\t\\t\\n\\t\\tint sum = 0, c = 0;\\n\\t\\tfor(int val:arr) sum += val;\\n\\t\\t\\n\\t\\tfor(int i=arr.length-1;i>=0;i--) {\\n\\t\\t\\tc += arr[i];\\n\\t\\t\\tsum -= arr[i];\\n\\t\\t\\tll.add(arr[i]);\\n\\t\\t\\tif(c>sum) return ll;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 841372,
                "title": "java-1ms-less-than-100",
                "content": "```\\npublic static List<Integer> minSubsequence(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(nums.length == 1) {\\n            ans.add(nums[0]);\\n            return ans;\\n        }\\n\\n        int[] arr = new int[101];\\n        int sumMax = 0;\\n        int currentSum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            arr[nums[i]] += 1;\\n            sumMax += nums[i];\\n        }\\n        for (int i = arr.length - 1; i > 0 ; i--) {\\n            int current = arr[i];\\n            if(current != 0) {\\n\\t\\t\\tfor(int number = 0; number < current; number++) {\\n\\t\\t\\t\\tsumMax -= i;\\n\\t\\t\\t\\tcurrentSum += i;\\n\\t\\t\\t\\tans.add(i);\\n\\t\\t\\t\\tif(currentSum > sumMax) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic static List<Integer> minSubsequence(int[] nums) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(nums.length == 1) {\\n            ans.add(nums[0]);\\n            return ans;\\n        }\\n\\n        int[] arr = new int[101];\\n        int sumMax = 0;\\n        int currentSum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            arr[nums[i]] += 1;\\n            sumMax += nums[i];\\n        }\\n        for (int i = arr.length - 1; i > 0 ; i--) {\\n            int current = arr[i];\\n            if(current != 0) {\\n\\t\\t\\tfor(int number = 0; number < current; number++) {\\n\\t\\t\\t\\tsumMax -= i;\\n\\t\\t\\t\\tcurrentSum += i;\\n\\t\\t\\t\\tans.add(i);\\n\\t\\t\\t\\tif(currentSum > sumMax) {\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745567,
                "title": "javascript-sort-sum-loop",
                "content": "```\\nvar minSubsequence = function(nums) {\\n    nums.sort((a, b) => b - a);\\n    const sum = _.sum(nums),\\n        ret = [],\\n        len = nums.length;\\n    let i = 0,\\n        runningSum = 0;\\n\\n    for (; i < len; i += 1) {\\n        if (runningSum <= sum - runningSum) {\\n            runningSum += nums[i];\\n            ret.push(nums[i]);\\n        }\\n    }\\n\\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSubsequence = function(nums) {\\n    nums.sort((a, b) => b - a);\\n    const sum = _.sum(nums),\\n        ret = [],\\n        len = nums.length;\\n    let i = 0,\\n        runningSum = 0;\\n\\n    for (; i < len; i += 1) {\\n        if (runningSum <= sum - runningSum) {\\n            runningSum += nums[i];\\n            ret.push(nums[i]);\\n        }\\n    }\\n\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 742801,
                "title": "c-using-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int sum = 0;\\n        for (int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n        }\\n        vector<int> res;\\n        int tmp = 0;\\n        for (int i = nums.size()-1;i>= 0 ;i--){\\n            tmp += nums[i];\\n            sum -= nums[i];\\n            res.push_back(nums[i]);\\n            if (tmp > sum){\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int sum = 0;\\n        for (int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n        }\\n        vector<int> res;\\n        int tmp = 0;\\n        for (int i = nums.size()-1;i>= 0 ;i--){\\n            tmp += nums[i];\\n            sum -= nums[i];\\n            res.push_back(nums[i]);\\n            if (tmp > sum){\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721115,
                "title": "c-tc-o-n-added-the-comments-runtime-12-ms-faster-than-95-68",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());//Sort the nums to make sure greater are at end\\n        int totalSum = 0;\\n        for(auto a:nums)\\n        {\\n            totalSum += a;//calculate the total sum of the array\\n        }\\n        int curSum = 0;\\n        vector<int> output;\\n        for(int i = nums.size()-1; i>=0; --i)\\n        {//iterate the backward until the curSum is greater than remaining sum.\\n            output.push_back(nums[i]);//push the item in the array\\n            curSum += nums[i];\\n            if(curSum > totalSum-curSum)//if curSum is greater than remaining break\\n                break;                \\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());//Sort the nums to make sure greater are at end\\n        int totalSum = 0;\\n        for(auto a:nums)\\n        {\\n            totalSum += a;//calculate the total sum of the array\\n        }\\n        int curSum = 0;\\n        vector<int> output;\\n        for(int i = nums.size()-1; i>=0; --i)\\n        {//iterate the backward until the curSum is greater than remaining sum.\\n            output.push_back(nums[i]);//push the item in the array\\n            curSum += nums[i];\\n            if(curSum > totalSum-curSum)//if curSum is greater than remaining break\\n                break;                \\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720413,
                "title": "simple-rust",
                "content": "```\\nimpl Solution {\\n    pub fn min_subsequence(mut nums: Vec<i32>) -> Vec<i32> {\\n        let mut res = Vec::new();\\n        nums.sort();\\n        while nums.iter().sum::<i32>() >= res.iter().sum::<i32>() {\\n            res.push(nums.pop().unwrap());\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_subsequence(mut nums: Vec<i32>) -> Vec<i32> {\\n        let mut res = Vec::new();\\n        nums.sort();\\n        while nums.iter().sum::<i32>() >= res.iter().sum::<i32>() {\\n            res.push(nums.pop().unwrap());\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705383,
                "title": "java-clean-solution-with-o-n-log-n-time",
                "content": "Sort the input and then keep adding biggest elements to the result\\n\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int sum = getSum(nums);\\n        Arrays.sort(nums);\\n        \\n        int currentSum = 0;\\n        int i = nums.length - 1;\\n        List<Integer> result = new ArrayList<>();\\n        \\n        while (currentSum <= sum) {\\n            sum -= nums[i];\\n            currentSum += nums[i];\\n            result.add(nums[i]);\\n            i--;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int getSum(int[] nums) {\\n        int sum = 0;\\n        \\n        for (int num : nums) {\\n            sum += num;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int sum = getSum(nums);\\n        Arrays.sort(nums);\\n        \\n        int currentSum = 0;\\n        int i = nums.length - 1;\\n        List<Integer> result = new ArrayList<>();\\n        \\n        while (currentSum <= sum) {\\n            sum -= nums[i];\\n            currentSum += nums[i];\\n            result.add(nums[i]);\\n            i--;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int getSum(int[] nums) {\\n        int sum = 0;\\n        \\n        for (int num : nums) {\\n            sum += num;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705196,
                "title": "python-o-n-very-easy-solution",
                "content": "\\tdef minSubsequence(self, nums: List[int]) -> List[int]:\\n        ct = [0]*101\\n        for n in nums:\\n            ct[n] += 1\\n        # Counting sort\\n        idx = 0\\n        for i, c in enumerate(ct):\\n            while c > 0:\\n                nums[idx] = i\\n                idx += 1\\n                c -= 1\\n        total = sum(nums)\\n        rsum = 0\\n        i, ans = len(nums), []\\n        while total - rsum >= rsum:\\n            i -= 1\\n            rsum += nums[i]\\n            ans.append(nums[i])\\n        return ans",
                "solutionTags": [],
                "code": "\\tdef minSubsequence(self, nums: List[int]) -> List[int]:\\n        ct = [0]*101\\n        for n in nums:\\n            ct[n] += 1\\n        # Counting sort\\n        idx = 0\\n        for i, c in enumerate(ct):\\n            while c > 0:\\n                nums[idx] = i\\n                idx += 1\\n                c -= 1\\n        total = sum(nums)\\n        rsum = 0\\n        i, ans = len(nums), []\\n        while total - rsum >= rsum:\\n            i -= 1\\n            rsum += nums[i]\\n            ans.append(nums[i])\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 680952,
                "title": "simple-c-solution",
                "content": "```\\nvector<int> minSubsequence(vector<int>& nums) {\\n        if(nums.size() == 1) return nums;\\n        vector<int> a;\\n        sort(nums.rbegin(), nums.rend());\\n        int c=0, b = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n                a.push_back(nums[i]);\\n                c += nums[i];\\n            for(int k = i+1; k<nums.size(); ++k){\\n                b += nums[k];\\n            }\\n            if(c>b){\\n                return a;\\n                break;\\n            }\\n            b = 0;\\n        }\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> minSubsequence(vector<int>& nums) {\\n        if(nums.size() == 1) return nums;\\n        vector<int> a;\\n        sort(nums.rbegin(), nums.rend());\\n        int c=0, b = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n                a.push_back(nums[i]);\\n                c += nums[i];\\n            for(int k = i+1; k<nums.size(); ++k){\\n                b += nums[k];\\n            }\\n            if(c>b){\\n                return a;\\n                break;\\n            }\\n            b = 0;\\n        }\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 616158,
                "title": "most-easy-using-simple-sort-function",
                "content": "class Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        vector<int> v1;\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long sum=0;\\n        long long sum1=0;\\n         long long sum2=0;\\n        int x;\\n        for(int i=0;i<nums.size();i++)\\n        sum+=nums[i];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum1+=nums[i];\\n            sum2=sum-sum1;\\n            if(sum1>sum2)\\n            {\\n                x=i;\\n                goto label;\\n            }\\n            \\n        }\\n        label:;\\n        for(int i=0;i<=x;i++)\\n        {\\n            v1.push_back(nums[i]);\\n        }\\n        return v1;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        vector<int> v1;\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long sum=0;\\n        long long sum1=0;\\n         long long sum2=0;\\n        int x;\\n        for(int i=0;i<nums.size();i++)\\n        sum+=nums[i];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum1+=nums[i];\\n            sum2=sum-sum1;\\n            if(sum1>sum2)\\n            {\\n                x=i;\\n                goto label;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 603771,
                "title": "cpp-simple-easy-sort-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int s=accumulate(begin(nums),end(nums),0);\\n        sort(begin(nums),end(nums));\\n        vector<int> res;\\n        int a=0;\\n        int i=nums.size()-1;\\n        while(i>-1&&a<=s){\\n            res.push_back(nums[i]);\\n            a+=nums[i];\\n            s-=nums[i];\\n            i--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int s=accumulate(begin(nums),end(nums),0);\\n        sort(begin(nums),end(nums));\\n        vector<int> res;\\n        int a=0;\\n        int i=nums.size()-1;\\n        while(i>-1&&a<=s){\\n            res.push_back(nums[i]);\\n            a+=nums[i];\\n            s-=nums[i];\\n            i--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602595,
                "title": "java-straightforward-solution-with-explanation-3-ms-39-4-mb-o-nlogn",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {  \\n        // Very important first step: Sorts nums[] in ascending order \\n        Arrays.sort(nums);\\n\\n        // get total sum of all its elements\\n        int totalSum = 0;\\n        for(int i: nums)\\n            totalSum += i;\\n        \\n        List<Integer> subsequence = new ArrayList<>();        \\n        int subSum = 0;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            subsequence.add(nums[i]);\\n            subSum += nums[i];\\n            // strictly greater than the totalSum\\n            if(subSum > totalSum - subSum)\\n                break;\\n        }\\n        return subsequence;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {  \\n        // Very important first step: Sorts nums[] in ascending order \\n        Arrays.sort(nums);\\n\\n        // get total sum of all its elements\\n        int totalSum = 0;\\n        for(int i: nums)\\n            totalSum += i;\\n        \\n        List<Integer> subsequence = new ArrayList<>();        \\n        int subSum = 0;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            subsequence.add(nums[i]);\\n            subSum += nums[i];\\n            // strictly greater than the totalSum\\n            if(subSum > totalSum - subSum)\\n                break;\\n        }\\n        return subsequence;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599571,
                "title": "java-98-o-nlogn-sorting-and-greedy",
                "content": "```\\npublic List<Integer> minSubsequence(int[] nums) {\\n        int sum=0;\\n        for(int num:nums)\\n            sum+=num;\\n        Arrays.sort(nums);\\n        List<Integer> res=new ArrayList();\\n        int n=nums.length;\\n        int currentSum=0;\\n\\t\\t// Iterating from end as the largest elements are at the end, and the goal is to take minimum element subsequence.\\n        for(int index=n-1; index>=0;index--){\\n            res.add(nums[index]);\\n            currentSum+=nums[index];\\n\\t\\t\\t// Whenver sum from the end is larger than the remaining sum, return res.\\n            if(currentSum>sum-currentSum)\\n                return res;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> minSubsequence(int[] nums) {\\n        int sum=0;\\n        for(int num:nums)\\n            sum+=num;\\n        Arrays.sort(nums);\\n        List<Integer> res=new ArrayList();\\n        int n=nums.length;\\n        int currentSum=0;\\n\\t\\t// Iterating from end as the largest elements are at the end, and the goal is to take minimum element subsequence.\\n        for(int index=n-1; index>=0;index--){\\n            res.add(nums[index]);\\n            currentSum+=nums[index];\\n\\t\\t\\t// Whenver sum from the end is larger than the remaining sum, return res.\\n            if(currentSum>sum-currentSum)\\n                return res;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594629,
                "title": "java-98-speed-100-mem",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int maxKey=0;\\n        List<Integer> list=new ArrayList<>();\\n        int picked=0;\\n        int sum=0;\\n        int index=nums.length-1;\\n        for (int i : nums) sum+=i;\\n        Arrays.sort(nums);\\n        \\n        \\n        while ( picked<=sum){\\n            picked+=nums[index];\\n            sum-=nums[index];\\n            \\n            list.add(nums[index]);\\n            index--;\\n        }\\n    return list;\\n    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int maxKey=0;\\n        List<Integer> list=new ArrayList<>();\\n        int picked=0;\\n        int sum=0;\\n        int index=nums.length-1;\\n        for (int i : nums) sum+=i;\\n        Arrays.sort(nums);\\n        \\n        \\n        while ( picked<=sum){\\n            picked+=nums[index];\\n            sum-=nums[index];\\n            \\n            list.add(nums[index]);\\n            index--;\\n        }\\n    return list;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590890,
                "title": "python-sort-and-then-start-from-end",
                "content": "2n + nlog(n) => O(nlogn) time complexity \\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        totalSum = sum(nums)\\n        k = len(nums) - 1\\n        runningSum = 0\\n        res = []\\n        nums.sort()\\n        \\n        while runningSum <= totalSum:\\n            runningSum += nums[k]\\n            totalSum -= nums[k]\\n            res.append(nums[k])\\n            k -= 1\\n            \\n        return sorted(res)[::-1]\\n",
                "solutionTags": [],
                "code": "2n + nlog(n) => O(nlogn) time complexity \\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        totalSum = sum(nums)\\n        k = len(nums) - 1\\n        runningSum = 0\\n        res = []\\n        nums.sort()\\n        \\n        while runningSum <= totalSum:\\n            runningSum += nums[k]\\n            totalSum -= nums[k]\\n            res.append(nums[k])\\n            k -= 1\\n            \\n        return sorted(res)[::-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 581735,
                "title": "16ms-o-n-c-beat-81-72-short-video-explanation",
                "content": "[Video](https://www.youtube.com/watch?v=JvPQpnakFBs&feature=youtu.be)\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n                vector<int> v;\\n                int s1=0, sfs=0,sfe=0;\\n\\n                sort(nums.begin(), nums.end(), greater<int>());\\n\\n                for(auto i:nums){\\n                        s1 += i;\\n                }\\n\\n                sfe = s1;\\n\\n                for(auto i:nums){\\n                        if(sfe>=sfs){\\n                                sfs = sfs + i;\\n                                sfe = sfe - i;\\n                                v.push_back(i);\\n                        }\\n                        if(sfe<sfs)\\n                                break;\\n                }\\n                return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n                vector<int> v;\\n                int s1=0, sfs=0,sfe=0;\\n\\n                sort(nums.begin(), nums.end(), greater<int>());\\n\\n                for(auto i:nums){\\n                        s1 += i;\\n                }\\n\\n                sfe = s1;\\n\\n                for(auto i:nums){\\n                        if(sfe>=sfs){\\n                                sfs = sfs + i;\\n                                sfe = sfe - i;\\n                                v.push_back(i);\\n                        }\\n                        if(sfe<sfs)\\n                                break;\\n                }\\n                return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577629,
                "title": "c-easy-97-speed-100-memory",
                "content": "class Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end(),greater<int>());\\n            int sum =0, value =0;\\n        for(int i :nums)\\n            sum+=i;\\n        \\n       \\n        vector<int> v;\\n        for(int i: nums)\\n        {\\n            if(sum>=value)\\n            {\\n                sum-=i;\\n                value+=i;\\n                v.push_back(i);     \\n                \\n            }\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end(),greater<int>());\\n            int sum =0, value =0;\\n        for(int i :nums)\\n            sum+=i;\\n        \\n       \\n        vector<int> v;\\n        for(int i: nums)\\n        {\\n            if(sum>=value)\\n            {\\n                sum-=i;\\n                value+=i;\\n                v.push_back(i);     \\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 576540,
                "title": "java-1ms-easy-to-understand-with-appropriate-comments-solution-1ms-run-time",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> l = new ArrayList<Integer>();\\n        Arrays.sort(nums);      //sorting to get max elements at last\\n        int i = nums.length - 1;\\n        int total_sum = 0;\\n        for(int a : nums)       //calculating the total elements sum for further processing\\n            total_sum += a;    \\n        int sub_sum = 0;\\n        while(i >= 0){          //we can get the max sub arr by subracting the sub arr with total arr sum\\n            if(sub_sum <= (total_sum - sub_sum)){     \\n                sub_sum +=nums[i];\\n                l.add(nums[i]);\\n            }            \\n            --i;\\n        }\\n        return l;\\n        // total time O(sort + n + n) --> depends on sorting algo, atleast we\\'ll get O(nlogn)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        List<Integer> l = new ArrayList<Integer>();\\n        Arrays.sort(nums);      //sorting to get max elements at last\\n        int i = nums.length - 1;\\n        int total_sum = 0;\\n        for(int a : nums)       //calculating the total elements sum for further processing\\n            total_sum += a;    \\n        int sub_sum = 0;\\n        while(i >= 0){          //we can get the max sub arr by subracting the sub arr with total arr sum\\n            if(sub_sum <= (total_sum - sub_sum)){     \\n                sub_sum +=nums[i];\\n                l.add(nums[i]);\\n            }            \\n            --i;\\n        }\\n        return l;\\n        // total time O(sort + n + n) --> depends on sorting algo, atleast we\\'ll get O(nlogn)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566800,
                "title": "python3-priority-queue-heap-tim-sort-counting-sort-easy-solutions",
                "content": "\\n\\n### default sort (Timsort)\\nT: O(nlogn)\\nS: O(1) without couting the result\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        \\n        all_sum = sum(nums)\\n        nums.sort(reverse=True)\\n        \\n        large_part = 0\\n        for i, val in enumerate(nums):\\n            large_part += val\\n            if large_part > all_sum - large_part:\\n                return nums[:i+1]\\n```\\n\\n### Counting Sort\\n\\nS: O(101) -> O(1)\\nT: O(101) -> O(1) without couting the result\\n\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n\\t    # the num range is 1 ~ 100, so that we can directly use the num as index\\n        counter = [0 for _ in range(101)]\\n        all_sum = 0\\n        \\n        for num in nums:\\n            all_sum += num\\n            counter[num] += 1\\n        \\n        large_part = 0\\n        result = []\\n        for i in reversed(range(1, 101)):\\n            while counter[i] > 0 and large_part <= all_sum - large_part:\\n                counter[i] -= 1\\n                large_part += i\\n                result.append(i)\\n        return result\\n```\\n\\n### Priority Queue/Heap\\n\\nInspired by [votrubac\\'s priority queue solution]( https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/discuss/564289/C%2B%2BJava-Priority-Queue), but I optimized it to O(1) by summing the small part with min heap of python, after reaching small_part > all_sum - small_part, it\\'s time to extract the large_part as normal. \\n\\nT: O(nlogn)\\nS: O(1) without couting the result list\\n\\n```\\n        heapify(nums)\\n        all_sum = sum(nums)\\n        small_part = 0\\n        \\n        while small_part < all_sum - small_part:\\n            min_val = heappop(nums)\\n            small_part += min_val\\n        \\n        result = deque([min_val])\\n        \\n        while nums:\\n            result.appendleft(heappop(nums))\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        \\n        all_sum = sum(nums)\\n        nums.sort(reverse=True)\\n        \\n        large_part = 0\\n        for i, val in enumerate(nums):\\n            large_part += val\\n            if large_part > all_sum - large_part:\\n                return nums[:i+1]\\n```\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n\\t    # the num range is 1 ~ 100, so that we can directly use the num as index\\n        counter = [0 for _ in range(101)]\\n        all_sum = 0\\n        \\n        for num in nums:\\n            all_sum += num\\n            counter[num] += 1\\n        \\n        large_part = 0\\n        result = []\\n        for i in reversed(range(1, 101)):\\n            while counter[i] > 0 and large_part <= all_sum - large_part:\\n                counter[i] -= 1\\n                large_part += i\\n                result.append(i)\\n        return result\\n```\n```\\n        heapify(nums)\\n        all_sum = sum(nums)\\n        small_part = 0\\n        \\n        while small_part < all_sum - small_part:\\n            min_val = heappop(nums)\\n            small_part += min_val\\n        \\n        result = deque([min_val])\\n        \\n        while nums:\\n            result.appendleft(heappop(nums))\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565494,
                "title": "python-max-heap",
                "content": "```python\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        res, nums  = [], list(map(self.changeSign, nums))\\n        \\n        heapify(nums)\\n        \\n        while nums:\\n            res.append(-heappop(nums))    \\n            if sum(res) > -sum(nums): return res\\n        \\n        return res\\n    \\n    def changeSign(self, n):\\n        return -n\\n```\\n\\n**Time**: `O(n*log(n))`\\n**Space**: `O(1)`",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        res, nums  = [], list(map(self.changeSign, nums))\\n        \\n        heapify(nums)\\n        \\n        while nums:\\n            res.append(-heappop(nums))    \\n            if sum(res) > -sum(nums): return res\\n        \\n        return res\\n    \\n    def changeSign(self, n):\\n        return -n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565229,
                "title": "using-sort-fully-explained-solution",
                "content": "\\nTime Complexity:-O(nlog(n)).\\nSpace Complexity:-O(n).\\n\\nApproach:-\\nInitially we will sort the array and define a vector named A. Now we will first calculate the sum of whole array and than \\nitterate the whole loop from the rear side and also updatig the value of temp. The loop runs untill temp<=sum/2 or i>=0.\\n\\nActually what happens with itterating the loop from rear side is that when we itterate the loop from rear side we are \\nconsidering the maximun values hence we can say that we can reach the target condition in less amount of time and also \\nby taking less number of variables.\\n\\nNow as loop runs we keep on updating the value of temp by just adding nums[i] to it and also adding nums[i] to the vector A.\\nAt last we return the vector A which represents the output result what we want.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        vector<int> A;\\n        sort(nums.begin(),nums.end());\\n        \\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            sum+=nums[i];\\n        \\n        int temp=0;\\n        for(int i=nums.size()-1;i>=0&&temp<=sum/2;i--)\\n        {\\n            A.push_back(nums[i]);\\n            temp+=nums[i];\\n        }\\n        \\n        return A;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        vector<int> A;\\n        sort(nums.begin(),nums.end());\\n        \\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            sum+=nums[i];\\n        \\n        int temp=0;\\n        for(int i=nums.size()-1;i>=0&&temp<=sum/2;i--)\\n        {\\n            A.push_back(nums[i]);\\n            temp+=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 564479,
                "title": "c-o-nlong-time-o-n-space-using-prefix-sum",
                "content": "vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int prefixSum[nums.size()];\\n        int k=0;\\n        prefixSum[k] = nums[nums.size()-1]; \\n \\n        for (int i = nums.size()-2; i >=0; i--) \\n        {\\n            k++;\\n            prefixSum[k] = prefixSum[k-1] + nums[i];\\n        }\\n        int sum=0;\\n        vector<int>v;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(sum<=prefixSum[nums.size()-1-i]) \\n            {\\n                sum+=nums[i];\\n                 v.push_back(nums[i]);\\n            }\\n            \\n        }\\n      return v;\\n    }",
                "solutionTags": [],
                "code": "vector<int> minSubsequence(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int prefixSum[nums.size()];\\n        int k=0;\\n        prefixSum[k] = nums[nums.size()-1]; \\n \\n        for (int i = nums.size()-2; i >=0; i--) \\n        {\\n            k++;\\n            prefixSum[k] = prefixSum[k-1] + nums[i];\\n        }\\n        int sum=0;\\n        vector<int>v;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(sum<=prefixSum[nums.size()-1-i]) \\n            {\\n                sum+=nums[i];\\n                 v.push_back(nums[i]);\\n            }\\n            \\n        }\\n      return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 564446,
                "title": "java-solution-using-heap",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>();\\n        for(int x:nums)\\n            q.add(x);\\n        int sum = Arrays.stream(nums).sum();\\n        int remove = 0;\\n        while(sum > remove && !q.isEmpty()){\\n            int x = q.peek();\\n            if((sum - x) > (remove + x)){\\n                remove += x;\\n                sum -= x;\\n                q.poll();\\n            }\\n            else \\n                break;\\n        }\\n        List<Integer> a = new ArrayList<>(q);\\n        Collections.sort(a,(x,y) -> y - x);\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>();\\n        for(int x:nums)\\n            q.add(x);\\n        int sum = Arrays.stream(nums).sum();\\n        int remove = 0;\\n        while(sum > remove && !q.isEmpty()){\\n            int x = q.peek();\\n            if((sum - x) > (remove + x)){\\n                remove += x;\\n                sum -= x;\\n                q.poll();\\n            }\\n            else \\n                break;\\n        }\\n        List<Integer> a = new ArrayList<>(q);\\n        Collections.sort(a,(x,y) -> y - x);\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564388,
                "title": "java-easy-solution-using-sort-3-ms-beats-100",
                "content": "1. Sort the array. \\n2. Initially, sum = sum of all elements in array, greaterSum = 0.\\n3. Traverse the array in reverse order (largest element to smallest element) and do:\\n\\t- add the element to greaterSum\\n\\t- subtract element from sum\\n\\t- add element to result\\n4. If greaterSum becomes larger than sum, then stop and return the result list.\\n\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        \\n        if(nums.length == 1)    \\n            return new ArrayList<>(Arrays.asList(nums[0]));\\n\\n        List<Integer> res = new ArrayList<>();\\n        \\n        Arrays.sort(nums);\\n        int sum = 0, greaterSum = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) \\n            sum += nums[i];                               \\n        \\n        int i = nums.length - 1;\\n        while(greaterSum <= sum) {\\n            greaterSum += nums[i];\\n            res.add(nums[i]);\\n            sum -= nums[i];\\n            --i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        \\n        if(nums.length == 1)    \\n            return new ArrayList<>(Arrays.asList(nums[0]));\\n\\n        List<Integer> res = new ArrayList<>();\\n        \\n        Arrays.sort(nums);\\n        int sum = 0, greaterSum = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) \\n            sum += nums[i];                               \\n        \\n        int i = nums.length - 1;\\n        while(greaterSum <= sum) {\\n            greaterSum += nums[i];\\n            res.add(nums[i]);\\n            sum -= nums[i];\\n            --i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564374,
                "title": "javascript-o-nlogn-o-1-space",
                "content": "```javascript\\nconst minSubsequence = (n) => {\\n    const nums = n.sort((a, b) => a - b);\\n    let left = nums.reduce((a, c) => a + c);\\n    let right = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n    \\tleft -= nums[i];\\n        right += nums[i];\\n        \\n        if (left < right) {\\n            return nums.splice(i).sort((a, b) => b - a);\\n        }\\n    }\\n    \\n    return [];\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst minSubsequence = (n) => {\\n    const nums = n.sort((a, b) => a - b);\\n    let left = nums.reduce((a, c) => a + c);\\n    let right = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n    \\tleft -= nums[i];\\n        right += nums[i];\\n        \\n        if (left < right) {\\n            return nums.splice(i).sort((a, b) => b - a);\\n        }\\n    }\\n    \\n    return [];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564301,
                "title": "java-short-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = 0, sum = 0;\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i = 0; i < n; i++) sum += nums[i];\\n        for(int i = n - 1; i >= 0; i--) {\\n            ans += nums[i];\\n            arr.add(nums[i]);\\n            if(ans > sum - ans) return arr;\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = 0, sum = 0;\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i = 0; i < n; i++) sum += nums[i];\\n        for(int i = n - 1; i >= 0; i--) {\\n            ans += nums[i];\\n            arr.add(nums[i]);\\n            if(ans > sum - ans) return arr;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 564284,
                "title": "python3-straightforward-track-sum",
                "content": "```python\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        if len(nums) < 2:\\n            return nums\\n        nums.sort(reverse=True)\\n        total, s = sum(nums), 0\\n        ans = []\\n        i=0\\n        while i<len(nums) and s <= total:\\n            s += nums[i]\\n            total -= nums[i]\\n            ans.append(nums[i])\\n            i += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        if len(nums) < 2:\\n            return nums\\n        nums.sort(reverse=True)\\n        total, s = sum(nums), 0\\n        ans = []\\n        i=0\\n        while i<len(nums) and s <= total:\\n            s += nums[i]\\n            total -= nums[i]\\n            ans.append(nums[i])\\n            i += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089090,
                "title": "golang-implementation-with-explanations-ready-to-be-used-in-interviews",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSince we need to find a sequence whose sum is greater than the sum of all numbers, we should first sort the array in descending order.\\n\\nIt is also necessary to know the sum of the array numbers. This will have to be calculated using a loop.\\n\\nAfter that, you can easily calculate the sequence in the loop.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe function starts by sorting the nums array in descending order using `sort` package. This step ensures that the largest numbers are at the beginning of the sorted array.\\n\\nIt calculates the total sum of all elements in the nums array by iterating through it.\\n\\nThe function then iterates through the sorted nums array in descending order. For each element in the sorted array, it appends that element to the result subsequence and updates `currentSum` by adding the current element to it. The function checks whether the sum of the remaining elements (i.e., `totalSum` - `currentSum`) is less than the `currentSum`.\\nIf this condition is met, it means that continuing to add smaller elements to the subsequence would not satisfy the condition of having the sum of the subsequence greater than the sum of the remaining elements.\\n\\n# Complexity\\n- Time complexity: $O(n*log(n))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minSubsequence(nums []int) []int {\\n    sort.Sort(sort.Reverse(sort.IntSlice(nums)))\\n\\n    totalSum := 0\\n    for _, n := range nums {\\n        totalSum += n\\n    }\\n\\n    currentSum := 0\\n    result := []int{}\\n    \\n    for _, n := range nums {\\n        result = append(result, n)\\n        currentSum += n\\n\\n        if totalSum - currentSum < currentSum {\\n            break\\n        }\\n    }\\n\\n    return result\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minSubsequence(nums []int) []int {\\n    sort.Sort(sort.Reverse(sort.IntSlice(nums)))\\n\\n    totalSum := 0\\n    for _, n := range nums {\\n        totalSum += n\\n    }\\n\\n    currentSum := 0\\n    result := []int{}\\n    \\n    for _, n := range nums {\\n        result = append(result, n)\\n        currentSum += n\\n\\n        if totalSum - currentSum < currentSum {\\n            break\\n        }\\n    }\\n\\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083342,
                "title": "solution-using-bucket-sort-by-radix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*digit)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\n\\n/*\\n * Bucket Sort \\n * Using Radix\\n *\\n *\\n*/\\n\\nclass RadixSort {\\npublic:\\n   vector<int> tempArr;\\nvoid sort(vector<int>& arr){\\n\\n\\tint sizeOfTheArr = arr.size();\\n\\n\\ttempArr.resize(sizeOfTheArr,0);\\n\\n\\tint maxElem = INT_MIN;\\n\\n\\n\\tfor (int i = 0; i < sizeOfTheArr; ++i)\\n\\t{\\n\\t\\tif(arr[i] > maxElem){\\n\\t\\t\\tmaxElem = arr[i];\\n\\t\\t}\\n\\t}\\n\\tint digitCount = log10(maxElem)+1;\\n\\n\\n\\tint div = 1;\\n\\n\\tfor (int i = 0; i < digitCount; ++i)\\n\\t{\\n\\t\\tsubSort(arr,sizeOfTheArr,div);\\n\\t\\tdiv *= 10;\\n\\t}\\n\\n}\\n\\n\\nvoid subSort(vector<int>&  arr,int inputSize,int dividend){\\n\\n\\tvector<int> decimalArr(10,0);\\n\\n\\tfill(tempArr.begin(),tempArr.end(),0);\\n\\n\\tfor (int i = 0; i < inputSize; ++i)\\n\\t{\\n\\t\\tdecimalArr[(arr[i] / dividend) % 10]++;\\n\\t}\\n\\n\\tfor (int i = 1; i < 10; ++i)\\n\\t{\\n\\t\\tdecimalArr[i] += decimalArr[i-1]; \\n\\t}\\n\\n\\tfor (int i = inputSize-1; i >= 0; --i)\\n\\t{\\n\\t\\ttempArr[decimalArr[(arr[i] / dividend) % 10]-1] = arr[i];\\n\\n\\t\\tdecimalArr[(arr[i] / dividend) % 10]--;\\n\\t}\\n\\t\\t\\n\\tfor (int i = 0; i < tempArr.size(); ++i)\\n\\t{\\n\\t\\tarr[i] = tempArr[i];\\n\\t}\\n\\n}\\n\\n\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n\\n\\n        RadixSort rd_sort;\\n\\n    \\tint sumOfAllElements = 0;\\n\\n    \\tfor (int i = 0; i < nums.size(); ++i)\\n    \\t{\\n    \\t\\tsumOfAllElements += nums[i];\\n    \\t}\\n\\n    \\t\\n        rd_sort.sort(nums);\\n\\t    \\n\\t    int target = (sumOfAllElements / 2 ) + 1;\\n\\n        int temp = 0;\\n\\t    \\n\\t    vector<int> ans;\\n\\n        int index = nums.size()-1;\\n\\nwhile(temp < target){\\ntemp += nums[index];\\nans.push_back(nums[index]);\\nindex--;\\n\\n\\n}\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\n\\n/*\\n * Bucket Sort \\n * Using Radix\\n *\\n *\\n*/\\n\\nclass RadixSort {\\npublic:\\n   vector<int> tempArr;\\nvoid sort(vector<int>& arr){\\n\\n\\tint sizeOfTheArr = arr.size();\\n\\n\\ttempArr.resize(sizeOfTheArr,0);\\n\\n\\tint maxElem = INT_MIN;\\n\\n\\n\\tfor (int i = 0; i < sizeOfTheArr; ++i)\\n\\t{\\n\\t\\tif(arr[i] > maxElem){\\n\\t\\t\\tmaxElem = arr[i];\\n\\t\\t}\\n\\t}\\n\\tint digitCount = log10(maxElem)+1;\\n\\n\\n\\tint div = 1;\\n\\n\\tfor (int i = 0; i < digitCount; ++i)\\n\\t{\\n\\t\\tsubSort(arr,sizeOfTheArr,div);\\n\\t\\tdiv *= 10;\\n\\t}\\n\\n}\\n\\n\\nvoid subSort(vector<int>&  arr,int inputSize,int dividend){\\n\\n\\tvector<int> decimalArr(10,0);\\n\\n\\tfill(tempArr.begin(),tempArr.end(),0);\\n\\n\\tfor (int i = 0; i < inputSize; ++i)\\n\\t{\\n\\t\\tdecimalArr[(arr[i] / dividend) % 10]++;\\n\\t}\\n\\n\\tfor (int i = 1; i < 10; ++i)\\n\\t{\\n\\t\\tdecimalArr[i] += decimalArr[i-1]; \\n\\t}\\n\\n\\tfor (int i = inputSize-1; i >= 0; --i)\\n\\t{\\n\\t\\ttempArr[decimalArr[(arr[i] / dividend) % 10]-1] = arr[i];\\n\\n\\t\\tdecimalArr[(arr[i] / dividend) % 10]--;\\n\\t}\\n\\t\\t\\n\\tfor (int i = 0; i < tempArr.size(); ++i)\\n\\t{\\n\\t\\tarr[i] = tempArr[i];\\n\\t}\\n\\n}\\n\\n\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n\\n\\n        RadixSort rd_sort;\\n\\n    \\tint sumOfAllElements = 0;\\n\\n    \\tfor (int i = 0; i < nums.size(); ++i)\\n    \\t{\\n    \\t\\tsumOfAllElements += nums[i];\\n    \\t}\\n\\n    \\t\\n        rd_sort.sort(nums);\\n\\t    \\n\\t    int target = (sumOfAllElements / 2 ) + 1;\\n\\n        int temp = 0;\\n\\t    \\n\\t    vector<int> ans;\\n\\n        int index = nums.size()-1;\\n\\nwhile(temp < target){\\ntemp += nums[index];\\nans.push_back(nums[index]);\\nindex--;\\n\\n\\n}\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080697,
                "title": "simple-and-best-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        vector<int> ans;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int diff=0;\\n        for(int i=0;i<nums.size();i++){\\n            diff=diff+nums[i];\\n            sum=sum-nums[i];\\n            if(diff<=sum){\\n                ans.push_back(nums[i]);\\n            }\\n            else{\\n                ans.push_back(nums[i]);\\n                break;\\n            }\\n            // else{\\n            //     break;\\n            // }\\n           // sum=sum-nums[i];\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        vector<int> ans;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        int diff=0;\\n        for(int i=0;i<nums.size();i++){\\n            diff=diff+nums[i];\\n            sum=sum-nums[i];\\n            if(diff<=sum){\\n                ans.push_back(nums[i]);\\n            }\\n            else{\\n                ans.push_back(nums[i]);\\n                break;\\n            }\\n            // else{\\n            //     break;\\n            // }\\n           // sum=sum-nums[i];\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078598,
                "title": "swift-simple-solution-memory-usage-less-then-100-faster-then-70",
                "content": "\\n# Approach\\nwe are simply taking middle position of array, then we sort it to divide larger and smaller values, then in repeat while loop we check if sum of larger values is more then sum of lower values we set array with sub range as a result then we double check if next subranges are better fit or not and return the reversed result. In fact we have really fast implementation( faster then 70%) and mostly the best possible memory usage( less then 100% )\\n\\n# Complexity\\nO(log(n)) -> please let me know if I am wrong\\n\\n# Code\\n```\\nclass Solution {\\n    func minSubsequence(_ nums: [Int]) -> [Int] {\\n        guard nums.count > 2 else {\\n            var array = nums.sorted(by: >)\\n            if array.count > 1 && array[array.startIndex] != array[array.count-1] {\\n                array.removeLast()\\n            }\\n            return array\\n        }\\n        var mid: Int = (nums.count)/2 - 1\\n        var biggerSum = 0\\n        var smallerSum = 0\\n        let array = nums.sorted()\\n        var result: [Int] = []\\n        repeat {\\n            biggerSum = array[mid+1..<array.endIndex].reduce(0, +)\\n            smallerSum = array[array.startIndex...mid].reduce(0, +)\\n            if biggerSum > smallerSum {\\n                result = Array(array[mid+1..<array.endIndex])\\n            }\\n            mid += 1\\n            let nextLargeSum = array[mid+1..<array.endIndex].reduce(0, +)\\n            let nextSmallSum = array[array.startIndex...mid].reduce(0, +)\\n            if nextLargeSum > nextSmallSum {\\n                result = Array(array[mid+1..<array.endIndex])\\n                biggerSum = 0\\n                smallerSum = 0\\n            }\\n                \\n        } while biggerSum <= smallerSum\\n        return result.reversed()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minSubsequence(_ nums: [Int]) -> [Int] {\\n        guard nums.count > 2 else {\\n            var array = nums.sorted(by: >)\\n            if array.count > 1 && array[array.startIndex] != array[array.count-1] {\\n                array.removeLast()\\n            }\\n            return array\\n        }\\n        var mid: Int = (nums.count)/2 - 1\\n        var biggerSum = 0\\n        var smallerSum = 0\\n        let array = nums.sorted()\\n        var result: [Int] = []\\n        repeat {\\n            biggerSum = array[mid+1..<array.endIndex].reduce(0, +)\\n            smallerSum = array[array.startIndex...mid].reduce(0, +)\\n            if biggerSum > smallerSum {\\n                result = Array(array[mid+1..<array.endIndex])\\n            }\\n            mid += 1\\n            let nextLargeSum = array[mid+1..<array.endIndex].reduce(0, +)\\n            let nextSmallSum = array[array.startIndex...mid].reduce(0, +)\\n            if nextLargeSum > nextSmallSum {\\n                result = Array(array[mid+1..<array.endIndex])\\n                biggerSum = 0\\n                smallerSum = 0\\n            }\\n                \\n        } while biggerSum <= smallerSum\\n        return result.reversed()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074620,
                "title": "java-easy-optimized-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n       List<Integer> output = new ArrayList<>();\\n       Arrays.sort(nums);\\n       int totalSum = 0;\\n\\n       for(int i = 0; i < nums.length; i++) {\\n           totalSum += nums[i];\\n       } \\n\\n        int subSum = 0;\\n        for(int i = nums.length - 1; i >= 0; i--) {\\n            subSum += nums[i];\\n            output.add(nums[i]);\\n            if(subSum > totalSum - subSum) {\\n                break;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n       List<Integer> output = new ArrayList<>();\\n       Arrays.sort(nums);\\n       int totalSum = 0;\\n\\n       for(int i = 0; i < nums.length; i++) {\\n           totalSum += nums[i];\\n       } \\n\\n        int subSum = 0;\\n        for(int i = nums.length - 1; i >= 0; i--) {\\n            subSum += nums[i];\\n            output.add(nums[i]);\\n            if(subSum > totalSum - subSum) {\\n                break;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072655,
                "title": "2-pointer-approach-to-solve-this-loop-s-once",
                "content": "# Intuition\\nThe problem requires finding a minimum-length subsequence from the given nums array such that the sum of its elements is strictly greater than the sum of the remaining elements in the array. To achieve this, we should aim to select the largest elements from the nums array for the subsequence.\\n\\n\\n\\n# Approach\\n1. Sort the nums array in non-decreasing order. This way, the largest elements will be at the end of the sorted array.\\n2. Initialize two pointers, left and right, at the beginning and end of the sorted array, respectively.\\n3. Initialize two variables, sub_sum to keep track of the sum of elements in the subsequence and sub_seq_sum to keep track of the sum of elements in the subsequence itself. Initially, both sub_sum and sub_seq_sum are set to 0.\\n4. Start a while loop with the condition that left is less than or equal to right. Inside the loop:\\na. Add the element at the left pointer to sub_sum.\\nb. While left is less than or equal to right and sub_sum is greater than or equal to sub_seq_sum, add the element at the right pointer to the sub_seq and increment sub_seq_sum by the element\\'s value. Then, decrement right by 1. This step ensures that we are building a subsequence with elements that have a sum greater than the remaining elements.\\nc. Increment left by 1 to consider the next element in the sorted array.\\nFinally, return the sub_seq as the minimum-length subsequence that meets the criteria.\\n\\n# Complexity\\n- Time complexity:\\n    -  Sorting the nums array takes O(n log n) time, and the while loop iterates at most n times, so the overall time complexity is O(n log n).\\n- Space complexity:\\n    -  We use additional space to store the sub_seq, which can have a maximum of n/2 elements (when all elements are distinct). Therefore, the space complexity is O(n).\\n# Code\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        left = 0\\n        right = len(nums)-1\\n        sub_sum = 0\\n        sub_seq = []\\n        sub_seq_sum = 0\\n        while left<=right:\\n            sub_sum +=nums[left]\\n            while left<=right and sub_sum>=sub_seq_sum:\\n                sub_seq.append(nums[right])\\n                sub_seq_sum+=nums[right]\\n                right -=1\\n            left+=1\\n        return sub_seq\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        left = 0\\n        right = len(nums)-1\\n        sub_sum = 0\\n        sub_seq = []\\n        sub_seq_sum = 0\\n        while left<=right:\\n            sub_sum +=nums[left]\\n            while left<=right and sub_sum>=sub_seq_sum:\\n                sub_seq.append(nums[right])\\n                sub_seq_sum+=nums[right]\\n                right -=1\\n            left+=1\\n        return sub_seq\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071351,
                "title": "1403",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            sum += nums[i]; \\n        }\\n        int ans = 0;\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = nums.length-1;i>=0;i--){\\n            if(ans > sum){\\n                break;\\n            }\\n            ans += nums[i];\\n            list.add(nums[i]);\\n            sum -= nums[i];\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            sum += nums[i]; \\n        }\\n        int ans = 0;\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = nums.length-1;i>=0;i--){\\n            if(ans > sum){\\n                break;\\n            }\\n            ans += nums[i];\\n            list.add(nums[i]);\\n            sum -= nums[i];\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067763,
                "title": "basic-c-solution-greedy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        vector<int> res;\\n        int sum1=0, sum2=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n           sum1 += nums[i];\\n           for(int j = i+1; j<nums.size(); j++)\\n           {\\n           sum2 += nums[j];\\n           }\\n           res.push_back(nums[i]);\\n           if(sum1 <= sum2)   sum2 = 0;\\n           else break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        vector<int> res;\\n        int sum1=0, sum2=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n           sum1 += nums[i];\\n           for(int j = i+1; j<nums.size(); j++)\\n           {\\n           sum2 += nums[j];\\n           }\\n           res.push_back(nums[i]);\\n           if(sum1 <= sum2)   sum2 = 0;\\n           else break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064141,
                "title": "simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minSubsequence(_ nums: [Int]) -> [Int] {\\n    var sum = nums.reduce(0, +)\\n    var sn = nums.sorted(by: >)\\n    var ans = [Int]()\\n    \\n    for i in sn {\\n        if sum >= 0 {\\n            ans.append(i)\\n            sum -= 2 * i\\n        }\\n    }\\n    \\n    return ans\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minSubsequence(_ nums: [Int]) -> [Int] {\\n    var sum = nums.reduce(0, +)\\n    var sn = nums.sorted(by: >)\\n    var ans = [Int]()\\n    \\n    for i in sn {\\n        if sum >= 0 {\\n            ans.append(i)\\n            sum -= 2 * i\\n        }\\n    }\\n    \\n    return ans\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059176,
                "title": "neat-swift-solution",
                "content": "# Approach\\nForm an array by appending the first element of reverse-sorted input array until it\\'s sum is greater than the half-sum of all elements.\\n\\n# Code\\n```\\nclass Solution {\\n  func minSubsequence(_ nums: [Int]) -> [Int] {\\n\\t\\tlet halfSum = nums.reduce(0, +) / 2\\n\\t\\tvar numsSorted = nums.sorted(by: >)\\n\\t\\tvar res = [numsSorted.removeFirst()]\\n\\n\\t\\twhile res.reduce(0, +) <= halfSum {\\n\\t\\t\\tres.append(numsSorted.removeFirst())\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n  func minSubsequence(_ nums: [Int]) -> [Int] {\\n\\t\\tlet halfSum = nums.reduce(0, +) / 2\\n\\t\\tvar numsSorted = nums.sorted(by: >)\\n\\t\\tvar res = [numsSorted.removeFirst()]\\n\\n\\t\\twhile res.reduce(0, +) <= halfSum {\\n\\t\\t\\tres.append(numsSorted.removeFirst())\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027851,
                "title": "o-n-log-n-runtime-and-o-1-memory-beats-100-runtime-and-memory-lots-of-comments",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef min_subsequence(nums)\\n\\n    # Sort array in descending order.\\n    nums.sort!{|a, b| b<=>a}\\n\\n    # Set right pointer for our max array to first index.\\n    max_array_index_r = 0\\n    # Set max array total to value of nums\\n    max_array_total = nums[0]\\n    # Set the total of all other items to sum of array minus first value.\\n    other_items_total = nums[1..-1].sum \\n\\n    # Keep increasting max_array_index_r and updating max array total and other items total \\n    # till max array total exceeds other items total.\\n    while max_array_total <= other_items_total\\n        max_array_index_r = max_array_index_r + 1\\n        max_array_total = max_array_total + nums[max_array_index_r]\\n        other_items_total = other_items_total - nums[max_array_index_r]\\n    end\\n    \\n    # Return nums to max_array_index_r\\n    nums[0..max_array_index_r]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef min_subsequence(nums)\\n\\n    # Sort array in descending order.\\n    nums.sort!{|a, b| b<=>a}\\n\\n    # Set right pointer for our max array to first index.\\n    max_array_index_r = 0\\n    # Set max array total to value of nums\\n    max_array_total = nums[0]\\n    # Set the total of all other items to sum of array minus first value.\\n    other_items_total = nums[1..-1].sum \\n\\n    # Keep increasting max_array_index_r and updating max array total and other items total \\n    # till max array total exceeds other items total.\\n    while max_array_total <= other_items_total\\n        max_array_index_r = max_array_index_r + 1\\n        max_array_total = max_array_total + nums[max_array_index_r]\\n        other_items_total = other_items_total - nums[max_array_index_r]\\n    end\\n    \\n    # Return nums to max_array_index_r\\n    nums[0..max_array_index_r]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4027580,
                "title": "python-easy-to-understand-beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        sum=0\\n        for num in nums:\\n            sum +=num\\n        x=0\\n        ans=[]\\n        nums.sort(reverse=True)\\n        for num in nums:\\n            x +=num\\n            ans.append(num)\\n            if x > sum-x:\\n                break;\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        sum=0\\n        for num in nums:\\n            sum +=num\\n        x=0\\n        ans=[]\\n        nums.sort(reverse=True)\\n        for num in nums:\\n            x +=num\\n            ans.append(num)\\n            if x > sum-x:\\n                break;\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025785,
                "title": "simple-solution-using-reverse-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust reverse sorting and then checking for each included value if the curr_sum > total_sum-curr_sum (strictly greater or not) ,, if yes then we can simply say we have our and and break out of the loop else keep pushing the remaining nums.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n$$O(NlogN)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        vector<int> res;\\n        int n = nums.size();\\n\\n        sort(nums.rbegin(),nums.rend());\\n\\n        int t_sum = 0;\\n\\n        for(int i=0;i<n;++i){\\n            t_sum += nums[i];\\n        }\\n\\n        int temp=0;\\n\\n        for(int i=0;i<n;++i){\\n            temp += nums[i];\\n            res.push_back(nums[i]);\\n            if(temp> t_sum-temp){\\n                break;\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        vector<int> res;\\n        int n = nums.size();\\n\\n        sort(nums.rbegin(),nums.rend());\\n\\n        int t_sum = 0;\\n\\n        for(int i=0;i<n;++i){\\n            t_sum += nums[i];\\n        }\\n\\n        int temp=0;\\n\\n        for(int i=0;i<n;++i){\\n            temp += nums[i];\\n            res.push_back(nums[i]);\\n            if(temp> t_sum-temp){\\n                break;\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023791,
                "title": "java-solution-by-a-beginner-learn-who-to-start-thinking-from-the-beginning",
                "content": "# Intuition\\nLook for the minimal effort on cpu so that you can find the best time complacity.\\n\\n# Approach\\nStart with the first largest element, check it if not sufficient then add more.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n       List<Integer> demo = new ArrayList<>();\\n    for (int num : nums) {\\n        demo.add(num);\\n    }\\n      Collections.sort(demo,(i,j)-> j-i);\\n     int sum  =  demo.stream().reduce(0,(i,j)-> i+j);\\n     int sum2=0;\\n     List<Integer> list = new ArrayList<>();\\n     for(int i = 0; i< demo.size(); i++){\\n         sum2 += demo.get(i);\\n         if(sum2>sum-sum2){\\n             list.add( demo.get(i));\\n           break;  \\n         }\\n         else{\\n             list.add( demo.get(i));\\n         }\\n     }\\n     return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n       List<Integer> demo = new ArrayList<>();\\n    for (int num : nums) {\\n        demo.add(num);\\n    }\\n      Collections.sort(demo,(i,j)-> j-i);\\n     int sum  =  demo.stream().reduce(0,(i,j)-> i+j);\\n     int sum2=0;\\n     List<Integer> list = new ArrayList<>();\\n     for(int i = 0; i< demo.size(); i++){\\n         sum2 += demo.get(i);\\n         if(sum2>sum-sum2){\\n             list.add( demo.get(i));\\n           break;  \\n         }\\n         else{\\n             list.add( demo.get(i));\\n         }\\n     }\\n     return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022541,
                "title": "beginner-friendly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        \\n        //Algorithm for finding minimum sequence in non increasing order\\n        Arrays.sort(nums);\\n        ArrayList<Integer>result=new ArrayList<>();\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n        int checkSum=0;\\n        int index=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            checkSum+=nums[i];\\n            if(checkSum>sum-checkSum){\\n                index=i;\\n                break;\\n            }\\n        }\\n\\n        for(int i=nums.length-1;i>=index;i--){\\n          result.add(nums[i]);\\n        }\\nreturn result;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        \\n        //Algorithm for finding minimum sequence in non increasing order\\n        Arrays.sort(nums);\\n        ArrayList<Integer>result=new ArrayList<>();\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n        int checkSum=0;\\n        int index=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            checkSum+=nums[i];\\n            if(checkSum>sum-checkSum){\\n                index=i;\\n                break;\\n            }\\n        }\\n\\n        for(int i=nums.length-1;i>=index;i--){\\n          result.add(nums[i]);\\n        }\\nreturn result;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018533,
                "title": "c-sorting-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int total_sum = accumulate(nums.begin(), nums.end(), 0);\\n\\n        sort(nums.begin(), nums.end(), greater<int>());\\n\\n        vector<int> subsequence;\\n        int count = 0;\\n        for(int &num : nums) {\\n            if(count > total_sum) \\n                break;\\n\\n            count += num;\\n            total_sum -= num;\\n            subsequence.push_back(num);\\n        }\\n\\n        return subsequence;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n        int total_sum = accumulate(nums.begin(), nums.end(), 0);\\n\\n        sort(nums.begin(), nums.end(), greater<int>());\\n\\n        vector<int> subsequence;\\n        int count = 0;\\n        for(int &num : nums) {\\n            if(count > total_sum) \\n                break;\\n\\n            count += num;\\n            total_sum -= num;\\n            subsequence.push_back(num);\\n        }\\n\\n        return subsequence;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018218,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int sum = 0, sum2=0;\\n        for(int i: nums){\\n            sum += i;\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        for(int i=nums.length-1; i>=0; i--){\\n            sum2 += nums[i];\\n            list.add(nums[i]);\\n            if(sum2>sum-sum2){\\n                break;\\n            }\\n\\n        }\\n        return list;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n        int sum = 0, sum2=0;\\n        for(int i: nums){\\n            sum += i;\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<>();\\n        for(int i=nums.length-1; i>=0; i--){\\n            sum2 += nums[i];\\n            list.add(nums[i]);\\n            if(sum2>sum-sum2){\\n                break;\\n            }\\n\\n        }\\n        return list;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011289,
                "title": "simple-solution-runtime-99",
                "content": "![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-09-06 \\u0432 21.58.48.png](https://assets.leetcode.com/users/images/5b3f0690-0fe2-49d6-a816-d061e094cdaa_1694026786.3811731.png)\\n\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse= True)\\n        sum_nums = sum(nums)\\n        for i, num in enumerate(nums):\\n            sum_nums -= num*2\\n            if sum_nums < 0:\\n                return nums[:i+1]     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        nums.sort(reverse= True)\\n        sum_nums = sum(nums)\\n        for i, num in enumerate(nums):\\n            sum_nums -= num*2\\n            if sum_nums < 0:\\n                return nums[:i+1]     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004577,
                "title": "c-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> MinSubsequence(int[] nums) {\\n    int total = nums.Sum(); \\n    Array.Sort(nums);\\n    List<int> result = new List<int>();\\n\\n    if (nums.Length == 1){\\n        result.Add(nums[0]);\\n        return result;\\n    }\\n\\n    for (int i = nums.Length - 1; i >= 0; i--)\\n    {\\n        if (result.Count == 0)\\n        {\\n            result.Add(nums[i]);\\n        }\\n\\n        if (total - result.Sum() < result.Sum())\\n        {\\n            return result;\\n        }\\n\\n        else\\n        {\\n            if (i >= 1)\\n            {\\n                result.Add(nums[i - 1]);\\n            }\\n\\n            if (total - result.Sum() < result.Sum())\\n            {\\n                return result;\\n            }\\n        }\\n    }\\n\\n    return result;   \\n    }   \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> MinSubsequence(int[] nums) {\\n    int total = nums.Sum(); \\n    Array.Sort(nums);\\n    List<int> result = new List<int>();\\n\\n    if (nums.Length == 1){\\n        result.Add(nums[0]);\\n        return result;\\n    }\\n\\n    for (int i = nums.Length - 1; i >= 0; i--)\\n    {\\n        if (result.Count == 0)\\n        {\\n            result.Add(nums[i]);\\n        }\\n\\n        if (total - result.Sum() < result.Sum())\\n        {\\n            return result;\\n        }\\n\\n        else\\n        {\\n            if (i >= 1)\\n            {\\n                result.Add(nums[i - 1]);\\n            }\\n\\n            if (total - result.Sum() < result.Sum())\\n            {\\n                return result;\\n            }\\n        }\\n    }\\n\\n    return result;   \\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998077,
                "title": "beats-86-79-js-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar minSubsequence = function(nums) {\\n    let sum = 0\\n    let sum1 = 0\\n    let count = 0\\n \\n    for(let i = 0; i < nums.length;i++) {\\n        sum += nums[i]\\n    }\\n    nums.sort((a,b) => b-a)\\n\\n    for(let j = 0;j < nums.length;j++) {\\n        sum1 += nums[j]\\n        count++\\n        if(sum1 > sum - sum1) {\\n            break\\n        }\\n    }\\n\\n    return nums.slice(0,count) \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar minSubsequence = function(nums) {\\n    let sum = 0\\n    let sum1 = 0\\n    let count = 0\\n \\n    for(let i = 0; i < nums.length;i++) {\\n        sum += nums[i]\\n    }\\n    nums.sort((a,b) => b-a)\\n\\n    for(let j = 0;j < nums.length;j++) {\\n        sum1 += nums[j]\\n        count++\\n        if(sum1 > sum - sum1) {\\n            break\\n        }\\n    }\\n\\n    return nums.slice(0,count) \\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565046,
                "content": [
                    {
                        "username": "ijaz20",
                        "content": "Subsquence means relative position of array shouldn\\'t be spoiled right?\\n\\nOr atleast add this example\\nInput:\\n[6,4,4,7,7]\\nOtput: \\n[7,7,6]"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The sum of the subsequence should be **strictly** greater:\\n7 + 7 = 14 and 6 + 4 + 4 = 14, so equal, the result is not good.\\n7 + 7 + 6 = 20 and 4 + 4 = 8 is good.\\n7 + 7 + 4 = 18 and 4 + 6 = 10 is not good, because the sum 18 is not the maximum sum, as you can see 20 is the maximum."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Yes... but this problem is strange. It asks for a subsequence, but at the end it then tells you to sort this subsequence. Which means it never needed to be a subsequence in the first place, we are rearranging its order anyhow. You can literally ignore the subsequence requirement. \\n\\nThis problem is much harder if we must keep the order of the subsequence AND it still has to be be monotonically non increasing order, yet of minimal size. It would no longer necessarily be just the largest numbers that make the condition true:\\n\\nIf your list was [4,4,7,6,7] per the example, [7,6,7] could NOT be the answer, as its not in non increasing order, nor could [7,7,6] as that is no longer a valid subsequence. "
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Consider the fact to return the subsequence with MINIMUM SIZE and MAXIMUM TOTAL SUM of all its elements, it is possible only with the subsequence of the biggest elements in the array and are to be arranged in non-increasing order.\\n\\n\\nSo, Sorting the given array `nums` in non increasing order first, will provide the required sequence in desired arrangement to be returned [non increasing order]. From there it\\'s just a matter of iteration from beginning the collecting the sum of the iterated values, `iterated_sum` simultaneously adding the iterated values in the answer array, `Ans` and returning it if `Ans.size()<=nums.size()/2 && ` `2*iterated_sum>Total_sum_of_elements_in_nums`"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "thx"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks for the tip! Made this question much easier."
                    },
                    {
                        "username": "developer25",
                        "content": "The title of the question is not accurate, it should be SEQUENCE instead of SUBSEQUENCE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "actually. \"subarray\". "
                    },
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/aa758302-2808-4ef1-aa76-e11a3d31d5b9_1598048453.6842115.png)\\n"
                    },
                    {
                        "username": "shadowion",
                        "content": "Really we\\'re returning a subset rather than a subsequence, given the non-increasing order rule"
                    },
                    {
                        "username": "shadowion",
                        "content": "Hence the flexibility with sorting / using a bucket sort, which removes the relative orderings of the elements. "
                    },
                    {
                        "username": "clmusket",
                        "content": "It says \"Note the subsequence has to be returned in non-decreasing order.\" but this is wrong because for inputs [4,3,10,9,8] the result [10,9] is accepted but non-decreasing [9,10] is not accepted."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "There\\'s still an error in the explanation of example 2\\'s output. It says \\'Note the subsequence has to be returned in non-decreasing order.\\'  You can infer from the outputs of both examples that they\\'re meant to be in non-increasing order, but it is confusing!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Says \"Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order\" now. Did it change?"
                    }
                ]
            },
            {
                "id": 1846177,
                "content": [
                    {
                        "username": "ijaz20",
                        "content": "Subsquence means relative position of array shouldn\\'t be spoiled right?\\n\\nOr atleast add this example\\nInput:\\n[6,4,4,7,7]\\nOtput: \\n[7,7,6]"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The sum of the subsequence should be **strictly** greater:\\n7 + 7 = 14 and 6 + 4 + 4 = 14, so equal, the result is not good.\\n7 + 7 + 6 = 20 and 4 + 4 = 8 is good.\\n7 + 7 + 4 = 18 and 4 + 6 = 10 is not good, because the sum 18 is not the maximum sum, as you can see 20 is the maximum."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Yes... but this problem is strange. It asks for a subsequence, but at the end it then tells you to sort this subsequence. Which means it never needed to be a subsequence in the first place, we are rearranging its order anyhow. You can literally ignore the subsequence requirement. \\n\\nThis problem is much harder if we must keep the order of the subsequence AND it still has to be be monotonically non increasing order, yet of minimal size. It would no longer necessarily be just the largest numbers that make the condition true:\\n\\nIf your list was [4,4,7,6,7] per the example, [7,6,7] could NOT be the answer, as its not in non increasing order, nor could [7,7,6] as that is no longer a valid subsequence. "
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Consider the fact to return the subsequence with MINIMUM SIZE and MAXIMUM TOTAL SUM of all its elements, it is possible only with the subsequence of the biggest elements in the array and are to be arranged in non-increasing order.\\n\\n\\nSo, Sorting the given array `nums` in non increasing order first, will provide the required sequence in desired arrangement to be returned [non increasing order]. From there it\\'s just a matter of iteration from beginning the collecting the sum of the iterated values, `iterated_sum` simultaneously adding the iterated values in the answer array, `Ans` and returning it if `Ans.size()<=nums.size()/2 && ` `2*iterated_sum>Total_sum_of_elements_in_nums`"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "thx"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks for the tip! Made this question much easier."
                    },
                    {
                        "username": "developer25",
                        "content": "The title of the question is not accurate, it should be SEQUENCE instead of SUBSEQUENCE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "actually. \"subarray\". "
                    },
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/aa758302-2808-4ef1-aa76-e11a3d31d5b9_1598048453.6842115.png)\\n"
                    },
                    {
                        "username": "shadowion",
                        "content": "Really we\\'re returning a subset rather than a subsequence, given the non-increasing order rule"
                    },
                    {
                        "username": "shadowion",
                        "content": "Hence the flexibility with sorting / using a bucket sort, which removes the relative orderings of the elements. "
                    },
                    {
                        "username": "clmusket",
                        "content": "It says \"Note the subsequence has to be returned in non-decreasing order.\" but this is wrong because for inputs [4,3,10,9,8] the result [10,9] is accepted but non-decreasing [9,10] is not accepted."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "There\\'s still an error in the explanation of example 2\\'s output. It says \\'Note the subsequence has to be returned in non-decreasing order.\\'  You can infer from the outputs of both examples that they\\'re meant to be in non-increasing order, but it is confusing!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Says \"Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order\" now. Did it change?"
                    }
                ]
            },
            {
                "id": 1575466,
                "content": [
                    {
                        "username": "ijaz20",
                        "content": "Subsquence means relative position of array shouldn\\'t be spoiled right?\\n\\nOr atleast add this example\\nInput:\\n[6,4,4,7,7]\\nOtput: \\n[7,7,6]"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The sum of the subsequence should be **strictly** greater:\\n7 + 7 = 14 and 6 + 4 + 4 = 14, so equal, the result is not good.\\n7 + 7 + 6 = 20 and 4 + 4 = 8 is good.\\n7 + 7 + 4 = 18 and 4 + 6 = 10 is not good, because the sum 18 is not the maximum sum, as you can see 20 is the maximum."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Yes... but this problem is strange. It asks for a subsequence, but at the end it then tells you to sort this subsequence. Which means it never needed to be a subsequence in the first place, we are rearranging its order anyhow. You can literally ignore the subsequence requirement. \\n\\nThis problem is much harder if we must keep the order of the subsequence AND it still has to be be monotonically non increasing order, yet of minimal size. It would no longer necessarily be just the largest numbers that make the condition true:\\n\\nIf your list was [4,4,7,6,7] per the example, [7,6,7] could NOT be the answer, as its not in non increasing order, nor could [7,7,6] as that is no longer a valid subsequence. "
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Consider the fact to return the subsequence with MINIMUM SIZE and MAXIMUM TOTAL SUM of all its elements, it is possible only with the subsequence of the biggest elements in the array and are to be arranged in non-increasing order.\\n\\n\\nSo, Sorting the given array `nums` in non increasing order first, will provide the required sequence in desired arrangement to be returned [non increasing order]. From there it\\'s just a matter of iteration from beginning the collecting the sum of the iterated values, `iterated_sum` simultaneously adding the iterated values in the answer array, `Ans` and returning it if `Ans.size()<=nums.size()/2 && ` `2*iterated_sum>Total_sum_of_elements_in_nums`"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "thx"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks for the tip! Made this question much easier."
                    },
                    {
                        "username": "developer25",
                        "content": "The title of the question is not accurate, it should be SEQUENCE instead of SUBSEQUENCE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "actually. \"subarray\". "
                    },
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/aa758302-2808-4ef1-aa76-e11a3d31d5b9_1598048453.6842115.png)\\n"
                    },
                    {
                        "username": "shadowion",
                        "content": "Really we\\'re returning a subset rather than a subsequence, given the non-increasing order rule"
                    },
                    {
                        "username": "shadowion",
                        "content": "Hence the flexibility with sorting / using a bucket sort, which removes the relative orderings of the elements. "
                    },
                    {
                        "username": "clmusket",
                        "content": "It says \"Note the subsequence has to be returned in non-decreasing order.\" but this is wrong because for inputs [4,3,10,9,8] the result [10,9] is accepted but non-decreasing [9,10] is not accepted."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "There\\'s still an error in the explanation of example 2\\'s output. It says \\'Note the subsequence has to be returned in non-decreasing order.\\'  You can infer from the outputs of both examples that they\\'re meant to be in non-increasing order, but it is confusing!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Says \"Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order\" now. Did it change?"
                    }
                ]
            },
            {
                "id": 1574256,
                "content": [
                    {
                        "username": "ijaz20",
                        "content": "Subsquence means relative position of array shouldn\\'t be spoiled right?\\n\\nOr atleast add this example\\nInput:\\n[6,4,4,7,7]\\nOtput: \\n[7,7,6]"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The sum of the subsequence should be **strictly** greater:\\n7 + 7 = 14 and 6 + 4 + 4 = 14, so equal, the result is not good.\\n7 + 7 + 6 = 20 and 4 + 4 = 8 is good.\\n7 + 7 + 4 = 18 and 4 + 6 = 10 is not good, because the sum 18 is not the maximum sum, as you can see 20 is the maximum."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Yes... but this problem is strange. It asks for a subsequence, but at the end it then tells you to sort this subsequence. Which means it never needed to be a subsequence in the first place, we are rearranging its order anyhow. You can literally ignore the subsequence requirement. \\n\\nThis problem is much harder if we must keep the order of the subsequence AND it still has to be be monotonically non increasing order, yet of minimal size. It would no longer necessarily be just the largest numbers that make the condition true:\\n\\nIf your list was [4,4,7,6,7] per the example, [7,6,7] could NOT be the answer, as its not in non increasing order, nor could [7,7,6] as that is no longer a valid subsequence. "
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Consider the fact to return the subsequence with MINIMUM SIZE and MAXIMUM TOTAL SUM of all its elements, it is possible only with the subsequence of the biggest elements in the array and are to be arranged in non-increasing order.\\n\\n\\nSo, Sorting the given array `nums` in non increasing order first, will provide the required sequence in desired arrangement to be returned [non increasing order]. From there it\\'s just a matter of iteration from beginning the collecting the sum of the iterated values, `iterated_sum` simultaneously adding the iterated values in the answer array, `Ans` and returning it if `Ans.size()<=nums.size()/2 && ` `2*iterated_sum>Total_sum_of_elements_in_nums`"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "thx"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks for the tip! Made this question much easier."
                    },
                    {
                        "username": "developer25",
                        "content": "The title of the question is not accurate, it should be SEQUENCE instead of SUBSEQUENCE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "actually. \"subarray\". "
                    },
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/aa758302-2808-4ef1-aa76-e11a3d31d5b9_1598048453.6842115.png)\\n"
                    },
                    {
                        "username": "shadowion",
                        "content": "Really we\\'re returning a subset rather than a subsequence, given the non-increasing order rule"
                    },
                    {
                        "username": "shadowion",
                        "content": "Hence the flexibility with sorting / using a bucket sort, which removes the relative orderings of the elements. "
                    },
                    {
                        "username": "clmusket",
                        "content": "It says \"Note the subsequence has to be returned in non-decreasing order.\" but this is wrong because for inputs [4,3,10,9,8] the result [10,9] is accepted but non-decreasing [9,10] is not accepted."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "There\\'s still an error in the explanation of example 2\\'s output. It says \\'Note the subsequence has to be returned in non-decreasing order.\\'  You can infer from the outputs of both examples that they\\'re meant to be in non-increasing order, but it is confusing!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Says \"Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order\" now. Did it change?"
                    }
                ]
            },
            {
                "id": 1889781,
                "content": [
                    {
                        "username": "ijaz20",
                        "content": "Subsquence means relative position of array shouldn\\'t be spoiled right?\\n\\nOr atleast add this example\\nInput:\\n[6,4,4,7,7]\\nOtput: \\n[7,7,6]"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The sum of the subsequence should be **strictly** greater:\\n7 + 7 = 14 and 6 + 4 + 4 = 14, so equal, the result is not good.\\n7 + 7 + 6 = 20 and 4 + 4 = 8 is good.\\n7 + 7 + 4 = 18 and 4 + 6 = 10 is not good, because the sum 18 is not the maximum sum, as you can see 20 is the maximum."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Yes... but this problem is strange. It asks for a subsequence, but at the end it then tells you to sort this subsequence. Which means it never needed to be a subsequence in the first place, we are rearranging its order anyhow. You can literally ignore the subsequence requirement. \\n\\nThis problem is much harder if we must keep the order of the subsequence AND it still has to be be monotonically non increasing order, yet of minimal size. It would no longer necessarily be just the largest numbers that make the condition true:\\n\\nIf your list was [4,4,7,6,7] per the example, [7,6,7] could NOT be the answer, as its not in non increasing order, nor could [7,7,6] as that is no longer a valid subsequence. "
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Consider the fact to return the subsequence with MINIMUM SIZE and MAXIMUM TOTAL SUM of all its elements, it is possible only with the subsequence of the biggest elements in the array and are to be arranged in non-increasing order.\\n\\n\\nSo, Sorting the given array `nums` in non increasing order first, will provide the required sequence in desired arrangement to be returned [non increasing order]. From there it\\'s just a matter of iteration from beginning the collecting the sum of the iterated values, `iterated_sum` simultaneously adding the iterated values in the answer array, `Ans` and returning it if `Ans.size()<=nums.size()/2 && ` `2*iterated_sum>Total_sum_of_elements_in_nums`"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "thx"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks for the tip! Made this question much easier."
                    },
                    {
                        "username": "developer25",
                        "content": "The title of the question is not accurate, it should be SEQUENCE instead of SUBSEQUENCE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "actually. \"subarray\". "
                    },
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/aa758302-2808-4ef1-aa76-e11a3d31d5b9_1598048453.6842115.png)\\n"
                    },
                    {
                        "username": "shadowion",
                        "content": "Really we\\'re returning a subset rather than a subsequence, given the non-increasing order rule"
                    },
                    {
                        "username": "shadowion",
                        "content": "Hence the flexibility with sorting / using a bucket sort, which removes the relative orderings of the elements. "
                    },
                    {
                        "username": "clmusket",
                        "content": "It says \"Note the subsequence has to be returned in non-decreasing order.\" but this is wrong because for inputs [4,3,10,9,8] the result [10,9] is accepted but non-decreasing [9,10] is not accepted."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "There\\'s still an error in the explanation of example 2\\'s output. It says \\'Note the subsequence has to be returned in non-decreasing order.\\'  You can infer from the outputs of both examples that they\\'re meant to be in non-increasing order, but it is confusing!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Says \"Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order\" now. Did it change?"
                    }
                ]
            },
            {
                "id": 1677983,
                "content": [
                    {
                        "username": "ijaz20",
                        "content": "Subsquence means relative position of array shouldn\\'t be spoiled right?\\n\\nOr atleast add this example\\nInput:\\n[6,4,4,7,7]\\nOtput: \\n[7,7,6]"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "The sum of the subsequence should be **strictly** greater:\\n7 + 7 = 14 and 6 + 4 + 4 = 14, so equal, the result is not good.\\n7 + 7 + 6 = 20 and 4 + 4 = 8 is good.\\n7 + 7 + 4 = 18 and 4 + 6 = 10 is not good, because the sum 18 is not the maximum sum, as you can see 20 is the maximum."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Yes... but this problem is strange. It asks for a subsequence, but at the end it then tells you to sort this subsequence. Which means it never needed to be a subsequence in the first place, we are rearranging its order anyhow. You can literally ignore the subsequence requirement. \\n\\nThis problem is much harder if we must keep the order of the subsequence AND it still has to be be monotonically non increasing order, yet of minimal size. It would no longer necessarily be just the largest numbers that make the condition true:\\n\\nIf your list was [4,4,7,6,7] per the example, [7,6,7] could NOT be the answer, as its not in non increasing order, nor could [7,7,6] as that is no longer a valid subsequence. "
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "Consider the fact to return the subsequence with MINIMUM SIZE and MAXIMUM TOTAL SUM of all its elements, it is possible only with the subsequence of the biggest elements in the array and are to be arranged in non-increasing order.\\n\\n\\nSo, Sorting the given array `nums` in non increasing order first, will provide the required sequence in desired arrangement to be returned [non increasing order]. From there it\\'s just a matter of iteration from beginning the collecting the sum of the iterated values, `iterated_sum` simultaneously adding the iterated values in the answer array, `Ans` and returning it if `Ans.size()<=nums.size()/2 && ` `2*iterated_sum>Total_sum_of_elements_in_nums`"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "thx"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks for the tip! Made this question much easier."
                    },
                    {
                        "username": "developer25",
                        "content": "The title of the question is not accurate, it should be SEQUENCE instead of SUBSEQUENCE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "actually. \"subarray\". "
                    },
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/aa758302-2808-4ef1-aa76-e11a3d31d5b9_1598048453.6842115.png)\\n"
                    },
                    {
                        "username": "shadowion",
                        "content": "Really we\\'re returning a subset rather than a subsequence, given the non-increasing order rule"
                    },
                    {
                        "username": "shadowion",
                        "content": "Hence the flexibility with sorting / using a bucket sort, which removes the relative orderings of the elements. "
                    },
                    {
                        "username": "clmusket",
                        "content": "It says \"Note the subsequence has to be returned in non-decreasing order.\" but this is wrong because for inputs [4,3,10,9,8] the result [10,9] is accepted but non-decreasing [9,10] is not accepted."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "There\\'s still an error in the explanation of example 2\\'s output. It says \\'Note the subsequence has to be returned in non-decreasing order.\\'  You can infer from the outputs of both examples that they\\'re meant to be in non-increasing order, but it is confusing!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Says \"Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order\" now. Did it change?"
                    }
                ]
            }
        ]
    }
]