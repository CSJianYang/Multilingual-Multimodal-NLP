[
    {
        "title": "Number of Even and Odd Bits",
        "question_content": "You are given a positive integer n.\nLet even denote the number of even indices in the binary representation of n (0-indexed) with value 1.\nLet odd denote the number of odd indices in the binary representation of n (0-indexed) with value 1.\nReturn an integer array answer where answer = [even, odd].\n&nbsp;\nExample 1:\n\nInput: n = 17\nOutput: [2,0]\nExplanation: The binary representation of 17 is 10001. \nIt contains 1 on the 0th and 4th indices. \nThere are 2 even and 0 odd indices.\n\nExample 2:\n\nInput: n = 2\nOutput: [0,1]\nExplanation: The binary representation of 2 is 10.\nIt contains 1 on the 1st index. \nThere are 0 even and 1 odd indices.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000",
        "solutions": [
            {
                "id": 3314042,
                "title": "one-liner",
                "content": "We can count each bit, which would make sense if we have a stream of bits.\\n\\nFor an integer, we can just mask old and even bits (using bitwise AND), and use `popcount` to count remaining bits.\\n\\n**Java**\\n```java\\npublic int[] evenOddBit(int n) {\\n    return new int[] {Integer.bitCount(n & 0b0101010101), \\n                      Integer.bitCount(n & 0b1010101010)};\\n}\\n```\\n**C++**\\n```cpp\\nvector<int> evenOddBit(int n) {\\n    return {__builtin_popcount(n & 0b0101010101), \\n            __builtin_popcount(n & 0b1010101010)};\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        return [(n & 0b10101010101).bit_count(), (n & 0b01010101010).bit_count()]\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\npublic int[] evenOddBit(int n) {\\n    return new int[] {Integer.bitCount(n & 0b0101010101), \\n                      Integer.bitCount(n & 0b1010101010)};\\n}\\n```\n```cpp\\nvector<int> evenOddBit(int n) {\\n    return {__builtin_popcount(n & 0b0101010101), \\n            __builtin_popcount(n & 0b1010101010)};\\n}\\n```\n```python\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        return [(n & 0b10101010101).bit_count(), (n & 0b01010101010).bit_count()]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314158,
                "title": "checking-each-bit-very-simple-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0, odd = 0;\\n        for(int i = 0; i < 32; ++i){\\n            if(n & (1 << i)){\\n                if(i%2) odd++;\\n                else even++;\\n            }\\n        }\\n        return {even, odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0, odd = 0;\\n        for(int i = 0; i < 32; ++i){\\n            if(n & (1 << i)){\\n                if(i%2) odd++;\\n                else even++;\\n            }\\n        }\\n        return {even, odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316362,
                "title": "easy-and-clean-java-solution-using-bitwise-operator-and-counting-bits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck the bits bitwise using right shift operator and count for corresponding bits at even and odd position.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake n1 for even count and n2 for odd count.\\nKeep a variable idx for index count.\\nif index is even, check if element at 0th position is 1, if yes, increment n1\\nSimilarly for n2\\nFinally, make an array for the counts and return\\nSimple!!!\\nReach out if you have doubts\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int n1 = 0;\\n        int n2 = 0;\\n        if(n == 0) return new int[]{0, 0};\\n        int idx = 0;\\n        \\n        while(n > 0) {\\n            if(idx % 2 == 0) {\\n                if((n & 1) == 1) n1++;\\n            }\\n            else {\\n                if((n & 1) == 1) n2++;\\n            }\\n            idx++;\\n            n = (n >> 1);\\n        }\\n        \\n        return new int[]{n1, n2};\\n    }\\n}\\n```\\n\\n  PLEASEEEE DO UPVOTE IF YOU LIKE IT!!!\\n  IT WOULD MAKE MY DAY! :)\\n![image.png](https://assets.leetcode.com/users/images/a765b813-28e9-4be0-ac86-11b9c4eb851c_1679703179.3775415.png)\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int n1 = 0;\\n        int n2 = 0;\\n        if(n == 0) return new int[]{0, 0};\\n        int idx = 0;\\n        \\n        while(n > 0) {\\n            if(idx % 2 == 0) {\\n                if((n & 1) == 1) n1++;\\n            }\\n            else {\\n                if((n & 1) == 1) n2++;\\n            }\\n            idx++;\\n            n = (n >> 1);\\n        }\\n        \\n        return new int[]{n1, n2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314182,
                "title": "easy-c-counting-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConstraints are low (max 10 bits) so just counted set bit even and odd bits\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialise the even , odd and bit count as 0.\\n2. Used while loop to count all even setbits and oddsetbits\\n3. return the ans.\\n# Complexity\\n- Time complexity: O(No of bits) here no of bits wll be always less than 11.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int a=0,b=0;\\n        int c=0;\\n        while(n>0)\\n        {\\n            if(c%2==0)\\n            {\\n                if(n%2==1)\\n                {\\n                    a++;\\n                }\\n            }\\n            else\\n            {\\n                if(n%2==1) b++;\\n            }\\n            n=n/2;\\n            c++;\\n            \\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int a=0,b=0;\\n        int c=0;\\n        while(n>0)\\n        {\\n            if(c%2==0)\\n            {\\n                if(n%2==1)\\n                {\\n                    a++;\\n                }\\n            }\\n            else\\n            {\\n                if(n%2==1) b++;\\n            }\\n            n=n/2;\\n            c++;\\n            \\n        }\\n        return {a,b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316862,
                "title": "python-3-2-lines-w-example-t-m-31-ms-13-8-mb",
                "content": "Here\\'s the code:\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:                 \\n        evens, odds = int(\\'0101010101\\',2), int(\\'1010101010\\',2)\\n\\n        return [(evens&n).bit_count(),(odds&n).bit_count()]\\n```\\nHere\\'s an example:\\n```\\n   Example:  n = 545 --> \\'0b1000100001\\'\\n\\n       n = 1000100001       n = 1000100001\\n   evens = 0101010101    odds = 1010101010\\n           \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013           \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n evens&n = 0000000001  odds&n = 1000100000\\n\\n                 return [1,2]\\n```\\n[https://leetcode.com/problems/number-of-even-and-odd-bits/submissions/918209401/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:                 \\n        evens, odds = int(\\'0101010101\\',2), int(\\'1010101010\\',2)\\n\\n        return [(evens&n).bit_count(),(odds&n).bit_count()]\\n```\n```\\n   Example:  n = 545 --> \\'0b1000100001\\'\\n\\n       n = 1000100001       n = 1000100001\\n   evens = 0101010101    odds = 1010101010\\n           \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013           \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n evens&n = 0000000001  odds&n = 1000100000\\n\\n                 return [1,2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314168,
                "title": "c-simple-and-easy-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int count=0;\\n        int evn=0;\\n        int odd=0;\\n        while(n)\\n        {\\n            \\n            if(n&1==1)\\n            {\\n                if(count%2==0)evn++;\\n                else odd++;\\n            }\\n                \\n                \\n            count++;\\n            n=n>>1;\\n        }\\n        return {evn,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int count=0;\\n        int evn=0;\\n        int odd=0;\\n        while(n)\\n        {\\n            \\n            if(n&1==1)\\n            {\\n                if(count%2==0)evn++;\\n                else odd++;\\n            }\\n                \\n                \\n            count++;\\n            n=n>>1;\\n        }\\n        return {evn,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319392,
                "title": "python3-simple",
                "content": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        res = [0,0]\\n        flag = False\\n        while n:\\n            val = n & 1\\n            n >>=1\\n            res[flag] += val\\n            flag = not flag\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        res = [0,0]\\n        flag = False\\n        while n:\\n            val = n & 1\\n            n >>=1\\n            res[flag] += val\\n            flag = not flag\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314556,
                "title": "detailed-explained-simple-java-solution-faster-than-100",
                "content": "**Time Complexity : O(n)** \\n**Space Complexity : O(1)** \\n\\n**If you like hit the like button. Otherwise comment down for clarification.**\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        // First convert integer to a string\\n        String bString = Integer.toBinaryString(n);\\n\\n        // Then reverse it because in numbers we count\\n        // indexes from right to left but in string we\\n        // count indexes from left to right.\\n        // we use StringBuilder to reverse the string.\\n         StringBuilder sb=new StringBuilder(bString);\\n        sb.reverse();\\n\\n        // Now convert the StringBuilder to a string\\n        String s = sb.toString();\\n        // Now count the number of odd and even bits presents in the string\\n        int odd=0,even=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                if(i%2==0) even++;\\n                else\\n                    odd++;\\n            }\\n        }\\n        // Now store even and odds in an array and return that array.\\n        int a[] = new int[2];\\n        a[0]=even;\\n        a[1]=odd;\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        // First convert integer to a string\\n        String bString = Integer.toBinaryString(n);\\n\\n        // Then reverse it because in numbers we count\\n        // indexes from right to left but in string we\\n        // count indexes from left to right.\\n        // we use StringBuilder to reverse the string.\\n         StringBuilder sb=new StringBuilder(bString);\\n        sb.reverse();\\n\\n        // Now convert the StringBuilder to a string\\n        String s = sb.toString();\\n        // Now count the number of odd and even bits presents in the string\\n        int odd=0,even=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'1\\')\\n            {\\n                if(i%2==0) even++;\\n                else\\n                    odd++;\\n            }\\n        }\\n        // Now store even and odds in an array and return that array.\\n        int a[] = new int[2];\\n        a[0]=even;\\n        a[1]=odd;\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314221,
                "title": "simple-and-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust create binary string of the given number and count set bits at even and odd places.\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    \\n    string bina(long n)\\n  {\\n    long i;\\n        string r;\\n    cout << \"0\";\\n    for (i = 1 << 30; i > 0; i = i / 2)\\n    {\\n      if((n & i) != 0)\\n      {\\n        r += \"1\";\\n      }\\n      else\\n      {\\n        r += \"0\";\\n      }\\n    }\\n        return r;\\n  }\\n    \\n    vector<int> evenOddBit(int n) {\\n        string bin = bina(n);\\n        int even = 0, odd = 0;\\n        for(int i=0; i<bin.size(); i++)\\n        {\\n            if((i%2)==1 && bin[i]==\\'1\\')odd++;\\n            if((i%2)==0 && bin[i]==\\'1\\')even++;\\n        }\\n        vector<int> res = {even, odd};\\n        return res;\\n    }\\n};\\n```\\n\\n```java []\\nclass Solution {\\n    \\n    String bina(long n) {\\n        StringBuilder r = new StringBuilder();\\n        for (long i = 1L << 30; i > 0; i = i / 2) {\\n            if ((n & i) != 0) {\\n                r.append(\"1\");\\n            } else {\\n                r.append(\"0\");\\n            }\\n        }\\n        return r.toString();\\n    }\\n    \\n    public List<Integer> evenOddBit(int n) {\\n        String bin = bina(n);\\n        int even = 0, odd = 0;\\n        for (int i = 0; i < bin.length(); i++) {\\n            if ((i % 2) == 1 && bin.charAt(i) == \\'1\\') {\\n                odd++;\\n            }\\n            if ((i % 2) == 0 && bin.charAt(i) == \\'1\\') {\\n                even++;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        res.add(even);\\n        res.add(odd);\\n        return res;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    \\n    def bina(self, n: int) -> str:\\n        r = \"\"\\n        for i in range(30, -1, -1):\\n            if (n & (1 << i)) != 0:\\n                r += \"1\"\\n            else:\\n                r += \"0\"\\n        return r\\n    \\n    def evenOddBit(self, n: int) -> List[int]:\\n        bin_str = self.bina(n)\\n        even = odd = 0\\n        for i in range(len(bin_str)):\\n            if i % 2 == 1 and bin_str[i] == \\'1\\':\\n                odd += 1\\n            if i % 2 == 0 and bin_str[i] == \\'1\\':\\n                even += 1\\n        return [even, odd]\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    \\n    string bina(long n)\\n  {\\n    long i;\\n        string r;\\n    cout << \"0\";\\n    for (i = 1 << 30; i > 0; i = i / 2)\\n    {\\n      if((n & i) != 0)\\n      {\\n        r += \"1\";\\n      }\\n      else\\n      {\\n        r += \"0\";\\n      }\\n    }\\n        return r;\\n  }\\n    \\n    vector<int> evenOddBit(int n) {\\n        string bin = bina(n);\\n        int even = 0, odd = 0;\\n        for(int i=0; i<bin.size(); i++)\\n        {\\n            if((i%2)==1 && bin[i]==\\'1\\')odd++;\\n            if((i%2)==0 && bin[i]==\\'1\\')even++;\\n        }\\n        vector<int> res = {even, odd};\\n        return res;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    \\n    String bina(long n) {\\n        StringBuilder r = new StringBuilder();\\n        for (long i = 1L << 30; i > 0; i = i / 2) {\\n            if ((n & i) != 0) {\\n                r.append(\"1\");\\n            } else {\\n                r.append(\"0\");\\n            }\\n        }\\n        return r.toString();\\n    }\\n    \\n    public List<Integer> evenOddBit(int n) {\\n        String bin = bina(n);\\n        int even = 0, odd = 0;\\n        for (int i = 0; i < bin.length(); i++) {\\n            if ((i % 2) == 1 && bin.charAt(i) == \\'1\\') {\\n                odd++;\\n            }\\n            if ((i % 2) == 0 && bin.charAt(i) == \\'1\\') {\\n                even++;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        res.add(even);\\n        res.add(odd);\\n        return res;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    \\n    def bina(self, n: int) -> str:\\n        r = \"\"\\n        for i in range(30, -1, -1):\\n            if (n & (1 << i)) != 0:\\n                r += \"1\"\\n            else:\\n                r += \"0\"\\n        return r\\n    \\n    def evenOddBit(self, n: int) -> List[int]:\\n        bin_str = self.bina(n)\\n        even = odd = 0\\n        for i in range(len(bin_str)):\\n            if i % 2 == 1 and bin_str[i] == \\'1\\':\\n                odd += 1\\n            if i % 2 == 0 and bin_str[i] == \\'1\\':\\n                even += 1\\n        return [even, odd]\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314146,
                "title": "simple-set-bit-check-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) \\n    {\\n        int even = 0, odd = 0;\\n        for (int i = 0; i < 32; i++) //n is 1000 at max => 32 bit integer\\n        {\\n            int bit = 0;\\n            if ((1 << i) & n) bit = 1;\\n            \\n            if (i % 2 == 0 && bit == 1) even++;\\n            else if (i % 2 != 0 && bit == 1) odd++;\\n        }\\n        return {even, odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) \\n    {\\n        int even = 0, odd = 0;\\n        for (int i = 0; i < 32; i++) //n is 1000 at max => 32 bit integer\\n        {\\n            int bit = 0;\\n            if ((1 << i) & n) bit = 1;\\n            \\n            if (i % 2 == 0 && bit == 1) even++;\\n            else if (i % 2 != 0 && bit == 1) odd++;\\n        }\\n        return {even, odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314108,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        bool odd = false;\\n        vector<int>ans(2,0);\\n        while(n>0){\\n            if(odd){\\n                if(n&1) ans[1]++;\\n                odd=false;\\n            }\\n            else{\\n                if(n&1) ans[0]++;\\n                odd=true;\\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        bool odd = false;\\n        vector<int>ans(2,0);\\n        while(n>0){\\n            if(odd){\\n                if(n&1) ans[1]++;\\n                odd=false;\\n            }\\n            else{\\n                if(n&1) ans[0]++;\\n                odd=true;\\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314059,
                "title": "short-clean-java",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] res = new int[2];\\n        String bit = Integer.toBinaryString(n);\\n        for(int i=bit.length()-1, k=0; i>=0; i--){\\n            if(i % 2 == 0)  res[0] += bit.charAt(k++) - \\'0\\';\\n            else    res[1] += bit.charAt(k++) - \\'0\\';\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] res = new int[2];\\n        String bit = Integer.toBinaryString(n);\\n        for(int i=bit.length()-1, k=0; i>=0; i--){\\n            if(i % 2 == 0)  res[0] += bit.charAt(k++) - \\'0\\';\\n            else    res[1] += bit.charAt(k++) - \\'0\\';\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541778,
                "title": "c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int x = 0, o = 0, e = 0;\\n        while(n){\\n            x++;\\n            if(n&1)e++;\\n            n >>= 1;\\n            if(n==0)break;\\n            if(n&1)o++;\\n            n >>= 1;\\n            x++;\\n        }\\n            return {e,o};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int x = 0, o = 0, e = 0;\\n        while(n){\\n            x++;\\n            if(n&1)e++;\\n            n >>= 1;\\n            if(n==0)break;\\n            if(n&1)o++;\\n            n >>= 1;\\n            x++;\\n        }\\n            return {e,o};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316001,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        s=bin(n)[2:][::-1]\\n        even=0\\n        odd=0\\n        for i in range(len(s)):\\n            if i%2==1 and s[i]==\\'1\\':\\n                odd+=1\\n\\n            if i%2==0 and s[i]==\\'1\\':\\n                even+=1\\n\\n\\n        return [even,odd]            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        s=bin(n)[2:][::-1]\\n        even=0\\n        odd=0\\n        for i in range(len(s)):\\n            if i%2==1 and s[i]==\\'1\\':\\n                odd+=1\\n\\n            if i%2==0 and s[i]==\\'1\\':\\n                even+=1\\n\\n\\n        return [even,odd]            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315038,
                "title": "python3-simple-solutions-with-explanation-string-bit-manipulation",
                "content": "The logic behind is based on the observation that the least significant group of ones can be determined by checking whether the least significant bit of n is a \\'1\\' or a \\'0\\'. Similarly, the next group of ones can be determined by checking the second least significant bit, and so on.\\nWe count adjacent groups of ones, starting from the most significant bit to the least significant bit. If the current index is even and the value is \\'1\\', increment the first element of the list, otherwise, if the current index is odd and the value is also \\'1\\', increment the second element of the list.\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        \\n        for idx, val in enumerate(bin(n)[2:][::-1]):\\n            if idx % 2 == 0 and val == \\'1\\':\\n                ans[0] += 1\\n            elif idx % 2 == 1 and val == \\'1\\':\\n                ans[1] += 1\\n                \\n        return ans\\n```\\nSame story, but now with bitwise operations. Inside the while loop, we add the least significant bit of **n** to the appropriate element in the list based on the value of **i**: if i == 0, we add the least significant bit to the first element of the list, otherwise, we add it to the second element of the list. Next, we **right shift** n by one bit, removes the least significant bit of n. Finally, we use **XOR** i with 1 to flips the value of i between 0 and 1.\\n\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        i = 0\\n        \\n        while n:\\n            ans[i] += n & 1\\n            n >>= 1\\n            i ^= 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        \\n        for idx, val in enumerate(bin(n)[2:][::-1]):\\n            if idx % 2 == 0 and val == \\'1\\':\\n                ans[0] += 1\\n            elif idx % 2 == 1 and val == \\'1\\':\\n                ans[1] += 1\\n                \\n        return ans\\n```\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        i = 0\\n        \\n        while n:\\n            ans[i] += n & 1\\n            n >>= 1\\n            i ^= 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314835,
                "title": "c-easy-to-understand-bit-manipulation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int cte=0, cto=0,i=0;\\n        while(n!=0){\\n            if(i%2==0 and (n&1)==1)cte++;\\n            if(i%2!=0 and (n&1)==1)cto++;\\n            i++;\\n            n=n>>1;\\n        }\\n        return {cte, cto};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int cte=0, cto=0,i=0;\\n        while(n!=0){\\n            if(i%2==0 and (n&1)==1)cte++;\\n            if(i%2!=0 and (n&1)==1)cto++;\\n            i++;\\n            n=n>>1;\\n        }\\n        return {cte, cto};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314820,
                "title": "beats-java-c-easiest",
                "content": "**JAVA**\\n```\\npublic int[] evenOddBit(int n) {\\n        int x=1<<9;    // as 1<=n<=1000 is given in constraints\\n\\t\\tint even=0,odd=0;\\n\\t\\tint i=0;\\n\\t\\tint [] ans = new int[2];\\n\\t\\twhile(i<10)\\n\\t\\t{\\n\\t\\t\\tif((n&x)>0 && i%2==0)\\n\\t\\t\\t\\todd++;\\n\\t\\t\\telse if((n&x)>0 && i%2==1)\\n\\t\\t\\t\\teven++;\\n\\t\\t\\ti++;\\n\\t\\t\\tx=x>>1;\\n\\t\\t}\\n\\t\\tans[0]=even; ans[1]=odd;\\n\\t\\treturn ans;\\n\\t}\\n```\\n**C++**\\n\\n```\\nvector<int> evenOddBit(int n) {\\n\\t\\tint x=1<<9;    // as 1<=n<=1000 is given in constraints\\n\\t\\tint even=0,odd=0;\\n\\t\\tint i=0;\\n\\t\\twhile(i<10)\\n\\t\\t{\\n\\t\\t\\t\\tif((n&x) && i%2==0)\\n\\t\\t\\t\\t\\t odd++;\\n\\t\\t\\t\\telse if((n&x) && i%2==1)\\n\\t\\t\\t\\t\\t even++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tx=x>>1;\\n\\t\\t}\\n\\t\\treturn {even,odd};\\n}\\n```\\n**THANK YOU**",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\npublic int[] evenOddBit(int n) {\\n        int x=1<<9;    // as 1<=n<=1000 is given in constraints\\n\\t\\tint even=0,odd=0;\\n\\t\\tint i=0;\\n\\t\\tint [] ans = new int[2];\\n\\t\\twhile(i<10)\\n\\t\\t{\\n\\t\\t\\tif((n&x)>0 && i%2==0)\\n\\t\\t\\t\\todd++;\\n\\t\\t\\telse if((n&x)>0 && i%2==1)\\n\\t\\t\\t\\teven++;\\n\\t\\t\\ti++;\\n\\t\\t\\tx=x>>1;\\n\\t\\t}\\n\\t\\tans[0]=even; ans[1]=odd;\\n\\t\\treturn ans;\\n\\t}\\n```\n```\\nvector<int> evenOddBit(int n) {\\n\\t\\tint x=1<<9;    // as 1<=n<=1000 is given in constraints\\n\\t\\tint even=0,odd=0;\\n\\t\\tint i=0;\\n\\t\\twhile(i<10)\\n\\t\\t{\\n\\t\\t\\t\\tif((n&x) && i%2==0)\\n\\t\\t\\t\\t\\t odd++;\\n\\t\\t\\t\\telse if((n&x) && i%2==1)\\n\\t\\t\\t\\t\\t even++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tx=x>>1;\\n\\t\\t}\\n\\t\\treturn {even,odd};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3314451,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n\\n        int even = 0 , odd = 0 , count = 1;\\n\\n        while(n){\\n            int bit = n & 1;\\n            n = n>>1;\\n            count++;\\n            if(bit==1){\\n                if(count%2==0)\\n                    even++;\\n                else\\n                    odd++;\\n            }\\n        }\\n\\n        return {even,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n\\n        int even = 0 , odd = 0 , count = 1;\\n\\n        while(n){\\n            int bit = n & 1;\\n            n = n>>1;\\n            count++;\\n            if(bit==1){\\n                if(count%2==0)\\n                    even++;\\n                else\\n                    odd++;\\n            }\\n        }\\n\\n        return {even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314012,
                "title": "java-o-n-time-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] evenOddBit(int n) {\\n    var even = 0;\\n    var odd = 0;\\n    \\n    for (var i=0; n > 0; i++, n /= 2) {\\n      if (i % 2 == 0)\\n        even += (n & 1);\\n      else\\n        odd += (n & 1);\\n    }\\n    return new int[] {even, odd};\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int[] evenOddBit(int n) {\\n    var even = 0;\\n    var odd = 0;\\n    \\n    for (var i=0; n > 0; i++, n /= 2) {\\n      if (i % 2 == 0)\\n        even += (n & 1);\\n      else\\n        odd += (n & 1);\\n    }\\n    return new int[] {even, odd};\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883919,
                "title": "c-simple-2-bits-at-a-time",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-Add first odd bit to odd bit count\\n-Add first even bit to even bit count\\n-Shift bits by 2 to the right\\n-Repeats until there are no bits left\\n-Divides even bit count by 2 to get correct value\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> res{0,0};\\n        while(n){\\n            res[0]+=n&0b01;//add 1 odd bits\\n            res[1]+=n&0b10;//add 2 to even bits\\n            n>>=2;\\n        }\\n        res[1]>>=1;//divide even bits by 2\\n        return res; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> res{0,0};\\n        while(n){\\n            res[0]+=n&0b01;//add 1 odd bits\\n            res[1]+=n&0b10;//add 2 to even bits\\n            n>>=2;\\n        }\\n        res[1]>>=1;//divide even bits by 2\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325143,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int arr[] = new int[2];\\n        int x = 0;\\n        while(n > 0)\\n        {\\n            int rem = n % 2;\\n            if(x == 0)\\n            {\\n                x = 1;\\n                if(rem == 1)\\n                arr[0]++;\\n            }\\n            else\\n            {\\n                x = 0;\\n                if(rem == 1)\\n                arr[1]++;\\n            }\\n            n /= 2;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int arr[] = new int[2];\\n        int x = 0;\\n        while(n > 0)\\n        {\\n            int rem = n % 2;\\n            if(x == 0)\\n            {\\n                x = 1;\\n                if(rem == 1)\\n                arr[0]++;\\n            }\\n            else\\n            {\\n                x = 0;\\n                if(rem == 1)\\n                arr[1]++;\\n            }\\n            n /= 2;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321370,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        x=(bin(n)[2:])[::-1]\\n        even=0\\n        odd=0\\n        for i in range(len(x)):\\n            if i%2==0:\\n                if x[i]==\"1\":\\n                    even+=1\\n            else:\\n                if x[i]==\"1\":\\n                    odd+=1\\n        return [even, odd]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        x=(bin(n)[2:])[::-1]\\n        even=0\\n        odd=0\\n        for i in range(len(x)):\\n            if i%2==0:\\n                if x[i]==\"1\":\\n                    even+=1\\n            else:\\n                if x[i]==\"1\":\\n                    odd+=1\\n        return [even, odd]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316444,
                "title": "c-bitset",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> res;\\n        bitset<32> b(n);\\n        string a=b.to_string();\\n        int ev=0,od=0;\\n        reverse(a.begin(),a.end());\\n        for(int i=0;i<=31;i++){\\n            if(a[i]==\\'1\\'){\\n                od+=(i&1);\\n                ev+=(!(i&1));\\n            }\\n        }\\n        res.push_back(ev);\\n        res.push_back(od);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> res;\\n        bitset<32> b(n);\\n        string a=b.to_string();\\n        int ev=0,od=0;\\n        reverse(a.begin(),a.end());\\n        for(int i=0;i<=31;i++){\\n            if(a[i]==\\'1\\'){\\n                od+=(i&1);\\n                ev+=(!(i&1));\\n            }\\n        }\\n        res.push_back(ev);\\n        res.push_back(od);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315107,
                "title": "java-0ms-100-faster-memory-less-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        String binary = Integer.toBinaryString(n);\\n        int[] result = new int[2];\\n        int len = binary.length();\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (binary.charAt(i) == \\'1\\') {\\n                result[(len - i - 1) & 1]++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        String binary = Integer.toBinaryString(n);\\n        int[] result = new int[2];\\n        int len = binary.length();\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (binary.charAt(i) == \\'1\\') {\\n                result[(len - i - 1) & 1]++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314590,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0;\\n        int odd = 0, i = 0;\\n        while(n > 0) {\\n            int t = n % 2;\\n            n /= 2;\\n            if(t%2==1) {\\n                if(i%2==1) {\\n                    odd++;\\n                    }\\n                else {\\n                    even++;\\n                    }\\n            }\\n            i++;\\n        }\\n        \\n        return {even, odd};  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0;\\n        int odd = 0, i = 0;\\n        while(n > 0) {\\n            int t = n % 2;\\n            n /= 2;\\n            if(t%2==1) {\\n                if(i%2==1) {\\n                    odd++;\\n                    }\\n                else {\\n                    even++;\\n                    }\\n            }\\n            i++;\\n        }\\n        \\n        return {even, odd};  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314318,
                "title": "simple-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        for(int i = 0; i < 1000; i++){};\\n        vector<int> v;\\n        while(n){\\n            v.push_back(n%2);\\n            n >>= 1;\\n        }\\n        // reverse(v.begin(),v.end());\\n        // for(auto &i: v)cout<<i<<\" \";\\n        // cout<<endl;\\n        int x = 0, y = 0;\\n        for(int i = 0; i < v.size(); i++){\\n            if(i&1){\\n                x += (v[i]);\\n            }else{\\n                y += (v[i]);\\n            }\\n        }\\n        return {y,x};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        for(int i = 0; i < 1000; i++){};\\n        vector<int> v;\\n        while(n){\\n            v.push_back(n%2);\\n            n >>= 1;\\n        }\\n        // reverse(v.begin(),v.end());\\n        // for(auto &i: v)cout<<i<<\" \";\\n        // cout<<endl;\\n        int x = 0, y = 0;\\n        for(int i = 0; i < v.size(); i++){\\n            if(i&1){\\n                x += (v[i]);\\n            }else{\\n                y += (v[i]);\\n            }\\n        }\\n        return {y,x};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314276,
                "title": "easy-understanding-using-tostring-method-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n convert the integer to binary and calc odd or even if bit value is 1. reverse\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntrack of odd and even indexes and loop over the binary indexes and check for the conditions\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar evenOddBit = function (n) {\\n  let binaryN = n.toString(2).split(\"\").reverse();\\n  let odd = 0;\\n  let even = 0;\\n  for (let i = 0; i < binaryN.length; i++) {\\n    if (binaryN[i] == 1) {\\n      if (i % 2 == 0) even++;\\n      else odd++;\\n    }\\n  }\\n  return [even, odd];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar evenOddBit = function (n) {\\n  let binaryN = n.toString(2).split(\"\").reverse();\\n  let odd = 0;\\n  let even = 0;\\n  for (let i = 0; i < binaryN.length; i++) {\\n    if (binaryN[i] == 1) {\\n      if (i % 2 == 0) even++;\\n      else odd++;\\n    }\\n  }\\n  return [even, odd];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3314112,
                "title": "best-solution-in-c-bitmask",
                "content": "# Complexity\\n- Time complexity:\\nO(10) = O(1)\\n\\n- Space complexity:\\nO(1)  \\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even=0,odd=0;\\n        vector<int> ans(2);\\n        for(int i=0;i<10;i++){ //for ease take upto 32\\n            if(n & 1<<i){  //if != 0 then\\n                if(i & 1)  //if ith index is odd\\n                    odd++;\\n                else\\n                    even++;\\n            }\\n        }\\n        ans[0]=even,ans[1]=odd;\\n        return ans;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/0224e98d-cfb8-4bf5-95ed-5e03f9ffd92f_1679198627.6153738.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even=0,odd=0;\\n        vector<int> ans(2);\\n        for(int i=0;i<10;i++){ //for ease take upto 32\\n            if(n & 1<<i){  //if != 0 then\\n                if(i & 1)  //if ith index is odd\\n                    odd++;\\n                else\\n                    even++;\\n            }\\n        }\\n        ans[0]=even,ans[1]=odd;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861184,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int count_bits(int n) {\\n        int cnt = 0;\\n        while(n) {\\n            n &= (n - 1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    vector<int> evenOddBit(int n) {\\n        int odd = count_bits(n & 0b0101010101);\\n        int even = count_bits(n & 0b1010101010);\\n        return {odd, even};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count_bits(int n) {\\n        int cnt = 0;\\n        while(n) {\\n            n &= (n - 1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    vector<int> evenOddBit(int n) {\\n        int odd = count_bits(n & 0b0101010101);\\n        int even = count_bits(n & 0b1010101010);\\n        return {odd, even};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815049,
                "title": "beats-100-runtime-99-83-in-memory-the-simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe task is to count the number of 1\\'s in the binary representation of an integer at even and odd positions.\\n\\n# Approach\\n**Step-by-Step Guide to Count Even and Odd Bits**\\n\\n1.***Check LSB (Least Significant Bit):*** \\nPerform a bitwise AND operation of the number num with 1. If the result of num & 1 is not equal to 0, it means the LSB of num is 1; otherwise, it is 0.\\nFor example:\\n5 (0101) & 1 (0001) = 0001 (not equal to 0)\\n\\n**2**.***Increment Even and Odd Counts:*** \\nBased on the result from the previous step and the current position i (even or odd), increment the corresponding count variable even or odd.\\n\\nFor example, if the result of num & 1 is not equal to 0 and i is even, increment the even count. Similarly, if i is odd, increment the odd count.\\n\\n**3**.***Update num for Next Iteration:** \\nRight shift the number num by 1 position to move to the next bit. Update the value of num with the result of the right shift.*\\n\\nFor example:\\n5 (0101) >> 1 = 0010\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- **Time complexity: O(1)**\\n- The time complexity of the given code is O(1), which means it has **constant time complexity.** Regardless of the input value n, **the while loop runs 32 times** because an int in Java is represented by 32 bits. Therefore, the **number of iterations is fixed** and not dependent on the size of n.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:O(1)**\\n- The space complexity of the code is O(1) as well. The code uses a constant amount of space to store the integers even, odd, and i, as well as the integer array created using new int[]{even, odd}. **The space used does not depend on the input value \\'n\\'.**\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n\\n        int even =0;\\n        int odd =0;\\n        int i=0;\\n\\n        while(i<32)\\n        {\\n            if( ( (n & 1)!=0 ) && (i%2 ==0) )\\n                even ++;\\n            else\\n                if( ( (n & 1) !=0) && (i%2 != 0) )\\n                    odd++;\\n                \\n            n = n>>1;\\n            i++;\\n        }\\n        return new int[]{even,odd};\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n\\n        int even =0;\\n        int odd =0;\\n        int i=0;\\n\\n        while(i<32)\\n        {\\n            if( ( (n & 1)!=0 ) && (i%2 ==0) )\\n                even ++;\\n            else\\n                if( ( (n & 1) !=0) && (i%2 != 0) )\\n                    odd++;\\n                \\n            n = n>>1;\\n            i++;\\n        }\\n        return new int[]{even,odd};\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688681,
                "title": "simple-c-solution",
                "content": "# Approach\\n- Maintain two integer variables, `even` and `odd`, to count the number of even and odd indices in the binary representation of integer n.\\n- Divide `n` by 2 while `n` is positive, and if `n modulo 2` is `1`, add `1` to its corresponding variable.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int[] EvenOddBit(int n)\\n    {\\n        var even = 0;\\n        var odd = 0;\\n\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                ++even;\\n            }\\n\\n            n /= 2;\\n\\n            if (n % 2 == 1)\\n            {\\n                ++odd;\\n            }\\n\\n            n /= 2;\\n        }\\n\\n        return new[] {even, odd};\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] EvenOddBit(int n)\\n    {\\n        var even = 0;\\n        var odd = 0;\\n\\n        while (n > 0)\\n        {\\n            if (n % 2 == 1)\\n            {\\n                ++even;\\n            }\\n\\n            n /= 2;\\n\\n            if (n % 2 == 1)\\n            {\\n                ++odd;\\n            }\\n\\n            n /= 2;\\n        }\\n\\n        return new[] {even, odd};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685120,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int>v;\\n        int even=0;\\n        int odd=0;\\n        int size=log2(n)+1;\\n        for(int i=0;i<size;i++)\\n        {\\n            if(i%2==0 && ((n&(1<<i))!=0))\\n            even++;\\n            if(i%2==1 && ((n&(1<<i))!=0))\\n            odd++;\\n        }\\n        v.push_back(even);\\n        v.push_back(odd);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int>v;\\n        int even=0;\\n        int odd=0;\\n        int size=log2(n)+1;\\n        for(int i=0;i<size;i++)\\n        {\\n            if(i%2==0 && ((n&(1<<i))!=0))\\n            even++;\\n            if(i%2==1 && ((n&(1<<i))!=0))\\n            odd++;\\n        }\\n        v.push_back(even);\\n        v.push_back(odd);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672237,
                "title": "2595-number-of-even-and-odd-bits-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        String str1 = Integer.toBinaryString(n);\\n\\t\\t\\t\\tStringBuffer sc = new StringBuffer(str1);\\n\\t\\t\\t\\tsc.reverse();\\n\\t\\t\\t\\tString str =sc.toString();\\n\\t    \\n\\t    int Even_count = 0;\\n\\t    int Odd_count = 0;\\n\\t    int[] arr = new int[2];\\n\\t    \\n\\t    for(int i=0 ; i<str.length();i++){\\n\\t        if((str.charAt(i) == \\'1\\') && i%2==0){\\n\\t            Even_count++;\\n\\t        }\\n\\t        else if(str.charAt(i) == \\'1\\'){\\n\\t            Odd_count++;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    arr[0] = Even_count;\\n\\t    arr[1] = Odd_count;\\n\\t    \\n\\t    return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        String str1 = Integer.toBinaryString(n);\\n\\t\\t\\t\\tStringBuffer sc = new StringBuffer(str1);\\n\\t\\t\\t\\tsc.reverse();\\n\\t\\t\\t\\tString str =sc.toString();\\n\\t    \\n\\t    int Even_count = 0;\\n\\t    int Odd_count = 0;\\n\\t    int[] arr = new int[2];\\n\\t    \\n\\t    for(int i=0 ; i<str.length();i++){\\n\\t        if((str.charAt(i) == \\'1\\') && i%2==0){\\n\\t            Even_count++;\\n\\t        }\\n\\t        else if(str.charAt(i) == \\'1\\'){\\n\\t            Odd_count++;\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    arr[0] = Even_count;\\n\\t    arr[1] = Odd_count;\\n\\t    \\n\\t    return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626656,
                "title": "simplest-beginner-friendly-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        s = bin(n)[2:][::-1]\\n        a, b = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                if i&1:\\n                    b+=1\\n                else:\\n                    a+=1\\n        return [a,b]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        s = bin(n)[2:][::-1]\\n        a, b = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                if i&1:\\n                    b+=1\\n                else:\\n                    a+=1\\n        return [a,b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454760,
                "title": "c-python-o-n-soution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0, odd = 0, ind = 0;\\n        while(n) {\\n            if((ind & 1) && (n & 1)) odd++;\\n            else if(n & 1) even++;\\n            ind++;\\n            n = n >> 1;\\n        }\\n        return {even, odd};\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        even = odd = ind = 0\\n        while n:\\n            if (ind & 1) and (n & 1):\\n                odd += 1\\n            elif n & 1:\\n                even += 1\\n            ind += 1\\n            n = n >> 1\\n        return [even, odd]\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0, odd = 0, ind = 0;\\n        while(n) {\\n            if((ind & 1) && (n & 1)) odd++;\\n            else if(n & 1) even++;\\n            ind++;\\n            n = n >> 1;\\n        }\\n        return {even, odd};\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        even = odd = ind = 0\\n        while n:\\n            if (ind & 1) and (n & 1):\\n                odd += 1\\n            elif n & 1:\\n                even += 1\\n            ind += 1\\n            n = n >> 1\\n        return [even, odd]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400477,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int pos1=0, pos2=0;\\n        bool chk=1;\\n        while (n>0){\\n            if (chk){\\n                pos1+= (n&1);\\n            }\\n            else{\\n                pos2+= (n&1);\\n            }\\n            chk= !chk;\\n            n= n>>1;\\n        }\\n        return {pos1,pos2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int pos1=0, pos2=0;\\n        bool chk=1;\\n        while (n>0){\\n            if (chk){\\n                pos1+= (n&1);\\n            }\\n            else{\\n                pos2+= (n&1);\\n            }\\n            chk= !chk;\\n            n= n>>1;\\n        }\\n        return {pos1,pos2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354334,
                "title": "day-363-veryyyy-easy-all-ways-explained-one-pass-bit-manipulation",
                "content": "# Intuition & Approach &  Complexity\\n##### \\u2022\\tThe problem asks us to count the number of 1\\'s in the binary representation of a given positive integer n at even and odd indices separately. \\n##### \\u2022\\tThe even indices are the positions with an even power of 2, starting from the rightmost bit with index 0, while the odd indices are the positions with an odd power of 2. \\n##### \\u2022\\tThe evenOddBit1() function uses a simple approach to count the number of 1\\'s at even and odd indices separately. It iterates over the bits of n from right to left, and for each bit, it checks if it is at an even or odd index based on the value of the flag variable. \\n##### \\u2022\\tIf the bit is at an even index, it increments the even counter, otherwise, it increments the odd counter. It then toggles the value of the flag variable to switch between even and odd indices, and shifts n to the right by 1 bit. \\n##### \\u2022\\tThe algorithm used in the evenOddBit1() function is based on the observation that the binary representation of a positive integer n has a 1 at an even index if and only if the least significant bit of n is 1, and the binary representation of n/2 has a 1 at an odd index. \\n##### \\u2022\\tSimilarly, the binary representation of n has a 1 at an odd index if and only if the least significant bit of n is 1, and the binary representation of n/2 has a 1 at an even index. \\n##### \\u2022\\tThis observation allows us to count the number of 1\\'s at even and odd indices separately by iterating over the bits of n and toggling the value of the flag variable. \\n##### \\u2022\\tThe time complexity of the evenOddBit1() function is O(log n), where n is the input integer, since we need to iterate over the bits of n . \\n##### \\u2022\\tThe space complexity is O(1), since we only need to store two integer variables even and odd .\\n\\n\\n# Code\\n```java []\\n    public int[] evenOddBit1(int n) {\\n        int even=0,odd=0;\\n        boolean flag=true;\\n        while(n>0){\\n            if(flag)  even+=n&1;\\n            else  odd+=n&1;\\n            flag=!flag;\\n            n>>=1;\\n        }return new int[]{even,odd};\\n    }\\n```\\n```c++ []\\nvector<int> evenOddBit(int n) {\\n    int even = 0, odd = 0;\\n    bool flag = true;\\n    while (n > 0) {\\n        if (flag) {\\n            even += n & 1;\\n        } else {\\n            odd += n & 1;\\n        }\\n        flag = !flag;\\n        n >>= 1;\\n    }\\n    return {even, odd};\\n}\\n```\\n```python []\\ndef evenOddBit1(n):\\n    even, odd = 0, 0\\n    flag = True\\n    while n > 0:\\n        if flag:\\n            even += n & 1\\n        else:\\n            odd += n & 1\\n        flag = not flag\\n        n >>= 1\\n    return [even, odd]\\n```\\n# 2nd way \\n\\n```java []\\n    public int[] evenOddBit(int n) {\\n        int A[] = new int[2],i=0;\\n        while(n>0){\\n            A[i]+=n%2;\\n            i=1-i;\\n            n/=2;\\n        }return A;\\n    }\\n```\\n```PYTHON []\\ndef evenOddBit(n):\\n    A = [0, 0]\\n    i = 0\\n    while n > 0:\\n        A[i] += n % 2\\n        i = 1 - i\\n        n //= 2\\n    return A\\n```\\n```C++ []\\nvector<int> evenOddBit(int n) {\\n    std::vector<int> A(2);\\n    int i = 0;\\n    while (n > 0) {\\n        A[i] += n % 2;\\n        i = 1 - i;\\n        n /= 2;\\n    }\\n    return A;\\n}\\n```\\n\\n# ONE LINER \\n\\n```JAVA []\\npublic int[] evenOddBit(int n) {\\n    return new int[] {Integer.bitCount(n & 0b0101010101), Integer.bitCount(n & 0b1010101010)};\\n}\\n```\\n\\n```C++ []\\nvector<int> evenOddBit(int n) {\\n    return {__builtin_popcount(n & 0b0101010101), __builtin_popcount(n & 0b1010101010)};\\n}\\n```\\n```PYTHON []\\ndef evenOddBit(n):\\n    return [bin(n & 0b0101010101).count(\\'1\\'),  bin(n & 0b1010101010).count(\\'1\\')]\\n```\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/a07b9197-a4cc-4232-84b7-9c033153ebe1_1680072290.883467.webp)\\n\\n![meme2.png](https://assets.leetcode.com/users/images/54f32d08-fa09-4104-9b14-657709a369db_1680072303.138686.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```java []\\n    public int[] evenOddBit1(int n) {\\n        int even=0,odd=0;\\n        boolean flag=true;\\n        while(n>0){\\n            if(flag)  even+=n&1;\\n            else  odd+=n&1;\\n            flag=!flag;\\n            n>>=1;\\n        }return new int[]{even,odd};\\n    }\\n```\n```c++ []\\nvector<int> evenOddBit(int n) {\\n    int even = 0, odd = 0;\\n    bool flag = true;\\n    while (n > 0) {\\n        if (flag) {\\n            even += n & 1;\\n        } else {\\n            odd += n & 1;\\n        }\\n        flag = !flag;\\n        n >>= 1;\\n    }\\n    return {even, odd};\\n}\\n```\n```python []\\ndef evenOddBit1(n):\\n    even, odd = 0, 0\\n    flag = True\\n    while n > 0:\\n        if flag:\\n            even += n & 1\\n        else:\\n            odd += n & 1\\n        flag = not flag\\n        n >>= 1\\n    return [even, odd]\\n```\n```java []\\n    public int[] evenOddBit(int n) {\\n        int A[] = new int[2],i=0;\\n        while(n>0){\\n            A[i]+=n%2;\\n            i=1-i;\\n            n/=2;\\n        }return A;\\n    }\\n```\n```PYTHON []\\ndef evenOddBit(n):\\n    A = [0, 0]\\n    i = 0\\n    while n > 0:\\n        A[i] += n % 2\\n        i = 1 - i\\n        n //= 2\\n    return A\\n```\n```C++ []\\nvector<int> evenOddBit(int n) {\\n    std::vector<int> A(2);\\n    int i = 0;\\n    while (n > 0) {\\n        A[i] += n % 2;\\n        i = 1 - i;\\n        n /= 2;\\n    }\\n    return A;\\n}\\n```\n```JAVA []\\npublic int[] evenOddBit(int n) {\\n    return new int[] {Integer.bitCount(n & 0b0101010101), Integer.bitCount(n & 0b1010101010)};\\n}\\n```\n```C++ []\\nvector<int> evenOddBit(int n) {\\n    return {__builtin_popcount(n & 0b0101010101), __builtin_popcount(n & 0b1010101010)};\\n}\\n```\n```PYTHON []\\ndef evenOddBit(n):\\n    return [bin(n & 0b0101010101).count(\\'1\\'),  bin(n & 0b1010101010).count(\\'1\\')]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3348419,
                "title": "javascript-it-s-much-faster-with-the-bitwise-operators-and",
                "content": "# Intuition\\nAlthough you can use `.toString(2)` to get a binary string, this is slower and less efficient.\\n\\nLet\\'s calculate each bit of the number one by one. \\n\\n# Code\\n```\\nconst evenOddBit = function(n) {\\n    let even = 0;\\n    let odd = 0;\\n    let i = 0;\\n\\n    while (n > 0) {\\n        if (n & 1) { // \"if n is an odd number\"\\n            if (i % 2 === 0) { // can also write `if (!(i & 1))`\\n                even++;\\n            } else {\\n                odd++;\\n            }\\n        }\\n\\n        i++;\\n        n >>= 1; // remove one bit from `n`, i.e. shift it by one bit\\n    }\\n\\n    return [even, odd];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst evenOddBit = function(n) {\\n    let even = 0;\\n    let odd = 0;\\n    let i = 0;\\n\\n    while (n > 0) {\\n        if (n & 1) { // \"if n is an odd number\"\\n            if (i % 2 === 0) { // can also write `if (!(i & 1))`\\n                even++;\\n            } else {\\n                odd++;\\n            }\\n        }\\n\\n        i++;\\n        n >>= 1; // remove one bit from `n`, i.e. shift it by one bit\\n    }\\n\\n    return [even, odd];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3335496,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        string bin;\\n        while(n){\\n            bin+=to_string(n%2);\\n            n/=2;\\n        }\\n        vector<int> res(2);\\n        for(int i = 0; i < bin.size(); i++){\\n            if(bin[i] == \\'1\\'){\\n                if(!(i&1)) res[0]++;\\n                else res[1]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        string bin;\\n        while(n){\\n            bin+=to_string(n%2);\\n            n/=2;\\n        }\\n        vector<int> res(2);\\n        for(int i = 0; i < bin.size(); i++){\\n            if(bin[i] == \\'1\\'){\\n                if(!(i&1)) res[0]++;\\n                else res[1]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331413,
                "title": "fast-87-95-c-python-js-java-unversal-approach",
                "content": "# Approach\\nBest Approach.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$ \\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst evenOddBit = (n) => {\\n  let a = 0, b = 0, counter = 0;\\n  while (n > 0) {\\n    if (n % 2 == 1) {\\n      counter % 2 === 0 ? a++ : b++;\\n    }\\n    counter++;\\n    n = Math.floor(n / 2);\\n  }\\n  return [a, b];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst evenOddBit = (n) => {\\n  let a = 0, b = 0, counter = 0;\\n  while (n > 0) {\\n    if (n % 2 == 1) {\\n      counter % 2 === 0 ? a++ : b++;\\n    }\\n    counter++;\\n    n = Math.floor(n / 2);\\n  }\\n  return [a, b];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328278,
                "title": "simple-java-loop-solution",
                "content": "# Runtime: \\n1 ms beats = 99.94%\\n\\n# Runtime: \\n42.5 MB beats = 72.91%\\n\\n# Code\\nThis is my qute simple solution via loop on each bit and sum of bit values\\n\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int evenCount = 0;\\n        int oddCount = 0;\\n        \\n        for (int evenBitPosition = 0, oddBitPosition = 1; oddBitPosition < 32; evenBitPosition += 2, oddBitPosition += 2) {\\n            evenCount += 0x1 & (n >> evenBitPosition);\\n            oddCount += 0x1 & (n >> oddBitPosition);\\n        }\\n\\n        return new int[] {evenCount, oddCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int evenCount = 0;\\n        int oddCount = 0;\\n        \\n        for (int evenBitPosition = 0, oddBitPosition = 1; oddBitPosition < 32; evenBitPosition += 2, oddBitPosition += 2) {\\n            evenCount += 0x1 & (n >> evenBitPosition);\\n            oddCount += 0x1 & (n >> oddBitPosition);\\n        }\\n\\n        return new int[] {evenCount, oddCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326998,
                "title": "100-faster-solution-o-1-space-c-counting",
                "content": "\\n# Complexity\\n- Time complexity:\\n  O(1)\\n// upto 10 bits only\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int index=0;\\n        int even=0;\\n        int odd=0;\\n        while(n>0)\\n        {\\n            int k=n%2;\\n            n/=2;\\n            if(k==1)\\n            {\\n                if(index%2==0)\\n                {\\n                    even++;\\n                }\\n                else\\n                {\\n                    odd++;\\n                }\\n            }\\n            index++;\\n        }\\n        return{even,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int index=0;\\n        int even=0;\\n        int odd=0;\\n        while(n>0)\\n        {\\n            int k=n%2;\\n            n/=2;\\n            if(k==1)\\n            {\\n                if(index%2==0)\\n                {\\n                    even++;\\n                }\\n                else\\n                {\\n                    odd++;\\n                }\\n            }\\n            index++;\\n        }\\n        return{even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325121,
                "title": "beginner-friendly-approach",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        \\n        int even = 0;\\n        int odd = 0;\\n\\n        int idx = 0;\\n\\n        while (n > 0) {\\n\\n            // Getting bits from the number\\n            int rem = n % 2;\\n            \\n            // If the index is even and rem is 1     \\n            if (idx % 2 == 0 && rem == 1) {\\n\\n                even += 1;\\n\\n            } else if (idx % 2 != 0 && rem == 1) {\\n\\n                odd += 1;\\n\\n            }\\n\\n            idx += 1;\\n            \\n            // Modifying the number.\\n            n = n / 2;\\n        }\\n        \\n        // Creating a two size array  \\n        int ans[] = new int[2];\\n\\n        ans[0] = even;\\n        ans[1] = odd;\\n\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        \\n        int even = 0;\\n        int odd = 0;\\n\\n        int idx = 0;\\n\\n        while (n > 0) {\\n\\n            // Getting bits from the number\\n            int rem = n % 2;\\n            \\n            // If the index is even and rem is 1     \\n            if (idx % 2 == 0 && rem == 1) {\\n\\n                even += 1;\\n\\n            } else if (idx % 2 != 0 && rem == 1) {\\n\\n                odd += 1;\\n\\n            }\\n\\n            idx += 1;\\n            \\n            // Modifying the number.\\n            n = n / 2;\\n        }\\n        \\n        // Creating a two size array  \\n        int ans[] = new int[2];\\n\\n        ans[0] = even;\\n        ans[1] = odd;\\n\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321272,
                "title": "easiest-solution-ever-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert the number to binary and reverse the string to find the indices having 1s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJavascript in-buit functions to the moon ;)\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nfunction dec2bin(dec) {\\n  return (dec >>> 0).toString(2);\\n}\\nvar evenOddBit = function(n) {\\n    let arr = dec2bin(n).split(\"\").reverse()\\n    console.log(arr)\\n    let even=0,odd=0;\\n    for(let i=0;i<arr.length;i++ ){\\n      if(i%2==0 && arr[i]==\\'1\\') even++;\\n      if(i%2!=0 && arr[i]==\\'1\\') odd++;\\n    }\\n    return [even,odd]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nfunction dec2bin(dec) {\\n  return (dec >>> 0).toString(2);\\n}\\nvar evenOddBit = function(n) {\\n    let arr = dec2bin(n).split(\"\").reverse()\\n    console.log(arr)\\n    let even=0,odd=0;\\n    for(let i=0;i<arr.length;i++ ){\\n      if(i%2==0 && arr[i]==\\'1\\') even++;\\n      if(i%2!=0 && arr[i]==\\'1\\') odd++;\\n    }\\n    return [even,odd]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3319939,
                "title": "simple-ruby-solution-one-liner",
                "content": "# Code\\n```\\n# Runtime 89 ms, Beats 100%\\n# Memory 210.9 MB, Beats 100%\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef even_odd_bit(n)\\n  [(n & 341).digits(2).count(1), (n & 682).digits(2).count(1)]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Runtime 89 ms, Beats 100%\\n# Memory 210.9 MB, Beats 100%\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef even_odd_bit(n)\\n  [(n & 341).digits(2).count(1), (n & 682).digits(2).count(1)]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3319809,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n    int[] arr = { 0, 0 };\\n\\t\\tStringBuilder ss = new StringBuilder(Integer.toString(n, 2));\\n\\t\\tss.reverse();\\n\\t\\tfor (int i = 0; i <= ss.length() - 1; i++) {\\n\\t\\t\\tif (i % 2 == 0 && ss.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tarr[0] = arr[0] + 1;\\n\\t\\t\\t} else if (i % 2 == 1 && ss.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tarr[1] = arr[1] + 1;\\n\\t\\t\\t}\\n\\t\\t}          \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n    int[] arr = { 0, 0 };\\n\\t\\tStringBuilder ss = new StringBuilder(Integer.toString(n, 2));\\n\\t\\tss.reverse();\\n\\t\\tfor (int i = 0; i <= ss.length() - 1; i++) {\\n\\t\\t\\tif (i % 2 == 0 && ss.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tarr[0] = arr[0] + 1;\\n\\t\\t\\t} else if (i % 2 == 1 && ss.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tarr[1] = arr[1] + 1;\\n\\t\\t\\t}\\n\\t\\t}          \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319302,
                "title": "using-strconv-formatint-strings-split-in-golang",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc evenOddBit(num int) []int {\\n\\n\\tbinary := strconv.FormatInt(int64(num), 2)\\n\\ttemp := strings.Split(binary, \"\")\\n\\tfor i, j := 0, len(temp)-1; i < j; i, j = i+1, j-1 {\\n\\t\\ttemp[i], temp[j] = temp[j], temp[i]\\n\\t}\\n\\tvar arr =make([]int,2)\\n\\tfor i := 0; i < len(temp); i++ {\\n\\t\\tif temp[i] == \"1\" {\\n\\t\\t\\tif i%2 == 0 {\\n\\t\\t\\t\\tarr[0] += 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tarr[1] += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn arr\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc evenOddBit(num int) []int {\\n\\n\\tbinary := strconv.FormatInt(int64(num), 2)\\n\\ttemp := strings.Split(binary, \"\")\\n\\tfor i, j := 0, len(temp)-1; i < j; i, j = i+1, j-1 {\\n\\t\\ttemp[i], temp[j] = temp[j], temp[i]\\n\\t}\\n\\tvar arr =make([]int,2)\\n\\tfor i := 0; i < len(temp); i++ {\\n\\t\\tif temp[i] == \"1\" {\\n\\t\\t\\tif i%2 == 0 {\\n\\t\\t\\t\\tarr[0] += 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tarr[1] += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3317272,
                "title": "c-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        \\n        int index = 0;\\n        int even = 0 , odd = 0;\\n\\n        while(n){\\n            if(n % 2){\\n                if(index % 2) odd++;\\n                else even++;\\n            }\\n            index++;\\n            n /= 2;\\n        }\\n        \\n        return {even,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        \\n        int index = 0;\\n        int even = 0 , odd = 0;\\n\\n        while(n){\\n            if(n % 2){\\n                if(index % 2) odd++;\\n                else even++;\\n            }\\n            index++;\\n            n /= 2;\\n        }\\n        \\n        return {even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316629,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func evenOddBit(_ n: Int) -> [Int] {\\n        var (n, i, ans) = (n, 0, [0, 0])\\n        \\n        while n>0{\\n            if n%2 == 1{\\n                ans[i%2] += 1\\n            }\\n            \\n            i += 1\\n            n /= 2\\n        }\\n        \\n        return  ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func evenOddBit(_ n: Int) -> [Int] {\\n        var (n, i, ans) = (n, 0, [0, 0])\\n        \\n        while n>0{\\n            if n%2 == 1{\\n                ans[i%2] += 1\\n            }\\n            \\n            i += 1\\n            n /= 2\\n        }\\n        \\n        return  ans\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316602,
                "title": "simple-o-n-solution-in-c",
                "content": "# Intuition\\nUse Odd and Even Hex pattern and find the bits set.\\n\\n# Approach\\nUse Odd and Even Hex pattern and find the bits set. Extract bit count from the pattern\\n\\n# Complexity\\n- Time complexity:\\nO(2N)\\n\\n- Space complexity:\\nO(2)\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* evenOddBit(int n, int* returnSize){\\n\\n    *returnSize = 2;\\n\\n    int evenBit =  (n & (0x55555555));\\n    int oddBit =   (n & (0xAAAAAAAA));\\n    int evenCount = 0;\\n    int oddCount = 0;\\n\\n    while (evenBit)\\n    {\\n        if (evenBit & 0x01)\\n        {\\n            evenCount++;\\n        }\\n        evenBit = evenBit>>1;\\n    }\\n\\n    while (oddBit)\\n    {\\n        if (oddBit & 0x01)\\n        {\\n            oddCount++;\\n        }\\n        oddBit = oddBit>>1;\\n    }\\n\\n    int *arr = (int*)malloc(sizeof(int)*2);\\n\\n    arr[0] = evenCount;\\n    arr[1] = oddCount;\\n\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* evenOddBit(int n, int* returnSize){\\n\\n    *returnSize = 2;\\n\\n    int evenBit =  (n & (0x55555555));\\n    int oddBit =   (n & (0xAAAAAAAA));\\n    int evenCount = 0;\\n    int oddCount = 0;\\n\\n    while (evenBit)\\n    {\\n        if (evenBit & 0x01)\\n        {\\n            evenCount++;\\n        }\\n        evenBit = evenBit>>1;\\n    }\\n\\n    while (oddBit)\\n    {\\n        if (oddBit & 0x01)\\n        {\\n            oddCount++;\\n        }\\n        oddBit = oddBit>>1;\\n    }\\n\\n    int *arr = (int*)malloc(sizeof(int)*2);\\n\\n    arr[0] = evenCount;\\n    arr[1] = oddCount;\\n\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3315270,
                "title": "c-beats-100-time-and-space",
                "content": "# Intuition\\nIterating through binary representation, and keeping track of current bit count. \\n\\n# Approach\\nInterate through the binary representation of the number , `bit` denotes the current bit number we are accessing, if the bit is `1` as per the parity of `bit` increment `even` or `odd`.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int odd = 0, even = 0, bit = 0;\\n        while (n > 0) {\\n            (n % 2 == 1 ? (bit % 2 == 0 ? even++ : odd++) : true);\\n            bit++;\\n            n /= 2;\\n        }         \\n        return { even , odd };   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int odd = 0, even = 0, bit = 0;\\n        while (n > 0) {\\n            (n % 2 == 1 ? (bit % 2 == 0 ? even++ : odd++) : true);\\n            bit++;\\n            n /= 2;\\n        }         \\n        return { even , odd };   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315261,
                "title": "c-halwa-solution-100-faster",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even=0, odd=0, index=0;\\n        while(n){\\n            if(n&1==1){\\n                (index%2)==0?even++:odd++;\\n            }\\n            index++;\\n            n = n>>1;\\n        }\\n        vector<int>ans;\\n        ans.push_back(even);\\n        ans.push_back(odd);\\n        return ans;\\n    }\\n};\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even=0, odd=0, index=0;\\n        while(n){\\n            if(n&1==1){\\n                (index%2)==0?even++:odd++;\\n            }\\n            index++;\\n            n = n>>1;\\n        }\\n        vector<int>ans;\\n        ans.push_back(even);\\n        ans.push_back(odd);\\n        return ans;\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314966,
                "title": "brute-force-easy-o-n-using-decimal-to-binary-conversion",
                "content": "vector<int> evenOddBit(int n) {\\n       \\n        vector<int>binary;\\n \\n         int i = 0;\\n       while (n > 0) {\\n\\n        binary.push_back(n % 2);\\n        n = n / 2;\\n        i++;\\n       }\\n        \\n        int od=0,ev = 0;\\n        //reverse(binary.begin(),binary.end());\\n        for(int i=0;i<binary.size();i++)cout<<binary[i];\\n        for(int i=0;i<binary.size();i++)\\n        {\\n            if(i%2 == 0 && binary[i] == 1)\\n            {\\n                ev++;\\n            }\\n            \\n            if(i%2 != 0 && binary[i] == 1)\\n            {\\n                od++;\\n            }\\n        }\\n        return {ev,od};\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<int> evenOddBit(int n) {\\n       \\n        vector<int>binary;\\n \\n         int i = 0;\\n       while (n > 0) {\\n\\n        binary.push_back(n % 2);\\n        n = n / 2;\\n        i++;\\n       }\\n        \\n        int od=0,ev = 0;\\n        //reverse(binary.begin(),binary.end());\\n        for(int i=0;i<binary.size();i++)cout<<binary[i];\\n        for(int i=0;i<binary.size();i++)\\n        {\\n            if(i%2 == 0 && binary[i] == 1)\\n            {\\n                ev++;\\n            }\\n            \\n            if(i%2 != 0 && binary[i] == 1)\\n            {\\n                od++;\\n            }\\n        }\\n        return {ev,od};\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 3314902,
                "title": "c-bit-manipulation-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int e=0, o=0, cnt=0;\\n        while(n>0){\\n            if(cnt%2==0){\\n                if(n&1){\\n                    e++;\\n                }\\n                n=n>>1;\\n            }\\n            else{\\n                if(n&1){\\n                    o++;\\n                }\\n                n=n>>1;\\n            }\\n            cnt++;\\n        }\\n        return {e, o};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int e=0, o=0, cnt=0;\\n        while(n>0){\\n            if(cnt%2==0){\\n                if(n&1){\\n                    e++;\\n                }\\n                n=n>>1;\\n            }\\n            else{\\n                if(n&1){\\n                    o++;\\n                }\\n                n=n>>1;\\n            }\\n            cnt++;\\n        }\\n        return {e, o};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314874,
                "title": "very-easy-python-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        i = 0\\n        while n > 0:\\n            if n % 2:\\n                ans[i] += 1\\n            i = not i\\n            n //= 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        i = 0\\n        while n > 0:\\n            if n % 2:\\n                ans[i] += 1\\n            i = not i\\n            n //= 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314514,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int even=0;\\n        int odd=0;\\n        String str=Integer.toBinaryString(n);\\n        String rev=reverse(str);\\n        for(int i=0;i<rev.length();i++){\\n            if(rev.charAt(i)==\\'1\\' && i%2==0){\\n                even++;\\n            }else if(rev.charAt(i)==\\'1\\' && i%2!=0){\\n                odd++;\\n            }\\n        }\\n        int ans[]=new int[2];\\n        ans[0]=even;\\n        ans[1]=odd;\\n        return ans;\\n    }\\n    public String reverse(String str){\\n        String rev=\"\";\\n        for(int i=0;i<str.length();i++){\\n            char ch=str.charAt(i);\\n            rev=ch+rev;\\n        }\\n        return rev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int even=0;\\n        int odd=0;\\n        String str=Integer.toBinaryString(n);\\n        String rev=reverse(str);\\n        for(int i=0;i<rev.length();i++){\\n            if(rev.charAt(i)==\\'1\\' && i%2==0){\\n                even++;\\n            }else if(rev.charAt(i)==\\'1\\' && i%2!=0){\\n                odd++;\\n            }\\n        }\\n        int ans[]=new int[2];\\n        ans[0]=even;\\n        ans[1]=odd;\\n        return ans;\\n    }\\n    public String reverse(String str){\\n        String rev=\"\";\\n        for(int i=0;i<str.length();i++){\\n            char ch=str.charAt(i);\\n            rev=ch+rev;\\n        }\\n        return rev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314490,
                "title": "c-easy-solution",
                "content": "class Solution {\\n   public:\\n    vector<int> evenOddBit(int n) {\\n\\n        int even = 0 , odd = 0 , count = 1;\\n\\n        while(n){\\n            int bit = n & 1;\\n            n = n>>1;\\n            count++;\\n            if(bit==1){\\n                if(count%2==0)\\n                    even++;\\n                else\\n                    odd++;\\n            }\\n        }\\n        return {even,odd};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n   public:\\n    vector<int> evenOddBit(int n) {\\n\\n        int even = 0 , odd = 0 , count = 1;\\n\\n        while(n){\\n            int bit = n & 1;\\n            n = n>>1;\\n            count++;\\n            if(bit==1){\\n                if(count%2==0)\\n                    even++;\\n                else\\n                    odd++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3314411,
                "title": "c-java-decimal-to-binary-count",
                "content": "## Explanation:\\n1. Convert the decimal number to binary array form\\n2. Count the number of odd bits and even bits as per the given condition\\n\\n## Code:\\n```Java []\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] res=new int[2];\\n        String num=Integer.toBinaryString(n);\\n        int odd=0,even=0;\\n        for(int i=num.length()-1,k=0;i>=0;i--,k++){\\n            if(num.charAt(i)==\\'1\\'){\\n                if(k%2==0) res[0]++;\\n                else res[1]++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int>arr;\\n        int i=0;\\n        while(n!= 0){\\n            arr.push_back(n%2);\\n            i++,n/=2;\\n        } \\n        int even=0,odd=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] && (i)%2) odd++;\\n            else if(arr[i]) even++;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] res=new int[2];\\n        String num=Integer.toBinaryString(n);\\n        int odd=0,even=0;\\n        for(int i=num.length()-1,k=0;i>=0;i--,k++){\\n            if(num.charAt(i)==\\'1\\'){\\n                if(k%2==0) res[0]++;\\n                else res[1]++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int>arr;\\n        int i=0;\\n        while(n!= 0){\\n            arr.push_back(n%2);\\n            i++,n/=2;\\n        } \\n        int even=0,odd=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] && (i)%2) odd++;\\n            else if(arr[i]) even++;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314288,
                "title": "java-2-solutions-easy",
                "content": "# Solution 1:\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int even = 0, odd = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            int idx = s.length() - i - 1;\\n            if (s.charAt(i) == \\'1\\') {\\n                if (idx % 2 == 0) even++;\\n                else odd++;\\n            }\\n        }\\n        \\n        return new int[] {even, odd};\\n    }\\n}\\n```\\n##### Time complexity: $$O(32) => O(1)$$\\n##### Space complexity: $$O(32) => O(1)$$\\n---\\n# Solution 2:\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int idx = 0;\\n        int even = 0, odd = 0;\\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                if (idx % 2 == 0) even++;\\n                else odd++;\\n            }\\n            n >>= 1;\\n            idx++;\\n        }\\n        \\n        return new int[] {even, odd};\\n    }\\n}\\n```\\n##### Time complexity: $$O(32) => O(1)$$\\n##### Space complexity: $$O(1)$$",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        String s = Integer.toBinaryString(n);\\n        int even = 0, odd = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            int idx = s.length() - i - 1;\\n            if (s.charAt(i) == \\'1\\') {\\n                if (idx % 2 == 0) even++;\\n                else odd++;\\n            }\\n        }\\n        \\n        return new int[] {even, odd};\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int idx = 0;\\n        int even = 0, odd = 0;\\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                if (idx % 2 == 0) even++;\\n                else odd++;\\n            }\\n            n >>= 1;\\n            idx++;\\n        }\\n        \\n        return new int[] {even, odd};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314258,
                "title": "javascript-direct-way-98ms",
                "content": "```\\nconst evenOddBit = (n) => {\\n   let s = n.toString(2), res = [0, 0];\\n   for (let i = s.length - 1, cur = 0; ~i; i--, cur ^= 1) {\\n       if (s[i] == \\'1\\') {\\n           cur ? res[1]++ : res[0]++;\\n       }\\n   }\\n   return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst evenOddBit = (n) => {\\n   let s = n.toString(2), res = [0, 0];\\n   for (let i = s.length - 1, cur = 0; ~i; i--, cur ^= 1) {\\n       if (s[i] == \\'1\\') {\\n           cur ? res[1]++ : res[0]++;\\n       }\\n   }\\n   return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3314166,
                "title": "simple-parity-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply find all bits from 0th position and add corresponsing value for parity of index of bit 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> ans = {0, 0};\\n        int par = 0;\\n        while(n){\\n            if(par == 0){\\n                if(n % 2)   ans[0]++;\\n            }else{\\n                if(n % 2)   ans[1]++;\\n            }\\n            n /= 2;\\n            par = (par + 1) % 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> ans = {0, 0};\\n        int par = 0;\\n        while(n){\\n            if(par == 0){\\n                if(n % 2)   ans[0]++;\\n            }else{\\n                if(n % 2)   ans[1]++;\\n            }\\n            n /= 2;\\n            par = (par + 1) % 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314152,
                "title": "python-easy-100-beats-2595-number-of-even-and-odd-bits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        val = bin(n)[2::][::-1]\\n        l = [0 , 0]\\n        for i in range(0 , len(val)):\\n            if val[i]==\\'1\\':\\n                if i%2:l[1]+=1\\n                else:l[0]+=1\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        val = bin(n)[2::][::-1]\\n        l = [0 , 0]\\n        for i in range(0 , len(val)):\\n            if val[i]==\\'1\\':\\n                if i%2:l[1]+=1\\n                else:l[0]+=1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314129,
                "title": "8-lines-c-easy-bit-manipulation",
                "content": "### Please upvote if you liked this post\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0, odd = 0;\\n        for(int i = 10; i>=0; i--){\\n            int bit = (n >> i) & 1;\\n            if(i%2 == 0 && bit)\\n                even++;\\n            if(i%2 != 0 && bit)\\n                odd++;\\n        }\\n        \\n        return {even, odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0, odd = 0;\\n        for(int i = 10; i>=0; i--){\\n            int bit = (n >> i) & 1;\\n            if(i%2 == 0 && bit)\\n                even++;\\n            if(i%2 != 0 && bit)\\n                odd++;\\n        }\\n        \\n        return {even, odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314101,
                "title": "easy-binary",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        x=bin(n)\\n        s=x[2:]\\n        s=s[::-1]\\n        # s=str(n)\\n        l=list(s)\\n        ot=[0,0]\\n        for i in range(len(s)) :\\n            if(l[i]==\\'1\\' and (i)%2==1) :\\n                ot[1]+=1\\n            elif(l[i]==\\'1\\' and i%2==0) :\\n                ot[0]+=1\\n        return ot\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        x=bin(n)\\n        s=x[2:]\\n        s=s[::-1]\\n        # s=str(n)\\n        l=list(s)\\n        ot=[0,0]\\n        for i in range(len(s)) :\\n            if(l[i]==\\'1\\' and (i)%2==1) :\\n                ot[1]+=1\\n            elif(l[i]==\\'1\\' and i%2==0) :\\n                ot[0]+=1\\n        return ot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314087,
                "title": "simple-solution-faster-than-100",
                "content": "If you are new to bit manipulation solve is question first.\\nhttps://leetcode.com/problems/number-of-1-bits/\\n\\nTC: O(N);\\nSC: O(1);\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int flag = 1; //when flag = 1, index is even. Since it is 0 based indexing.\\n        int even = 0;\\n        int odd = 0;\\n        while(n != 0){\\n            int bit = n & 1;\\n            if(bit == 1 && flag == 1){\\n                even++;\\n            }\\n            if(bit == 1 && flag != 1){\\n                odd++;\\n            }\\n            flag = Math.abs(flag - 1); //toggle the state of flag.\\n            //if flag is 1 it will become 0, and if flag is 0 then it will become 1.\\n            \\n            n = n >>> 1; \\n        }\\n        return new int[]{even, odd};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int flag = 1; //when flag = 1, index is even. Since it is 0 based indexing.\\n        int even = 0;\\n        int odd = 0;\\n        while(n != 0){\\n            int bit = n & 1;\\n            if(bit == 1 && flag == 1){\\n                even++;\\n            }\\n            if(bit == 1 && flag != 1){\\n                odd++;\\n            }\\n            flag = Math.abs(flag - 1); //toggle the state of flag.\\n            //if flag is 1 it will become 0, and if flag is 0 then it will become 1.\\n            \\n            n = n >>> 1; \\n        }\\n        return new int[]{even, odd};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314002,
                "title": "c-simple-string-use-to-convert-to-binary",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        string s = \"\";\\n        while(n){\\n            if(n%2) s+=\\'1\\';\\n            else s += \\'0\\';\\n            n/=2;\\n        }\\n        // reverse(s.begin(),s.end());\\n        // cout<<s<<\"\\\\n\";\\n        int e=0,o=0;\\n        for(int i=0;i<s.size();i++){\\n            if(i%2==1 && s[i]==\\'1\\') o+=1;\\n            if(i%2==0 && s[i]==\\'1\\') e+=1;\\n        }\\n        return {e,o};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        string s = \"\";\\n        while(n){\\n            if(n%2) s+=\\'1\\';\\n            else s += \\'0\\';\\n            n/=2;\\n        }\\n        // reverse(s.begin(),s.end());\\n        // cout<<s<<\"\\\\n\";\\n        int e=0,o=0;\\n        for(int i=0;i<s.size();i++){\\n            if(i%2==1 && s[i]==\\'1\\') o+=1;\\n            if(i%2==0 && s[i]==\\'1\\') e+=1;\\n        }\\n        return {e,o};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4100646,
                "title": "simple-solution-using-divmod",
                "content": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        fl = True\\n        while n > 0:\\n            n, d = divmod(n, 2)\\n            if d:\\n                ans[0] += fl\\n                ans[1] += not fl\\n            fl = not fl\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        fl = True\\n        while n > 0:\\n            n, d = divmod(n, 2)\\n            if d:\\n                ans[0] += fl\\n                ans[1] += not fl\\n            fl = not fl\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095507,
                "title": "c-easiest-and-short-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even =0, odd = 0, i=0;\\n        while(n > 0){\\n            odd+=(n&1 and i&1);\\n            even+=(n&1 and !(i&1));\\n            n>>=1;\\n            i++;\\n        }\\n        return {even, odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even =0, odd = 0, i=0;\\n        while(n > 0){\\n            odd+=(n&1 and i&1);\\n            even+=(n&1 and !(i&1));\\n            n>>=1;\\n            i++;\\n        }\\n        return {even, odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091996,
                "title": "simple-c-easy-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0, odd = 0;\\n        while(n)\\n        {\\n            if(n&1)      // will only check for index {0,2,4,6,8...}\\n            {                          //even\\n                even+=1;\\n                n = n>>1;\\n            }\\n            else\\n               n = n>>1;\\n            if(n&1)      // will only check for index {1,3,5,....}\\n            {                          //odd\\n                odd+=1;\\n                n = n>>1;\\n            }else\\n               n = n>>1;\\n\\n        }\\n        return {even,odd};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0, odd = 0;\\n        while(n)\\n        {\\n            if(n&1)      // will only check for index {0,2,4,6,8...}\\n            {                          //even\\n                even+=1;\\n                n = n>>1;\\n            }\\n            else\\n               n = n>>1;\\n            if(n&1)      // will only check for index {1,3,5,....}\\n            {                          //odd\\n                odd+=1;\\n                n = n>>1;\\n            }else\\n               n = n>>1;\\n\\n        }\\n        return {even,odd};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078672,
                "title": "bitwise-comparison-method",
                "content": "# Intuition\\nUse a bitmask to inspect each bit of the int.\\n\\n# Approach\\nmaintain a mask that gets shifted left after each iteration. In each iteration, use a bitwise and to see if anything is left, if so, adjust the appropriate index in your answer array. Shift n 1 bit to the right.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] answer = new int[2];\\n        for(int i = 0;i<Integer.SIZE;i++){\\n          if((n&0x01)>0)\\n            answer[i%2]++;\\n          n>>=1;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] answer = new int[2];\\n        for(int i = 0;i<Integer.SIZE;i++){\\n          if((n&0x01)>0)\\n            answer[i%2]++;\\n          n>>=1;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078065,
                "title": "easy-to-understand-python-code",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe took an incremental variable i and it represent whether the bit is in even position or not.And after running the while loop until n=0 we then decide what to return based on the length of the binary representation of n .take an example 16 its binary representaion is \"10000\" and here even=1 and odd=0 and number of bits is 5.So we return [even,odd] for odd number of bits and vice versa\\n\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        odd=0\\n        even=0\\n        i=0\\n        while n>0:\\n            if n%2==1 :\\n                if i%2==0:\\n                    even+=1\\n                else:\\n                    odd+=1\\n            n=n//2\\n            i+=1\\n        if len(bin(n))%2==0:\\n            return [odd,even]\\n        else:\\n            return [even,odd]\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        odd=0\\n        even=0\\n        i=0\\n        while n>0:\\n            if n%2==1 :\\n                if i%2==0:\\n                    even+=1\\n                else:\\n                    odd+=1\\n            n=n//2\\n            i+=1\\n        if len(bin(n))%2==0:\\n            return [odd,even]\\n        else:\\n            return [even,odd]\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077809,
                "title": "simple-solution-beats-100",
                "content": "# Complexity\\n- Time complexity:\\n0(logn)\\n\\n# Code\\n```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef even_odd_bit(n)\\n    even = 0\\n    odd = 0\\n    binary_digits = n.to_s(2).to_i.digits\\n\\n    binary_digits.each_with_index do |num, idx|\\n      if num == 1 && idx.even?\\n         even += 1\\n      elsif num == 1 && idx.odd?\\n         odd +=1\\n      end\\n    end\\n    [even, odd]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef even_odd_bit(n)\\n    even = 0\\n    odd = 0\\n    binary_digits = n.to_s(2).to_i.digits\\n\\n    binary_digits.each_with_index do |num, idx|\\n      if num == 1 && idx.even?\\n         even += 1\\n      elsif num == 1 && idx.odd?\\n         odd +=1\\n      end\\n    end\\n    [even, odd]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4070578,
                "title": "evenoddbit-easy-c-approach-with-bits-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        //even index location with 1 will increment the counter\\n        //odd index with 1 will increase counter\\n        vector<int> v;\\n       while(n>0){\\n//binary representation of the number\\n       v.push_back(n&1);\\n       n=n>>1;\\n       if (v.empty()) v.push_back(0); \\n    }\\n        vector<int> ans;\\n        int e=0,o=0;\\n        for(int i=0;i<v.size();i++){\\n            if(i%2==0&&v[i]==1) e++;\\n            if(i%2==1&&v[i]==1) o++;\\n        }\\n        return {e,o};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        //even index location with 1 will increment the counter\\n        //odd index with 1 will increase counter\\n        vector<int> v;\\n       while(n>0){\\n//binary representation of the number\\n       v.push_back(n&1);\\n       n=n>>1;\\n       if (v.empty()) v.push_back(0); \\n    }\\n        vector<int> ans;\\n        int e=0,o=0;\\n        for(int i=0;i<v.size();i++){\\n            if(i%2==0&&v[i]==1) e++;\\n            if(i%2==1&&v[i]==1) o++;\\n        }\\n        return {e,o};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068946,
                "title": "easy-100-runtime-c-bitmanipulation-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int evenCount = 0;\\n        int oddCount = 0;\\n        bool turn = 0;\\n        while(n){\\n            if(1 & n){\\n                turn == 0 ? evenCount++:oddCount++;\\n            }\\n            turn = !turn;\\n            n = (n >> 1);\\n        }\\n        return {evenCount,oddCount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int evenCount = 0;\\n        int oddCount = 0;\\n        bool turn = 0;\\n        while(n){\\n            if(1 & n){\\n                turn == 0 ? evenCount++:oddCount++;\\n            }\\n            turn = !turn;\\n            n = (n >> 1);\\n        }\\n        return {evenCount,oddCount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060882,
                "title": "1ms-beats-100-easy-to-understand-java-solution-easypeasy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![download.jpg](https://assets.leetcode.com/users/images/511e6db4-d5a9-493a-bfe4-21b3dd54b869_1695054422.3209288.jpeg)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int i;\\n        StringBuilder s=new StringBuilder();\\n        int ans[]=new int[2];\\n        while(n>=1){\\n            s.append(n%2);\\n            n=n/2;\\n        }\\n        int e=0;\\n        int o=0;\\n        String str=s.toString();\\n        for(i=0;i<=str.length()-1;i++){\\n            if(str.charAt(i)==\\'1\\' && i%2==0){\\n                e++;\\n            }\\n            else if(str.charAt(i)==\\'1\\' && i%2!=0){\\n                o++;\\n            }\\n        }\\n        ans[0]=e;\\n        ans[1]=o;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int i;\\n        StringBuilder s=new StringBuilder();\\n        int ans[]=new int[2];\\n        while(n>=1){\\n            s.append(n%2);\\n            n=n/2;\\n        }\\n        int e=0;\\n        int o=0;\\n        String str=s.toString();\\n        for(i=0;i<=str.length()-1;i++){\\n            if(str.charAt(i)==\\'1\\' && i%2==0){\\n                e++;\\n            }\\n            else if(str.charAt(i)==\\'1\\' && i%2!=0){\\n                o++;\\n            }\\n        }\\n        ans[0]=e;\\n        ans[1]=o;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060556,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nChecking odd-even place while checking set bit.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int odd_cnt=0, even_cnt=0, cnt=0;\\n        while(n){\\n            if((n&1)&1 && cnt&1){\\n                odd_cnt++;\\n            }else if((n&1)&1 && cnt%2==0){\\n                even_cnt++;\\n            }\\n            n = n>>1;\\n            cnt++;\\n        }\\n        return {even_cnt, odd_cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int odd_cnt=0, even_cnt=0, cnt=0;\\n        while(n){\\n            if((n&1)&1 && cnt&1){\\n                odd_cnt++;\\n            }else if((n&1)&1 && cnt%2==0){\\n                even_cnt++;\\n            }\\n            n = n>>1;\\n            cnt++;\\n        }\\n        return {even_cnt, odd_cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046359,
                "title": "beats-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int e =0;\\n        int o =0;\\n        int count=0;\\n        while(n>0){\\n            int l = n&1;\\n            if(l==1){\\n                if(count%2==0){\\n                e++;\\n                }\\n                else{\\n                    o++;\\n                }\\n            }\\n            count++;\\n            n= n>>1;\\n            \\n        }\\n        int[] a = new int[2];\\n        a[0]=e;\\n        a[1]=o;\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int e =0;\\n        int o =0;\\n        int count=0;\\n        while(n>0){\\n            int l = n&1;\\n            if(l==1){\\n                if(count%2==0){\\n                e++;\\n                }\\n                else{\\n                    o++;\\n                }\\n            }\\n            count++;\\n            n= n>>1;\\n            \\n        }\\n        int[] a = new int[2];\\n        a[0]=e;\\n        a[1]=o;\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044456,
                "title": "python-w-out-direct-bit-manipulation",
                "content": "# Intuition\\nThe least significant bit of a decimal number n is always 1 if n is odd and is always 0 if n is even. Use this fact to infer whether the current digit is 0 or 1.\\n\\n# Approach\\nUse n%2 to see if n is odd or even. Increment the respective counter of the current index by 1 if n n%2 == 1. Regardless of whether the index is odd or eveb, n%2 == 1 must always be true to increase the counter by 1. Use a flag to keep track of whether the current index is even or odd - simply flip the boolean state by notting the current state at the end of each iteration.\\n\\nTo simulate a bitshift to the right, take the floor division of n by 2. \\n\\nOnce n is zero, all the binary digits of n have been exhausted.\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$ - halving n with each iteration\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        \\n        even = odd = 0\\n        idx_even = True\\n\\n        while n:\\n            if n % 2:\\n                odd += not idx_even\\n                even += idx_even\\n            n //= 2\\n            idx_even = not idx_even\\n\\n        return [even, odd]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        \\n        even = odd = 0\\n        idx_even = True\\n\\n        while n:\\n            if n % 2:\\n                odd += not idx_even\\n                even += idx_even\\n            n //= 2\\n            idx_even = not idx_even\\n\\n        return [even, odd]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042731,
                "title": "easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) \\n    {\\n        //we have to check even indices with value 1\\n        //we have to check odd indices with value 1\\n        string str = \"\";\\n        while(n != 1)\\n        {\\n            bool rem = (n%2);\\n            n = n / 2;\\n            if(rem == true) str.push_back(\\'1\\');\\n            else str.push_back(\\'0\\');\\n        }\\n        if(n == 1) str.push_back(\\'1\\');\\n        reverse(str.begin(),str.end());\\n        \\n        int even = 0;\\n        int odd = 0;\\n        int pos = 0;\\n        for(int i = str.length() - 1; i >= 0 ; i--)\\n        {\\n            if((pos%2) == 0 and str[i] == \\'1\\') even++;\\n            else if((pos%2) != 0 and str[i] == \\'1\\') odd++;\\n\\n            pos++;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) \\n    {\\n        //we have to check even indices with value 1\\n        //we have to check odd indices with value 1\\n        string str = \"\";\\n        while(n != 1)\\n        {\\n            bool rem = (n%2);\\n            n = n / 2;\\n            if(rem == true) str.push_back(\\'1\\');\\n            else str.push_back(\\'0\\');\\n        }\\n        if(n == 1) str.push_back(\\'1\\');\\n        reverse(str.begin(),str.end());\\n        \\n        int even = 0;\\n        int odd = 0;\\n        int pos = 0;\\n        for(int i = str.length() - 1; i >= 0 ; i--)\\n        {\\n            if((pos%2) == 0 and str[i] == \\'1\\') even++;\\n            else if((pos%2) != 0 and str[i] == \\'1\\') odd++;\\n\\n            pos++;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042699,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        string s=\"\";\\n        while(n)\\n        {\\n            s.push_back(n%2+\\'0\\');\\n            n/=2;\\n        }\\n        int even=0;\\n        int odd=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'1\\' and i%2==0)\\n            {\\n                even++;\\n            }\\n            else if(s[i]==\\'1\\' and i%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        string s=\"\";\\n        while(n)\\n        {\\n            s.push_back(n%2+\\'0\\');\\n            n/=2;\\n        }\\n        int even=0;\\n        int odd=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'1\\' and i%2==0)\\n            {\\n                even++;\\n            }\\n            else if(s[i]==\\'1\\' and i%2!=0)\\n            {\\n                odd++;\\n            }\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041171,
                "title": "basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int e=0,o=0,i=0;\\n        while(n>0){\\n            if((n&1)!=0){\\n                if(i%2==0)\\n                    e++;\\n                else \\n                    o++;\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        return new int[]{e,o};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int e=0,o=0,i=0;\\n        while(n>0){\\n            if((n&1)!=0){\\n                if(i%2==0)\\n                    e++;\\n                else \\n                    o++;\\n            }\\n            n=n>>1;\\n            i++;\\n        }\\n        return new int[]{e,o};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037698,
                "title": "easily-understandable-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        even=0\\n        odd=0\\n        k=0\\n        while(n>0):\\n            r=n%2\\n            if r==1:\\n                if k%2==0:\\n                    even+=1\\n                else:\\n                    odd+=1\\n            k+=1\\n            n//=2\\n        return [even,odd]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        even=0\\n        odd=0\\n        k=0\\n        while(n>0):\\n            r=n%2\\n            if r==1:\\n                if k%2==0:\\n                    even+=1\\n                else:\\n                    odd+=1\\n            k+=1\\n            n//=2\\n        return [even,odd]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035252,
                "title": "100-beats-solution-in-java",
                "content": "![image.png](https://assets.leetcode.com/users/images/3493ecc8-eef0-4596-b9b0-670d48ea6a81_1694518067.482552.png)\\n# Complexity\\n- Time complexity: O(log n base 2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(log n base 2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n\\n\\n        String str = convertToBinaryString(n);\\n        int[] result = new int[2];\\n\\n        for(int i = 0; i<str.length(); i++){\\n            if(str.charAt(i)==\\'1\\'){\\n                if(i%2==0) result[0]++;\\n                else result[1]++;\\n            } \\n        }\\n\\n        return result;\\n        \\n    }\\n\\n\\n    public String convertToBinaryString(int n){\\n\\n        StringBuilder sb = new StringBuilder();\\n        while(n!=0){\\n            sb.append(n&1);\\n            n = n>>>1;\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n\\n\\n        String str = convertToBinaryString(n);\\n        int[] result = new int[2];\\n\\n        for(int i = 0; i<str.length(); i++){\\n            if(str.charAt(i)==\\'1\\'){\\n                if(i%2==0) result[0]++;\\n                else result[1]++;\\n            } \\n        }\\n\\n        return result;\\n        \\n    }\\n\\n\\n    public String convertToBinaryString(int n){\\n\\n        StringBuilder sb = new StringBuilder();\\n        while(n!=0){\\n            sb.append(n&1);\\n            n = n>>>1;\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032060,
                "title": "faster-than-100-c",
                "content": "# Complexity\\n- Time complexity: log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<int> evenOddBit(int n) {\\n    vector<int> res(2);\\n    int i=0;  // 0:even, 1:odd\\n    while (n>0) {\\n      res[i] += n&1;\\n      n >>= 1;\\n      i ^= 1;\\n    }\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> evenOddBit(int n) {\\n    vector<int> res(2);\\n    int i=0;  // 0:even, 1:odd\\n    while (n>0) {\\n      res[i] += n&1;\\n      n >>= 1;\\n      i ^= 1;\\n    }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013867,
                "title": "100-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        uint8_t even = 0;\\n        uint8_t odd = 0;\\n        bool flag = true;\\n        for(uint8_t i=0;i<31;++i){\\n            if(flag){\\n                even += (n & 0b1);\\n            }else{\\n                odd += (n & 0b1);\\n            }\\n            flag = !flag;\\n            n >>= 1;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        uint8_t even = 0;\\n        uint8_t odd = 0;\\n        bool flag = true;\\n        for(uint8_t i=0;i<31;++i){\\n            if(flag){\\n                even += (n & 0b1);\\n            }else{\\n                odd += (n & 0b1);\\n            }\\n            flag = !flag;\\n            n >>= 1;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012362,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n\\n        int even =0;\\n        int odd =0;\\n        int i=0;\\n\\n        while(i<32)\\n        {\\n            if( ( (n & 1)!=0 ) && (i%2 ==0) )\\n                even ++;\\n            else\\n                if( ( (n & 1) !=0) && (i%2 != 0) )\\n                    odd++;\\n                \\n            n = n>>1;\\n            i++;\\n        }\\n        return new int[]{even,odd};\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n\\n        int even =0;\\n        int odd =0;\\n        int i=0;\\n\\n        while(i<32)\\n        {\\n            if( ( (n & 1)!=0 ) && (i%2 ==0) )\\n                even ++;\\n            else\\n                if( ( (n & 1) !=0) && (i%2 != 0) )\\n                    odd++;\\n                \\n            n = n>>1;\\n            i++;\\n        }\\n        return new int[]{even,odd};\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011439,
                "title": "java-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int ans[] = new int[2];\\n\\n        int c = -1;\\n\\n        while(n > 0) {\\n            c++;\\n            if((n & 1) != 0){\\n                ans[c % 2]++;\\n            }\\n            n = n >> 1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int ans[] = new int[2];\\n\\n        int c = -1;\\n\\n        while(n > 0) {\\n            c++;\\n            if((n & 1) != 0){\\n                ans[c % 2]++;\\n            }\\n            n = n >> 1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009201,
                "title": "typescript-javascript-regex-solution",
                "content": "```\\nfunction evenOddBit(n: number): number[] {\\n    const bin: string = (n).toString(2);\\n    const reverseBin = bin.split(\\'\\').reverse().join(\\'\\');\\n    let even: number = 0;\\n    let length: number = bin.length;\\n    for(let i = 0; i < length; i+=2){\\n        if(reverseBin[i] === \\'1\\') even++;\\n    }\\n    const odd = (reverseBin.match(/1/g)?.length || 0) - even;\\n    return [even, odd];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction evenOddBit(n: number): number[] {\\n    const bin: string = (n).toString(2);\\n    const reverseBin = bin.split(\\'\\').reverse().join(\\'\\');\\n    let even: number = 0;\\n    let length: number = bin.length;\\n    for(let i = 0; i < length; i+=2){\\n        if(reverseBin[i] === \\'1\\') even++;\\n    }\\n    const odd = (reverseBin.match(/1/g)?.length || 0) - even;\\n    return [even, odd];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004529,
                "title": "easy-java-solution",
                "content": "# Intuition\\nJust check the number of 1s and 0s after converting the given number to string.\\n\\n# Approach\\nThe approach used my me is brute force so the time and space complexity isn\\'t the best but it gets the job done.\\nWe just have to make sure that the string is reversed before we traverse through it as the indexing here is starting from the right side and not the usual left.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[] evenOddBit(int n) \\n    {\\n        int o = 0, p = 0;\\n        String w = \"\";\\n        String s = Integer.toBinaryString(n);\\n        System.out.println(s);\\n        for(int i = 0; i<s.length(); i++)\\n        w = s.charAt(i)+w;\\n        for(int i = 0; i<w.length(); i++)\\n        {   if(w.charAt(i) == \\'1\\' && i%2 == 0)\\n            p++;\\n            if(w.charAt(i) == \\'1\\' && i%2!=0)\\n            o++;\\n        }\\n        int a[] = new int[2];\\n        a[0] = p;\\n        a[1] = o;\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] evenOddBit(int n) \\n    {\\n        int o = 0, p = 0;\\n        String w = \"\";\\n        String s = Integer.toBinaryString(n);\\n        System.out.println(s);\\n        for(int i = 0; i<s.length(); i++)\\n        w = s.charAt(i)+w;\\n        for(int i = 0; i<w.length(); i++)\\n        {   if(w.charAt(i) == \\'1\\' && i%2 == 0)\\n            p++;\\n            if(w.charAt(i) == \\'1\\' && i%2!=0)\\n            o++;\\n        }\\n        int a[] = new int[2];\\n        a[0] = p;\\n        a[1] = o;\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003929,
                "title": "easy-c-solution-beats-100",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* evenOddBit(int n, int* returnSize){\\n\\n   *returnSize  = 2; \\n    int *arr = (int *)malloc(sizeof(int)*2);\\n    \\n    int even = 0, odd = 0; \\n    bool isEven = true;  \\n    \\n    while(n > 0)\\n    {\\n        if (isEven == true)\\n        {\\n            if ((n & 1) != 0)\\n            {\\n                even++;\\n            }\\n            isEven = false;\\n        }\\n        else\\n        {\\n            if ((n & 1) != 0)\\n            {\\n                odd++;\\n            }\\n            isEven = true;\\n        }\\n        n = (n >> 1);\\n    }\\n    \\n    arr[0] = even; \\n    arr[1] = odd;\\n    return arr; \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* evenOddBit(int n, int* returnSize){\\n\\n   *returnSize  = 2; \\n    int *arr = (int *)malloc(sizeof(int)*2);\\n    \\n    int even = 0, odd = 0; \\n    bool isEven = true;  \\n    \\n    while(n > 0)\\n    {\\n        if (isEven == true)\\n        {\\n            if ((n & 1) != 0)\\n            {\\n                even++;\\n            }\\n            isEven = false;\\n        }\\n        else\\n        {\\n            if ((n & 1) != 0)\\n            {\\n                odd++;\\n            }\\n            isEven = true;\\n        }\\n        n = (n >> 1);\\n    }\\n    \\n    arr[0] = even; \\n    arr[1] = odd;\\n    return arr; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001088,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        string s;\\n        while(n) {\\n            s.push_back((n % 2) + \\'0\\');\\n            n /= 2;\\n        }       \\n\\n        int even = 0, odd = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'1\\') {\\n                if(i % 2 == 0)\\n                    even++;\\n                else\\n                    odd++;\\n            }\\n        }\\n\\n        return {even, odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        string s;\\n        while(n) {\\n            s.push_back((n % 2) + \\'0\\');\\n            n /= 2;\\n        }       \\n\\n        int even = 0, odd = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'1\\') {\\n                if(i % 2 == 0)\\n                    even++;\\n                else\\n                    odd++;\\n            }\\n        }\\n\\n        return {even, odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997747,
                "title": "harshi-s-simple-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int cnte=0,cnto=0,i=0;\\n        vector<int> c;\\n        while(n>0)\\n        {\\n            int a=n&1;\\n           if(a)\\n           {\\n            if(i%2==0)\\n            cnte++;\\n            else\\n            cnto++;\\n           }\\n           i++;\\n           n=n>>1;\\n        }\\n        c.push_back(cnte);\\n        c.push_back(cnto);\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int cnte=0,cnto=0,i=0;\\n        vector<int> c;\\n        while(n>0)\\n        {\\n            int a=n&1;\\n           if(a)\\n           {\\n            if(i%2==0)\\n            cnte++;\\n            else\\n            cnto++;\\n           }\\n           i++;\\n           n=n>>1;\\n        }\\n        c.push_back(cnte);\\n        c.push_back(cnto);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992489,
                "title": "solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def evenOddBit(self, n):\\n        b=bin(n)[2:]\\n        l=[0,0]\\n        a=len(b)\\n        for i in range(a):\\n            if b[i]==\\'1\\':\\n                j=(a-i-1)\\n                if j%2==0:\\n                    l[0]+=1\\n                else:\\n                    l[1]+=1\\n        return l\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def evenOddBit(self, n):\\n        b=bin(n)[2:]\\n        l=[0,0]\\n        a=len(b)\\n        for i in range(a):\\n            if b[i]==\\'1\\':\\n                j=(a-i-1)\\n                if j%2==0:\\n                    l[0]+=1\\n                else:\\n                    l[1]+=1\\n        return l\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990320,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef even_odd_bit(n)\\n    even = 0\\n    odd = 0\\n    \\n    n_to_s = n.to_s(2).reverse\\n    index = 0\\n    while index < n_to_s.size\\n        if index.even? and n_to_s[index] == \"1\"\\n            even = even + 1\\n        elsif index.odd? and n_to_s[index] == \"1\"\\n            odd = odd + 1\\n        end\\n\\n        index = index + 1\\n    end\\n\\n    return [even, odd]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef even_odd_bit(n)\\n    even = 0\\n    odd = 0\\n    \\n    n_to_s = n.to_s(2).reverse\\n    index = 0\\n    while index < n_to_s.size\\n        if index.even? and n_to_s[index] == \"1\"\\n            even = even + 1\\n        elsif index.odd? and n_to_s[index] == \"1\"\\n            odd = odd + 1\\n        end\\n\\n        index = index + 1\\n    end\\n\\n    return [even, odd]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3989847,
                "title": "c-easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int i=0;\\n        int even=0,odd=0;\\n        while(n>0)\\n        {\\n            int rem=n%2;\\n            if(i%2==0 && rem==1)\\n            even+=1;\\n            if(i%2!=0 && rem==1)\\n            odd+=1;\\n            n=n/2;\\n            i++;\\n        }\\n        \\n        vector<int>v;\\n        v.push_back(even);\\n        v.push_back(odd);\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int i=0;\\n        int even=0,odd=0;\\n        while(n>0)\\n        {\\n            int rem=n%2;\\n            if(i%2==0 && rem==1)\\n            even+=1;\\n            if(i%2!=0 && rem==1)\\n            odd+=1;\\n            n=n/2;\\n            i++;\\n        }\\n        \\n        vector<int>v;\\n        v.push_back(even);\\n        v.push_back(odd);\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988275,
                "title": "beats-98-92-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar evenOddBit = function(n) {\\n    let even = 0;\\n    let odd = 0;\\n\\n    while( n ){\\n        if(n % 2 === 1){\\n            even++;\\n        }\\n\\n        n >>= 1;\\n\\n        if( n % 2 === 1){\\n            odd++;\\n        }\\n\\n        n >>= 1;\\n    }\\n\\n    return [even, odd]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar evenOddBit = function(n) {\\n    let even = 0;\\n    let odd = 0;\\n\\n    while( n ){\\n        if(n % 2 === 1){\\n            even++;\\n        }\\n\\n        n >>= 1;\\n\\n        if( n % 2 === 1){\\n            odd++;\\n        }\\n\\n        n >>= 1;\\n    }\\n\\n    return [even, odd]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985747,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0,odd = 0;\\n        int i = 0;\\n        while(n > 0){\\n            if(n%2 == 1){\\n                if(i%2 == 0){\\n                    even++;\\n                }else{\\n                    odd++;\\n                }\\n            }\\n            n = n/2;\\n            i++;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0,odd = 0;\\n        int i = 0;\\n        while(n > 0){\\n            if(n%2 == 1){\\n                if(i%2 == 0){\\n                    even++;\\n                }else{\\n                    odd++;\\n                }\\n            }\\n            n = n/2;\\n            i++;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982915,
                "title": "simple-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(position of msb)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int ans[]=new int[2];\\n        int i=0;\\n        while(n!=0)\\n        {\\n           if((n&1)!=0)\\n           ans[i]++;\\n           n=n>>1;\\n           i=(i+1)%2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int ans[]=new int[2];\\n        int i=0;\\n        while(n!=0)\\n        {\\n           if((n&1)!=0)\\n           ans[i]++;\\n           n=n>>1;\\n           i=(i+1)%2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980481,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        s = bin(n)[2:][::-1]\\n        even = sum(s[i] == \\'1\\' for i in range(0, len(s), 2))\\n        odd = sum(s[i] == \\'1\\' for i in range(1, len(s), 2))\\n        return [even, odd]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        s = bin(n)[2:][::-1]\\n        even = sum(s[i] == \\'1\\' for i in range(0, len(s), 2))\\n        odd = sum(s[i] == \\'1\\' for i in range(1, len(s), 2))\\n        return [even, odd]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979974,
                "title": "easy-c-solution-beginner-s-friendly-full-explanation",
                "content": "\\n\\n# Approach\\n1. Convert the number into binary.\\n2. Check if the digit is 1 or not.\\n3. If it is 1 then count whether it\\'s index is even or odd.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> ans;\\n        while(n>0){\\n            int temp=n%2;\\n            ans.push_back(temp);\\n            n=n/2;\\n        }\\n        \\n        int even = 0, odd = 0;\\n        for (int i = 0; i < ans.size(); i++){\\n            if (ans[i] == 1){\\n                if (i % 2 == 0){\\n                    even++;\\n                }\\n                else{\\n                    odd++;\\n                }\\n            }\\n        }\\n        \\n        return {even,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> ans;\\n        while(n>0){\\n            int temp=n%2;\\n            ans.push_back(temp);\\n            n=n/2;\\n        }\\n        \\n        int even = 0, odd = 0;\\n        for (int i = 0; i < ans.size(); i++){\\n            if (ans[i] == 1){\\n                if (i % 2 == 0){\\n                    even++;\\n                }\\n                else{\\n                    odd++;\\n                }\\n            }\\n        }\\n        \\n        return {even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977248,
                "title": "beats-100-in-java-fully-explained-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// \\uD83C\\uDF1F Count Even and Odd Set Bits! \\uD83C\\uDF1F\\n\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        // Initialize counters for even and odd set bits\\n        int even = 0, odd = 0, idx = 0;\\n\\n        // Iterate while there are bits left in the number\\n        while (n > 0) {\\n            // Get the remainder when dividing by 2 (current bit)\\n            int rem = n % 2;\\n\\n            // Check if the current index is even and the bit is 1\\n            if (idx % 2 == 0 && rem == 1) {\\n                even++; // Increment the count of even set bits\\n            }\\n            // Check if the current index is odd and the bit is 1\\n            else if (idx % 2 != 0 && rem == 1) {\\n                odd++; // Increment the count of odd set bits\\n            }\\n\\n            // Move to the next index and divide the number by 2\\n            idx++;\\n            n /= 2;\\n        }\\n\\n        // Create an array to store the counts of even and odd set bits\\n        int[] res = new int[2];\\n        res[0] = even; // Store the count of even set bits\\n        res[1] = odd;  // Store the count of odd set bits\\n        return res;    // Return the result array\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// \\uD83C\\uDF1F Count Even and Odd Set Bits! \\uD83C\\uDF1F\\n\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        // Initialize counters for even and odd set bits\\n        int even = 0, odd = 0, idx = 0;\\n\\n        // Iterate while there are bits left in the number\\n        while (n > 0) {\\n            // Get the remainder when dividing by 2 (current bit)\\n            int rem = n % 2;\\n\\n            // Check if the current index is even and the bit is 1\\n            if (idx % 2 == 0 && rem == 1) {\\n                even++; // Increment the count of even set bits\\n            }\\n            // Check if the current index is odd and the bit is 1\\n            else if (idx % 2 != 0 && rem == 1) {\\n                odd++; // Increment the count of odd set bits\\n            }\\n\\n            // Move to the next index and divide the number by 2\\n            idx++;\\n            n /= 2;\\n        }\\n\\n        // Create an array to store the counts of even and odd set bits\\n        int[] res = new int[2];\\n        res[0] = even; // Store the count of even set bits\\n        res[1] = odd;  // Store the count of odd set bits\\n        return res;    // Return the result array\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976972,
                "title": "python-reverse-string",
                "content": "# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        bn = \"{0:b}\".format(n)[::-1]\\n        res = [0, 0]\\n        for i, val in enumerate(bn):\\n            if val is \\'1\\':\\n                if i % 2 == 0: res[0] += 1\\n                else: res[1] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        bn = \"{0:b}\".format(n)[::-1]\\n        res = [0, 0]\\n        for i, val in enumerate(bn):\\n            if val is \\'1\\':\\n                if i % 2 == 0: res[0] += 1\\n                else: res[1] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976808,
                "title": "javascript-reverse-string",
                "content": "# Code\\n```\\nvar evenOddBit = function(n) {\\n    return n.toString(2).split(\\'\\').reverse().reduce((p, c, i) => {\\n        if (c === \\'1\\') {\\n            i % 2 === 0 ? p[0]++ : p[1]++\\n        }\\n        return p;\\n    }, [0, 0]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar evenOddBit = function(n) {\\n    return n.toString(2).split(\\'\\').reverse().reduce((p, c, i) => {\\n        if (c === \\'1\\') {\\n            i % 2 === 0 ? p[0]++ : p[1]++\\n        }\\n        return p;\\n    }, [0, 0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976110,
                "title": "i-don-t-know-pretty-easy-o-log-n",
                "content": "# Intuition\\nCheck whether the remainder of mod2 is 1. If it is, you have to add 1 to the odd or even counter, depending on the changing bool. Then devide by 2 to get the next bit-number.\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> ans = {0,0};\\n        bool isAtOdd = true;\\n        while(n>0){\\n            if(n%2){\\n                if(isAtOdd) ans[0]++;\\n                else ans[1]++;\\n            }\\n            n/=2;\\n            isAtOdd = !isAtOdd;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> ans = {0,0};\\n        bool isAtOdd = true;\\n        while(n>0){\\n            if(n%2){\\n                if(isAtOdd) ans[0]++;\\n                else ans[1]++;\\n            }\\n            n/=2;\\n            isAtOdd = !isAtOdd;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975985,
                "title": "c-simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to convert the given integer `n` into its binary representation and then count the number of even and odd positions with a value of `1`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach involves two main steps:\\n\\n1. Binary Conversion:\\nThe input integer `n` is converted to its binary representation. This is done by repeatedly dividing `n` by 2 and storing the remainders in reverse order. These remainders represent the binary bits of `n`.\\n\\n2. Counting Even and Odd Positions:\\nAfter obtaining the binary representation, the code iterates through each bit position and counts the number of `1` bits in even and odd positions. The position of the bits is determined by the index in the binary representation.\\n\\n3. Returning the Result:\\nFinally, the code returns a vector containing the counts of `1` bits in even and odd positions.\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> bin;\\n\\n        while(n > 0) {\\n            bin.push_back(n % 2);\\n            n /= 2;\\n        }\\n\\n        int even = 0, odd = 0;\\n\\n        for(int i = 0; i < bin.size(); i++) {\\n            if(i % 2 == 0 && bin[i] == 1) {\\n                even++;\\n            } else if(bin[i] == 1) {\\n                odd++;\\n            }\\n        }\\n\\n        return {even, odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> bin;\\n\\n        while(n > 0) {\\n            bin.push_back(n % 2);\\n            n /= 2;\\n        }\\n\\n        int even = 0, odd = 0;\\n\\n        for(int i = 0; i < bin.size(); i++) {\\n            if(i % 2 == 0 && bin[i] == 1) {\\n                even++;\\n            } else if(bin[i] == 1) {\\n                odd++;\\n            }\\n        }\\n\\n        return {even, odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968231,
                "title": "beats-98-easy-and-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        even=[]\\n        odd=[]\\n        li=[]\\n        for i in range(31):\\n            if (n>>i)&1==1:\\n                x=i-1\\n                if x%2==0:\\n                    even.append(x)\\n                else:\\n                    odd.append(x)\\n        y=len(even)\\n        li.append(y)\\n        z=len(odd)\\n        li.append(z)\\n        return li[::-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        even=[]\\n        odd=[]\\n        li=[]\\n        for i in range(31):\\n            if (n>>i)&1==1:\\n                x=i-1\\n                if x%2==0:\\n                    even.append(x)\\n                else:\\n                    odd.append(x)\\n        y=len(even)\\n        li.append(y)\\n        z=len(odd)\\n        li.append(z)\\n        return li[::-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962861,
                "title": "c-beats-100-simple-and-explained",
                "content": "# Intuition\\nArray of 2, indices are 0 (even) and 1 (odd).\\nSimple bitwise traversal while tracking its \"index\" in a variable. Increment array at the index variable whenever a bit is set.\\n\\n# Approach\\n- Initialize array <code>v[2]</code> to 0, maintain a count variable to track index <code>cnt</code>.\\n- While traversing, check if the LSB is set (n&1).\\n- If it is set, then check <code>cnt</code> variable. If it is odd, increment <code>v[1]</code>, else increment ```v[0]```.\\nThis can be checked by directly incrementing <code>v[cnt & 1]</code>.\\n- Keep incrementing <code>cnt</code> in loop and left shift n by 1.\\n# Complexity\\n- Time complexity: O(log<sub>2</sub>n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> v (2, 0);\\n        int cnt = 0;\\n\\n        while(n){\\n            if(n&1)\\n                v[cnt&1] += 1;\\n            cnt++;\\n            n >>= 1;\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```v[0]```\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        vector<int> v (2, 0);\\n        int cnt = 0;\\n\\n        while(n){\\n            if(n&1)\\n                v[cnt&1] += 1;\\n            cnt++;\\n            n >>= 1;\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957732,
                "title": "c-right-shift",
                "content": "```\\npublic class Solution {\\n    public int[] EvenOddBit(int n)\\n    {\\n        var answer = new int[2];\\n        var count = 0;\\n\\n        while (n != 0)\\n        {\\n            answer[count++ % 2] += n & 1;\\n\\n            n >>= 1;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] EvenOddBit(int n)\\n    {\\n        var answer = new int[2];\\n        var count = 0;\\n\\n        while (n != 0)\\n        {\\n            answer[count++ % 2] += n & 1;\\n\\n            n >>= 1;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950438,
                "title": "beats-100-0ms-runtime-a-very-simple-approach-to-solve-the-given-problem",
                "content": "# Intuition\\n**please upvote**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf even bit is high(1) then we increase even and if odd is high increase odd. But how shoud we traverse on bits...\\nNumbers are less than 1000 that is there can only be 10 bits 0 to 9 index. I think now you all can traverse easily.\\ntry yourself..\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate an int array of size 2.arr[0] will hold even while arr[1] will hold odd.\\nhere n will traverse on even bits and m will traverse on odd.\\nm = n>>1 because bits are 0-indexed and 0 is even. hence we shifted it by one so that it traverse odd bits. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) you can also do this in constant time if you simply run a loop from 0 to 9. but here time taken will always be less than or equal to constant time.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* evenOddBit(int n, int* r){\\n    *r=2;\\n    int* arr=(int*)malloc(*r * sizeof(int));\\n    arr[0]=arr[1]=0;\\n    int m=n>>1;\\n    while(n){//traversing even bits\\n        if(n&1) arr[0]++;\\n        n=n>>2;\\n    }\\n    while(m){//traversing odd bits\\n        if(m&1) arr[1]++;\\n        m=m>>2;\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* evenOddBit(int n, int* r){\\n    *r=2;\\n    int* arr=(int*)malloc(*r * sizeof(int));\\n    arr[0]=arr[1]=0;\\n    int m=n>>1;\\n    while(n){//traversing even bits\\n        if(n&1) arr[0]++;\\n        n=n>>2;\\n    }\\n    while(m){//traversing odd bits\\n        if(m&1) arr[1]++;\\n        m=m>>2;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945544,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        i = 0\\n        while n:\\n            if n&1:\\n                ans[i%2] += 1\\n            i += 1\\n            n >>= 1\\n        return ans\\n```\\n\\n![image](https://assets.leetcode.com/users/images/86037c7f-86da-4f31-8bf4-b3a5b639207c_1692711022.1913788.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        ans = [0, 0]\\n        i = 0\\n        while n:\\n            if n&1:\\n                ans[i%2] += 1\\n            i += 1\\n            n >>= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941092,
                "title": "bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int counteven=0;\\n        int countodd=0;\\n        for(int i=31 ; i>=0 ; i--){\\n            if(i%2==0){\\n                if((n & (1<<i))!=0){\\n                    counteven++;\\n                }\\n            }else{\\n                if((n & (1<<i))!=0){\\n                    countodd++;\\n                }\\n            }\\n        }\\n        return {counteven , countodd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int counteven=0;\\n        int countodd=0;\\n        for(int i=31 ; i>=0 ; i--){\\n            if(i%2==0){\\n                if((n & (1<<i))!=0){\\n                    counteven++;\\n                }\\n            }else{\\n                if((n & (1<<i))!=0){\\n                    countodd++;\\n                }\\n            }\\n        }\\n        return {counteven , countodd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938528,
                "title": "golang-smple-0ms",
                "content": "```\\nfunc evenOddBit(n int) []int {\\n    even, odd := 0, 0\\n    count := 0\\n    for n >= 1 {\\n        tmp := n % 2\\n        if count % 2 == 0 {\\n            even += tmp\\n        } else {\\n            odd += tmp\\n        }\\n        count += 1\\n        n = n / 2\\n    }\\n    return []int{even, odd}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc evenOddBit(n int) []int {\\n    even, odd := 0, 0\\n    count := 0\\n    for n >= 1 {\\n        tmp := n % 2\\n        if count % 2 == 0 {\\n            even += tmp\\n        } else {\\n            odd += tmp\\n        }\\n        count += 1\\n        n = n / 2\\n    }\\n    return []int{even, odd}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936025,
                "title": "java-runtime-1ms-beats-100-easy-understandable-beginners-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] res = new int[2];\\n        int num = n;\\n        int even = 0,odd = 0;\\n\\n        for(int i=0;i<32;i++){\\n            if(i%2 == 0){\\n               if((n&1) == 1)\\n               even++;\\n            n>>=1;\\n            }\\n            else {\\n                if((n&1)==1)\\n                odd++;\\n             n>>=1;   \\n            }\\n        }\\n        res[0] = even;\\n        res[1] = odd;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] res = new int[2];\\n        int num = n;\\n        int even = 0,odd = 0;\\n\\n        for(int i=0;i<32;i++){\\n            if(i%2 == 0){\\n               if((n&1) == 1)\\n               even++;\\n            n>>=1;\\n            }\\n            else {\\n                if((n&1)==1)\\n                odd++;\\n             n>>=1;   \\n            }\\n        }\\n        res[0] = even;\\n        res[1] = odd;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919796,
                "title": "100-beat-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int even=0, odd=0;\\n          ArrayList<Integer>ans=new ArrayList<>();\\n        while(n!=0)\\n        {\\n            int bit=n&1;\\n            ans.add(bit);\\n           \\n            n=n>>1;\\n        }\\n        int []arr=new int[ans.size()];\\n        for(int i=0;i<ans.size(); i++)\\n        {\\n            arr[i]=ans.get(i);\\n        }\\n        for(int i=arr.length-1; i>=0; i--)\\n        {\\n            if(i%2==0)\\n            {\\n                if(arr[i]==1)\\n                {\\n                   even++;\\n                }\\n               \\n            }\\n            else if(i%2!=0)\\n            {\\n                if(arr[i]==1)\\n                {\\n                    odd++;\\n                }\\n            }\\n\\n        }\\n        int []temp=new int[2];\\n        temp[0]=even;\\n        temp[1]=odd;\\n        return temp;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int even=0, odd=0;\\n          ArrayList<Integer>ans=new ArrayList<>();\\n        while(n!=0)\\n        {\\n            int bit=n&1;\\n            ans.add(bit);\\n           \\n            n=n>>1;\\n        }\\n        int []arr=new int[ans.size()];\\n        for(int i=0;i<ans.size(); i++)\\n        {\\n            arr[i]=ans.get(i);\\n        }\\n        for(int i=arr.length-1; i>=0; i--)\\n        {\\n            if(i%2==0)\\n            {\\n                if(arr[i]==1)\\n                {\\n                   even++;\\n                }\\n               \\n            }\\n            else if(i%2!=0)\\n            {\\n                if(arr[i]==1)\\n                {\\n                    odd++;\\n                }\\n            }\\n\\n        }\\n        int []temp=new int[2];\\n        temp[0]=even;\\n        temp[1]=odd;\\n        return temp;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916550,
                "title": "clean-go-solution",
                "content": "# Code\\n```\\nfunc evenOddBit(n int) []int {\\n\\tres := make([]int, 2)\\n\\ti := 0\\n\\tfor n > 0 {\\n\\t\\tres[i] += n & 1\\n\\t\\ti ^= 1\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc evenOddBit(n int) []int {\\n\\tres := make([]int, 2)\\n\\ti := 0\\n\\tfor n > 0 {\\n\\t\\tres[i] += n & 1\\n\\t\\ti ^= 1\\n\\t\\tn >>= 1\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899164,
                "title": "go-simple-solution",
                "content": "# Code\\n```\\nfunc evenOddBit(n int) []int {\\n\\tv := []int{0, 0}\\n\\tvar i byte\\n\\tfor n != 0 {\\n\\t\\tv[i] += n & 1\\n\\t\\tn >>= 1\\n\\t\\ti = (i + 1) % 2\\n\\t}\\n\\treturn v\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc evenOddBit(n int) []int {\\n\\tv := []int{0, 0}\\n\\tvar i byte\\n\\tfor n != 0 {\\n\\t\\tv[i] += n & 1\\n\\t\\tn >>= 1\\n\\t\\ti = (i + 1) % 2\\n\\t}\\n\\treturn v\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896705,
                "title": "python-simple",
                "content": "```class Solution(object):\\n    def evenOddBit(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 2:\\n            return [0,1]\\n\\n        binary = \\'{0:00b}\\'.format(n)\\n        print(binary)\\n        even = 0 \\n        odd = 0\\n        index = 0\\n\\n        for i in range(len(binary)-1, -1, -1):\\n            if i%2 == 0:\\n                print(\\'even index\\')\\n                print(i)\\n                print(binary[i])\\n                if binary[index] == \\'1\\':\\n                    even += 1\\n            else:\\n                print(\\'odd index\\')\\n                print(i)\\n                print(binary[i])\\n                if binary[index] == \\'1\\':\\n                    odd += 1\\n            index+=1\\n\\n        return [even, odd]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def evenOddBit(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 2:\\n            return [0,1]\\n\\n        binary = \\'{0:00b}",
                "codeTag": "Java"
            },
            {
                "id": 3895350,
                "title": "python-easy-understanding-and-simple-solution-thanks",
                "content": "Thanks for reading :)\\n\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        even = odd = cnt = 0\\n        answer = []\\n        for i in bin(n)[2:][::-1]:\\n            if cnt % 2 == 0 and i == \\'1\\':\\n                even += 1\\n            elif cnt % 2 != 0 and i == \\'1\\':\\n                odd += 1            \\n            cnt += 1 \\n        answer.append(even)\\n        answer.append(odd)\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        even = odd = cnt = 0\\n        answer = []\\n        for i in bin(n)[2:][::-1]:\\n            if cnt % 2 == 0 and i == \\'1\\':\\n                even += 1\\n            elif cnt % 2 != 0 and i == \\'1\\':\\n                odd += 1            \\n            cnt += 1 \\n        answer.append(even)\\n        answer.append(odd)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889252,
                "title": "easy-solution-in-c-beats-100",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToBinary(int num) {\\n        string binary;\\n        if (num == 0) {\\n            binary = \"0\";\\n        } else {\\n            while (num > 0) {\\n                binary = char(\\'0\\' + (num % 2)) + binary;\\n                num /= 2;\\n            }\\n        }\\n        return binary;\\n    }\\n    vector<int> evenOddBit(int n) {\\n        string str=intToBinary(n);\\n        reverse(str.begin(),str.end());\\n        int even=0;\\n        int odd=0;\\n        for(int i=0;i<str.length();i++){\\n            if(i%2==0  && str[i]==\\'1\\'){\\n                even++;\\n            }\\n            else if(i%2!=0 && str[i]==\\'1\\'){\\n                odd++;\\n            }\\n        }\\n        return{even,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string intToBinary(int num) {\\n        string binary;\\n        if (num == 0) {\\n            binary = \"0\";\\n        } else {\\n            while (num > 0) {\\n                binary = char(\\'0\\' + (num % 2)) + binary;\\n                num /= 2;\\n            }\\n        }\\n        return binary;\\n    }\\n    vector<int> evenOddBit(int n) {\\n        string str=intToBinary(n);\\n        reverse(str.begin(),str.end());\\n        int even=0;\\n        int odd=0;\\n        for(int i=0;i<str.length();i++){\\n            if(i%2==0  && str[i]==\\'1\\'){\\n                even++;\\n            }\\n            else if(i%2!=0 && str[i]==\\'1\\'){\\n                odd++;\\n            }\\n        }\\n        return{even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887480,
                "title": "python-simplest-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        s = bin(n)[2:][::-1]\\n        odd, even = 0, 0\\n        for index, i in enumerate (s):\\n            if i == \"1\" and index %2 == 0:\\n                even += 1\\n            if i == \"1\" and index %2 != 0:\\n                odd += 1\\n        return [even, odd]\\n\\n\\n\\n        # one = s.count(\\'1\\')\\n        # if one % 2 == 0:\\n        #     return [one, 0]\\n        # else: return [0, one]\\n```\\n### Please upvote if you like my solution",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        s = bin(n)[2:][::-1]\\n        odd, even = 0, 0\\n        for index, i in enumerate (s):\\n            if i == \"1\" and index %2 == 0:\\n                even += 1\\n            if i == \"1\" and index %2 != 0:\\n                odd += 1\\n        return [even, odd]\\n\\n\\n\\n        # one = s.count(\\'1\\')\\n        # if one % 2 == 0:\\n        #     return [one, 0]\\n        # else: return [0, one]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885913,
                "title": "100-fast-solution-in-one-line",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        return {__builtin_popcount(n & 0b0101010101), __builtin_popcount(n & 0b1010101010)};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        return {__builtin_popcount(n & 0b0101010101), __builtin_popcount(n & 0b1010101010)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875797,
                "title": "intuitive-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        String str = Integer.toBinaryString(n);\\n        StringBuilder sb = new StringBuilder(str);\\n        sb.reverse();\\n        String s = sb.toString();\\n\\n        int even=0, odd=0;\\n        for(int i=0; i<s.length(); i++) {\\n            if(i%2==0 && s.charAt(i) == \\'1\\') even++;\\n            else if(i%2!=0 && s.charAt(i) == \\'1\\') odd++;\\n        }\\n\\n        return new int[]{even, odd};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        String str = Integer.toBinaryString(n);\\n        StringBuilder sb = new StringBuilder(str);\\n        sb.reverse();\\n        String s = sb.toString();\\n\\n        int even=0, odd=0;\\n        for(int i=0; i<s.length(); i++) {\\n            if(i%2==0 && s.charAt(i) == \\'1\\') even++;\\n            else if(i%2!=0 && s.charAt(i) == \\'1\\') odd++;\\n        }\\n\\n        return new int[]{even, odd};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871258,
                "title": "simple-java-solution-using-bit-manipulation",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        \\n        int i = 0;\\n        int odd = 0,even = 0;\\n        while(n > 0)\\n        {\\n           //Cheking the right most bit if its 1 and also at even    index the even will be incresed\\n            if((n & 1) == 1 && i % 2 == 0)\\n            {\\n                even++;\\n            }\\n//Cheking the right most bit if its 1 and also at  odd index the odd will be incresed\\n             if((n & 1) == 1 && i % 2 != 0)\\n            {\\n                odd++;\\n            }\\n            i++;\\n         // n will right shift 1 times and rmb become changed \\n            n = n >> 1;\\n        }\\n       \\n        return new int []{even,odd};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        \\n        int i = 0;\\n        int odd = 0,even = 0;\\n        while(n > 0)\\n        {\\n           //Cheking the right most bit if its 1 and also at even    index the even will be incresed\\n            if((n & 1) == 1 && i % 2 == 0)\\n            {\\n                even++;\\n            }\\n//Cheking the right most bit if its 1 and also at  odd index the odd will be incresed\\n             if((n & 1) == 1 && i % 2 != 0)\\n            {\\n                odd++;\\n            }\\n            i++;\\n         // n will right shift 1 times and rmb become changed \\n            n = n >> 1;\\n        }\\n       \\n        return new int []{even,odd};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861970,
                "title": "while-loop-vs-one-line-of-code",
                "content": "## While loop\\n![image.png](https://assets.leetcode.com/users/images/0bd104b4-7160-439a-8e8c-bf254bd7d681_1691139589.4202158.png)\\n\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        result = [0, 0, 0]\\n        bit_pos = 1\\n        while n:\\n            n, rem = divmod(n, 2)\\n            result[bit_pos] += rem\\n            bit_pos *= -1\\n        return result[1:]\\n```\\n\\n## One line of code\\n![image.png](https://assets.leetcode.com/users/images/264a1f3a-f306-4c56-b3d8-7f26464be1ba_1691139643.2703006.png)\\n\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        return [bin(n)[-1:1:-2].count(\"1\"), bin(n)[-2:1:-2].count(\"1\")]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        result = [0, 0, 0]\\n        bit_pos = 1\\n        while n:\\n            n, rem = divmod(n, 2)\\n            result[bit_pos] += rem\\n            bit_pos *= -1\\n        return result[1:]\\n```\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        return [bin(n)[-1:1:-2].count(\"1\"), bin(n)[-2:1:-2].count(\"1\")]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860435,
                "title": "swift-one-liner-o-1-time-o-1-space",
                "content": "Sometimes the builtin functionality of the Swift standard library makes it feel like I\\'m cheating...\\n\\nThis is $O(1)$ time as most modern CPUs have an instruction to do this. \\n\\n# Code\\n```\\nclass Solution {\\n    func evenOddBit(_ n: Int) -> [Int] {\\n        [(n & 0x55555555).nonzeroBitCount, (n & 0xaaaaaaaa).nonzeroBitCount]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func evenOddBit(_ n: Int) -> [Int] {\\n        [(n & 0x55555555).nonzeroBitCount, (n & 0xaaaaaaaa).nonzeroBitCount]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852411,
                "title": "python-easy-clean-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        res = [0, 0]\\n        for i, v in enumerate(bin(n)[2:][::-1]):\\n            if v == \\'1\\':\\n                if i % 2 == 0:\\n                    res[0] += 1\\n                else:\\n                    res[1] += 1\\n        return res\\n```\\n![catty.png](https://assets.leetcode.com/users/images/a3ec0297-9ad0-465d-acec-fbe614712ae0_1690968826.1296113.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        res = [0, 0]\\n        for i, v in enumerate(bin(n)[2:][::-1]):\\n            if v == \\'1\\':\\n                if i % 2 == 0:\\n                    res[0] += 1\\n                else:\\n                    res[1] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851679,
                "title": "java-1ms-beats-100-00",
                "content": "# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n\\n        int[] answer = new int[2];  // what we\\'ll return\\n        int[] powersOfTwo = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1};\\n\\n        for (int i = 0; i < powersOfTwo.length; ++i) {\\n            if (n >= powersOfTwo[i]) {\\n                ++answer[i % 2];\\n                n -= powersOfTwo[i];\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n\\n        int[] answer = new int[2];  // what we\\'ll return\\n        int[] powersOfTwo = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1};\\n\\n        for (int i = 0; i < powersOfTwo.length; ++i) {\\n            if (n >= powersOfTwo[i]) {\\n                ++answer[i % 2];\\n                n -= powersOfTwo[i];\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842871,
                "title": "easy-solution-o-1-space-complexity",
                "content": "```\\nclass Solution {\\n\\tpublic:\\n    vector<int> evenOddBit(int n) {\\n        int ev=n;               //Starting from even bit 0th\\n        int od=n>>1;       //Starting from odd bit 1st\\n        int even=0,odd=0;\\n        while(ev){\\n            if((ev&1))even++;        //increase the count if bit is on\\n            ev=ev>>2;          //after 0 even bit is 2 so shift by 2\\n        }\\n         while(od){\\n            if((od&1))odd++;        //increase the count if bit is on\\n            od=od>>2;         //after 1 odd is 3 so shift by 2\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic:\\n    vector<int> evenOddBit(int n) {\\n        int ev=n;               //Starting from even bit 0th\\n        int od=n>>1;       //Starting from odd bit 1st\\n        int even=0,odd=0;\\n        while(ev){\\n            if((ev&1))even++;        //increase the count if bit is on\\n            ev=ev>>2;          //after 0 even bit is 2 so shift by 2\\n        }\\n         while(od){\\n            if((od&1))odd++;        //increase the count if bit is on\\n            od=od>>2;         //after 1 odd is 3 so shift by 2\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839304,
                "title": "java-beats-bit-manipulation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int even=0,odd=0,count=0;\\n        while(n >0){\\n            if((n & 1)== 1 && count%2==0) even++;\\n            if((n & 1)== 1 && count%2!=0) odd++;\\n            count++;\\n            n >>=1;\\n        }\\n       return new int []{even,odd}; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int even=0,odd=0,count=0;\\n        while(n >0){\\n            if((n & 1)== 1 && count%2==0) even++;\\n            if((n & 1)== 1 && count%2!=0) odd++;\\n            count++;\\n            n >>=1;\\n        }\\n       return new int []{even,odd}; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836008,
                "title": "91-beats-easy-solution",
                "content": "# Intuition:\\nThe problem aims to count the number of even and odd bits in the binary representation of a given integer `n`. To achieve this, we need to traverse through the binary digits of `n`, keeping track of the count of even and odd bits.\\n\\n# Approach:\\n1. Initialize two counters: `evencount` and `oddcount`, both set to 0, which will keep track of the number of even and odd bits, respectively.\\n2. Initialize a variable `iteration` set to 0, which will help us determine the position of the bit we are currently processing (0-based index).\\n3. Traverse through the binary digits of `n` using the right-shift operation and bitwise AND with 1.\\n4. Check the remainder (`rem`) obtained from the above step:\\n   - If `rem` is 1 and `iteration` is even, increment `evencount`, as it indicates an even bit.\\n   - If `rem` is 1 and `iteration` is odd, increment `oddcount`, as it indicates an odd bit.\\n   - For any other value of `rem`, no action is needed as it corresponds to a 0 bit.\\n5. Increment the `iteration` to process the next bit.\\n6. Continue the above steps until `n` becomes 0, i.e., all bits are processed.\\n7. Return the counts of even and odd bits as the result in an array.\\n\\n# Time Complexity:\\nThe time complexity of the solution is O(log n) because the number of iterations required to traverse through the binary representation of `n` is proportional to the number of bits in `n`. As `n` grows, the number of bits it requires increases logarithmically. Therefore, the time complexity is logarithmic in the input `n`.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        \\n        int[] res = new int[2];\\n\\n        int evencount = 0;\\n        int oddcount = 0;\\n        int iteration = 0;\\n        while(n>0){\\n            int rem = n % 2;\\n            if(rem == 1 && iteration%2==0){\\n                evencount++;\\n                iteration++;\\n            }\\n            else if(rem == 1 && iteration%2==1){\\n                oddcount++;\\n                iteration++;\\n            }\\n            else{\\n                iteration++;\\n            }\\n            n = n/2;\\n        }\\n        res[0] = evencount;\\n        res[1] = oddcount;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        \\n        int[] res = new int[2];\\n\\n        int evencount = 0;\\n        int oddcount = 0;\\n        int iteration = 0;\\n        while(n>0){\\n            int rem = n % 2;\\n            if(rem == 1 && iteration%2==0){\\n                evencount++;\\n                iteration++;\\n            }\\n            else if(rem == 1 && iteration%2==1){\\n                oddcount++;\\n                iteration++;\\n            }\\n            else{\\n                iteration++;\\n            }\\n            n = n/2;\\n        }\\n        res[0] = evencount;\\n        res[1] = oddcount;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827482,
                "title": "standard-java-solution",
                "content": "### Theory\\nYou don\\'t need to count the bits from left to right. We can use bit manipulation and count from right to left.\\n\\n### Solution\\n```\\n    public int[] evenOddBit(int n) {\\n        int evens = 0, odds = 0, idx = 0;\\n        while (n > 0) {\\n            int lastBit = n & 1;\\n            if (lastBit == 1) {\\n                if (idx % 2 == 0) evens++;\\n                else odds++;\\n            }\\n            idx++;\\n            n = n >> 1;\\n        }\\n        \\n        return new int[] {evens, odds};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] evenOddBit(int n) {\\n        int evens = 0, odds = 0, idx = 0;\\n        while (n > 0) {\\n            int lastBit = n & 1;\\n            if (lastBit == 1) {\\n                if (idx % 2 == 0) evens++;\\n                else odds++;\\n            }\\n            idx++;\\n            n = n >> 1;\\n        }\\n        \\n        return new int[] {evens, odds};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823141,
                "title": "number-of-even-and-odd-bits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        int ce1 = 0;\\n        int co1 = 0;\\n        while(n>0)\\n        {\\n            arr.add(n%2);\\n            n=n/2;\\n        }\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            if(i%2==0&&arr.get(i)==1)\\n            ce1++;\\n            else if(i%2==1&&arr.get(i)==1)\\n            co1++;\\n        }\\n        int[] a = new int[2];\\n        a[0] = ce1;\\n        a[1] = co1;\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        int ce1 = 0;\\n        int co1 = 0;\\n        while(n>0)\\n        {\\n            arr.add(n%2);\\n            n=n/2;\\n        }\\n        for(int i=arr.size()-1;i>=0;i--)\\n        {\\n            if(i%2==0&&arr.get(i)==1)\\n            ce1++;\\n            else if(i%2==1&&arr.get(i)==1)\\n            co1++;\\n        }\\n        int[] a = new int[2];\\n        a[0] = ce1;\\n        a[1] = co1;\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823132,
                "title": "easy-java-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int ans[]=new int[2];\\n        int k=0;\\n        int even=0;\\n        int odd=0;\\n        while(n!=0){\\n            int p=1&n;\\n            if(p>0&&k%2==0)even++;\\n            if(p>0&&k%2!=0)odd++;\\n            n=n>>>1;\\n            k++;\\n        }\\n        ans[0]=even;\\n        ans[1]=odd;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int ans[]=new int[2];\\n        int k=0;\\n        int even=0;\\n        int odd=0;\\n        while(n!=0){\\n            int p=1&n;\\n            if(p>0&&k%2==0)even++;\\n            if(p>0&&k%2!=0)odd++;\\n            n=n>>>1;\\n            k++;\\n        }\\n        ans[0]=even;\\n        ans[1]=odd;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817528,
                "title": "java-simple-rotate-flag-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNo need to use modulus when you can just use a boolean to increment the counters\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        boolean rotate = false;\\n        int even = 0, odd = 0;\\n        while(n != 0){\\n            int evenOrOdd = n & 1;\\n            if(!rotate && evenOrOdd == 1) even++;\\n            if(rotate && evenOrOdd == 1) odd++;\\n            n >>>= 1;\\n            rotate = !rotate;\\n        }\\n        return new int[]{even, odd};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        boolean rotate = false;\\n        int even = 0, odd = 0;\\n        while(n != 0){\\n            int evenOrOdd = n & 1;\\n            if(!rotate && evenOrOdd == 1) even++;\\n            if(rotate && evenOrOdd == 1) odd++;\\n            n >>>= 1;\\n            rotate = !rotate;\\n        }\\n        return new int[]{even, odd};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815637,
                "title": "easy-python-solution-bruteforce-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        binary = bin(n)\\n        even = 0\\n        odd = 0\\n        binary = str(binary)\\n        binary = binary[::-1]\\n        for i in range(len(str(binary))):\\n            if binary[i] == \"1\" and i % 2 == 0:\\n                even += 1\\n            elif binary[i] == \"1\" and i % 2 == 1:\\n                odd += 1\\n        return [even,odd]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evenOddBit(self, n: int) -> List[int]:\\n        binary = bin(n)\\n        even = 0\\n        odd = 0\\n        binary = str(binary)\\n        binary = binary[::-1]\\n        for i in range(len(str(binary))):\\n            if binary[i] == \"1\" and i % 2 == 0:\\n                even += 1\\n            elif binary[i] == \"1\" and i % 2 == 1:\\n                odd += 1\\n        return [even,odd]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813378,
                "title": "easy-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> bin(int n)\\n    {\\n        vector<int> ans;\\n        while(n>0)\\n        {\\n            ans.push_back(n%2);\\n            n/=2;\\n        }\\n        //reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    vector<int> evenOddBit(int n) {\\n        vector<int> binary=bin(n);\\n        int even=0, odd=0;\\n        for(int i=0; i<binary.size(); i++)\\n        {\\n            if(binary[i]==1)\\n            {\\n                if(i%2==0)\\n                    even++;\\n                else\\n                    odd++;\\n            }\\n        }\\n        return {even, odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> bin(int n)\\n    {\\n        vector<int> ans;\\n        while(n>0)\\n        {\\n            ans.push_back(n%2);\\n            n/=2;\\n        }\\n        //reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    vector<int> evenOddBit(int n) {\\n        vector<int> binary=bin(n);\\n        int even=0, odd=0;\\n        for(int i=0; i<binary.size(); i++)\\n        {\\n            if(binary[i]==1)\\n            {\\n                if(i%2==0)\\n                    even++;\\n                else\\n                    odd++;\\n            }\\n        }\\n        return {even, odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813264,
                "title": "easy-c-solution-using-bit-wise-operator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        \\n        int even = 0, odd = 0;\\n        int count = 0;\\n        \\n        while( n>0 )\\n        {\\n            if( (n&1)>0 && (count%2 == 0))\\n            {\\n                even++;\\n            }\\n            else if( (n&1)>0 && (count%2 != 0))\\n            {\\n                odd++;\\n            }\\n            count++;\\n            n = (n>>1);\\n        }\\n         return vector<int>{even,odd};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        \\n        int even = 0, odd = 0;\\n        int count = 0;\\n        \\n        while( n>0 )\\n        {\\n            if( (n&1)>0 && (count%2 == 0))\\n            {\\n                even++;\\n            }\\n            else if( (n&1)>0 && (count%2 != 0))\\n            {\\n                odd++;\\n            }\\n            count++;\\n            n = (n>>1);\\n        }\\n         return vector<int>{even,odd};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812921,
                "title": "simple-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int o=0,e=0;\\n        while(n){\\n            if(n&1)e++;\\n            n>>=1;\\n            if(n==0)break;\\n            if(n&1)o++;\\n            n>>=1;\\n        }\\n        return {e,o};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int o=0,e=0;\\n        while(n){\\n            if(n&1)e++;\\n            n>>=1;\\n            if(n==0)break;\\n            if(n&1)o++;\\n            n>>=1;\\n        }\\n        return {e,o};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800029,
                "title": "c-easy-to-understand-two-solutions-beats-runtime-94-memory-52",
                "content": "# First Solution\\n![image.png](https://assets.leetcode.com/users/images/c030fe8d-2a84-426c-8c52-e8ef58619278_1690014811.6499333.png)\\n\\n# Approach\\nThis code uses bitwise operations to directly access the bits of the integer n. The while loop iterates through each bit of n from right to left. The expression (n & 1) checks if the least significant bit of n is 1. If it is, the corresponding element in the returnValue array is incremented. The index variable keeps track of the position of the current bit, and is used to determine whether to increment the first or second element of the returnValue array. Finally, the n >>= 1 operation shifts the bits of n to the right by one position, effectively removing the least significant bit.\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] EvenOddBit(int n) {\\n        int[] returnValue = new int[2];\\n        int index = 0;\\n        while (n > 0)\\n        {\\n            if ((n & 1) == 1)\\n            {\\n                returnValue[index % 2]++;\\n            }\\n            index++;\\n            n >>= 1;\\n        }\\n        \\n        return returnValue;\\n    }\\n}\\n```\\n\\n\\n# Second Solution\\n![image.png](https://assets.leetcode.com/users/images/ace095c8-5084-4214-a4fa-b7b12218b98e_1690015028.898001.png)\\n\\n\\n# Approach\\nThe code first converts the integer n to its binary representation using the Convert.ToString method, with the second argument specifying the base (2 for binary). The code then iterates through the binary string in reverse order, starting from the last character. For each character, if it is \\u20181\\u2019, the code increments the corresponding element in the returnValue array. The index of the element to increment is determined by calculating the position of the current bit from the right side of the binary string, and taking its remainder when divided by 2. If the position is even, the first element of the returnValue array is incremented; if it is odd, the second element is incremented.\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] EvenOddBit(int n) {\\n        int[] retunrValue = new int[2];\\n        string bits = Convert.ToString(n, 2);\\n        for (int i = bits.Length - 1; i >= 0; i--)\\n        {\\n            if (bits[i] == \\'1\\')\\n            {\\n                retunrValue[(bits.Length - 1 - i) % 2]++;\\n            }\\n        }\\n\\n        return retunrValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] EvenOddBit(int n) {\\n        int[] returnValue = new int[2];\\n        int index = 0;\\n        while (n > 0)\\n        {\\n            if ((n & 1) == 1)\\n            {\\n                returnValue[index % 2]++;\\n            }\\n            index++;\\n            n >>= 1;\\n        }\\n        \\n        return returnValue;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int[] EvenOddBit(int n) {\\n        int[] retunrValue = new int[2];\\n        string bits = Convert.ToString(n, 2);\\n        for (int i = bits.Length - 1; i >= 0; i--)\\n        {\\n            if (bits[i] == \\'1\\')\\n            {\\n                retunrValue[(bits.Length - 1 - i) % 2]++;\\n            }\\n        }\\n\\n        return retunrValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783341,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0, odd = 0;\\n        int size = -1, m = n;\\n\\n        while(m){\\n            size++;\\n            m = m >> 1;\\n        }\\n\\n        int k = 0;\\n        while(n && k<=size){\\n            if(n&1 && k%2==0) even++;\\n            else if(n&1 && k%2!=0) odd++;\\n            k++;\\n            n = n >> 1;\\n        }\\n\\n        return {even, odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even = 0, odd = 0;\\n        int size = -1, m = n;\\n\\n        while(m){\\n            size++;\\n            m = m >> 1;\\n        }\\n\\n        int k = 0;\\n        while(n && k<=size){\\n            if(n&1 && k%2==0) even++;\\n            else if(n&1 && k%2!=0) odd++;\\n            k++;\\n            n = n >> 1;\\n        }\\n\\n        return {even, odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779970,
                "title": "qs-2595-easy-java-solution-beats-93-53-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int sum=0,rem=0,counter=0;\\n        while(n>0){\\n            rem=n%2;\\n            sum=(int)(sum+(rem*Math.pow(10,counter)));\\n            counter++;\\n            n=n/2;\\n        }\\n        int oddEven[]=new int[2];\\n        counter=0;\\n        while(sum>0){\\n            rem=sum%10;\\n            if(counter%2==0 && rem==1)\\n            oddEven[0]++;\\n            if(counter%2!=0 && rem==1)\\n            oddEven[1]++;\\n            sum/=10;\\n            counter++;\\n        }\\n        return oddEven;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int sum=0,rem=0,counter=0;\\n        while(n>0){\\n            rem=n%2;\\n            sum=(int)(sum+(rem*Math.pow(10,counter)));\\n            counter++;\\n            n=n/2;\\n        }\\n        int oddEven[]=new int[2];\\n        counter=0;\\n        while(sum>0){\\n            rem=sum%10;\\n            if(counter%2==0 && rem==1)\\n            oddEven[0]++;\\n            if(counter%2!=0 && rem==1)\\n            oddEven[1]++;\\n            sum/=10;\\n            counter++;\\n        }\\n        return oddEven;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779462,
                "title": "best-approch-best-cases-in-terms-of-time-complexity-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n         int[] arr = new int[2];\\n        for(int i =0;i<32;i++){\\n            if((n&1) == 1){\\n                arr[i % 2 == 0 ? 0 : 1]++;\\n            }\\n            n>>=1;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n         int[] arr = new int[2];\\n        for(int i =0;i<32;i++){\\n            if((n&1) == 1){\\n                arr[i % 2 == 0 ? 0 : 1]++;\\n            }\\n            n>>=1;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779269,
                "title": "100-beats-in-java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] arr = new int[2];\\n        for(int i =0;i<32;i++){\\n            if((n&1) == 1){\\n                arr[i % 2 == 0 ? 0 : 1]++;\\n            }\\n            n>>=1;\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] arr = new int[2];\\n        for(int i =0;i<32;i++){\\n            if((n&1) == 1){\\n                arr[i % 2 == 0 ? 0 : 1]++;\\n            }\\n            n>>=1;\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778035,
                "title": "100-faster-solution-o-1-space-o-no-of-bits-in-a-number-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBit Manipulation\\nBeats 100.00% in time complexity\\nBeats 96.70% in space complexity\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(no.of bits in a number)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even=0,odd=0,count=0;\\n        while(n>0)\\n        {\\n            if(n&1==1)    (count%2==0)?even++:odd++;\\n            count++;\\n            n=n>>1;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        int even=0,odd=0,count=0;\\n        while(n>0)\\n        {\\n            if(n&1==1)    (count%2==0)?even++:odd++;\\n            count++;\\n            n=n>>1;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775870,
                "title": "java-solution-3ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        String ans = \"\";\\n        while(n!=0){\\n            ans =  ans + String.valueOf(n%2);\\n            n = n/2;\\n        }\\n        int[] arr = new int[2];\\n        arr[0] = 0;\\n        arr[1] = 0;\\n        for(int i=0;i<ans.length();i++){\\n            if(ans.charAt(i)==\\'1\\' && i%2==0){\\n                arr[0]++;\\n            }\\n            else if(ans.charAt(i)==\\'1\\' && i%2==1){\\n                arr[1]++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        String ans = \"\";\\n        while(n!=0){\\n            ans =  ans + String.valueOf(n%2);\\n            n = n/2;\\n        }\\n        int[] arr = new int[2];\\n        arr[0] = 0;\\n        arr[1] = 0;\\n        for(int i=0;i<ans.length();i++){\\n            if(ans.charAt(i)==\\'1\\' && i%2==0){\\n                arr[0]++;\\n            }\\n            else if(ans.charAt(i)==\\'1\\' && i%2==1){\\n                arr[1]++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775869,
                "title": "c-solution-3ms-runtime-72-91-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        string ans = \"\";\\n        while(n!=0){\\n            ans =  ans + to_string(n%2);\\n            n = n/2;\\n        }\\n        vector<int> arr(2,0);\\n        for(int i=0;i<ans.length();i++){\\n            if(ans[i]==\\'1\\' && i%2==0){\\n                arr[0]++;\\n            }\\n            else if(ans[i]==\\'1\\' && i%2==1){\\n                arr[1]++;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) {\\n        string ans = \"\";\\n        while(n!=0){\\n            ans =  ans + to_string(n%2);\\n            n = n/2;\\n        }\\n        vector<int> arr(2,0);\\n        for(int i=0;i<ans.length();i++){\\n            if(ans[i]==\\'1\\' && i%2==0){\\n                arr[0]++;\\n            }\\n            else if(ans[i]==\\'1\\' && i%2==1){\\n                arr[1]++;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768966,
                "title": "java-easy-bit-manipulation-100-beats",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(no.of bits)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int num = n, ec = 0, oc = 0;\\n        boolean even = true;\\n        while(num!=0){\\n            if(even){\\n               ec += ((num & 1) == 1)? 1 : 0;\\n            }\\n            else{\\n               oc += ((num & 1) == 1) ? 1 : 0;\\n            }\\n            num>>=1;\\n            even = !even;\\n        }\\n        return (new int[]{ec,oc});\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int num = n, ec = 0, oc = 0;\\n        boolean even = true;\\n        while(num!=0){\\n            if(even){\\n               ec += ((num & 1) == 1)? 1 : 0;\\n            }\\n            else{\\n               oc += ((num & 1) == 1) ? 1 : 0;\\n            }\\n            num>>=1;\\n            even = !even;\\n        }\\n        return (new int[]{ec,oc});\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767074,
                "title": "easy-java-solution-1ms-beats-100-bit-manipulation",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] arr=new int[2];\\n        for(int i=0;i<10;i++)\\n        {\\n            if( ( ( n >> i) & 1) == 1)\\n            {\\n                arr[i%2]++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] evenOddBit(int n) {\\n        int[] arr=new int[2];\\n        for(int i=0;i<10;i++)\\n        {\\n            if( ( ( n >> i) & 1) == 1)\\n            {\\n                arr[i%2]++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751184,
                "title": "beginner-friendly-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) \\n    {\\n        int odd=0;\\n        int even=0;\\n        int count=0;\\n        while(n!=0)\\n        {\\n            if(n&1==1 && count%2==0)\\n            {\\n                even++;\\n            }\\n            else if(n&1==1 && count%2!=0)\\n            {\\n                odd++;\\n            }\\n            n=n>>1;\\n            count++;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> evenOddBit(int n) \\n    {\\n        int odd=0;\\n        int even=0;\\n        int count=0;\\n        while(n!=0)\\n        {\\n            if(n&1==1 && count%2==0)\\n            {\\n                even++;\\n            }\\n            else if(n&1==1 && count%2!=0)\\n            {\\n                odd++;\\n            }\\n            n=n>>1;\\n            count++;\\n        }\\n        return {even,odd};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749297,
                "title": "very-fast-js-solution",
                "content": "# Very Fast Solution Using Bits Manipulation\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA fast bit manipulation problem solution involves using bitwitse and,shift right operators to efficiently manipulate the bits of the input data\\n\\n# Complexity\\n- Time complexity:Number of Digits in Number :)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nfunction getBit(num, idx) {\\n  num = num >> idx;\\n  return num & 1;\\n}\\nvar evenOddBit = function(n) {\\n    let odd= 0,even = 0,idx = 0;\\n    while(n){\\n        if(getBit(n,0) == 1){\\n            if(idx%2 == 0)even++;\\n            else odd++;\\n        }\\n        n >>=1;\\n        idx++;\\n    }\\n    return [even,odd]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nfunction getBit(num, idx) {\\n  num = num >> idx;\\n  return num & 1;\\n}\\nvar evenOddBit = function(n) {\\n    let odd= 0,even = 0,idx = 0;\\n    while(n){\\n        if(getBit(n,0) == 1){\\n            if(idx%2 == 0)even++;\\n            else odd++;\\n        }\\n        n >>=1;\\n        idx++;\\n    }\\n    return [even,odd]\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1838392,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1836951,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1836863,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1841132,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1836975,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1843127,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1877387,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1837252,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1836837,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 2007919,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1838392,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1836951,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1836863,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1841132,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1836975,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1843127,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1877387,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1837252,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 1836837,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            },
            {
                "id": 2007919,
                "content": [
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is uncleared, the example 1 and 2 conflicts logic. example 1 start index from 0, example 2 start index from 1 and can not complete this question."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  thanks for your reply. My brain is open for new knowledge, this is really cool answer, I really appricate that."
                    },
                    {
                        "username": "shin_98",
                        "content": "[@khangnguyen0318](/khangnguyen0318) Do you know what is \"least signifcant bit\"? https://en.wikipedia.org/wiki/Bit_numbering\\n\\nFor me it\\'s \"natural\" (? I don\\'t know how to describe it) that you count bits from \"least significant\" to \"most significant\". So you don\\'t have to \"reverse\" bits per se, but just count in proper way."
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "[@shin_98](/shin_98)  My misstake about the reverse case. But, how do you know this question should reverse the bits? Because the question is not telling that, and we should understand the example"
                    },
                    {
                        "username": "shin_98",
                        "content": "It\\'s clear. It\\'s all about \"least significant bit\" which is on right most side.\\nIf in example 1, index starts from 0, maybe in example 2 it starts from 0 too?\\nIf so, then you can easly determine that 0 index is on right.\\nBut even without exaples, when you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "bgelov",
                        "content": "It is not clear why it is necessary to go from the last index to the first. It looks like secret knowledge. "
                    },
                    {
                        "username": "bgelov",
                        "content": "[@shin_98](/shin_98) Thanks for the clarification! In any case, there\\'s an upside from questions like this, that you\\'ll always remember that it works that way :)"
                    },
                    {
                        "username": "shin_98",
                        "content": "Not really. When you write a number, you write \"8\". It\\'s eight. When you want to write seventy eight, where do you \"add\" seven to represent \"next\" digit?\\nIn front of eight: \"78\".  In binary it\\'s \"least significant bit\". In general it\\'s \"least significant digit\" and it\\'s on the right side.\\nSo you have to start with \"least significant bit\" because it\\'s index is 0."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Why is everyone reversing the binary number?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@shin_98](/shin_98)  yes didn\\'t think in this way. But it really makes sense.  Thanks. "
                    },
                    {
                        "username": "shin_98",
                        "content": "[@arvindkumarrao](/arvindkumarrao) It doesn\\'t have to be mentioned, because it\\'s \"least significant bit\". It\\'s always on the right.\\nWhen you want to convert big number in binary to decimal with pen and paper, on which didgit do you start?\\n\"10000111100101100\" if i got this number, i start on right, because regardless of it\\'s length, it always starts with 2^0 on the right\\nIf you would like to start on left, you would have to count number of digits first, and then determine power of 2^N, on the left most side."
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "[@prem_2111](/prem_2111) \\n\\nFrom Example 2:\\n\\nInput: n = 2\\nOutput: [0,1]\\nExplanation: The binary representation of 2 is 10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n"
                    },
                    {
                        "username": "prem_1121",
                        "content": "[@arvindkumarrao](/arvindkumarrao) \\nHow do you know they are considering index from right to left?"
                    },
                    {
                        "username": "arvindkumarrao",
                        "content": "because they are considering indexes from right side not left. But no where in problem it is mentioned. (except example)"
                    },
                    {
                        "username": "user2285TI",
                        "content": "Note: Indices of binary representations start from the right. I think the first example is a bad example as it reaffirms our misunderstanding that indexing would start from the left. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "Question is incomplete ? or not ?\\nNot properly explained..."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@rmramkumar](/rmramkumar)  Hello, when dealing with binary representation of numbers or any other symbols, the indexing starts from the right side."
                    },
                    {
                        "username": "rmramkumar",
                        "content": "the question seems to be wrong "
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how here \\n10.\\nIt contains 1 on the 1st index. \\nThere are 0 even and 1 odd indices.\\n\\n1 is in 0th index and 0 in 1 st index But in question why like that ?\\n"
                    },
                    {
                        "username": "prithvivarma-nallapuraju",
                        "content": "I am also having the same doubt"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int odd=0,even=0,count=1;\n        while(n!=0){\n            int x=n&1;  // last bit LSB\n            count++; //counting to know the index / position\n            if(x==1){  \n                if(count%2==0) even++;\n                else odd++;\n            }\nn=n>>1;  //shifting\n        }\n        return {even,odd};\n    }\n}; "
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Please don\\'s post your solution"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "tip:\\nafter a fail run I think its counting from last to first \\nin case of 2 --> 10\\nhere 1st index is 1 when you count from last !!"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n- This problem can be done by performing a bitwise AND operation of the input integer n with two binary masks: 0x55555555 and 0xAAAAAAAA.\\n- The binary mask 0x55555555 has alternate bits set to 1 starting from the least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at even positions.\\n- The binary mask 0xAAAAAAAA has alternate bits set to 1 starting from the second least significant bit. Therefore, performing a bitwise AND operation of n with this mask extracts the set bits at odd positions.\\n- The number of set bits in the resulting binary representations are counted using the Integer.bitCount method, and the results are returned as an integer array containing the count of even and odd bits, respectively."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code:\\nhttps://leetcode.com/problems/number-of-even-and-odd-bits/solutions/3314064/java-one-liner/"
                    },
                    {
                        "username": "pa-one55",
                        "content": "used a vector for storing bits, and then did the counting"
                    }
                ]
            }
        ]
    }
]