[
    {
        "title": "Find Score of an Array After Marking All Elements",
        "question_content": "You are given an array nums consisting of positive integers.\nStarting with score = 0, apply the following algorithm:\n\n\tChoose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.\n\tAdd the value of the chosen integer to score.\n\tMark the chosen element and its two adjacent elements if they exist.\n\tRepeat until all the array elements are marked.\n\nReturn the score you get after applying the above algorithm.\n&nbsp;\nExample 1:\n\nInput: nums = [2,1,3,4,5,2]\nOutput: 7\nExplanation: We mark the elements as follows:\n- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2].\n- 2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2].\n- 4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2].\nOur score is 1 + 2 + 4 = 7.\n\nExample 2:\n\nInput: nums = [2,3,5,1,3,2]\nOutput: 5\nExplanation: We mark the elements as follows:\n- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2].\n- 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2].\n- 2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2].\nOur score is 1 + 2 + 2 = 5.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 106",
        "solutions": [
            {
                "id": 3312206,
                "title": "using-ordered-set-very-simple-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans = 0;\\n        set<pair<int, int>> st;\\n        for(int i = 0; i < nums.size(); ++i){ st.insert({nums[i], i}); }\\n        for(auto s: st){\\n            if(nums[s.second]) {\\n                nums[s.second] = 0;\\n                if(s.second - 1 >= 0) nums[s.second - 1] = 0;\\n                if(s.second + 1 < nums.size()) nums[s.second + 1] = 0;\\n                ans += s.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans = 0;\\n        set<pair<int, int>> st;\\n        for(int i = 0; i < nums.size(); ++i){ st.insert({nums[i], i}); }\\n        for(auto s: st){\\n            if(nums[s.second]) {\\n                nums[s.second] = 0;\\n                if(s.second - 1 >= 0) nums[s.second - 1] = 0;\\n                if(s.second + 1 < nums.size()) nums[s.second + 1] = 0;\\n                ans += s.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312034,
                "title": "python-simulation",
                "content": "# **Explanation**\\nSorted the element by the value and index.\\nFor each `A[i]`, check it\\'s visited `seen[i]`.\\nIf not yet, update `res += a`,\\nand mark `seen[i] = seen[i - 1] = seen[i + 1] = 1`.\\nFinally return `res`.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Python**\\n```py\\n    def findScore(self, A: List[int]) -> int:\\n        seen = [0] * (len(A) + 1)\\n        res = 0\\n        for a,i in sorted([a,i] for i,a in enumerate(A)):\\n            if seen[i]: continue\\n            res += a\\n            seen[i] = seen[i - 1] = seen[i + 1] = 1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def findScore(self, A: List[int]) -> int:\\n        seen = [0] * (len(A) + 1)\\n        res = 0\\n        for a,i in sorted([a,i] for i,a in enumerate(A)):\\n            if seen[i]: continue\\n            res += a\\n            seen[i] = seen[i - 1] = seen[i + 1] = 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3312059,
                "title": "java-priorityqueue-easy-to-understand",
                "content": "```\\nclass Pair{\\n    int num;\\n    int index;\\n    Pair(int num, int index)\\n    { this.num = num; this.index = index; }\\n}\\nclass Solution {\\n    public long findScore(int[] nums) \\n    {\\n        int n = nums.length;\\n        PriorityQueue<Pair>pq = new PriorityQueue<Pair>((Pair a, Pair b)->{\\n            if (a.num != b.num) return (a.num - b.num);\\n            else return (a.index - b.index);\\n        });\\n        for (int i = 0; i < nums.length; i++ ) pq.add(new Pair(nums[i], i));\\n        boolean[] marked = new boolean[n];\\n        \\n        long ans = 0;\\n        while(!pq.isEmpty())\\n        {\\n            int currNum = pq.peek().num;\\n            int currIdx = pq.peek().index;\\n            pq.poll();\\n            if (marked[currIdx]) continue;\\n            \\n            ans += currNum;\\n            marked[currIdx] = true;\\n            if (currIdx + 1 < n) marked[currIdx + 1] = true;\\n            if (currIdx - 1 >= 0) marked[currIdx - 1] = true; \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Pair{\\n    int num;\\n    int index;\\n    Pair(int num, int index)\\n    { this.num = num; this.index = index; }\\n}\\nclass Solution {\\n    public long findScore(int[] nums) \\n    {\\n        int n = nums.length;\\n        PriorityQueue<Pair>pq = new PriorityQueue<Pair>((Pair a, Pair b)->{\\n            if (a.num != b.num) return (a.num - b.num);\\n            else return (a.index - b.index);\\n        });\\n        for (int i = 0; i < nums.length; i++ ) pq.add(new Pair(nums[i], i));\\n        boolean[] marked = new boolean[n];\\n        \\n        long ans = 0;\\n        while(!pq.isEmpty())\\n        {\\n            int currNum = pq.peek().num;\\n            int currIdx = pq.peek().index;\\n            pq.poll();\\n            if (marked[currIdx]) continue;\\n            \\n            ans += currNum;\\n            marked[currIdx] = true;\\n            if (currIdx + 1 < n) marked[currIdx + 1] = true;\\n            if (currIdx - 1 >= 0) marked[currIdx - 1] = true; \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312018,
                "title": "index-array",
                "content": "Index array is a common and important technique. \\n\\nIt allows you to iterate the number array in the sorted order, without changing the position of elements in the number array.\\n\\nNote that the sort compare function needs to compare indexes if values are the same. In C++, we can use `stable_sort` to do just that internally.\\n\\n**C++**\\n```cpp    \\nlong long findScore(vector<int>& n) {\\n    long long score = 0, sz = n.size();\\n    vector<int> id(sz);\\n    iota(begin(id), end(id), 0);\\n    stable_sort(begin(id), end(id), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int i : id)\\n        if (n[i]) {\\n            score += n[i];\\n            n[i] = n[min((int)sz - 1, i + 1)] = n[max(0, i - 1)] = 0;            \\n        }\\n    return score;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp    \\nlong long findScore(vector<int>& n) {\\n    long long score = 0, sz = n.size();\\n    vector<int> id(sz);\\n    iota(begin(id), end(id), 0);\\n    stable_sort(begin(id), end(id), [&](int i, int j){ return n[i] < n[j]; });\\n    for (int i : id)\\n        if (n[i]) {\\n            score += n[i];\\n            n[i] = n[min((int)sz - 1, i + 1)] = n[max(0, i - 1)] = 0;            \\n        }\\n    return score;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3312223,
                "title": "java-python-3-treeset",
                "content": "**Method 1: Use only TreeSet/SortedSet.**\\n\\n```java\\n    public long findScore(int[] nums) {\\n        TreeSet<List<Integer>> valIndex = new TreeSet<>(\\n            Comparator.comparingLong(l -> l.get(0) * 1_000_001L + l.get(1))\\n        );\\n        for (int i = 0; i < nums.length; ++i) {\\n            valIndex.add(Arrays.asList(nums[i], i));\\n        }\\n        long score = 0;\\n        while (!valIndex.isEmpty()) {\\n            var l = valIndex.pollFirst();\\n            int key = l.get(0), index = l.get(1);\\n            for (int neighborIndex : new int[]{index - 1, index + 1}) {\\n                if (0 <= neighborIndex && neighborIndex < nums.length) {\\n                    valIndex.remove(Arrays.asList(nums[neighborIndex], neighborIndex));\\n                }\\n            }\\n            score += key;\\n        }\\n        return score;\\n    }\\n```\\n\\n```python\\nfrom sortedcontainers import *\\n\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        val_index, score = SortedSet(), 0\\n        for i, num in enumerate(nums):\\n            val_index.add((num, i))\\n        while len(val_index) > 0:\\n            key, idx = val_index.pop(0)\\n            score += key\\n            for neighbor_index in idx - 1, idx + 1:    \\n                if 0 <= neighbor_index < len(nums):\\n                    val_index.discard((nums[neighbor_index], neighbor_index))\\n        return score\\n```\\n**Method 2: TreeMap + TreeSet**\\n\\n1. Traverse the input `nums`, use each value as the key of TreeMap, and put the corresponding index into TreeSet as the value of the TreeMap.\\n2. Add to the score the first key of the TreeMap, remove the smallest index of the first key; Then remove the neighbors (if any) of the index;\\n3. Repeat 2. till the TreeMap is empty, and return the score.\\n \\n```java\\n    public long findScore(int[] nums) {\\n        TreeMap<Integer, TreeSet<Integer>> indices = new TreeMap<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            indices.computeIfAbsent(nums[i], s -> new TreeSet<>()).add(i);\\n        }\\n        long score = 0;\\n        while (!indices.isEmpty()) {\\n            int key = indices.firstKey();\\n            int index = indices.get(key).pollFirst();\\n            removeIfEmpty(indices, key);\\n            for (int neighborIndex : new int[]{index - 1, index + 1}) {\\n                if (0 <= neighborIndex && neighborIndex < nums.length) {\\n                    int neighborValue = nums[neighborIndex];\\n                    if (indices.containsKey(neighborValue)) {\\n                        indices.get(neighborValue).remove(neighborIndex);\\n                        removeIfEmpty(indices, neighborValue);\\n                    }\\n                }\\n            }\\n            score += key;\\n        }\\n        return score;\\n    }\\n    private void removeIfEmpty(TreeMap<Integer, TreeSet<Integer>> indices, int key) {\\n        if (indices.get(key).isEmpty()) {\\n            indices.remove(key);\\n        }\\n    }\\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(n)`, where `n = nums.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long findScore(int[] nums) {\\n        TreeSet<List<Integer>> valIndex = new TreeSet<>(\\n            Comparator.comparingLong(l -> l.get(0) * 1_000_001L + l.get(1))\\n        );\\n        for (int i = 0; i < nums.length; ++i) {\\n            valIndex.add(Arrays.asList(nums[i], i));\\n        }\\n        long score = 0;\\n        while (!valIndex.isEmpty()) {\\n            var l = valIndex.pollFirst();\\n            int key = l.get(0), index = l.get(1);\\n            for (int neighborIndex : new int[]{index - 1, index + 1}) {\\n                if (0 <= neighborIndex && neighborIndex < nums.length) {\\n                    valIndex.remove(Arrays.asList(nums[neighborIndex], neighborIndex));\\n                }\\n            }\\n            score += key;\\n        }\\n        return score;\\n    }\\n```\n```python\\nfrom sortedcontainers import *\\n\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        val_index, score = SortedSet(), 0\\n        for i, num in enumerate(nums):\\n            val_index.add((num, i))\\n        while len(val_index) > 0:\\n            key, idx = val_index.pop(0)\\n            score += key\\n            for neighbor_index in idx - 1, idx + 1:    \\n                if 0 <= neighbor_index < len(nums):\\n                    val_index.discard((nums[neighbor_index], neighbor_index))\\n        return score\\n```\n```java\\n    public long findScore(int[] nums) {\\n        TreeMap<Integer, TreeSet<Integer>> indices = new TreeMap<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            indices.computeIfAbsent(nums[i], s -> new TreeSet<>()).add(i);\\n        }\\n        long score = 0;\\n        while (!indices.isEmpty()) {\\n            int key = indices.firstKey();\\n            int index = indices.get(key).pollFirst();\\n            removeIfEmpty(indices, key);\\n            for (int neighborIndex : new int[]{index - 1, index + 1}) {\\n                if (0 <= neighborIndex && neighborIndex < nums.length) {\\n                    int neighborValue = nums[neighborIndex];\\n                    if (indices.containsKey(neighborValue)) {\\n                        indices.get(neighborValue).remove(neighborIndex);\\n                        removeIfEmpty(indices, neighborValue);\\n                    }\\n                }\\n            }\\n            score += key;\\n        }\\n        return score;\\n    }\\n    private void removeIfEmpty(TreeMap<Integer, TreeSet<Integer>> indices, int key) {\\n        if (indices.get(key).isEmpty()) {\\n            indices.remove(key);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312103,
                "title": "easy-c-code-sorting-vector-pair-visited-or-not",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-->First create a vector of pair \"VP\" which stores the elements of given vector along with their indexes.\\n-->Sort VP\\n-->Create a Vector \"Check\" of the same size and initialize it with \"0\" value\\n-->Now traverse the \"VP\" and check if the index of the current element has been visited or not\\n-->If not then increment the answer by the value of current element and mark the element and it\\'s neighbouring indexes as visited.\\n\\n# Complexity\\n- Time complexity O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(pair<long long,long long>&a,pair<long long,long long>&b){\\n        if(a.first==b.first)return a.second<b.second;\\n        return a.first<b.first;\\n    }\\n    long long findScore(vector<int>&v) {\\n        long long i,n=v.size(),ans=0;\\n        vector<pair<long long,long long>>vp;\\n        for(i=0;i<n;i++)vp.push_back({v[i],i});\\n        sort(vp.begin(),vp.end(),comp);\\n        vector<int>check(n,0);\\n        for(i=0;i<n;i++){\\n            long long x = vp[i].first;\\n            long long y = vp[i].second;\\n            if(!check[y]){// check for those indexes only which we never visited earlier\\n                ans+=x;\\n                check[y]=1;// mark the value of current index y and it\\'s neighbour indexes. \\n                if(y-1>=0)check[y-1]=1;\\n                if(y+1<n)check[y+1]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<long long,long long>&a,pair<long long,long long>&b){\\n        if(a.first==b.first)return a.second<b.second;\\n        return a.first<b.first;\\n    }\\n    long long findScore(vector<int>&v) {\\n        long long i,n=v.size(),ans=0;\\n        vector<pair<long long,long long>>vp;\\n        for(i=0;i<n;i++)vp.push_back({v[i],i});\\n        sort(vp.begin(),vp.end(),comp);\\n        vector<int>check(n,0);\\n        for(i=0;i<n;i++){\\n            long long x = vp[i].first;\\n            long long y = vp[i].second;\\n            if(!check[y]){// check for those indexes only which we never visited earlier\\n                ans+=x;\\n                check[y]=1;// mark the value of current index y and it\\'s neighbour indexes. \\n                if(y-1>=0)check[y-1]=1;\\n                if(y+1<n)check[y+1]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312831,
                "title": "find-score-of-an-array-after-marking-all-elements-c-beginner-friendly-explained",
                "content": "# Intuition\\nJust do the implementation which is asked in the question.The tricky part is keep the record of the index. To keep the record of index we will use set of pairs.\\n\\n# Approach\\n1. Create a set of pairs to store the elements of the array with there indexes. \\n2. Create a visited array to mark the visited elements\\n3. Insert all the elements with there in set with there indexes\\n4. Iterate the set. Since set stores elements in sorted order first check if the element is visited or not. If the element is not visited then add the value of element to result and mark there adjacent elements as visited. Do this for all elements\\n5. At last return the result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n       \\n        int n = nums.size();\\n        set<pair<long long, long long>> st;\\n        vector<int> vis(n,0);\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            st.insert({nums[i],i});\\n        }\\n        \\n        long long result = 0;\\n        \\n        int i = 0;\\n        \\n       for(auto x: st)\\n       {\\n           int index = x.second;\\n           if(vis[index] == 0)\\n           {\\n               result += x.first;\\n               vis[index] = 1;\\n               if(index - 1 >= 0) vis[index-1] = 1;\\n               if(index + 1 < n) vis[index + 1] = 1;\\n           }\\n       }\\n        \\n       return result; \\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n       \\n        int n = nums.size();\\n        set<pair<long long, long long>> st;\\n        vector<int> vis(n,0);\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            st.insert({nums[i],i});\\n        }\\n        \\n        long long result = 0;\\n        \\n        int i = 0;\\n        \\n       for(auto x: st)\\n       {\\n           int index = x.second;\\n           if(vis[index] == 0)\\n           {\\n               result += x.first;\\n               vis[index] = 1;\\n               if(index - 1 >= 0) vis[index-1] = 1;\\n               if(index + 1 < n) vis[index + 1] = 1;\\n           }\\n       }\\n        \\n       return result; \\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312046,
                "title": "c-hashmap-to-store-positions-easy-40-time-20-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& v) {\\n      int n = v.size();\\n      map<int, vector<int>> mp;\\n      for(int i = 0; i < n; i++){\\n        mp[v[i]].emplace_back(i);\\n      }\\n      long long ans = 0;\\n      vector<bool> vis(n, false);\\n      for(auto &[f, s]: mp){\\n        for(auto &i: s){\\n          if(!vis[i]){\\n            ans += f;\\n            vis[i] = true;\\n            vis[max(i - 1, 0)] = true;\\n            vis[min(i + 1, n - 1)] = true;\\n          }\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& v) {\\n      int n = v.size();\\n      map<int, vector<int>> mp;\\n      for(int i = 0; i < n; i++){\\n        mp[v[i]].emplace_back(i);\\n      }\\n      long long ans = 0;\\n      vector<bool> vis(n, false);\\n      for(auto &[f, s]: mp){\\n        for(auto &i: s){\\n          if(!vis[i]){\\n            ans += f;\\n            vis[i] = true;\\n            vis[max(i - 1, 0)] = true;\\n            vis[min(i + 1, n - 1)] = true;\\n          }\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319284,
                "title": "c-map-sort",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& a) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<a.size();i++){\\n            v.push_back({a[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        map<int,int>m;\\n        int tt=0;\\n        long long ans=0;\\n        for(int i=0;i<v.size();i++){\\n              if(!m[v[i].second]){\\n                  tt++;\\n                  m[v[i].second]++;\\n                  ans += v[i].first;\\n                  int x=v[i].second;\\n                  m[x-1]=1;\\n                  m[x+1]=1;\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/0f5fba2c-c99c-4e61-9810-14f548c47320_1679303122.6883874.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& a) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<a.size();i++){\\n            v.push_back({a[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        map<int,int>m;\\n        int tt=0;\\n        long long ans=0;\\n        for(int i=0;i<v.size();i++){\\n              if(!m[v[i].second]){\\n                  tt++;\\n                  m[v[i].second]++;\\n                  ans += v[i].first;\\n                  int x=v[i].second;\\n                  m[x-1]=1;\\n                  m[x+1]=1;\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312088,
                "title": "min-heap-priority-queue",
                "content": "### Space Complexity : O(n)\\n### Time Complexity : O(n logn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        long long sum = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        \\n        // put all the values into min heap with their corresponding indexes into the min heap\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        \\n        // create a visited array that is initially unvisited\\n        vector<int> vis(nums.size(),-1);\\n        \\n        // till my min heap is not empty\\n        while(!pq.empty())\\n        {\\n            int val = pq.top().first;\\n            int idx = pq.top().second;\\n            pq.pop();\\n            \\n            // if curr value idx in not visited before\\n            if(vis[idx] == -1)\\n            {\\n                // add it and mark this visited\\n                sum += val;\\n                vis[idx] = 1;\\n                \\n                // left adjacent\\n                if(idx-1 >= 0)\\n                {\\n                    vis[idx-1] = 1;\\n                }\\n                \\n                // right adjacent\\n                if(idx+1 < nums.size())\\n                {\\n                    vis[idx+1] = 1;\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        long long sum = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        \\n        // put all the values into min heap with their corresponding indexes into the min heap\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        \\n        // create a visited array that is initially unvisited\\n        vector<int> vis(nums.size(),-1);\\n        \\n        // till my min heap is not empty\\n        while(!pq.empty())\\n        {\\n            int val = pq.top().first;\\n            int idx = pq.top().second;\\n            pq.pop();\\n            \\n            // if curr value idx in not visited before\\n            if(vis[idx] == -1)\\n            {\\n                // add it and mark this visited\\n                sum += val;\\n                vis[idx] = 1;\\n                \\n                // left adjacent\\n                if(idx-1 >= 0)\\n                {\\n                    vis[idx-1] = 1;\\n                }\\n                \\n                // right adjacent\\n                if(idx+1 < nums.size())\\n                {\\n                    vis[idx+1] = 1;\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320764,
                "title": "python-3-9-lines-sort-iterate-t-m-1202-ms-45-6-mb",
                "content": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n\\n        n, score, seen = len(nums), 0, set()\\n\\n        queue = sorted(enumerate(nums), key = lambda x: (x[1],x[0]))\\n\\n        for idx, num in queue:\\n            if idx in seen: continue\\n\\n            score+= num\\n            \\n            seen.add(idx)\\n            if idx > 0  : seen.add(idx-1)\\n            if idx < n-1: seen.add(idx+1) \\n            \\n        return score\\n```\\n[https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/submissions/918336401/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n\\n        n, score, seen = len(nums), 0, set()\\n\\n        queue = sorted(enumerate(nums), key = lambda x: (x[1],x[0]))\\n\\n        for idx, num in queue:\\n            if idx in seen: continue\\n\\n            score+= num\\n            \\n            seen.add(idx)\\n            if idx > 0  : seen.add(idx-1)\\n            if idx < n-1: seen.add(idx+1) \\n            \\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312257,
                "title": "set-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans = 0, n = nums.size();\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({nums[i], i});\\n        \\n        sort(v.begin(), v.end());\\n        unordered_set<int> seen;\\n        \\n        for(auto i : v) {\\n            int val = i.first, idx = i.second;\\n            if(seen.find(idx) == seen.end()) {\\n                ans += val;\\n                seen.insert(idx);\\n                seen.insert(idx + 1);\\n                seen.insert(idx - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans = 0, n = nums.size();\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({nums[i], i});\\n        \\n        sort(v.begin(), v.end());\\n        unordered_set<int> seen;\\n        \\n        for(auto i : v) {\\n            int val = i.first, idx = i.second;\\n            if(seen.find(idx) == seen.end()) {\\n                ans += val;\\n                seen.insert(idx);\\n                seen.insert(idx + 1);\\n                seen.insert(idx - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312091,
                "title": "java-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>((i1, i2) -> {\\n            if(nums[i1] == nums[i2]){\\n                return i1 - i2;\\n            }\\n            return nums[i1] - nums[i2];\\n        });\\n        int n = nums.length;\\n        for(int i = 0 ; i < n; i++){\\n            minHeap.add(i);\\n        }\\n        long result = 0;\\n        boolean[] visited = new boolean[n];\\n        while(!minHeap.isEmpty()){\\n            int i = minHeap.poll();\\n            if(visited[i]){\\n                continue;\\n            }\\n            result += nums[i];\\n            if(i > 0){\\n                visited[i - 1] = true;\\n            }\\n            if(i < n - 1){\\n                visited[i + 1] = true;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>((i1, i2) -> {\\n            if(nums[i1] == nums[i2]){\\n                return i1 - i2;\\n            }\\n            return nums[i1] - nums[i2];\\n        });\\n        int n = nums.length;\\n        for(int i = 0 ; i < n; i++){\\n            minHeap.add(i);\\n        }\\n        long result = 0;\\n        boolean[] visited = new boolean[n];\\n        while(!minHeap.isEmpty()){\\n            int i = minHeap.poll();\\n            if(visited[i]){\\n                continue;\\n            }\\n            result += nums[i];\\n            if(i > 0){\\n                visited[i - 1] = true;\\n            }\\n            if(i < n - 1){\\n                visited[i + 1] = true;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312069,
                "title": "priority-queue-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n       vector<int>vis(nums.size(),0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n\\n        long long ans=0;\\n        while(pq.size())\\n        {\\n            int ind=pq.top().second;\\n            if(vis[ind])\\n            {\\n                pq.pop();\\n                continue;\\n            }\\n            ans+=pq.top().first;\\n            vis[ind]=1;\\n            if(ind-1>=0)\\n                vis[ind-1]=1;\\n            \\n            if(ind+1<nums.size())\\n                vis[ind+1]=1;\\n            \\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n       vector<int>vis(nums.size(),0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n\\n        long long ans=0;\\n        while(pq.size())\\n        {\\n            int ind=pq.top().second;\\n            if(vis[ind])\\n            {\\n                pq.pop();\\n                continue;\\n            }\\n            ans+=pq.top().first;\\n            vis[ind]=1;\\n            if(ind-1>=0)\\n                vis[ind-1]=1;\\n            \\n            if(ind+1<nums.size())\\n                vis[ind+1]=1;\\n            \\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381039,
                "title": "javascript-solution-with-sorting",
                "content": "# Intuition\\nWe can do a simple simulation here.\\n\\n# Approach\\nMap initial array to new one, consisting of pairs {val, index} where val is the value of element from orignal array and index is the index of element in initial array. Sort new array in increasing order, if `val1 == val2`, compare `idnex1` and `index2`. Iterate this array, if the current element is not marked, mark element, mark both element neighbours.\\n\\n# Complexity\\n- Time complexity:\\nO(N*Log(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findScore = function(nums) {\\n    let arr = nums.map((n, i) => ({val: n, index: i}));\\n    const marked = new Set();\\n    \\n    arr.sort((a, b) => {\\n        if (a.val === b.val){\\n            return a.index - b.index;\\n        }\\n        return a.val - b.val;\\n    });\\n\\n    let res = 0;\\n    for(let n of arr) {\\n        if(!marked.has(n.index)){\\n            marked.add(n.index);\\n            marked.add(n.index-1);\\n            marked.add(n.index+1);\\n            res += n.val\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findScore = function(nums) {\\n    let arr = nums.map((n, i) => ({val: n, index: i}));\\n    const marked = new Set();\\n    \\n    arr.sort((a, b) => {\\n        if (a.val === b.val){\\n            return a.index - b.index;\\n        }\\n        return a.val - b.val;\\n    });\\n\\n    let res = 0;\\n    for(let n of arr) {\\n        if(!marked.has(n.index)){\\n            marked.add(n.index);\\n            marked.add(n.index-1);\\n            marked.add(n.index+1);\\n            res += n.val\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3312765,
                "title": "c-simple-priority-queue-hashing-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we have to find minimum number so we can use min heap data structure (priority_queue). To check a element is marked or not we will use a map of map<int,bool>.Its a simple constuctive approch to solve this problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialise the priority queue of pair<int,int> where first element of pair is element and second is index of it.Initial the ans as 0.Initialise map of index with value as boolean to check it is marked or not.\\n2. Push all value of num in priority queue of pair with indexes of element. Mark all index in map as true initiall.\\n3. Run a while loop until priority queue is not empty.\\n4. In loop, If pq.top().second is false then just do pq.top to remove the marked element from priority queue. else increase the ans by pq.top().first and marked the index in map as false and marked its adjacent indexes.Check for corner index while marking adjacent.\\n5. After the completion of while loop just return the ans.\\n\\n# Complexity\\n- Time complexity:N*log(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        long long ans=0;\\n        map<int,bool> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[i]=true;\\n        }\\n\\n        for(int i=0;i<n;i++) pq.push({nums[i],i});\\n        while(!pq.empty())\\n        {\\n            if(mp[pq.top().second]==false) \\n            {\\n                pq.pop();\\n            }\\n            else\\n            {\\n                ans+=pq.top().first;\\n                mp[pq.top().second]=false;\\n                int ind=pq.top().second;\\n                if(ind==0)\\n                {\\n                    mp[ind+1]=false;\\n             \\n                }\\n                else if(ind==n-1)\\n                {\\n                    mp[ind-1]=false;\\n                }\\n                else\\n                {\\n                    mp[ind+1]=false;\\n                    mp[ind-1]=false;\\n                }\\n            }\\n        }\\n              return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        long long ans=0;\\n        map<int,bool> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[i]=true;\\n        }\\n\\n        for(int i=0;i<n;i++) pq.push({nums[i],i});\\n        while(!pq.empty())\\n        {\\n            if(mp[pq.top().second]==false) \\n            {\\n                pq.pop();\\n            }\\n            else\\n            {\\n                ans+=pq.top().first;\\n                mp[pq.top().second]=false;\\n                int ind=pq.top().second;\\n                if(ind==0)\\n                {\\n                    mp[ind+1]=false;\\n             \\n                }\\n                else if(ind==n-1)\\n                {\\n                    mp[ind-1]=false;\\n                }\\n                else\\n                {\\n                    mp[ind+1]=false;\\n                    mp[ind-1]=false;\\n                }\\n            }\\n        }\\n              return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541684,
                "title": "c-using-heap-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();;\\n        if(n==1)return nums[0];\\n        long long int ans = 0;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;\\n        int i;\\n        for(i = 0; i < n; i++){\\n            pq.push({nums[i],i});\\n        }\\n        vector<int> v(n,true);\\n        vector<int> tmp;\\n        while(!pq.empty()){\\n            tmp = pq.top();\\n            pq.pop();\\n            if(tmp[1]==0 && v[0]){\\n                ans += tmp[0];\\n                v[0] = v[1] = false;\\n            }else if(tmp[1]==n-1 && v[n-1]){\\n                ans += tmp[0];\\n                v[n-2] = v[n-1] = false;\\n            }else if(v[tmp[1]]){\\n                ans += tmp[0];\\n                v[tmp[1]-1] = v[tmp[1]] = v[tmp[1]+1] = false;\\n            }\\n            // cout<<ans<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();;\\n        if(n==1)return nums[0];\\n        long long int ans = 0;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;\\n        int i;\\n        for(i = 0; i < n; i++){\\n            pq.push({nums[i],i});\\n        }\\n        vector<int> v(n,true);\\n        vector<int> tmp;\\n        while(!pq.empty()){\\n            tmp = pq.top();\\n            pq.pop();\\n            if(tmp[1]==0 && v[0]){\\n                ans += tmp[0];\\n                v[0] = v[1] = false;\\n            }else if(tmp[1]==n-1 && v[n-1]){\\n                ans += tmp[0];\\n                v[n-2] = v[n-1] = false;\\n            }else if(v[tmp[1]]){\\n                ans += tmp[0];\\n                v[tmp[1]-1] = v[tmp[1]] = v[tmp[1]+1] = false;\\n            }\\n            // cout<<ans<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3319665,
                "title": "c-minheap-easytounderstand-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we have to find minimum number and then we have to mark its right element and left element if exists.If an element is marked then we don\\'t have to add that element to our score else we will add and then return score.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we will maintain a min-heap of pairs we will store number and index.\\nwe will keep checking if that number is marked visited or not if it is not marked then we will ad that to our score else we will just pop.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlongn)\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>>pq;\\n        int n=nums.size();\\nvector<long long>v(n,0);\\nfor(int i=0;i<nums.size();i++){\\n    pq.push({nums[i],i});\\n}\\nlong long ans=0;\\nwhile(!pq.empty()){\\n    long long min=pq.top().first;\\n    long long ind=pq.top().second;\\n    if(v[ind]==0){\\n         ans+=min;\\n         if(ind>=1){\\n             v[ind-1]=1;\\n         }\\n         if(ind+1<n){\\n      v[ind+1]=1;\\n         }\\n     }\\n     pq.pop();\\n}\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<long long,long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>>pq;\\n        int n=nums.size();\\nvector<long long>v(n,0);\\nfor(int i=0;i<nums.size();i++){\\n    pq.push({nums[i],i});\\n}\\nlong long ans=0;\\nwhile(!pq.empty()){\\n    long long min=pq.top().first;\\n    long long ind=pq.top().second;\\n    if(v[ind]==0){\\n         ans+=min;\\n         if(ind>=1){\\n             v[ind-1]=1;\\n         }\\n         if(ind+1<n){\\n      v[ind+1]=1;\\n         }\\n     }\\n     pq.pop();\\n}\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312314,
                "title": "heap-easiest-solution-python3",
                "content": "\\n```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int: \\n        heap = [(nums[i],i) for i in range(len(nums))] \\n        marked = {} \\n        score = 0\\n        heapq.heapify(heap) \\n        for i in range(len(nums)):\\n            mini,ind = heapq.heappop(heap) \\n            if ind not in marked:\\n                score += mini \\n                marked[ind] = 1 \\n                marked[ind-1] = marked[ind+1] = 1 \\n        return score\\n        \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int: \\n        heap = [(nums[i],i) for i in range(len(nums))] \\n        marked = {} \\n        score = 0\\n        heapq.heapify(heap) \\n        for i in range(len(nums)):\\n            mini,ind = heapq.heappop(heap) \\n            if ind not in marked:\\n                score += mini \\n                marked[ind] = 1 \\n                marked[ind-1] = marked[ind+1] = 1 \\n        return score\\n        \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312178,
                "title": "c-priority-queue-min-heap-efficient-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            pq.push({nums[i], i});\\n        }\\n        \\n        long long score=0;\\n        while(!pq.empty())\\n        {\\n            int val= pq.top().first;\\n            int idx= pq.top().second;\\n            pq.pop();\\n            \\n            if(nums[idx] == -1) continue;\\n            \\n            score += val;\\n            nums[idx] = -1;\\n            if(idx-1 >= 0) nums[idx-1]=-1;\\n            if(idx+1 < n) nums[idx+1]=-1;\\n        }\\n        return score;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            pq.push({nums[i], i});\\n        }\\n        \\n        long long score=0;\\n        while(!pq.empty())\\n        {\\n            int val= pq.top().first;\\n            int idx= pq.top().second;\\n            pq.pop();\\n            \\n            if(nums[idx] == -1) continue;\\n            \\n            score += val;\\n            nums[idx] = -1;\\n            if(idx-1 >= 0) nums[idx-1]=-1;\\n            if(idx+1 < n) nums[idx+1]=-1;\\n        }\\n        return score;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312074,
                "title": "value-index-pair-sort-easy-intuitive",
                "content": "**c++**\\n```\\nlong long ans = 0;\\n    vector<pair<int, int>> valueIndex;\\n    unordered_set<int> indx;\\n\\n    for (int i = 0; i < nums.size(); i++)\\n        valueIndex.push_back({nums[i], i});\\n\\n    sort(valueIndex.begin(), valueIndex.end(), [](pair<int, int> p1, pair<int, int> p2) {\\n        if (p1.first == p2.first) return p1.second < p2.second;\\n        else return p1.first < p2.first;\\n        });\\n\\n    for (auto p : valueIndex) {\\n        if (!indx.count(p.second)) {\\n            ans += p.first;\\n            indx.insert(p.second);\\n            if (p.second > 0) indx.insert(p.second - 1);\\n            if (p.second < nums.size() - 1) indx.insert(p.second + 1);\\n        }\\n    }\\n\\n    return ans;\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlong long ans = 0;\\n    vector<pair<int, int>> valueIndex;\\n    unordered_set<int> indx;\\n\\n    for (int i = 0; i < nums.size(); i++)\\n        valueIndex.push_back({nums[i], i});\\n\\n    sort(valueIndex.begin(), valueIndex.end(), [](pair<int, int> p1, pair<int, int> p2) {\\n        if (p1.first == p2.first) return p1.second < p2.second;\\n        else return p1.first < p2.first;\\n        });\\n\\n    for (auto p : valueIndex) {\\n        if (!indx.count(p.second)) {\\n            ans += p.first;\\n            indx.insert(p.second);\\n            if (p.second > 0) indx.insert(p.second - 1);\\n            if (p.second < nums.size() - 1) indx.insert(p.second + 1);\\n        }\\n    }\\n\\n    return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3312033,
                "title": "c-priority-queue",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        ll ans=0;\\n        int n=nums.size(),c=0;\\n        unordered_map<int,bool> mp;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i],i});\\n        }\\n        while(n--){\\n            auto ele = pq.top();\\n            pq.pop();\\n            int val = ele.first, ind = ele.second;\\n            if(mp.find(ind) == mp.end()){\\n                ans += val;\\n                mp[ind] =1;\\n                mp[ind-1] = 1;\\n                mp[ind+1] =1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        ll ans=0;\\n        int n=nums.size(),c=0;\\n        unordered_map<int,bool> mp;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i],i});\\n        }\\n        while(n--){\\n            auto ele = pq.top();\\n            pq.pop();\\n            int val = ele.first, ind = ele.second;\\n            if(mp.find(ind) == mp.end()){\\n                ans += val;\\n                mp[ind] =1;\\n                mp[ind-1] = 1;\\n                mp[ind+1] =1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550883,
                "title": "well-explained-java-solution",
                "content": "# Intuition\\n    Sort elements depending upon their value and indexes.   \\n    Use a simple boolean array to keep a track of vis indx\\n    There are two cases that we commonly face -> \\n        1) The index is not visited \\n            Add that val to score and marks adj if possible\\n            Mark that index as true and adj true as well \\n            DONE \\n        2) The index is visited \\n            Do nothing , skip that element\\n# Approach\\n    PriorityQueue that sorts elements using the value and idx , pls refer\\n    the pair class that I have used .\\n    While(queue) is not empty , do the functions that I have written in \\n    Intuition section .\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n     static class Pair {\\n        int element;\\n        int idx ;\\n        public Pair (int x , int y) {\\n            this.element = x;\\n            this.idx = y;\\n        }\\n    }\\n    public long findScore(int[] nums) {\\n        long score = 0;\\n        boolean[] vis = new boolean[nums.length];\\n        PriorityQueue<Pair> q = new PriorityQueue<>((a,b)->a.element==b.element?a.idx-b.idx:a.element-b.element);\\n        for (int i=0;i<nums.length;++i) {\\n            q.offer(new Pair(nums[i], i));\\n        }\\n        while(!q.isEmpty()) {\\n            Pair currPair = q.poll();\\n            if(!vis[currPair.idx]) {\\n                vis[currPair.idx]=true;\\n                score+=(long)currPair.element;\\n                if((currPair.idx+1)<nums.length) {\\n                    vis[currPair.idx+1]=true;\\n                }\\n                if((currPair.idx-1)>=0) {\\n                    vis[currPair.idx-1]=true;\\n                }\\n            }\\n        }\\n        return(score);\\n    }\\n}\\n```\\n// Upvotes are always welcome \\uD83D\\uDE07",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     static class Pair {\\n        int element;\\n        int idx ;\\n        public Pair (int x , int y) {\\n            this.element = x;\\n            this.idx = y;\\n        }\\n    }\\n    public long findScore(int[] nums) {\\n        long score = 0;\\n        boolean[] vis = new boolean[nums.length];\\n        PriorityQueue<Pair> q = new PriorityQueue<>((a,b)->a.element==b.element?a.idx-b.idx:a.element-b.element);\\n        for (int i=0;i<nums.length;++i) {\\n            q.offer(new Pair(nums[i], i));\\n        }\\n        while(!q.isEmpty()) {\\n            Pair currPair = q.poll();\\n            if(!vis[currPair.idx]) {\\n                vis[currPair.idx]=true;\\n                score+=(long)currPair.element;\\n                if((currPair.idx+1)<nums.length) {\\n                    vis[currPair.idx+1]=true;\\n                }\\n                if((currPair.idx-1)>=0) {\\n                    vis[currPair.idx-1]=true;\\n                }\\n            }\\n        }\\n        return(score);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466395,
                "title": "implementation-of-priority-queue-please-upvote",
                "content": "\\n# Approach\\nI\\'ve used a priority queue to store pairs of elements and their indices in ascending order of element value. then popping the smallest unmarked element from the queue, marking it and its adjacent elements (if necessary), and adding its value to the score. \\n\\n# Complexity\\n- Time complexity:\\nO(n log n) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long findScore(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<bool> marked(n, false);\\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n    for (int i = 0; i < n; i++) {\\n        pq.push(make_pair(nums[i], i));\\n    }\\n    long long score = 0;\\n    while (!pq.empty()) {\\n        pair<int,int> p = pq.top();\\n        pq.pop();\\n        int j = p.second;\\n        if (!marked[j]) {\\n            marked[j] = true;\\n            score += nums[j];\\n            if (j > 0) marked[j-1] = true;\\n            if (j < n-1) marked[j+1] = true;\\n        }\\n    }\\n    return score;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long findScore(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<bool> marked(n, false);\\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n    for (int i = 0; i < n; i++) {\\n        pq.push(make_pair(nums[i], i));\\n    }\\n    long long score = 0;\\n    while (!pq.empty()) {\\n        pair<int,int> p = pq.top();\\n        pq.pop();\\n        int j = p.second;\\n        if (!marked[j]) {\\n            marked[j] = true;\\n            score += nums[j];\\n            if (j > 0) marked[j-1] = true;\\n            if (j < n-1) marked[j+1] = true;\\n        }\\n    }\\n    return score;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457725,
                "title": "easiest-solution-zscaler-assessment-question",
                "content": "- Create a priority queue to store the unmarked integers in the array. The priority queue will be sorted in ascending order of the integers. In case of a tie, the one with the smallest index is selected.\\n\\n- Initialize a boolean array \"seen\" of size n (n = length of nums) to keep track of marked elements. Mark all elements as \"false\".\\n\\n- Initialize a variable \"score\" to 0.\\n\\n- While the priority queue is not empty, repeat the following steps:\\na. Remove the element with the smallest value from the priority queue.\\nb. Check if the element is already marked. If it is, move to the next element.\\nc. If the element is not marked, add its value to the score.\\nd. Mark the element as seen by setting the corresponding index in the \"seen\" array to true.\\ne. If the element has adjacent elements, mark them as seen too.\\n\\n- Return the score.\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        int n=nums.length;\\n        PriorityQueue<int []>pq=new PriorityQueue<>((a,b)->{\\n            if(a[0]!=b[0]){\\n                return a[0]-b[0];\\n            }\\n            else{\\n                return a[1]-b[1];\\n            }\\n        });\\n        for(int i=0;i<n;i++){\\n            pq.offer(new int[]{nums[i],i});\\n        }\\n        long score=0;\\n        boolean seen[]=new boolean[n];\\n        while(!pq.isEmpty()){\\n            int i[]=pq.poll();\\n            int index=i[1];\\n            if(!seen[index]){\\n                score+=i[0];\\n                seen[index]=true;\\n                if(index-1>=0){\\n                    if(!seen[index-1]){\\n                        seen[index-1]=true;\\n                    }\\n                }\\n                if(index+1<n){\\n                    if(!seen[index+1]){\\n                        seen[index+1]=true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return score;\\n    }\\n}\\n```\\n# Upvoting is Much Appreciated",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        int n=nums.length;\\n        PriorityQueue<int []>pq=new PriorityQueue<>((a,b)->{\\n            if(a[0]!=b[0]){\\n                return a[0]-b[0];\\n            }\\n            else{\\n                return a[1]-b[1];\\n            }\\n        });\\n        for(int i=0;i<n;i++){\\n            pq.offer(new int[]{nums[i],i});\\n        }\\n        long score=0;\\n        boolean seen[]=new boolean[n];\\n        while(!pq.isEmpty()){\\n            int i[]=pq.poll();\\n            int index=i[1];\\n            if(!seen[index]){\\n                score+=i[0];\\n                seen[index]=true;\\n                if(index-1>=0){\\n                    if(!seen[index-1]){\\n                        seen[index-1]=true;\\n                    }\\n                }\\n                if(index+1<n){\\n                    if(!seen[index+1]){\\n                        seen[index+1]=true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338651,
                "title": "c-solution-using-priority-queue",
                "content": "\\n```\\nclass Solution {\\npublic:\\n\\n    long long findScore(vector<int>& nums) {\\n        long long n=nums.size();\\n        long long ans=0;\\n        priority_queue<pair<long long,long long>, vector<pair<long long,long long>>, greater<pair<long long,long long>> > q;\\n\\n        for(long long i=0;i<n;i++){\\n            q.push({nums[i],i});\\n        }\\n\\n        vector<long long> vis(n,0);\\n\\n        while(!q.empty()){\\n            if(vis[q.top().second]==1) q.pop();\\n            else{\\n            long long val = q.top().first;\\n            long long in = q.top().second;\\n            q.pop();\\n            ans+=val;\\n            vis[in]=1;\\n            if(in-1>=0) vis[in-1]=1;\\n            if(in+1<n) vis[in+1]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long findScore(vector<int>& nums) {\\n        long long n=nums.size();\\n        long long ans=0;\\n        priority_queue<pair<long long,long long>, vector<pair<long long,long long>>, greater<pair<long long,long long>> > q;\\n\\n        for(long long i=0;i<n;i++){\\n            q.push({nums[i],i});\\n        }\\n\\n        vector<long long> vis(n,0);\\n\\n        while(!q.empty()){\\n            if(vis[q.top().second]==1) q.pop();\\n            else{\\n            long long val = q.top().first;\\n            long long in = q.top().second;\\n            q.pop();\\n            ans+=val;\\n            vis[in]=1;\\n            if(in-1>=0) vis[in-1]=1;\\n            if(in+1<n) vis[in+1]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316420,
                "title": "c-sorting",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n#define LL long long\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        LL res=0;\\n        int sz=(int)nums.size();\\n        vector<pair<int,int>> arr(sz);\\n        for(int i=0;i<sz;i++){\\n            arr[i].first=nums[i];\\n            arr[i].second=i;\\n        }\\n        sort(arr.begin(),arr.end());\\n        vector<bool> used(sz,false);\\n        for(int i=0;i<sz;i++){\\n            int mn=arr[i].first;\\n            int pos=arr[i].second;\\n            if(pos==0){\\n                if(!used[pos]){\\n                    res+=mn;\\n                    used[pos]=true;\\n                    used[pos+1]=true;\\n                }\\n            }\\n            else if(pos==sz-1){\\n                if(!used[pos]){\\n                    res+=mn;\\n                    used[pos]=true;\\n                    used[pos-1]=true;\\n                }\\n            }\\n            else if(!used[pos]){\\n                res+=mn;\\n                used[pos]=true;\\n                used[pos+1]=true;\\n                used[pos-1]=true;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n#define LL long long\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        LL res=0;\\n        int sz=(int)nums.size();\\n        vector<pair<int,int>> arr(sz);\\n        for(int i=0;i<sz;i++){\\n            arr[i].first=nums[i];\\n            arr[i].second=i;\\n        }\\n        sort(arr.begin(),arr.end());\\n        vector<bool> used(sz,false);\\n        for(int i=0;i<sz;i++){\\n            int mn=arr[i].first;\\n            int pos=arr[i].second;\\n            if(pos==0){\\n                if(!used[pos]){\\n                    res+=mn;\\n                    used[pos]=true;\\n                    used[pos+1]=true;\\n                }\\n            }\\n            else if(pos==sz-1){\\n                if(!used[pos]){\\n                    res+=mn;\\n                    used[pos]=true;\\n                    used[pos-1]=true;\\n                }\\n            }\\n            else if(!used[pos]){\\n                res+=mn;\\n                used[pos]=true;\\n                used[pos+1]=true;\\n                used[pos-1]=true;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3312425,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        look=[0]*(len(nums)+1)\\n        ans=0\\n        for a,i in sorted([a,i] for i,a in enumerate(nums)):\\n            if look[i]:\\n                continue\\n\\n            ans+=a\\n            look[i]=look[i-1]=look[i+1]=1\\n\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        look=[0]*(len(nums)+1)\\n        ans=0\\n        for a,i in sorted([a,i] for i,a in enumerate(nums)):\\n            if look[i]:\\n                continue\\n\\n            ans+=a\\n            look[i]=look[i-1]=look[i+1]=1\\n\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312377,
                "title": "python-3-priority-queue-heap",
                "content": "# Code\\n```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        ans,pq,seen,n = 0,[],set(),len(nums)\\n        for i,num in enumerate(nums):\\n            heapq.heappush(pq,(num,i))\\n        while pq:\\n            empty = False\\n            while True:\\n                if not pq: \\n                    empty = True\\n                    break\\n                num,i = heapq.heappop(pq)\\n                if i not in seen:\\n                    break\\n            if empty:\\n                break\\n            ans += num\\n            if i+1<n:\\n                seen.add(i+1)\\n            if i-1>=0:\\n                seen.add(i-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        ans,pq,seen,n = 0,[],set(),len(nums)\\n        for i,num in enumerate(nums):\\n            heapq.heappush(pq,(num,i))\\n        while pq:\\n            empty = False\\n            while True:\\n                if not pq: \\n                    empty = True\\n                    break\\n                num,i = heapq.heappop(pq)\\n                if i not in seen:\\n                    break\\n            if empty:\\n                break\\n            ans += num\\n            if i+1<n:\\n                seen.add(i+1)\\n            if i-1>=0:\\n                seen.add(i-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312301,
                "title": "python-sorting-set",
                "content": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        used = set()\\n        score = 0\\n        for num, i in sorted((num, i) for i, num in enumerate(nums)):\\n            if i in used:\\n                continue\\n            score += num\\n            used.update([i-1, i, i+1])\\n        return score\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        used = set()\\n        score = 0\\n        for num, i in sorted((num, i) for i, num in enumerate(nums)):\\n            if i in used:\\n                continue\\n            score += num\\n            used.update([i-1, i, i+1])\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312050,
                "title": "just-do-it-priority-queue-set-c",
                "content": "# Intuition\\nJust apply the instructions of the problem. \\n\\n# Approach\\nCreate a priority_queue or set that stores the pair $(arr_i,i)$ and just apply the operations until exist some element in the queue/set\\n\\n# Complexity\\n- Time complexity:\\n$O(n log(n))$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        set<pair<int,int>> st;\\n        int n  = nums.size();\\n        for(int i = 0;i<n;i++){\\n            st.insert({nums[i],i});\\n        }\\n        \\n        long long ans = 0;\\n        while(st.size()){\\n            auto mn = *st.begin();\\n            ans+=mn.first;\\n            if(mn.second){\\n                pair<int,int> l = {nums[mn.second-1],mn.second-1};\\n                st.erase(l);\\n            }\\n            if(mn.second !=(n-1)){\\n                pair<int,int> r = {nums[mn.second+1],mn.second+1};\\n                st.erase(r);\\n            }\\n            st.erase(st.begin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        set<pair<int,int>> st;\\n        int n  = nums.size();\\n        for(int i = 0;i<n;i++){\\n            st.insert({nums[i],i});\\n        }\\n        \\n        long long ans = 0;\\n        while(st.size()){\\n            auto mn = *st.begin();\\n            ans+=mn.first;\\n            if(mn.second){\\n                pair<int,int> l = {nums[mn.second-1],mn.second-1};\\n                st.erase(l);\\n            }\\n            if(mn.second !=(n-1)){\\n                pair<int,int> r = {nums[mn.second+1],mn.second+1};\\n                st.erase(r);\\n            }\\n            st.erase(st.begin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312030,
                "title": "short-sweet-c-code-easy-to-understand-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long int ans = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int i =0, n = nums.size();\\n        i = 0;\\n        while(i<n){\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n        vector<int> v(n,1);\\n        while(!pq.empty()){\\n            pair<int,int> p = pq.top();\\n            pq.pop();\\n            if(v[p.second]){\\n                ans += p.first;\\n                if(p.second-1>=0){\\n                    v[p.second-1] = 0;\\n                }\\n                if(p.second+1<n){\\n                    v[p.second+1] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long int ans = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int i =0, n = nums.size();\\n        i = 0;\\n        while(i<n){\\n            pq.push({nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 3745463,
                "title": "easy-java-solution-beats-98-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long ans = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)-> (a[0]==b[0])?(a[1]-b[1]):(a[0]-b[0]));\\n        boolean[] vis = new boolean[nums.length];\\n\\n        for(int i = 0;i < nums.length;i++){\\n            pq.offer(new int[]{nums[i],i});\\n        }\\n\\n        while(!pq.isEmpty()){\\n            int[] it = pq.poll();\\n            if(!vis[it[1]]){\\n                vis[it[1]] = true;\\n                ans += it[0];\\n\\n                if(it[1] > 0){\\n                    vis[it[1]-1] = true;\\n                }\\n                if(it[1] < nums.length-1){\\n                    vis[it[1]+1] = true;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long ans = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)-> (a[0]==b[0])?(a[1]-b[1]):(a[0]-b[0]));\\n        boolean[] vis = new boolean[nums.length];\\n\\n        for(int i = 0;i < nums.length;i++){\\n            pq.offer(new int[]{nums[i],i});\\n        }\\n\\n        while(!pq.isEmpty()){\\n            int[] it = pq.poll();\\n            if(!vis[it[1]]){\\n                vis[it[1]] = true;\\n                ans += it[0];\\n\\n                if(it[1] > 0){\\n                    vis[it[1]-1] = true;\\n                }\\n                if(it[1] < nums.length-1){\\n                    vis[it[1]+1] = true;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457841,
                "title": "python-heap-explained",
                "content": "# Intuition\\nWe have to mark the smallest index as well as its left and right element too if they exist.\\nTo find the smallest integer present use a heap pushing (ele, index)\\nnow pop the smallest element and add it to seen and score if we havent seen this index before and then also add its left and right index if they exist.\\n\\n# Code\\n```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        score = 0\\n        bag = []\\n        for i, num in enumerate(nums):\\n            bag.append((num, i))\\n        heapq.heapify(bag)\\n        seen = set()\\n        while bag:\\n            smallestNum, idx = heapq.heappop(bag)\\n            if idx not in seen:\\n                score += smallestNum\\n                seen.add(idx)\\n                if idx - 1 >= 0:\\n                    seen.add(idx-1)\\n                if idx + 1 < len(nums):\\n                    seen.add(idx+1)\\n        return(score)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        score = 0\\n        bag = []\\n        for i, num in enumerate(nums):\\n            bag.append((num, i))\\n        heapq.heapify(bag)\\n        seen = set()\\n        while bag:\\n            smallestNum, idx = heapq.heappop(bag)\\n            if idx not in seen:\\n                score += smallestNum\\n                seen.add(idx)\\n                if idx - 1 >= 0:\\n                    seen.add(idx-1)\\n                if idx + 1 < len(nums):\\n                    seen.add(idx+1)\\n        return(score)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451331,
                "title": "c-min-heap-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- MIN HEAP\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a min heap to store the elements of the input array along with their indices and a boolean flag that indicates whether the element has been marked or not.\\n- Iterate through the priority queue until it becomes empty.\\nFor each element in the priority queue, mark it as visited, add its value to the score, and mark its adjacent unvisited elements.\\n- Add the unvisited adjacent elements to the priority queue along with their indices and a boolean flag.\\n- Repeat the process until all elements in the priority queue have been visited.\\n- Return the score obtained.\\n\\n# Complexity\\nTime complexity: O(n * logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- This is because we are using a priority queue, which has an insertion and removal time complexity of O(log n) and a total of n elements are being inserted and removed. \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    typedef pair <pair<int, int>, bool> pi;\\n    typedef long long ll;\\n\\n    long long findScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        priority_queue <pi, vector <pi>, greater <pi>> pq;\\n\\n        for(int i = 0; i < n; i++)\\n            pq.push({{nums[i], i}, false});\\n\\n        ll score = 0;\\n        vector <bool> marked(n, false);\\n\\n        while(!pq.empty())\\n        {\\n           int a = pq.top().first.first;\\n           int idx = pq.top().first.second;\\n           pq.pop();\\n\\n           if(marked[idx])\\n              continue;\\n\\n            score += a;  \\n            marked[idx] = true;  \\n\\n            //check for left adjacent element \\n            if((idx - 1 >= 0) && !marked[idx - 1])\\n            {\\n                pq.push({{nums[idx - 1], idx}, false});\\n                marked[idx-1] = true;\\n            }\\n\\n            //check for right adjacent element \\n            if((idx + 1 < n) && !marked[idx + 1])\\n            {\\n                pq.push({{nums[idx + 1], idx + 1}, false});\\n                marked[idx + 1] = true;\\n            }\\n        } \\n        return score;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    typedef pair <pair<int, int>, bool> pi;\\n    typedef long long ll;\\n\\n    long long findScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        priority_queue <pi, vector <pi>, greater <pi>> pq;\\n\\n        for(int i = 0; i < n; i++)\\n            pq.push({{nums[i], i}, false});\\n\\n        ll score = 0;\\n        vector <bool> marked(n, false);\\n\\n        while(!pq.empty())\\n        {\\n           int a = pq.top().first.first;\\n           int idx = pq.top().first.second;\\n           pq.pop();\\n\\n           if(marked[idx])\\n              continue;\\n\\n            score += a;  \\n            marked[idx] = true;  \\n\\n            //check for left adjacent element \\n            if((idx - 1 >= 0) && !marked[idx - 1])\\n            {\\n                pq.push({{nums[idx - 1], idx}, false});\\n                marked[idx-1] = true;\\n            }\\n\\n            //check for right adjacent element \\n            if((idx + 1 < n) && !marked[idx + 1])\\n            {\\n                pq.push({{nums[idx + 1], idx + 1}, false});\\n                marked[idx + 1] = true;\\n            }\\n        } \\n        return score;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400312,
                "title": "easy-c-solution-sets-priority-queue",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Sets\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long score=0;\\n        set<pair<int,int>> st;\\n        for (int i=0; i<nums.size(); i++){\\n            st.insert({nums[i],i});\\n        }\\n        while (!st.empty()){\\n            auto mini= *st.begin();\\n            score+= mini.first;\\n            int i= mini.second;\\n            st.erase(st.begin());\\n            if (i+1<nums.size() && st.find({nums[i+1],i+1})!=st.end()){\\n                st.erase({nums[i+1],i+1});\\n            }\\n            if (i-1>=0 && st.find({nums[i-1],i-1})!=st.end()){\\n                st.erase({nums[i-1],i-1});\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```\\n\\n## Priority Queue\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long score=0;\\n        map<int,bool> mark;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for (int i=0; i<nums.size(); i++){\\n            pq.push({nums[i],i});\\n            mark[i]=0;\\n        }\\n        while (!pq.empty()){\\n            auto mini= pq.top();\\n            pq.pop();\\n            int i= mini.second;\\n            if (mark[i])continue;\\n            score+= mini.first;\\n            mark[i]=1;\\n            if (i+1<nums.size()){\\n                mark[i+1]=1;\\n            }\\n            if (i-1>=0){\\n                mark[i-1]=1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long score=0;\\n        set<pair<int,int>> st;\\n        for (int i=0; i<nums.size(); i++){\\n            st.insert({nums[i],i});\\n        }\\n        while (!st.empty()){\\n            auto mini= *st.begin();\\n            score+= mini.first;\\n            int i= mini.second;\\n            st.erase(st.begin());\\n            if (i+1<nums.size() && st.find({nums[i+1],i+1})!=st.end()){\\n                st.erase({nums[i+1],i+1});\\n            }\\n            if (i-1>=0 && st.find({nums[i-1],i-1})!=st.end()){\\n                st.erase({nums[i-1],i-1});\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long score=0;\\n        map<int,bool> mark;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for (int i=0; i<nums.size(); i++){\\n            pq.push({nums[i],i});\\n            mark[i]=0;\\n        }\\n        while (!pq.empty()){\\n            auto mini= pq.top();\\n            pq.pop();\\n            int i= mini.second;\\n            if (mark[i])continue;\\n            score+= mini.first;\\n            mark[i]=1;\\n            if (i+1<nums.size()){\\n                mark[i+1]=1;\\n            }\\n            if (i-1>=0){\\n                mark[i-1]=1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365924,
                "title": "easy-c-code-using-pq",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n            pq.push({nums[i], i});\\n\\n        long long sum = 0;\\n        int n = nums.size();\\n        unordered_map<int,int> idxMarked;\\n\\n        while(!pq.empty())\\n        {\\n            int small= pq.top().first, idx = pq.top().second;\\n            pq.pop();\\n            if(!idxMarked.count(idx))\\n            {\\n                sum+=small;\\n                idxMarked[idx] += 1;\\n                if(idx+1 < n and !idxMarked.count(idx+1))\\n                    idxMarked[idx+1] += 1;\\n                if(idx-1 >= 0 and !idxMarked.count(idx-1))\\n                    idxMarked[idx-1] += 1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n\\n        for(int i = 0; i < nums.size(); i++)\\n            pq.push({nums[i], i});\\n\\n        long long sum = 0;\\n        int n = nums.size();\\n        unordered_map<int,int> idxMarked;\\n\\n        while(!pq.empty())\\n        {\\n            int small= pq.top().first, idx = pq.top().second;\\n            pq.pop();\\n            if(!idxMarked.count(idx))\\n            {\\n                sum+=small;\\n                idxMarked[idx] += 1;\\n                if(idx+1 < n and !idxMarked.count(idx+1))\\n                    idxMarked[idx+1] += 1;\\n                if(idx-1 >= 0 and !idxMarked.count(idx-1))\\n                    idxMarked[idx-1] += 1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337195,
                "title": "c-multimap-clean-code",
                "content": "**Please upvote if you like my solution :)**\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        multimap<int,int>hash;\\n        vector<int>vis(n,0);\\n        for(int i=0;i<nums.size();i++){\\n            hash.insert(pair<int,int>(nums[i],i));\\n        }\\n        for(auto it:hash){\\n            int first = it.first;\\n            int second = it.second;\\n            if(vis[second] == 0){\\n                if(second-1>=0){\\n                    vis[second-1] = 1;\\n                }\\n                if(second+1<n){\\n                    vis[second+1] = 1;\\n                }\\n                ans += first;\\n                vis[second] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        multimap<int,int>hash;\\n        vector<int>vis(n,0);\\n        for(int i=0;i<nums.size();i++){\\n            hash.insert(pair<int,int>(nums[i],i));\\n        }\\n        for(auto it:hash){\\n            int first = it.first;\\n            int second = it.second;\\n            if(vis[second] == 0){\\n                if(second-1>=0){\\n                    vis[second-1] = 1;\\n                }\\n                if(second+1<n){\\n                    vis[second+1] = 1;\\n                }\\n                ans += first;\\n                vis[second] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322615,
                "title": "java-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long res=0;\\n        int n=nums.length;\\n        int a[][]=new int[n][2];\\n        for(int i=0;i<n;i++){a[i][0]=i;a[i][1]=nums[i];}\\n        Arrays.sort(a,(x,y)->x[1]-y[1]);\\n        for(int i=0;i<n;i++){\\n            int index=a[i][0];\\n            if(nums[index]==-1)continue;\\n            res+=nums[index];\\n            nums[index]=-1;\\n            if(index>0)nums[index-1]=-1;\\n            if(index<n-1)nums[index+1]=-1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n/*\\n 0-2   \\n 1-1\\n 2-3\\n 3-4\\n 4-5\\n 5-2\\n\\n 1-1\\n 0-2\\n 5-2\\n 2-3\\n 3-4\\n 4-5\\n\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long res=0;\\n        int n=nums.length;\\n        int a[][]=new int[n][2];\\n        for(int i=0;i<n;i++){a[i][0]=i;a[i][1]=nums[i];}\\n        Arrays.sort(a,(x,y)->x[1]-y[1]);\\n        for(int i=0;i<n;i++){\\n            int index=a[i][0];\\n            if(nums[index]==-1)continue;\\n            res+=nums[index];\\n            nums[index]=-1;\\n            if(index>0)nums[index-1]=-1;\\n            if(index<n-1)nums[index+1]=-1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n/*\\n 0-2   \\n 1-1\\n 2-3\\n 3-4\\n 4-5\\n 5-2\\n\\n 1-1\\n 0-2\\n 5-2\\n 2-3\\n 3-4\\n 4-5\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317652,
                "title": "optimal-java-solution-using-priority-queue-with-detailed-explanation",
                "content": "# Intuition\\n The question states we must keep on marking on the smallest element and it\\'s adjacent elements. However, in case of a tie, we decide it by the smallest index. Whenever such a case arises, we should go for Priority Queue when there is a first parameter, and only in case of it\\'s tie, we go for another.\\n\\n# Approach\\n1. Create a Priority Queue<int[]> to add all (elements, index) sorted in ascending order of value followed by ascending order of index.\\n2. Create a HashSet to keep store of which indexes have been marked.\\n3. Run a while loop till all elements in Queue are removed, or the set has all the indexes.\\n4. Keep on marking the elements and calculating score as per the problem statement.\\n\\n# Complexity\\n- Time complexity:\\n     O(N) \\n\\n- Space complexity:\\n O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        int n = nums.length; long score = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n\\n        for(int i=0; i<n; i++){\\n            pq.offer(new int[]{nums[i], i});\\n        }\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while(!pq.isEmpty() && hs.size() < n){\\n            int top[] = pq.poll();\\n            if(hs.contains(top[1])){\\n                continue;\\n            }\\n            score += top[0];\\n            hs.add(top[1]);\\n            if(top[1] > 0 && !hs.contains(top[1]-1)){\\n                hs.add(top[1]-1);\\n            }\\n            if(top[1] < n-1 && !hs.contains(top[1]+1)){\\n                hs.add(top[1]+1);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        int n = nums.length; long score = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n\\n        for(int i=0; i<n; i++){\\n            pq.offer(new int[]{nums[i], i});\\n        }\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while(!pq.isEmpty() && hs.size() < n){\\n            int top[] = pq.poll();\\n            if(hs.contains(top[1])){\\n                continue;\\n            }\\n            score += top[0];\\n            hs.add(top[1]);\\n            if(top[1] > 0 && !hs.contains(top[1]-1)){\\n                hs.add(top[1]-1);\\n            }\\n            if(top[1] < n-1 && !hs.contains(top[1]+1)){\\n                hs.add(top[1]+1);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317031,
                "title": "simple-c-code-using-min-heap-and-map",
                "content": "# Intuition\\nWe need to maintain smallest number with smallest index ->PAIR IN MIN HEAP\\nTo maintain visited indices->MAP\\n\\n# Approach\\nJust push all the numbers with their indices in Min Heap.Now while your heap is not empty just check if the number is previously marked or not if it is marked then do nothing else add it to score and mark its adjacent elements in map\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN))\\n\\n- Space complexity:\\nO(2*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        unordered_map<int,int> mpp;\\n        long long score=0;\\n        while(!pq.empty()){\\n            int tmp=pq.top().first;\\n            int tmpind=pq.top().second;\\n            pq.pop();\\n            if(mpp[tmpind]==-1) continue;\\n            else{\\n                score+=tmp;\\n                mpp[tmpind-1]=-1;\\n                mpp[tmpind+1]=-1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        unordered_map<int,int> mpp;\\n        long long score=0;\\n        while(!pq.empty()){\\n            int tmp=pq.top().first;\\n            int tmpind=pq.top().second;\\n            pq.pop();\\n            if(mpp[tmpind]==-1) continue;\\n            else{\\n                score+=tmp;\\n                mpp[tmpind-1]=-1;\\n                mpp[tmpind+1]=-1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315800,
                "title": "java-priorityqueue-custom-class",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int val, idx;\\n        Pair (int val, int idx) {\\n            this.val = val;\\n            this.idx = idx;\\n        }\\n    }\\n    \\n    public long findScore(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> {\\n            if (a.val == b.val) {\\n                return a.idx - b.idx;\\n            }\\n            return a.val - b.val;\\n        });\\n        for (int i = 0; i < n; i++) {\\n            pq.add(new Pair(nums[i], i));\\n        }\\n        \\n        int[] blocked = new int[100_001];\\n        long answer = 0l;\\n        \\n        while (!pq.isEmpty()) {\\n            Pair rem = pq.remove();\\n            if (blocked[rem.idx] == 1) continue;\\n            if (blocked[rem.idx] == 0) {\\n                answer += rem.val;\\n            }\\n            blocked[rem.idx] = 1;\\n            blocked[Math.max(0, rem.idx - 1)] = 1;\\n            blocked[Math.min(n - 1, rem.idx + 1)] = 1;\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Pair {\\n        int val, idx;\\n        Pair (int val, int idx) {\\n            this.val = val;\\n            this.idx = idx;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3315036,
                "title": "c-min-heap-faster-easy-to-understand",
                "content": "* ***Using Min Heap***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        long long score = 0;\\n        \\n        // declare a min heap\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        // declare a vis array\\n        \\n        vector<bool> vis(n, false);\\n        \\n        // push all the elements with index into pq\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push({nums[i], i});\\n        }\\n        \\n        // perform the given operations\\n        \\n        while(!pq.empty())\\n        {\\n            auto curr = pq.top();\\n            \\n            pq.pop();\\n            \\n            int idx = curr.second;\\n            \\n            int curr_score = curr.first;\\n            \\n            // if the curr idx is not visited then add to score and mark the adjacent as visited\\n            \\n            if(vis[idx] == false)\\n            {\\n                score += curr_score;\\n                \\n                if(idx - 1 >= 0)\\n                {\\n                    vis[idx - 1] = true;\\n                }\\n                \\n                if(idx + 1 < n)\\n                {\\n                    vis[idx + 1] = true;\\n                }\\n            }\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        long long score = 0;\\n        \\n        // declare a min heap\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        // declare a vis array\\n        \\n        vector<bool> vis(n, false);\\n        \\n        // push all the elements with index into pq\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            pq.push({nums[i], i});\\n        }\\n        \\n        // perform the given operations\\n        \\n        while(!pq.empty())\\n        {\\n            auto curr = pq.top();\\n            \\n            pq.pop();\\n            \\n            int idx = curr.second;\\n            \\n            int curr_score = curr.first;\\n            \\n            // if the curr idx is not visited then add to score and mark the adjacent as visited\\n            \\n            if(vis[idx] == false)\\n            {\\n                score += curr_score;\\n                \\n                if(idx - 1 >= 0)\\n                {\\n                    vis[idx - 1] = true;\\n                }\\n                \\n                if(idx + 1 < n)\\n                {\\n                    vis[idx + 1] = true;\\n                }\\n            }\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314776,
                "title": "python3-solution-sorting",
                "content": "# Approach\\nsort the array for `index`, and traverse to the index with the smallest element, check if you marked it or not in `dp`, if it is not marked mark its adjacent element and add its `value` to the `score`.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python\\nclass Solution:\\n    def findScore(self, A: List[int]) -> int:\\n        n = len(A)\\n        dp = [False] * n\\n        score = 0\\n        for v, k in sorted((i, e) for e, i in enumerate(A)):\\n            if dp[k]: continue\\n            if k > 0: dp[k - 1] = True\\n            if k < n - 1: dp[k + 1] = True\\n            score += v\\n        return score\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```Python\\nclass Solution:\\n    def findScore(self, A: List[int]) -> int:\\n        n = len(A)\\n        dp = [False] * n\\n        score = 0\\n        for v, k in sorted((i, e) for e, i in enumerate(A)):\\n            if dp[k]: continue\\n            if k > 0: dp[k - 1] = True\\n            if k < n - 1: dp[k + 1] = True\\n            score += v\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314675,
                "title": "simple-priority-queue-90-faster",
                "content": "**Intuition**\\n- A `priority queue` stores value and `index`, which in turn lets us extract the smallest number\\n- The `mark closure` marks adjacent elements to prevent being used later\\n- Finally, only relevant numbers are added to the result\\n\\n**Code**\\n```c++\\nclass Solution {\\npublic:\\n     long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for (int i = 0; i < nums.size(); i++) pq.push({nums[i], i});\\n\\n        auto mark = [&](int idx) {\\n            nums[idx] = 0;\\n            auto prev = idx - 1, next = idx + 1;\\n            if (prev >= 0) nums[prev] = 0;\\n            if (next < nums.size()) nums[next] = 0;\\n        };\\n\\n        long long res = 0;\\n        while (pq.size()) {\\n            auto top = pq.top(); pq.pop();\\n            auto val = top.first, idx = top.second;\\n            if (nums[idx]) res += nums[idx], mark(idx);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n     long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for (int i = 0; i < nums.size(); i++) pq.push({nums[i], i});\\n\\n        auto mark = [&](int idx) {\\n            nums[idx] = 0;\\n            auto prev = idx - 1, next = idx + 1;\\n            if (prev >= 0) nums[prev] = 0;\\n            if (next < nums.size()) nums[next] = 0;\\n        };\\n\\n        long long res = 0;\\n        while (pq.size()) {\\n            auto top = pq.top(); pq.pop();\\n            auto val = top.first, idx = top.second;\\n            if (nums[idx]) res += nums[idx], mark(idx);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313393,
                "title": "java-minheap-hashset",
                "content": "# Intuition:\\nUse min heap to access the least element in the array and add it to score.\\nMark the adjacent left and right as well as the current index by putting it into the hashset.\\n\\n---\\n# Solution:\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a, b) -> a[0] == b[0]? a[1] - b[1] : a[0] - b[0]\\n        );\\n        for (int i = 0; i < nums.length; i++) {\\n            pq.offer(new int[] {nums[i], i});\\n        }\\n        \\n        Set<Integer> set = new HashSet<>();\\n        long score = 0;\\n        while (!pq.isEmpty() && set.size() != nums.length) {\\n            int[] top = pq.poll();\\n            if (set.contains(top[1])) {\\n                continue;\\n            }\\n            score += top[0];\\n            if (top[1] - 1 >= 0) {\\n                set.add(top[1] - 1);\\n            }\\n            if (top[1] + 1 < nums.length) {\\n                set.add(top[1] + 1);\\n            }\\n        }\\n        \\n        return score;\\n    }\\n}\\n```\\n---\\n*You can check out my video explanation (Channel link in profile bio).*\\n\\n---\\n##### Time complexity: $$O(n.logn)$$\\n##### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a, b) -> a[0] == b[0]? a[1] - b[1] : a[0] - b[0]\\n        );\\n        for (int i = 0; i < nums.length; i++) {\\n            pq.offer(new int[] {nums[i], i});\\n        }\\n        \\n        Set<Integer> set = new HashSet<>();\\n        long score = 0;\\n        while (!pq.isEmpty() && set.size() != nums.length) {\\n            int[] top = pq.poll();\\n            if (set.contains(top[1])) {\\n                continue;\\n            }\\n            score += top[0];\\n            if (top[1] - 1 >= 0) {\\n                set.add(top[1] - 1);\\n            }\\n            if (top[1] + 1 < nums.length) {\\n                set.add(top[1] + 1);\\n            }\\n        }\\n        \\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312923,
                "title": "c-sorting-map-easy-solution",
                "content": "# Intuition\\nSorting the given array so we would start with minimum and using map to store the positions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI sorted the array to get the minimum values and then stored the indexes(positions of the values in actual array). \\nIt is a simple way to store positions in map with a vector<int> to store for duplicate values and mark the positions.\\nSkip for same values.  \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> s(n,0);\\n        \\n        s = nums;\\n        sort(s.begin(), s.end());\\n\\n        long long  sc = 0;\\n        map<int,vector<int>> mp;\\n        \\n\\n        for (int idx=0; idx<n; idx++) {\\n\\n            if (mp.find(nums[idx]) == mp.end()) {\\n                vector<int> temp;\\n                temp.push_back(idx);\\n                mp.insert({nums[idx], temp});\\n            }\\n\\n            else {\\n                mp[nums[idx]].push_back(idx);\\n            }\\n        }\\n        \\n        for (int i=0; i<n; i++) {\\n            \\n            long long f = s[i];\\n            if (i>0 && s[i] == s[i-1]) continue;\\n            \\n            vector<int> pos = mp[f];\\n\\n            for (auto x: pos) {\\n            \\n                if (nums[x] != 0) {\\n                    sc += f;\\n                    nums[x] = 0;\\n                    if (x-1>=0) nums[x-1] = 0;\\n                    if (x+1<n) nums[x+1] = 0;\\n                }\\n            }\\n            \\n        }\\n        \\n        return sc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> s(n,0);\\n        \\n        s = nums;\\n        sort(s.begin(), s.end());\\n\\n        long long  sc = 0;\\n        map<int,vector<int>> mp;\\n        \\n\\n        for (int idx=0; idx<n; idx++) {\\n\\n            if (mp.find(nums[idx]) == mp.end()) {\\n                vector<int> temp;\\n                temp.push_back(idx);\\n                mp.insert({nums[idx], temp});\\n            }\\n\\n            else {\\n                mp[nums[idx]].push_back(idx);\\n            }\\n        }\\n        \\n        for (int i=0; i<n; i++) {\\n            \\n            long long f = s[i];\\n            if (i>0 && s[i] == s[i-1]) continue;\\n            \\n            vector<int> pos = mp[f];\\n\\n            for (auto x: pos) {\\n            \\n                if (nums[x] != 0) {\\n                    sc += f;\\n                    nums[x] = 0;\\n                    if (x-1>=0) nums[x-1] = 0;\\n                    if (x+1<n) nums[x+1] = 0;\\n                }\\n            }\\n            \\n        }\\n        \\n        return sc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312810,
                "title": "java-solution-min-heap-easy-to-understand",
                "content": "\\tExplanation:this is kind of BFS that we\\'re doing but here we\\'re limited to only adjacent sides, so if some cell is not visited add them \\t\\n\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic  long findScore(int[] nums) {\\n\\t\\t\\tlong sum=0;\\n\\t\\t\\tPriorityQueue<int[]> q = new PriorityQueue<>((x,y)-> {return  x[0]!=y[0]?x[0]-y[0]:x[1]-y[1]}); // so when you try to sort on values then there\\'s\\n\\t\\t\\t//a case where you you have two same numbers and it might choose the one with further index which will result in wrong ans\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tq.offer(new int[]{nums[i],i});\\n\\t\\t\\t}\\n\\n\\t\\t\\tboolean[] vis = new boolean[nums.length];\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tint val=q.peek()[0], index=q.peek()[1];\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t\\tif(!vis[index]){\\n\\t\\t\\t\\t\\tsum+=val;\\n\\t\\t\\t\\t\\tif(index-1>=0)vis[index-1]=true;\\n\\t\\t\\t\\t\\tif(index+1<nums.length)vis[index+1]=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn sum;\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic  long findScore(int[] nums) {\\n\\t\\t\\tlong sum=0;\\n\\t\\t\\tPriorityQueue<int[]> q = new PriorityQueue<>((x,y)-> {return  x[0]!=y[0]?x[0]-y[0]:x[1]-y[1]}",
                "codeTag": "Java"
            },
            {
                "id": 3312601,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func findScore(_ nums: [Int]) -> Int {\\n        var sorted = nums.enumerated().sorted(by: { $0.element < $1.element })\\n        var (v, score) = (Set<Int>(), 0)\\n\\n        for s in sorted {\\n            guard !v.contains(s.offset) else {continue}\\n            v.insert(s.offset + 1)\\n            v.insert(s.offset - 1)\\n            score += s.element\\n        }\\n\\n        return score\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findScore(_ nums: [Int]) -> Int {\\n        var sorted = nums.enumerated().sorted(by: { $0.element < $1.element })\\n        var (v, score) = (Set<Int>(), 0)\\n\\n        for s in sorted {\\n            guard !v.contains(s.offset) else {continue}\\n            v.insert(s.offset + 1)\\n            v.insert(s.offset - 1)\\n            score += s.element\\n        }\\n\\n        return score\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312597,
                "title": "min-heap-approach-nlogn",
                "content": "# Intuition\\nWe have to get the minimum element from the array in every pass so min heap is suitable. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a min heap and push all elements in min heap with a pair of {nums[i],i} \\n2. Create a visited array of size nums.size(); to keep a track of    elements that are visted ie index of minimum element, index of minimun element +1 and index of minimum element -1.\\n3. keep a track of count and increase it by adding the minimum element if that element is not visited.  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)- as there are n elements and we are pushing n elements in min heap\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)- for storing n elements in heap.\\nO(n)- for creating a visited array of size n\\n\\n------> O(2n)----->O(n)\\n\\n# Code\\n```\\ntypedef pair<int,int>pi;\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        priority_queue<pi,vector<pi>,greater<pi>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        long long ans=0;\\n       vector<int>visited(nums.size(),0);\\n        while(!pq.empty())\\n        {\\n            auto it=pq.top();\\n            int element=it.first;\\n            int index=it.second;\\n            pq.pop();\\n            if(visited[index]==0)\\n            {\\n                ans=ans+element;\\n                visited[index]=1;\\n                if(index-1>=0)\\n                visited[index-1]=1;\\n                if(index+1<=n-1)\\n                visited[index+1]=1;\\n                \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int,int>pi;\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        priority_queue<pi,vector<pi>,greater<pi>>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        long long ans=0;\\n       vector<int>visited(nums.size(),0);\\n        while(!pq.empty())\\n        {\\n            auto it=pq.top();\\n            int element=it.first;\\n            int index=it.second;\\n            pq.pop();\\n            if(visited[index]==0)\\n            {\\n                ans=ans+element;\\n                visited[index]=1;\\n                if(index-1>=0)\\n                visited[index-1]=1;\\n                if(index+1<=n-1)\\n                visited[index+1]=1;\\n                \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312561,
                "title": "simple-priority-queue-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]==b[1] ? a[0]-b[0] : a[1]-b[1]);\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            pq.add(new int[]{i,nums[i]});\\n        }\\n        Set<Integer> set=new HashSet<>();\\n        long ans=0;\\n        while(!pq.isEmpty()){\\n            int a[]=pq.poll();\\n            if(set.contains(a[0])){\\n                continue;\\n            }\\n            else{\\n                // System.out.println(a[1]);\\n                ans+=a[1];\\n                set.add(a[0]);\\n                set.add(a[0]+1);\\n                set.add(a[0]-1);\\n                // System.out.println(set);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]==b[1] ? a[0]-b[0] : a[1]-b[1]);\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            pq.add(new int[]{i,nums[i]});\\n        }\\n        Set<Integer> set=new HashSet<>();\\n        long ans=0;\\n        while(!pq.isEmpty()){\\n            int a[]=pq.poll();\\n            if(set.contains(a[0])){\\n                continue;\\n            }\\n            else{\\n                // System.out.println(a[1]);\\n                ans+=a[1];\\n                set.add(a[0]);\\n                set.add(a[0]+1);\\n                set.add(a[0]-1);\\n                // System.out.println(set);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312398,
                "title": "complete-explanation-map-queue-c",
                "content": "\\n\\n# Approach\\nThe code creates a map that stores the indices of each number in the input array. It then loops through the map, selecting the smallest unmarked number and adding it to the score while marking it and its adjacent elements. The code keeps track of visited elements using a vector, and removes the index from the map once it has been marked. The loop continues until all numbers have been marked, and the final score is returned.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(nlogn)$$\\n<!-- Add y$$O(n)$$our time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Create a map to store the indices of each number in the array\\n        map<int, queue<int>> num_indices;\\n        for(int i = 0; i < n; i++){\\n            num_indices[nums[i]].push(i);\\n        }\\n        \\n        // Initialize the answer and visited array\\n        ll ans = 0;\\n        vector<int> visited(n, 0);\\n        \\n        // Loop until all numbers are marked\\n        while(num_indices.size() > 0){\\n            // Get the smallest unmarked number from the map\\n            int num = num_indices.begin()->first;\\n            int index = num_indices.begin()->second.front();\\n            \\n            // Check if the number is marked\\n            if(!visited[index]){\\n                // Add the number to the score and mark it and its adjacent elements\\n                ans += nums[index];\\n                visited[index] = 1;\\n                if(index-1 >= 0) visited[index-1] = 1;\\n                if(index+1 < n) visited[index+1] = 1;\\n            }\\n            \\n            // Remove the index from the map\\n            num_indices.begin()->second.pop();\\n            if(num_indices.begin()->second.size() == 0){\\n            //if there is not any remaning index for nums[i] in map then erase the mp[nums[i]]\\n                num_indices.erase(num_indices.begin());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Ordered Map"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Create a map to store the indices of each number in the array\\n        map<int, queue<int>> num_indices;\\n        for(int i = 0; i < n; i++){\\n            num_indices[nums[i]].push(i);\\n        }\\n        \\n        // Initialize the answer and visited array\\n        ll ans = 0;\\n        vector<int> visited(n, 0);\\n        \\n        // Loop until all numbers are marked\\n        while(num_indices.size() > 0){\\n            // Get the smallest unmarked number from the map\\n            int num = num_indices.begin()->first;\\n            int index = num_indices.begin()->second.front();\\n            \\n            // Check if the number is marked\\n            if(!visited[index]){\\n                // Add the number to the score and mark it and its adjacent elements\\n                ans += nums[index];\\n                visited[index] = 1;\\n                if(index-1 >= 0) visited[index-1] = 1;\\n                if(index+1 < n) visited[index+1] = 1;\\n            }\\n            \\n            // Remove the index from the map\\n            num_indices.begin()->second.pop();\\n            if(num_indices.begin()->second.size() == 0){\\n            //if there is not any remaning index for nums[i] in map then erase the mp[nums[i]]\\n                num_indices.erase(num_indices.begin());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312380,
                "title": "c-solution-using-priority-queue-and-set-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& numbers) {\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> minHeap;\\n        \\n        for (int i = 0; i < numbers.size(); i++)\\n            minHeap.push({numbers[i], i});//Pushing the element with its index\\n        \\n        long long maxScore = 0LL;\\n        unordered_set<int> visIndices;//set to store marked indices\\n        while (!minHeap.empty()) {\\n            vector<int> current = minHeap.top();\\n            minHeap.pop();\\n            if (visIndices.count(current[1]))//If given index is already marked\\n                continue;\\n            maxScore += current[0];//Add to our score\\n\\t\\t\\t//Marking the current and adjacent elements\\n            visIndices.insert(current[1]);\\n            visIndices.insert(current[1] - 1);\\n            visIndices.insert(current[1] + 1);\\n        }\\n        return maxScore; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& numbers) {\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> minHeap;\\n        \\n        for (int i = 0; i < numbers.size(); i++)\\n            minHeap.push({numbers[i], i});//Pushing the element with its index\\n        \\n        long long maxScore = 0LL;\\n        unordered_set<int> visIndices;//set to store marked indices\\n        while (!minHeap.empty()) {\\n            vector<int> current = minHeap.top();\\n            minHeap.pop();\\n            if (visIndices.count(current[1]))//If given index is already marked\\n                continue;\\n            maxScore += current[0];//Add to our score\\n\\t\\t\\t//Marking the current and adjacent elements\\n            visIndices.insert(current[1]);\\n            visIndices.insert(current[1] - 1);\\n            visIndices.insert(current[1] + 1);\\n        }\\n        return maxScore; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312272,
                "title": "python-heap",
                "content": "# Code\\n```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        visited = set()\\n        h = [(num, i) for i,num in enumerate(nums)]\\n        heapify(h)\\n        res = 0\\n        while h:\\n            num, i = heappop(h)\\n            if i not in visited:\\n                res += num\\n                if i-1>=0:\\n                    visited.add(i-1)\\n                if i+1<n:\\n                    visited.add(i+1)\\n                visited.add(i)\\n        return res\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        visited = set()\\n        h = [(num, i) for i,num in enumerate(nums)]\\n        heapify(h)\\n        res = 0\\n        while h:\\n            num, i = heappop(h)\\n            if i not in visited:\\n                res += num\\n                if i-1>=0:\\n                    visited.add(i-1)\\n                if i+1<n:\\n                    visited.add(i+1)\\n                visited.add(i)\\n        return res\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312232,
                "title": "simple-c-approach",
                "content": "# Complexity\\n- Time complexity: O(n*log(n)) for sorting\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nJust simply store value and original index and then sort it.\\nAfter that just traverse new array and keep track of marked index.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        vector<vector<int>> aux;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++){aux.push_back({nums[i],i});}\\n        sort(aux.begin(),aux.end(),[&](vector<int>& a,vector<int>& b){return a[0]==b[0]?a[1]<b[1]:a[0]<b[0];});\\n        vector<int> vis(n,1);\\n        long long ans=0;\\n        for(int i=0; i<n; i++){\\n            if(vis[aux[i][1]]){\\n                vis[aux[i][1]]=0;\\n                ans+=aux[i][0];\\n                if(aux[i][1]){vis[aux[i][1]-1]=0;}\\n                if(aux[i][1]<n-1){vis[aux[i][1]+1]=0;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        vector<vector<int>> aux;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++){aux.push_back({nums[i],i});}\\n        sort(aux.begin(),aux.end(),[&](vector<int>& a,vector<int>& b){return a[0]==b[0]?a[1]<b[1]:a[0]<b[0];});\\n        vector<int> vis(n,1);\\n        long long ans=0;\\n        for(int i=0; i<n; i++){\\n            if(vis[aux[i][1]]){\\n                vis[aux[i][1]]=0;\\n                ans+=aux[i][0];\\n                if(aux[i][1]){vis[aux[i][1]-1]=0;}\\n                if(aux[i][1]<n-1){vis[aux[i][1]+1]=0;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312195,
                "title": "min-heap-c-short-sweet-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long int ans = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int i =0, n = nums.size();\\n        while(i<n){\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n        vector<int> v(n,1);\\n        while(!pq.empty()){\\n            pair<int,int> p = pq.top();\\n            pq.pop();\\n            if(v[p.second]){\\n                ans += p.first;\\n                if(p.second-1>=0){\\n                    v[p.second-1] = 0;\\n                }\\n                if(p.second+1<n){\\n                    v[p.second+1] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long int ans = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int i =0, n = nums.size();\\n        while(i<n){\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n        vector<int> v(n,1);\\n        while(!pq.empty()){\\n            pair<int,int> p = pq.top();\\n            pq.pop();\\n            if(v[p.second]){\\n                ans += p.first;\\n                if(p.second-1>=0){\\n                    v[p.second-1] = 0;\\n                }\\n                if(p.second+1<n){\\n                    v[p.second+1] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3312183,
                "title": "priority-queue-c",
                "content": "# Approach\\nAs we have to obtain minimum value at each iteration, we can use `priority queue` here. Next, we only have to pick the minimum element from the priority queue, mark its adjacent element in the `ma` array.\\n\\nThe score is added to our answer only if the popped out element is not previously marked.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*n) $$\\u2248$$ O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define pii pair<int, int>\\nclass Solution\\n{\\npublic:\\n    long long findScore(vector<int> &a)\\n    {\\n        long long sc = 0ll;\\n        priority_queue<pii, vector<pii>, greater<pii>> s;\\n        for (int i = 0; i < a.size(); ++i)\\n            s.push({a[i], i});\\n        vector<int> ma(a.size(), 0);\\n        while (!s.empty())\\n        {\\n            auto [ele, in] = s.top();\\n            s.pop();\\n            if (ma[in] == 0)\\n            {\\n                ma[in] = 1;\\n                if (in - 1 >= 0)\\n                    ma[in - 1] = 1;\\n                if (in + 1 < a.size())\\n                    ma[in + 1] = 1;\\n                sc += 0ll + ele;\\n            }\\n        }\\n        return sc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pii pair<int, int>\\nclass Solution\\n{\\npublic:\\n    long long findScore(vector<int> &a)\\n    {\\n        long long sc = 0ll;\\n        priority_queue<pii, vector<pii>, greater<pii>> s;\\n        for (int i = 0; i < a.size(); ++i)\\n            s.push({a[i], i});\\n        vector<int> ma(a.size(), 0);\\n        while (!s.empty())\\n        {\\n            auto [ele, in] = s.top();\\n            s.pop();\\n            if (ma[in] == 0)\\n            {\\n                ma[in] = 1;\\n                if (in - 1 >= 0)\\n                    ma[in - 1] = 1;\\n                if (in + 1 < a.size())\\n                    ma[in + 1] = 1;\\n                sc += 0ll + ele;\\n            }\\n        }\\n        return sc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312094,
                "title": "understandable-set-unordered-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();\\n        set<pair<int,int>>st;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert({nums[i],i});\\n            mp[i]=nums[i];\\n        }\\n        long long score=0;\\n        while(!st.empty())\\n        {\\n            auto it=st.begin();\\n            int val=it->first;\\n            int index=it->second;\\n            st.erase({val,index});\\n            cout<<val<<\" \"<<endl;\\n            score+=val;\\n            if(index+1<n)\\n            {\\n                int temp=mp[index+1];\\n                if(st.find({temp,index+1})!=st.end())st.erase({temp,index+1});\\n            }\\n            if(index-1>=0)\\n            {\\n                int temp=mp[index-1];\\n                if(st.find({temp,index-1})!=st.end())st.erase({temp,index-1});\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();\\n        set<pair<int,int>>st;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert({nums[i],i});\\n            mp[i]=nums[i];\\n        }\\n        long long score=0;\\n        while(!st.empty())\\n        {\\n            auto it=st.begin();\\n            int val=it->first;\\n            int index=it->second;\\n            st.erase({val,index});\\n            cout<<val<<\" \"<<endl;\\n            score+=val;\\n            if(index+1<n)\\n            {\\n                int temp=mp[index+1];\\n                if(st.find({temp,index+1})!=st.end())st.erase({temp,index+1});\\n            }\\n            if(index-1>=0)\\n            {\\n                int temp=mp[index-1];\\n                if(st.find({temp,index-1})!=st.end())st.erase({temp,index-1});\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3312093,
                "title": "python-heapq",
                "content": "```python\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        score, heap, marked = 0, [], set()\\n        \\n        for i, n in enumerate(nums):\\n            heappush(heap, (n, i))\\n        \\n        while heap:\\n            n, i = heappop(heap)\\n            if i in marked:\\n                continue\\n\\n            score += n\\n            marked |= {i - 1, i + 1}\\n\\n        return score\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        score, heap, marked = 0, [], set()\\n        \\n        for i, n in enumerate(nums):\\n            heappush(heap, (n, i))\\n        \\n        while heap:\\n            n, i = heappop(heap)\\n            if i in marked:\\n                continue\\n\\n            score += n\\n            marked |= {i - 1, i + 1}\\n\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312079,
                "title": "c-well-commented-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to get the elements and their indexes. Then, sort the elements so that we can access the minimum element first and mark the adjacent elements using the stored indexes.\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size(); \\n        vector<bool>marked(n,false); // stores whether an element is marked or not\\n        vector<pair<long long, int>>sorted; // to get the elements and their indexes\\n        for(int i=0;i<n;i++){\\n            sorted.push_back({nums[i],i}); \\n        }\\n        sort(sorted.begin(),sorted.end()); // sort the elements so that we can choose minimum element first\\n        long long score=0; \\n        for(auto p:sorted){\\n            int num=p.first,idx=p.second;\\n            if(!marked[idx]){ // if not already marked \\n                score+=num;\\n                marked[idx]=true;  // mark it true and mark the adjacent elements\\n                if(idx>0)\\n                    marked[idx-1]=true; \\n                if(idx<n-1)\\n                    marked[idx+1]=true;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size(); \\n        vector<bool>marked(n,false); // stores whether an element is marked or not\\n        vector<pair<long long, int>>sorted; // to get the elements and their indexes\\n        for(int i=0;i<n;i++){\\n            sorted.push_back({nums[i],i}); \\n        }\\n        sort(sorted.begin(),sorted.end()); // sort the elements so that we can choose minimum element first\\n        long long score=0; \\n        for(auto p:sorted){\\n            int num=p.first,idx=p.second;\\n            if(!marked[idx]){ // if not already marked \\n                score+=num;\\n                marked[idx]=true;  // mark it true and mark the adjacent elements\\n                if(idx>0)\\n                    marked[idx-1]=true; \\n                if(idx<n-1)\\n                    marked[idx+1]=true;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312078,
                "title": "c-min-heap-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long int ans=0;\\n        vector<int>v(nums.size(), 0);\\n        map<int, int>m;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>q;\\n        for(int i=0; i<nums.size(); i++){\\n            q.push({nums[i], i});\\n        }\\n        while(!q.empty()){\\n            int ft=q.top().first, sc=q.top().second;\\n            q.pop();\\n            if(!v[sc]){\\n                ans+=ft;\\n                v[sc]++;\\n                if(sc<nums.size()-1){\\n                    if(!v[sc+1]){v[sc+1]++;}\\n                }\\n                if(sc>0){\\n                    if(!v[sc-1]){v[sc-1]++;}\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long int ans=0;\\n        vector<int>v(nums.size(), 0);\\n        map<int, int>m;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>q;\\n        for(int i=0; i<nums.size(); i++){\\n            q.push({nums[i], i});\\n        }\\n        while(!q.empty()){\\n            int ft=q.top().first, sc=q.top().second;\\n            q.pop();\\n            if(!v[sc]){\\n                ans+=ft;\\n                v[sc]++;\\n                if(sc<nums.size()-1){\\n                    if(!v[sc+1]){v[sc+1]++;}\\n                }\\n                if(sc>0){\\n                    if(!v[sc-1]){v[sc-1]++;}\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312057,
                "title": "easy-java-solution-treemap-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long score=0;\\n        Map<Integer,ArrayList<Integer>> tm= new TreeMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(tm.containsKey(nums[i])){\\n                ArrayList<Integer> list=tm.get(nums[i]);\\n                list.add(i);\\n                tm.put(nums[i],list);\\n            }\\n            else{\\n                tm.put(nums[i],new ArrayList<Integer>());\\n                ArrayList<Integer> list=tm.get(nums[i]);\\n                list.add(i);\\n                tm.put(nums[i],list);\\n            }\\n        }\\n            HashSet<Integer> hs=new HashSet<>();\\n            for (Map.Entry<Integer,ArrayList<Integer>>e : tm.entrySet()){\\n                if(hs.size()<nums.length){\\n                    ArrayList<Integer> arr=e.getValue();\\n                    for(int j=0;j<arr.size();j++){\\n                        if(!hs.contains(arr.get(j))){\\n                            hs.add(arr.get(j));\\n                            if((arr.get(j))-1>=0)\\n                                hs.add((arr.get(j))-1);\\n                            if((arr.get(j)+1)<nums.length)\\n                                hs.add((arr.get(j))+1);\\n                            score+=e.getKey();\\n                        }\\n                    }\\n                }\\n            }\\n            return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long score=0;\\n        Map<Integer,ArrayList<Integer>> tm= new TreeMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(tm.containsKey(nums[i])){\\n                ArrayList<Integer> list=tm.get(nums[i]);\\n                list.add(i);\\n                tm.put(nums[i],list);\\n            }\\n            else{\\n                tm.put(nums[i],new ArrayList<Integer>());\\n                ArrayList<Integer> list=tm.get(nums[i]);\\n                list.add(i);\\n                tm.put(nums[i],list);\\n            }\\n        }\\n            HashSet<Integer> hs=new HashSet<>();\\n            for (Map.Entry<Integer,ArrayList<Integer>>e : tm.entrySet()){\\n                if(hs.size()<nums.length){\\n                    ArrayList<Integer> arr=e.getValue();\\n                    for(int j=0;j<arr.size();j++){\\n                        if(!hs.contains(arr.get(j))){\\n                            hs.add(arr.get(j));\\n                            if((arr.get(j))-1>=0)\\n                                hs.add((arr.get(j))-1);\\n                            if((arr.get(j)+1)<nums.length)\\n                                hs.add((arr.get(j))+1);\\n                            score+=e.getKey();\\n                        }\\n                    }\\n                }\\n            }\\n            return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312025,
                "title": "c-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans=0;\\n        vector<bool> vis(nums.size(),false);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        while(pq.size()){\\n            auto x = pq.top();\\n            pq.pop();\\n            if(!vis[x.second]){\\n                ans += x.first;\\n                vis[x.second] = true;\\n                if(x.second>0 && !vis[x.second-1]){\\n                    vis[x.second-1] = true;\\n                }\\n                if(x.second+1<nums.size() && !vis[x.second+1]){\\n                    vis[x.second+1] = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans=0;\\n        vector<bool> vis(nums.size(),false);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        while(pq.size()){\\n            auto x = pq.top();\\n            pq.pop();\\n            if(!vis[x.second]){\\n                ans += x.first;\\n                vis[x.second] = true;\\n                if(x.second>0 && !vis[x.second-1]){\\n                    vis[x.second-1] = true;\\n                }\\n                if(x.second+1<nums.size() && !vis[x.second+1]){\\n                    vis[x.second+1] = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084442,
                "title": "python3-solution-with-using-heap",
                "content": "# Code\\n```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        heap = []\\n\\n        marked = set()\\n\\n        for idx, num in enumerate(nums):\\n            heapq.heappush(heap, (num, idx))\\n        \\n        score = 0\\n        while heap:\\n            num, idx = heapq.heappop(heap)\\n\\n            if idx in marked: continue\\n\\n            score += num\\n\\n            marked.add(idx)\\n            marked.add(idx - 1)\\n            marked.add(idx + 1)\\n        \\n        return score\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        heap = []\\n\\n        marked = set()\\n\\n        for idx, num in enumerate(nums):\\n            heapq.heappush(heap, (num, idx))\\n        \\n        score = 0\\n        while heap:\\n            num, idx = heapq.heappop(heap)\\n\\n            if idx in marked: continue\\n\\n            score += num\\n\\n            marked.add(idx)\\n            marked.add(idx - 1)\\n            marked.add(idx + 1)\\n        \\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071213,
                "title": "min-heap-custom-comaprator-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass structure {\\n    public:  \\n      int val;\\n      int left;\\n      int right;\\n      int index;\\n\\n      structure(int a, int b,int c,int d){\\n          val=a;\\n          left=b;\\n          right=c;\\n          index=d;\\n      }\\n\\n     \\n\\n};\\n\\nclass Compare {\\npublic:\\n    bool operator()(structure* s1, structure* s2)\\n    {\\n         if(s1->val ==s2->val){\\n             return s1->index>s2->index;\\n         }\\n        \\n\\n        return s1->val>s2->val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n     \\n\\n\\n    long long findScore(vector<int>& nums) {\\n          \\n\\n          if(nums.size()==1){\\n              return nums[0];\\n          } \\n\\n          long long ans=0;\\n\\n          priority_queue<structure*,vector<structure*>,Compare>pq;\\n          map<int,int>mp;\\n         for(int i=0;i<nums.size();i++){\\n       \\n             if(i==0 ){\\n\\n                   structure*  temp=new structure(nums[i],-1,i+1,i);\\n                    pq.push(temp);\\n                    continue;\\n             }\\n\\n             if(i==nums.size()-1){\\n                    structure* temp=new structure(nums[i],i-1,-1,i);\\n                     pq.push(temp);\\n                     continue;\\n             }\\n\\n\\n                 structure* temp=new structure(nums[i],i-1,i+1,i);\\n            //  mp[nums[i]]++;\\n\\n             pq.push(temp);\\n         }\\n\\n         while(!pq.empty()){\\n               \\n               structure* temp=pq.top();\\n               pq.pop();\\n            //whole logic \\n\\n            if(mp.find(temp->index)==mp.end()){\\n                \\n                ans+=temp->val;\\n                mp[temp->left]=1;\\n                mp[temp->right]=1;\\n                mp[temp->index]=1;\\n\\n                \\n\\n            }\\n\\n\\n\\n         }\\n\\n\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass structure {\\n    public:  \\n      int val;\\n      int left;\\n      int right;\\n      int index;\\n\\n      structure(int a, int b,int c,int d){\\n          val=a;\\n          left=b;\\n          right=c;\\n          index=d;\\n      }\\n\\n     \\n\\n};\\n\\nclass Compare {\\npublic:\\n    bool operator()(structure* s1, structure* s2)\\n    {\\n         if(s1->val ==s2->val){\\n             return s1->index>s2->index;\\n         }\\n        \\n\\n        return s1->val>s2->val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n     \\n\\n\\n    long long findScore(vector<int>& nums) {\\n          \\n\\n          if(nums.size()==1){\\n              return nums[0];\\n          } \\n\\n          long long ans=0;\\n\\n          priority_queue<structure*,vector<structure*>,Compare>pq;\\n          map<int,int>mp;\\n         for(int i=0;i<nums.size();i++){\\n       \\n             if(i==0 ){\\n\\n                   structure*  temp=new structure(nums[i],-1,i+1,i);\\n                    pq.push(temp);\\n                    continue;\\n             }\\n\\n             if(i==nums.size()-1){\\n                    structure* temp=new structure(nums[i],i-1,-1,i);\\n                     pq.push(temp);\\n                     continue;\\n             }\\n\\n\\n                 structure* temp=new structure(nums[i],i-1,i+1,i);\\n            //  mp[nums[i]]++;\\n\\n             pq.push(temp);\\n         }\\n\\n         while(!pq.empty()){\\n               \\n               structure* temp=pq.top();\\n               pq.pop();\\n            //whole logic \\n\\n            if(mp.find(temp->index)==mp.end()){\\n                \\n                ans+=temp->val;\\n                mp[temp->left]=1;\\n                mp[temp->right]=1;\\n                mp[temp->index]=1;\\n\\n                \\n\\n            }\\n\\n\\n\\n         }\\n\\n\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063021,
                "title": "beats-85-sc-no-extra-set-array-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI got the intuition from this question https://leetcode.com/problems/missing-number . It is obvious we need to use a priority queue because we have to start removing the smallest unmarked number and its adjecents.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPut all elements of array along with their index in the priority queue. in the format q.push({num,index})\\nStart popping the element from queue and mark index, index+1 and index-1(if all of them exist) as negative in nums array.\\nand only add the valid nums[index] values\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)(for initialing the pq)\\nO(n)(for the main loop in which I am popping from the pq)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n     // Max value based on the constraint\\n        int n = nums.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, MyComparator> pq;\\n\\n        for (int i = 0; i < n; i++) {\\n            pq.push({nums[i], i});\\n        }\\n        long long sum = 0;\\n\\n        while (!pq.empty()) {\\n            int minElement = pq.top().first;\\n            int index = pq.top().second;\\n            pq.pop();\\n            if ( nums[index]>0) {\\n            cout<<\"minElement \"<<minElement<<\"index \"<<index<<endl;\\n                sum += minElement;\\n                nums[index]=-nums[index];\\n                if(index-1>=0 && nums[index-1]>0)\\n                {\\n                    nums[index-1]=-nums[index-1];\\n                }\\n                if(index+1<=n-1 && nums[index+1]>0)\\n                {\\n                    nums[index+1]=-nums[index+1];\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\nprivate:\\n    struct MyComparator{\\n    bool operator()(const pair<int,int>&a,const pair<int,int>&b) {\\n          if(a.first==b.first){\\n              return a.second>b.second;\\n          }\\n          return a.first>b.first;\\n        }\\n    };\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n     // Max value based on the constraint\\n        int n = nums.size();\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, MyComparator> pq;\\n\\n        for (int i = 0; i < n; i++) {\\n            pq.push({nums[i], i});\\n        }\\n        long long sum = 0;\\n\\n        while (!pq.empty()) {\\n            int minElement = pq.top().first;\\n            int index = pq.top().second;\\n            pq.pop();\\n            if ( nums[index]>0) {\\n            cout<<\"minElement \"<<minElement<<\"index \"<<index<<endl;\\n                sum += minElement;\\n                nums[index]=-nums[index];\\n                if(index-1>=0 && nums[index-1]>0)\\n                {\\n                    nums[index-1]=-nums[index-1];\\n                }\\n                if(index+1<=n-1 && nums[index+1]>0)\\n                {\\n                    nums[index+1]=-nums[index+1];\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\nprivate:\\n    struct MyComparator{\\n    bool operator()(const pair<int,int>&a,const pair<int,int>&b) {\\n          if(a.first==b.first){\\n              return a.second>b.second;\\n          }\\n          return a.first>b.first;\\n        }\\n    };\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4058177,
                "title": "simple-c-solution-ordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        set<pair<int,int>> st;\\n        for(int i=0;i<nums.size();i++) st.insert({nums[i], i});\\n        long long score = 0;\\n        while(st.size() > 0) {\\n            auto ele = *st.begin();\\n            auto ind = ele.second;\\n            score += ele.first;\\n            st.erase(ele);\\n\\n            if(ind-1 >= 0) {\\n                pair<int,int> lft_ele = {nums[ind-1], ind-1};\\n                if(st.count(lft_ele) == 1) st.erase(lft_ele);\\n            }\\n\\n            \\n            if(ind+1 < nums.size()) {\\n                pair<int,int> rgh_ele = {nums[ind+1], ind+1};\\n                if(st.count(rgh_ele) == 1) st.erase(rgh_ele);\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        set<pair<int,int>> st;\\n        for(int i=0;i<nums.size();i++) st.insert({nums[i], i});\\n        long long score = 0;\\n        while(st.size() > 0) {\\n            auto ele = *st.begin();\\n            auto ind = ele.second;\\n            score += ele.first;\\n            st.erase(ele);\\n\\n            if(ind-1 >= 0) {\\n                pair<int,int> lft_ele = {nums[ind-1], ind-1};\\n                if(st.count(lft_ele) == 1) st.erase(lft_ele);\\n            }\\n\\n            \\n            if(ind+1 < nums.size()) {\\n                pair<int,int> rgh_ele = {nums[ind+1], ind+1};\\n                if(st.count(rgh_ele) == 1) st.erase(rgh_ele);\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044553,
                "title": "simple-java-solution-minheap-hashset",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a priority queue (min heap) pq with a custom comparator that compares pairs based on the number and its index.\\n2. Create a HashSet to store the visited elements in the given array.\\n3. Iterate through the array and add each entry as a pair to the priority queue.\\n4. While the priority queue is not empty, extract the peek element from the priority queue and if is not visited add it to ans and mark its left and right indices as visited.\\n5. Return the ans. \\n\\n# Complexity\\n- Time complexity: O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        int num;\\n        int index;\\n        Pair(int num, int index){\\n            this.num = num;\\n            this.index = index;\\n        }\\n    }\\n    public long findScore(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>(){\\n            public int compare(Pair a, Pair b){\\n                if(a.num == b.num){\\n                    return a.index-b.index;\\n                }\\n                return a.num - b.num;\\n            }\\n        });\\n        HashSet<Integer> visited = new HashSet<>();\\n        long ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            pq.add(new Pair(nums[i], i));\\n        }\\n\\n        while(!pq.isEmpty()){\\n            Pair temp = pq.poll();\\n            if(!visited.contains(temp.index)){\\n                visited.add(temp.index);\\n                ans += temp.num;\\n                int left = temp.index - 1;\\n                int right = temp.index + 1;\\n\\n                if(left>=0 && !visited.contains(left)){\\n                    visited.add(left);\\n                }\\n                if(right<n && !visited.contains(right)){\\n                    visited.add(right);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int num;\\n        int index;\\n        Pair(int num, int index){\\n            this.num = num;\\n            this.index = index;\\n        }\\n    }\\n    public long findScore(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>(){\\n            public int compare(Pair a, Pair b){\\n                if(a.num == b.num){\\n                    return a.index-b.index;\\n                }\\n                return a.num - b.num;\\n            }\\n        });\\n        HashSet<Integer> visited = new HashSet<>();\\n        long ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            pq.add(new Pair(nums[i], i));\\n        }\\n\\n        while(!pq.isEmpty()){\\n            Pair temp = pq.poll();\\n            if(!visited.contains(temp.index)){\\n                visited.add(temp.index);\\n                ans += temp.num;\\n                int left = temp.index - 1;\\n                int right = temp.index + 1;\\n\\n                if(left>=0 && !visited.contains(left)){\\n                    visited.add(left);\\n                }\\n                if(right<n && !visited.contains(right)){\\n                    visited.add(right);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041635,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int findScore(List<int> nums) {\\n      var total = 0;\\n      final List<Pair> e = [];\\n      for (int i = 0; i < nums.length; i++) {\\n          e.add(Pair(nums[i], i));\\n      }\\n\\n      final List<bool> marked = List.filled(nums.length, false);\\n\\n      e.sort((a, b) {\\n          if (a.val == b.val) {\\n              return a.idx.compareTo(b.idx);\\n          } else {\\n              return a.val.compareTo(b.val);\\n          }\\n      });\\n      for (var i in e) {\\n          final value = i.val;\\n          final index = i.idx;\\n          if (!marked[index]) {\\n              total += value;\\n              marked[index] = true;\\n              if (index > 0) {\\n                  marked[index - 1] = true;\\n              }\\n              if (index < nums.length - 1) {\\n                  marked[index + 1] = true;\\n              }             \\n          }\\n      }\\n\\n      return total;\\n  }\\n}\\n\\nclass Pair<T extends Object> {\\n    Pair(this.val, this.idx);\\n\\n    final int val;\\n    final int idx;\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int findScore(List<int> nums) {\\n      var total = 0;\\n      final List<Pair> e = [];\\n      for (int i = 0; i < nums.length; i++) {\\n          e.add(Pair(nums[i], i));\\n      }\\n\\n      final List<bool> marked = List.filled(nums.length, false);\\n\\n      e.sort((a, b) {\\n          if (a.val == b.val) {\\n              return a.idx.compareTo(b.idx);\\n          } else {\\n              return a.val.compareTo(b.val);\\n          }\\n      });\\n      for (var i in e) {\\n          final value = i.val;\\n          final index = i.idx;\\n          if (!marked[index]) {\\n              total += value;\\n              marked[index] = true;\\n              if (index > 0) {\\n                  marked[index - 1] = true;\\n              }\\n              if (index < nums.length - 1) {\\n                  marked[index + 1] = true;\\n              }             \\n          }\\n      }\\n\\n      return total;\\n  }\\n}\\n\\nclass Pair<T extends Object> {\\n    Pair(this.val, this.idx);\\n\\n    final int val;\\n    final int idx;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029105,
                "title": "c-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can take help of set for performing this. Set will store nums with their respective indexes in sorted order so we can get minimum element easily and also remove the no longer needed elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a set for storing pairs of {nums[index],index}.\\n2. Pick the top element of set everytime and add it to result. Remove the pairs {index-1} and {index+1} from the set. Also remove the current index pair from set.\\n3. When set beacomes empty, return the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n        set<pair<int, int>>s;     // {nums[i],i}\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            s.insert({nums[i],i});\\n        }\\n        \\n        long long ans = 0;\\n        \\n        while(!s.empty()){\\n            \\n            auto it = s.begin();\\n            \\n            \\n            int num = it->first;\\n            int idx = it->second;\\n            \\n            ans+= num;\\n            \\n            if(idx!=0){\\n                s.erase({nums[idx-1],idx-1});\\n            }\\n            \\n            if(idx!=nums.size()-1){\\n                s.erase({nums[idx+1],idx+1});\\n            }\\n            \\n            s.erase(it);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n        set<pair<int, int>>s;     // {nums[i],i}\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            s.insert({nums[i],i});\\n        }\\n        \\n        long long ans = 0;\\n        \\n        while(!s.empty()){\\n            \\n            auto it = s.begin();\\n            \\n            \\n            int num = it->first;\\n            int idx = it->second;\\n            \\n            ans+= num;\\n            \\n            if(idx!=0){\\n                s.erase({nums[idx-1],idx-1});\\n            }\\n            \\n            if(idx!=nums.size()-1){\\n                s.erase({nums[idx+1],idx+1});\\n            }\\n            \\n            s.erase(it);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021026,
                "title": "python-brute-force-sorting-minheap",
                "content": "# **1. BRUTE FORCE SOLUTION - O(N^2)**\\n\\nAs the problem statement says, we repeat the steps until we have marked all the elements in the list.\\n\\nSo basically, until the number of marked elements are not \"n\", we have to get the current smallest unmarked element, increment the score, and mark its left and right elements, if possible.\\n\\nIn the Brute Force approach, in each iteration, we will have to traverse the whole list to get the smallest at that point hence, the overall time complexity becomes O(N^2) and so, this solution fails for large test cases.\\n\\n\\n```\\ndef findScore(self, nums: List[int]) -> int:\\n\\t# Length of the list\\n\\tn = len(nums)\\n\\n\\t# Score to return\\n\\tscore = 0\\n\\n\\t# Elements that have been marked\\n\\tmarkedElements = set()\\n\\n\\t# Index of smallest element\\n\\tsmallestIdx = -1\\n\\n\\twhile len(markedElements) != n:\\n\\n\\t\\t# Smallest element\\n\\t\\tsmallestElement = float(\"inf\")\\n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif i not in markedElements and nums[i] < smallestElement: \\n\\t\\t\\t\\tsmallestElement = nums[i]\\n\\t\\t\\t\\tsmallestIdx = i\\n\\n\\t\\t# Increment the score\\n\\t\\tscore += smallestElement\\n\\n\\t\\t# Mark the elements\\n\\t\\tmarkedElements.add(smallestIdx)\\n\\n\\t\\t# Mark the index on left\\n\\t\\tif smallestIdx > 0: markedElements.add(smallestIdx - 1)  \\n\\n\\t\\t# Mark the index on right\\n\\t\\tif smallestIdx < n - 1: markedElements.add(smallestIdx + 1)\\n\\n\\n\\t# Return the score\\n\\treturn score\\n```\\n\\n# **2. SORTING SOLUTION - O(NLogN)**\\nFrom the Brute Force solution, it is easy to figure out that the reason why it fails is because we have to find the next smallest element in each iteration. But, what if we knew what index would be the smallest at any point of time? We can know that by sorting the list.\\n\\nBut do note that since the marking of indices has to be done on the original list, we cannot sort the original list. We have to create a whole new list that has a pair at each index - (element, original index). And then, we can sort the list by the elements in increasing order.\\n\\nIn this way, we can know at any time, what index in the original list will have the smallest element.\\n\\n\\tFor example, nums = [2,1,3,4,5,2]\\n\\t\\n\\tSo, first we create pairs -\\n\\t\\n\\tnewList = [(2,0), (1,1), (3,2), (4,3), (5,4), (2,5)]\\n\\t\\n\\tAnd now, we can sort it in increasing order\\n\\t\\n\\tnewList = [(1,1), (2,0), (2,5), (3,2), (4,3), (5,4)]\\n\\t\\n\\tSo now, in each iteration we can easily get the smallest index in original list\\n\\tby keeping track of the newList indices.\\n\\t\\n\\tSo initially, newList[0] is the smallest -> (1,1)\\n\\tIt means, in the original list, the index \"1\" will have the smallest element in first iteration\\n\\t\\n\\tSo, we will increment score by 1. Score = 1\\n\\tAnd mark the elements on left and right.\\n\\t\\n\\tSo, we mark the indices 0 and 2, and also itself.\\n\\t\\n\\tMarked Indices = [0,1,2]\\n\\tsocre = 1\\n\\t\\n\\tNext, we see newList has next smallest index as 0. But, it is already marked.\\n\\tNext, we have the smallest index as \"5\". At \"5\", we have element 2\\n\\t\\n\\tSo, score += 2 => 3\\n\\tAnd we mark the elements on its left and right (if they are present)\\n\\tmarked indices = [0,1,2,4,5]\\n\\t\\n\\tNext, the smallest index is \"2\" but it is already marked\\n\\tNext, the smallest index is \"3\" so, again, we increment score by nums[3] => 4\\n\\t\\n\\tScore += 4 => 7\\n\\tAnd finally, we have marked all the indices = [0,1,2,3,4,5]\\n\\t\\n\\tAnd our loop ends\\n\\t\\nSo, the final score is 7.\\n\\nAnd that\\'s the whole idea of Sorting approach.\\n\\n```\\ndef findScore(self, nums: List[int]) -> int:\\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Score to return\\n        score = 0\\n        \\n        # Indices of Elements that have been marked\\n        markedIndices = set()\\n        \\n        # The reason why the Brute Force approach failed is -\\n        # In each iteration, we have to loop over the entire list to find the current smallest element\\n        # Instead, let\\'s use Sorting to make the solution better\\n        # Basically we want the indices of the smallest elements so that\\'s why we will keep the original indices with the elements\\n        # So, at each index in sortedIndices, we have a pair - (element, its original index)\\n        # Because when we mark the indices on left and right, we do that in the original list, not in the sorted list. Got it?\\n        sortedIndices = [(nums[i], i) for i in range(n)]\\n        sortedIndices.sort()\\n        \\n        # To keep track of the current smallest element\\n        # Since sortedIndices list is sorted in increasing order, initially, the smallest is at the index 0\\n        i = 0\\n        \\n        while len(markedIndices) != n:\\n            \\n            # Get the current smallest element\\n            # We use \"i\" to keep track of current smallest\\n            # So, if it is already marked in original list, we want the next smallest\\n            while sortedIndices[i][1] in markedIndices: i += 1\\n                \\n            # Increment the score\\n            score += sortedIndices[i][0]\\n\\n            # Mark the elements\\n            markedIndices.add(sortedIndices[i][1])\\n\\n            # Mark the index on left\\n            if sortedIndices[i][1] > 0: markedIndices.add(sortedIndices[i][1] - 1)  \\n\\n            # Mark the index on right\\n            if sortedIndices[i][1] < n - 1: markedIndices.add(sortedIndices[i][1] + 1)\\n                \\n            # Update i\\n            i += 1\\n                \\n                \\n        # Return the score\\n        return score\\n```\\n\\n# **3. MINHEAP SOLUTION - O(NLogN)**\\n\\nWe can also use a MinHeap to get the smallest element and its original index from the top of the minHeap at any time. The solution is almost similar to the Sorting solution, just that we don\\'t have to explicitly keep track of the smallest element\\'s index since we know smallest in a minHeap is always the top element.\\n\\n```\\ndef findScore(self, nums: List[int]) -> int:\\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Score to return\\n        score = 0\\n        \\n        # Indices of Elements that have been marked\\n        markedIndices = set()\\n        \\n        # We can also use a minHeap here and it will work the same as a sorted list did\\n        minHeap = []\\n        for i in range(n): heappush(minHeap, (nums[i], i))\\n            \\n        # The only change is we no longer have to use a pointer to keep track of smallest element\\n        # We know the smallest will always be on top of the minHeap\\n        while len(markedIndices) != n:\\n            \\n            # Get the current smallest element from top of the minHeap\\n            # If it is already marked in original list, we want the next smallest\\n            while minHeap[0][1] in markedIndices: heappop(minHeap)\\n                \\n            # Smallest\\n            smallestPair = heappop(minHeap)\\n                \\n            # Increment the score\\n            score += smallestPair[0]\\n\\n            # Mark the elements\\n            markedIndices.add(smallestPair[1])\\n\\n            # Mark the index on left\\n            if smallestPair[1] > 0: markedIndices.add(smallestPair[1] - 1)  \\n\\n            # Mark the index on right\\n            if smallestPair[1] < n - 1: markedIndices.add(smallestPair[1] + 1)\\n                \\n                \\n        # Return the score\\n        return score\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef findScore(self, nums: List[int]) -> int:\\n\\t# Length of the list\\n\\tn = len(nums)\\n\\n\\t# Score to return\\n\\tscore = 0\\n\\n\\t# Elements that have been marked\\n\\tmarkedElements = set()\\n\\n\\t# Index of smallest element\\n\\tsmallestIdx = -1\\n\\n\\twhile len(markedElements) != n:\\n\\n\\t\\t# Smallest element\\n\\t\\tsmallestElement = float(\"inf\")\\n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif i not in markedElements and nums[i] < smallestElement: \\n\\t\\t\\t\\tsmallestElement = nums[i]\\n\\t\\t\\t\\tsmallestIdx = i\\n\\n\\t\\t# Increment the score\\n\\t\\tscore += smallestElement\\n\\n\\t\\t# Mark the elements\\n\\t\\tmarkedElements.add(smallestIdx)\\n\\n\\t\\t# Mark the index on left\\n\\t\\tif smallestIdx > 0: markedElements.add(smallestIdx - 1)  \\n\\n\\t\\t# Mark the index on right\\n\\t\\tif smallestIdx < n - 1: markedElements.add(smallestIdx + 1)\\n\\n\\n\\t# Return the score\\n\\treturn score\\n```\n```\\ndef findScore(self, nums: List[int]) -> int:\\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Score to return\\n        score = 0\\n        \\n        # Indices of Elements that have been marked\\n        markedIndices = set()\\n        \\n        # The reason why the Brute Force approach failed is -\\n        # In each iteration, we have to loop over the entire list to find the current smallest element\\n        # Instead, let\\'s use Sorting to make the solution better\\n        # Basically we want the indices of the smallest elements so that\\'s why we will keep the original indices with the elements\\n        # So, at each index in sortedIndices, we have a pair - (element, its original index)\\n        # Because when we mark the indices on left and right, we do that in the original list, not in the sorted list. Got it?\\n        sortedIndices = [(nums[i], i) for i in range(n)]\\n        sortedIndices.sort()\\n        \\n        # To keep track of the current smallest element\\n        # Since sortedIndices list is sorted in increasing order, initially, the smallest is at the index 0\\n        i = 0\\n        \\n        while len(markedIndices) != n:\\n            \\n            # Get the current smallest element\\n            # We use \"i\" to keep track of current smallest\\n            # So, if it is already marked in original list, we want the next smallest\\n            while sortedIndices[i][1] in markedIndices: i += 1\\n                \\n            # Increment the score\\n            score += sortedIndices[i][0]\\n\\n            # Mark the elements\\n            markedIndices.add(sortedIndices[i][1])\\n\\n            # Mark the index on left\\n            if sortedIndices[i][1] > 0: markedIndices.add(sortedIndices[i][1] - 1)  \\n\\n            # Mark the index on right\\n            if sortedIndices[i][1] < n - 1: markedIndices.add(sortedIndices[i][1] + 1)\\n                \\n            # Update i\\n            i += 1\\n                \\n                \\n        # Return the score\\n        return score\\n```\n```\\ndef findScore(self, nums: List[int]) -> int:\\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Score to return\\n        score = 0\\n        \\n        # Indices of Elements that have been marked\\n        markedIndices = set()\\n        \\n        # We can also use a minHeap here and it will work the same as a sorted list did\\n        minHeap = []\\n        for i in range(n): heappush(minHeap, (nums[i], i))\\n            \\n        # The only change is we no longer have to use a pointer to keep track of smallest element\\n        # We know the smallest will always be on top of the minHeap\\n        while len(markedIndices) != n:\\n            \\n            # Get the current smallest element from top of the minHeap\\n            # If it is already marked in original list, we want the next smallest\\n            while minHeap[0][1] in markedIndices: heappop(minHeap)\\n                \\n            # Smallest\\n            smallestPair = heappop(minHeap)\\n                \\n            # Increment the score\\n            score += smallestPair[0]\\n\\n            # Mark the elements\\n            markedIndices.add(smallestPair[1])\\n\\n            # Mark the index on left\\n            if smallestPair[1] > 0: markedIndices.add(smallestPair[1] - 1)  \\n\\n            # Mark the index on right\\n            if smallestPair[1] < n - 1: markedIndices.add(smallestPair[1] + 1)\\n                \\n                \\n        # Return the score\\n        return score\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4007541,
                "title": "java-simple-solution-o-n-log-n-using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\n    class Pair {\\n        int num;\\n        int index;\\n        public Pair(int num, int index) {\\n            this.num = num;\\n            this.index = index;\\n        }\\n    }\\n    public long findScore(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>() {\\n            @Override\\n            public int compare(Pair a, Pair b) {\\n                if (a.num == b.num) {\\n                    return a.index - b.index;\\n                }\\n                return a.num - b.num;\\n            }\\n        });\\n        HashSet<Integer> marked = new HashSet();\\n        for (int i = 0; i < n; i++) {\\n            pq.add(new Pair(nums[i], i));\\n        }\\n        \\n        long score = 0;\\n        while (!pq.isEmpty()) {\\n            Pair currPair = pq.poll();\\n            int currNum = currPair.num;\\n            int currIndex = currPair.index;\\n            if (marked.contains(currIndex)) continue;\\n            score += currNum;\\n            marked.add(currIndex);\\n            marked.add(currIndex - 1);\\n            marked.add(currIndex + 1);\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int num;\\n        int index;\\n        public Pair(int num, int index) {\\n            this.num = num;\\n            this.index = index;\\n        }\\n    }\\n    public long findScore(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>() {\\n            @Override\\n            public int compare(Pair a, Pair b) {\\n                if (a.num == b.num) {\\n                    return a.index - b.index;\\n                }\\n                return a.num - b.num;\\n            }\\n        });\\n        HashSet<Integer> marked = new HashSet();\\n        for (int i = 0; i < n; i++) {\\n            pq.add(new Pair(nums[i], i));\\n        }\\n        \\n        long score = 0;\\n        while (!pq.isEmpty()) {\\n            Pair currPair = pq.poll();\\n            int currNum = currPair.num;\\n            int currIndex = currPair.index;\\n            if (marked.contains(currIndex)) continue;\\n            score += currNum;\\n            marked.add(currIndex);\\n            marked.add(currIndex - 1);\\n            marked.add(currIndex + 1);\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998271,
                "title": "c-beats-70-of-coders-simplest-easiest-optimal-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n\\n        long long ans = 0;\\n        multimap<int, int> mp;\\n        vector<int> vis(nums.size(), 0);\\n\\n        for(int i=0; i<nums.size(); i++)\\n            mp.insert({nums[i], i+1});\\n\\n        for(auto it : mp) {\\n            int index = it.second - 1;\\n            if(vis[index] == 0) {\\n                ans += it.first;\\n                vis[index] = 1;\\n                if(index-1 >= 0) vis[index-1] = 1;\\n                if(index < nums.size()-1) vis[index+1] = 1;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n\\n        long long ans = 0;\\n        multimap<int, int> mp;\\n        vector<int> vis(nums.size(), 0);\\n\\n        for(int i=0; i<nums.size(); i++)\\n            mp.insert({nums[i], i+1});\\n\\n        for(auto it : mp) {\\n            int index = it.second - 1;\\n            if(vis[index] == 0) {\\n                ans += it.first;\\n                vis[index] = 1;\\n                if(index-1 >= 0) vis[index-1] = 1;\\n                if(index < nums.size()-1) vis[index+1] = 1;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998254,
                "title": "c-simplest-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n\\n        long long ans = 0;\\n        multimap<int, int> mp;\\n        vector<int> vis(nums.size(), 0);\\n\\n        for(int i=0; i<nums.size(); i++)\\n            mp.insert({nums[i], i+1});\\n\\n        for(auto it : mp) {\\n            int index = it.second - 1;\\n            if(vis[index] == 0) {\\n                ans += it.first;\\n                vis[index] = 1;\\n                if(index-1 >= 0) vis[index-1] = 1;\\n                if(index < nums.size()-1) vis[index+1] = 1;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n\\n        long long ans = 0;\\n        multimap<int, int> mp;\\n        vector<int> vis(nums.size(), 0);\\n\\n        for(int i=0; i<nums.size(); i++)\\n            mp.insert({nums[i], i+1});\\n\\n        for(auto it : mp) {\\n            int index = it.second - 1;\\n            if(vis[index] == 0) {\\n                ans += it.first;\\n                vis[index] = 1;\\n                if(index-1 >= 0) vis[index-1] = 1;\\n                if(index < nums.size()-1) vis[index+1] = 1;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985124,
                "title": "simple-c-easy-min-heap-priority-queue-value-index",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i], i});\\n        }\\n        vector<int> vis(n, 0);\\n        long long ans = 0;\\n\\n        while(!pq.empty()){\\n            int node = pq.top().first;\\n            int index = pq.top().second;\\n            pq.pop();\\n            if(vis[index]==0){\\n                ans+=node;\\n                if(index-1>=0){\\n                    vis[index-1] = 1;\\n                }\\n                if(index+1<n){\\n                    vis[index+1] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i], i});\\n        }\\n        vector<int> vis(n, 0);\\n        long long ans = 0;\\n\\n        while(!pq.empty()){\\n            int node = pq.top().first;\\n            int index = pq.top().second;\\n            pq.pop();\\n            if(vis[index]==0){\\n                ans+=node;\\n                if(index-1>=0){\\n                    vis[index-1] = 1;\\n                }\\n                if(index+1<n){\\n                    vis[index+1] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975705,
                "title": "java-priorityqueue-lambda-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        int n = nums.length;\\n        boolean[] visited = new boolean[n];\\n        int count = 0;\\n        \\n        long score = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] == b[0] ? a[1]-b[1] : a[0]-b[0]));\\n        for(int i = 0; i < n; i++){\\n            pq.add(new int[]{nums[i], i});\\n        }\\n\\n        while(pq.size() > 0){\\n            int[] arr = pq.peek();\\n            int idx = arr[1];\\n            if(!visited[idx]){\\n                score += arr[0];\\n                visited[idx] = true;\\n                count++;\\n                if(idx+1 < n && !visited[idx+1]){\\n                    count++;\\n                    visited[idx+1] = true;\\n                }\\n                if(idx > 0 && !visited[idx-1]){\\n                    count++;\\n                    visited[idx-1] = true;\\n                }\\n                pq.poll();\\n            }else{\\n                pq.poll();\\n            }\\n            \\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        int n = nums.length;\\n        boolean[] visited = new boolean[n];\\n        int count = 0;\\n        \\n        long score = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] == b[0] ? a[1]-b[1] : a[0]-b[0]));\\n        for(int i = 0; i < n; i++){\\n            pq.add(new int[]{nums[i], i});\\n        }\\n\\n        while(pq.size() > 0){\\n            int[] arr = pq.peek();\\n            int idx = arr[1];\\n            if(!visited[idx]){\\n                score += arr[0];\\n                visited[idx] = true;\\n                count++;\\n                if(idx+1 < n && !visited[idx+1]){\\n                    count++;\\n                    visited[idx+1] = true;\\n                }\\n                if(idx > 0 && !visited[idx-1]){\\n                    count++;\\n                    visited[idx-1] = true;\\n                }\\n                pq.poll();\\n            }else{\\n                pq.poll();\\n            }\\n            \\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951456,
                "title": "simple-solution-using-min-heap-min-priority-queue",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        vector<int> marked(n, 0);\\n\\n        for(int i=0 ;i<nums.size() ;i++)\\n        pq.push({nums[i], i});\\n\\n        while(!pq.empty()){\\n            int val = pq.top().first;\\n            int index = pq.top().second;\\n            pq.pop();\\n            \\n            if(!marked[index]){\\n                marked[index] = 1;\\n                ans += val;\\n\\n                if(index<n-1)\\n                marked[index+1] = 1;\\n                if(index>0)\\n                marked[index-1] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        vector<int> marked(n, 0);\\n\\n        for(int i=0 ;i<nums.size() ;i++)\\n        pq.push({nums[i], i});\\n\\n        while(!pq.empty()){\\n            int val = pq.top().first;\\n            int index = pq.top().second;\\n            pq.pop();\\n            \\n            if(!marked[index]){\\n                marked[index] = 1;\\n                ans += val;\\n\\n                if(index<n-1)\\n                marked[index+1] = 1;\\n                if(index>0)\\n                marked[index-1] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936209,
                "title": "easy-java-solution-priority-queue-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static class Point{\\n        int idx;\\n        int val;\\n\\n        Point(int idx, int val){\\n            this.idx = idx;\\n            this.val = val;\\n        }\\n    }\\n\\n    public long findScore(int[] arr) {\\n\\n        PriorityQueue<Point> pq = new PriorityQueue<>((a,b)-> b.val==a.val ? a.idx-b.idx : a.val-b.val);\\n\\n        int n = arr.length;\\n\\n        boolean visited[] = new boolean[n];\\n\\n\\n\\n        for(int i=0; i<n; i++){\\n            pq.add(new Point(i,arr[i]));\\n        }\\n\\n        long ans = 0;\\n\\n        while(pq.size()!=0){\\n            Point p = pq.remove();\\n            int idx = p.idx;\\n\\n            if(!visited[idx]){\\n                ans+=p.val;\\n                visited[idx] = true;\\n\\n                if(idx-1>=0 && !visited[idx-1]) visited[idx-1] = true;\\n                if(idx+1<n && !visited[idx+1]) visited[idx+1] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static class Point{\\n        int idx;\\n        int val;\\n\\n        Point(int idx, int val){\\n            this.idx = idx;\\n            this.val = val;\\n        }\\n    }\\n\\n    public long findScore(int[] arr) {\\n\\n        PriorityQueue<Point> pq = new PriorityQueue<>((a,b)-> b.val==a.val ? a.idx-b.idx : a.val-b.val);\\n\\n        int n = arr.length;\\n\\n        boolean visited[] = new boolean[n];\\n\\n\\n\\n        for(int i=0; i<n; i++){\\n            pq.add(new Point(i,arr[i]));\\n        }\\n\\n        long ans = 0;\\n\\n        while(pq.size()!=0){\\n            Point p = pq.remove();\\n            int idx = p.idx;\\n\\n            if(!visited[idx]){\\n                ans+=p.val;\\n                visited[idx] = true;\\n\\n                if(idx-1>=0 && !visited[idx-1]) visited[idx-1] = true;\\n                if(idx+1<n && !visited[idx+1]) visited[idx+1] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931827,
                "title": "java-very-easy-using-custom-comparator-boolean-array",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return Integer.compare(a[1], b[1]);\\n            }\\n            return Integer.compare(a[0], b[0]);\\n        });\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            pq.add(new int[] { nums[i], i });\\n        }\\n        \\n        boolean[] marked = new boolean[nums.length];\\n        long score = 0;\\n\\n        while (!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            int value = curr[0];\\n            int idx = curr[1];\\n\\n            if (!marked[idx]) {\\n                score += value;\\n                marked[idx] = true;\\n\\n                if (idx > 0) {\\n                    marked[idx - 1] = true;\\n                }\\n                if (idx < nums.length - 1) {\\n                    marked[idx + 1] = true;\\n                }\\n            }\\n        }\\n        \\n        return score;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            if (a[0] == b[0]) {\\n                return Integer.compare(a[1], b[1]);\\n            }\\n            return Integer.compare(a[0], b[0]);\\n        });\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            pq.add(new int[] { nums[i], i });\\n        }\\n        \\n        boolean[] marked = new boolean[nums.length];\\n        long score = 0;\\n\\n        while (!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            int value = curr[0];\\n            int idx = curr[1];\\n\\n            if (!marked[idx]) {\\n                score += value;\\n                marked[idx] = true;\\n\\n                if (idx > 0) {\\n                    marked[idx - 1] = true;\\n                }\\n                if (idx < nums.length - 1) {\\n                    marked[idx + 1] = true;\\n                }\\n            }\\n        }\\n        \\n        return score;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929285,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDelete the smallest element and track index of deleted element along with the index of neighbour element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N log(N))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\\n        int n=nums.size();\\n        unordered_set<int> seen;\\n        for(int i=0;i<nums.size();i++){\\n            q.push(make_pair(nums[i],i));\\n            seen.insert(i);\\n        }\\n        long long int sum=0;\\n        while(seen.size()!=0){\\n             \\n             int index=q.top().second;\\n             q.pop();\\n             if(seen.find(index)==seen.end()){\\n                 continue;\\n             }\\n             if(index-1>=0 && seen.find(index-1)!=seen.end() ){\\n                seen.erase(index-1);\\n             }\\n             if(index+1<n && seen.find(index+1)!=seen.end()){\\n                 seen.erase(index+1);\\n             }\\n             seen.erase(index);\\n             sum+=nums[index];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\\n        int n=nums.size();\\n        unordered_set<int> seen;\\n        for(int i=0;i<nums.size();i++){\\n            q.push(make_pair(nums[i],i));\\n            seen.insert(i);\\n        }\\n        long long int sum=0;\\n        while(seen.size()!=0){\\n             \\n             int index=q.top().second;\\n             q.pop();\\n             if(seen.find(index)==seen.end()){\\n                 continue;\\n             }\\n             if(index-1>=0 && seen.find(index-1)!=seen.end() ){\\n                seen.erase(index-1);\\n             }\\n             if(index+1<n && seen.find(index+1)!=seen.end()){\\n                 seen.erase(index+1);\\n             }\\n             seen.erase(index);\\n             sum+=nums[index];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923406,
                "title": "golang-100-sort-solution",
                "content": "# Code\\n```go\\nfunc findScore(nums []int) int64 {\\n\\tmagic := make([][2]int, 0, len(nums))\\n\\tfor i, v := range nums {\\n\\t\\tmagic = append(magic, [2]int{i, v})\\n\\t}\\n\\tsort.Slice(magic, func(i, j int) bool {\\n\\t\\tif magic[i][1] == magic[j][1] {\\n\\t\\t\\treturn magic[i][0] < magic[j][0]\\n\\t\\t}\\n\\t\\treturn magic[i][1] < magic[j][1]\\n\\t})\\n\\tscore := 0\\n\\tfor _, m := range magic {\\n\\t\\tif nums[m[0]] == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tscore += m[1]\\n\\t\\tnums[m[0]] = 0\\n\\t\\tif m[0] - 1 >= 0 {\\n\\t\\t\\tnums[m[0] - 1] = 0\\n\\t\\t}\\n\\t\\tif m[0] + 1 < len(nums) {\\n\\t\\t\\tnums[m[0] + 1] = 0\\n\\t\\t}\\n\\t}\\n\\treturn int64(score)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```go\\nfunc findScore(nums []int) int64 {\\n\\tmagic := make([][2]int, 0, len(nums))\\n\\tfor i, v := range nums {\\n\\t\\tmagic = append(magic, [2]int{i, v})\\n\\t}\\n\\tsort.Slice(magic, func(i, j int) bool {\\n\\t\\tif magic[i][1] == magic[j][1] {\\n\\t\\t\\treturn magic[i][0] < magic[j][0]\\n\\t\\t}\\n\\t\\treturn magic[i][1] < magic[j][1]\\n\\t})\\n\\tscore := 0\\n\\tfor _, m := range magic {\\n\\t\\tif nums[m[0]] == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tscore += m[1]\\n\\t\\tnums[m[0]] = 0\\n\\t\\tif m[0] - 1 >= 0 {\\n\\t\\t\\tnums[m[0] - 1] = 0\\n\\t\\t}\\n\\t\\tif m[0] + 1 < len(nums) {\\n\\t\\t\\tnums[m[0] + 1] = 0\\n\\t\\t}\\n\\t}\\n\\treturn int64(score)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909619,
                "title": "c-min-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i], i});\\n        }\\n        vector<int> vis(n, 0);\\n        long long ans = 0;\\n\\n        while(!pq.empty()){\\n            int node = pq.top().first;\\n            int index = pq.top().second;\\n            pq.pop();\\n            if(vis[index]==0){\\n                ans+=node;\\n                if(index-1>=0){\\n                    vis[index-1] = 1;\\n                }\\n                if(index+1<n){\\n                    vis[index+1] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i], i});\\n        }\\n        vector<int> vis(n, 0);\\n        long long ans = 0;\\n\\n        while(!pq.empty()){\\n            int node = pq.top().first;\\n            int index = pq.top().second;\\n            pq.pop();\\n            if(vis[index]==0){\\n                ans+=node;\\n                if(index-1>=0){\\n                    vis[index-1] = 1;\\n                }\\n                if(index+1<n){\\n                    vis[index+1] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905524,
                "title": "python3-2-solutions",
                "content": "1. **Brute Force Method.** (*results in TLE*)\\n\\n\\tTime Complexity : O(n<sup>2</sup>)\\n\\tSpace Compelxity : O(1)\\n\\t```\\n\\tclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        count = len(nums)\\n        res = 0\\n        while count > 0:\\n            i = 0\\n            curr_min, curr_ind = float(\"inf\"), -1\\n            \\n\\t\\t\\t# find the current min out of the non-marked elements\\n            while i < len(nums):\\n                if nums[i] > 0 and nums[i] < curr_min:\\n                    curr_min = nums[i]\\n                    curr_ind = i\\n                i += 1\\n            \\n            # find the result\\n            res += curr_min\\n            \\n            # mark the current element\\n            nums[curr_ind] *= -1\\n            count -= 1\\n            \\n            # mark the right adjacent element, if present\\n            if nums[min(curr_ind + 1, len(nums) - 1)] > 0:\\n                nums[min(curr_ind + 1, len(nums) - 1)] *= -1\\n                count -= 1\\n            \\n            # mark the left adjacent element, if present\\n            if nums[max(0, curr_ind - 1)] > 0:\\n                nums[max(0, curr_ind - 1)] *= -1\\n                count -= 1\\n                \\n        return res\\n\\t```\\n\\t\\n\\t\\n2. **Slightly Better Brute Force Method.** (*accepted*)\\n\\n\\tTime Complexity : O(n log n)\\n\\tSpace Complexity : O(log n) {*space req for sorting*}\\n\\t```\\n\\tclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        res = 0\\n        for v, k in sorted((e, i) for i, e in enumerate(nums)):\\n            if nums[k] < 0:\\n                continue\\n            res += v\\n            nums[k] *= -1\\n            \\n            if nums[min(k + 1, len(nums) - 1)] > 0:\\n                nums[min(k + 1, len(nums) - 1)] *= -1\\n            \\n            if nums[max(0, k - 1)] > 0:\\n                nums[max(0, k - 1)] *= -1\\n        return res\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        count = len(nums)\\n        res = 0\\n        while count > 0:\\n            i = 0\\n            curr_min, curr_ind = float(\"inf\"), -1\\n            \\n\\t\\t\\t# find the current min out of the non-marked elements\\n            while i < len(nums):\\n                if nums[i] > 0 and nums[i] < curr_min:\\n                    curr_min = nums[i]\\n                    curr_ind = i\\n                i += 1\\n            \\n            # find the result\\n            res += curr_min\\n            \\n            # mark the current element\\n            nums[curr_ind] *= -1\\n            count -= 1\\n            \\n            # mark the right adjacent element, if present\\n            if nums[min(curr_ind + 1, len(nums) - 1)] > 0:\\n                nums[min(curr_ind + 1, len(nums) - 1)] *= -1\\n                count -= 1\\n            \\n            # mark the left adjacent element, if present\\n            if nums[max(0, curr_ind - 1)] > 0:\\n                nums[max(0, curr_ind - 1)] *= -1\\n                count -= 1\\n                \\n        return res\\n\\t```\n```\\n\\tclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        res = 0\\n        for v, k in sorted((e, i) for i, e in enumerate(nums)):\\n            if nums[k] < 0:\\n                continue\\n            res += v\\n            nums[k] *= -1\\n            \\n            if nums[min(k + 1, len(nums) - 1)] > 0:\\n                nums[min(k + 1, len(nums) - 1)] *= -1\\n            \\n            if nums[max(0, k - 1)] > 0:\\n                nums[max(0, k - 1)] *= -1\\n        return res\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3886267,
                "title": "c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> &a,pair<int,int> &b)\\n    {\\n        if(a.first!=b.first) return a.first<b.first;\\n        return a.second<b.second;\\n    }\\n    long long findScore(vector<int>& a) {\\n        vector<pair<int,int>> p;\\n        for(int i=0;i<a.size();i++) p.push_back({a[i],i});\\n        sort(p.begin(),p.end(),cmp);\\n        map<int,vector<int>> q;\\n        map<int,int> m;\\n\\n        long long int s=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            vector<int> v;\\n            if(i-1>=0) v.push_back(i-1); \\n            if(i+1<a.size()) v.push_back(i+1);\\n            q[i]=v;\\n        }\\n        for(int i=0;i<p.size();i++)\\n        {\\n            int id=p[i].second;\\n            if(m[id]>0) continue;\\n            s+=p[i].first;\\n            for(auto j : q[id])\\n            m[j]++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> &a,pair<int,int> &b)\\n    {\\n        if(a.first!=b.first) return a.first<b.first;\\n        return a.second<b.second;\\n    }\\n    long long findScore(vector<int>& a) {\\n        vector<pair<int,int>> p;\\n        for(int i=0;i<a.size();i++) p.push_back({a[i],i});\\n        sort(p.begin(),p.end(),cmp);\\n        map<int,vector<int>> q;\\n        map<int,int> m;\\n\\n        long long int s=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            vector<int> v;\\n            if(i-1>=0) v.push_back(i-1); \\n            if(i+1<a.size()) v.push_back(i+1);\\n            q[i]=v;\\n        }\\n        for(int i=0;i<p.size();i++)\\n        {\\n            int id=p[i].second;\\n            if(m[id]>0) continue;\\n            s+=p[i].first;\\n            for(auto j : q[id])\\n            m[j]++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868496,
                "title": "c-90-using-visiting-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n\\n        vector<int>vis(n,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n\\n        long long ans=0;\\n        while(!pq.empty())\\n        {\\n            int num=pq.top().first;\\n            int ind=pq.top().second;\\n\\n            pq.pop();\\n            \\n\\n            if(vis[ind]==1)\\n            {\\n                ans=ans+num;\\n                vis[ind]=0;\\n\\n                if(ind+1<n)\\n                vis[ind+1]=0;\\n\\n                if(ind-1>=0)\\n                vis[ind-1]=0;\\n            }\\n\\n            \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n\\n        vector<int>vis(n,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n\\n        long long ans=0;\\n        while(!pq.empty())\\n        {\\n            int num=pq.top().first;\\n            int ind=pq.top().second;\\n\\n            pq.pop();\\n            \\n\\n            if(vis[ind]==1)\\n            {\\n                ans=ans+num;\\n                vis[ind]=0;\\n\\n                if(ind+1<n)\\n                vis[ind+1]=0;\\n\\n                if(ind-1>=0)\\n                vis[ind-1]=0;\\n            }\\n\\n            \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857068,
                "title": "python-easy-understanding-no-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWork with only sort and indexes\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust sort array, and save to new array with [element, ind]\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(logN * N)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(N)$\\n# Code\\n```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        res = 0\\n        new = []\\n        for i in range(len(nums)):\\n            new.append([nums[i], i])\\n\\n        new = sorted(new, key=lambda x: (x[0], x[1]))\\n        used = [0] * len(nums)\\n        l = 0\\n        # print(new)\\n        while l < len(nums):\\n            ind = new[l][1]\\n            if used[ind]:\\n                l += 1\\n                continue\\n            res += new[l][0]\\n            used[ind] = 1\\n            if ind - 1 >= 0:\\n                used[ind - 1] = 1\\n            if ind + 1 < len(nums):\\n                used[ind + 1] = 1\\n            l += 1\\n        # print(res)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        res = 0\\n        new = []\\n        for i in range(len(nums)):\\n            new.append([nums[i], i])\\n\\n        new = sorted(new, key=lambda x: (x[0], x[1]))\\n        used = [0] * len(nums)\\n        l = 0\\n        # print(new)\\n        while l < len(nums):\\n            ind = new[l][1]\\n            if used[ind]:\\n                l += 1\\n                continue\\n            res += new[l][0]\\n            used[ind] = 1\\n            if ind - 1 >= 0:\\n                used[ind - 1] = 1\\n            if ind + 1 < len(nums):\\n                used[ind + 1] = 1\\n            l += 1\\n        # print(res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830944,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        \\n        sorted_nums = sorted(nums.copy())\\n        \\n        lookup = defaultdict(deque)\\n        \\n        for index, num in enumerate(nums):\\n            lookup[num].append(index)\\n            \\n        score = 0\\n        \\n        marked_indices = defaultdict(int)\\n        \\n        \\n        for num in sorted_nums:\\n            q = lookup[num]\\n            \\n            if not q:\\n                continue\\n                \\n            index = q.popleft()\\n            \\n            if index in marked_indices:\\n                continue\\n                \\n            score += num\\n            \\n            marked_indices[index - 1] += 1\\n            marked_indices[index + 1] += 1\\n            \\n\\n            \\n        \\n        \\n        return score\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        \\n        sorted_nums = sorted(nums.copy())\\n        \\n        lookup = defaultdict(deque)\\n        \\n        for index, num in enumerate(nums):\\n            lookup[num].append(index)\\n            \\n        score = 0\\n        \\n        marked_indices = defaultdict(int)\\n        \\n        \\n        for num in sorted_nums:\\n            q = lookup[num]\\n            \\n            if not q:\\n                continue\\n                \\n            index = q.popleft()\\n            \\n            if index in marked_indices:\\n                continue\\n                \\n            score += num\\n            \\n            marked_indices[index - 1] += 1\\n            marked_indices[index + 1] += 1\\n            \\n\\n            \\n        \\n        \\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799284,
                "title": "priority-queue-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long score=0;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>p;\\n        vector<int>check(n,0);\\n\\n        for(int i=0;i<nums.size();i++) p.push({nums[i],i});\\n\\n        while(!p.empty()){\\n            int k=p.top().first;\\n            int ind=p.top().second;\\n            if(!check[ind]){\\n                score+=k;\\n                check[ind]=1;\\n                if(ind-1>=0) check[ind-1]=1;\\n                if(ind+1<n)  check[ind+1]=1;\\n                }\\n            p.pop();\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long score=0;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>p;\\n        vector<int>check(n,0);\\n\\n        for(int i=0;i<nums.size();i++) p.push({nums[i],i});\\n\\n        while(!p.empty()){\\n            int k=p.top().first;\\n            int ind=p.top().second;\\n            if(!check[ind]){\\n                score+=k;\\n                check[ind]=1;\\n                if(ind-1>=0) check[ind-1]=1;\\n                if(ind+1<n)  check[ind+1]=1;\\n                }\\n            p.pop();\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773477,
                "title": "simple-and-easy-to-understand-simple-heap",
                "content": "```\\nclass Solution {\\n    public class Pair implements Comparable<Pair>{\\n        int value;\\n        int index;\\n        // It store the value and index \\n        public Pair(int val,int idx){\\n            this.value = val;\\n            this.index = idx;\\n        }\\n        \\n      public int compareTo(Pair obj){\\n        return (obj.value == this.value?(this.index-obj.index):(this.value - obj.value));\\n      }\\n    }\\n    public long findScore(int[] nums) {\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            pq.add(new Pair(nums[i],i));\\n        }\\n        \\n        boolean visited[] = new boolean[nums.length];\\n        \\n        long score = 0;\\n        \\n        while(!pq.isEmpty()){\\n            \\n            Pair rem = pq.remove();\\n            \\n            if(!visited[rem.index]){\\n                \\n                score += rem.value;\\n                visited[rem.index] = true;\\n                \\n                if(rem.index-1>=0 && visited[rem.index-1] == false){\\n                    visited[rem.index-1] = true;\\n                }\\n                \\n                if(rem.index+1<nums.length && visited[rem.index+1] == false){\\n                    visited[rem.index+1] = true;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return score;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair implements Comparable<Pair>{\\n        int value;\\n        int index;\\n        // It store the value and index \\n        public Pair(int val,int idx){\\n            this.value = val;\\n            this.index = idx;\\n        }\\n        \\n      public int compareTo(Pair obj){\\n        return (obj.value == this.value?(this.index-obj.index):(this.value - obj.value));\\n      }\\n    }\\n    public long findScore(int[] nums) {\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            pq.add(new Pair(nums[i],i));\\n        }\\n        \\n        boolean visited[] = new boolean[nums.length];\\n        \\n        long score = 0;\\n        \\n        while(!pq.isEmpty()){\\n            \\n            Pair rem = pq.remove();\\n            \\n            if(!visited[rem.index]){\\n                \\n                score += rem.value;\\n                visited[rem.index] = true;\\n                \\n                if(rem.index-1>=0 && visited[rem.index-1] == false){\\n                    visited[rem.index-1] = true;\\n                }\\n                \\n                if(rem.index+1<nums.length && visited[rem.index+1] == false){\\n                    visited[rem.index+1] = true;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return score;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769583,
                "title": "best-solution-with-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();\\n        long long sum=0;\\n        map<int,int>mp;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        while(pq.size()!=0)\\n        {\\n            int p=pq.top().second;\\n            if(mp.find(p)!=mp.end())\\n            {\\n               pq.pop();\\n            }\\n            else\\n            {\\n                sum=sum+pq.top().first;\\n                 if(p==0)\\n                {\\n                  mp[p]++;\\n                  mp[p+1]++;\\n                }\\n                else if(p==n-1)\\n                {\\n                   mp[p]++;\\n                  mp[p-1]++;\\n                }\\n                else\\n                {\\n                  mp[p]++;\\n                  mp[p+1]++;\\n                  mp[p-1]++;\\n                }\\n            }\\n        } \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();\\n        long long sum=0;\\n        map<int,int>mp;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        while(pq.size()!=0)\\n        {\\n            int p=pq.top().second;\\n            if(mp.find(p)!=mp.end())\\n            {\\n               pq.pop();\\n            }\\n            else\\n            {\\n                sum=sum+pq.top().first;\\n                 if(p==0)\\n                {\\n                  mp[p]++;\\n                  mp[p+1]++;\\n                }\\n                else if(p==n-1)\\n                {\\n                   mp[p]++;\\n                  mp[p-1]++;\\n                }\\n                else\\n                {\\n                  mp[p]++;\\n                  mp[p+1]++;\\n                  mp[p-1]++;\\n                }\\n            }\\n        } \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750210,
                "title": "easy-c-solution-min-heap-beats-70-time-75-space",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();;\\n        if(n==1)return nums[0];\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i = 0; i < n; i++){\\n            pq.push({nums[i],i});\\n        }\\n        vector<int> v(n,1);\\n        long long int s = 0;\\n        int t;\\n        while(!pq.empty()){\\n            t = pq.top().second;\\n            pq.pop();\\n            if(v[t]==1){\\n                s+=nums[t];\\n                v[t]=0;\\n                if(t>0)\\n                    v[t-1]=0;\\n                if(t<n-1)\\n                    v[t+1]=0;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();;\\n        if(n==1)return nums[0];\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i = 0; i < n; i++){\\n            pq.push({nums[i],i});\\n        }\\n        vector<int> v(n,1);\\n        long long int s = 0;\\n        int t;\\n        while(!pq.empty()){\\n            t = pq.top().second;\\n            pq.pop();\\n            if(v[t]==1){\\n                s+=nums[t];\\n                v[t]=0;\\n                if(t>0)\\n                    v[t-1]=0;\\n                if(t<n-1)\\n                    v[t+1]=0;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749794,
                "title": "c-simple-intutive-hash-table",
                "content": "# Intuition\\n\\n\\n# Approach\\n1. Create a map to store the indexes of elements of array and a vector whose all indexes are intitally marked  0 \\n2. As we have created a map so elements will be stored in sorted order\\n3. Iterate elements of map and we can mark all the adjacent indexes 1 and if a index if already marked as 1 we will not do any calculation for that index \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        map<int, vector<long >>mp;\\n        for( int i  =0 ; i<n ; i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<int>v(n , 0);\\n        long long score=0 ;\\n        for(auto it:mp)\\n        {\\n            for(auto it2:it.second)\\n            {\\n                if(v[it2]==0)\\n                {\\n                    score+=it.first;\\n                    if(it2-1 >=0) v[it2-1]=1;\\n                    if(it2+1<n)v[it2+1]=1;\\n                }\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        map<int, vector<long >>mp;\\n        for( int i  =0 ; i<n ; i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<int>v(n , 0);\\n        long long score=0 ;\\n        for(auto it:mp)\\n        {\\n            for(auto it2:it.second)\\n            {\\n                if(v[it2]==0)\\n                {\\n                    score+=it.first;\\n                    if(it2-1 >=0) v[it2-1]=1;\\n                    if(it2+1<n)v[it2+1]=1;\\n                }\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738356,
                "title": "90-beating-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long score = 0;\\n        boolean [] visited=new boolean[nums.length];\\n        int [][] arr = new int[nums.length][2];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=i;\\n\\n        }\\n        Arrays.sort(arr,(a,b)->a[0]-b[0]);\\n        for(int i =0;i<nums.length;i++){\\n            if(!visited[arr[i][1]]){\\n                visited[arr[i][1]]=true;\\n                score+=arr[i][0];\\n                if(arr[i][1]-1>=0){\\n                    visited[arr[i][1]-1]=true;\\n                }\\n                if(arr[i][1]+1<nums.length){\\n                    visited[arr[i][1]+1]=true;\\n                }\\n\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long score = 0;\\n        boolean [] visited=new boolean[nums.length];\\n        int [][] arr = new int[nums.length][2];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=i;\\n\\n        }\\n        Arrays.sort(arr,(a,b)->a[0]-b[0]);\\n        for(int i =0;i<nums.length;i++){\\n            if(!visited[arr[i][1]]){\\n                visited[arr[i][1]]=true;\\n                score+=arr[i][0];\\n                if(arr[i][1]-1>=0){\\n                    visited[arr[i][1]-1]=true;\\n                }\\n                if(arr[i][1]+1<nums.length){\\n                    visited[arr[i][1]+1]=true;\\n                }\\n\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728528,
                "title": "o-nlogn-min-heap-solution-easy-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        vector<bool> mark(nums.size(),false);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n\\n        while(!pq.empty())\\n        {\\n            auto it=pq.top();\\n            int val=it.first;\\n            int ind=it.second;\\n            pq.pop();\\n            if(mark[ind])   continue;\\n            else\\n            {\\n                ans+=val;\\n                mark[ind]=true;\\n                if(ind-1>=0)    mark[ind-1]=true;\\n                if(ind+1<nums.size())   mark[ind+1]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        vector<bool> mark(nums.size(),false);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n\\n        while(!pq.empty())\\n        {\\n            auto it=pq.top();\\n            int val=it.first;\\n            int ind=it.second;\\n            pq.pop();\\n            if(mark[ind])   continue;\\n            else\\n            {\\n                ans+=val;\\n                mark[ind]=true;\\n                if(ind-1>=0)    mark[ind-1]=true;\\n                if(ind+1<nums.size())   mark[ind+1]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714127,
                "title": "95-faster-simple-sorting-and-pair-of-vectors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<bool>vis(n,false);\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums[i],i});\\n        }\\n        long long ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int ind=v[i].second;\\n            if(vis[ind]==false)\\n            {\\n                vis[ind]=true;\\n                ans+=v[i].first;\\n                if(ind-1>=0 && ind+1<n)\\n                {\\n                    vis[ind-1]=true;\\n                    vis[ind+1]=true;\\n                }\\n                else if(ind==0)\\n\\n                {\\n                     vis[ind+1]=true;\\n                }\\n                else if(ind==n-1)\\n                     vis[ind-1]=true;\\n\\n            }\\n            else\\n            continue;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<bool>vis(n,false);\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums[i],i});\\n        }\\n        long long ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int ind=v[i].second;\\n            if(vis[ind]==false)\\n            {\\n                vis[ind]=true;\\n                ans+=v[i].first;\\n                if(ind-1>=0 && ind+1<n)\\n                {\\n                    vis[ind-1]=true;\\n                    vis[ind+1]=true;\\n                }\\n                else if(ind==0)\\n\\n                {\\n                     vis[ind+1]=true;\\n                }\\n                else if(ind==n-1)\\n                     vis[ind-1]=true;\\n\\n            }\\n            else\\n            continue;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702205,
                "title": "java-priority-queue-easy-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n\\n- Space complexity:\\n  O(n) - visited + O(n) - PriorityQueue ~ O(2*n)\\n\\n// Tried using masking to mark the index visited to reduce the space complexity but cleared only 1014/1044. help anyone?\\n\\ncode in comment.\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long score=0;\\n\\n        boolean [] vis=new boolean[nums.length];\\n\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->{\\n            if(a[0]==b[0])\\n            return a[1]-b[1]; // sorting based on index\\n\\n            return a[0]-b[0]; // sorting based on value\\n        });\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            pq.add(new int[]{nums[i],i});// num-index\\n        }\\n \\n        //int mask=0;\\n        while(pq.size()>0)\\n        {\\n            int[] t=pq.remove();\\n            \\n            //if not marked - then proceed\\n            if(!vis[t[1]])//(((mask>>t[1])&1)==0)\\n            {                \\n                score+=t[0];\\n                vis[t[1]]=true;\\n                //mask|=1<<t[1];\\n                \\n                //marking the left index\\n                if((t[1]-1)>=0)\\n                vis[t[1]-1]=true;\\n                //mask|=1<<(t[1]-1);\\n                \\n                //marking the right index\\n                if((t[1]+1)<nums.length)\\n                vis[t[1]+1]=true;\\n                //mask|=1<<(t[1]+1);\\n            }\\n        }\\n\\n        return score;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long score=0;\\n\\n        boolean [] vis=new boolean[nums.length];\\n\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->{\\n            if(a[0]==b[0])\\n            return a[1]-b[1]; // sorting based on index\\n\\n            return a[0]-b[0]; // sorting based on value\\n        });\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            pq.add(new int[]{nums[i],i});// num-index\\n        }\\n \\n        //int mask=0;\\n        while(pq.size()>0)\\n        {\\n            int[] t=pq.remove();\\n            \\n            //if not marked - then proceed\\n            if(!vis[t[1]])//(((mask>>t[1])&1)==0)\\n            {                \\n                score+=t[0];\\n                vis[t[1]]=true;\\n                //mask|=1<<t[1];\\n                \\n                //marking the left index\\n                if((t[1]-1)>=0)\\n                vis[t[1]-1]=true;\\n                //mask|=1<<(t[1]-1);\\n                \\n                //marking the right index\\n                if((t[1]+1)<nums.length)\\n                vis[t[1]+1]=true;\\n                //mask|=1<<(t[1]+1);\\n            }\\n        }\\n\\n        return score;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701562,
                "title": "easy-solution-using-min-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> p;\\n    long long findScore(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n       priority_queue<p,vector<p>,greater<p>> pq;\\n       long long sum=0;\\n       for(int i=0;i<nums.size();i++){\\n           pq.push({nums[i],i});\\n       }\\n       while(!pq.empty()){\\n           p p1=pq.top();\\n           if(nums[p1.second]!=0){\\n              cout<<p1.first<<endl;\\n               sum=sum+p1.first;\\n               if(p1.second==0) nums[1]=0;\\n               else if(p1.second==nums.size()-1) nums[nums.size()-2]=0;\\n               else{\\n                   nums[p1.second+1]=0;\\n                   nums[p1.second-1]=0;\\n               }\\n           }\\n           pq.pop();\\n       }\\n       return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> p;\\n    long long findScore(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n       priority_queue<p,vector<p>,greater<p>> pq;\\n       long long sum=0;\\n       for(int i=0;i<nums.size();i++){\\n           pq.push({nums[i],i});\\n       }\\n       while(!pq.empty()){\\n           p p1=pq.top();\\n           if(nums[p1.second]!=0){\\n              cout<<p1.first<<endl;\\n               sum=sum+p1.first;\\n               if(p1.second==0) nums[1]=0;\\n               else if(p1.second==nums.size()-1) nums[nums.size()-2]=0;\\n               else{\\n                   nums[p1.second+1]=0;\\n                   nums[p1.second-1]=0;\\n               }\\n           }\\n           pq.pop();\\n       }\\n       return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3699414,
                "title": "python3-easy-solution-heap",
                "content": "# Code\\n```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        marked = [False] * len(nums)\\n        q = []\\n        for i, n in enumerate(nums):\\n            heapq.heappush(q, (n, i))\\n        \\n        score = 0\\n        while q:\\n            n, i = heapq.heappop(q)\\n\\n            if marked[i] == False:\\n                score += n\\n                marked[i] = True\\n                if i - 1 >= 0:\\n                    marked[i - 1] = True\\n                if i + 1 < len(nums):\\n                    marked[i + 1] = True\\n        return score\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        marked = [False] * len(nums)\\n        q = []\\n        for i, n in enumerate(nums):\\n            heapq.heappush(q, (n, i))\\n        \\n        score = 0\\n        while q:\\n            n, i = heapq.heappop(q)\\n\\n            if marked[i] == False:\\n                score += n\\n                marked[i] = True\\n                if i - 1 >= 0:\\n                    marked[i - 1] = True\\n                if i + 1 < len(nums):\\n                    marked[i + 1] = True\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682057,
                "title": "approach-using-heap-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n       long long ans=0;\\n       priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n         pq.push(make_pair(nums[i],i));\\n       }\\n       map<int,bool>mp;\\n       int cnt=0;\\n       int n=nums.size();\\n       while(!pq.empty())\\n       {\\n         auto it=pq.top();\\n         pq.pop();\\n         int indx=it.second;\\n         int val=it.first;\\n         if(!mp[indx])\\n         {\\n           ans+=val;\\n           mp[indx]=1;\\n           cnt++;\\n           if((indx+1)<n)\\n           {\\n           cnt++;\\n           mp[indx+1]=1;\\n           }\\n           if((indx-1)>-1)\\n           {\\n           cnt++;\\n           mp[indx-1]=1;\\n           }\\n         }\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n       long long ans=0;\\n       priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n         pq.push(make_pair(nums[i],i));\\n       }\\n       map<int,bool>mp;\\n       int cnt=0;\\n       int n=nums.size();\\n       while(!pq.empty())\\n       {\\n         auto it=pq.top();\\n         pq.pop();\\n         int indx=it.second;\\n         int val=it.first;\\n         if(!mp[indx])\\n         {\\n           ans+=val;\\n           mp[indx]=1;\\n           cnt++;\\n           if((indx+1)<n)\\n           {\\n           cnt++;\\n           mp[indx+1]=1;\\n           }\\n           if((indx-1)>-1)\\n           {\\n           cnt++;\\n           mp[indx-1]=1;\\n           }\\n         }\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677084,
                "title": "set-and-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        array=[]\\n        n=len(nums)\\n        markel=set()\\n        for i in range(0,len(nums)):\\n            l=[nums[i],i,0]\\n            heapq.heappush(array,l)\\n        score=0\\n        while array:\\n            popped=heapq.heappop(array)\\n            if popped[1] not in markel:\\n                score+=popped[0]\\n                indexofpopped=popped[1]\\n                if indexofpopped-1>=0:\\n                    markel.add(indexofpopped-1)\\n                if indexofpopped+1<n:\\n                    markel.add(indexofpopped+1)\\n                markel.add(indexofpopped)  \\n        return score          \\n\\n                    \\n\\n                \\n                \\n                          \\n        return score        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        array=[]\\n        n=len(nums)\\n        markel=set()\\n        for i in range(0,len(nums)):\\n            l=[nums[i],i,0]\\n            heapq.heappush(array,l)\\n        score=0\\n        while array:\\n            popped=heapq.heappop(array)\\n            if popped[1] not in markel:\\n                score+=popped[0]\\n                indexofpopped=popped[1]\\n                if indexofpopped-1>=0:\\n                    markel.add(indexofpopped-1)\\n                if indexofpopped+1<n:\\n                    markel.add(indexofpopped+1)\\n                markel.add(indexofpopped)  \\n        return score          \\n\\n                    \\n\\n                \\n                \\n                          \\n        return score        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669135,
                "title": "simple-java-sorting-solution-no-heaps-tree-sets-and-so-on-beats-96-time-wise",
                "content": "Simply build another array with the values + indexes of the original array and keep track of the marked numbers in a yet separate boolean array:\\n\\nTime: O(nlogn)\\nSpace: O(n)\\n\\n```\\nclass Solution\\n{\\n    public long findScore(int[] nums)\\n    {\\n        boolean [] marked = new boolean[nums.length];\\n        int [][] sorted = new int [nums.length][2];\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            sorted[i] = new int [] {nums[i], i};\\n        }\\n        Arrays.sort(sorted, (a, b) -> (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n        long output = 0;\\n        for (int [] s : sorted)\\n        {\\n            if (marked[s[1]])\\n            {\\n                continue;\\n            }\\n            output += s[0];\\n            marked[s[1]] = true;\\n            if (s[1] > 0)\\n            {\\n                marked[s[1] - 1] = true;\\n            }\\n            if (s[1] < marked.length - 1)\\n            {\\n                marked[s[1] + 1] = true;\\n            }\\n        }\\n        return output;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution\\n{\\n    public long findScore(int[] nums)\\n    {\\n        boolean [] marked = new boolean[nums.length];\\n        int [][] sorted = new int [nums.length][2];\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            sorted[i] = new int [] {nums[i], i}",
                "codeTag": "Java"
            },
            {
                "id": 3660112,
                "title": "simple-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findScore = function(nums) {\\n    let marked = new Set()\\n    let res = 0\\n    for(let i = 0; i < nums.length; i++){\\n        nums[i] = [nums[i], i]\\n    }\\n    nums.sort((a,b) => a[0] - b[0])\\n    for (let i = 0; i < nums.length; i++){\\n        if (!marked.has(nums[i][1])){\\n            const pos = nums[i][1]\\n            marked.add(pos)\\n            marked.add(pos - 1)\\n            marked.add(pos + 1)\\n            res += nums[i][0]\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findScore = function(nums) {\\n    let marked = new Set()\\n    let res = 0\\n    for(let i = 0; i < nums.length; i++){\\n        nums[i] = [nums[i], i]\\n    }\\n    nums.sort((a,b) => a[0] - b[0])\\n    for (let i = 0; i < nums.length; i++){\\n        if (!marked.has(nums[i][1])){\\n            const pos = nums[i][1]\\n            marked.add(pos)\\n            marked.add(pos - 1)\\n            marked.add(pos + 1)\\n            res += nums[i][0]\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3644091,
                "title": "easy-priority-queue-implementation-detailed-explanation",
                "content": "\\n# Learn how to use pair of classes in Priority Queue efficiently\\uD83E\\uDDE0\\uD83D\\uDCAB\\n\\n# Intuition\\nWhenever i saw question is about ***maximum and minimum***, my first thought is **************PRIORITY QUEUE(HEAP)**************\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\uD83E\\uDD2F\\n\\n> We can also think about **sorting**,but we loss the index values\\uD83E\\uDD72\\n\\n# Approach\\nUsing a **PAIR CLASS** we an make PriorityQueue Also look the condition when values are equal then value with low index value is given more Pririty.\\n\\n```\\n//Lets talk about this for better understanding \\uD83D\\uDE42\\n\\nif(this.val!=other.val){\\n            return Integer.compare(this.val,other.val);\\n        }\\n        else{\\n            return Integer.compare(this.indx,other.indx);\\n\\n        }\\n```\\nIt first checks if the val attributes of the current object (this.val) and the other object (other.val) are not equal. If they are not equal, it compares the val attributes directly using `Integer.compare(this.val, other.val)`. This ensures the element with the smaller val value is ordered first in the priority queue.\\n\\nIf the val attributes are equal, it compares the indx attributes using `Integer.compare(this.indx, other.indx)`. By swapping the parameters in Integer.compare, it ensures the element with the smaller indx value is ordered first in the priority queue.\\n\\n**To look for visited item we can use boolean array here and mark true for every visit and also for its adjacent.**\\n\\n**finally add the value to result.**\\n\\n# Complexity\\n- Time complexity:\\n**O(nlogn)**\\n\\n- Space complexity:\\n**O(n)**\\n\\n# Code\\n```\\nclass Solution {\\n    class mypair implements Comparable<mypair>{\\n        int val;\\n        int indx;\\n       mypair(int a,int b){\\n           val=a;\\n           indx=b;\\n       } \\n    public int compareTo(mypair other){\\n        if(this.val!=other.val){\\n            return Integer.compare(this.val,other.val);\\n        }\\n        else{\\n            return Integer.compare(this.indx,other.indx);\\n\\n        }\\n    }\\n    }\\n    public long findScore(int[] nums) {\\n        PriorityQueue<mypair>pq=new PriorityQueue<>();\\n        boolean boolarray[]=new boolean[nums.length];\\n        int n=nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            pq.add(new mypair(nums[i],i));\\n        } \\n    long res=0;\\n        while(pq.size()!=0){\\n            \\n           if(boolarray[pq.peek().indx]==true){\\n//If current element in the bool array is visited then it must be removed from queue\\n               \\n               pq.poll();\\n           }\\n           else{\\n//else check for its adjacent and mark visited\\n               if(pq.peek().indx-1>=0)boolarray[pq.peek().indx-1]=true;\\n               if(pq.peek().indx+1<n)boolarray[pq.peek().indx+1]=true;\\n               boolarray[pq.peek().indx]=true;\\n//add the current value and removed it\\n               res+=pq.poll().val;\\n               \\n           }\\n        }\\n        \\n        return res;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//Lets talk about this for better understanding \\uD83D\\uDE42\\n\\nif(this.val!=other.val){\\n            return Integer.compare(this.val,other.val);\\n        }\\n        else{\\n            return Integer.compare(this.indx,other.indx);\\n\\n        }\\n```\n```\\nclass Solution {\\n    class mypair implements Comparable<mypair>{\\n        int val;\\n        int indx;\\n       mypair(int a,int b){\\n           val=a;\\n           indx=b;\\n       } \\n    public int compareTo(mypair other){\\n        if(this.val!=other.val){\\n            return Integer.compare(this.val,other.val);\\n        }\\n        else{\\n            return Integer.compare(this.indx,other.indx);\\n\\n        }\\n    }\\n    }\\n    public long findScore(int[] nums) {\\n        PriorityQueue<mypair>pq=new PriorityQueue<>();\\n        boolean boolarray[]=new boolean[nums.length];\\n        int n=nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            pq.add(new mypair(nums[i],i));\\n        } \\n    long res=0;\\n        while(pq.size()!=0){\\n            \\n           if(boolarray[pq.peek().indx]==true){\\n//If current element in the bool array is visited then it must be removed from queue\\n               \\n               pq.poll();\\n           }\\n           else{\\n//else check for its adjacent and mark visited\\n               if(pq.peek().indx-1>=0)boolarray[pq.peek().indx-1]=true;\\n               if(pq.peek().indx+1<n)boolarray[pq.peek().indx+1]=true;\\n               boolarray[pq.peek().indx]=true;\\n//add the current value and removed it\\n               res+=pq.poll().val;\\n               \\n           }\\n        }\\n        \\n        return res;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629498,
                "title": "python3-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n\\n        ans=0\\n        \\n        arr=[]\\n        for i,val in enumerate(nums):\\n            arr.append([val,i])\\n\\n        arr.sort()\\n        n=i+1\\n\\n\\n        for i in range(n):\\n            if nums[arr[i][1]]:\\n                if arr[i][1]>0:   nums[arr[i][1]-1]=0\\n                if arr[i][1]+1<n: nums[arr[i][1]+1]=0\\n                ans+=arr[i][0]\\n                nums[arr[i][1]]=0\\n           \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n\\n        ans=0\\n        \\n        arr=[]\\n        for i,val in enumerate(nums):\\n            arr.append([val,i])\\n\\n        arr.sort()\\n        n=i+1\\n\\n\\n        for i in range(n):\\n            if nums[arr[i][1]]:\\n                if arr[i][1]>0:   nums[arr[i][1]-1]=0\\n                if arr[i][1]+1<n: nums[arr[i][1]+1]=0\\n                ans+=arr[i][0]\\n                nums[arr[i][1]]=0\\n           \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626804,
                "title": "time-complexity-n-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        if(nums.size() == 1)\\n        {\\n            return nums[0];\\n        }\\n  \\n      priority_queue<pair<int , int> , vector<pair<int,int>> , greater<pair<int,int>> >pq;\\n      for(int i = 0; i<nums.size(); i++)\\n      {\\n          pq.push({nums[i],  i});\\n      }\\n      long long int count =0 ;\\n      \\n        while(!pq.empty()){\\n\\n           int idx = pq.top().second;\\n             \\n              if(nums[idx] != -1){\\n                   if(idx!=0 && idx!=nums.size()-1)\\n                   {\\n                       nums[idx] = -1;\\n                       nums[idx-1] = -1;\\n                       nums[idx+1] = -1;\\n                       count = count + pq.top().first;\\n\\n                   }else if( idx == 0 )\\n                   {\\n                       nums[idx+1] =-1;\\n                       nums[idx] = -1;\\n                       count = count + pq.top().first;\\n                   }else if(idx == nums.size()-1)\\n                   {\\n                       nums[idx-1] = -1;\\n                       nums[idx] = -1;\\n                       count = count + pq.top().first;\\n                   }\\n        }\\n               pq.pop();\\n        } \\n             \\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        if(nums.size() == 1)\\n        {\\n            return nums[0];\\n        }\\n  \\n      priority_queue<pair<int , int> , vector<pair<int,int>> , greater<pair<int,int>> >pq;\\n      for(int i = 0; i<nums.size(); i++)\\n      {\\n          pq.push({nums[i],  i});\\n      }\\n      long long int count =0 ;\\n      \\n        while(!pq.empty()){\\n\\n           int idx = pq.top().second;\\n             \\n              if(nums[idx] != -1){\\n                   if(idx!=0 && idx!=nums.size()-1)\\n                   {\\n                       nums[idx] = -1;\\n                       nums[idx-1] = -1;\\n                       nums[idx+1] = -1;\\n                       count = count + pq.top().first;\\n\\n                   }else if( idx == 0 )\\n                   {\\n                       nums[idx+1] =-1;\\n                       nums[idx] = -1;\\n                       count = count + pq.top().first;\\n                   }else if(idx == nums.size()-1)\\n                   {\\n                       nums[idx-1] = -1;\\n                       nums[idx] = -1;\\n                       count = count + pq.top().first;\\n                   }\\n        }\\n               pq.pop();\\n        } \\n             \\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599069,
                "title": "using-priority-queue-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int n = nums.size();\\n        vector<int>mark(n,0);\\n        long long score = 0;\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i],i});\\n        }\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            int val = it.first;\\n            int ind = it.second;\\n            pq.pop();\\n            if(!mark[ind]){\\n                mark[ind]=1;\\n                score+=val;\\n                if(ind-1>=0&&mark[ind-1]==0){\\n                    mark[ind-1]=1;\\n                }\\n                if(ind+1<n&&mark[ind+1]==0){\\n                    mark[ind+1]=1;\\n                }\\n            }\\n        }\\n      return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int n = nums.size();\\n        vector<int>mark(n,0);\\n        long long score = 0;\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i],i});\\n        }\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            int val = it.first;\\n            int ind = it.second;\\n            pq.pop();\\n            if(!mark[ind]){\\n                mark[ind]=1;\\n                score+=val;\\n                if(ind-1>=0&&mark[ind-1]==0){\\n                    mark[ind-1]=1;\\n                }\\n                if(ind+1<n&&mark[ind+1]==0){\\n                    mark[ind+1]=1;\\n                }\\n            }\\n        }\\n      return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531108,
                "title": "python-sort",
                "content": "We can either sort the array or use heap. I simply sorted.\\n```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        nums = [(val, i) for i, val in enumerate(nums)]\\n        visited = set()\\n        nums.sort()\\n        score = 0\\n        for val, i in nums:\\n            if i not in visited:\\n                visited.add(i-1)\\n                visited.add(i + 1)\\n                score += val\\n        return score\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        nums = [(val, i) for i, val in enumerate(nums)]\\n        visited = set()\\n        nums.sort()\\n        score = 0\\n        for val, i in nums:\\n            if i not in visited:\\n                visited.add(i-1)\\n                visited.add(i + 1)\\n                score += val\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519179,
                "title": "java-greedy-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> indexes = new PriorityQueue<>(\\n            //if two nums values are same sort the indexes in incr order\\n            //else sort them in incr order of nums[i] value\\n            (a, b) -> nums[a] == nums[b] ? a - b : nums[a] - nums[b]\\n        );\\n        boolean[] marked = new boolean[n];\\n        for(int i = 0; i < n; i++) indexes.add(i);\\n\\n        long score = 0;\\n        while(!indexes.isEmpty()){\\n            int smallestValIndex = indexes.poll();\\n            if(marked[smallestValIndex]) continue;\\n            marked[smallestValIndex] = true;\\n            if(smallestValIndex - 1 >= 0) marked[smallestValIndex - 1] = true;\\n            if(smallestValIndex + 1 < n) marked[smallestValIndex + 1] = true;\\n\\n            score += nums[smallestValIndex];\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> indexes = new PriorityQueue<>(\\n            //if two nums values are same sort the indexes in incr order\\n            //else sort them in incr order of nums[i] value\\n            (a, b) -> nums[a] == nums[b] ? a - b : nums[a] - nums[b]\\n        );\\n        boolean[] marked = new boolean[n];\\n        for(int i = 0; i < n; i++) indexes.add(i);\\n\\n        long score = 0;\\n        while(!indexes.isEmpty()){\\n            int smallestValIndex = indexes.poll();\\n            if(marked[smallestValIndex]) continue;\\n            marked[smallestValIndex] = true;\\n            if(smallestValIndex - 1 >= 0) marked[smallestValIndex - 1] = true;\\n            if(smallestValIndex + 1 < n) marked[smallestValIndex + 1] = true;\\n\\n            score += nums[smallestValIndex];\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483964,
                "title": "hashset-priority-queue-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+n)=O(2n)=O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n         for(int i=0;i<nums.size();i++)\\n            pq.push({nums[i],i});\\n            \\n            unordered_set<int> st;\\n            long long score=0;\\n            while(st.size()!=nums.size()){\\n                auto [ele,idx]=pq.top();pq.pop();\\n                if(st.find(idx)==st.end()){\\n                    score+=ele;\\n                    st.insert(idx); //mark cur ele\\n                    if(idx-1>=0)st.insert(idx-1); //mark its left index\\n                    if(idx+1<nums.size())st.insert(idx+1); // mark its right index\\n                }\\n            }\\n\\n            return score;\\n\\n\\n    }\\n};\\n```\\n// please upvote",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n         for(int i=0;i<nums.size();i++)\\n            pq.push({nums[i],i});\\n            \\n            unordered_set<int> st;\\n            long long score=0;\\n            while(st.size()!=nums.size()){\\n                auto [ele,idx]=pq.top();pq.pop();\\n                if(st.find(idx)==st.end()){\\n                    score+=ele;\\n                    st.insert(idx); //mark cur ele\\n                    if(idx-1>=0)st.insert(idx-1); //mark its left index\\n                    if(idx+1<nums.size())st.insert(idx+1); // mark its right index\\n                }\\n            }\\n\\n            return score;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481490,
                "title": "solution-without-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& a) {\\n        int i,j,n=a.size();\\n        long long sum=0;\\n        map<int,vector<int>>mk;\\n        for(i=0;i<n;i++){\\n            mk[a[i]].push_back(i);\\n        }\\n        for(auto ii:mk){\\n            if(ii.second.size()){\\n                for(auto dd:ii.second){\\n                    if(a[dd]){\\n                        sum+=a[dd];\\n                        if(dd-1>=0){\\n                            a[dd-1]=0;\\n                        }\\n                        if(dd+1<a.size()){\\n                            a[dd+1]=0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& a) {\\n        int i,j,n=a.size();\\n        long long sum=0;\\n        map<int,vector<int>>mk;\\n        for(i=0;i<n;i++){\\n            mk[a[i]].push_back(i);\\n        }\\n        for(auto ii:mk){\\n            if(ii.second.size()){\\n                for(auto dd:ii.second){\\n                    if(a[dd]){\\n                        sum+=a[dd];\\n                        if(dd-1>=0){\\n                            a[dd-1]=0;\\n                        }\\n                        if(dd+1<a.size()){\\n                            a[dd+1]=0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476355,
                "title": "python-heap-set",
                "content": "```\\nclass Solution(object):\\n    def findScore(self, nums):\\n        heap, m = [], len(nums)\\n        for i, e in enumerate(nums):\\n            heappush(heap, (e, i))\\n        seen, ans = set(), 0\\n        while heap:\\n            e, i = heappop(heap)\\n            if (e, i) in seen:\\n                continue\\n            ans += e\\n            seen.add((e, i))\\n            left, right = i - 1, i + 1\\n            if 0 <= left < m:\\n                seen.add((nums[left], left))\\n            if 0 <= right < m:\\n                seen.add((nums[right], right))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def findScore(self, nums):\\n        heap, m = [], len(nums)\\n        for i, e in enumerate(nums):\\n            heappush(heap, (e, i))\\n        seen, ans = set(), 0\\n        while heap:\\n            e, i = heappop(heap)\\n            if (e, i) in seen:\\n                continue\\n            ans += e\\n            seen.add((e, i))\\n            left, right = i - 1, i + 1\\n            if 0 <= left < m:\\n                seen.add((nums[left], left))\\n            if 0 <= right < m:\\n                seen.add((nums[right], right))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474046,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n-> store the element of nums with thier index in set \"st\" by making pair.\\n-> \"st\" will sort according to the first element of pair(nums[i]).\\n-> create another set \"s\" to store the index and to check wether the index is marked.\\n-> rether then marking element ,mark their index\\uD83D\\uDE09.\\n-> iterate through set \"st\" and first check the index(second element of pair) int set \"s\".\\n-> if that index is present do nothing(continue).\\n-> else we have to add that element in our \"ans\",and mark that index and also mark the adjasent indexes.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans =0;\\n        set<pair<int,int>>st;\\n        for(int i=0;i<nums.size();i++){\\n    <!-- \"store the element of nums with thier index in set \"st\" by making pair.\" -->\\n            st.insert({nums[i],i});\\n        }\\n    <!-- \" \"st\" will sort according to the first element of pair(nums[i]).\" -->\\n        \\n        set<int>s;\\n    <!--\" create another set \"s\" to store the index and to check wether the index is marked.\" -->\\n        int ind;\\n    <!-- \"iterate through set \"st\" and first check the index(second element of pair) int set \"s\".\" -->\\n        for(auto x:st){\\n            ind =x.second;\\n    <!-- \"if that index is present do nothing(continue)\". -->\\n            if(s.count(ind)) continue;\\n            else{\\n    <!-- \"else we have to add that element in our \"ans\",and mark that index and also mark the adjasent indexes.\" -->\\n                s.insert(ind);\\n                if(ind<nums.size()) s.insert(ind+1);\\n                if(ind>0) s.insert(ind-1);\\n                ans += x.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans =0;\\n        set<pair<int,int>>st;\\n        for(int i=0;i<nums.size();i++){\\n    <!-- \"store the element of nums with thier index in set \"st\" by making pair.\" -->\\n            st.insert({nums[i],i});\\n        }\\n    <!-- \" \"st\" will sort according to the first element of pair(nums[i]).\" -->\\n        \\n        set<int>s;\\n    <!--\" create another set \"s\" to store the index and to check wether the index is marked.\" -->\\n        int ind;\\n    <!-- \"iterate through set \"st\" and first check the index(second element of pair) int set \"s\".\" -->\\n        for(auto x:st){\\n            ind =x.second;\\n    <!-- \"if that index is present do nothing(continue)\". -->\\n            if(s.count(ind)) continue;\\n            else{\\n    <!-- \"else we have to add that element in our \"ans\",and mark that index and also mark the adjasent indexes.\" -->\\n                s.insert(ind);\\n                if(ind<nums.size()) s.insert(ind+1);\\n                if(ind>0) s.insert(ind-1);\\n                ans += x.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472599,
                "title": "easy-to-understand-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n<!-- Please upvote if you like this solution. -->\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i],i});\\n        }\\n        unordered_map<int,bool> mp;\\n        for(int i=0;i<n;i++){\\n            mp[i]=false;\\n        }\\n        long long sum=0;\\n        while(!pq.empty()){\\n            auto top=pq.top();\\n            pq.pop();\\n            int num=top.first;\\n            int index=top.second;\\n            if(!mp[index]){\\n                sum+=nums[index];\\n                if(index-1>=0){\\n                    mp[index-1]=true;\\n                }\\n                if(index+1<n){\\n                    mp[index+1]=true;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i],i});\\n        }\\n        unordered_map<int,bool> mp;\\n        for(int i=0;i<n;i++){\\n            mp[i]=false;\\n        }\\n        long long sum=0;\\n        while(!pq.empty()){\\n            auto top=pq.top();\\n            pq.pop();\\n            int num=top.first;\\n            int index=top.second;\\n            if(!mp[index]){\\n                sum+=nums[index];\\n                if(index-1>=0){\\n                    mp[index-1]=true;\\n                }\\n                if(index+1<n){\\n                    mp[index+1]=true;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469878,
                "title": "python-3-simple-solution-time-nlog-n-space-n",
                "content": "# Intuition\\nInitially, the idea is to find the smallest unmarked value in the array and add it to the score. After adding the smallest value, we need to mark its neighbors, so they are not considered in the next iteration. We have to do this until all elements are marked.\\n\\n# Approach\\n1. Create an array of indices sorted according to the value at the corresponding index in the input array.\\n2. Initialize a variable `score` to keep track of the total score.\\n3. Iterate through the sorted indices:\\n   a. If the value at the current index is greater than 0, it means it is unmarked. Add this value to the `score`.\\n   b. Mark the neighboring elements by setting their values to 0 (if they exist).\\n4. Return the final `score`.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log{n})$$, because sorting the indices takes $$n\\\\log{n}$$ time.\\n- Space complexity: $$O(n)$$, as we create an additional array to store sorted indices.\\n\\n# Code\\n```python\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        sorted_indexes = sorted(range(len(nums)), key=lambda index: nums[index])\\n        score = 0\\n        for i in sorted_indexes:\\n            if nums[i] > 0:\\n                score += nums[i]\\n                if i > 0:\\n                    nums[i-1] = 0\\n                if i < (len(nums) - 1):\\n                    nums[i+1] = 0\\n        return score\\n```\\nThis code defines a class `Solution` with the function `findScore` that takes an input array `nums` and returns the computed score following the approach mentioned above.\\n                \\n\\n                \\n            \\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        sorted_indexes = sorted(range(len(nums)), key=lambda index: nums[index])\\n        score = 0\\n        for i in sorted_indexes:\\n            if nums[i] > 0:\\n                score += nums[i]\\n                if i > 0:\\n                    nums[i-1] = 0\\n                if i < (len(nums) - 1):\\n                    nums[i+1] = 0\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461847,
                "title": "rust-python-go-o-n-logn-explanation",
                "content": "# Intuition\\nHave an information whether the element was already used (either selected or can no longer be selected) `is_selected`. \\n\\nThen iterate over all elements, in order specified in the description, if the element is not in `is_selected`, then add to res and mark it (and elements around it) as selected.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$\\n- Space complexity: $O(n)$\\n\\n\\n```Rust []\\n#[derive(Eq, Ord, PartialEq, PartialOrd)]\\nstruct El {\\n  val: i64,\\n  pos: usize,\\n}\\n\\nimpl Solution {\\n  pub fn find_score(nums: Vec<i32>) -> i64 {\\n    let (mut res, n) = (0, nums.len());\\n        \\n    let mut data = Vec::with_capacity(n);\\n    for i in 0 .. n {\\n      data.push(El{val: nums[i] as i64, pos: i + 1})\\n    }\\n    data.sort_unstable();\\n\\n    let mut is_selected = vec![false; n + 2];\\n    for v in data {\\n      if !is_selected[v.pos] {\\n        res += v.val;\\n        is_selected[v.pos - 1] = true;\\n        is_selected[v.pos    ] = true;\\n        is_selected[v.pos + 1] = true;\\n      }\\n    }\\n\\n    return res;\\n  }\\n}\\n```\\n```Python []\\nclass Solution:\\n  def findScore(self, nums: List[int]) -> int:\\n    res = 0\\n    selected = [0] * (len(nums) + 2)\\n\\n    data = [(v, p + 1) for p, v in enumerate(nums)]\\n    data.sort()\\n    \\n    for v, p in data:\\n      if selected[p]:\\n        continue\\n      \\n      res += v\\n      selected[p    ] = 1\\n      selected[p + 1] = 1\\n      selected[p - 1] = 1\\n\\n    return res\\n```\\n```Go []\\nimport \"sort\"\\n\\ntype el struct {\\n  Val int\\n  Pos int\\n}\\n\\nfunc findScore(nums []int) int64 {\\n  res, is_selected := int64(0), make([]bool, len(nums) + 2) \\n  data := make([]el, len(nums))\\n\\n  for i, v := range nums {\\n    data[i] = el{v, i + 1}\\n  }\\n\\n  sort.Slice(data, func(i, j int) bool {\\n    if data[i].Val < data[j].Val {\\n      return true\\n    }\\n    if data[i].Val == data[j].Val {\\n      return data[i].Pos < data[j].Pos\\n    }\\n    return false\\n  })\\n\\n  for _, el := range data {\\n    if is_selected[el.Pos] {\\n      continue\\n    }\\n\\n    res += int64(el.Val)\\n    is_selected[el.Pos - 1] = true\\n    is_selected[el.Pos    ] = true\\n    is_selected[el.Pos + 1] = true\\n  }\\n\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust []\\n#[derive(Eq, Ord, PartialEq, PartialOrd)]\\nstruct El {\\n  val: i64,\\n  pos: usize,\\n}\\n\\nimpl Solution {\\n  pub fn find_score(nums: Vec<i32>) -> i64 {\\n    let (mut res, n) = (0, nums.len());\\n        \\n    let mut data = Vec::with_capacity(n);\\n    for i in 0 .. n {\\n      data.push(El{val: nums[i] as i64, pos: i + 1})\\n    }\\n    data.sort_unstable();\\n\\n    let mut is_selected = vec![false; n + 2];\\n    for v in data {\\n      if !is_selected[v.pos] {\\n        res += v.val;\\n        is_selected[v.pos - 1] = true;\\n        is_selected[v.pos    ] = true;\\n        is_selected[v.pos + 1] = true;\\n      }\\n    }\\n\\n    return res;\\n  }\\n}\\n```\n```Python []\\nclass Solution:\\n  def findScore(self, nums: List[int]) -> int:\\n    res = 0\\n    selected = [0] * (len(nums) + 2)\\n\\n    data = [(v, p + 1) for p, v in enumerate(nums)]\\n    data.sort()\\n    \\n    for v, p in data:\\n      if selected[p]:\\n        continue\\n      \\n      res += v\\n      selected[p    ] = 1\\n      selected[p + 1] = 1\\n      selected[p - 1] = 1\\n\\n    return res\\n```\n```Go []\\nimport \"sort\"\\n\\ntype el struct {\\n  Val int\\n  Pos int\\n}\\n\\nfunc findScore(nums []int) int64 {\\n  res, is_selected := int64(0), make([]bool, len(nums) + 2) \\n  data := make([]el, len(nums))\\n\\n  for i, v := range nums {\\n    data[i] = el{v, i + 1}\\n  }\\n\\n  sort.Slice(data, func(i, j int) bool {\\n    if data[i].Val < data[j].Val {\\n      return true\\n    }\\n    if data[i].Val == data[j].Val {\\n      return data[i].Pos < data[j].Pos\\n    }\\n    return false\\n  })\\n\\n  for _, el := range data {\\n    if is_selected[el.Pos] {\\n      continue\\n    }\\n\\n    res += int64(el.Val)\\n    is_selected[el.Pos - 1] = true\\n    is_selected[el.Pos    ] = true\\n    is_selected[el.Pos + 1] = true\\n  }\\n\\n  return res\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452522,
                "title": "sorting-and-marking-adjacent-indexes",
                "content": "# Approach\\n- Store (value,index) pair in helper vector.\\n- Sort ascending. C++ does the right thing (uses values first then indexes)\\n- Traverse new vector, adding values and marking adjacent indexes.\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        vector<pair<int,int>> vals;\\n        for (int i = 0; i < nums.size(); i++) {\\n            vals.push_back({nums[i], i});\\n        }\\n\\n        std::sort(vals.begin(), vals.end());\\n\\n        long long sum = 0;\\n        for (auto& pair : vals) {\\n            int i = pair.second;\\n            if (nums[i] > 0) {\\n                sum += nums[i];\\n                if (i > 0) { nums[i - 1] = 0; }\\n                if (i < nums.size() - 1) { nums[i + 1] = 0; }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        vector<pair<int,int>> vals;\\n        for (int i = 0; i < nums.size(); i++) {\\n            vals.push_back({nums[i], i});\\n        }\\n\\n        std::sort(vals.begin(), vals.end());\\n\\n        long long sum = 0;\\n        for (auto& pair : vals) {\\n            int i = pair.second;\\n            if (nums[i] > 0) {\\n                sum += nums[i];\\n                if (i > 0) { nums[i - 1] = 0; }\\n                if (i < nums.size() - 1) { nums[i + 1] = 0; }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450124,
                "title": "simple-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        long long int res = 0; \\n        vector<pair<int, int>> v ;\\n        unordered_set<int> s ; \\n        for(int i = 0; i< nums.size();i++)\\n        v.push_back({nums[i],i});\\n        sort(v.begin(),v.end());\\n\\n        for(int i = 0; i<v.size();i++)\\n        {   \\n            int val = v[i].first;\\n            int index = v[i].second;\\n            if(s.find(index)==s.end())\\n            {\\n                res += val;\\n                s.insert(index);\\n                if(index-1>=0)\\n                s.insert(index-1);\\n                if(index+1<nums.size())\\n                s.insert(index+1);\\n            }\\n            \\n        }\\n\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        long long int res = 0; \\n        vector<pair<int, int>> v ;\\n        unordered_set<int> s ; \\n        for(int i = 0; i< nums.size();i++)\\n        v.push_back({nums[i],i});\\n        sort(v.begin(),v.end());\\n\\n        for(int i = 0; i<v.size();i++)\\n        {   \\n            int val = v[i].first;\\n            int index = v[i].second;\\n            if(s.find(index)==s.end())\\n            {\\n                res += val;\\n                s.insert(index);\\n                if(index-1>=0)\\n                s.insert(index-1);\\n                if(index+1<nums.size())\\n                s.insert(index+1);\\n            }\\n            \\n        }\\n\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447477,
                "title": "easiest-c-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>vis(n, 0);\\n        vector<pair<int, int>>indices;\\n        for(int i = 0; i<n; i++)\\n        {\\n            indices.push_back({nums[i], i});\\n        }\\n        sort(indices.begin(), indices.end());\\n        long long ans = 0;\\n        for(auto e: indices)\\n        {\\n            int ind = e.second;\\n            if(!vis[ind])\\n            {\\n                ans+= e.first;\\n                vis[ind] = 1;\\n                if(ind+1<n)vis[ind+1] = 1;\\n                if(ind-1>=0)vis[ind-1] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int>vis(n, 0);\\n        vector<pair<int, int>>indices;\\n        for(int i = 0; i<n; i++)\\n        {\\n            indices.push_back({nums[i], i});\\n        }\\n        sort(indices.begin(), indices.end());\\n        long long ans = 0;\\n        for(auto e: indices)\\n        {\\n            int ind = e.second;\\n            if(!vis[ind])\\n            {\\n                ans+= e.first;\\n                vis[ind] = 1;\\n                if(ind+1<n)vis[ind+1] = 1;\\n                if(ind-1>=0)vis[ind-1] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445563,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public long FindScore(int[] nums)\\n    {\\n        long scores = 0;\\n        var marked = new bool[nums.Length];\\n        var comparer = Comparer<(int, int)>.Create((a, b) => {\\n            if (a.Item1 == b.Item1)\\n                return a.Item2.CompareTo(b.Item2);\\n\\n            return a.Item1.CompareTo(b.Item1);\\n        });\\n        var pq = new PriorityQueue<(int, int), (int, int)>(comparer);\\n\\n\\n        for (int i = 0; i < nums.Length; i++)\\n            pq.Enqueue((nums[i], i), (nums[i], i));\\n\\n        while (pq.Count > 0)\\n        {\\n            var temp = pq.Dequeue();\\n            if (!marked[temp.Item2])\\n            {\\n                scores += temp.Item1;\\n                marked[temp.Item2] = true;\\n                if(temp.Item2 - 1 >= 0)\\n                    marked[temp.Item2 - 1] = true;\\n                if(temp.Item2 + 1 < nums.Length)\\n                    marked[temp.Item2 + 1] = true;\\n            }\\n        }\\n\\n        return scores;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long FindScore(int[] nums)\\n    {\\n        long scores = 0;\\n        var marked = new bool[nums.Length];\\n        var comparer = Comparer<(int, int)>.Create((a, b) => {\\n            if (a.Item1 == b.Item1)\\n                return a.Item2.CompareTo(b.Item2);\\n\\n            return a.Item1.CompareTo(b.Item1);\\n        });\\n        var pq = new PriorityQueue<(int, int), (int, int)>(comparer);\\n\\n\\n        for (int i = 0; i < nums.Length; i++)\\n            pq.Enqueue((nums[i], i), (nums[i], i));\\n\\n        while (pq.Count > 0)\\n        {\\n            var temp = pq.Dequeue();\\n            if (!marked[temp.Item2])\\n            {\\n                scores += temp.Item1;\\n                marked[temp.Item2] = true;\\n                if(temp.Item2 - 1 >= 0)\\n                    marked[temp.Item2 - 1] = true;\\n                if(temp.Item2 + 1 < nums.Length)\\n                    marked[temp.Item2 + 1] = true;\\n            }\\n        }\\n\\n        return scores;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440072,
                "title": "simple-and-easy-apply-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static  bool cmp(pair<int,int>a,pair<int,int>b)\\n    {\\n        if(a.first==b.first)\\n            return a.second<b.second;\\n        return a.first<b.first;\\n    }\\n    long long findScore(vector<int>& nums) {\\n        vector<pair<int,int>>v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            v.push_back({nums[i],i});\\n        sort(v.begin(),v.end(),cmp);\\n        vector<int>used(n,0);\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=v[i].first,index=v[i].second;\\n            if(used[index]==0)\\n            {\\n                used[index]=1;\\n                if(index-1>=0)\\n                    used[index-1]=1;\\n                if(index+1<n)\\n                    used[index+1]=1;\\n                ans+=val;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static  bool cmp(pair<int,int>a,pair<int,int>b)\\n    {\\n        if(a.first==b.first)\\n            return a.second<b.second;\\n        return a.first<b.first;\\n    }\\n    long long findScore(vector<int>& nums) {\\n        vector<pair<int,int>>v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            v.push_back({nums[i],i});\\n        sort(v.begin(),v.end(),cmp);\\n        vector<int>used(n,0);\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=v[i].first,index=v[i].second;\\n            if(used[index]==0)\\n            {\\n                used[index]=1;\\n                if(index-1>=0)\\n                    used[index-1]=1;\\n                if(index+1<n)\\n                    used[index+1]=1;\\n                ans+=val;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437388,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        int vis[n];\\n        for(int i=0; i<n; i++) vis[i] = 0;\\n\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;\\n        for(int i=0; i<n; i++) q.push({nums[i], i});\\n\\n        ll score = 0;\\n        while(!q.empty())\\n        {\\n            auto t = q.top();\\n            q.pop();\\n\\n            int i = t.second;\\n            if(!vis[i])\\n            {\\n                score += t.first;\\n                vis[i] = 1;\\n                if(i+1 < n) vis[i+1] = 1;\\n                if(i-1>=0) vis[i-1] = 1;\\n            }\\n        }\\n\\n        return score;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        int vis[n];\\n        for(int i=0; i<n; i++) vis[i] = 0;\\n\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;\\n        for(int i=0; i<n; i++) q.push({nums[i], i});\\n\\n        ll score = 0;\\n        while(!q.empty())\\n        {\\n            auto t = q.top();\\n            q.pop();\\n\\n            int i = t.second;\\n            if(!vis[i])\\n            {\\n                score += t.first;\\n                vis[i] = 1;\\n                if(i+1 < n) vis[i+1] = 1;\\n                if(i-1>=0) vis[i-1] = 1;\\n            }\\n        }\\n\\n        return score;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427400,
                "title": "using-priority-queue-by-checking-marked-or-not-marked",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n         priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>\\n         pq;\\n        \\n        long long int ans=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pair<int,int> p;\\n            p.first=nums[i];\\n            p.second=i;\\n            pq.push(p);\\n        }\\n\\n\\n        int count=0;\\n        int n=nums.size();\\n\\n        vector<bool> v(nums.size(),false);\\n\\n\\n\\n        while(!pq.empty())\\n        {   \\n           \\n            if(v[pq.top().second]==false)\\n            {   \\n              ans+=pq.top().first;\\n            }\\n            else\\n            {\\n                pq.pop();\\n            continue;\\n            \\n            }\\n            v[pq.top().second]=true;\\n\\n            if(pq.top().second==0)\\n            {\\n                v[pq.top().second+1]=true;\\n            }\\n            else if(pq.top().second==n-1)\\n            {\\n                v[pq.top().second-1]=true;\\n            }\\n            else\\n            {   \\n                v[pq.top().second-1]=true;\\n               \\n              \\n                v[pq.top().second+1]=true;\\n              \\n            }\\n          \\n            pq.pop();\\n           \\n\\n\\n        }\\n\\n        return ans;\\n\\n\\n       \\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n         priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>\\n         pq;\\n        \\n        long long int ans=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pair<int,int> p;\\n            p.first=nums[i];\\n            p.second=i;\\n            pq.push(p);\\n        }\\n\\n\\n        int count=0;\\n        int n=nums.size();\\n\\n        vector<bool> v(nums.size(),false);\\n\\n\\n\\n        while(!pq.empty())\\n        {   \\n           \\n            if(v[pq.top().second]==false)\\n            {   \\n              ans+=pq.top().first;\\n            }\\n            else\\n            {\\n                pq.pop();\\n            continue;\\n            \\n            }\\n            v[pq.top().second]=true;\\n\\n            if(pq.top().second==0)\\n            {\\n                v[pq.top().second+1]=true;\\n            }\\n            else if(pq.top().second==n-1)\\n            {\\n                v[pq.top().second-1]=true;\\n            }\\n            else\\n            {   \\n                v[pq.top().second-1]=true;\\n               \\n              \\n                v[pq.top().second+1]=true;\\n              \\n            }\\n          \\n            pq.pop();\\n           \\n\\n\\n        }\\n\\n        return ans;\\n\\n\\n       \\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427053,
                "title": "sort",
                "content": "```\\nlong long findScore(vector<int>& n)\\n{\\n\\tvector<int> v(size(n));\\n\\tiota(begin(v), end(v), 0);\\n\\tstable_sort(begin(v), end(v), [&](int i, int j){ return n[i]<n[j]; });\\n\\tlong long out{};\\n\\tfor(const auto & i : v)\\n\\t{\\n\\t\\tout += n[i];         \\n\\t\\tif(n[i])\\n\\t\\t{\\n\\t\\t\\tif(i)           n[i-1]=0;\\n\\t\\t\\tif(i+1<size(n)) n[i+1]=0;\\n\\t\\t}\\n\\t\\tn[i] = 0;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long findScore(vector<int>& n)\\n{\\n\\tvector<int> v(size(n));\\n\\tiota(begin(v), end(v), 0);\\n\\tstable_sort(begin(v), end(v), [&](int i, int j){ return n[i]<n[j]; });\\n\\tlong long out{};\\n\\tfor(const auto & i : v)\\n\\t{\\n\\t\\tout += n[i];         \\n\\t\\tif(n[i])\\n\\t\\t{\\n\\t\\t\\tif(i)           n[i-1]=0;\\n\\t\\t\\tif(i+1<size(n)) n[i+1]=0;\\n\\t\\t}\\n\\t\\tn[i] = 0;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3426815,
                "title": "easy-solution-using-heap-and-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        min_heap=[]\\n        for i  in range(len(nums)):\\n            heappush(min_heap,(nums[i],i))\\n        c=0\\n        vis=set()\\n        while min_heap:\\n            val,idx=heappop(min_heap)\\n            if idx in vis:\\n                continue\\n            vis.add(idx+1)\\n            vis.add(idx)\\n            vis.add(idx-1)\\n            c+=val\\n        return c\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        min_heap=[]\\n        for i  in range(len(nums)):\\n            heappush(min_heap,(nums[i],i))\\n        c=0\\n        vis=set()\\n        while min_heap:\\n            val,idx=heappop(min_heap)\\n            if idx in vis:\\n                continue\\n            vis.add(idx+1)\\n            vis.add(idx)\\n            vis.add(idx-1)\\n            c+=val\\n        return c\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425247,
                "title": "easy-c-solution",
                "content": "# Intuition\\nUse MinHeap\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse MinHeap & pop the minimum element and if not marked then do the process.\\n# Also i am storing the data in the min heap in format like **[(data + index) , data]**\\nso automatically if same element are present then the element with lesser index will come first.\\n\\nThat\\'s all !\\nThanks for reading \\uD83D\\uDE4F\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        typedef pair<int, int> pii; // value + index : value\\n        \\n        long long score = 0;\\n        priority_queue<pii, vector<pii>, greater<pii>> minHeap;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            minHeap.push({nums[i] + i, nums[i]});\\n        }\\n\\n        while (minHeap.size()) {\\n            pii p = minHeap.top();\\n            minHeap.pop();\\n            int index = p.first - p.second;\\n\\n            if (nums[index] != -1) {\\n                score += nums[index];\\n                nums[index] = -1;\\n                if (index > 0)\\n                    nums[index - 1] = -1;\\n                if (index < nums.size() - 1)\\n                    nums[index + 1] = -1;\\n            }\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        typedef pair<int, int> pii; // value + index : value\\n        \\n        long long score = 0;\\n        priority_queue<pii, vector<pii>, greater<pii>> minHeap;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            minHeap.push({nums[i] + i, nums[i]});\\n        }\\n\\n        while (minHeap.size()) {\\n            pii p = minHeap.top();\\n            minHeap.pop();\\n            int index = p.first - p.second;\\n\\n            if (nums[index] != -1) {\\n                score += nums[index];\\n                nums[index] = -1;\\n                if (index > 0)\\n                    nums[index - 1] = -1;\\n                if (index < nums.size() - 1)\\n                    nums[index + 1] = -1;\\n            }\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423493,
                "title": "c-multiset-heap",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    #define pii pair<int,int>\\n    #define F first\\n    #define S second\\n    #define ll long long\\n    long long findScore(vector<int>& nums) {\\n        multiset<pii> ms;//{ele,idx}\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            ms.insert({nums[i],i});\\n        }\\n        ll score = 0;\\n        while(!ms.empty()){\\n            auto it = *ms.begin();\\n            ms.erase(ms.begin());\\n            score += it.first;\\n\\n            int leftIdx = (it.second)-1 ;\\n            int rightIdx = (it.second)+1 ;\\n\\n            //remove leftIdx and rightIdx from multiset\\n\\n            if(leftIdx >= 0 and leftIdx<=n-1){\\n                auto it1 = ms.find({nums[leftIdx],leftIdx});\\n                if(it1 != ms.end()){\\n                    ms.erase(it1);\\n                }\\n                \\n            }\\n\\n            if(rightIdx >= 0 and rightIdx<=n-1){\\n                auto it2 = ms.find({nums[rightIdx],rightIdx});\\n                if(it2 != ms.end()){\\n                    ms.erase(it2);\\n                }\\n            }\\n\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    #define pii pair<int,int>\\n    #define F first\\n    #define S second\\n    #define ll long long\\n    long long findScore(vector<int>& nums) {\\n        multiset<pii> ms;//{ele,idx}\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            ms.insert({nums[i],i});\\n        }\\n        ll score = 0;\\n        while(!ms.empty()){\\n            auto it = *ms.begin();\\n            ms.erase(ms.begin());\\n            score += it.first;\\n\\n            int leftIdx = (it.second)-1 ;\\n            int rightIdx = (it.second)+1 ;\\n\\n            //remove leftIdx and rightIdx from multiset\\n\\n            if(leftIdx >= 0 and leftIdx<=n-1){\\n                auto it1 = ms.find({nums[leftIdx],leftIdx});\\n                if(it1 != ms.end()){\\n                    ms.erase(it1);\\n                }\\n                \\n            }\\n\\n            if(rightIdx >= 0 and rightIdx<=n-1){\\n                auto it2 = ms.find({nums[rightIdx],rightIdx});\\n                if(it2 != ms.end()){\\n                    ms.erase(it2);\\n                }\\n            }\\n\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418973,
                "title": "find-score-of-an-array-after-marking-all-elements",
                "content": "--------------- Easy C++ Solution --------------------\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n    long long ans = 0;\\n    set<pair<int, int>> numAndIndices;\\n    vector<bool> seen(nums.size());\\n\\n    for (int i = 0; i < nums.size(); ++i)\\n      numAndIndices.insert({nums[i], i});\\n\\n    for (auto& [num, i] : numAndIndices) {\\n      if (seen[i])\\n        continue;\\n      if (i > 0)\\n        seen[i - 1] = true;\\n      if (i + 1 < nums.size())\\n        seen[i + 1] = true;\\n      seen[i] = true;\\n      ans += num;\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n    long long ans = 0;\\n    set<pair<int, int>> numAndIndices;\\n    vector<bool> seen(nums.size());\\n\\n    for (int i = 0; i < nums.size(); ++i)\\n      numAndIndices.insert({nums[i], i});\\n\\n    for (auto& [num, i] : numAndIndices) {\\n      if (seen[i])\\n        continue;\\n      if (i > 0)\\n        seen[i - 1] = true;\\n      if (i + 1 < nums.size())\\n        seen[i + 1] = true;\\n      seen[i] = true;\\n      ans += num;\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415174,
                "title": "easy-understandable-priority-queue",
                "content": "# Intuition: \\n- Priority Queue + Hashing(Visited Index)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Create a vector pair to store element,index of the array \\n- Create a min heap and push the vector pair\\n- Now, while pq is not empty: \\n- take the top element from the pq\\n-       element = pq.top().first\\n-  if it is not visited, add element to the ans\\n-       idx = pq.top().second\\n- Mark the idx-1 & idx+1 as visited \\n- Finally return the ans\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Approximately O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Approximately O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef pair<long long,long long> pl;\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        vector<pl> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums[i],i});\\n        }\\n        priority_queue<pl,vector<pl>, greater<pl>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push(v[i]);\\n        }\\n\\n        long long ans=0;\\n        vector<bool> vis(n,false);\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int val=it.first;\\n            int idx=it.second;\\n\\n            if(!vis[idx]){\\n                ans+=val;\\n                if(idx-1>=0){\\n                    vis[idx-1]=true;\\n                }\\n                if(idx+1<n){\\n                    vis[idx+1]=true;\\n                }\\n            }\\n            vis[idx]=true;\\n            if(vis[idx]){\\n                pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\ntypedef pair<long long,long long> pl;\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        vector<pl> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums[i],i});\\n        }\\n        priority_queue<pl,vector<pl>, greater<pl>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push(v[i]);\\n        }\\n\\n        long long ans=0;\\n        vector<bool> vis(n,false);\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int val=it.first;\\n            int idx=it.second;\\n\\n            if(!vis[idx]){\\n                ans+=val;\\n                if(idx-1>=0){\\n                    vis[idx-1]=true;\\n                }\\n                if(idx+1<n){\\n                    vis[idx+1]=true;\\n                }\\n            }\\n            vis[idx]=true;\\n            if(vis[idx]){\\n                pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414153,
                "title": "c-sorting-easy-to-understand-fast-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> &a, pair<int,int> &b)\\n    {\\n        if(a.first == b.first)\\n        {\\n            return a.second < b.second;\\n        }\\n        return a.first < b.first;\\n    }\\n    \\n    long long findScore(vector<int>& nums) {\\n        vector<pair<int,int>> v1;\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            v1.push_back({nums[i],i});\\n        }\\n        sort(v1.begin(),v1.end(),cmp);\\n        vector<int> marked(n,0);\\n        long long int ans = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(marked[v1[i].second] == 0)\\n            {\\n                ans += v1[i].first;\\n                int index = v1[i].second;\\n                marked[index] = 1;\\n                if(index > 0)\\n                {\\n                    marked[index-1] = 1;\\n                }\\n                if(index < n-1)\\n                {\\n                    marked[index+1] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> &a, pair<int,int> &b)\\n    {\\n        if(a.first == b.first)\\n        {\\n            return a.second < b.second;\\n        }\\n        return a.first < b.first;\\n    }\\n    \\n    long long findScore(vector<int>& nums) {\\n        vector<pair<int,int>> v1;\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            v1.push_back({nums[i],i});\\n        }\\n        sort(v1.begin(),v1.end(),cmp);\\n        vector<int> marked(n,0);\\n        long long int ans = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(marked[v1[i].second] == 0)\\n            {\\n                ans += v1[i].first;\\n                int index = v1[i].second;\\n                marked[index] = 1;\\n                if(index > 0)\\n                {\\n                    marked[index-1] = 1;\\n                }\\n                if(index < n-1)\\n                {\\n                    marked[index+1] = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404496,
                "title": "java-treemap-set",
                "content": "# Explanation\\nUsing TreeMap to keep sorted values + their indices.\\nThen going thru all values from map (kept as keys) and checking of the indices have already been marked.\\n\\nCheers!\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        TreeMap<Integer, List<Integer>> map = new TreeMap<>();\\n        for (int i = 0; i < nums.length; i++) map.computeIfAbsent(nums[i], n -> new ArrayList<>()).add(i);\\n        Set<Integer> marked = new HashSet<>();\\n        long score = 0;\\n        for (int key : map.keySet()) {\\n            List<Integer> list = map.get(key);\\n            for (int idx : list) {\\n                if (!marked.contains(idx)) {\\n                    score += key;\\n                    marked.add(idx);\\n                    marked.add(idx + 1);\\n                    marked.add(idx - 1);\\n                }\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        TreeMap<Integer, List<Integer>> map = new TreeMap<>();\\n        for (int i = 0; i < nums.length; i++) map.computeIfAbsent(nums[i], n -> new ArrayList<>()).add(i);\\n        Set<Integer> marked = new HashSet<>();\\n        long score = 0;\\n        for (int key : map.keySet()) {\\n            List<Integer> list = map.get(key);\\n            for (int idx : list) {\\n                if (!marked.contains(idx)) {\\n                    score += key;\\n                    marked.add(idx);\\n                    marked.add(idx + 1);\\n                    marked.add(idx - 1);\\n                }\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403381,
                "title": "c-solution-heap-set",
                "content": "# Code\\n```\\nclass Solution {\\n    typedef pair<long long,int> pi;\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        if(nums.size() == 1){return nums[0];}\\n        if(nums.size() == 2){return nums[0] < nums[1] ? nums[0] : nums[1];}\\n\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        for(int i = 0;i < nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        \\n        set<long long> s;\\n        long long res = 0;\\n        while(!pq.empty()){\\n            long long no = pq.top().first;\\n            long long ind = pq.top().second;\\n\\n            if(s.find(ind) != s.end()){\\n                pq.pop();\\n            }else{\\n                pq.pop();\\n                if(ind == 0){\\n                    nums[ind] = -1;\\n                    nums[ind + 1] = -1; \\n                    s.insert(ind);\\n                    s.insert(ind+1);\\n                }else if(ind == nums.size() - 1){\\n                    nums[ind] = -1;\\n                    nums[ind - 1] = -1;\\n                    s.insert(ind);\\n                    s.insert(ind-1);\\n                }else{\\n                    nums[ind] = -1;\\n                    nums[ind + 1] = -1; \\n                    nums[ind - 1] = -1;\\n                    s.insert(ind);\\n                    s.insert(ind+1);\\n                    s.insert(ind-1);\\n                }\\n                res += no;\\n            }\\n\\n            if(s.size() == nums.size()) {break;}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    typedef pair<long long,int> pi;\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        if(nums.size() == 1){return nums[0];}\\n        if(nums.size() == 2){return nums[0] < nums[1] ? nums[0] : nums[1];}\\n\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        for(int i = 0;i < nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        \\n        set<long long> s;\\n        long long res = 0;\\n        while(!pq.empty()){\\n            long long no = pq.top().first;\\n            long long ind = pq.top().second;\\n\\n            if(s.find(ind) != s.end()){\\n                pq.pop();\\n            }else{\\n                pq.pop();\\n                if(ind == 0){\\n                    nums[ind] = -1;\\n                    nums[ind + 1] = -1; \\n                    s.insert(ind);\\n                    s.insert(ind+1);\\n                }else if(ind == nums.size() - 1){\\n                    nums[ind] = -1;\\n                    nums[ind - 1] = -1;\\n                    s.insert(ind);\\n                    s.insert(ind-1);\\n                }else{\\n                    nums[ind] = -1;\\n                    nums[ind + 1] = -1; \\n                    nums[ind - 1] = -1;\\n                    s.insert(ind);\\n                    s.insert(ind+1);\\n                    s.insert(ind-1);\\n                }\\n                res += no;\\n            }\\n\\n            if(s.size() == nums.size()) {break;}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399064,
                "title": "heap-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the problem is asked about finding the minimum value each time, so priority queue can used to extract the minimum each time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHeapify the existing array with index, by default python has min-heap. And i also had extra array marked, inorder to track the marked values after extracting minimum each time from the heap.\\nIterating over the heap, till heap becomes empty.\\nEach time, check if the idx is already marked.\\nIf yes, continue\\nelse, \\n    i. add the minimum value to score\\n    ii. check for the neighbors and marked them\\nFinally, return the score\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nHeapify takes NlogN (N is the number of elements in an array)\\nIterating through heat and extracting min each time takes: NlogN\\nOverall : NlogN + NlogN => O(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAdditional space is used for marked array which is of size N.\\nSpace complexity: O(N)\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        \\'\\'\\'\\n        We will store the index, value in heap, by default python has min-heap\\n        We will also have marked array and mark everything to false initially\\n        \\'\\'\\'\\n        n = len(nums)\\n        if n == 1:\\n            return nums[0]\\n        \\n        marked = [False] * n\\n        nums_with_index = [(val, idx) for idx, val in enumerate(nums)]\\n        \\n        # heapify\\n        heapq.heapify(nums_with_index)\\n        score = 0\\n        while nums_with_index:\\n            val, idx = heapq.heappop(nums_with_index)\\n            # print(idx, val)\\n            # check if the idx is already marked\\n            if marked[idx] == True:\\n                continue\\n            else:\\n                # add value to score\\n                score += val\\n                # first mark the index\\n                marked[idx] = True\\n                # mark the neighbors if present\\n                if idx == 0:\\n                    marked[idx + 1] = True\\n                elif idx == n - 1:\\n                    marked[idx - 1] = True\\n                else:\\n                    marked[idx + 1] = True\\n                    marked[idx - 1] = True\\n        return score\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        \\'\\'\\'\\n        We will store the index, value in heap, by default python has min-heap\\n        We will also have marked array and mark everything to false initially\\n        \\'\\'\\'\\n        n = len(nums)\\n        if n == 1:\\n            return nums[0]\\n        \\n        marked = [False] * n\\n        nums_with_index = [(val, idx) for idx, val in enumerate(nums)]\\n        \\n        # heapify\\n        heapq.heapify(nums_with_index)\\n        score = 0\\n        while nums_with_index:\\n            val, idx = heapq.heappop(nums_with_index)\\n            # print(idx, val)\\n            # check if the idx is already marked\\n            if marked[idx] == True:\\n                continue\\n            else:\\n                # add value to score\\n                score += val\\n                # first mark the index\\n                marked[idx] = True\\n                # mark the neighbors if present\\n                if idx == 0:\\n                    marked[idx + 1] = True\\n                elif idx == n - 1:\\n                    marked[idx - 1] = True\\n                else:\\n                    marked[idx + 1] = True\\n                    marked[idx - 1] = True\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398390,
                "title": "priority-queue-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long score{}; \\n        vector<int> marked(nums.size() , 0); // zeros represent that the all array is not marked   \\n        priority_queue< pair<int,int> , vector<pair<int , int>> ,greater<pair<int , int>> > q{};\\n        for(int i = 0 ; i < nums.size() ; i++) q.push({nums[i] , i });\\n        while(!q.empty()){\\n            auto p = q.top();\\n            int index = p.second;\\n            if(marked[index] == 0 ){\\n                marked[index] = 1 ; q.pop();\\n                score += p.first;\\n                if(index + 1 < nums.size()){ marked[index+1] = 1 ;}\\n                if(index - 1 >=0 ) {marked[index - 1 ] = 1 ;}\\n            }else q.pop();\\n\\n        }\\n       return score ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long score{}; \\n        vector<int> marked(nums.size() , 0); // zeros represent that the all array is not marked   \\n        priority_queue< pair<int,int> , vector<pair<int , int>> ,greater<pair<int , int>> > q{};\\n        for(int i = 0 ; i < nums.size() ; i++) q.push({nums[i] , i });\\n        while(!q.empty()){\\n            auto p = q.top();\\n            int index = p.second;\\n            if(marked[index] == 0 ){\\n                marked[index] = 1 ; q.pop();\\n                score += p.first;\\n                if(index + 1 < nums.size()){ marked[index+1] = 1 ;}\\n                if(index - 1 >=0 ) {marked[index - 1 ] = 1 ;}\\n            }else q.pop();\\n\\n        }\\n       return score ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393564,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/0788c05d-d2ed-49a1-884e-77b295c9a39f_1680952014.6283407.png)\\n\\n```\\nstruct pair {\\n    int val;\\n    int idx;\\n};\\n\\n#define ll long long\\n\\nint cmp(const void* a, const void* b) {\\n    const struct pair pa = *(const struct pair*) a;\\n    const struct pair pb = *(const struct pair*) b;\\n    if (pa.val == pb.val) return pa.idx - pb.idx;\\n    return pa.val - pb.val;\\n}\\n\\nlong long findScore(int* nums, int numsSize) {\\n    if (numsSize == 1) return (ll)nums[0];\\n    struct pair* arr = (struct pair*) calloc(numsSize, sizeof(struct pair));\\n    bool* IsMarked = (bool*) calloc(numsSize, sizeof(bool));\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i].val = nums[i];\\n        arr[i].idx = i;\\n    }\\n    qsort(arr, numsSize, sizeof(struct pair), cmp);  \\n    ll ans = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (IsMarked[arr[i].idx] == false) {\\n            ans += arr[i].val;\\n            if (arr[i].idx + 1 < numsSize) IsMarked[arr[i].idx + 1] = true;\\n            if (arr[i].idx - 1 >= 0) IsMarked[arr[i].idx - 1] = true;\\n        }\\n    }\\n    free(arr);\\n    free(IsMarked);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nstruct pair {\\n    int val;\\n    int idx;\\n};\\n\\n#define ll long long\\n\\nint cmp(const void* a, const void* b) {\\n    const struct pair pa = *(const struct pair*) a;\\n    const struct pair pb = *(const struct pair*) b;\\n    if (pa.val == pb.val) return pa.idx - pb.idx;\\n    return pa.val - pb.val;\\n}\\n\\nlong long findScore(int* nums, int numsSize) {\\n    if (numsSize == 1) return (ll)nums[0];\\n    struct pair* arr = (struct pair*) calloc(numsSize, sizeof(struct pair));\\n    bool* IsMarked = (bool*) calloc(numsSize, sizeof(bool));\\n    for (int i = 0; i < numsSize; i++) {\\n        arr[i].val = nums[i];\\n        arr[i].idx = i;\\n    }\\n    qsort(arr, numsSize, sizeof(struct pair), cmp);  \\n    ll ans = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (IsMarked[arr[i].idx] == false) {\\n            ans += arr[i].val;\\n            if (arr[i].idx + 1 < numsSize) IsMarked[arr[i].idx + 1] = true;\\n            if (arr[i].idx - 1 >= 0) IsMarked[arr[i].idx - 1] = true;\\n        }\\n    }\\n    free(arr);\\n    free(IsMarked);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3393440,
                "title": "easy-c-solution-priority-queue",
                "content": "\\n         typedef pair<int,int>pd;\\n    struct mycomp{\\n        constexpr bool operator()(\\n        pair<int,int> const &a, pair<int,int> const &b)\\n        {\\n        if(a.first==b.first)\\n        {\\n            return a.second>b.second;\\n             }\\n            return a.first>b.first;\\n            \\n        }\\n    };\\n    long long findScore(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>visited(n,0);\\n        if(n==1)\\n        {\\n            return arr[0];\\n        }\\n        \\n        \\n        priority_queue<pd,vector<pd>,mycomp>pq;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pq.push({arr[i],i});\\n            \\n        }\\n        long long sum=0;\\n        \\n        while(!pq.empty())\\n        {\\n            auto top=pq.top();\\n            if(visited[top.second]==0)\\n            {\\n                visited[top.second]=1;\\n                sum+=top.first;\\n                if(top.second==0)\\n                {\\n                      visited[top.second+1]=1;\\n                }\\n                else if(top.second==n-1)\\n                {\\n                      visited[top.second-1]=1;\\n                }\\n                else\\n                {\\n                     visited[top.second+1]=1;\\n                     visited[top.second-1]=1;\\n                }\\n                    \\n            }\\n            pq.pop();\\n            \\n            \\n        }\\n        return sum;\\n        \\n        \\n        \\n        \\n    }",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n         typedef pair<int,int>pd;\\n    struct mycomp{\\n        constexpr bool operator()(\\n        pair<int,int> const &a, pair<int,int> const &b)\\n        {\\n        if(a.first==b.first)\\n        {\\n            return a.second>b.second;\\n             }\\n            return a.first>b.first;\\n            \\n        }\\n    };\\n    long long findScore(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>visited(n,0);\\n        if(n==1)\\n        {\\n            return arr[0];\\n        }\\n        \\n        \\n        priority_queue<pd,vector<pd>,mycomp>pq;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pq.push({arr[i],i});\\n            \\n        }\\n        long long sum=0;\\n        \\n        while(!pq.empty())\\n        {\\n            auto top=pq.top();\\n            if(visited[top.second]==0)\\n            {\\n                visited[top.second]=1;\\n                sum+=top.first;\\n                if(top.second==0)\\n                {\\n                      visited[top.second+1]=1;\\n                }\\n                else if(top.second==n-1)\\n                {\\n                      visited[top.second-1]=1;\\n                }\\n                else\\n                {\\n                     visited[top.second+1]=1;\\n                     visited[top.second-1]=1;\\n                }\\n                    \\n            }\\n            pq.pop();\\n            \\n            \\n        }\\n        return sum;\\n        \\n        \\n        \\n        \\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 3388024,
                "title": "java-c-priorityqueue-ordered-set-easy-to-understand",
                "content": "# PriorityQueue (Min Heap)\\n---\\n## Java\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        PriorityQueue<int[]> minHeap=new PriorityQueue<>((a,b)->\\n        (a[0]==b[0])?a[1]-b[1]:a[0]-b[0]);\\n        for(int i=0;i<nums.length;i++){\\n            minHeap.add(new int[]{nums[i],i});\\n        }\\n        long res=0;\\n        while(!minHeap.isEmpty()){\\n            int[] arr=minHeap.poll();\\n            int index=arr[1];\\n            if(nums[index]>0){\\n                res+=nums[index];\\n                nums[index]*=-1;\\n                if(index>0||index<nums.length-1){\\n                    if(index>0&&nums[index-1]>0){\\n                        nums[index-1]*=-1;\\n                    }\\n                    if(index<nums.length-1&&nums[index+1]>0){\\n                        nums[index+1]*=-1;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n# Ordered Set\\n---\\n## C++\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        set<pair<int,int>> s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert({nums[i],i});\\n        }\\n        long long res=0;\\n        for(auto &pair: s){\\n            if(nums[pair.second]>0){\\n                res+=pair.first;\\n                nums[pair.second]=0;\\n                if(pair.second>0) nums[pair.second-1]=0;\\n                if(pair.second<nums.size()-1) nums[pair.second+1]=0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        PriorityQueue<int[]> minHeap=new PriorityQueue<>((a,b)->\\n        (a[0]==b[0])?a[1]-b[1]:a[0]-b[0]);\\n        for(int i=0;i<nums.length;i++){\\n            minHeap.add(new int[]{nums[i],i});\\n        }\\n        long res=0;\\n        while(!minHeap.isEmpty()){\\n            int[] arr=minHeap.poll();\\n            int index=arr[1];\\n            if(nums[index]>0){\\n                res+=nums[index];\\n                nums[index]*=-1;\\n                if(index>0||index<nums.length-1){\\n                    if(index>0&&nums[index-1]>0){\\n                        nums[index-1]*=-1;\\n                    }\\n                    if(index<nums.length-1&&nums[index+1]>0){\\n                        nums[index+1]*=-1;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        set<pair<int,int>> s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert({nums[i],i});\\n        }\\n        long long res=0;\\n        for(auto &pair: s){\\n            if(nums[pair.second]>0){\\n                res+=pair.first;\\n                nums[pair.second]=0;\\n                if(pair.second>0) nums[pair.second-1]=0;\\n                if(pair.second<nums.size()-1) nums[pair.second+1]=0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382620,
                "title": "c-simple-ordering-2-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is same for both of the following 2 approaches.\\n\\n1. We sort each items (in increasing order) by the value.\\n2. The first one is the smallest value. So we add the value to the answer.\\n3. And we also know the index of that smallest value. So we can remove the left and right item (of the current item) out of our consideration.\\n\\nIf we use the set, we can directly from the current,left,right items from the set.\\n\\nIf we use the vector and sort, we just change the value of each left,right items as 0. So if we just add the values from the beginning to the end, we get the answer.\\n\\nvector+sort is slightly faster in this case.\\n\\n- vector+sort : $$O(N log N)$$ for first sort. +$$O(N)$$ for iteration.\\n- set         : $$O(N log N)$$ for the set construction, +$$O(N)$$ for iteration. +$$O(N log N)$$ for the deletion of unnecessary left/right/current items.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N log N)$$\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n\\nUsing the set.\\n```\\nclass Solution {\\npublic:\\n    using PII=pair<int,int>;\\n    long long findScore(vector<int>& nums) {\\n        long long n=nums.size(), score=0LL;\\n        // val vs index\\n        set<PII> st;\\n        for(long long i=0; i<n; i++) st.insert({nums[i],i});\\n        while(!st.empty()){\\n            auto kv = *st.begin();\\n            score += kv.first;\\n            if(kv.second>0)   st.erase({nums[kv.second-1], kv.second-1});\\n            if(kv.second<n-1) st.erase({nums[kv.second+1], kv.second+1});\\n            st.erase(kv);\\n        }\\n        return score;\\n    }\\n};\\n```\\n\\nUsing the vector + sort\\n\\n```\\nclass Solution {\\npublic:\\n    using PII=pair<int,int>;\\n    long long findScore(vector<int>& nums) {\\n        long long n=nums.size(), score=0LL;\\n        // val vs index\\n        vector<PII> table;\\n        for(long long i=0; i<n; i++) table.push_back({nums[i],i});\\n        sort(begin(table), end(table));\\n        for(auto& kv : table){\\n            if(nums[kv.second]<=0) continue;\\n            score += kv.first;\\n            if(kv.second>0)   nums[kv.second-1]=0;\\n            if(kv.second<n-1) nums[kv.second+1]=0;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using PII=pair<int,int>;\\n    long long findScore(vector<int>& nums) {\\n        long long n=nums.size(), score=0LL;\\n        // val vs index\\n        set<PII> st;\\n        for(long long i=0; i<n; i++) st.insert({nums[i],i});\\n        while(!st.empty()){\\n            auto kv = *st.begin();\\n            score += kv.first;\\n            if(kv.second>0)   st.erase({nums[kv.second-1], kv.second-1});\\n            if(kv.second<n-1) st.erase({nums[kv.second+1], kv.second+1});\\n            st.erase(kv);\\n        }\\n        return score;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using PII=pair<int,int>;\\n    long long findScore(vector<int>& nums) {\\n        long long n=nums.size(), score=0LL;\\n        // val vs index\\n        vector<PII> table;\\n        for(long long i=0; i<n; i++) table.push_back({nums[i],i});\\n        sort(begin(table), end(table));\\n        for(auto& kv : table){\\n            if(nums[kv.second]<=0) continue;\\n            score += kv.first;\\n            if(kv.second>0)   nums[kv.second-1]=0;\\n            if(kv.second<n-1) nums[kv.second+1]=0;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378940,
                "title": "java-solution-easy-understand-and-intuitive",
                "content": "# Approach\\nWe can make a TreeMap to store num and its indexes in linkedlist.\\nThen we can traverse the TreeMap to check each index and mark them.\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        Map<Integer, List<Integer>> map = new TreeMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            List<Integer> list = map.getOrDefault(nums[i], new LinkedList());\\n            list.add(i);\\n            map.put(nums[i], list);\\n        }\\n        boolean[] mark = new boolean[nums.length];\\n        long res = 0;\\n        for (int key: map.keySet()) {\\n            for (int i: map.get(key)) {\\n                if (!mark[i]) {\\n                    res += key;\\n                    int pre = i-1, next = i+1;\\n                    if (pre >= 0 && pre < nums.length && !mark[pre]) {\\n                        mark[pre] = true;\\n                    }  \\n                    if (next >= 0 && next < nums.length && !mark[next]) {\\n                        mark[next] = true;\\n                    }                      \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        Map<Integer, List<Integer>> map = new TreeMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            List<Integer> list = map.getOrDefault(nums[i], new LinkedList());\\n            list.add(i);\\n            map.put(nums[i], list);\\n        }\\n        boolean[] mark = new boolean[nums.length];\\n        long res = 0;\\n        for (int key: map.keySet()) {\\n            for (int i: map.get(key)) {\\n                if (!mark[i]) {\\n                    res += key;\\n                    int pre = i-1, next = i+1;\\n                    if (pre >= 0 && pre < nums.length && !mark[pre]) {\\n                        mark[pre] = true;\\n                    }  \\n                    if (next >= 0 && next < nums.length && !mark[next]) {\\n                        mark[next] = true;\\n                    }                      \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364092,
                "title": "python-1-loop-easy",
                "content": "Do what\\'s asked.\\n```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        \"\"\"\\n        [2,1,3,4,5,2]\\n        (1,1) (2,0) -(2,5) -(3,2) (4,3) -(5,4)        \\n        \"\"\"        \\n        score = 0\\n        marked = set()\\n        \\n        for n, i in sorted([(n,i) for i,n in enumerate(nums)]):\\n            if i not in marked:\\n                marked.add(i)\\n                marked.add(i - 1)\\n                marked.add(i + 1)\\n                score += n\\n\\n        return score\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        \"\"\"\\n        [2,1,3,4,5,2]\\n        (1,1) (2,0) -(2,5) -(3,2) (4,3) -(5,4)        \\n        \"\"\"        \\n        score = 0\\n        marked = set()\\n        \\n        for n, i in sorted([(n,i) for i,n in enumerate(nums)]):\\n            if i not in marked:\\n                marked.add(i)\\n                marked.add(i - 1)\\n                marked.add(i + 1)\\n                score += n\\n\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363175,
                "title": "easy-c-priority-queue-min-heap-hashing-visited-or-not-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we have to find minimum number so we can use min heap data structure (priority_queue). To check a element is marked or not we will use a map of map<int,bool>.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialise the priority queue of pair<int,int> where first element of pair is element and second is index of it.Initial the ans as 0.Initialise map of index with value as boolean to check it is marked or not.\\nPush all value of num in priority queue of pair with indexes of element. Mark all index in map as true initiall.\\nRun a while loop until priority queue is not empty.\\nIn loop, If pq.top().second is visited then just do pq.pop to remove the marked element from priority queue. else increase the ans by pq.top().first and marked the index in map as visited and marked its adjacent indexes as visited.Check for corner index while marking adjacent.\\nAfter the completion of while loop just return the ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nN*log(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        long long ans=0;\\n        map<int,bool> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[i]=true;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        while(!pq.empty())\\n        {\\n            if(mp[pq.top().second]==false) \\n            {\\n                pq.pop();\\n            }\\n            else\\n            {\\n                ans+=pq.top().first;\\n                mp[pq.top().second]=false;\\n                int ind=pq.top().second;\\n                if(ind==0)\\n                {\\n                    mp[ind+1]=false;\\n             \\n                }\\n                else if(ind==n-1)\\n                {\\n                    mp[ind-1]=false;\\n                }\\n                else\\n                {\\n                    mp[ind+1]=false;\\n                    mp[ind-1]=false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        long long ans=0;\\n        map<int,bool> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[i]=true;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        while(!pq.empty())\\n        {\\n            if(mp[pq.top().second]==false) \\n            {\\n                pq.pop();\\n            }\\n            else\\n            {\\n                ans+=pq.top().first;\\n                mp[pq.top().second]=false;\\n                int ind=pq.top().second;\\n                if(ind==0)\\n                {\\n                    mp[ind+1]=false;\\n             \\n                }\\n                else if(ind==n-1)\\n                {\\n                    mp[ind-1]=false;\\n                }\\n                else\\n                {\\n                    mp[ind+1]=false;\\n                    mp[ind-1]=false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361230,
                "title": "java-priorityqueue-solution-with-comments",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(nlog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>((a,b) -> nums[a] ==  nums[b] ? a - b : nums[a] - nums[b] );\\n        \\n        for (int i =0 ;i < nums.length; i++) {\\n            queue.add(i);\\n        }\\n        \\n        // store visited indexes here.\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        long score = 0; \\n        while(queue.size() > 0)\\n        {\\n            var cur = queue.poll();\\n            if (visited.contains(cur)) {\\n                continue;\\n            }\\n            visited.add(cur);\\n            score+= nums[cur];\\n            if (cur > 0) {\\n                visited.add( cur-1);\\n            }\\n            if (cur < nums.length -1) {\\n                visited.add(cur+1);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>((a,b) -> nums[a] ==  nums[b] ? a - b : nums[a] - nums[b] );\\n        \\n        for (int i =0 ;i < nums.length; i++) {\\n            queue.add(i);\\n        }\\n        \\n        // store visited indexes here.\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        long score = 0; \\n        while(queue.size() > 0)\\n        {\\n            var cur = queue.poll();\\n            if (visited.contains(cur)) {\\n                continue;\\n            }\\n            visited.add(cur);\\n            score+= nums[cur];\\n            if (cur > 0) {\\n                visited.add( cur-1);\\n            }\\n            if (cur < nums.length -1) {\\n                visited.add(cur+1);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356826,
                "title": "simple-approach-min-priority-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n        long long  score=0;\\n        int n=nums.size();\\n        vector<int>mark(n,-1);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        while(!pq.empty())\\n        {\\n            int top=pq.top().first;\\n            int index=pq.top().second;\\n            pq.pop();\\n            if(mark[index]==-1)\\n            {\\n                score+=top;\\n                mark[index]=1;\\n                if(index-1>=0) mark[index-1]=1;\\n                if(index+1<n)  mark[index+1]=1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        \\n        long long  score=0;\\n        int n=nums.size();\\n        vector<int>mark(n,-1);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        while(!pq.empty())\\n        {\\n            int top=pq.top().first;\\n            int index=pq.top().second;\\n            pq.pop();\\n            if(mark[index]==-1)\\n            {\\n                score+=top;\\n                mark[index]=1;\\n                if(index-1>=0) mark[index-1]=1;\\n                if(index+1<n)  mark[index+1]=1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352832,
                "title": "priority-queue-easy-to-understand",
                "content": "Put everything into the priority queue. Bring out the smallest element one by one and mark the index of the three neighbouring elements with \"-1\".\\nJust add those numbers into the score whose index will not be marked with \"-1\". Return the score!\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        ll n=nums.size();\\n        priority_queue <pair<int,int>, \\n        vector<pair<int,int>>, \\n        greater<pair<int,int>>> pq;\\n        //val, index\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        ll score=0;\\n        while(!pq.empty()){\\n            pair<int,int> it=pq.top();\\n            pq.pop();\\n            if(nums[it.second]!=-1){\\n                score+=it.first;\\n                nums[it.second]=-1;\\n                if(it.second-1>=0) nums[it.second-1]=-1;\\n                if(it.second+1<n) nums[it.second+1]=-1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        ll n=nums.size();\\n        priority_queue <pair<int,int>, \\n        vector<pair<int,int>>, \\n        greater<pair<int,int>>> pq;\\n        //val, index\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n        }\\n        ll score=0;\\n        while(!pq.empty()){\\n            pair<int,int> it=pq.top();\\n            pq.pop();\\n            if(nums[it.second]!=-1){\\n                score+=it.first;\\n                nums[it.second]=-1;\\n                if(it.second-1>=0) nums[it.second-1]=-1;\\n                if(it.second+1<n) nums[it.second+1]=-1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351287,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue <pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++)\\n            pq.push({nums[i],i});\\n        long long ans = 0;\\n        int tmp;\\n        while(!pq.empty()){\\n            while(!pq.empty() && vis[pq.top().second])\\n                pq.pop(); \\n            if(pq.empty())\\n                break;\\n            tmp = pq.top().second;\\n            ans += pq.top().first;\\n            pq.pop();\\n            if(tmp > 0)\\n                vis[tmp-1] = 1;\\n            if(tmp < n-1)\\n                vis[tmp+1] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        int n = nums.size();\\n        priority_queue <pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++)\\n            pq.push({nums[i],i});\\n        long long ans = 0;\\n        int tmp;\\n        while(!pq.empty()){\\n            while(!pq.empty() && vis[pq.top().second])\\n                pq.pop(); \\n            if(pq.empty())\\n                break;\\n            tmp = pq.top().second;\\n            ans += pq.top().first;\\n            pq.pop();\\n            if(tmp > 0)\\n                vis[tmp-1] = 1;\\n            if(tmp < n-1)\\n                vis[tmp+1] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349074,
                "title": "using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long res=0;\\n        int n=nums.size();\\n        set<pair<int,int>>st;\\n        for(int i=0;i<nums.size();i++){\\n            st.insert({nums[i],i});\\n        }\\n        for(auto it:st){\\n            if(nums[it.second]!=0){\\n                res+=it.first;\\n                nums[it.second]=0;\\n                nums[max(it.second-1,0)]=0;\\n                nums[min(it.second+1,n-1)]=0;\\n\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long res=0;\\n        int n=nums.size();\\n        set<pair<int,int>>st;\\n        for(int i=0;i<nums.size();i++){\\n            st.insert({nums[i],i});\\n        }\\n        for(auto it:st){\\n            if(nums[it.second]!=0){\\n                res+=it.first;\\n                nums[it.second]=0;\\n                nums[max(it.second-1,0)]=0;\\n                nums[min(it.second+1,n-1)]=0;\\n\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348092,
                "title": "help-needed-curious-case",
                "content": "I found a very curious case. Kindly help me if you can explain what\\'s going on exactly.\\nIn my approach to this question, I inserted the pair {nums[index], index} into a min heap. Then did the steps as required.\\nIt took Nlogn time to create the heap as well as Nlogn time while popping elements out of it. Have a look at the code:\\n```\\nclass Solution {\\n    struct CompareScore {\\n    bool operator()(vector<int> p1, vector<int> p2)\\n    {\\n        if(p1[0] > p2[0]) return true;\\n        else if(p1[0] == p2[0] && p1[1]>p2[1]) return true;\\n        else return false;\\n    }\\n    };\\n    \\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<vector<int>, vector<vector<int>>, CompareScore> pq;\\n        for(int i=0; i<nums.size(); i++){\\n            pq.push({nums[i], i});\\n        }\\n        vector<int> curr(2,0);\\n        int number = 0, idx = 1;\\n        long long score = 0;\\n        while(!pq.empty()){\\n            curr = pq.top();\\n            pq.pop();\\n            if(nums[curr[idx]]>0){\\n                score += curr[number];\\n                //cout<<curr[number]<<\" \"<<curr[idx]<<endl;\\n                nums[curr[idx]] *= -1;\\n                if(curr[idx]+1<nums.size() && nums[curr[idx]+1]>0) \\n                    nums[curr[idx]+1] *= -1;\\n                if(curr[idx]-1>=0 && nums[curr[idx]-1]>0) \\n                    nums[curr[idx]-1] *= -1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```\\n\\nThis code gave me TLE. Although, according to me(correct me if I am wrong), Time complexity would be NLogn only. to be much more specific 2NlogN.\\n\\nWhile when I used a vector as a container and sorted it using STL function, it ran perfectly. I get it that it took NlogN time to sort it and then while accessing, it took order N only, but the creation of the array itself took order N time. So essentially total complexity would be NlogN + 2N. Have a look at the code below:\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        vector<vector<int>> pq;\\n        for(int i=0; i<nums.size(); i++){\\n            pq.push_back({nums[i], i});\\n        }\\n        sort(pq.begin(), pq.end());\\n        vector<int> curr(2,0);\\n        int number = 0, idx = 1;\\n        long long score = 0;\\n        for(int i=0; i<pq.size(); i++){\\n            curr = pq[i];\\n            if(nums[curr[idx]]>0){\\n                score += curr[number];\\n                //cout<<curr[number]<<\" \"<<curr[idx]<<endl;\\n                nums[curr[idx]] *= -1;\\n                if(curr[idx]+1<nums.size() && nums[curr[idx]+1]>0) \\n                    nums[curr[idx]+1] *= -1;\\n                if(curr[idx]-1>=0 && nums[curr[idx]-1]>0) \\n                    nums[curr[idx]-1] *= -1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```\\n\\nCan someone please help me understanding why one code ran perfectly while other one gave TLE?\\n\\nThanks already.",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    struct CompareScore {\\n    bool operator()(vector<int> p1, vector<int> p2)\\n    {\\n        if(p1[0] > p2[0]) return true;\\n        else if(p1[0] == p2[0] && p1[1]>p2[1]) return true;\\n        else return false;\\n    }\\n    };\\n    \\npublic:\\n    long long findScore(vector<int>& nums) {\\n        priority_queue<vector<int>, vector<vector<int>>, CompareScore> pq;\\n        for(int i=0; i<nums.size(); i++){\\n            pq.push({nums[i], i});\\n        }\\n        vector<int> curr(2,0);\\n        int number = 0, idx = 1;\\n        long long score = 0;\\n        while(!pq.empty()){\\n            curr = pq.top();\\n            pq.pop();\\n            if(nums[curr[idx]]>0){\\n                score += curr[number];\\n                //cout<<curr[number]<<\" \"<<curr[idx]<<endl;\\n                nums[curr[idx]] *= -1;\\n                if(curr[idx]+1<nums.size() && nums[curr[idx]+1]>0) \\n                    nums[curr[idx]+1] *= -1;\\n                if(curr[idx]-1>=0 && nums[curr[idx]-1]>0) \\n                    nums[curr[idx]-1] *= -1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        vector<vector<int>> pq;\\n        for(int i=0; i<nums.size(); i++){\\n            pq.push_back({nums[i], i});\\n        }\\n        sort(pq.begin(), pq.end());\\n        vector<int> curr(2,0);\\n        int number = 0, idx = 1;\\n        long long score = 0;\\n        for(int i=0; i<pq.size(); i++){\\n            curr = pq[i];\\n            if(nums[curr[idx]]>0){\\n                score += curr[number];\\n                //cout<<curr[number]<<\" \"<<curr[idx]<<endl;\\n                nums[curr[idx]] *= -1;\\n                if(curr[idx]+1<nums.size() && nums[curr[idx]+1]>0) \\n                    nums[curr[idx]+1] *= -1;\\n                if(curr[idx]-1>=0 && nums[curr[idx]-1]>0) \\n                    nums[curr[idx]-1] *= -1;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3346893,
                "title": "two-code-whith-simple-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(nlong n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans = 0;\\n        set<pair<int, int>> st;\\n        for(int i = 0; i < nums.size(); ++i){ st.insert({nums[i], i}); }\\n        for(auto s: st){\\n            if(nums[s.second]) {\\n                nums[s.second] = 0;\\n                if(s.second - 1 >= 0) nums[s.second - 1] = 0;\\n                if(s.second + 1 < nums.size()) nums[s.second + 1] = 0;\\n                ans += s.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        set<pair<int,int>> s;\\n        int n=nums.size(),i;\\n        long long ans=0;\\n        for(i=0;i<n;i++)s.insert(make_pair(nums[i],i));\\n        while(!s.empty())\\n        {\\n            ans+=s.begin()->first;\\n            i=s.begin()->second;\\n            s.erase(s.begin());\\n            if(i+1<n)s.erase(make_pair(nums[i+1],i+1));\\n            if(i-1 >=0)s.erase(make_pair(nums[i-1],i-1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        long long ans = 0;\\n        set<pair<int, int>> st;\\n        for(int i = 0; i < nums.size(); ++i){ st.insert({nums[i], i}); }\\n        for(auto s: st){\\n            if(nums[s.second]) {\\n                nums[s.second] = 0;\\n                if(s.second - 1 >= 0) nums[s.second - 1] = 0;\\n                if(s.second + 1 < nums.size()) nums[s.second + 1] = 0;\\n                ans += s.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        set<pair<int,int>> s;\\n        int n=nums.size(),i;\\n        long long ans=0;\\n        for(i=0;i<n;i++)s.insert(make_pair(nums[i],i));\\n        while(!s.empty())\\n        {\\n            ans+=s.begin()->first;\\n            i=s.begin()->second;\\n            s.erase(s.begin());\\n            if(i+1<n)s.erase(make_pair(nums[i+1],i+1));\\n            if(i-1 >=0)s.erase(make_pair(nums[i-1],i-1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346256,
                "title": "c-easy-map-and-visited-array-solution",
                "content": "# Intuition\\n--Keep a map of all the array elements as key-array element,        value-vector<int> of all the locations at which the element is present\\n--keep a visited array \\n--traverse through the map\\'s value and mark visited the location, location-1,location+1, and add to ans the map\\'s key.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        map<int,vector<int>> mp;\\n        long long ans=0;\\n        vector<int> visited(nums.size(),0);\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]].push_back(i);\\n        for(auto x:mp)\\n        {\\n            for(auto a:x.second)\\n            {\\n                if(visited[a]==0)\\n                {\\n                    visited[a]=1;\\n                    if(a-1>=0)\\n                        visited[a-1]=1;\\n                    if(a+1<nums.size())\\n                        visited[a+1]=1;\\n                    ans+=nums[a];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findScore(vector<int>& nums) {\\n        map<int,vector<int>> mp;\\n        long long ans=0;\\n        vector<int> visited(nums.size(),0);\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]].push_back(i);\\n        for(auto x:mp)\\n        {\\n            for(auto a:x.second)\\n            {\\n                if(visited[a]==0)\\n                {\\n                    visited[a]=1;\\n                    if(a-1>=0)\\n                        visited[a-1]=1;\\n                    if(a+1<nums.size())\\n                        visited[a+1]=1;\\n                    ans+=nums[a];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343085,
                "title": "java-code-beats-96-storage-beats-91-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long score = 0;\\n        int [] visited=new int[nums.length];\\n        int [][] arr = new int[nums.length][2];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=i;\\n\\n        }\\n        // Collections.sort(ls);\\n        Arrays.sort(arr,(a,b)->a[0]-b[0]);\\n        for(int i =0;i<nums.length;i++){\\n            if(visited[arr[i][1]]==0){\\n                visited[arr[i][1]]=1;\\n                score=score+arr[i][0];\\n                if(arr[i][1]-1>=0){\\n                    visited[arr[i][1]-1]=1;\\n                }\\n                if(arr[i][1]+1<nums.length){\\n                    visited[arr[i][1]+1]=1;\\n                }\\n\\n            }\\n        }\\n        // System.out.println(Arrays.deepToString(arr));\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long findScore(int[] nums) {\\n        long score = 0;\\n        int [] visited=new int[nums.length];\\n        int [][] arr = new int[nums.length][2];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=i;\\n\\n        }\\n        // Collections.sort(ls);\\n        Arrays.sort(arr,(a,b)->a[0]-b[0]);\\n        for(int i =0;i<nums.length;i++){\\n            if(visited[arr[i][1]]==0){\\n                visited[arr[i][1]]=1;\\n                score=score+arr[i][0];\\n                if(arr[i][1]-1>=0){\\n                    visited[arr[i][1]-1]=1;\\n                }\\n                if(arr[i][1]+1<nums.length){\\n                    visited[arr[i][1]+1]=1;\\n                }\\n\\n            }\\n        }\\n        // System.out.println(Arrays.deepToString(arr));\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342793,
                "title": "min-priority-queue-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        int n=nums.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            q.push({nums[x],x});\\n        }\\n        long long score=0;\\n        while(!q.empty())\\n        {\\n            int val=q.top().first;\\n            int pos=q.top().second;\\n            if(nums[pos]!=-1)\\n            {\\n                score+=(long long)val;\\n                nums[pos]=-1;\\n                if(pos+1<n) nums[pos+1]=-1;\\n                if(pos-1>=0) nums[pos-1]=-1;\\n            }\\n            q.pop();\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long findScore(vector<int>& nums) \\n    {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        int n=nums.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            q.push({nums[x],x});\\n        }\\n        long long score=0;\\n        while(!q.empty())\\n        {\\n            int val=q.top().first;\\n            int pos=q.top().second;\\n            if(nums[pos]!=-1)\\n            {\\n                score+=(long long)val;\\n                nums[pos]=-1;\\n                if(pos+1<n) nums[pos+1]=-1;\\n                if(pos-1>=0) nums[pos-1]=-1;\\n            }\\n            q.pop();\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1836372,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Expose all cheaters of the contest of this question using my link:\\nhttps://leetcode.com/discuss/feedback/3312685/Exposing-Q3-cheaters-of-Biweekly-100"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "how you can be sure about that !"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "Can someone explain why this input-[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42] expects output as 212 and not 170 , including my trace below for understanding -- \\nFormat: min unmarked element -- array in each iteration after removing the marked elements -- score \\n\\n3 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 22, 3, 42, 42] 3 \\n8 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 11\\n10 [10, 44, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 21\\n16 [30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 37\\n17 [30, 17, 38, 41, 45, 45, 34, 30, 42] 54\\n30 [41, 45, 45, 34, 30, 42] 84\\n41 [41, 45, 45] 125\\n45 [45] 170"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@ma5termiind](/ma5termiind) had the same problem, thanks for clarifying.  I think the problem statement should include this/make it more clear"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@strukturen](/strukturen) Got it , thanks \nJust for other people who are stuck with the same issue , we don't have to pop the element as when we pop, the elements get shifted and become neighbours when they are not so. \nFor eg- when we pick 30 , 42 is not actually the neighbour of 30 but since we have popped some elements in between it becomes one which alters the result"
                    },
                    {
                        "username": "strukturen",
                        "content": "You have to mark every neighbor of the current minimum element. When you choose 30 you should not mark 42 because it is not a neighbor of 30. "
                    },
                    {
                        "username": "Antarab",
                        "content": "Yes- same doubt"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This question was asked on Zscaler Assessment Test for Summer Hiring.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Create a priority queue to store the unmarked integers in the array. The priority queue will be sorted in ascending order of the integers. In case of a tie, the one with the smallest index is selected.\\n\\n- Initialize a boolean array \"seen\" of size n (n = length of nums) to keep track of marked elements. Mark all elements as \"false\".\\n\\n- Initialize a variable \"score\" to 0.\\n\\n- While the priority queue is not empty, repeat the following steps:\\na. Remove the element with the smallest value from the priority queue.\\nb. Check if the element is already marked. If it is, move to the next element.\\nc. If the element is not marked, add its value to the score.\\nd. Mark the element as seen by setting the corresponding index in the \"seen\" array to true.\\ne. If the element has adjacent elements, mark them as seen too.\\n\\n- Return the score.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the code link for reference:-)**\\nhttps://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/solutions/3457725/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Antarab",
                        "content": "class Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        s=0\\n        while len(nums)>0:\\n            m= min(nums)\\n            idx= nums.index(m)\\n\\n            s=s+m\\n            try:\\n                nums.pop(idx+1)\\n            except:\\n                pass\\n            nums.pop(idx)\\n            try:\\n                if idx>0:\\n                    nums.pop(idx-1)\\n            except:\\n                pass\\n        return s\\n\\nnums =\\n[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42]\\n\\nwhy its 212 not 170\\n\\n3+10+16+17+30+41+45 ???"
                    },
                    {
                        "username": "TB09",
                        "content": "You shouldn\\'t be popping elements from nums which will cause unmarked elements to be marked which they don\\'t belong to be neighbour index of current minimum "
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "def findScore(self, nums: List[int]) -> int:\\n        ans = []\\n        while nums:\\n            mini = min(nums)\\n            idx = nums.index(mini)\\n            ans.append(mini)\\n            if idx + 1 < len(nums):\\n                nums.pop(idx+1)\\n            nums.pop(idx)\\n            if idx - 1 >= 0:\\n                nums.pop(idx-1)\\n        return sum(ans)\\nCan some one please tell me whats the error here? why it gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1836491,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Expose all cheaters of the contest of this question using my link:\\nhttps://leetcode.com/discuss/feedback/3312685/Exposing-Q3-cheaters-of-Biweekly-100"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "how you can be sure about that !"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "Can someone explain why this input-[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42] expects output as 212 and not 170 , including my trace below for understanding -- \\nFormat: min unmarked element -- array in each iteration after removing the marked elements -- score \\n\\n3 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 22, 3, 42, 42] 3 \\n8 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 11\\n10 [10, 44, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 21\\n16 [30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 37\\n17 [30, 17, 38, 41, 45, 45, 34, 30, 42] 54\\n30 [41, 45, 45, 34, 30, 42] 84\\n41 [41, 45, 45] 125\\n45 [45] 170"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@ma5termiind](/ma5termiind) had the same problem, thanks for clarifying.  I think the problem statement should include this/make it more clear"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@strukturen](/strukturen) Got it , thanks \nJust for other people who are stuck with the same issue , we don't have to pop the element as when we pop, the elements get shifted and become neighbours when they are not so. \nFor eg- when we pick 30 , 42 is not actually the neighbour of 30 but since we have popped some elements in between it becomes one which alters the result"
                    },
                    {
                        "username": "strukturen",
                        "content": "You have to mark every neighbor of the current minimum element. When you choose 30 you should not mark 42 because it is not a neighbor of 30. "
                    },
                    {
                        "username": "Antarab",
                        "content": "Yes- same doubt"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This question was asked on Zscaler Assessment Test for Summer Hiring.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Create a priority queue to store the unmarked integers in the array. The priority queue will be sorted in ascending order of the integers. In case of a tie, the one with the smallest index is selected.\\n\\n- Initialize a boolean array \"seen\" of size n (n = length of nums) to keep track of marked elements. Mark all elements as \"false\".\\n\\n- Initialize a variable \"score\" to 0.\\n\\n- While the priority queue is not empty, repeat the following steps:\\na. Remove the element with the smallest value from the priority queue.\\nb. Check if the element is already marked. If it is, move to the next element.\\nc. If the element is not marked, add its value to the score.\\nd. Mark the element as seen by setting the corresponding index in the \"seen\" array to true.\\ne. If the element has adjacent elements, mark them as seen too.\\n\\n- Return the score.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the code link for reference:-)**\\nhttps://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/solutions/3457725/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Antarab",
                        "content": "class Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        s=0\\n        while len(nums)>0:\\n            m= min(nums)\\n            idx= nums.index(m)\\n\\n            s=s+m\\n            try:\\n                nums.pop(idx+1)\\n            except:\\n                pass\\n            nums.pop(idx)\\n            try:\\n                if idx>0:\\n                    nums.pop(idx-1)\\n            except:\\n                pass\\n        return s\\n\\nnums =\\n[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42]\\n\\nwhy its 212 not 170\\n\\n3+10+16+17+30+41+45 ???"
                    },
                    {
                        "username": "TB09",
                        "content": "You shouldn\\'t be popping elements from nums which will cause unmarked elements to be marked which they don\\'t belong to be neighbour index of current minimum "
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "def findScore(self, nums: List[int]) -> int:\\n        ans = []\\n        while nums:\\n            mini = min(nums)\\n            idx = nums.index(mini)\\n            ans.append(mini)\\n            if idx + 1 < len(nums):\\n                nums.pop(idx+1)\\n            nums.pop(idx)\\n            if idx - 1 >= 0:\\n                nums.pop(idx-1)\\n        return sum(ans)\\nCan some one please tell me whats the error here? why it gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1904612,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Expose all cheaters of the contest of this question using my link:\\nhttps://leetcode.com/discuss/feedback/3312685/Exposing-Q3-cheaters-of-Biweekly-100"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "how you can be sure about that !"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "Can someone explain why this input-[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42] expects output as 212 and not 170 , including my trace below for understanding -- \\nFormat: min unmarked element -- array in each iteration after removing the marked elements -- score \\n\\n3 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 22, 3, 42, 42] 3 \\n8 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 11\\n10 [10, 44, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 21\\n16 [30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 37\\n17 [30, 17, 38, 41, 45, 45, 34, 30, 42] 54\\n30 [41, 45, 45, 34, 30, 42] 84\\n41 [41, 45, 45] 125\\n45 [45] 170"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@ma5termiind](/ma5termiind) had the same problem, thanks for clarifying.  I think the problem statement should include this/make it more clear"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@strukturen](/strukturen) Got it , thanks \nJust for other people who are stuck with the same issue , we don't have to pop the element as when we pop, the elements get shifted and become neighbours when they are not so. \nFor eg- when we pick 30 , 42 is not actually the neighbour of 30 but since we have popped some elements in between it becomes one which alters the result"
                    },
                    {
                        "username": "strukturen",
                        "content": "You have to mark every neighbor of the current minimum element. When you choose 30 you should not mark 42 because it is not a neighbor of 30. "
                    },
                    {
                        "username": "Antarab",
                        "content": "Yes- same doubt"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This question was asked on Zscaler Assessment Test for Summer Hiring.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Create a priority queue to store the unmarked integers in the array. The priority queue will be sorted in ascending order of the integers. In case of a tie, the one with the smallest index is selected.\\n\\n- Initialize a boolean array \"seen\" of size n (n = length of nums) to keep track of marked elements. Mark all elements as \"false\".\\n\\n- Initialize a variable \"score\" to 0.\\n\\n- While the priority queue is not empty, repeat the following steps:\\na. Remove the element with the smallest value from the priority queue.\\nb. Check if the element is already marked. If it is, move to the next element.\\nc. If the element is not marked, add its value to the score.\\nd. Mark the element as seen by setting the corresponding index in the \"seen\" array to true.\\ne. If the element has adjacent elements, mark them as seen too.\\n\\n- Return the score.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the code link for reference:-)**\\nhttps://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/solutions/3457725/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Antarab",
                        "content": "class Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        s=0\\n        while len(nums)>0:\\n            m= min(nums)\\n            idx= nums.index(m)\\n\\n            s=s+m\\n            try:\\n                nums.pop(idx+1)\\n            except:\\n                pass\\n            nums.pop(idx)\\n            try:\\n                if idx>0:\\n                    nums.pop(idx-1)\\n            except:\\n                pass\\n        return s\\n\\nnums =\\n[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42]\\n\\nwhy its 212 not 170\\n\\n3+10+16+17+30+41+45 ???"
                    },
                    {
                        "username": "TB09",
                        "content": "You shouldn\\'t be popping elements from nums which will cause unmarked elements to be marked which they don\\'t belong to be neighbour index of current minimum "
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "def findScore(self, nums: List[int]) -> int:\\n        ans = []\\n        while nums:\\n            mini = min(nums)\\n            idx = nums.index(mini)\\n            ans.append(mini)\\n            if idx + 1 < len(nums):\\n                nums.pop(idx+1)\\n            nums.pop(idx)\\n            if idx - 1 >= 0:\\n                nums.pop(idx-1)\\n        return sum(ans)\\nCan some one please tell me whats the error here? why it gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1874551,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Expose all cheaters of the contest of this question using my link:\\nhttps://leetcode.com/discuss/feedback/3312685/Exposing-Q3-cheaters-of-Biweekly-100"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "how you can be sure about that !"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "Can someone explain why this input-[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42] expects output as 212 and not 170 , including my trace below for understanding -- \\nFormat: min unmarked element -- array in each iteration after removing the marked elements -- score \\n\\n3 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 22, 3, 42, 42] 3 \\n8 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 11\\n10 [10, 44, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 21\\n16 [30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 37\\n17 [30, 17, 38, 41, 45, 45, 34, 30, 42] 54\\n30 [41, 45, 45, 34, 30, 42] 84\\n41 [41, 45, 45] 125\\n45 [45] 170"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@ma5termiind](/ma5termiind) had the same problem, thanks for clarifying.  I think the problem statement should include this/make it more clear"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@strukturen](/strukturen) Got it , thanks \nJust for other people who are stuck with the same issue , we don't have to pop the element as when we pop, the elements get shifted and become neighbours when they are not so. \nFor eg- when we pick 30 , 42 is not actually the neighbour of 30 but since we have popped some elements in between it becomes one which alters the result"
                    },
                    {
                        "username": "strukturen",
                        "content": "You have to mark every neighbor of the current minimum element. When you choose 30 you should not mark 42 because it is not a neighbor of 30. "
                    },
                    {
                        "username": "Antarab",
                        "content": "Yes- same doubt"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This question was asked on Zscaler Assessment Test for Summer Hiring.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Create a priority queue to store the unmarked integers in the array. The priority queue will be sorted in ascending order of the integers. In case of a tie, the one with the smallest index is selected.\\n\\n- Initialize a boolean array \"seen\" of size n (n = length of nums) to keep track of marked elements. Mark all elements as \"false\".\\n\\n- Initialize a variable \"score\" to 0.\\n\\n- While the priority queue is not empty, repeat the following steps:\\na. Remove the element with the smallest value from the priority queue.\\nb. Check if the element is already marked. If it is, move to the next element.\\nc. If the element is not marked, add its value to the score.\\nd. Mark the element as seen by setting the corresponding index in the \"seen\" array to true.\\ne. If the element has adjacent elements, mark them as seen too.\\n\\n- Return the score.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the code link for reference:-)**\\nhttps://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/solutions/3457725/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Antarab",
                        "content": "class Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        s=0\\n        while len(nums)>0:\\n            m= min(nums)\\n            idx= nums.index(m)\\n\\n            s=s+m\\n            try:\\n                nums.pop(idx+1)\\n            except:\\n                pass\\n            nums.pop(idx)\\n            try:\\n                if idx>0:\\n                    nums.pop(idx-1)\\n            except:\\n                pass\\n        return s\\n\\nnums =\\n[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42]\\n\\nwhy its 212 not 170\\n\\n3+10+16+17+30+41+45 ???"
                    },
                    {
                        "username": "TB09",
                        "content": "You shouldn\\'t be popping elements from nums which will cause unmarked elements to be marked which they don\\'t belong to be neighbour index of current minimum "
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "def findScore(self, nums: List[int]) -> int:\\n        ans = []\\n        while nums:\\n            mini = min(nums)\\n            idx = nums.index(mini)\\n            ans.append(mini)\\n            if idx + 1 < len(nums):\\n                nums.pop(idx+1)\\n            nums.pop(idx)\\n            if idx - 1 >= 0:\\n                nums.pop(idx-1)\\n        return sum(ans)\\nCan some one please tell me whats the error here? why it gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1836614,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Expose all cheaters of the contest of this question using my link:\\nhttps://leetcode.com/discuss/feedback/3312685/Exposing-Q3-cheaters-of-Biweekly-100"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "how you can be sure about that !"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "Can someone explain why this input-[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42] expects output as 212 and not 170 , including my trace below for understanding -- \\nFormat: min unmarked element -- array in each iteration after removing the marked elements -- score \\n\\n3 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 22, 3, 42, 42] 3 \\n8 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 11\\n10 [10, 44, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 21\\n16 [30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 37\\n17 [30, 17, 38, 41, 45, 45, 34, 30, 42] 54\\n30 [41, 45, 45, 34, 30, 42] 84\\n41 [41, 45, 45] 125\\n45 [45] 170"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@ma5termiind](/ma5termiind) had the same problem, thanks for clarifying.  I think the problem statement should include this/make it more clear"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@strukturen](/strukturen) Got it , thanks \nJust for other people who are stuck with the same issue , we don't have to pop the element as when we pop, the elements get shifted and become neighbours when they are not so. \nFor eg- when we pick 30 , 42 is not actually the neighbour of 30 but since we have popped some elements in between it becomes one which alters the result"
                    },
                    {
                        "username": "strukturen",
                        "content": "You have to mark every neighbor of the current minimum element. When you choose 30 you should not mark 42 because it is not a neighbor of 30. "
                    },
                    {
                        "username": "Antarab",
                        "content": "Yes- same doubt"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This question was asked on Zscaler Assessment Test for Summer Hiring.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Create a priority queue to store the unmarked integers in the array. The priority queue will be sorted in ascending order of the integers. In case of a tie, the one with the smallest index is selected.\\n\\n- Initialize a boolean array \"seen\" of size n (n = length of nums) to keep track of marked elements. Mark all elements as \"false\".\\n\\n- Initialize a variable \"score\" to 0.\\n\\n- While the priority queue is not empty, repeat the following steps:\\na. Remove the element with the smallest value from the priority queue.\\nb. Check if the element is already marked. If it is, move to the next element.\\nc. If the element is not marked, add its value to the score.\\nd. Mark the element as seen by setting the corresponding index in the \"seen\" array to true.\\ne. If the element has adjacent elements, mark them as seen too.\\n\\n- Return the score.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the code link for reference:-)**\\nhttps://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/solutions/3457725/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Antarab",
                        "content": "class Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        s=0\\n        while len(nums)>0:\\n            m= min(nums)\\n            idx= nums.index(m)\\n\\n            s=s+m\\n            try:\\n                nums.pop(idx+1)\\n            except:\\n                pass\\n            nums.pop(idx)\\n            try:\\n                if idx>0:\\n                    nums.pop(idx-1)\\n            except:\\n                pass\\n        return s\\n\\nnums =\\n[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42]\\n\\nwhy its 212 not 170\\n\\n3+10+16+17+30+41+45 ???"
                    },
                    {
                        "username": "TB09",
                        "content": "You shouldn\\'t be popping elements from nums which will cause unmarked elements to be marked which they don\\'t belong to be neighbour index of current minimum "
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "def findScore(self, nums: List[int]) -> int:\\n        ans = []\\n        while nums:\\n            mini = min(nums)\\n            idx = nums.index(mini)\\n            ans.append(mini)\\n            if idx + 1 < len(nums):\\n                nums.pop(idx+1)\\n            nums.pop(idx)\\n            if idx - 1 >= 0:\\n                nums.pop(idx-1)\\n        return sum(ans)\\nCan some one please tell me whats the error here? why it gives wrong ans?"
                    }
                ]
            },
            {
                "id": 1836499,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Expose all cheaters of the contest of this question using my link:\\nhttps://leetcode.com/discuss/feedback/3312685/Exposing-Q3-cheaters-of-Biweekly-100"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "how you can be sure about that !"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "Can someone explain why this input-[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42] expects output as 212 and not 170 , including my trace below for understanding -- \\nFormat: min unmarked element -- array in each iteration after removing the marked elements -- score \\n\\n3 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 22, 3, 42, 42] 3 \\n8 [10, 44, 10, 8, 48, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 11\\n10 [10, 44, 30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 21\\n16 [30, 17, 38, 41, 27, 16, 33, 45, 45, 34, 30, 42] 37\\n17 [30, 17, 38, 41, 45, 45, 34, 30, 42] 54\\n30 [41, 45, 45, 34, 30, 42] 84\\n41 [41, 45, 45] 125\\n45 [45] 170"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@ma5termiind](/ma5termiind) had the same problem, thanks for clarifying.  I think the problem statement should include this/make it more clear"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "[@strukturen](/strukturen) Got it , thanks \nJust for other people who are stuck with the same issue , we don't have to pop the element as when we pop, the elements get shifted and become neighbours when they are not so. \nFor eg- when we pick 30 , 42 is not actually the neighbour of 30 but since we have popped some elements in between it becomes one which alters the result"
                    },
                    {
                        "username": "strukturen",
                        "content": "You have to mark every neighbor of the current minimum element. When you choose 30 you should not mark 42 because it is not a neighbor of 30. "
                    },
                    {
                        "username": "Antarab",
                        "content": "Yes- same doubt"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**This question was asked on Zscaler Assessment Test for Summer Hiring.**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Create a priority queue to store the unmarked integers in the array. The priority queue will be sorted in ascending order of the integers. In case of a tie, the one with the smallest index is selected.\\n\\n- Initialize a boolean array \"seen\" of size n (n = length of nums) to keep track of marked elements. Mark all elements as \"false\".\\n\\n- Initialize a variable \"score\" to 0.\\n\\n- While the priority queue is not empty, repeat the following steps:\\na. Remove the element with the smallest value from the priority queue.\\nb. Check if the element is already marked. If it is, move to the next element.\\nc. If the element is not marked, add its value to the score.\\nd. Mark the element as seen by setting the corresponding index in the \"seen\" array to true.\\ne. If the element has adjacent elements, mark them as seen too.\\n\\n- Return the score.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the code link for reference:-)**\\nhttps://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/solutions/3457725/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Antarab",
                        "content": "class Solution:\\n    def findScore(self, nums: List[int]) -> int:\\n        s=0\\n        while len(nums)>0:\\n            m= min(nums)\\n            idx= nums.index(m)\\n\\n            s=s+m\\n            try:\\n                nums.pop(idx+1)\\n            except:\\n                pass\\n            nums.pop(idx)\\n            try:\\n                if idx>0:\\n                    nums.pop(idx-1)\\n            except:\\n                pass\\n        return s\\n\\nnums =\\n[10,44,10,8,48,30,17,38,41,27,16,33,45,45,34,30,22,3,42,42]\\n\\nwhy its 212 not 170\\n\\n3+10+16+17+30+41+45 ???"
                    },
                    {
                        "username": "TB09",
                        "content": "You shouldn\\'t be popping elements from nums which will cause unmarked elements to be marked which they don\\'t belong to be neighbour index of current minimum "
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "def findScore(self, nums: List[int]) -> int:\\n        ans = []\\n        while nums:\\n            mini = min(nums)\\n            idx = nums.index(mini)\\n            ans.append(mini)\\n            if idx + 1 < len(nums):\\n                nums.pop(idx+1)\\n            nums.pop(idx)\\n            if idx - 1 >= 0:\\n                nums.pop(idx-1)\\n        return sum(ans)\\nCan some one please tell me whats the error here? why it gives wrong ans?"
                    }
                ]
            }
        ]
    }
]