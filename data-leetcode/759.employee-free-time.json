[
    {
        "title": "Pyramid Transition Matrix",
        "question_content": "You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains one less block than the row beneath it and is centered on top.\nTo make the pyramid aesthetically pleasing, there are only specific triangular patterns that are allowed. A triangular pattern consists of a single block stacked on top of two blocks. The patterns are given&nbsp;as a list of&nbsp;three-letter strings allowed, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block.\n\n\tFor example, \"ABC\" represents a triangular pattern with a 'C' block stacked on top of an 'A' (left) and 'B' (right) block. Note that this is different from \"BAC\" where 'B' is on the left bottom and 'A' is on the right bottom.\n\nYou start with a bottom row of blocks bottom, given as a single string, that you must use as the base of the pyramid.\nGiven bottom and allowed, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in allowed, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: bottom = \"BCD\", allowed = [\"BCC\",\"CDE\",\"CEA\",\"FFF\"]\nOutput: true\nExplanation: The allowed triangular patterns are shown on the right.\nStarting from the bottom (level 3), we can build \"CE\" on level 2 and then build \"A\" on level 1.\nThere are three triangular patterns in the pyramid, which are \"BCC\", \"CDE\", and \"CEA\". All are allowed.\n\nExample 2:\n\nInput: bottom = \"AAAA\", allowed = [\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\nOutput: false\nExplanation: The allowed triangular patterns are shown on the right.\nStarting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1.\n\n&nbsp;\nConstraints:\n\n\t2 <= bottom.length <= 6\n\t0 <= allowed.length <= 216\n\tallowed[i].length == 3\n\tThe letters in all input strings are from the set {'A', 'B', 'C', 'D', 'E', 'F'}.\n\tAll the values of allowed are unique.",
        "solutions": [
            {
                "id": 113054,
                "title": "java-solution-map-backtracking",
                "content": "A little long, but very straightforward.\\n```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : allowed) {\\n            String key = s.substring(0,2);\\n            if (!map.containsKey(key)) map.put(key, new ArrayList<String>());\\n            map.get(key).add(s.substring(2));\\n        }\\n        \\n        return helper(bottom, map);\\n    }\\n    \\n    private boolean helper(String bottom, Map<String, List<String>> map) {\\n        if(bottom.length() == 1) return true;\\n        for (int i = 0; i<bottom.length()-1; i++) {\\n            if (!map.containsKey(bottom.substring(i,i+2))) return false;\\n        }\\n        List<String> ls = new ArrayList<>();\\n        getList(bottom, 0, new StringBuilder(), ls, map);\\n        for (String s : ls) {\\n            if (helper(s, map)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private void getList(String bottom, int idx, StringBuilder sb, List<String> ls, Map<String, List<String>> map) {\\n        if (idx == bottom.length() - 1) {\\n            ls.add(sb.toString());\\n            return;\\n        }\\n        for (String s : map.get(bottom.substring(idx, idx+2))) {\\n            sb.append(s);\\n            getList(bottom, idx + 1, sb, ls, map);\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : allowed) {\\n            String key = s.substring(0,2);\\n            if (!map.containsKey(key)) map.put(key, new ArrayList<String>());\\n            map.get(key).add(s.substring(2));\\n        }\\n        \\n        return helper(bottom, map);\\n    }\\n    \\n    private boolean helper(String bottom, Map<String, List<String>> map) {\\n        if(bottom.length() == 1) return true;\\n        for (int i = 0; i<bottom.length()-1; i++) {\\n            if (!map.containsKey(bottom.substring(i,i+2))) return false;\\n        }\\n        List<String> ls = new ArrayList<>();\\n        getList(bottom, 0, new StringBuilder(), ls, map);\\n        for (String s : ls) {\\n            if (helper(s, map)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private void getList(String bottom, int idx, StringBuilder sb, List<String> ls, Map<String, List<String>> map) {\\n        if (idx == bottom.length() - 1) {\\n            ls.add(sb.toString());\\n            return;\\n        }\\n        for (String s : map.get(bottom.substring(idx, idx+2))) {\\n            sb.append(s);\\n            getList(bottom, idx + 1, sb, ls, map);\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170870,
                "title": "concise-c-recursive-solution-10-line",
                "content": "10 line C++ recursive solution\\n```C++\\nclass Solution {\\npublic:\\n  bool pyramidTransition(string bottom, vector<string>& allowed) {\\n    unordered_map<string, vector<char>> m;\\n    for(auto& s:allowed) m[s.substr(0, 2)].push_back(s.back());\\n    return helper(bottom, m, 0, \"\");\\n  }\\n  bool helper(string bottom, unordered_map<string, vector<char>>& m, int start, string next){\\n    if(bottom.size() == 1) return true;\\n    if(start == (int)bottom.size() - 1) return helper(next, m, 0, \"\");\\n    for(char c : m[bottom.substr(start, 2)])\\n      if(helper(bottom, m, start+1, next+c)) return true;\\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n  bool pyramidTransition(string bottom, vector<string>& allowed) {\\n    unordered_map<string, vector<char>> m;\\n    for(auto& s:allowed) m[s.substr(0, 2)].push_back(s.back());\\n    return helper(bottom, m, 0, \"\");\\n  }\\n  bool helper(string bottom, unordered_map<string, vector<char>>& m, int start, string next){\\n    if(bottom.size() == 1) return true;\\n    if(start == (int)bottom.size() - 1) return helper(next, m, 0, \"\");\\n    for(char c : m[bottom.substr(start, 2)])\\n      if(helper(bottom, m, start+1, next+c)) return true;\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113038,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n\\n    def pyramidTransition(self, bottom, allowed):\\n        f = collections.defaultdict(lambda: defaultdict(list))\\n        for a, b, c in allowed: f[a][b].append(c)\\n\\n        def pyramid(bottom):\\n            if len(bottom) == 1: return True\\n            for i in itertools.product(*(f[a][b] for a, b in zip(bottom, bottom[1:]))):\\n                if pyramid(i): return True\\n            return False\\n        return pyramid(bottom)\\n```\\nMake ``pyramid`` into one line if you like:\\n```\\ndef pyramid(bottom):\\n            return len(bottom) == 1 or any(pyramid(i) for i in product(*(f[a][b] for a, b in zip(bottom, bottom[1:]))))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def pyramidTransition(self, bottom, allowed):\\n        f = collections.defaultdict(lambda: defaultdict(list))\\n        for a, b, c in allowed: f[a][b].append(c)\\n\\n        def pyramid(bottom):\\n            if len(bottom) == 1: return True\\n            for i in itertools.product(*(f[a][b] for a, b in zip(bottom, bottom[1:]))):\\n                if pyramid(i): return True\\n            return False\\n        return pyramid(bottom)\\n```\n```\\ndef pyramid(bottom):\\n            return len(bottom) == 1 or any(pyramid(i) for i in product(*(f[a][b] for a, b in zip(bottom, bottom[1:]))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149032,
                "title": "java-top-down-clean-dp",
                "content": "Dealing with layer is a little bit awkward, here I use a `#` to separate the layer and then it turns to a simple string. Here\\'s the code:\\n```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<Character>> map = new HashMap<>();\\n        for (String s : allowed) {\\n            String key = s.substring(0, 2);\\n            map.putIfAbsent(key, new ArrayList<>());\\n            map.get(key).add(s.charAt(2));\\n        }\\n        return dfs(map, bottom + \"#\", new HashSet<>());\\n    }\\n    \\n    boolean dfs(Map<String, List<Character>> map, String s, Set<String> memo) {\\n        if (s.length() == 1) return true;\\n        if (memo.contains(s)) return false;\\n        String key = s.substring(0, 2);\\n        if (key.charAt(1) == \\'#\\') return dfs(map, s.substring(2) + \\'#\\', memo);\\n        for (char c : map.getOrDefault(key, new ArrayList<>())) {\\n            if (dfs(map, s.substring(1) + c, memo)) return true;\\n        }\\n        memo.add(s);\\n        return false;\\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<Character>> map = new HashMap<>();\\n        for (String s : allowed) {\\n            String key = s.substring(0, 2);\\n            map.putIfAbsent(key, new ArrayList<>());\\n            map.get(key).add(s.charAt(2));\\n        }\\n        return dfs(map, bottom + \"#\", new HashSet<>());\\n    }\\n    \\n    boolean dfs(Map<String, List<Character>> map, String s, Set<String> memo) {\\n        if (s.length() == 1) return true;\\n        if (memo.contains(s)) return false;\\n        String key = s.substring(0, 2);\\n        if (key.charAt(1) == \\'#\\') return dfs(map, s.substring(2) + \\'#\\', memo);\\n        for (char c : map.getOrDefault(key, new ArrayList<>())) {\\n            if (dfs(map, s.substring(1) + c, memo)) return true;\\n        }\\n        memo.add(s);\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113062,
                "title": "c-passed-counter-example-dfs-with-memoization-6-ms",
                "content": "The standard DP solution cannot pass the most upvoted counter example. Here is my DFS/backtracking solution with a couple optimizations. The run time is ~1000 ms (now 6 ms possibly due to large test cases removed). The big O run time would be exponential.\\n\\nTheoretically, BFS should work. We can use unordered_set<string> to keep all possible strings for each level. Then move up and generate possible combinations for next level. When reaching the top, if the set is non-empty, return true. However, it will result in TLE. The advantage of DFS is early termination. Once we find a valid solution, we don't have to traverse the whole tree, although the worse case runtime is the same.  \\n\\nA couple optimization:\\n1) memoization: unordered_set<string> invalid, to keep all the strings that won't work.\\n2) 2D vector<char> to keep edges, such as \"ABE\". \\n3) early termination if a string cannot generate a string of next level. For example, \"ABFE\" while there is no edge of \"BF#\".\\n```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_set<string> invalid;\\n        // 7 characters from A to G, size 49 is sufficient.\\n        vector<vector<char>> edges(49);\\n        for (string& s: allowed) {\\n            int key = (s[0]-'A')*7+s[1]-'A';\\n            edges[key].push_back(s[2]);\\n        }\\n        return helper(invalid, bottom, edges);\\n    }\\nprivate:\\n    bool helper(unordered_set<string>& invalid, string& bottom, vector<vector<char>>& edges) {\\n        if (bottom.size() <= 1) return true;\\n        if (invalid.count(bottom)) return false;\\n        int n = bottom.size();\\n        // early termination if next level string is impossible\\n        for (int i = 0; i < n-1; i++) {\\n            int key = (bottom[i]-'A')*7+bottom[i+1]-'A';\\n            if (edges[key].empty()) {\\n                invalid.insert(bottom);\\n                return false;\\n            }\\n        }\\n        // try all possible strings (from backtracking) of next level\\n        string path(n-1, 'A');\\n        if (dfs(invalid, bottom, edges, path, 0)) return true;\\n        invalid.insert(bottom);\\n        return false;\\n    }\\n    bool dfs(unordered_set<string>& invalid, string& s, vector<vector<char>>& edges, string& path, int idx) {\\n        // find a possible string of next level\\n        if (idx+1 == s.size()) return helper(invalid, path, edges);\\n        int key = (s[idx]-'A')*7+s[idx+1]-'A'; \\n        for (char c: edges[key]) {\\n            path[idx] = c;\\n            if (dfs(invalid, s, edges, path, idx+1)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_set<string> invalid;\\n        // 7 characters from A to G, size 49 is sufficient.\\n        vector<vector<char>> edges(49);\\n        for (string& s: allowed) {\\n            int key = (s[0]-'A')*7+s[1]-'A';\\n            edges[key].push_back(s[2]);\\n        }\\n        return helper(invalid, bottom, edges);\\n    }\\nprivate:\\n    bool helper(unordered_set<string>& invalid, string& bottom, vector<vector<char>>& edges) {\\n        if (bottom.size() <= 1) return true;\\n        if (invalid.count(bottom)) return false;\\n        int n = bottom.size();\\n        // early termination if next level string is impossible\\n        for (int i = 0; i < n-1; i++) {\\n            int key = (bottom[i]-'A')*7+bottom[i+1]-'A';\\n            if (edges[key].empty()) {\\n                invalid.insert(bottom);\\n                return false;\\n            }\\n        }\\n        // try all possible strings (from backtracking) of next level\\n        string path(n-1, 'A');\\n        if (dfs(invalid, bottom, edges, path, 0)) return true;\\n        invalid.insert(bottom);\\n        return false;\\n    }\\n    bool dfs(unordered_set<string>& invalid, string& s, vector<vector<char>>& edges, string& path, int idx) {\\n        // find a possible string of next level\\n        if (idx+1 == s.size()) return helper(invalid, path, edges);\\n        int key = (s[idx]-'A')*7+s[idx+1]-'A'; \\n        for (char c: edges[key]) {\\n            path[idx] = c;\\n            if (dfs(invalid, s, edges, path, idx+1)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621275,
                "title": "c-dfs",
                "content": "```cpp\\nunordered_map<string, vector<char>> m;\\nbool dfs(string &bottom, string top) {\\n    if (top.size() == bottom.size() - 1)\\n        return top.empty() ? true : dfs(top, string());\\n    for (auto ch : m[bottom.substr(top.size(), 2)])\\n        if (dfs(bottom, top + ch))\\n            return true;\\n    return false;\\n}\\nbool pyramidTransition(string bottom, vector<string>& allowed) {\\n    for (auto &s : allowed)\\n        m[s.substr(0, 2)].push_back(s[2]);\\n    return dfs(bottom, string());\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nunordered_map<string, vector<char>> m;\\nbool dfs(string &bottom, string top) {\\n    if (top.size() == bottom.size() - 1)\\n        return top.empty() ? true : dfs(top, string());\\n    for (auto ch : m[bottom.substr(top.size(), 2)])\\n        if (dfs(bottom, top + ch))\\n            return true;\\n    return false;\\n}\\nbool pyramidTransition(string bottom, vector<string>& allowed) {\\n    for (auto &s : allowed)\\n        m[s.substr(0, 2)].push_back(s[2]);\\n    return dfs(bottom, string());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113075,
                "title": "dp-o-n-2-m",
                "content": "**n** is the size of *bottom*, **m** is the length of *allowed*.\\n\\n**Update**: even this solution is ACed, personally, I don't think it is correct - see https://discuss.leetcode.com/topic/115541/counter-example-to-the-standard-code\\n\\nBut, I still think it's worth to note it down here to help understand what the official solution wanted it be.\\n\\n```\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        int n = bottom.length();\\n        Map<Character, List<String>> map = new HashMap<>();\\n        for(String s : allowed) {\\n            char key = s.charAt(2);\\n            if (!map.containsKey(key))\\n                map.put(key, new ArrayList<>());\\n            map.get(key).add(s.substring(0,2));\\n        }\\n        \\n        boolean[][][] dp = new boolean[n][n][7];\\n        for(int i = 0; i < n; i++) {\\n            dp[n-1][i][bottom.charAt(i)-'A'] = true;\\n        }\\n        for(int i = n-2; i >= 0; i--) {\\n            for(int j = 0; j <= i; j++)\\n                for(char ch = 'A'; ch <= 'G'; ch++) {\\n                    if (!map.containsKey(ch)) continue;\\n                    for(String b : map.get(ch)) {\\n                        if (dp[i+1][j][b.charAt(0) - 'A'] && dp[i+1][j+1][b.charAt(1)-'A'])\\n                            dp[i][j][ch - 'A'] = true;\\n                    }\\n                }\\n        }\\n        \\n        for(int i = 0; i < 7; i++)\\n            if (dp[0][0][i]) return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        int n = bottom.length();\\n        Map<Character, List<String>> map = new HashMap<>();\\n        for(String s : allowed) {\\n            char key = s.charAt(2);\\n            if (!map.containsKey(key))\\n                map.put(key, new ArrayList<>());\\n            map.get(key).add(s.substring(0,2));\\n        }\\n        \\n        boolean[][][] dp = new boolean[n][n][7];\\n        for(int i = 0; i < n; i++) {\\n            dp[n-1][i][bottom.charAt(i)-'A'] = true;\\n        }\\n        for(int i = n-2; i >= 0; i--) {\\n            for(int j = 0; j <= i; j++)\\n                for(char ch = 'A'; ch <= 'G'; ch++) {\\n                    if (!map.containsKey(ch)) continue;\\n                    for(String b : map.get(ch)) {\\n                        if (dp[i+1][j][b.charAt(0) - 'A'] && dp[i+1][j+1][b.charAt(1)-'A'])\\n                            dp[i][j][ch - 'A'] = true;\\n                    }\\n                }\\n        }\\n        \\n        for(int i = 0; i < 7; i++)\\n            if (dp[0][0][i]) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640226,
                "title": "dfs-solution-c",
                "content": "Start from initial bottom and make another upper level bottom by trying all posssible cases for triplets...In this way if you reach at the top where bottom size==1 then return true cause you have reach to top ... SO its possible otherwise return false;\\n```\\nclass Solution {\\n    unordered_map<string,vector<char> > m;\\npublic:\\n    bool dfs(string bot,int i,string tem){\\n        if(bot.size()==1) return true;\\n        if(i==bot.size()-1) {\\n            string st;\\n            return dfs(tem,0,st);\\n        }\\n        for(auto v:m[bot.substr(i,2)]){\\n            tem.push_back(v);\\n            if(dfs(bot,i+1,tem)){\\n                return true;\\n            }\\n            tem.pop_back();\\n        }\\n        return false;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        for(auto a:allowed){\\n            m[a.substr(0,2)].push_back(a[2]);\\n        }\\n        string te;\\n        return dfs(bottom,0,te);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string,vector<char> > m;\\npublic:\\n    bool dfs(string bot,int i,string tem){\\n        if(bot.size()==1) return true;\\n        if(i==bot.size()-1) {\\n            string st;\\n            return dfs(tem,0,st);\\n        }\\n        for(auto v:m[bot.substr(i,2)]){\\n            tem.push_back(v);\\n            if(dfs(bot,i+1,tem)){\\n                return true;\\n            }\\n            tem.pop_back();\\n        }\\n        return false;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        for(auto a:allowed){\\n            m[a.substr(0,2)].push_back(a[2]);\\n        }\\n        string te;\\n        return dfs(bottom,0,te);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374538,
                "title": "java-2ms-easy-dfs",
                "content": "```\\npublic boolean pyramidTransition(String bottom, List<String> allowed) {\\n\\tSet<Character>[][] map = new Set[7][7];\\n\\n\\tfor (String triple : allowed) {\\n\\t\\tint i = triple.charAt(0) - \\'A\\', j = triple.charAt(1) - \\'A\\';\\n\\t\\tif (map[i][j] == null) map[i][j] = new HashSet<>();\\n\\n\\t\\tmap[i][j].add(triple.charAt(2));\\n\\t}\\n\\n\\treturn dfs(map, bottom, \"\", 0);\\n}\\n\\nprivate boolean dfs(Set<Character>[][] map, String bottom, String top, int k) {\\n\\tif (bottom.length() == 1) return true;\\n\\n\\tif (k == bottom.length() - 1) return dfs(map, top, \"\", 0);\\n\\n\\tint i = bottom.charAt(k) - \\'A\\', j = bottom.charAt(k + 1) - \\'A\\';\\n\\tif (map[i][j] == null) return false;\\n\\n\\tfor (char candidate : map[i][j]) {\\n\\t\\tif (dfs(map, bottom, top + candidate, k + 1)) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean pyramidTransition(String bottom, List<String> allowed) {\\n\\tSet<Character>[][] map = new Set[7][7];\\n\\n\\tfor (String triple : allowed) {\\n\\t\\tint i = triple.charAt(0) - \\'A\\', j = triple.charAt(1) - \\'A\\';\\n\\t\\tif (map[i][j] == null) map[i][j] = new HashSet<>();\\n\\n\\t\\tmap[i][j].add(triple.charAt(2));\\n\\t}\\n\\n\\treturn dfs(map, bottom, \"\", 0);\\n}\\n\\nprivate boolean dfs(Set<Character>[][] map, String bottom, String top, int k) {\\n\\tif (bottom.length() == 1) return true;\\n\\n\\tif (k == bottom.length() - 1) return dfs(map, top, \"\", 0);\\n\\n\\tint i = bottom.charAt(k) - \\'A\\', j = bottom.charAt(k + 1) - \\'A\\';\\n\\tif (map[i][j] == null) return false;\\n\\n\\tfor (char candidate : map[i][j]) {\\n\\t\\tif (dfs(map, bottom, top + candidate, k + 1)) return true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 312271,
                "title": "javascript-dfs-memo-100-with-comments",
                "content": "```\\n/**\\n * @param {string} bottom\\n * @param {string[]} allowed\\n * @return {boolean}\\n */\\nvar pyramidTransition = function(bottom, allowed) {\\n    \\n    /*Initialise map of \\'children\\':[parent1,parent2,...]*/\\n    let map=new Map();\\n    allowed.map((item)=>{\\n       let t=map.get(item[0]+item[1])||new Array();\\n        t.push(item[2]);\\n        map.set(item[0]+item[1],t);\\n    });    \\n    \\n    /*For Caching*/\\n    let memo=new Map();\\n    \\n    let solve = function(cur,ind,next){\\n        /* if this level is already examined*/\\n        if(memo.has(cur))\\n            return memo.get(cur);\\n        \\n        /* if this level is top*/\\n        if(cur.length==1)\\n            return true;\\n        \\n        /* if we are at last character of this level*/\\n        if(ind>=cur.length-1){\\n            let res=solve(next,0,\\'\\'); //Solve the upper level\\n            memo.set(next,res);      //Cache the result\\n            return res;             //return\\n        }\\n        \\n        /* if the current 2 characters do not have a parent */\\n        if(!map.has(cur.substring(ind,ind+2))){\\n            memo.set(cur,false);\\n            return false;\\n        }\\n        \\n        /*Loop over all parents of current 2 characters*/\\n        for(let char of map.get(cur.substring(ind,ind+2))){\\n            if(solve(cur,ind+1,next+char))\\n                return true;\\n        }\\n        return false;\\n    }\\n    return solve(bottom,0,\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} bottom\\n * @param {string[]} allowed\\n * @return {boolean}\\n */\\nvar pyramidTransition = function(bottom, allowed) {\\n    \\n    /*Initialise map of \\'children\\':[parent1,parent2,...]*/\\n    let map=new Map();\\n    allowed.map((item)=>{\\n       let t=map.get(item[0]+item[1])||new Array();\\n        t.push(item[2]);\\n        map.set(item[0]+item[1],t);\\n    });    \\n    \\n    /*For Caching*/\\n    let memo=new Map();\\n    \\n    let solve = function(cur,ind,next){\\n        /* if this level is already examined*/\\n        if(memo.has(cur))\\n            return memo.get(cur);\\n        \\n        /* if this level is top*/\\n        if(cur.length==1)\\n            return true;\\n        \\n        /* if we are at last character of this level*/\\n        if(ind>=cur.length-1){\\n            let res=solve(next,0,\\'\\'); //Solve the upper level\\n            memo.set(next,res);      //Cache the result\\n            return res;             //return\\n        }\\n        \\n        /* if the current 2 characters do not have a parent */\\n        if(!map.has(cur.substring(ind,ind+2))){\\n            memo.set(cur,false);\\n            return false;\\n        }\\n        \\n        /*Loop over all parents of current 2 characters*/\\n        for(let char of map.get(cur.substring(ind,ind+2))){\\n            if(solve(cur,ind+1,next+char))\\n                return true;\\n        }\\n        return false;\\n    }\\n    return solve(bottom,0,\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142509,
                "title": "my-python-dfs-solution",
                "content": "My DFS solution adds a ``nextLayer`` variable which records the sub-string of next layer. The idea is simple. Everytime we extract the first two characters from ``bottomLayer``. If the first two characters appears in the ``blockDict``, append the top element to ``nextLayer`` variable and call DFS. If we reach the last two characters in ``bottomLayer``, we set ``nextLayer`` to ``bottomLayer``, set empty to ``nextLayer``, and call DFS. The DFS function returns True once we get a string of ``bottomLayer`` with length = 1.\\n\\nTo speed up, we set an early termination condition that check if the last two characters in ``nextLayer`` in the ``blockDict`` list or not.\\n\\nThe execution time of my solution is 36 ms.\\n```\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        if len(bottom) <= 1:\\n            return False\\n        blockDict = {}\\n        for block in allowed:\\n            if block[:2] not in blockDict:\\n                blockDict[block[:2]] = []\\n            \\n            blockDict[block[:2]].append(block[2])\\n\\n        def dfs(bottomLayer, nextLayer):\\n            if len(bottomLayer) == 1:\\n                return True\\n\\n            if bottomLayer[:2] in blockDict:\\n                for nextElement in blockDict[bottomLayer[:2]]:\\n                    if len(bottomLayer) <= 2:\\n                        # move to next layer\\n                        if dfs(nextLayer + nextElement, \"\"):\\n                            return True\\n                    else:\\n                        if len(nextLayer) <= 0 or (nextLayer[-1] + nextElement) in blockDict:\\n                            if dfs(bottomLayer[1:], nextLayer + nextElement):\\n                                return True\\n\\n            return False\\n        return dfs(bottom, \"\")\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        if len(bottom) <= 1:\\n            return False\\n        blockDict = {}\\n        for block in allowed:\\n            if block[:2] not in blockDict:\\n                blockDict[block[:2]] = []\\n            \\n            blockDict[block[:2]].append(block[2])\\n\\n        def dfs(bottomLayer, nextLayer):\\n            if len(bottomLayer) == 1:\\n                return True\\n\\n            if bottomLayer[:2] in blockDict:\\n                for nextElement in blockDict[bottomLayer[:2]]:\\n                    if len(bottomLayer) <= 2:\\n                        # move to next layer\\n                        if dfs(nextLayer + nextElement, \"\"):\\n                            return True\\n                    else:\\n                        if len(nextLayer) <= 0 or (nextLayer[-1] + nextElement) in blockDict:\\n                            if dfs(bottomLayer[1:], nextLayer + nextElement):\\n                                return True\\n\\n            return False\\n        return dfs(bottom, \"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268424,
                "title": "python-3-bfs-and-dfs",
                "content": "BFS solution: gives TLE\\n\\n\\tclass Solution:\\n\\t\\t\\tdef get_states(self,s,i,new,allowed):\\n\\t\\t\\t\\tif i==len(s):\\n\\t\\t\\t\\t\\tself.res.append(\\'\\'.join(new))\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\tfor x in allowed[s[i-1]+s[i]]:\\n\\t\\t\\t\\t\\tnew.append(x)\\n\\t\\t\\t\\t\\tself.get_states(s,i+1,new,allowed)\\n\\t\\t\\t\\t\\tnew.pop()\\n\\n\\t\\t\\tdef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n\\t\\t\\t\\ta=defaultdict(list)\\n\\t\\t\\t\\tfor s in allowed:\\n\\t\\t\\t\\t\\ta[s[:2]].append(s[2])\\n\\t\\t\\t\\tself.res=[bottom]\\n\\t\\t\\t\\tfor x in self.res:\\n\\t\\t\\t\\t\\tif len(x)==1:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\tself.get_states(x,1,[],a)\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\nDFS solution: \\n\\n\\tclass Solution:\\n\\t\\t@cache \\n\\t\\tdef dfs(self ,state, i, nxt):\\n\\t\\t\\tif len(state) == 1:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif len(state) - 1 == len(nxt): # we have reached the next state completely so this state is valid\\n\\t\\t\\t\\treturn dfs(nxt, 0, \"\")\\n\\t\\t\\tif i == len(state) - 1: # we have reached the last index without moving to next state it shows this state is invalid\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tfor c in a[state[i]+state[i+1]]:\\n\\t\\t\\t\\tif dfs(state, i+1, nxt + c):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False\\n\\t\\n\\t\\tdef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n\\t\\t\\ta = defaultdict(list)\\n\\t\\t\\tfor s in allowed:\\n\\t\\t\\t\\ta[s[:2]].append(s[2])\\n\\t\\t\\treturn self.dfs(bottom, 0, \"\")",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "BFS solution: gives TLE\\n\\n\\tclass Solution:\\n\\t\\t\\tdef get_states(self,s,i,new,allowed):\\n\\t\\t\\t\\tif i==len(s):\\n\\t\\t\\t\\t\\tself.res.append(\\'\\'.join(new))\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\tfor x in allowed[s[i-1]+s[i]]:\\n\\t\\t\\t\\t\\tnew.append(x)\\n\\t\\t\\t\\t\\tself.get_states(s,i+1,new,allowed)\\n\\t\\t\\t\\t\\tnew.pop()\\n\\n\\t\\t\\tdef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n\\t\\t\\t\\ta=defaultdict(list)\\n\\t\\t\\t\\tfor s in allowed:\\n\\t\\t\\t\\t\\ta[s[:2]].append(s[2])\\n\\t\\t\\t\\tself.res=[bottom]\\n\\t\\t\\t\\tfor x in self.res:\\n\\t\\t\\t\\t\\tif len(x)==1:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\tself.get_states(x,1,[],a)\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\nDFS solution: \\n\\n\\tclass Solution:\\n\\t\\t@cache \\n\\t\\tdef dfs(self ,state, i, nxt):\\n\\t\\t\\tif len(state) == 1:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif len(state) - 1 == len(nxt): # we have reached the next state completely so this state is valid\\n\\t\\t\\t\\treturn dfs(nxt, 0, \"\")\\n\\t\\t\\tif i == len(state) - 1: # we have reached the last index without moving to next state it shows this state is invalid\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tfor c in a[state[i]+state[i+1]]:\\n\\t\\t\\t\\tif dfs(state, i+1, nxt + c):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False\\n\\t\\n\\t\\tdef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n\\t\\t\\ta = defaultdict(list)\\n\\t\\t\\tfor s in allowed:\\n\\t\\t\\t\\ta[s[:2]].append(s[2])\\n\\t\\t\\treturn self.dfs(bottom, 0, \"\")",
                "codeTag": "Java"
            },
            {
                "id": 295124,
                "title": "easy-to-understand-java-solution-map-recursion",
                "content": "Feel free to let me know if I can improve the solution\\n```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        //Construct allowed Map to map allowed characters to Strings in allowed list\\n        HashMap<String, List<String>> allowedMap = new HashMap<>();\\n\\t\\tfor(String s : allowed) {\\n\\t\\t\\tString temp = s.substring(0,2);\\n        \\tif(!allowedMap.containsKey(temp)) {\\n        \\t\\tallowedMap.put(temp, new ArrayList<String>());\\n        \\t}\\n        \\tallowedMap.get(temp).add(s.substring(2));\\n        }\\n\\t\\treturn pyramidTransition(allowedMap, bottom.length(), 0, bottom, \"\");\\n    }\\n\\t\\n\\tpublic boolean pyramidTransition(HashMap<String, List<String>> allowedMap, int row, int index, String currentString, String nextString) {\\n        //if you reach the top row, you have successfully created the pyramid\\n\\t\\tif(row == 0) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n        \\n        //if you are on the last index of the current row, move up by one row\\n\\t\\tif(index == currentString.length() - 1) {\\n\\t\\t\\treturn pyramidTransition(allowedMap, row - 1, 0, nextString, \"\");\\n\\t\\t}\\n        \\n\\t\\tList<String> temp = allowedMap.get(currentString.substring(index, index + 2));\\n        \\n        //if there is no allowed character to be placed, your combination has failed\\n\\t\\tif(temp == null)\\n\\t\\t\\treturn false;\\n        \\n        //for every allowed character to your combination, construct the nextString and recurse\\n\\t\\tfor(String s : temp) {\\n\\t\\t\\tif(pyramidTransition(allowedMap, row, index + 1, currentString, nextString + s))\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n        \\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        //Construct allowed Map to map allowed characters to Strings in allowed list\\n        HashMap<String, List<String>> allowedMap = new HashMap<>();\\n\\t\\tfor(String s : allowed) {\\n\\t\\t\\tString temp = s.substring(0,2);\\n        \\tif(!allowedMap.containsKey(temp)) {\\n        \\t\\tallowedMap.put(temp, new ArrayList<String>());\\n        \\t}\\n        \\tallowedMap.get(temp).add(s.substring(2));\\n        }\\n\\t\\treturn pyramidTransition(allowedMap, bottom.length(), 0, bottom, \"\");\\n    }\\n\\t\\n\\tpublic boolean pyramidTransition(HashMap<String, List<String>> allowedMap, int row, int index, String currentString, String nextString) {\\n        //if you reach the top row, you have successfully created the pyramid\\n\\t\\tif(row == 0) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n        \\n        //if you are on the last index of the current row, move up by one row\\n\\t\\tif(index == currentString.length() - 1) {\\n\\t\\t\\treturn pyramidTransition(allowedMap, row - 1, 0, nextString, \"\");\\n\\t\\t}\\n        \\n\\t\\tList<String> temp = allowedMap.get(currentString.substring(index, index + 2));\\n        \\n        //if there is no allowed character to be placed, your combination has failed\\n\\t\\tif(temp == null)\\n\\t\\t\\treturn false;\\n        \\n        //for every allowed character to your combination, construct the nextString and recurse\\n\\t\\tfor(String s : temp) {\\n\\t\\t\\tif(pyramidTransition(allowedMap, row, index + 1, currentString, nextString + s))\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n        \\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113056,
                "title": "share-my-dfs-python-solutions",
                "content": "My idea is very simple, just DFS and passed in 1899ms :)\\nI used the cartesian product python library function to enumerate all the possibilities for DFS.\\n```\\ndef pyramidTransition(bottom, allowed):\\n    hashmap = dict()\\n    for triplet in allowed:\\n        if triplet[:2] not in hashmap:\\n            hashmap[triplet[:2]] = []\\n        hashmap[triplet[:2]] += [triplet[2]]\\n\\n    def dfs(bottom):\\n        if len(bottom) == 2 and bottom in hashmap:\\n            return True\\n        options = []\\n        for i in range(len(bottom) - 1):\\n            if bottom[i:i+2] in hashmap:\\n                options.append(hashmap[bottom[i:i+2]])\\n            else:\\n                return False\\n        for bot in itertools.product(*options):\\n            if dfs(''.join(bot)):\\n                return True\\n        return False\\n    return dfs(bottom)\\n```",
                "solutionTags": [],
                "code": "```\\ndef pyramidTransition(bottom, allowed):\\n    hashmap = dict()\\n    for triplet in allowed:\\n        if triplet[:2] not in hashmap:\\n            hashmap[triplet[:2]] = []\\n        hashmap[triplet[:2]] += [triplet[2]]\\n\\n    def dfs(bottom):\\n        if len(bottom) == 2 and bottom in hashmap:\\n            return True\\n        options = []\\n        for i in range(len(bottom) - 1):\\n            if bottom[i:i+2] in hashmap:\\n                options.append(hashmap[bottom[i:i+2]])\\n            else:\\n                return False\\n        for bot in itertools.product(*options):\\n            if dfs(''.join(bot)):\\n                return True\\n        return False\\n    return dfs(bottom)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1661915,
                "title": "concise-backtracking-with-memoization-easy",
                "content": "I tried without memo but it give tle as it has some overlapping subproblems we can use a unordered map for the memo.\\n  \\n  \\n  \\n  \\n\\t  unordered_map<string,bool>m;\\n\\t bool  backtrack(string bottom,unordered_map<string,vector<char>>&map,string new_string,int curr)\\n    {\\n     if(bottom.length()==1) return true;\\n     if(curr==bottom.length()-1) \\n     {      if(m.find(new_string)!=m.end())\\n         return m[new_string];\\n      else\\n         return m[new_string]=backtrack(new_string,map,\"\",0);\\n     }\\n     for(char x:map[bottom.substr(curr,2)])\\n         if(backtrack(bottom,map,new_string+x,curr+1))\\n             return true;\\n     \\n     return false;\\n        \\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n               \\n        \\n        unordered_map<string,vector<char>>map;\\n        string s=\"\";\\n        for(int i=0;i<allowed.size();i++)\\n        {\\n            s=allowed[i].substr(0,2);\\n            map[s].push_back(allowed[i][2]);\\n        \\n            \\n        }\\n    \\n        //backtracking\\n        return backtrack(bottom,map,\"\",0);\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "I tried without memo but it give tle as it has some overlapping subproblems we can use a unordered map for the memo.\\n  \\n  \\n  \\n  \\n\\t  unordered_map<string,bool>m;\\n\\t bool  backtrack(string bottom,unordered_map<string,vector<char>>&map,string new_string,int curr)\\n    {\\n     if(bottom.length()==1) return true;\\n     if(curr==bottom.length()-1) \\n     {      if(m.find(new_string)!=m.end())\\n         return m[new_string];\\n      else\\n         return m[new_string]=backtrack(new_string,map,\"\",0);\\n     }\\n     for(char x:map[bottom.substr(curr,2)])\\n         if(backtrack(bottom,map,new_string+x,curr+1))\\n             return true;\\n     \\n     return false;\\n        \\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n               \\n        \\n        unordered_map<string,vector<char>>map;\\n        string s=\"\";\\n        for(int i=0;i<allowed.size();i++)\\n        {\\n            s=allowed[i].substr(0,2);\\n            map[s].push_back(allowed[i][2]);\\n        \\n            \\n        }\\n    \\n        //backtracking\\n        return backtrack(bottom,map,\"\",0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 992808,
                "title": "short-bfs",
                "content": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> l) {\\n        if (bottom.length() <= 1) return true;\\n        var idx = new HashMap<String,List<String>>();\\n        for(var s : l){\\n            idx.computeIfAbsent(s.substring(0,2),i->new ArrayList<>()).add(s);\\n        }\\n        var row = new ArrayList<Set<String>>();\\n        for(int i = 2; i <= bottom.length(); ++i){\\n            var top = new HashSet<>(idx.getOrDefault(bottom.substring(i-2,i),List.of()));\\n            if (top.size() == 0) return false;\\n            row.add(top);\\n        }\\n        while(row.size()>1){\\n            var preRow = new ArrayList<Set<String>>();\\n            for(int j = 1; j < row.size();++j){\\n                var last = new HashSet<String>();\\n                preRow.add(last);\\n                for(var left : row.get(j-1)){\\n                    for(var right : row.get(j)){\\n                        last.addAll(idx.getOrDefault(\"\"+left.charAt(2)+right.charAt(2), List.of()));\\n                    }\\n                }\\n                if (last.size() == 0) return false;\\n            }            \\n            row = preRow;\\n        }\\n        return row.size() > 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> l) {\\n        if (bottom.length() <= 1) return true;\\n        var idx = new HashMap<String,List<String>>();\\n        for(var s : l){\\n            idx.computeIfAbsent(s.substring(0,2),i->new ArrayList<>()).add(s);\\n        }\\n        var row = new ArrayList<Set<String>>();\\n        for(int i = 2; i <= bottom.length(); ++i){\\n            var top = new HashSet<>(idx.getOrDefault(bottom.substring(i-2,i),List.of()));\\n            if (top.size() == 0) return false;\\n            row.add(top);\\n        }\\n        while(row.size()>1){\\n            var preRow = new ArrayList<Set<String>>();\\n            for(int j = 1; j < row.size();++j){\\n                var last = new HashSet<String>();\\n                preRow.add(last);\\n                for(var left : row.get(j-1)){\\n                    for(var right : row.get(j)){\\n                        last.addAll(idx.getOrDefault(\"\"+left.charAt(2)+right.charAt(2), List.of()));\\n                    }\\n                }\\n                if (last.size() == 0) return false;\\n            }            \\n            row = preRow;\\n        }\\n        return row.size() > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329488,
                "title": "python-generator-32ms-with-explanation",
                "content": "The idea is straighforward. Given the bottom row, we consider every possible way to lay the next row of bricks, and then recursively process each potential next row as the new bottom row. Whenever the bottom row reaches size 1 during any recursive call, we know we have a valid pyramid and can return True.\\n\\nWe use a simple function nextLevel(lvl: str) -> str that recursively generates all the possible next level combinations. In the base case, if there is only one brick in the current level, then the next level is empty.\\n\\nIf there are more than one brick in the current level of size N, then we first pretend that the first brick of the row doesn\\'t exist, and then recursively generate all the possible next rows that can be placed atop the smaller current row of size N-1 starting from the second brick.\\n\\nAfterwards, we lookup all the bricks that can be placed atop of the first two bricks, and prepend each possible brick to every possible next levels already generated from the reduced current row of size N-1, and now we have all the possible next levels for the original full-sized current row.\\n\\nUse another recursive function validate(bottom: str) -> bool to recursively process every row that we generated. If we ever get a size 1 bottom row, terminate the search and return True. If no input row of length 1 is encountered, we return False by default.\\n\\n\\tdef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        \\n        graph = collections.defaultdict(list)\\n        \\n        for triple in allowed:\\n            graph[triple[:2]].append(triple[2])\\n            \\n        def nextLevel(lvl):\\n            if len(lvl) == 1:\\n                yield \"\"\\n            else:\\n                for each in nextLevel(lvl[1:]):\\n                    for brick in graph[lvl[:2]]:\\n                        yield brick + each\\n        \\n        def validate(lvl):\\n            if len(lvl) == 1:\\n                return True\\n            \\n            for each in nextLevel(lvl):\\n                if validate(each):\\n                    return True\\n                    \\n            return False\\n\\t\\t\\t\\n        return validate(bottom)",
                "solutionTags": [],
                "code": "The idea is straighforward. Given the bottom row, we consider every possible way to lay the next row of bricks, and then recursively process each potential next row as the new bottom row. Whenever the bottom row reaches size 1 during any recursive call, we know we have a valid pyramid and can return True.\\n\\nWe use a simple function nextLevel(lvl: str) -> str that recursively generates all the possible next level combinations. In the base case, if there is only one brick in the current level, then the next level is empty.\\n\\nIf there are more than one brick in the current level of size N, then we first pretend that the first brick of the row doesn\\'t exist, and then recursively generate all the possible next rows that can be placed atop the smaller current row of size N-1 starting from the second brick.\\n\\nAfterwards, we lookup all the bricks that can be placed atop of the first two bricks, and prepend each possible brick to every possible next levels already generated from the reduced current row of size N-1, and now we have all the possible next levels for the original full-sized current row.\\n\\nUse another recursive function validate(bottom: str) -> bool to recursively process every row that we generated. If we ever get a size 1 bottom row, terminate the search and return True. If no input row of length 1 is encountered, we return False by default.\\n\\n\\tdef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        \\n        graph = collections.defaultdict(list)\\n        \\n        for triple in allowed:\\n            graph[triple[:2]].append(triple[2])\\n            \\n        def nextLevel(lvl):\\n            if len(lvl) == 1:\\n                yield \"\"\\n            else:\\n                for each in nextLevel(lvl[1:]):\\n                    for brick in graph[lvl[:2]]:\\n                        yield brick + each\\n        \\n        def validate(lvl):\\n            if len(lvl) == 1:\\n                return True\\n            \\n            for each in nextLevel(lvl):\\n                if validate(each):\\n                    return True\\n                    \\n            return False\\n\\t\\t\\t\\n        return validate(bottom)",
                "codeTag": "Python3"
            },
            {
                "id": 3645167,
                "title": "python-elegant-short-backtracking-no-tle",
                "content": "# Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + m)$$, where $$n$$ - length of ```bottom``` and $$m$$ - ```allowed``` size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        @cache\\n        def dfs(level: str) -> bool:\\n            if len(level) == 1:\\n                return True\\n\\n            return any(\\n                dfs(next_level)\\n                for next_level in product(*(pool[x + y] for x, y in pairwise(level)))\\n            )\\n\\n        pool = defaultdict(list)\\n\\n        for pattern in allowed:\\n            pool[pattern[:2]].append(pattern[2])\\n\\n        return dfs(bottom)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```bottom```\n```allowed```\n```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        @cache\\n        def dfs(level: str) -> bool:\\n            if len(level) == 1:\\n                return True\\n\\n            return any(\\n                dfs(next_level)\\n                for next_level in product(*(pool[x + y] for x, y in pairwise(level)))\\n            )\\n\\n        pool = defaultdict(list)\\n\\n        for pattern in allowed:\\n            pool[pattern[:2]].append(pattern[2])\\n\\n        return dfs(bottom)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244532,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n private:\\n  bool dfs(const string& row, const string& nextRow, int i,\\n         unordered_map<string, vector<char>>& Map) \\n  {\\n    if (row.length() == 1)\\n      return true;\\n    if (nextRow.length() == row.length() - 1)\\n      return dfs(nextRow, \"\", 0, Map);\\n    const string& prefix = row.substr(i, 2);\\n    if (Map.find(prefix) != Map.end()){\\n      for (auto c : Map[prefix])\\n        if (dfs(row, nextRow + c, i + 1, Map))\\n          return true;\\n    }\\n    return false;\\n  }\\n public:\\n  bool pyramidTransition(string bottom, vector<string>& allowed) {\\n    unordered_map<string, vector<char>> Map;\\n    for (auto& a : allowed)\\n      Map[a.substr(0, 2)].push_back(a[2]);\\n    return dfs(bottom, \"\", 0, Map);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n private:\\n  bool dfs(const string& row, const string& nextRow, int i,\\n         unordered_map<string, vector<char>>& Map) \\n  {\\n    if (row.length() == 1)\\n      return true;\\n    if (nextRow.length() == row.length() - 1)\\n      return dfs(nextRow, \"\", 0, Map);\\n    const string& prefix = row.substr(i, 2);\\n    if (Map.find(prefix) != Map.end()){\\n      for (auto c : Map[prefix])\\n        if (dfs(row, nextRow + c, i + 1, Map))\\n          return true;\\n    }\\n    return false;\\n  }\\n public:\\n  bool pyramidTransition(string bottom, vector<string>& allowed) {\\n    unordered_map<string, vector<char>> Map;\\n    for (auto& a : allowed)\\n      Map[a.substr(0, 2)].push_back(a[2]);\\n    return dfs(bottom, \"\", 0, Map);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288127,
                "title": "most-simple-python-solution-with-comments",
                "content": "First implemented simple DFS approach but TLE. So the second version, add simple memoization of the rows when they are all filled, and do not visit them again.\\n\\nFirst Solution TLE\\n```\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool    \\n        \"\"\"\\n        dic = defaultdict(list)\\n        for i in allowed:\\n            dic[(i[0], i[1])].append(i[2])\\n        \\n        res = []\\n        \\n        def dfs(arr, nxt):\\n            #base case second floor and check top exists\\n            if len(arr) == 2 and dic[(arr[0], arr[1])]:\\n                return True\\n            \\n            #go to the next row now\\n            if len(arr) == len(nxt) + 1:\\n                return dfs(nxt, [])\\n\\n            #keep iterating the same row\\n            if dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\\n                for val in dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\\n                    if dfs(arr, nxt + [val]):\\n                        return True\\n            return False\\n        \\n        return dfs(bottom, [])\\n```\\nSecond Solution passes \\n```\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        dic = defaultdict(list)\\n        for i in allowed:\\n            dic[(i[0], i[1])].append(i[2])\\n        \\n        res = []\\n        visited = set()\\n        def dfs(arr, nxt):\\n            #base case second floor and check top exists\\n            if len(arr) == 2 and dic[(arr[0], arr[1])]:\\n                return True\\n            \\n            #go to the next row now\\n            if len(arr) == len(nxt) + 1:\\n                if tuple(nxt) in visited:\\n                    return False\\n                visited.add(tuple(nxt))\\n                return dfs(nxt, [])\\n\\n            #keep iterating the same row\\n            if dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\\n                for val in dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\\n                    if dfs(arr, nxt + [val]):\\n                        return True\\n            return False\\n        \\n        return dfs(bottom, [])\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool    \\n        \"\"\"\\n        dic = defaultdict(list)\\n        for i in allowed:\\n            dic[(i[0], i[1])].append(i[2])\\n        \\n        res = []\\n        \\n        def dfs(arr, nxt):\\n            #base case second floor and check top exists\\n            if len(arr) == 2 and dic[(arr[0], arr[1])]:\\n                return True\\n            \\n            #go to the next row now\\n            if len(arr) == len(nxt) + 1:\\n                return dfs(nxt, [])\\n\\n            #keep iterating the same row\\n            if dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\\n                for val in dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\\n                    if dfs(arr, nxt + [val]):\\n                        return True\\n            return False\\n        \\n        return dfs(bottom, [])\\n```\n```\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        dic = defaultdict(list)\\n        for i in allowed:\\n            dic[(i[0], i[1])].append(i[2])\\n        \\n        res = []\\n        visited = set()\\n        def dfs(arr, nxt):\\n            #base case second floor and check top exists\\n            if len(arr) == 2 and dic[(arr[0], arr[1])]:\\n                return True\\n            \\n            #go to the next row now\\n            if len(arr) == len(nxt) + 1:\\n                if tuple(nxt) in visited:\\n                    return False\\n                visited.add(tuple(nxt))\\n                return dfs(nxt, [])\\n\\n            #keep iterating the same row\\n            if dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\\n                for val in dic[(arr[len(nxt)], arr[len(nxt) + 1])]:\\n                    if dfs(arr, nxt + [val]):\\n                        return True\\n            return False\\n        \\n        return dfs(bottom, [])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737801,
                "title": "javascript-solution-top-down-with-memoization",
                "content": "```\\nvar pyramidTransition = function(bottom, allowed) {\\n    const set = new Set(allowed);\\n    const memo = new Map();\\n    const chars = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\\n    \\n    return topDown(bottom, bottom.length - 1);\\n    \\n    function topDown(prev, row) {\\n        const key = `${prev}#${row}`;\\n        \\n        if (row === 0) return true;\\n        if (memo.has(key)) return memo.get(key);\\n\\n        let pats = new Set();\\n        pats.add(\"\");\\n\\n        for (let i = 0; i < row; i++) {\\n            const tmp = new Set();\\n\\n            const leftBot = prev.charAt(i);\\n            const rightBot = prev.charAt(i + 1);\\n\\n            for (const char of chars) {\\n                const triadStr = leftBot + rightBot + char;\\n\\n                if (set.has(triadStr)) {\\n                    for (const pat of pats) {\\n                        tmp.add(pat + char);\\n                    }                 \\n                }\\n            }\\n          \\n            pats = tmp;\\n        }\\n        \\n        for (const pat of pats) {\\n            if (topDown(pat, row - 1)) return true;\\n        }\\n        \\n        memo.set(key, false);\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar pyramidTransition = function(bottom, allowed) {\\n    const set = new Set(allowed);\\n    const memo = new Map();\\n    const chars = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\\n    \\n    return topDown(bottom, bottom.length - 1);\\n    \\n    function topDown(prev, row) {\\n        const key = `${prev}#${row}`;\\n        \\n        if (row === 0) return true;\\n        if (memo.has(key)) return memo.get(key);\\n\\n        let pats = new Set();\\n        pats.add(\"\");\\n\\n        for (let i = 0; i < row; i++) {\\n            const tmp = new Set();\\n\\n            const leftBot = prev.charAt(i);\\n            const rightBot = prev.charAt(i + 1);\\n\\n            for (const char of chars) {\\n                const triadStr = leftBot + rightBot + char;\\n\\n                if (set.has(triadStr)) {\\n                    for (const pat of pats) {\\n                        tmp.add(pat + char);\\n                    }                 \\n                }\\n            }\\n          \\n            pats = tmp;\\n        }\\n        \\n        for (const pat of pats) {\\n            if (topDown(pat, row - 1)) return true;\\n        }\\n        \\n        memo.set(key, false);\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1701421,
                "title": "c-solution-faster-than-100-00-dfs-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string, vector<char>> mapping;\\n        for (const string& s : allowed)\\n        {\\n            mapping[s.substr(0, 2)].push_back(s[2]);\\n        }\\n\\n        return dfs(bottom, \"\", mapping);\\n    }\\n    \\nprivate:\\n    unordered_map<string, bool> memo;\\n    bool dfs(string bottom, string top, unordered_map<string, vector<char>>& mapping)\\n    {\\n        if (bottom.size() == 2 && top.size() == 1)\\n        {\\n            return true;\\n        }\\n        \\n        if (memo.count(bottom))\\n            return memo[bottom];\\n        \\n        if (bottom.size() - top.size() == 1)\\n        {\\n            bool result = dfs(top, \"\", mapping);\\n            memo[top] = result;\\n            return result;\\n        }\\n        \\n        string sub = bottom.substr(top.size(), 2);\\n        if (mapping.count(sub) == 0)\\n            return false;\\n        \\n        for (char c : mapping[sub])\\n        {\\n            bool result = dfs(bottom, top + c, mapping);\\n            if (result)\\n            {\\n                memo[bottom] = true;\\n                return true;\\n            }\\n                \\n        }\\n        \\n        memo[bottom] = false;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string, vector<char>> mapping;\\n        for (const string& s : allowed)\\n        {\\n            mapping[s.substr(0, 2)].push_back(s[2]);\\n        }\\n\\n        return dfs(bottom, \"\", mapping);\\n    }\\n    \\nprivate:\\n    unordered_map<string, bool> memo;\\n    bool dfs(string bottom, string top, unordered_map<string, vector<char>>& mapping)\\n    {\\n        if (bottom.size() == 2 && top.size() == 1)\\n        {\\n            return true;\\n        }\\n        \\n        if (memo.count(bottom))\\n            return memo[bottom];\\n        \\n        if (bottom.size() - top.size() == 1)\\n        {\\n            bool result = dfs(top, \"\", mapping);\\n            memo[top] = result;\\n            return result;\\n        }\\n        \\n        string sub = bottom.substr(top.size(), 2);\\n        if (mapping.count(sub) == 0)\\n            return false;\\n        \\n        for (char c : mapping[sub])\\n        {\\n            bool result = dfs(bottom, top + c, mapping);\\n            if (result)\\n            {\\n                memo[bottom] = true;\\n                return true;\\n            }\\n                \\n        }\\n        \\n        memo[bottom] = false;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184250,
                "title": "java-dfs-solution-with-photo-and-comments-beat-99-55-95-09",
                "content": "![image](https://assets.leetcode.com/users/images/74ab3179-9867-4482-a3c1-8b882b2e7837_1619799424.1245065.png)\\n```java\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        final int[][] pyramid = new int[8][8];\\n        // if BCD, the depth is 2, so depth = bottom.length() - 1\\n        final int depth = bottom.length() - 1;\\n        // convert char to int, then fill the bottom of pyramid\\n        for (int i = 0; i < bottom.length(); i++) {\\n            pyramid[depth][i] = bottom.charAt(i) - \\'A\\';\\n        }\\n        // 3 dimensional array to store allowed\\n        final boolean[][][] candidates = new boolean[7][7][7];\\n        // A -> 0, B -> 1, c -> 2 ...\\n        for (String a : allowed) {\\n            candidates[a.charAt(0) - \\'A\\'][a.charAt(1) - \\'A\\'][a.charAt(2) - \\'A\\'] = true;\\n        }\\n        // dfs to solve pyramid\\n        return dfs(pyramid, depth, 0, candidates);\\n    }\\n\\n    private boolean dfs(int[][] pyramid, int depth, int index, boolean[][][] candidates) {\\n        // end condition, if we can reach the top of pyramid, return true\\n        if (depth == 0 && index == 0) {\\n            return true;\\n        }\\n        // depth == index means that we finish this level, now go to level - 1\\n        if (depth == index) {\\n            return dfs(pyramid, depth - 1, 0, candidates);\\n        }\\n        // foreach index, we retrieve the itself and the int after it.\\n        final int first = pyramid[depth][index];\\n        final int second = pyramid[depth][index + 1];\\n        // check whether we could find the third char(represent by int) in candidates\\n        for (int i = 0; i < 7; i++) {\\n            if (candidates[first][second][i]) {\\n                // if found, set it to the position [level - 1][index]\\n                pyramid[depth - 1][index] = i;\\n                // then dfs, if return true, it means we could reach the top, else try other possibility\\n                if (dfs(pyramid, depth, index + 1, candidates)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```java\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        final int[][] pyramid = new int[8][8];\\n        // if BCD, the depth is 2, so depth = bottom.length() - 1\\n        final int depth = bottom.length() - 1;\\n        // convert char to int, then fill the bottom of pyramid\\n        for (int i = 0; i < bottom.length(); i++) {\\n            pyramid[depth][i] = bottom.charAt(i) - \\'A\\';\\n        }\\n        // 3 dimensional array to store allowed\\n        final boolean[][][] candidates = new boolean[7][7][7];\\n        // A -> 0, B -> 1, c -> 2 ...\\n        for (String a : allowed) {\\n            candidates[a.charAt(0) - \\'A\\'][a.charAt(1) - \\'A\\'][a.charAt(2) - \\'A\\'] = true;\\n        }\\n        // dfs to solve pyramid\\n        return dfs(pyramid, depth, 0, candidates);\\n    }\\n\\n    private boolean dfs(int[][] pyramid, int depth, int index, boolean[][][] candidates) {\\n        // end condition, if we can reach the top of pyramid, return true\\n        if (depth == 0 && index == 0) {\\n            return true;\\n        }\\n        // depth == index means that we finish this level, now go to level - 1\\n        if (depth == index) {\\n            return dfs(pyramid, depth - 1, 0, candidates);\\n        }\\n        // foreach index, we retrieve the itself and the int after it.\\n        final int first = pyramid[depth][index];\\n        final int second = pyramid[depth][index + 1];\\n        // check whether we could find the third char(represent by int) in candidates\\n        for (int i = 0; i < 7; i++) {\\n            if (candidates[first][second][i]) {\\n                // if found, set it to the position [level - 1][index]\\n                pyramid[depth - 1][index] = i;\\n                // then dfs, if return true, it means we could reach the top, else try other possibility\\n                if (dfs(pyramid, depth, index + 1, candidates)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 921324,
                "title": "python3-progressively-building-new-rows",
                "content": "\\n```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mp = {}\\n        for x, y, z in allowed: mp.setdefault((x, y), set()).add(z)\\n            \\n        def fn(row): \\n            \"\"\"Return list of rows built from given row.\"\"\"\\n            ans = [\"\"]\\n            for x, y in zip(row, row[1:]):\\n                if (x, y) not in mp: return []\\n                ans = [xx + zz for xx in ans for zz in mp[x, y]]\\n            return ans \\n        \\n        # dfs \\n        stack = [bottom]\\n        while stack: \\n            row = stack.pop()\\n            if len(row) == 1: return True \\n            stack.extend(fn(row))\\n        return False \\n```\\n\\n\\n```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mp = {}\\n        for x, y, z in allowed: mp.setdefault((x, y), set()).add(z)\\n            \\n        def fn(row):\\n            \"\"\"Return True if row could be built.\"\"\"\\n            if len(row) == 1: return True \\n            for xx in product(*(mp.get((x, y), []) for x, y in zip(row, row[1:]))): \\n                if fn(xx): return True \\n            return False \\n        \\n        return fn(bottom)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mp = {}\\n        for x, y, z in allowed: mp.setdefault((x, y), set()).add(z)\\n            \\n        def fn(row): \\n            \"\"\"Return list of rows built from given row.\"\"\"\\n            ans = [\"\"]\\n            for x, y in zip(row, row[1:]):\\n                if (x, y) not in mp: return []\\n                ans = [xx + zz for xx in ans for zz in mp[x, y]]\\n            return ans \\n        \\n        # dfs \\n        stack = [bottom]\\n        while stack: \\n            row = stack.pop()\\n            if len(row) == 1: return True \\n            stack.extend(fn(row))\\n        return False \\n```\n```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mp = {}\\n        for x, y, z in allowed: mp.setdefault((x, y), set()).add(z)\\n            \\n        def fn(row):\\n            \"\"\"Return True if row could be built.\"\"\"\\n            if len(row) == 1: return True \\n            for xx in product(*(mp.get((x, y), []) for x, y in zip(row, row[1:]))): \\n                if fn(xx): return True \\n            return False \\n        \\n        return fn(bottom)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454869,
                "title": "faster-than-95-cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<string,set<char>> m;\\n    \\n    bool fun(string b,string s,int i)\\n    {\\n        if(b.length()==1)\\n        return true;\\n        \\n        if(i==b.length()-1)\\n        return fun(s,\"\",0);\\n        \\n        string a=b.substr(i,2);\\n        for(char ch:m[a])\\n        {\\n            string n=s+ch;\\n            if(fun(b,n,i+1))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool pyramidTransition(string b, vector<string>& all) {\\n        for(string i:all)\\n        m[i.substr(0,2)].insert(i[2]);\\n        return fun(b,\"\",0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<string,set<char>> m;\\n    \\n    bool fun(string b,string s,int i)\\n    {\\n        if(b.length()==1)\\n        return true;\\n        \\n        if(i==b.length()-1)\\n        return fun(s,\"\",0);\\n        \\n        string a=b.substr(i,2);\\n        for(char ch:m[a])\\n        {\\n            string n=s+ch;\\n            if(fun(b,n,i+1))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool pyramidTransition(string b, vector<string>& all) {\\n        for(string i:all)\\n        m[i.substr(0,2)].insert(i[2]);\\n        return fun(b,\"\",0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453193,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n    unordered_set<string> invalid;\\n    bool solve(string bottom, int i, unordered_map<string,string> mp, string z)\\n    {\\n        int n=bottom.size();\\n        int m=z.size();\\n        if(n<2)\\n        return true;\\n        if(invalid.count(bottom))\\n        return false;\\n        if(m==n-1)\\n        return solve(z, 0, mp, \"\");\\n        if(m>1 && mp.find(z.substr(m-2,2))==mp.end())\\n        return false;\\n        for(char ch:mp[bottom.substr(i,2)]){\\n            z.push_back(ch);\\n            if(solve(bottom, i+1, mp, z))\\n            return true;\\n            z.pop_back();\\n        }\\n        invalid.insert(bottom);\\n        return false;\\n    }\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string,string> mp;\\n        for(int i=0;i<allowed.size();i++)\\n        {\\n            mp[allowed[i].substr(0,2)].push_back(allowed[i][2]);\\n        }\\n        return solve(bottom, 0, mp, \"\");\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        n = len(bottom)\\n        mat = [[(\\'X\\', -1) for _ in range(n-1-i)] for i in range(n-1)]\\n        stack = [(row, l-row) for l in range(n-1) for row in range(l+1)]\\n        mapping = {}\\n        for a in allowed:\\n            if a[:2] not in mapping:\\n                mapping[a[:2]] = [a[2]]\\n            else:\\n                mapping[a[:2]].append(a[2])\\n        pos = 0\\n        def find_parents(row, col):\\n            if row == 0:\\n                return bottom[col:col+2]\\n            return mat[row-1][col][0] + mat[row-1][col+1][0]\\n\\n        while pos >= 0 and pos < len(stack):\\n            row, col = stack[pos]\\n            me, idx = mat[row][col]\\n            parents = find_parents(row, col)\\n            options = mapping.get(parents, [])\\n            if idx+1 < len(options):\\n                idx += 1\\n                me = options[idx]\\n                mat[row][col] = (me, idx)\\n                pos += 1\\n            else:\\n                pos -= 1\\n        return pos >= len(stack)\\n```\\n\\n```Java []\\nclass Solution {\\n  public boolean pyramidTransition(String bottom, List<String> allowed) {\\n    Map<String, Set<Character>> map = new HashMap<>();\\n    for (String s : allowed) {\\n      String k = s.substring(0, 2);\\n      Set<Character> set = map.getOrDefault(k, new HashSet<>());\\n      set.add(s.charAt(2));\\n      map.put(k, set);\\n    }\\n    Map<String, Integer> dp = new HashMap<>();\\n    boolean res = search2(bottom + \"#\", map, dp);\\n    return res;\\n  }\\n  private boolean search2(String s, Map<String, Set<Character>> map, Map<String, Integer> dp) {\\n    if (s.length() == 1) return true;\\n    if (dp.containsKey(s)) return dp.get(s) == 1;\\n    String key = s.substring(0, 2);\\n    if (key.charAt(1) == \\'#\\') return search2(s.substring(2) + \"#\", map, dp);\\n    for (Character c : map.getOrDefault(key, new HashSet<>())) {\\n      boolean r = search2(s.substring(1) + c, map, dp);\\n      if (r) {\\n        dp.put(s, 1);\\n        return true;\\n      }\\n    }\\n    dp.put(s, 0);\\n    return false;\\n  }\\n  private boolean search(String s, Map<String, Set<Character>> map, Map<String, Integer> dp) {\\n    if (s.length() == 2) {\\n      return map.containsKey(s);\\n    }\\n    if (s.length() < 2) return false;\\n    List<String> nextLevel = new ArrayList<>();\\n    nextLevel.add(\"\");\\n    for (int i = 0; i < s.length() - 1; i++) {\\n      List<String> list = new ArrayList<>();\\n      String k = s.substring(i, i + 2);\\n      if (!map.containsKey(k)) return false;\\n      for (Character e : map.get(k)) {\\n        for (String ps : nextLevel) {\\n          list.add(ps + e);\\n        }\\n      }\\n      nextLevel = list;\\n    }\\n    boolean res = false;\\n    for (String e : nextLevel) {\\n      res = search(e, map, dp);\\n      if (res) return true;\\n    }\\n    return false;\\n  } \\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n    unordered_set<string> invalid;\\n    bool solve(string bottom, int i, unordered_map<string,string> mp, string z)\\n    {\\n        int n=bottom.size();\\n        int m=z.size();\\n        if(n<2)\\n        return true;\\n        if(invalid.count(bottom))\\n        return false;\\n        if(m==n-1)\\n        return solve(z, 0, mp, \"\");\\n        if(m>1 && mp.find(z.substr(m-2,2))==mp.end())\\n        return false;\\n        for(char ch:mp[bottom.substr(i,2)]){\\n            z.push_back(ch);\\n            if(solve(bottom, i+1, mp, z))\\n            return true;\\n            z.pop_back();\\n        }\\n        invalid.insert(bottom);\\n        return false;\\n    }\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string,string> mp;\\n        for(int i=0;i<allowed.size();i++)\\n        {\\n            mp[allowed[i].substr(0,2)].push_back(allowed[i][2]);\\n        }\\n        return solve(bottom, 0, mp, \"\");\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        n = len(bottom)\\n        mat = [[(\\'X\\', -1) for _ in range(n-1-i)] for i in range(n-1)]\\n        stack = [(row, l-row) for l in range(n-1) for row in range(l+1)]\\n        mapping = {}\\n        for a in allowed:\\n            if a[:2] not in mapping:\\n                mapping[a[:2]] = [a[2]]\\n            else:\\n                mapping[a[:2]].append(a[2])\\n        pos = 0\\n        def find_parents(row, col):\\n            if row == 0:\\n                return bottom[col:col+2]\\n            return mat[row-1][col][0] + mat[row-1][col+1][0]\\n\\n        while pos >= 0 and pos < len(stack):\\n            row, col = stack[pos]\\n            me, idx = mat[row][col]\\n            parents = find_parents(row, col)\\n            options = mapping.get(parents, [])\\n            if idx+1 < len(options):\\n                idx += 1\\n                me = options[idx]\\n                mat[row][col] = (me, idx)\\n                pos += 1\\n            else:\\n                pos -= 1\\n        return pos >= len(stack)\\n```\n```Java []\\nclass Solution {\\n  public boolean pyramidTransition(String bottom, List<String> allowed) {\\n    Map<String, Set<Character>> map = new HashMap<>();\\n    for (String s : allowed) {\\n      String k = s.substring(0, 2);\\n      Set<Character> set = map.getOrDefault(k, new HashSet<>());\\n      set.add(s.charAt(2));\\n      map.put(k, set);\\n    }\\n    Map<String, Integer> dp = new HashMap<>();\\n    boolean res = search2(bottom + \"#\", map, dp);\\n    return res;\\n  }\\n  private boolean search2(String s, Map<String, Set<Character>> map, Map<String, Integer> dp) {\\n    if (s.length() == 1) return true;\\n    if (dp.containsKey(s)) return dp.get(s) == 1;\\n    String key = s.substring(0, 2);\\n    if (key.charAt(1) == \\'#\\') return search2(s.substring(2) + \"#\", map, dp);\\n    for (Character c : map.getOrDefault(key, new HashSet<>())) {\\n      boolean r = search2(s.substring(1) + c, map, dp);\\n      if (r) {\\n        dp.put(s, 1);\\n        return true;\\n      }\\n    }\\n    dp.put(s, 0);\\n    return false;\\n  }\\n  private boolean search(String s, Map<String, Set<Character>> map, Map<String, Integer> dp) {\\n    if (s.length() == 2) {\\n      return map.containsKey(s);\\n    }\\n    if (s.length() < 2) return false;\\n    List<String> nextLevel = new ArrayList<>();\\n    nextLevel.add(\"\");\\n    for (int i = 0; i < s.length() - 1; i++) {\\n      List<String> list = new ArrayList<>();\\n      String k = s.substring(i, i + 2);\\n      if (!map.containsKey(k)) return false;\\n      for (Character e : map.get(k)) {\\n        for (String ps : nextLevel) {\\n          list.add(ps + e);\\n        }\\n      }\\n      nextLevel = list;\\n    }\\n    boolean res = false;\\n    for (String e : nextLevel) {\\n      res = search(e, map, dp);\\n      if (res) return true;\\n    }\\n    return false;\\n  } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170883,
                "title": "c-solution-beats-90-memoization",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string,vector<char>>dp;\\n    unordered_map<string,bool>mem;\\n    bool backtrack(string bottom,string next,int index){\\n        //if we only have a single length pattern then return true\\n        if(bottom.size()==1){\\n            return mem[bottom]=true;\\n        } else if(next.size()==bottom.size()-1){\\n            //if the pattern of the next layer is complete, then it will become the \\n            //new bottom and the next layer becomes empty again. Index gets set to 0\\n            //as we have to start all over again on this next layer\\n            return backtrack(next,\"\",0);\\n        } else if(mem.count(bottom)){\\n            return mem[bottom];\\n        } else {\\n            //iterate through all the possible allowed patterns and if any valid pattern\\n            //is found return true\\n            string key=bottom.substr(index,2);\\n            for(int i=0;i<dp[key].size();i++){\\n                next.push_back(dp[key][i]);\\n                bool isAns=backtrack(bottom,next,index+1);\\n                if(isAns){\\n                    return mem[bottom]=true;\\n                }\\n                next.pop_back();\\n            }\\n            //else return false\\n            return mem[bottom]=false;\\n        }\\n    }\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        //storing all the allowed triangular patterns\\n        for(int i=0;i<allowed.size();i++){\\n            dp[allowed[i].substr(0,2)].push_back(allowed[i][2]);\\n        }\\n        return backtrack(bottom,\"\",0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string,vector<char>>dp;\\n    unordered_map<string,bool>mem;\\n    bool backtrack(string bottom,string next,int index){\\n        //if we only have a single length pattern then return true\\n        if(bottom.size()==1){\\n            return mem[bottom]=true;\\n        } else if(next.size()==bottom.size()-1){\\n            //if the pattern of the next layer is complete, then it will become the \\n            //new bottom and the next layer becomes empty again. Index gets set to 0\\n            //as we have to start all over again on this next layer\\n            return backtrack(next,\"\",0);\\n        } else if(mem.count(bottom)){\\n            return mem[bottom];\\n        } else {\\n            //iterate through all the possible allowed patterns and if any valid pattern\\n            //is found return true\\n            string key=bottom.substr(index,2);\\n            for(int i=0;i<dp[key].size();i++){\\n                next.push_back(dp[key][i]);\\n                bool isAns=backtrack(bottom,next,index+1);\\n                if(isAns){\\n                    return mem[bottom]=true;\\n                }\\n                next.pop_back();\\n            }\\n            //else return false\\n            return mem[bottom]=false;\\n        }\\n    }\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        //storing all the allowed triangular patterns\\n        for(int i=0;i<allowed.size();i++){\\n            dp[allowed[i].substr(0,2)].push_back(allowed[i][2]);\\n        }\\n        return backtrack(bottom,\"\",0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998277,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        dic=defaultdict(set)\\n        for x,y,z in allowed:\\n            dic[x+y].add(z)\\n        @cache\\n        def gett(i,arr,l=\\'\\'):\\n            if len(arr)==1:return True\\n            if i+1==len(arr):\\n                return gett(0,l,\\'\\')       \\n            for x in dic[arr[i]+arr[i+1]]:\\n                if l and not dic[l[-1]+x]:\\n                    continue\\n                if gett(i+1,arr,l+x):\\n                    return True\\n            return False\\n        return gett(0,bottom)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        dic=defaultdict(set)\\n        for x,y,z in allowed:\\n            dic[x+y].add(z)\\n        @cache\\n        def gett(i,arr,l=\\'\\'):\\n            if len(arr)==1:return True\\n            if i+1==len(arr):\\n                return gett(0,l,\\'\\')       \\n            for x in dic[arr[i]+arr[i+1]]:\\n                if l and not dic[l[-1]+x]:\\n                    continue\\n                if gett(i+1,arr,l+x):\\n                    return True\\n            return False\\n        return gett(0,bottom)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684955,
                "title": "python-recursion-memoization",
                "content": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        allowed=set(allowed)\\n        letters=[\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\']\\n        @lru_cache(None)\\n        def solve(bottom):\\n            if len(bottom)==1: return True\\n            tops=[\"\"]\\n            n=len(bottom)\\n            ans=False\\n            for i in range(n-1):\\n                temp=[]\\n                while tops:\\n                    top=tops.pop(0)\\n                    for letter in letters:\\n                        if bottom[i]+bottom[i+1]+letter in allowed:\\n                            temp.append(top+letter)\\n                tops=temp\\n            for top in tops:\\n                ans=ans or solve(top)\\n            return ans\\n        return solve(bottom)\\n                    \\n                \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        allowed=set(allowed)\\n        letters=[\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\']\\n        @lru_cache(None)\\n        def solve(bottom):\\n            if len(bottom)==1: return True\\n            tops=[\"\"]\\n            n=len(bottom)\\n            ans=False\\n            for i in range(n-1):\\n                temp=[]\\n                while tops:\\n                    top=tops.pop(0)\\n                    for letter in letters:\\n                        if bottom[i]+bottom[i+1]+letter in allowed:\\n                            temp.append(top+letter)\\n                tops=temp\\n            for top in tops:\\n                ans=ans or solve(top)\\n            return ans\\n        return solve(bottom)\\n                    \\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333996,
                "title": "clean-python-backtrack-solution",
                "content": "Other python posts look like a mess so I added mine :D\\n\\n\\n```\\nimport collections\\n\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        \\n        pair_to_top = collections.defaultdict(lambda: [])\\n        for triple in allowed:\\n            pair_to_top[triple[0:2]].append(triple[2])\\n        \\n        def checkPyramid(bottom_list, next_list):\\n            if len(bottom_list) == 1:\\n                return True\\n            if len(next_list) == len(bottom_list) - 1:\\n                new_next_list = []\\n                return checkPyramid(next_list, new_next_list)\\n        \\n            # fill remaining values for next_list\\n            for i in range(len(next_list), len(bottom_list) - 1):\\n                pair = bottom_list[i] + bottom_list[i + 1]\\n                if len(pair_to_top[pair]) == 0:\\n                    return False\\n                \\n                # from all possible values.\\n                for top in pair_to_top[pair]:\\n                    # choose one\\n                    next_list.append(top)\\n                    if checkPyramid(bottom_list, next_list):\\n                        return True\\n                    # backtrack\\n                    next_list.pop()\\n            return False\\n        \\n        next_list = []\\n        bottom_list = [i for i in bottom]\\n        return checkPyramid(bottom_list, next_list)\\n\\t```",
                "solutionTags": [],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        \\n        pair_to_top = collections.defaultdict(lambda: [])\\n        for triple in allowed:\\n            pair_to_top[triple[0:2]].append(triple[2])\\n        \\n        def checkPyramid(bottom_list, next_list):\\n            if len(bottom_list) == 1:\\n                return True\\n            if len(next_list) == len(bottom_list) - 1:\\n                new_next_list = []\\n                return checkPyramid(next_list, new_next_list)\\n        \\n            # fill remaining values for next_list\\n            for i in range(len(next_list), len(bottom_list) - 1):\\n                pair = bottom_list[i] + bottom_list[i + 1]\\n                if len(pair_to_top[pair]) == 0:\\n                    return False\\n                \\n                # from all possible values.\\n                for top in pair_to_top[pair]:\\n                    # choose one\\n                    next_list.append(top)\\n                    if checkPyramid(bottom_list, next_list):\\n                        return True\\n                    # backtrack\\n                    next_list.pop()\\n            return False\\n        \\n        next_list = []\\n        bottom_list = [i for i in bottom]\\n        return checkPyramid(bottom_list, next_list)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1304813,
                "title": "c-clean-code-using-backtracking-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\nbool help(string &bottom,int dp[1001],string next){\\n    if(bottom.size()==1) return true;\\n    if(next.size()==bottom.size()-1){\\n        return help(next,dp,\"\");    //    \"next\" becomes the new \"bottom\"\\n    }\\n    for(int j=0;j<7;j++){\\n        // \\'A\\'+j is above bottom[next.size()] and bottom[next.size()+1]\\n        if(dp[100*(bottom[next.size()]-\\'A\\')+10*(bottom[next.size()+1]-\\'A\\')+j]){\\n            next.push_back(\\'A\\'+j);\\n            bool z= help(bottom,dp,next);\\n            if(z) return true;\\n            next.pop_back();\\n        }\\n    }\\n    return false;\\n}\\n\\nbool pyramidTransition(string bottom, vector<string> &allowed)\\n{\\n    int dp[1001]={0};\\n    for(auto it:allowed){\\n        int cur=100*(it[0]-\\'A\\')+10*(it[1]-\\'A\\')+it[2]-\\'A\\';   \\n        //  if \"ABF\" is allowed, then storing this allowed configuration as digits in dp\\n        //  so, \"ABF\" is interpreted as 126 and dp[126] becomes true  \\n        dp[cur]=1;\\n    }\\n    string nxt=\"\";\\n    return help(bottom,dp,nxt);\\n}\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nbool help(string &bottom,int dp[1001],string next){\\n    if(bottom.size()==1) return true;\\n    if(next.size()==bottom.size()-1){\\n        return help(next,dp,\"\");    //    \"next\" becomes the new \"bottom\"\\n    }\\n    for(int j=0;j<7;j++){\\n        // \\'A\\'+j is above bottom[next.size()] and bottom[next.size()+1]\\n        if(dp[100*(bottom[next.size()]-\\'A\\')+10*(bottom[next.size()+1]-\\'A\\')+j]){\\n            next.push_back(\\'A\\'+j);\\n            bool z= help(bottom,dp,next);\\n            if(z) return true;\\n            next.pop_back();\\n        }\\n    }\\n    return false;\\n}\\n\\nbool pyramidTransition(string bottom, vector<string> &allowed)\\n{\\n    int dp[1001]={0};\\n    for(auto it:allowed){\\n        int cur=100*(it[0]-\\'A\\')+10*(it[1]-\\'A\\')+it[2]-\\'A\\';   \\n        //  if \"ABF\" is allowed, then storing this allowed configuration as digits in dp\\n        //  so, \"ABF\" is interpreted as 126 and dp[126] becomes true  \\n        dp[cur]=1;\\n    }\\n    string nxt=\"\";\\n    return help(bottom,dp,nxt);\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271624,
                "title": "90-faster-dfs-c",
                "content": "```\\nclass Solution {\\n    map<pair<char, char>, vector<char>> m;\\npublic:\\n    bool canMake(string cur, string nxt, int idx) {\\n        if(cur.size() == 1) return true;\\n        if(cur.size()==2) return (m[{cur[0], cur[1]}].size()>=1);\\n        if(idx==cur.size()) return canMake(nxt, \"\", 1);\\n        \\n        pair<char, char> p = {cur[idx-1], cur[idx]};\\n        \\n        for(int i=0; i<m[p].size(); i++) \\n            if(canMake(cur, nxt + m[p][i], idx+1)) return true;\\n        \\n        return false;\\n    }\\n    \\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        m.clear();\\n        \\n        for(int i=0; i<allowed.size(); i++) \\n            m[{allowed[i][0], allowed[i][1]}].push_back(allowed[i][2]);\\n        \\n        return canMake(bottom, \"\", 1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    map<pair<char, char>, vector<char>> m;\\npublic:\\n    bool canMake(string cur, string nxt, int idx) {\\n        if(cur.size() == 1) return true;\\n        if(cur.size()==2) return (m[{cur[0], cur[1]}",
                "codeTag": "Java"
            },
            {
                "id": 1043827,
                "title": "c-backtracking-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<char>> mp;\\n    \\n    bool backtrack(string &bottom,int i,string &curr){\\n        if(bottom.size()==1)\\n            return true;\\n        if(i==bottom.size()-1){\\n            string s=\"\";\\n            return backtrack(curr,0,s);\\n        }\\n        string tt=bottom.substr(i,2);\\n        if(mp.find(tt)==mp.end())\\n            return false;\\n        for(auto u:mp[tt]){\\n            curr.push_back(u);\\n            if(backtrack(bottom,i+1,curr))\\n                return true;\\n            curr.pop_back();\\n        }\\n        return false;\\n    }\\n\\t\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        for(auto u:allowed){\\n            mp[u.substr(0,2)].push_back(u[2]);\\n        }\\n        string s=\"\";\\n        return backtrack(bottom,0,s);\\n    }\\n};\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_map<string,vector<char>> mp;\\n    \\n    bool backtrack(string &bottom,int i,string &curr){\\n        if(bottom.size()==1)\\n            return true;\\n        if(i==bottom.size()-1){\\n            string s=\"\";\\n            return backtrack(curr,0,s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1023805,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool trans(string s, unordered_map<string, vector<char>>& m, int start, string t){\\n        if(s.length() == 1) return true;\\n        if(start == s.length() - 1) return trans(t, m, 0, \"\");\\n        \\n        string temp = s.substr(start, 2);\\n        if(m.count(temp) == 0) return false;\\n        \\n        for(int i: m.at(temp)){\\n            t.push_back(i);\\n            if(trans(s, m, start + 1, t) == true) return true;\\n            t.pop_back();\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string, vector<char>> m;\\n        \\n        for(string s: allowed) m[s.substr(0, 2)].push_back(s.at(2));\\n \\n        return trans(bottom, m, 0, \"\");\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool trans(string s, unordered_map<string, vector<char>>& m, int start, string t){\\n        if(s.length() == 1) return true;\\n        if(start == s.length() - 1) return trans(t, m, 0, \"\");\\n        \\n        string temp = s.substr(start, 2);\\n        if(m.count(temp) == 0) return false;\\n        \\n        for(int i: m.at(temp)){\\n            t.push_back(i);\\n            if(trans(s, m, start + 1, t) == true) return true;\\n            t.pop_back();\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string, vector<char>> m;\\n        \\n        for(string s: allowed) m[s.substr(0, 2)].push_back(s.at(2));\\n \\n        return trans(bottom, m, 0, \"\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987707,
                "title": "java-beats-100-dfs-using-bitset-map-and-single-char-array",
                "content": "**Approach:** Start with bottom layer and build upper layer by applying all possible parents for each 2 characters. Repeat the process for upper layer until we reach the topmost layer (of length 1). We can do this using DFS or BFS.\\n\\n**Optimization 1:** To speed up figuring out parents for 2 characters, build a map of allowed parents for each 2 characters. We can use an ```ArrayList``` of characters as the value in this map. Alternatively, we could store this ```ArrayList``` data in a single integer by using bitset concept i.e. ```i```\\'th bit is set to 1 to represent that ```i```\\'th character is present (remember, we\\'re dealing with just 7 characters).\\n\\n**Optimization 2:** We don\\'t really need 2 ```Strings/StringBuilders/char arrays``` for current and next layers. We could just use a single char array and maintain a length variable to represent which layer we\\'re in. We could read the map value using ```c[i]``` and ```c[i+1]``` as key and save ```c[i]``` value temporarily. After this, we\\'re free to replace ```c[i]``` using all possible parent values. In the end, we restore ```c[i]```\\'s value back using its saved value.\\n\\n```\\n// 0 ms. 100%\\nprivate boolean dfs(char[] c, int i, int L, int[][] map) {\\n    if(L == 1) return true;\\n    if(i == L - 1) return dfs(c, 0, L - 1, map);\\n    char save = c[i], p = \\'A\\';\\n    for(int v = map[c[i] - \\'A\\'][c[i + 1] - \\'A\\']; v != 0; v >>= 1, p++) if((v & 1) != 0) {\\n        c[i] = p;\\n        if(dfs(c, i + 1, L, map)) return true;\\n    }\\n    c[i] = save;\\n    return false;\\n}\\npublic boolean pyramidTransition(String bottom, List<String> allowed) {\\n    int[][] map = new int[7][7];\\n    for(String s: allowed) map[s.charAt(0) - \\'A\\'][s.charAt(1) - \\'A\\'] |= 1 << (s.charAt(2) - \\'A\\');\\n    return dfs(bottom.toCharArray(), 0, bottom.length(), map);\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```ArrayList```\n```ArrayList```\n```i```\n```i```\n```Strings/StringBuilders/char arrays```\n```c[i]```\n```c[i+1]```\n```c[i]```\n```c[i]```\n```c[i]```\n```\\n// 0 ms. 100%\\nprivate boolean dfs(char[] c, int i, int L, int[][] map) {\\n    if(L == 1) return true;\\n    if(i == L - 1) return dfs(c, 0, L - 1, map);\\n    char save = c[i], p = \\'A\\';\\n    for(int v = map[c[i] - \\'A\\'][c[i + 1] - \\'A\\']; v != 0; v >>= 1, p++) if((v & 1) != 0) {\\n        c[i] = p;\\n        if(dfs(c, i + 1, L, map)) return true;\\n    }\\n    c[i] = save;\\n    return false;\\n}\\npublic boolean pyramidTransition(String bottom, List<String> allowed) {\\n    int[][] map = new int[7][7];\\n    for(String s: allowed) map[s.charAt(0) - \\'A\\'][s.charAt(1) - \\'A\\'] |= 1 << (s.charAt(2) - \\'A\\');\\n    return dfs(bottom.toCharArray(), 0, bottom.length(), map);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 951913,
                "title": "c-backtracking-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool backtrack(int l, deque<char> new_bottom, deque<char> old_bottom, unordered_map<string, vector<char>> &um){\\n        if(old_bottom.size() == 1) return true;\\n        if(l == old_bottom.size()-1){\\n            deque<char> d;\\n            return backtrack(0, d, new_bottom, um);\\n        }\\n\\n        char c1 = old_bottom[l];\\n        char c2 = old_bottom[l+1];\\n        string key = string(1, c1) + c2;\\n        if(!um.count(key)) return false;\\n        for(char c: um[key]){\\n            new_bottom.push_back(c);\\n            if(backtrack(l+1, new_bottom, old_bottom, um) == true){\\n                return true;\\n            }\\n            new_bottom.pop_back();\\n        }\\n        return false;\\n    }\\n\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string, vector<char>> um;\\n        for(int i=0; i<allowed.size(); i++){\\n            um[allowed[i].substr(0, 2)].push_back(allowed[i][2]);\\n        }\\n        deque<char> old_bottom,  new_bottom;\\n        for(char c:bottom){\\n            old_bottom.push_back(c);\\n        } \\n        return backtrack(0, new_bottom, old_bottom, um);       \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool backtrack(int l, deque<char> new_bottom, deque<char> old_bottom, unordered_map<string, vector<char>> &um){\\n        if(old_bottom.size() == 1) return true;\\n        if(l == old_bottom.size()-1){\\n            deque<char> d;\\n            return backtrack(0, d, new_bottom, um);\\n        }\\n\\n        char c1 = old_bottom[l];\\n        char c2 = old_bottom[l+1];\\n        string key = string(1, c1) + c2;\\n        if(!um.count(key)) return false;\\n        for(char c: um[key]){\\n            new_bottom.push_back(c);\\n            if(backtrack(l+1, new_bottom, old_bottom, um) == true){\\n                return true;\\n            }\\n            new_bottom.pop_back();\\n        }\\n        return false;\\n    }\\n\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string, vector<char>> um;\\n        for(int i=0; i<allowed.size(); i++){\\n            um[allowed[i].substr(0, 2)].push_back(allowed[i][2]);\\n        }\\n        deque<char> old_bottom,  new_bottom;\\n        for(char c:bottom){\\n            old_bottom.push_back(c);\\n        } \\n        return backtrack(0, new_bottom, old_bottom, um);       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888728,
                "title": "python-recursion",
                "content": "At each step, try all possible color codes. Here I used a recursive implementation (and I have to confess it runs slow, the solution is accepted anyway).\\n\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        def recur(s):\\n            if res[0]:\\n                return\\n            if len(s)==1:\\n                res[0] = True\\n                return\\n            nex = []\\n            for i in range(len(s)-1):\\n                key = \\'\\'.join([s[i],s[i+1]])\\n                nex.append(h[key])\\n            if any((len(x)==0 for x in nex)):\\n                return\\n            nex2 = [\\'\\']\\n            for x in nex:\\n                tmp = []\\n                for y in x:\\n                    for z in nex2:\\n                        if z+y not in tmp:\\n                            tmp.append(z+y)\\n                nex2 = tmp\\n            for e in nex2:\\n                recur(e)\\n        \\n        h = defaultdict(list)\\n        for e in allowed:\\n            key = \\'\\'.join(e[:2])\\n            h[key].append(e[2])\\n        res = [False]\\n        \\n        recur(bottom)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        def recur(s):\\n            if res[0]:\\n                return\\n            if len(s)==1:\\n                res[0] = True\\n                return\\n            nex = []\\n            for i in range(len(s)-1):\\n                key = \\'\\'.join([s[i],s[i+1]])\\n                nex.append(h[key])\\n            if any((len(x)==0 for x in nex)):\\n                return\\n            nex2 = [\\'\\']\\n            for x in nex:\\n                tmp = []\\n                for y in x:\\n                    for z in nex2:\\n                        if z+y not in tmp:\\n                            tmp.append(z+y)\\n                nex2 = tmp\\n            for e in nex2:\\n                recur(e)\\n        \\n        h = defaultdict(list)\\n        for e in allowed:\\n            key = \\'\\'.join(e[:2])\\n            h[key].append(e[2])\\n        res = [False]\\n        \\n        recur(bottom)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865335,
                "title": "c-solution-with-explanation",
                "content": "First we build  a mapping from first two letters of allowed to the last letter.\\nNext we form a layer above the bottom layer, by parsing through the the above mapping. The layer above the bottom layer will be \\none length shorter. When we make such string, we call the `pyramidTransition` function again, giving it the new bottom layer. \\nWhen we have reached to bottom layer of length one, means we have successfully build the tree, and hence return true.\\n\\n```\\nclass Solution {\\npublic:\\n    map<string, vector<string>> mp;\\n\\t\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        if(mp.size() == 0) {\\n            for(auto& s: allowed) {\\n                mp[s.substr(0,2)].push_back(s.substr(2,1));\\n            }\\n        }\\n        string t;\\n        return dfs(bottom, 0, allowed, t);\\n    }\\n    \\n    bool dfs(string b, int pos, vector<string>& allowed, string t) {\\n        if(b.size() == 1) return true;\\n        if(t.size() == b.size()-1) return pyramidTransition(t, allowed);\\n        bool ans = false;\\n        for(auto& e: mp[b.substr(pos, 2)]) {\\n            t.push_back(e[0]);\\n            ans = ans | dfs(b, pos+1, allowed, t);\\n            if(ans == true) break;\\n            t.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<string, vector<string>> mp;\\n\\t\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        if(mp.size() == 0) {\\n            for(auto& s: allowed) {\\n                mp[s.substr(0,2)].push_back(s.substr(2,1));\\n            }\\n        }\\n        string t;\\n        return dfs(bottom, 0, allowed, t);\\n    }\\n    \\n    bool dfs(string b, int pos, vector<string>& allowed, string t) {\\n        if(b.size() == 1) return true;\\n        if(t.size() == b.size()-1) return pyramidTransition(t, allowed);\\n        bool ans = false;\\n        for(auto& e: mp[b.substr(pos, 2)]) {\\n            t.push_back(e[0]);\\n            ans = ans | dfs(b, pos+1, allowed, t);\\n            if(ans == true) break;\\n            t.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825509,
                "title": "java-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\n    Map<String, List<String>> map;\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        // build map\\n        map = new HashMap<>();\\n        for(String s : allowed) {\\n            String key = s.substring(0, 2);\\n            String value = s.substring(2, 3);\\n            map.putIfAbsent(key, new ArrayList<>());\\n            map.get(key).add(value);\\n        }        \\n        return dfs(bottom);\\n    }\\n    \\n    private boolean dfs(String bottom) {\\n        if(bottom.length() == 1) return true;\\n        List<String> nextBottoms = new ArrayList<>();\\n        generateNextBottoms(bottom, nextBottoms, \"\", 0);        \\n        for(String next : nextBottoms) {\\n            if(dfs(next)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private void generateNextBottoms(String bottom, List<String> res, String cur, int i) {\\n        if(cur.length() == bottom.length() - 1) {\\n            res.add(cur);\\n            return;\\n        }\\n        String key = bottom.substring(i, i + 2);\\n        if(!map.containsKey(key)) {\\n            return;\\n        }\\n        List<String> values = map.get(key);\\n        for(String c : values) {\\n            generateNextBottoms(bottom, res, cur + c, i + 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<String, List<String>> map;\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        // build map\\n        map = new HashMap<>();\\n        for(String s : allowed) {\\n            String key = s.substring(0, 2);\\n            String value = s.substring(2, 3);\\n            map.putIfAbsent(key, new ArrayList<>());\\n            map.get(key).add(value);\\n        }        \\n        return dfs(bottom);\\n    }\\n    \\n    private boolean dfs(String bottom) {\\n        if(bottom.length() == 1) return true;\\n        List<String> nextBottoms = new ArrayList<>();\\n        generateNextBottoms(bottom, nextBottoms, \"\", 0);        \\n        for(String next : nextBottoms) {\\n            if(dfs(next)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    private void generateNextBottoms(String bottom, List<String> res, String cur, int i) {\\n        if(cur.length() == bottom.length() - 1) {\\n            res.add(cur);\\n            return;\\n        }\\n        String key = bottom.substring(i, i + 2);\\n        if(!map.containsKey(key)) {\\n            return;\\n        }\\n        List<String> values = map.get(key);\\n        for(String c : values) {\\n            generateNextBottoms(bottom, res, cur + c, i + 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824893,
                "title": "c-map-backtracking-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool  result = false;\\n    bool helper(const string &level, const int begin, const unordered_map<string, vector<string>> &mymap, string nextlevel)\\n    {\\n        if(begin == level.size() -1){\\n            //reached the end of current level.\\n            if(nextlevel.size() == 1) {\\n                // you reached the end of current level , and nextlevel size is 1, meaning top of the pyramid\\n                result = true;\\n                return true;\\n            }\\n            //make nextlevel as current level and continue;\\n            string nextnextlevel;\\n            return helper(nextlevel, 0, mymap, nextnextlevel);\\n        }\\n        bool rc = false;\\n        auto leaves = level.substr(begin, 2);//get leaves string\\n        auto mit = mymap.find(leaves);\\n        if(mit == mymap.end())\\n            return false;\\n        for(const auto &parent:mit->second){\\n            // for every parent which these leaves can map to, add the parent to nextlevel\\n            auto tsize = nextlevel.size();\\n            nextlevel.append(parent);\\n            rc |= helper(level, begin+1, mymap, nextlevel);\\n            nextlevel.erase(tsize);\\n            //if somewhere during backtracking recursion, there was solution found, break;\\n            if(result)\\n                break;\\n        }\\n        return rc;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        // build map of leaves to parent combinations.\\n        // leaves are the first 2 chars in the allowed string.\\n        // parent is the last char in the allowed string.\\n        unordered_map<string, vector<string>> mymap;\\n        for(const auto & a: allowed){\\n            mymap[a.substr(0,2)].push_back(a.substr(2,1));\\n        }\\n        string running;\\n        helper(bottom , 0, mymap, running);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool  result = false;\\n    bool helper(const string &level, const int begin, const unordered_map<string, vector<string>> &mymap, string nextlevel)\\n    {\\n        if(begin == level.size() -1){\\n            //reached the end of current level.\\n            if(nextlevel.size() == 1) {\\n                // you reached the end of current level , and nextlevel size is 1, meaning top of the pyramid\\n                result = true;\\n                return true;\\n            }\\n            //make nextlevel as current level and continue;\\n            string nextnextlevel;\\n            return helper(nextlevel, 0, mymap, nextnextlevel);\\n        }\\n        bool rc = false;\\n        auto leaves = level.substr(begin, 2);//get leaves string\\n        auto mit = mymap.find(leaves);\\n        if(mit == mymap.end())\\n            return false;\\n        for(const auto &parent:mit->second){\\n            // for every parent which these leaves can map to, add the parent to nextlevel\\n            auto tsize = nextlevel.size();\\n            nextlevel.append(parent);\\n            rc |= helper(level, begin+1, mymap, nextlevel);\\n            nextlevel.erase(tsize);\\n            //if somewhere during backtracking recursion, there was solution found, break;\\n            if(result)\\n                break;\\n        }\\n        return rc;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        // build map of leaves to parent combinations.\\n        // leaves are the first 2 chars in the allowed string.\\n        // parent is the last char in the allowed string.\\n        unordered_map<string, vector<string>> mymap;\\n        for(const auto & a: allowed){\\n            mymap[a.substr(0,2)].push_back(a.substr(2,1));\\n        }\\n        string running;\\n        helper(bottom , 0, mymap, running);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750063,
                "title": "c-dfs-99-time-98-space-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        vector<string> v(49);\\n        for (string& s : allowed) v[(s[0] - \\'A\\') * 7 + (s[1] - \\'A\\')].push_back(s[2]);\\n        return helper(v, bottom, \"\");\\n    }\\n    bool helper(vector<string>& v, string bottom, string build)\\n    {\\n        int n = build.length();\\n        if (bottom.length() == 1) return true;\\n        if (bottom.length() == n + 1) return helper(v, build, \"\");\\n        for (char& c : v[(bottom[n] - \\'A\\') * 7 + (bottom[n+1] - \\'A\\')]) if (helper(v, bottom, build + c)) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        vector<string> v(49);\\n        for (string& s : allowed) v[(s[0] - \\'A\\') * 7 + (s[1] - \\'A\\')].push_back(s[2]);\\n        return helper(v, bottom, \"\");\\n    }\\n    bool helper(vector<string>& v, string bottom, string build)\\n    {\\n        int n = build.length();\\n        if (bottom.length() == 1) return true;\\n        if (bottom.length() == n + 1) return helper(v, build, \"\");\\n        for (char& c : v[(bottom[n] - \\'A\\') * 7 + (bottom[n+1] - \\'A\\')]) if (helper(v, bottom, build + c)) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747715,
                "title": "short-python-dfs-solution",
                "content": "```\\nimport collections\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        d=collections.defaultdict(set)\\n        for u,v,w in allowed:\\n            d[(u,v)].add(w)\\n        return self.transition(bottom,d)\\n        \\n    def transition(self, bottom, d):\\n        if len(bottom)==1: return True\\n        def dfs(i,path):\\n            if i==len(bottom)-1:\\n                return self.transition(path,d)\\n            for color in d[(bottom[i],bottom[i+1])]:\\n                if dfs(i+1,path+color):\\n                    return True\\n            return False\\n        return dfs(0,\\'\\')\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        d=collections.defaultdict(set)\\n        for u,v,w in allowed:\\n            d[(u,v)].add(w)\\n        return self.transition(bottom,d)\\n        \\n    def transition(self, bottom, d):\\n        if len(bottom)==1: return True\\n        def dfs(i,path):\\n            if i==len(bottom)-1:\\n                return self.transition(path,d)\\n            for color in d[(bottom[i],bottom[i+1])]:\\n                if dfs(i+1,path+color):\\n                    return True\\n            return False\\n        return dfs(0,\\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717493,
                "title": "clear-java-dfs",
                "content": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, Set<String>> map = new HashMap<>();\\n        for (String s : allowed) {\\n            map.putIfAbsent(s.substring(0, 2), new HashSet<>());\\n            map.get(s.substring(0, 2)).add(s.substring(2,3));\\n        }\\n        return dfs(map, bottom, \"\");\\n    }\\n    private boolean dfs(Map<String, Set<String>> map, String s, String up) {\\n        if (s.length() == 1) return true;\\n        if (s.length() == up.length() + 1) {\\n            return dfs(map, up, \"\");\\n        }\\n        int i = up.length();\\n        String cur = s.substring(i, i + 2);\\n        if (!map.containsKey(cur)) return false;\\n        for (String next : map.get(cur)) {\\n            if (dfs(map, s, up + next)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, Set<String>> map = new HashMap<>();\\n        for (String s : allowed) {\\n            map.putIfAbsent(s.substring(0, 2), new HashSet<>());\\n            map.get(s.substring(0, 2)).add(s.substring(2,3));\\n        }\\n        return dfs(map, bottom, \"\");\\n    }\\n    private boolean dfs(Map<String, Set<String>> map, String s, String up) {\\n        if (s.length() == 1) return true;\\n        if (s.length() == up.length() + 1) {\\n            return dfs(map, up, \"\");\\n        }\\n        int i = up.length();\\n        String cur = s.substring(i, i + 2);\\n        if (!map.containsKey(cur)) return false;\\n        for (String next : map.get(cur)) {\\n            if (dfs(map, s, up + next)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698125,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n  def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n    combos = collections.defaultdict(set)\\n    for triangle in allowed:\\n      combos[triangle[:2]].add(triangle[2])\\n\\n    def helper(lower: str, upper: str, pos: int)->bool:\\n\\t  # found it\\n      if len(lower) == 1:\\n        return True\\n\\t  # need to check the new line\\n      if pos == len(lower) - 1:\\n        return helper(upper, \\'\\', 0)\\n\\t\\t\\n      word = lower[pos:pos+2]\\n\\t  # if can\\'t continue, return False\\n      if word not in combos:\\n        return False\\n\\t\\t\\n      for c in combos[word]:\\n\\t    # If found a solution, return early\\n        ans = helper(lower, upper+c, pos+1)\\n        if ans:\\n          return True\\n\\n    ans = helper(bottom, \\'\\', 0)\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n    combos = collections.defaultdict(set)\\n    for triangle in allowed:\\n      combos[triangle[:2]].add(triangle[2])\\n\\n    def helper(lower: str, upper: str, pos: int)->bool:\\n\\t  # found it\\n      if len(lower) == 1:\\n        return True\\n\\t  # need to check the new line\\n      if pos == len(lower) - 1:\\n        return helper(upper, \\'\\', 0)\\n\\t\\t\\n      word = lower[pos:pos+2]\\n\\t  # if can\\'t continue, return False\\n      if word not in combos:\\n        return False\\n\\t\\t\\n      for c in combos[word]:\\n\\t    # If found a solution, return early\\n        ans = helper(lower, upper+c, pos+1)\\n        if ans:\\n          return True\\n\\n    ans = helper(bottom, \\'\\', 0)\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544649,
                "title": "java-dfs-memo-solution",
                "content": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<Character>> map = new HashMap<>();\\n        Map<String, Boolean> memo = new HashMap<>();\\n        for (String s : allowed) {\\n            String b = s.substring(0, 2);\\n            char t = s.charAt(2);\\n            if (!map.containsKey(b)) map.put(b, new ArrayList<Character>());\\n            map.get(b).add(t);\\n        }\\n        return helper(bottom.toCharArray(), map, memo);\\n    }\\n    \\n    private boolean helper(char[] cur, Map<String, List<Character>> map, Map<String, Boolean> memo) {\\n        String key = new String(cur);\\n        if (cur.length == 1) return true;\\n        if (memo.containsKey(key)) return memo.get(key);\\n        \\n        boolean res = false;\\n        char[] next = new char[cur.length - 1];\\n        for (int i = 0; i < cur.length - 1; i++) {\\n            String b = \"\" + cur[i] + cur[i + 1];\\n            if (!map.containsKey(b)) {\\n                memo.put(key, false);\\n                return false;\\n            }\\n            next[i] = map.get(b).get(0);\\n        }\\n        for (int i = 0; i < cur.length - 1; i++) {\\n            String b = \"\" + cur[i] + cur[i + 1];\\n            for (char c : map.get(b)) {\\n                next[i] = c;\\n                res |= helper(next, map, memo);\\n            }\\n        }\\n        memo.put(key, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<Character>> map = new HashMap<>();\\n        Map<String, Boolean> memo = new HashMap<>();\\n        for (String s : allowed) {\\n            String b = s.substring(0, 2);\\n            char t = s.charAt(2);\\n            if (!map.containsKey(b)) map.put(b, new ArrayList<Character>());\\n            map.get(b).add(t);\\n        }\\n        return helper(bottom.toCharArray(), map, memo);\\n    }\\n    \\n    private boolean helper(char[] cur, Map<String, List<Character>> map, Map<String, Boolean> memo) {\\n        String key = new String(cur);\\n        if (cur.length == 1) return true;\\n        if (memo.containsKey(key)) return memo.get(key);\\n        \\n        boolean res = false;\\n        char[] next = new char[cur.length - 1];\\n        for (int i = 0; i < cur.length - 1; i++) {\\n            String b = \"\" + cur[i] + cur[i + 1];\\n            if (!map.containsKey(b)) {\\n                memo.put(key, false);\\n                return false;\\n            }\\n            next[i] = map.get(b).get(0);\\n        }\\n        for (int i = 0; i < cur.length - 1; i++) {\\n            String b = \"\" + cur[i] + cur[i + 1];\\n            for (char c : map.get(b)) {\\n                next[i] = c;\\n                res |= helper(next, map, memo);\\n            }\\n        }\\n        memo.put(key, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454551,
                "title": "simple-c-solution-using-recursion",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool isAns(string previous, string current, int req, vector<string>& allowed, int it, int n) {\\n        if(req==0) {\\n            return true;\\n        }\\n        if(it==req) {\\n            previous = current;\\n            return isAns(current, \"\", req-1, allowed, 0, n);\\n        }\\n        bool ans;\\n        for(int i=0;i<n;i++) {\\n            if(allowed[i][0]==previous[it] && allowed[i][1]==previous[it+1]) {\\n                ans = isAns(previous, current+allowed[i][2], req, allowed, it+1, n);\\n                if(ans) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        return isAns(bottom, \"\", bottom.length()-1, allowed, 0, allowed.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAns(string previous, string current, int req, vector<string>& allowed, int it, int n) {\\n        if(req==0) {\\n            return true;\\n        }\\n        if(it==req) {\\n            previous = current;\\n            return isAns(current, \"\", req-1, allowed, 0, n);\\n        }\\n        bool ans;\\n        for(int i=0;i<n;i++) {\\n            if(allowed[i][0]==previous[it] && allowed[i][1]==previous[it+1]) {\\n                ans = isAns(previous, current+allowed[i][2], req, allowed, it+1, n);\\n                if(ans) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        return isAns(bottom, \"\", bottom.length()-1, allowed, 0, allowed.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441665,
                "title": "python-use-dfs-not-bfs-bfs-cause-tle",
                "content": "I always believe BFS is at least equal to DFS in term of performance if not better. But this problem changed my mind.\\nIf you use BFS in this case, and if the \"allowed\" dict is huge, you will have too many BFS branches and see TLE. But DFS handles this well, because if you have many \"allowed\" case, it means you are more likely to build a valid pyramid. And DFS will end as soon as seeing first valid pyramid.\\n\\n```\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        d=collections.defaultdict(set)\\n        for a,b,c in allowed:\\n            d[(a,b)].add(c)\\n        def check(s):\\n            if len(s)==1:\\n                return True\\n            cur=[]\\n            for a,b in zip(s,s[1:]):\\n                if (a,b) not in d:\\n                    return False\\n                cur=[v+c for c in d[(a,b)] for v in cur or [\\'\\']]\\n            for c in cur:\\n                if check(c):\\n                    return True\\n            return False\\n        return check(bottom)\\n```",
                "solutionTags": [],
                "code": "```\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        d=collections.defaultdict(set)\\n        for a,b,c in allowed:\\n            d[(a,b)].add(c)\\n        def check(s):\\n            if len(s)==1:\\n                return True\\n            cur=[]\\n            for a,b in zip(s,s[1:]):\\n                if (a,b) not in d:\\n                    return False\\n                cur=[v+c for c in d[(a,b)] for v in cur or [\\'\\']]\\n            for c in cur:\\n                if check(c):\\n                    return True\\n            return False\\n        return check(bottom)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 424221,
                "title": "4-line-python3-solution-98-64-cpu-100-memory",
                "content": "Works its way from the bottom to the top. At each level, populates a list coresponding to the blocks on that level. Each element of the list is a set of values the block can have (computed from the set of possible values for the neighboring blocks on the prior level).\\n\\nStops when the list is reduced to one element (i.e., we\\'ve reached the top of the pyramid). Returns true iff the set is non-empty.\\n\\n```\\ndef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n    current = [set(c) for c in bottom]\\n    while len(current) > 1:\\n        current = [set(a[2] for a in allowed if a[0] in left and a[1] in right) for left, right in zip(current[:-1], current[1:])]\\n    return bool(len(current[0]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n    current = [set(c) for c in bottom]\\n    while len(current) > 1:\\n        current = [set(a[2] for a in allowed if a[0] in left and a[1] in right) for left, right in zip(current[:-1], current[1:])]\\n    return bool(len(current[0]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 401892,
                "title": "simple-c-dfs-shortest-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(string curr, string next, unordered_map<string,set<char>>& m, int i)\\n    {\\n        if(curr.length() == 1)\\n            return true;\\n        \\n        if(next.length()+1 == curr.length())\\n            return dfs(next,\"\",m,0);\\n        \\n        for(auto itr=m[curr.substr(i,2)].begin();itr!=m[curr.substr(i,2)].end();itr++)\\n            if(dfs(curr,next+*itr,m,i+1))\\n                return true;\\n        \\n        return false;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string,set<char>> m;\\n        for(int i=0;i<allowed.size();i++)\\n            m[allowed[i].substr(0,2)].insert(allowed[i][2]);\\n        \\n        return dfs(bottom,\"\",m,0);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(string curr, string next, unordered_map<string,set<char>>& m, int i)\\n    {\\n        if(curr.length() == 1)\\n            return true;\\n        \\n        if(next.length()+1 == curr.length())\\n            return dfs(next,\"\",m,0);\\n        \\n        for(auto itr=m[curr.substr(i,2)].begin();itr!=m[curr.substr(i,2)].end();itr++)\\n            if(dfs(curr,next+*itr,m,i+1))\\n                return true;\\n        \\n        return false;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string,set<char>> m;\\n        for(int i=0;i<allowed.size();i++)\\n            m[allowed[i].substr(0,2)].insert(allowed[i][2]);\\n        \\n        return dfs(bottom,\"\",m,0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323175,
                "title": "java-iteration-solution-with-map",
                "content": "```\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String,List<String>> map = new HashMap();\\n        for(String s : allowed){\\n            String key = s.substring(0,2);\\n            if(!map.containsKey(key)){\\n                map.put(key,new ArrayList());\\n            }\\n            map.get(key).add(s.substring(2,3));\\n        }\\n        List<Set<String>> row = new ArrayList();\\n        for(char c : bottom.toCharArray()){\\n            HashSet<String> set = new HashSet();\\n            set.add(c+\"\");\\n            row.add(set);\\n        }\\n        \\n        while(row.size()>1){\\n            List<Set<String>> newRow = new ArrayList();\\n            for(int i=1; i<row.size(); i++){\\n                Set<String> left = row.get(i-1);\\n                Set<String> right = row.get(i);\\n                Set<String> newBlock = new HashSet();\\n                for(String leftString : left){\\n                    for(String rightString : right){\\n                        String key = leftString+rightString;\\n                        if(map.containsKey(key)) newBlock.addAll(map.get(key));\\n                    }\\n                }\\n                if(newBlock.isEmpty()) return false;\\n                newRow.add(newBlock);\\n            }   \\n            row = newRow;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String,List<String>> map = new HashMap();\\n        for(String s : allowed){\\n            String key = s.substring(0,2);\\n            if(!map.containsKey(key)){\\n                map.put(key,new ArrayList());\\n            }\\n            map.get(key).add(s.substring(2,3));\\n        }\\n        List<Set<String>> row = new ArrayList();\\n        for(char c : bottom.toCharArray()){\\n            HashSet<String> set = new HashSet();\\n            set.add(c+\"\");\\n            row.add(set);\\n        }\\n        \\n        while(row.size()>1){\\n            List<Set<String>> newRow = new ArrayList();\\n            for(int i=1; i<row.size(); i++){\\n                Set<String> left = row.get(i-1);\\n                Set<String> right = row.get(i);\\n                Set<String> newBlock = new HashSet();\\n                for(String leftString : left){\\n                    for(String rightString : right){\\n                        String key = leftString+rightString;\\n                        if(map.containsKey(key)) newBlock.addAll(map.get(key));\\n                    }\\n                }\\n                if(newBlock.isEmpty()) return false;\\n                newRow.add(newBlock);\\n            }   \\n            row = newRow;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 292548,
                "title": "java-6ms-plain-map-and-backtrack-solution-with-explanation",
                "content": "The basic idea is transiting the given input string from bottom to up level by level until we reach the summit, i.e., the length of input string is 1.  We can solve the problem with hashtable and backtracking:\\n1. For each element ```s``` in ```allowed```, we save the map from ```s[0, 2]``` to ```s[3]```;\\n2. For current input string, if it cannot transit to next level, return false. Otherwise, traverse all possible strings of next level it can transit, return true if any of its successive string can reach the summit.\\n\\n```\\npublic boolean pyramidTransition(String bottom, List<String> allowed) {\\n    Map<String, List<Character>> strToChar = new HashMap<String, List<Character>>();\\n    for(int i = 0; i < allowed.size(); i++) {\\n        strToChar.putIfAbsent(allowed.get(i).substring(0, 2), new ArrayList<Character>());\\n        strToChar.get(allowed.get(i).substring(0, 2)).add(allowed.get(i).charAt(2));\\n    }\\n\\n    return help(bottom, strToChar);\\n}\\n\\npublic boolean help(String current, Map<String, List<Character>> strToChar) {\\n    if( current.length() == 1 )\\n        return true;\\n\\t\\n    List<List<Character>> charList = new ArrayList<List<Character>>();\\n    for(int i = 0; i < current.length() - 1; i++) {\\n        String substr = current.substring(i, i + 2);\\n        List<Character> currentList = strToChar.getOrDefault(substr, null);\\n        if( currentList == null ) {\\n            return false;\\n        }\\n        charList.add(currentList);\\n    }\\n\\t\\n    List<String> resultList = new ArrayList<String>();\\n    traverse(resultList, charList, 0, new StringBuilder(\"\"));\\n\\n    for(int i = 0; i < resultList.size(); i++) {\\n        if( help(resultList.get(i), strToChar) )\\n            return true;\\n    }\\n    return false;\\n}\\n\\npublic void traverse(List<String> resultList, List<List<Character>> charList, int index, StringBuilder sb) {\\n    if( index == charList.size() ) {\\n        resultList.add(sb.toString());\\n        return;\\n    }\\n    List<Character> currentList = charList.get(index);\\n    for(int i = 0; i < currentList.size(); i++) {\\n        sb.append(currentList.get(i));\\n        traverse(resultList, charList, index + 1, sb);\\n        sb.deleteCharAt(index);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```s```\n```allowed```\n```s[0, 2]```\n```s[3]```\n```\\npublic boolean pyramidTransition(String bottom, List<String> allowed) {\\n    Map<String, List<Character>> strToChar = new HashMap<String, List<Character>>();\\n    for(int i = 0; i < allowed.size(); i++) {\\n        strToChar.putIfAbsent(allowed.get(i).substring(0, 2), new ArrayList<Character>());\\n        strToChar.get(allowed.get(i).substring(0, 2)).add(allowed.get(i).charAt(2));\\n    }\\n\\n    return help(bottom, strToChar);\\n}\\n\\npublic boolean help(String current, Map<String, List<Character>> strToChar) {\\n    if( current.length() == 1 )\\n        return true;\\n\\t\\n    List<List<Character>> charList = new ArrayList<List<Character>>();\\n    for(int i = 0; i < current.length() - 1; i++) {\\n        String substr = current.substring(i, i + 2);\\n        List<Character> currentList = strToChar.getOrDefault(substr, null);\\n        if( currentList == null ) {\\n            return false;\\n        }\\n        charList.add(currentList);\\n    }\\n\\t\\n    List<String> resultList = new ArrayList<String>();\\n    traverse(resultList, charList, 0, new StringBuilder(\"\"));\\n\\n    for(int i = 0; i < resultList.size(); i++) {\\n        if( help(resultList.get(i), strToChar) )\\n            return true;\\n    }\\n    return false;\\n}\\n\\npublic void traverse(List<String> resultList, List<List<Character>> charList, int index, StringBuilder sb) {\\n    if( index == charList.size() ) {\\n        resultList.add(sb.toString());\\n        return;\\n    }\\n    List<Character> currentList = charList.get(index);\\n    for(int i = 0; i < currentList.size(); i++) {\\n        sb.append(currentList.get(i));\\n        traverse(resultList, charList, index + 1, sb);\\n        sb.deleteCharAt(index);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 211835,
                "title": "java-concise-recursion-solution",
                "content": "```\\nclass Solution {\\n    Map<String, List<Character>> hash = new HashMap<>();\\n    \\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        for(String str: allowed) {\\n            if(!hash.containsKey(str.substring(0, 2))) hash.put(str.substring(0, 2), new ArrayList<>());\\n            hash.get(str.substring(0, 2)).add(str.charAt(2));\\n        }\\n        return DFS(bottom, 0, \"\");\\n    }\\n    \\n    boolean DFS(String bottom, int start, String next) {\\n        if(bottom.length() == 0) return true;\\n        if(start == bottom.length() - 1) return DFS(next, 0, \"\");\\n        List<Character> list = hash.getOrDefault(bottom.substring(start, start+2), new ArrayList<>());\\n        for(Character ch: list) {\\n            if(DFS(bottom, start+1, next+ch)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<String, List<Character>> hash = new HashMap<>();\\n    \\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        for(String str: allowed) {\\n            if(!hash.containsKey(str.substring(0, 2))) hash.put(str.substring(0, 2), new ArrayList<>());\\n            hash.get(str.substring(0, 2)).add(str.charAt(2));\\n        }\\n        return DFS(bottom, 0, \"\");\\n    }\\n    \\n    boolean DFS(String bottom, int start, String next) {\\n        if(bottom.length() == 0) return true;\\n        if(start == bottom.length() - 1) return DFS(next, 0, \"\");\\n        List<Character> list = hash.getOrDefault(bottom.substring(start, start+2), new ArrayList<>());\\n        for(Character ch: list) {\\n            if(DFS(bottom, start+1, next+ch)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173913,
                "title": "java-ac-iterative-easy-to-understand-beats-83",
                "content": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<Character, Map<Character, Set<Character>>> map = new HashMap<>();\\n        for (String allow : allowed) {\\n            map.putIfAbsent(allow.charAt(0), new HashMap<Character, Set<Character>>());\\n            map.get(allow.charAt(0)).putIfAbsent(allow.charAt(1), new HashSet<Character>());\\n            map.get(allow.charAt(0)).get(allow.charAt(1)).add(allow.charAt(2));\\n        }\\n        \\n        while (bottom.length() > 1) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 1; i < bottom.length(); i++) {\\n                char c1 = bottom.charAt(i-1), c2 = bottom.charAt(i);\\n                if (!map.containsKey(c1) || !map.get(c1).containsKey(c2) || map.get(c1).get(c2).isEmpty()) {\\n                    return false;\\n                }\\n\\n                Set<Character> set = map.get(c1).get(c2);    \\n                char pref = set.iterator().next();\\n                for (char c : set) {\\n                    if ((i == 1 || \\n                        (map.containsKey(sb.charAt(i-2)) && map.get(sb.charAt(i-2)).containsKey(c))) && \\n                        (i == bottom.length()-1 || map.containsKey(c))) {\\n                        pref = c;\\n                        break;\\n                    }\\n                }\\n\\n                sb.append(pref);\\n            }\\n\\n            bottom = sb.toString();\\n            // System.out.println(bottom);\\n            sb = new StringBuilder();\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\nThe intuition here is that we follow a very simple set of rules to construct the pyramid from the bottom up. First, we store a map that looks more complicated than it really is; in reality, it\\'s just a way to check if triplets exists. We map the first character of a triplet to a map from the second character to possible third characters. \\n\\nNow, we enter a while loop; each iteration of the while loop is the next layer of the pyramid. When our string ```bottom``` is length 1, then we know we have completed the pyramid. \\n\\nThe for loop starts at ```i=1``` and loops to ```i < bottom.length()```. In each iteration, we examine ```bottom.charAt(i-1), bottom.charAt(i)``` as the first and second chars of our triple. So in each iteration, we are searching for a third char to stack on top of the bottom two, which we will find and append to our StringBuilder. First, we check whether we have any valid solutions for the two characters we are building a character on top of. To do this, we see whether the map contains the first char as a key, contains the second char as a key in the map that the first char maps to, and has any third possible chars in the set mapped to the second char. If not, we save time and immediately return false.\\n\\nSo now we completed this check and can see that we do have some possible triplets to build upon the two chars we\\'re looking at. We take the set attached to these first two chars. We know it isn\\'t empty since we checked for that; now we want to find if a preferable character exists in this solution set. A preferable character is one where it can both be used as a second char of a triplet and as a first char of a triple, considering the surrounding chars of the layer we have built so far. So we iterate through the set and find any preferable character. If we didn\\'t find any, we just take any char from the set and append it. We could actually check here to see if we\\'re at the last layer, and if not, then failing to find a preferable char means we should return false, but for simplicity\\'s sake I wanted to keep the ```return false``` in only one place so it is clear what condition throws a false. Doing this in no way increases time complexity.\\n\\nIf we terminated our while loop without throwing a ```false```, that means ```bottom.length() == 1```. Our ```bottom``` string is the tip of the pyramid and we can now return true as the pyramid was built successfully.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<Character, Map<Character, Set<Character>>> map = new HashMap<>();\\n        for (String allow : allowed) {\\n            map.putIfAbsent(allow.charAt(0), new HashMap<Character, Set<Character>>());\\n            map.get(allow.charAt(0)).putIfAbsent(allow.charAt(1), new HashSet<Character>());\\n            map.get(allow.charAt(0)).get(allow.charAt(1)).add(allow.charAt(2));\\n        }\\n        \\n        while (bottom.length() > 1) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 1; i < bottom.length(); i++) {\\n                char c1 = bottom.charAt(i-1), c2 = bottom.charAt(i);\\n                if (!map.containsKey(c1) || !map.get(c1).containsKey(c2) || map.get(c1).get(c2).isEmpty()) {\\n                    return false;\\n                }\\n\\n                Set<Character> set = map.get(c1).get(c2);    \\n                char pref = set.iterator().next();\\n                for (char c : set) {\\n                    if ((i == 1 || \\n                        (map.containsKey(sb.charAt(i-2)) && map.get(sb.charAt(i-2)).containsKey(c))) && \\n                        (i == bottom.length()-1 || map.containsKey(c))) {\\n                        pref = c;\\n                        break;\\n                    }\\n                }\\n\\n                sb.append(pref);\\n            }\\n\\n            bottom = sb.toString();\\n            // System.out.println(bottom);\\n            sb = new StringBuilder();\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\n```bottom```\n```i=1```\n```i < bottom.length()```\n```bottom.charAt(i-1), bottom.charAt(i)```\n```return false```\n```false```\n```bottom.length() == 1```\n```bottom```",
                "codeTag": "Java"
            },
            {
                "id": 145880,
                "title": "easy-java-beat-100",
                "content": "```\\n    Map<String,List<String>> map = new HashMap<>();\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        int lenS = bottom.length(), len = allowed.size();\\n        for (String s : allowed) {\\n            String temp = s.substring(0,2);\\n            if (map.get(temp) == null) map.put(temp, new ArrayList<>());\\n            map.get(temp).add(s.substring(2));\\n        }\\n        return helper(bottom,0,\"\");\\n    }\\n     \\n    public boolean helper(String bottom, int index, String curr) {\\n        int len = bottom.length();\\n        if (len == 2) return map.get(bottom) != null;\\n        if (index == len - 1) return helper(curr, 0, \"\");\\n        String temp = bottom.substring(index,index+2);\\n        if (map.get(temp) == null) return false;\\n        List<String> list = map.get(temp);\\n        for (int i = 0; i < list.size(); i++) \\n            if (helper(bottom, index+1,curr+ list.get(i))) return true;;\\n        return false;\\n    } \\n```",
                "solutionTags": [],
                "code": "```\\n    Map<String,List<String>> map = new HashMap<>();\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        int lenS = bottom.length(), len = allowed.size();\\n        for (String s : allowed) {\\n            String temp = s.substring(0,2);\\n            if (map.get(temp) == null) map.put(temp, new ArrayList<>());\\n            map.get(temp).add(s.substring(2));\\n        }\\n        return helper(bottom,0,\"\");\\n    }\\n     \\n    public boolean helper(String bottom, int index, String curr) {\\n        int len = bottom.length();\\n        if (len == 2) return map.get(bottom) != null;\\n        if (index == len - 1) return helper(curr, 0, \"\");\\n        String temp = bottom.substring(index,index+2);\\n        if (map.get(temp) == null) return false;\\n        List<String> list = map.get(temp);\\n        for (int i = 0; i < list.size(); i++) \\n            if (helper(bottom, index+1,curr+ list.get(i))) return true;;\\n        return false;\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 145469,
                "title": "a-c-dfs-solution",
                "content": "Just check validity level by level. At each level, move char-by-char to check possibility, If all are satisfied, then return true.\\n```\\nclass Solution {\\npublic:\\n    bool dfs(string bottom, int start, vector<string>& allowed, string nextBottom) {\\n        if (nextBottom.size() == bottom.size() - 1) {\\n            if (nextBottom.size() == 1) return true;\\n            return dfs(nextBottom, 0, allowed, \"\");\\n        }\\n        \\n        string ab = bottom.substr(start, 2);\\n        for (auto candidate : allowed) {\\n            if (candidate[0] == ab[0] && candidate[1] == ab[1]) {\\n                if (dfs(bottom, start + 1, allowed, nextBottom + candidate[2])) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        return dfs(bottom, 0, allowed, \"\");\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(string bottom, int start, vector<string>& allowed, string nextBottom) {\\n        if (nextBottom.size() == bottom.size() - 1) {\\n            if (nextBottom.size() == 1) return true;\\n            return dfs(nextBottom, 0, allowed, \"\");\\n        }\\n        \\n        string ab = bottom.substr(start, 2);\\n        for (auto candidate : allowed) {\\n            if (candidate[0] == ab[0] && candidate[1] == ab[1]) {\\n                if (dfs(bottom, start + 1, allowed, nextBottom + candidate[2])) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        return dfs(bottom, 0, allowed, \"\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131458,
                "title": "python-8-liner",
                "content": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom, allowed):\\n        chars, allowed = \\'ABCDEFG\\', set(allowed)\\n        def dfs(r, q, i):\\n            if len(r) == 1: \\n                return True\\n            for c in chars:\\n                if r[i:i+2]+c in allowed and (i==len(r)-2 and dfs(q+c,\"\",0) or dfs(r,q+c,i+1)): return True\\n            return False\\n        return dfs(bottom, \"\", 0) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom, allowed):\\n        chars, allowed = \\'ABCDEFG\\', set(allowed)\\n        def dfs(r, q, i):\\n            if len(r) == 1: \\n                return True\\n            for c in chars:\\n                if r[i:i+2]+c in allowed and (i==len(r)-2 and dfs(q+c,\"\",0) or dfs(r,q+c,i+1)): return True\\n            return False\\n        return dfs(bottom, \"\", 0) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 120152,
                "title": "most-elegant-java-backtracking-10ms-solution",
                "content": "```\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, int[]> map = new HashMap<>();\\n        for(String n : allowed) {\\n            String key = n.substring(0, 2);\\n            int[] v = map.getOrDefault(key, new int[7]);\\n            v[n.charAt(2)-\\'A\\'] = 1;\\n            map.put(key, v);\\n        }\\n        return helper(bottom, 0, map, new StringBuilder());\\n    }\\n    \\n    private boolean helper(String cur, int start, Map<String, int[]> map, StringBuilder sb) {\\n        if(cur.length() == 1) return true;\\n        \\n        if(start == cur.length()-1) return helper(sb.toString(), 0, map, new StringBuilder());\\n        \\n        if(!map.containsKey(cur.substring(start, start+2))) return false;\\n        \\n        int[] v = map.get(cur.substring(start, start+2));\\n        for(int i=0; i<7; i++) {\\n             if(v[i] == 1) {\\n                if(helper(cur, start+1, map, sb.append((char)(\\'A\\'+i)))) return true;\\n                else sb.deleteCharAt(sb.length()-1);\\n             }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, int[]> map = new HashMap<>();\\n        for(String n : allowed) {\\n            String key = n.substring(0, 2);\\n            int[] v = map.getOrDefault(key, new int[7]);\\n            v[n.charAt(2)-\\'A\\'] = 1;\\n            map.put(key, v);\\n        }\\n        return helper(bottom, 0, map, new StringBuilder());\\n    }\\n    \\n    private boolean helper(String cur, int start, Map<String, int[]> map, StringBuilder sb) {\\n        if(cur.length() == 1) return true;\\n        \\n        if(start == cur.length()-1) return helper(sb.toString(), 0, map, new StringBuilder());\\n        \\n        if(!map.containsKey(cur.substring(start, start+2))) return false;\\n        \\n        int[] v = map.get(cur.substring(start, start+2));\\n        for(int i=0; i<7; i++) {\\n             if(v[i] == 1) {\\n                if(helper(cur, start+1, map, sb.append((char)(\\'A\\'+i)))) return true;\\n                else sb.deleteCharAt(sb.length()-1);\\n             }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113036,
                "title": "a-map-based-solution-based-on-memoization",
                "content": "A map based solution based on memoization. The idea is very simple, keep reducing the current row of blocks to the row above until we hit the top block.\\n\\n```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, Set<Character>> map = new HashMap<>();\\n        \\n        for (String s : allowed) {\\n            map.computeIfAbsent(s.substring(0, 2), k -> new HashSet<Character>()).add(s.charAt(2));\\n        }\\n        \\n        return dfs(bottom, \"\", map);\\n    }\\n    \\n    private boolean dfs(String below, String above, Map<String, Set<Character>> map) {\\n        if (below.length() == 2 && above.length() == 1) {\\n            return true;\\n        }\\n        \\n        if (above.length() == below.length() - 1) {\\n            return dfs(above, \"\", map);\\n        }\\n        \\n        int current = above.length();\\n        String base = below.substring(current, current + 2);\\n        \\n        if (map.containsKey(base)) {\\n            for (char ch : map.get(base)) {\\n                if (dfs(below, above + ch, map)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, Set<Character>> map = new HashMap<>();\\n        \\n        for (String s : allowed) {\\n            map.computeIfAbsent(s.substring(0, 2), k -> new HashSet<Character>()).add(s.charAt(2));\\n        }\\n        \\n        return dfs(bottom, \"\", map);\\n    }\\n    \\n    private boolean dfs(String below, String above, Map<String, Set<Character>> map) {\\n        if (below.length() == 2 && above.length() == 1) {\\n            return true;\\n        }\\n        \\n        if (above.length() == below.length() - 1) {\\n            return dfs(above, \"\", map);\\n        }\\n        \\n        int current = above.length();\\n        String base = below.substring(current, current + 2);\\n        \\n        if (map.containsKey(base)) {\\n            for (char ch : map.get(base)) {\\n                if (dfs(below, above + ch, map)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113051,
                "title": "c-dfs-accepted-3ms",
                "content": "Intuition Algorithm\\n```\\nclass Solution {\\nprivate:\\n    \\n    bool isOK(char l, char r, char u, unordered_set<string>& allow) {\\n        string s = \"ZZZ\";\\n        s[0] = l; s[1] = r; s[2] = u;\\n        return allow.count(s);\\n    }\\n    bool pt(string bottom, unordered_set<string>& allow, string op){\\n        int n = bottom.size();\\n        if (n == 1) return true;\\n        string ans(n - 1, 'Z');\\n        return (dfs(bottom, ans, 0, op, allow)) ;\\n    }\\n    \\n    bool dfs(string bottom, string ans, int idx, string op, unordered_set<string>& allow) {\\n        if (idx == ans.size()) {\\n            return pt(ans, allow, op);\\n        }\\n        for (char c : op) {\\n            if (isOK(bottom[idx], bottom[idx + 1], c, allow)) {\\n                ans[idx] = c;\\n                if (dfs(bottom, ans, idx + 1, op, allow)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        string op = \"ABCDEFG\";\\n        unordered_set<string> allow(allowed.begin(), allowed.end());\\n        return pt(bottom, allow, op);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\n    bool isOK(char l, char r, char u, unordered_set<string>& allow) {\\n        string s = \"ZZZ\";\\n        s[0] = l; s[1] = r; s[2] = u;\\n        return allow.count(s);\\n    }\\n    bool pt(string bottom, unordered_set<string>& allow, string op){\\n        int n = bottom.size();\\n        if (n == 1) return true;\\n        string ans(n - 1, 'Z');\\n        return (dfs(bottom, ans, 0, op, allow)) ;\\n    }\\n    \\n    bool dfs(string bottom, string ans, int idx, string op, unordered_set<string>& allow) {\\n        if (idx == ans.size()) {\\n            return pt(ans, allow, op);\\n        }\\n        for (char c : op) {\\n            if (isOK(bottom[idx], bottom[idx + 1], c, allow)) {\\n                ans[idx] = c;\\n                if (dfs(bottom, ans, idx + 1, op, allow)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        string op = \"ABCDEFG\";\\n        unordered_set<string> allow(allowed.begin(), allowed.end());\\n        return pt(bottom, allow, op);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076723,
                "title": "bfs-trie-java-solution-beats-100",
                "content": "# Intuition\\nA few things I noticed:\\n1. there was a dictionary of allowed words given almost everytime when a dictionary is given you have to use Tries\\n2. you only need to answer in true or false, i.e. as soon as we get a single true we can stop proceedinging, which makes it more of a bfs problem than a dfs problem.\\n\\n# Code\\n```\\nclass Node{\\n    Node[] letters=new Node[6];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        for(String s: allowed){\\n            addToTrie(root, s.toCharArray(), 0);\\n        }\\n        ArrayDeque<char[]> q=new ArrayDeque<>();\\n        q.addFirst(bottom.toCharArray());\\n        boolean flag=true;\\n        while(!q.isEmpty()){\\n            char[] arr=q.pollLast();\\n            if(arr.length==1){\\n                return true;\\n            }\\n            List<char[]> temp=new ArrayList<>();\\n            for(int i=0;i<arr.length-1;i++){\\n                List<char[]> newTemp=new ArrayList<>();\\n                List<Character> list=lookFor(arr[i], arr[i+1]);\\n                for(char c: list){\\n                    if(temp.isEmpty()){\\n                        if(i==0){\\n                            char[] x=new char[arr.length-1];\\n                            x[i]=c;\\n                            newTemp.add(x);\\n                        }else{\\n                            return false;\\n                        }\\n                    }else{\\n                        for(char[] m:temp){\\n                            char[] x=m.clone();\\n                            x[i]=c;\\n                            newTemp.add(x);\\n                            // System.out.println(Arrays.toString(m)+\" \"+Arrays.toString(x));\\n                        }\\n                    }\\n                    // System.out.println(i);\\n                    // for(char[] arr1: newTemp){\\n                    //     System.out.print(Arrays.toString(arr1));\\n                    // }\\n                    // System.out.println(\"\");\\n                }\\n                temp=newTemp;\\n                // System.out.println(\"temp\");\\n                //     for(char[] arr1: temp){\\n                //         System.out.print(Arrays.toString(arr1));\\n                //     }\\n                // System.out.println(\"\");\\n                // if(newTemp.isEmpty()){\\n                //     return false;\\n                // }\\n            }\\n            q.addAll(temp);\\n        \\n            // System.out.println(\"\");\\n            // for(char[] arr1: q){\\n            //     System.out.print(Arrays.toString(arr1));\\n            // }\\n        }\\n        return false;\\n    }\\n    public List<Character> lookFor(char a, char b){\\n        ArrayList<Character> ans=new ArrayList<>();\\n        if(root.letters[a-\\'A\\']!=null){\\n            if(root.letters[a-\\'A\\'].letters[b-\\'A\\']!=null){\\n                for(int i=0;i<6;i++){\\n                    if(root.letters[a-\\'A\\'].letters[b-\\'A\\'].letters[i]!=null){\\n                        ans.add((char)(i+\\'A\\'));\\n                    }\\n                }\\n            }\\n        }\\n        // System.out.println(a+\" \"+b+\" \"+ans);\\n        return ans;\\n    }\\n    public void addToTrie(Node node, char[] s, int index){\\n        if(index==s.length){\\n            return;\\n        }\\n        char c=s[index];\\n        if(node.letters[c-\\'A\\']==null){\\n            node.letters[c-\\'A\\']=new Node();\\n        }\\n        addToTrie(node.letters[c-\\'A\\'], s, index+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Node{\\n    Node[] letters=new Node[6];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        for(String s: allowed){\\n            addToTrie(root, s.toCharArray(), 0);\\n        }\\n        ArrayDeque<char[]> q=new ArrayDeque<>();\\n        q.addFirst(bottom.toCharArray());\\n        boolean flag=true;\\n        while(!q.isEmpty()){\\n            char[] arr=q.pollLast();\\n            if(arr.length==1){\\n                return true;\\n            }\\n            List<char[]> temp=new ArrayList<>();\\n            for(int i=0;i<arr.length-1;i++){\\n                List<char[]> newTemp=new ArrayList<>();\\n                List<Character> list=lookFor(arr[i], arr[i+1]);\\n                for(char c: list){\\n                    if(temp.isEmpty()){\\n                        if(i==0){\\n                            char[] x=new char[arr.length-1];\\n                            x[i]=c;\\n                            newTemp.add(x);\\n                        }else{\\n                            return false;\\n                        }\\n                    }else{\\n                        for(char[] m:temp){\\n                            char[] x=m.clone();\\n                            x[i]=c;\\n                            newTemp.add(x);\\n                            // System.out.println(Arrays.toString(m)+\" \"+Arrays.toString(x));\\n                        }\\n                    }\\n                    // System.out.println(i);\\n                    // for(char[] arr1: newTemp){\\n                    //     System.out.print(Arrays.toString(arr1));\\n                    // }\\n                    // System.out.println(\"\");\\n                }\\n                temp=newTemp;\\n                // System.out.println(\"temp\");\\n                //     for(char[] arr1: temp){\\n                //         System.out.print(Arrays.toString(arr1));\\n                //     }\\n                // System.out.println(\"\");\\n                // if(newTemp.isEmpty()){\\n                //     return false;\\n                // }\\n            }\\n            q.addAll(temp);\\n        \\n            // System.out.println(\"\");\\n            // for(char[] arr1: q){\\n            //     System.out.print(Arrays.toString(arr1));\\n            // }\\n        }\\n        return false;\\n    }\\n    public List<Character> lookFor(char a, char b){\\n        ArrayList<Character> ans=new ArrayList<>();\\n        if(root.letters[a-\\'A\\']!=null){\\n            if(root.letters[a-\\'A\\'].letters[b-\\'A\\']!=null){\\n                for(int i=0;i<6;i++){\\n                    if(root.letters[a-\\'A\\'].letters[b-\\'A\\'].letters[i]!=null){\\n                        ans.add((char)(i+\\'A\\'));\\n                    }\\n                }\\n            }\\n        }\\n        // System.out.println(a+\" \"+b+\" \"+ans);\\n        return ans;\\n    }\\n    public void addToTrie(Node node, char[] s, int index){\\n        if(index==s.length){\\n            return;\\n        }\\n        char c=s[index];\\n        if(node.letters[c-\\'A\\']==null){\\n            node.letters[c-\\'A\\']=new Node();\\n        }\\n        addToTrie(node.letters[c-\\'A\\'], s, index+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072263,
                "title": "backtracking-bit-manipulation-faster-than-60-java",
                "content": "# Code\\n```\\nclass Pyramid {\\n    int base;\\n    int top;\\n\\n    public Pyramid(int base, int top) {\\n        this.base = base;\\n        this.top = top;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<Integer, Set<Integer>> pyramids = new HashMap<>();\\n        for (String str: allowed) {\\n            Pyramid p = getPyramid(str, 2);\\n            pyramids.computeIfAbsent(p.base, e-> new HashSet<>()).add(p.top);\\n        }\\n        return slv(0, bottom.length() - 1, getPyramid(bottom, bottom.length()).base, 0, pyramids);\\n    }\\n\\n    private boolean slv(int i, int lvl, int curr, int next, Map<Integer, Set<Integer>> pyramids) {\\n        if (i == lvl) {\\n            curr = next;\\n            next = 0;\\n            lvl--;\\n            i = 0;\\n        }\\n        if (lvl == 0) return true;\\n        for (int c : pyramids.getOrDefault(getBase(curr, i), new HashSet<>())) \\n            if (slv(i + 1, lvl, curr, concatBits(next, c, i), pyramids)) return true;\\n        return false;\\n    }\\n\\n    private Pyramid getPyramid(String str, int end) {\\n        int base = 0;\\n        int top = 0;\\n        for (int i = 0; i < str.length(); i++) {\\n            if(i < end) base = setBits(base, str.charAt(i) - 65, 2);\\n            else top = setBits(top, str.charAt(i) - 65, 2);\\n        }\\n        return new Pyramid(base, top);\\n    }\\n\\n    private Integer getBase(int curr, int index) {\\n        return setBits(0, curr >> (index * 3), 5);\\n    }\\n\\n    private int concatBits(int next, int val, int start) {\\n        return next | (val << (start * 3));\\n    }\\n\\n    private int setBits(int base, int val, int start) {\\n        for (int j = start; j >= 0; j--)\\n            base = setBitsUtility(base, getBit(val, j));\\n        return base;\\n    }\\n\\n    private int setBitsUtility(int bits, int val) {\\n        return (bits << 1) | val;\\n    }\\n\\n    private int getBit(int bits, int i) {\\n        return ((1 << i) & bits) == 0 ? 0 : 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Pyramid {\\n    int base;\\n    int top;\\n\\n    public Pyramid(int base, int top) {\\n        this.base = base;\\n        this.top = top;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<Integer, Set<Integer>> pyramids = new HashMap<>();\\n        for (String str: allowed) {\\n            Pyramid p = getPyramid(str, 2);\\n            pyramids.computeIfAbsent(p.base, e-> new HashSet<>()).add(p.top);\\n        }\\n        return slv(0, bottom.length() - 1, getPyramid(bottom, bottom.length()).base, 0, pyramids);\\n    }\\n\\n    private boolean slv(int i, int lvl, int curr, int next, Map<Integer, Set<Integer>> pyramids) {\\n        if (i == lvl) {\\n            curr = next;\\n            next = 0;\\n            lvl--;\\n            i = 0;\\n        }\\n        if (lvl == 0) return true;\\n        for (int c : pyramids.getOrDefault(getBase(curr, i), new HashSet<>())) \\n            if (slv(i + 1, lvl, curr, concatBits(next, c, i), pyramids)) return true;\\n        return false;\\n    }\\n\\n    private Pyramid getPyramid(String str, int end) {\\n        int base = 0;\\n        int top = 0;\\n        for (int i = 0; i < str.length(); i++) {\\n            if(i < end) base = setBits(base, str.charAt(i) - 65, 2);\\n            else top = setBits(top, str.charAt(i) - 65, 2);\\n        }\\n        return new Pyramid(base, top);\\n    }\\n\\n    private Integer getBase(int curr, int index) {\\n        return setBits(0, curr >> (index * 3), 5);\\n    }\\n\\n    private int concatBits(int next, int val, int start) {\\n        return next | (val << (start * 3));\\n    }\\n\\n    private int setBits(int base, int val, int start) {\\n        for (int j = start; j >= 0; j--)\\n            base = setBitsUtility(base, getBit(val, j));\\n        return base;\\n    }\\n\\n    private int setBitsUtility(int bits, int val) {\\n        return (bits << 1) | val;\\n    }\\n\\n    private int getBit(int bits, int i) {\\n        return ((1 << i) & bits) == 0 ? 0 : 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041413,
                "title": "easy-dfs-solution-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<char>>atob;\\n    unordered_map<string,bool>mp;\\n    bool helper(int i,string &bottom,string &created){\\n        // cout<<bottom<<\" \"<<created<<\" \"<<endl;\\n        if(bottom.size()==2)\\n        {\\n            // cout<<bottom<<\" \"<<endl;\\n            if(atob[bottom].size()!=0)\\n            return true;\\n            return false;\\n        }\\n        // return true;\\n        string temp = to_string(i)+\" \"+bottom+\" \"+created;\\n        if(i+1==bottom.size()){\\n            string new_=\"\";\\n            return mp[temp]=helper(0,created,new_);\\n            \\n        }\\n        if(mp.find(temp)!=mp.end())\\n        return mp[temp];\\n\\n        bool ans=false;\\n        // while(i<bottom.size()-1){\\n            if(atob.find(bottom.substr(i,2))==atob.end())\\n            return false;\\n            for(auto str:atob[bottom.substr(i,2)]){\\n                if(str==\\'\\\\0\\')\\n                return 0;\\n                created.push_back(str);\\n                ans= helper(i+1,bottom,created) or ans;\\n                if(ans)\\n                return true;\\n                created.pop_back();\\n            }\\n            // i++;\\n\\n        // }\\n        return mp[temp]=ans;\\n\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n        for(auto str:allowed){\\n            atob[str.substr(0,2)].push_back(str[2]);\\n        }\\n        // for(auto it:atob){\\n        //     // cout<<;\\n        //     for(auto x:it.second)\\n        //     cout<<it.first<<x;\\n        //     cout<<endl;\\n        // }\\n        string new_=\"\";\\n        return helper(0,bottom,new_);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<char>>atob;\\n    unordered_map<string,bool>mp;\\n    bool helper(int i,string &bottom,string &created){\\n        // cout<<bottom<<\" \"<<created<<\" \"<<endl;\\n        if(bottom.size()==2)\\n        {\\n            // cout<<bottom<<\" \"<<endl;\\n            if(atob[bottom].size()!=0)\\n            return true;\\n            return false;\\n        }\\n        // return true;\\n        string temp = to_string(i)+\" \"+bottom+\" \"+created;\\n        if(i+1==bottom.size()){\\n            string new_=\"\";\\n            return mp[temp]=helper(0,created,new_);\\n            \\n        }\\n        if(mp.find(temp)!=mp.end())\\n        return mp[temp];\\n\\n        bool ans=false;\\n        // while(i<bottom.size()-1){\\n            if(atob.find(bottom.substr(i,2))==atob.end())\\n            return false;\\n            for(auto str:atob[bottom.substr(i,2)]){\\n                if(str==\\'\\\\0\\')\\n                return 0;\\n                created.push_back(str);\\n                ans= helper(i+1,bottom,created) or ans;\\n                if(ans)\\n                return true;\\n                created.pop_back();\\n            }\\n            // i++;\\n\\n        // }\\n        return mp[temp]=ans;\\n\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n        for(auto str:allowed){\\n            atob[str.substr(0,2)].push_back(str[2]);\\n        }\\n        // for(auto it:atob){\\n        //     // cout<<;\\n        //     for(auto x:it.second)\\n        //     cout<<it.first<<x;\\n        //     cout<<endl;\\n        // }\\n        string new_=\"\";\\n        return helper(0,bottom,new_);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3974616,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    Map<String,List<Character>> mp;\\n    Map<String,Boolean> dp;\\n    boolean helper(String bottom,int idx,String temp){\\n        if(bottom.length() == 1) return true;\\n        if(dp.containsKey(bottom + temp)) return dp.get(bottom + temp);\\n        if(idx == bottom.length()) return helper(temp,1,\"\");\\n        String key = \"\" + bottom.charAt(idx - 1) + bottom.charAt(idx);\\n        if(!mp.containsKey(key)){\\n            dp.put(bottom + temp,false);\\n            return false;\\n        }\\n        for(var c:mp.get(key)){\\n            if(helper(bottom,idx + 1,temp + c)){\\n                dp.put(bottom + temp + c,true);\\n                return true;\\n            }\\n        }\\n        dp.put(bottom + temp,false);\\n        return false;\\n    }\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        mp = new HashMap<>();\\n        dp = new HashMap<>();\\n        for(var a:allowed){\\n            String key = \"\" + a.charAt(0) + a.charAt(1);\\n            if(!mp.containsKey(key)) mp.put(key,new ArrayList<>());\\n            mp.get(key).add(a.charAt(2));\\n        }\\n        return helper(bottom,1,\"\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String,List<Character>> mp;\\n    Map<String,Boolean> dp;\\n    boolean helper(String bottom,int idx,String temp){\\n        if(bottom.length() == 1) return true;\\n        if(dp.containsKey(bottom + temp)) return dp.get(bottom + temp);\\n        if(idx == bottom.length()) return helper(temp,1,\"\");\\n        String key = \"\" + bottom.charAt(idx - 1) + bottom.charAt(idx);\\n        if(!mp.containsKey(key)){\\n            dp.put(bottom + temp,false);\\n            return false;\\n        }\\n        for(var c:mp.get(key)){\\n            if(helper(bottom,idx + 1,temp + c)){\\n                dp.put(bottom + temp + c,true);\\n                return true;\\n            }\\n        }\\n        dp.put(bottom + temp,false);\\n        return false;\\n    }\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        mp = new HashMap<>();\\n        dp = new HashMap<>();\\n        for(var a:allowed){\\n            String key = \"\" + a.charAt(0) + a.charAt(1);\\n            if(!mp.containsKey(key)) mp.put(key,new ArrayList<>());\\n            mp.get(key).add(a.charAt(2));\\n        }\\n        return helper(bottom,1,\"\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944294,
                "title": "dfs-use-stack-100-and-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbuild the pyramid by layer, pure code with some comments\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Stack for DFS\\nclass Stack():\\n    def __init__(self):\\n        self.lst = []\\n\\n    def size(self):\\n        return len(self.lst)\\n    \\n    def add(self, v):\\n        self.lst.append(v)\\n        return None\\n\\n    def top(self):\\n        return self.lst[-1]\\n\\n    def pop(self):\\n        if self.size() == 0:\\n            print(\"empty stack pop\")\\n            return None\\n        return self.lst.pop()\\n\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        # memorized func\\n        def memory_f(func):\\n            ret = {}\\n            def memorized_f(*args):\\n                if args not in ret:\\n                    ret[args] = func(*args)\\n                return ret[args]\\n            return memorized_f\\n    \\n        # check the left\\n        def allowedLetterLeft(left, val):\\n            if left == \"\":\\n                return True\\n            for i in range(len(allowed)):\\n                if allowed[i][0] == left and allowed[i][1] == val:\\n                    return True\\n            return False\\n\\n        # check the triangle\\n        def allowedLetterDown(downL, downR, val):\\n            for i in range(len(allowed)):\\n                if allowed[i][0] == downL and allowed[i][1] == downR and allowed[i][2] == val:\\n                    return True\\n            return False\\n        \\n        # memory function allowedLetterDown and allowedLetterLeft\\n        allowedLetterDown, allowedLetterLeft = memory_f(allowedLetterDown), memory_f(allowedLetterLeft)\\n\\n        # expand condition\\n        def allowedLetter(left, downL, downR, val):\\n            return allowedLetterLeft(left, val) and allowedLetterDown(downL, downR, val)\\n        \\n        letters = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\\n        length = len(bottom)\\n\\n        # build a layer on the bottom\\n        def pyramidLayer(bottom):            \\n            length = len(bottom)\\n\\n            if length == 1:\\n                return True\\n            \\n            stack = Stack()\\n            ret = [\"\" for _ in range(length-1)]\\n\\n            for l in letters:\\n                if allowedLetter(\"\", bottom[0], bottom[1], l):\\n                    node = [0, l]\\n                    stack.add(node)\\n\\n            while stack.size() != 0:\\n                node = stack.pop()\\n                position, letter = node\\n                ret[position] = letter\\n\\n                # find a solution for this layer\\n                if position == length-2:\\n                    return ret\\n                \\n                # the block on the rigth of the node\\n                for l in letters:\\n                    if allowedLetter(letter, bottom[position+1], bottom[position+2], l):\\n                        stack.add([position+1, l])\\n\\n            return False\\n        \\n        # build by layers\\n        for _ in range(length-1, 0, -1):\\n            new_bottom = pyramidLayer(bottom)\\n            if new_bottom == False:\\n                return False\\n            else:\\n                bottom = new_bottom\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Stack for DFS\\nclass Stack():\\n    def __init__(self):\\n        self.lst = []\\n\\n    def size(self):\\n        return len(self.lst)\\n    \\n    def add(self, v):\\n        self.lst.append(v)\\n        return None\\n\\n    def top(self):\\n        return self.lst[-1]\\n\\n    def pop(self):\\n        if self.size() == 0:\\n            print(\"empty stack pop\")\\n            return None\\n        return self.lst.pop()\\n\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        # memorized func\\n        def memory_f(func):\\n            ret = {}\\n            def memorized_f(*args):\\n                if args not in ret:\\n                    ret[args] = func(*args)\\n                return ret[args]\\n            return memorized_f\\n    \\n        # check the left\\n        def allowedLetterLeft(left, val):\\n            if left == \"\":\\n                return True\\n            for i in range(len(allowed)):\\n                if allowed[i][0] == left and allowed[i][1] == val:\\n                    return True\\n            return False\\n\\n        # check the triangle\\n        def allowedLetterDown(downL, downR, val):\\n            for i in range(len(allowed)):\\n                if allowed[i][0] == downL and allowed[i][1] == downR and allowed[i][2] == val:\\n                    return True\\n            return False\\n        \\n        # memory function allowedLetterDown and allowedLetterLeft\\n        allowedLetterDown, allowedLetterLeft = memory_f(allowedLetterDown), memory_f(allowedLetterLeft)\\n\\n        # expand condition\\n        def allowedLetter(left, downL, downR, val):\\n            return allowedLetterLeft(left, val) and allowedLetterDown(downL, downR, val)\\n        \\n        letters = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\\n        length = len(bottom)\\n\\n        # build a layer on the bottom\\n        def pyramidLayer(bottom):            \\n            length = len(bottom)\\n\\n            if length == 1:\\n                return True\\n            \\n            stack = Stack()\\n            ret = [\"\" for _ in range(length-1)]\\n\\n            for l in letters:\\n                if allowedLetter(\"\", bottom[0], bottom[1], l):\\n                    node = [0, l]\\n                    stack.add(node)\\n\\n            while stack.size() != 0:\\n                node = stack.pop()\\n                position, letter = node\\n                ret[position] = letter\\n\\n                # find a solution for this layer\\n                if position == length-2:\\n                    return ret\\n                \\n                # the block on the rigth of the node\\n                for l in letters:\\n                    if allowedLetter(letter, bottom[position+1], bottom[position+2], l):\\n                        stack.add([position+1, l])\\n\\n            return False\\n        \\n        # build by layers\\n        for _ in range(length-1, 0, -1):\\n            new_bottom = pyramidLayer(bottom)\\n            if new_bottom == False:\\n                return False\\n            else:\\n                bottom = new_bottom\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890833,
                "title": "go-slow",
                "content": "```\\nfunc pyramidTransition(bottom string, allowed []string) bool {\\n    patterns := genPatterns(allowed)\\n    return dfs(bottom, patterns)\\n}\\n\\nfunc dfs(bottom string, patterns map[string][]string) bool {\\n    if len(bottom) == 2 && len(patterns[bottom]) > 0 {\\n        return true\\n    }\\n\\n    layers := []string{}\\n    genLayers(bottom, \"\", &layers, patterns)\\n\\n    for _, layer := range layers {\\n        if dfs(layer, patterns) {\\n            return true\\n        }\\n    }\\n\\n    return false\\n}\\n\\nfunc genLayers(bottom, cur string, layers *[]string, patterns map[string][]string) {\\n    if len(bottom) == 1 {\\n        *layers = append(*layers, cur)\\n        return\\n    }\\n\\n    pats := patterns[bottom[:2]]\\n\\n    for _, pat := range pats {\\n        genLayers(bottom[1:], cur + pat, layers, patterns)\\n    }\\n}\\n\\nfunc genPatterns(allowed []string) map[string][]string {\\n    patterns := make(map[string][]string)\\n\\n    for _, a := range allowed {\\n        base := string(a[:2])\\n        top := string(a[2])\\n        patterns[base] = append(patterns[base], top)\\n    }\\n\\n    return patterns\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pyramidTransition(bottom string, allowed []string) bool {\\n    patterns := genPatterns(allowed)\\n    return dfs(bottom, patterns)\\n}\\n\\nfunc dfs(bottom string, patterns map[string][]string) bool {\\n    if len(bottom) == 2 && len(patterns[bottom]) > 0 {\\n        return true\\n    }\\n\\n    layers := []string{}\\n    genLayers(bottom, \"\", &layers, patterns)\\n\\n    for _, layer := range layers {\\n        if dfs(layer, patterns) {\\n            return true\\n        }\\n    }\\n\\n    return false\\n}\\n\\nfunc genLayers(bottom, cur string, layers *[]string, patterns map[string][]string) {\\n    if len(bottom) == 1 {\\n        *layers = append(*layers, cur)\\n        return\\n    }\\n\\n    pats := patterns[bottom[:2]]\\n\\n    for _, pat := range pats {\\n        genLayers(bottom[1:], cur + pat, layers, patterns)\\n    }\\n}\\n\\nfunc genPatterns(allowed []string) map[string][]string {\\n    patterns := make(map[string][]string)\\n\\n    for _, a := range allowed {\\n        base := string(a[:2])\\n        top := string(a[2])\\n        patterns[base] = append(patterns[base], top)\\n    }\\n\\n    return patterns\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3783491,
                "title": "dfs-approach",
                "content": "# Intuition\\nBuild the top layer while traversing the bottom layer. Then go to top, once bottom is complete. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nLinear\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool PyramidTransition(string bottom, IList<string> allowed) {\\n        var nodes = new Dictionary<string, List<char>>();\\n        foreach(string item in allowed)\\n        {\\n            char parent = item[2];\\n            string key = item.Substring(0,2);\\n            if (!nodes.TryGetValue(key, out var parents))\\n            {\\n                parents = new List<char>();\\n                nodes.Add(key, parents);\\n            }\\n\\n            nodes[key].Add(parent);\\n        }\\n\\n        return CanTransition(bottom, string.Empty, nodes);\\n    }\\n\\n    private bool CanTransition(string bottom, string top, Dictionary<string, List<char>> nodes)\\n    {\\n        if (bottom.Length == 1)\\n        {\\n            if (top.Length == 1)\\n                return true;\\n\\n            if (top.Length == 0)\\n                return false;\\n\\n            bottom = top;\\n            top = string.Empty;\\n        }\\n\\n        var curr = bottom.Substring(0, 2);\\n        if (!nodes.TryGetValue(curr, out var parents))\\n            return false;\\n\\n        foreach(char parent in parents)\\n        {\\n            if (CanTransition(bottom.Substring(1), top + parent, nodes))\\n                return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool PyramidTransition(string bottom, IList<string> allowed) {\\n        var nodes = new Dictionary<string, List<char>>();\\n        foreach(string item in allowed)\\n        {\\n            char parent = item[2];\\n            string key = item.Substring(0,2);\\n            if (!nodes.TryGetValue(key, out var parents))\\n            {\\n                parents = new List<char>();\\n                nodes.Add(key, parents);\\n            }\\n\\n            nodes[key].Add(parent);\\n        }\\n\\n        return CanTransition(bottom, string.Empty, nodes);\\n    }\\n\\n    private bool CanTransition(string bottom, string top, Dictionary<string, List<char>> nodes)\\n    {\\n        if (bottom.Length == 1)\\n        {\\n            if (top.Length == 1)\\n                return true;\\n\\n            if (top.Length == 0)\\n                return false;\\n\\n            bottom = top;\\n            top = string.Empty;\\n        }\\n\\n        var curr = bottom.Substring(0, 2);\\n        if (!nodes.TryGetValue(curr, out var parents))\\n            return false;\\n\\n        foreach(char parent in parents)\\n        {\\n            if (CanTransition(bottom.Substring(1), top + parent, nodes))\\n                return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284504,
                "title": "simple-c-dfs-and-back-tracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool f2(int ind,string &curr,unordered_map<string,vector<char>> &umap,string temp){\\n        \\n        if(ind==curr.size()-1){\\n            return f(temp,umap);\\n        }\\n        \\n        string req = curr.substr(ind,2);\\n        \\n        for(auto iter : umap[req]){\\n            if(f2(ind+1,curr,umap,temp+iter)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool f(string &curr,unordered_map<string,vector<char>> &umap){\\n        \\n        if(curr.size()==1){\\n            return true;\\n        }\\n\\n        string temp;\\n        \\n        for(int i = 0;i<curr.size()-1;i++){\\n            temp = curr.substr(i,2);\\n            if(umap.find(temp)==umap.end()){\\n                return false;\\n            }\\n        }\\n    \\n        return f2(0,curr,umap,\"\");\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n        unordered_map <string,vector<char>> umap;\\n        for(auto iter : allowed){\\n            umap[iter.substr(0,2)].push_back(iter[2]);\\n        }\\n        return f(bottom,umap);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool f2(int ind,string &curr,unordered_map<string,vector<char>> &umap,string temp){\\n        \\n        if(ind==curr.size()-1){\\n            return f(temp,umap);\\n        }\\n        \\n        string req = curr.substr(ind,2);\\n        \\n        for(auto iter : umap[req]){\\n            if(f2(ind+1,curr,umap,temp+iter)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool f(string &curr,unordered_map<string,vector<char>> &umap){\\n        \\n        if(curr.size()==1){\\n            return true;\\n        }\\n\\n        string temp;\\n        \\n        for(int i = 0;i<curr.size()-1;i++){\\n            temp = curr.substr(i,2);\\n            if(umap.find(temp)==umap.end()){\\n                return false;\\n            }\\n        }\\n    \\n        return f2(0,curr,umap,\"\");\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n        unordered_map <string,vector<char>> umap;\\n        for(auto iter : allowed){\\n            umap[iter.substr(0,2)].push_back(iter[2]);\\n        }\\n        return f(bottom,umap);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222063,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string btm, vector<string>& allowed) {     \\n        // prework\\uFF1A\\n        unordered_map<int,unordered_set<char>> dict;\\n        for (auto& s : allowed) dict[s[0]<<16|s[1]].insert(s[2]);\\n        \\n        unordered_set<string> f[2];\\n        f[0].insert(btm);\\n        \\n        int x = 0, l = 0, r = 0;\\n        for (int len = btm.size(); len >= 2; len--) {        \\n            for (int i = 1; i < len; i++) {         x ^= 1;\\n                for (auto s : f[1-x]) {             l = s[i-1], r = s[i];\\n                    for (auto m : dict[l<<16|r]) {\\n                        s[i-1] = m;\\n                        f[x].insert(s);\\n                        s[i-1] = l;\\n                    }\\n                }\\n                f[1-x].clear();\\n            }\\n            unordered_set<string> tmp;\\n            for (auto s : f[x]) s.pop_back(), tmp.insert(s);\\n            swap(f[x], tmp);\\n        }\\n        \\n        return !f[x].empty();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string btm, vector<string>& allowed) {     \\n        // prework\\uFF1A\\n        unordered_map<int,unordered_set<char>> dict;\\n        for (auto& s : allowed) dict[s[0]<<16|s[1]].insert(s[2]);\\n        \\n        unordered_set<string> f[2];\\n        f[0].insert(btm);\\n        \\n        int x = 0, l = 0, r = 0;\\n        for (int len = btm.size(); len >= 2; len--) {        \\n            for (int i = 1; i < len; i++) {         x ^= 1;\\n                for (auto s : f[1-x]) {             l = s[i-1], r = s[i];\\n                    for (auto m : dict[l<<16|r]) {\\n                        s[i-1] = m;\\n                        f[x].insert(s);\\n                        s[i-1] = l;\\n                    }\\n                }\\n                f[1-x].clear();\\n            }\\n            unordered_set<string> tmp;\\n            for (auto s : f[x]) s.pop_back(), tmp.insert(s);\\n            swap(f[x], tmp);\\n        }\\n        \\n        return !f[x].empty();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205312,
                "title": "c",
                "content": "```\\nclass Solution {\\n private:\\n  bool dfs(const string& row, const string& nextRow, int i,\\n         unordered_map<string, vector<char>>& Map) \\n  {\\n    if (row.length() == 1)\\n      return true;\\n  \\n    if (nextRow.length() == row.length() - 1)\\n      return dfs(nextRow, \"\", 0, Map);\\n\\n    const string& prefix = row.substr(i, 2);\\n\\n    if (Map.find(prefix) != Map.end()){\\n      for (auto c : Map[prefix])\\n        if (dfs(row, nextRow + c, i + 1, Map))\\n          return true;\\n    }\\n\\n    return false;\\n  }\\n public:\\n  bool pyramidTransition(string bottom, vector<string>& allowed) {\\n    unordered_map<string, vector<char>> Map;\\n\\n    for (auto& a : allowed)\\n      Map[a.substr(0, 2)].push_back(a[2]);\\n\\n    return dfs(bottom, \"\", 0, Map);\\n  }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n private:\\n  bool dfs(const string& row, const string& nextRow, int i,\\n         unordered_map<string, vector<char>>& Map) \\n  {\\n    if (row.length() == 1)\\n      return true;\\n  \\n    if (nextRow.length() == row.length() - 1)\\n      return dfs(nextRow, \"\", 0, Map);\\n\\n    const string& prefix = row.substr(i, 2);\\n\\n    if (Map.find(prefix) != Map.end()){\\n      for (auto c : Map[prefix])\\n        if (dfs(row, nextRow + c, i + 1, Map))\\n          return true;\\n    }\\n\\n    return false;\\n  }\\n public:\\n  bool pyramidTransition(string bottom, vector<string>& allowed) {\\n    unordered_map<string, vector<char>> Map;\\n\\n    for (auto& a : allowed)\\n      Map[a.substr(0, 2)].push_back(a[2]);\\n\\n    return dfs(bottom, \"\", 0, Map);\\n  }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100877,
                "title": "recursive-dp-dfs-solution-6ms-runtime-100-2-3mb-memory-100",
                "content": "# Intuition\\nBuild a hashmap of bottom character pairs and a list of their valid top characters. Build a hashet that tracks fully built bottom rows that have no solution. Traverse possible search space using a DFS, early exiting if the top row is contained in the set of all failed bottom rows.\\n\\n# Approach\\nIn the function `solve`:\\n- `bottom` is our current row\\n- `allowed` is a hashmap of bottom 2-char combos and their corresponding list of valid top characters\\n- `failed` is a hashset containing a list of bottom rows that do not have a solution\\n- `top` is a slice that has our working top row and additional empty space for future top rows\\n- `top_vec` is a vec that has the working top row (only useful for hashset checks)\\n\\nWe first check if the length of the bottom row is 1 because if it is then we report a success. We never get an input of size 1 so it mustve been called with a valid top character.\\n\\nOtherwise we check if the top row is 1 less than the bottom row. If that is the case then the top row is filled out and we split off that row from the entire top slice. That split off top row becomes the bottom and we start over with this. If that new bottom fails we add it to the failed list, revert our state, and report failure. If it succeeds then we report a success.\\n\\nOtherwise we check if the current iteration of the top row is contained within the failed set. If so then we already know we will fail since that part as a bottom row will not have a solution.\\n\\nOtherwise we are in-progress of filling out the current bottom. The effective length of the top row tells us how much is filled out. We calculate the next pair of characters to look at in the bottom row using the length of our top row. Then we check our hashmap for a corresponding list of top characters. For each top character we push it to our top row and call our solver again. If it returns true we are done and return true. If it returns false then we pop the character, go to the next one, and repeat. If no solver calls return true then we cannot find a valid state. We report the failure.\\n\\nAt the start we allocate enough space in top to house the number of blocks that would exist in a theoretically valid pyramid minus the bottom row since that is determined for us and we convert our bottom string and allowed string vector to the appropriate data structures to run our first solver call.\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn solve(\\n        bottom: &[u8],\\n        allowed: &HashMap<[u8; 2], Vec<u8>>,\\n        failed: &mut HashSet<Vec<u8>>,\\n        top_vec: &mut Vec<u8>,\\n        top: &mut [u8],\\n    ) -> bool {\\n        if bottom.len() == 1 {\\n            return true;\\n        } else if bottom.len() == top_vec.len() + 1 {\\n            let (bottom, top) = top.split_at_mut(top_vec.len());\\n            top_vec.clear();\\n            if Solution::solve(bottom, allowed, failed, top_vec, top) {\\n                return true;\\n            } else {\\n                failed.insert(bottom.to_vec());\\n                top_vec.extend_from_slice(bottom);\\n                return false;\\n            }\\n        } else if failed.contains(top_vec) {\\n            return false;\\n        }\\n\\n        if let Some(top_bytes) = allowed.get(&[bottom[top_vec.len()], bottom[top_vec.len() + 1]]) {\\n            for top_byte in top_bytes.iter() {\\n                top[top_vec.len()] = *top_byte;\\n                top_vec.push(*top_byte);\\n\\n                if !failed.contains(top_vec) {\\n                    if Solution::solve(bottom, allowed, failed, top_vec, top) {\\n                        return true;\\n                    }\\n                }\\n\\n                top_vec.pop();\\n            }\\n        };\\n\\n        false\\n    }\\n\\n    pub fn pyramid_transition(bottom: String, allowed: Vec<String>) -> bool {\\n        let mut map: HashMap<[u8; 2], Vec<u8>> = HashMap::new();\\n\\n        for s in allowed.iter().map(String::as_bytes) {\\n            let allowed_bottom = [s[0], s[1]];\\n            let allowed_top = s[2];\\n\\n            if let Some(v) = map.get_mut(&allowed_bottom) {\\n                v.push(allowed_top);\\n            } else {\\n                map.insert(allowed_bottom, vec![allowed_top]);\\n            }\\n        }\\n\\n        Solution::solve(\\n            bottom.as_bytes(),\\n            &map,\\n            &mut HashSet::new(),\\n            &mut Vec::with_capacity(bottom.len() - 1),\\n            &mut vec![0; (bottom.len() - 1) * bottom.len() / 2],\\n        )\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn solve(\\n        bottom: &[u8],\\n        allowed: &HashMap<[u8; 2], Vec<u8>>,\\n        failed: &mut HashSet<Vec<u8>>,\\n        top_vec: &mut Vec<u8>,\\n        top: &mut [u8],\\n    ) -> bool {\\n        if bottom.len() == 1 {\\n            return true;\\n        } else if bottom.len() == top_vec.len() + 1 {\\n            let (bottom, top) = top.split_at_mut(top_vec.len());\\n            top_vec.clear();\\n            if Solution::solve(bottom, allowed, failed, top_vec, top) {\\n                return true;\\n            } else {\\n                failed.insert(bottom.to_vec());\\n                top_vec.extend_from_slice(bottom);\\n                return false;\\n            }\\n        } else if failed.contains(top_vec) {\\n            return false;\\n        }\\n\\n        if let Some(top_bytes) = allowed.get(&[bottom[top_vec.len()], bottom[top_vec.len() + 1]]) {\\n            for top_byte in top_bytes.iter() {\\n                top[top_vec.len()] = *top_byte;\\n                top_vec.push(*top_byte);\\n\\n                if !failed.contains(top_vec) {\\n                    if Solution::solve(bottom, allowed, failed, top_vec, top) {\\n                        return true;\\n                    }\\n                }\\n\\n                top_vec.pop();\\n            }\\n        };\\n\\n        false\\n    }\\n\\n    pub fn pyramid_transition(bottom: String, allowed: Vec<String>) -> bool {\\n        let mut map: HashMap<[u8; 2], Vec<u8>> = HashMap::new();\\n\\n        for s in allowed.iter().map(String::as_bytes) {\\n            let allowed_bottom = [s[0], s[1]];\\n            let allowed_top = s[2];\\n\\n            if let Some(v) = map.get_mut(&allowed_bottom) {\\n                v.push(allowed_top);\\n            } else {\\n                map.insert(allowed_bottom, vec![allowed_top]);\\n            }\\n        }\\n\\n        Solution::solve(\\n            bottom.as_bytes(),\\n            &map,\\n            &mut HashSet::new(),\\n            &mut Vec::with_capacity(bottom.len() - 1),\\n            &mut vec![0; (bottom.len() - 1) * bottom.len() / 2],\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3092648,
                "title": "top-down-hashmap-memo",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<String>> sequenceHolder = new HashMap<>();\\n\\n        for (String str : allowed) {\\n            String key = str.substring(0, 2);\\n            String val = str.substring(2);\\n\\n            if (!sequenceHolder.containsKey(key)) {\\n                sequenceHolder.put(key, new ArrayList<>());\\n            }    \\n            sequenceHolder.get(key).add(val);\\n        }\\n        return recur(sequenceHolder, bottom, new StringBuilder(), 1, new HashMap<String, Boolean>());\\n    }\\n\\n    private boolean recur(Map<String, List<String>> sequenceHolder, String currRow, StringBuilder nextRow, \\n        int currIndex, HashMap<String, Boolean> memo) {\\n\\n        if (currRow.length() == 1) {\\n            return true;\\n        }\\n\\n        if (currIndex == currRow.length()) {\\n            return recur(sequenceHolder, nextRow.toString(), new StringBuilder(), 1, memo);\\n        }\\n        String memokey = currRow + \"|\" + nextRow + \"|\" + currIndex;\\n        String key = \"\" + currRow.charAt(currIndex - 1) + currRow.charAt(currIndex);\\n\\n        if (memo.containsKey(memokey)) {\\n            return memo.get(memokey);\\n        }\\n        boolean ans = false;\\n\\n        if (sequenceHolder.containsKey(key)) {\\n\\n            for (String child : sequenceHolder.get(key)) {\\n                nextRow.append(child);\\n\\n                if (recur(sequenceHolder, currRow, nextRow, currIndex + 1, memo)) {\\n                    ans = true;\\n                    break;\\n                }\\n                nextRow.deleteCharAt(nextRow.length() - 1);\\n            }\\n        }\\n        memo.put(memokey, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<String>> sequenceHolder = new HashMap<>();\\n\\n        for (String str : allowed) {\\n            String key = str.substring(0, 2);\\n            String val = str.substring(2);\\n\\n            if (!sequenceHolder.containsKey(key)) {\\n                sequenceHolder.put(key, new ArrayList<>());\\n            }    \\n            sequenceHolder.get(key).add(val);\\n        }\\n        return recur(sequenceHolder, bottom, new StringBuilder(), 1, new HashMap<String, Boolean>());\\n    }\\n\\n    private boolean recur(Map<String, List<String>> sequenceHolder, String currRow, StringBuilder nextRow, \\n        int currIndex, HashMap<String, Boolean> memo) {\\n\\n        if (currRow.length() == 1) {\\n            return true;\\n        }\\n\\n        if (currIndex == currRow.length()) {\\n            return recur(sequenceHolder, nextRow.toString(), new StringBuilder(), 1, memo);\\n        }\\n        String memokey = currRow + \"|\" + nextRow + \"|\" + currIndex;\\n        String key = \"\" + currRow.charAt(currIndex - 1) + currRow.charAt(currIndex);\\n\\n        if (memo.containsKey(memokey)) {\\n            return memo.get(memokey);\\n        }\\n        boolean ans = false;\\n\\n        if (sequenceHolder.containsKey(key)) {\\n\\n            for (String child : sequenceHolder.get(key)) {\\n                nextRow.append(child);\\n\\n                if (recur(sequenceHolder, currRow, nextRow, currIndex + 1, memo)) {\\n                    ans = true;\\n                    break;\\n                }\\n                nextRow.deleteCharAt(nextRow.length() - 1);\\n            }\\n        }\\n        memo.put(memokey, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077848,
                "title": "backtracking-dp-approach-java-simple-solution-clean-code",
                "content": "# Code\\n```java\\nclass Solution {\\n    Map<String,List<Character>> mp;\\n    Map<String,Boolean> dp;\\n    boolean helper(String bottom,int idx,String temp){\\n        if(bottom.length() == 1) return true;\\n        if(dp.containsKey(bottom + temp)) return dp.get(bottom + temp);\\n        if(idx == bottom.length()) return helper(temp,1,\"\");\\n        String key = \"\" + bottom.charAt(idx - 1) + bottom.charAt(idx);\\n        if(!mp.containsKey(key)){\\n            dp.put(bottom + temp,false);\\n            return false;\\n        }\\n        for(var c:mp.get(key)){\\n            if(helper(bottom,idx + 1,temp + c)){\\n                dp.put(bottom + temp + c,true);\\n                return true;\\n            }\\n        }\\n        dp.put(bottom + temp,false);\\n        return false;\\n    }\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        mp = new HashMap<>();\\n        dp = new HashMap<>();\\n        for(var a:allowed){\\n            String key = \"\" + a.charAt(0) + a.charAt(1);\\n            if(!mp.containsKey(key)) mp.put(key,new ArrayList<>());\\n            mp.get(key).add(a.charAt(2));\\n        }\\n        return helper(bottom,1,\"\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```java\\nclass Solution {\\n    Map<String,List<Character>> mp;\\n    Map<String,Boolean> dp;\\n    boolean helper(String bottom,int idx,String temp){\\n        if(bottom.length() == 1) return true;\\n        if(dp.containsKey(bottom + temp)) return dp.get(bottom + temp);\\n        if(idx == bottom.length()) return helper(temp,1,\"\");\\n        String key = \"\" + bottom.charAt(idx - 1) + bottom.charAt(idx);\\n        if(!mp.containsKey(key)){\\n            dp.put(bottom + temp,false);\\n            return false;\\n        }\\n        for(var c:mp.get(key)){\\n            if(helper(bottom,idx + 1,temp + c)){\\n                dp.put(bottom + temp + c,true);\\n                return true;\\n            }\\n        }\\n        dp.put(bottom + temp,false);\\n        return false;\\n    }\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        mp = new HashMap<>();\\n        dp = new HashMap<>();\\n        for(var a:allowed){\\n            String key = \"\" + a.charAt(0) + a.charAt(1);\\n            if(!mp.containsKey(key)) mp.put(key,new ArrayList<>());\\n            mp.get(key).add(a.charAt(2));\\n        }\\n        return helper(bottom,1,\"\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911809,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn pyramid_transition(bottom: String, allowed: Vec<String>) -> bool {\\n        let mut m = HashMap::new();\\n        for s in allowed {\\n            m.entry(s[0..2].to_string())\\n                .or_insert_with(Vec::new)\\n                .push(s[2..3].to_string());\\n        }\\n        let mut failed_states = HashSet::new();\\n        Self::helper(&bottom, &m, 0, \"\", &mut failed_states)\\n    }\\n\\n    fn helper(\\n        bottom: &str,\\n        m: &HashMap<String, Vec<String>>,\\n        start: usize,\\n        next: &str,\\n        failed_states: &mut HashSet<String>,\\n    ) -> bool {\\n        if bottom.len() == 1 {\\n            return true;\\n        }\\n        if start == bottom.len() - 1 {\\n            return Self::helper(next, m, 0, \"\", failed_states);\\n        }\\n        if failed_states.contains(&(bottom[start..].to_string() + \"#\" + next)) {\\n            return false;\\n        }\\n        let v = m\\n            .get(&(bottom[start..start + 2].to_string()))\\n            .unwrap_or(&vec![])\\n            .clone();\\n        for c in v.into_iter() {\\n            let next = next.to_string() + c.as_str();\\n            if Self::helper(bottom, m, start + 1, &next, failed_states) {\\n                return true;\\n            }\\n        }\\n        failed_states.insert(bottom[start..].to_string() + \"#\" + next);\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn pyramid_transition(bottom: String, allowed: Vec<String>) -> bool {\\n        let mut m = HashMap::new();\\n        for s in allowed {\\n            m.entry(s[0..2].to_string())\\n                .or_insert_with(Vec::new)\\n                .push(s[2..3].to_string());\\n        }\\n        let mut failed_states = HashSet::new();\\n        Self::helper(&bottom, &m, 0, \"\", &mut failed_states)\\n    }\\n\\n    fn helper(\\n        bottom: &str,\\n        m: &HashMap<String, Vec<String>>,\\n        start: usize,\\n        next: &str,\\n        failed_states: &mut HashSet<String>,\\n    ) -> bool {\\n        if bottom.len() == 1 {\\n            return true;\\n        }\\n        if start == bottom.len() - 1 {\\n            return Self::helper(next, m, 0, \"\", failed_states);\\n        }\\n        if failed_states.contains(&(bottom[start..].to_string() + \"#\" + next)) {\\n            return false;\\n        }\\n        let v = m\\n            .get(&(bottom[start..start + 2].to_string()))\\n            .unwrap_or(&vec![])\\n            .clone();\\n        for c in v.into_iter() {\\n            let next = next.to_string() + c.as_str();\\n            if Self::helper(bottom, m, start + 1, &next, failed_states) {\\n                return true;\\n            }\\n        }\\n        failed_states.insert(bottom[start..].to_string() + \"#\" + next);\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2898084,
                "title": "c-super-simple-dfs-works-on-the-latest-testcases",
                "content": "\\n```\\nclass Solution {\\npublic:\\n  bool pyramidTransition(string bottom, vector<string>& allowed) {\\n    unordered_map<string, vector<char>> m;\\n    for(auto& s:allowed) m[s.substr(0, 2)].push_back(s.back());\\n    unordered_set<string> failedStates;\\n    return helper(bottom, m, 0, \"\", failedStates);\\n  }\\n  bool helper(string bottom, unordered_map<string, vector<char>>& m, int start, string next, unordered_set<string> &failedStates){\\n    if(bottom.size() == 1) return true;\\n    if(start == (int)bottom.size() - 1) return helper(next, m, 0, \"\", failedStates);\\n    if(failedStates.find(bottom.substr(start) + \"#\" + next) != failedStates.end()) {return false;}\\n    for(char c : m[bottom.substr(start, 2)])\\n      if(helper(bottom, m, start+1, next+c, failedStates)) return true;\\n    failedStates.insert(bottom.substr(start) + \"#\" + next);\\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool pyramidTransition(string bottom, vector<string>& allowed) {\\n    unordered_map<string, vector<char>> m;\\n    for(auto& s:allowed) m[s.substr(0, 2)].push_back(s.back());\\n    unordered_set<string> failedStates;\\n    return helper(bottom, m, 0, \"\", failedStates);\\n  }\\n  bool helper(string bottom, unordered_map<string, vector<char>>& m, int start, string next, unordered_set<string> &failedStates){\\n    if(bottom.size() == 1) return true;\\n    if(start == (int)bottom.size() - 1) return helper(next, m, 0, \"\", failedStates);\\n    if(failedStates.find(bottom.substr(start) + \"#\" + next) != failedStates.end()) {return false;}\\n    for(char c : m[bottom.substr(start, 2)])\\n      if(helper(bottom, m, start+1, next+c, failedStates)) return true;\\n    failedStates.insert(bottom.substr(start) + \"#\" + next);\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820930,
                "title": "javascript-lots-of-comments",
                "content": "```\\n/**\\n * @param {string} bottom\\n * @param {string[]} allowed\\n * @return {boolean}\\n */\\nvar pyramidTransition = function(bottom, allowed) {\\n    const map = {};\\n    //create a map consisting of all pairs in allowed and their corresponding tops\\n        //  examples:\\n    \\n        //  { BC: [ \\'C\\' ], CD: [ \\'E\\' ], CE: [ \\'A\\' ], FF: [ \\'F\\' ] }\\n    \\n        //      or\\n    \\n        //{ AA: [ \\'B\\', \\'C\\' ], BC: [ \\'D\\' ], BB: [ \\'E\\' ], DE: [ \\'F\\' ] }\\n\\n    for (let top of allowed){\\n        let currentTop = top.substring(2);\\n        let currentBottomPair = top.substring(0,2)\\n        \\n        if (!(currentBottomPair in map)){\\n            map[currentBottomPair] = []\\n        };\\n        map[currentBottomPair].push(currentTop)\\n    };\\n    \\n    //set up a queue that will hold all possible options for the current row\\n    //initially this will be [bottom]  (only one option for the lowest row)\\n    \\n    let queue = [bottom];\\n    \\n    //create a set to avoid putting duplicates onto the queue\\n    \\n    let set = new Set();\\n    \\n    //set up a counter (\\'j\\') that will run a loop until the penultimate row\\n        //in other words, when all options consist of two letters, we will exit the loop\\n    \\n    for (let j = 1; j < bottom.length-1; j ++){\\n       \\n        //for each row, grab every possible option using queue.shift()\\n        //(using queue.length to determine when we have exausted all of that row\\'s options)\\n        \\n        // for each possible option in that row, get all of its next row options and add those to the queue \\n        \\n        let length = queue.length;\\n        for (let i = 0; i < length; i ++){\\n            const current = queue.shift();\\n            let options = getAllNextRowPossibles(current);\\n            for (let option of options){\\n                if (!set.has(option)){\\n                    set.add(option);\\n                    queue.push(option);\\n                };\\n            };\\n        \\n        };\\n    };\\n    //once we hit the row with only two-letter options, check to see if any of the options is in map.\\n    //if any one of the pairs is in map, return true\\n    //otherwise return false\\n    \\n    for (let i = 0; i < queue.length; i ++){\\n        if (queue[i] in map) return true;\\n    };\\n    \\n    return false;\\n    \\n    \\n    //the getAllNextRowPossibles function will take any possible row and return all of the options for the next row up\\n    //it uses two arrays:\\n        //nextRowOptions acts as the \\'master\\' array to hold all options\\n        //replacementOptions acts as a \\'temporary\\' array\\n    \\n    function getAllNextRowPossibles (row){\\n     let nextRowOptions = [\\'\\'];\\n     let replacementOptions = []\\n     for (let i = 0; i < row.length-1; i ++){\\n        \\n        const pair = row[i]+row[i+1];\\n         \\n     //for each pair in the current row, we use map to find all possible \"top\" letters\\n     //then add every \"top\" letter to every existing option in nextRowOptions and add the result to replacementOptions\\n     //once we have done that for every \"top\" letter (for that pair), replace nextRowOptions with a copy of replacementOptions and\\n        //reset replacementOptions to an empty array\\n    //this way, as we work our way across the pairs in the current row, each option in nextRowOptions grows by one letter, ultimately giving us every combination\\n         \\n    //here is an example:\\n         \\n         //map = {AA: [\\'B\\', \\'C\\', \\'D\\'], AB: [\\'E\\', \\'F\\']}\\n         //row = \\'AAB\\'\\n         //nextRowOptions = [\\'\\']; replacementOptions = [];\\n         //first pair is \\'AA\\', which has three \"top\" letters (\\'B\\', \\'C\\' and \\'D\\')\\n         //loop through every option in nextRowOptions (which happens to be \\'\\' since we are just starting)\\n         //we add each top letter to \\'\\' and push it into replacementOptions\\n         //replacementOptions will then be [\\'B\\', \\'C\\', \\'D\\']\\n         //convert nextRowOptions to a copy of replacementOptions and reset replacementOptions to []\\n         //loop through every option in nextRowOptions ([\\'B\\', \\'C\\', \\'D\\']) and add every \\'top\\' letter for the next pair (AB), push to replacementOptions\\n         //replacementOptions becomes [\\'BE\\', \\'BF\\', \\'CE\\', \\'CF\\', \\'DE\\', \\'DF\\']\\n         //convert nextRowOptions to a copy of replacementOptions and since we have hit the last pair of this row, return nextRowOptions\\n    \\n         \\n        if (pair in map){\\n            for (let existingOption of nextRowOptions){\\n                for (let newOption of map[pair]){\\n                    let item = existingOption + newOption\\n                \\n                    replacementOptions.push(item);\\n                \\n                };\\n            };\\n        };\\n        nextRowOptions = [...replacementOptions];\\n        replacementOptions = [];\\n        \\n      };\\n    return (nextRowOptions)\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string} bottom\\n * @param {string[]} allowed\\n * @return {boolean}\\n */\\nvar pyramidTransition = function(bottom, allowed) {\\n    const map = {};\\n    //create a map consisting of all pairs in allowed and their corresponding tops\\n        //  examples:\\n    \\n        //  { BC: [ \\'C\\' ], CD: [ \\'E\\' ], CE: [ \\'A\\' ], FF: [ \\'F\\' ] }\\n    \\n        //      or\\n    \\n        //{ AA: [ \\'B\\', \\'C\\' ], BC: [ \\'D\\' ], BB: [ \\'E\\' ], DE: [ \\'F\\' ] }\\n\\n    for (let top of allowed){\\n        let currentTop = top.substring(2);\\n        let currentBottomPair = top.substring(0,2)\\n        \\n        if (!(currentBottomPair in map)){\\n            map[currentBottomPair] = []\\n        };\\n        map[currentBottomPair].push(currentTop)\\n    };\\n    \\n    //set up a queue that will hold all possible options for the current row\\n    //initially this will be [bottom]  (only one option for the lowest row)\\n    \\n    let queue = [bottom];\\n    \\n    //create a set to avoid putting duplicates onto the queue\\n    \\n    let set = new Set();\\n    \\n    //set up a counter (\\'j\\') that will run a loop until the penultimate row\\n        //in other words, when all options consist of two letters, we will exit the loop\\n    \\n    for (let j = 1; j < bottom.length-1; j ++){\\n       \\n        //for each row, grab every possible option using queue.shift()\\n        //(using queue.length to determine when we have exausted all of that row\\'s options)\\n        \\n        // for each possible option in that row, get all of its next row options and add those to the queue \\n        \\n        let length = queue.length;\\n        for (let i = 0; i < length; i ++){\\n            const current = queue.shift();\\n            let options = getAllNextRowPossibles(current);\\n            for (let option of options){\\n                if (!set.has(option)){\\n                    set.add(option);\\n                    queue.push(option);\\n                };\\n            };\\n        \\n        };\\n    };\\n    //once we hit the row with only two-letter options, check to see if any of the options is in map.\\n    //if any one of the pairs is in map, return true\\n    //otherwise return false\\n    \\n    for (let i = 0; i < queue.length; i ++){\\n        if (queue[i] in map) return true;\\n    };\\n    \\n    return false;\\n    \\n    \\n    //the getAllNextRowPossibles function will take any possible row and return all of the options for the next row up\\n    //it uses two arrays:\\n        //nextRowOptions acts as the \\'master\\' array to hold all options\\n        //replacementOptions acts as a \\'temporary\\' array\\n    \\n    function getAllNextRowPossibles (row){\\n     let nextRowOptions = [\\'\\'];\\n     let replacementOptions = []\\n     for (let i = 0; i < row.length-1; i ++){\\n        \\n        const pair = row[i]+row[i+1];\\n         \\n     //for each pair in the current row, we use map to find all possible \"top\" letters\\n     //then add every \"top\" letter to every existing option in nextRowOptions and add the result to replacementOptions\\n     //once we have done that for every \"top\" letter (for that pair), replace nextRowOptions with a copy of replacementOptions and\\n        //reset replacementOptions to an empty array\\n    //this way, as we work our way across the pairs in the current row, each option in nextRowOptions grows by one letter, ultimately giving us every combination\\n         \\n    //here is an example:\\n         \\n         //map = {AA: [\\'B\\', \\'C\\', \\'D\\'], AB: [\\'E\\', \\'F\\']}\\n         //row = \\'AAB\\'\\n         //nextRowOptions = [\\'\\']; replacementOptions = [];\\n         //first pair is \\'AA\\', which has three \"top\" letters (\\'B\\', \\'C\\' and \\'D\\')\\n         //loop through every option in nextRowOptions (which happens to be \\'\\' since we are just starting)\\n         //we add each top letter to \\'\\' and push it into replacementOptions\\n         //replacementOptions will then be [\\'B\\', \\'C\\', \\'D\\']\\n         //convert nextRowOptions to a copy of replacementOptions and reset replacementOptions to []\\n         //loop through every option in nextRowOptions ([\\'B\\', \\'C\\', \\'D\\']) and add every \\'top\\' letter for the next pair (AB), push to replacementOptions\\n         //replacementOptions becomes [\\'BE\\', \\'BF\\', \\'CE\\', \\'CF\\', \\'DE\\', \\'DF\\']\\n         //convert nextRowOptions to a copy of replacementOptions and since we have hit the last pair of this row, return nextRowOptions\\n    \\n         \\n        if (pair in map){\\n            for (let existingOption of nextRowOptions){\\n                for (let newOption of map[pair]){\\n                    let item = existingOption + newOption\\n                \\n                    replacementOptions.push(item);\\n                \\n                };\\n            };\\n        };\\n        nextRowOptions = [...replacementOptions];\\n        replacementOptions = [];\\n        \\n      };\\n    return (nextRowOptions)\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2794622,
                "title": "python-straightforward-dfs-with-heuristic-pruning",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nClassical DFS may got TLE.\\n\\nTwo heuristic pruning strategies are added to reduce the running time.\\n(1) We check whether this block can make a potential base with the previous block.\\n(2) We check whether this block is the \"left\" block of some base.\\n\\n# Code\\n```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mem = dict()\\n        mem2 = set()\\n        for a in allowed:\\n            if a[:2] not in mem:\\n                mem[a[:2]] = list()\\n            \\n            mem2.add(a[0])\\n\\n            mem[a[:2]].append(a[-1])\\n        \\n        n = len(bottom)\\n\\n        def helper(cur_sol, i, j):\\n            if i == n:\\n                return True\\n            \\n            l, r = cur_sol[i - 1][j], cur_sol[i - 1][j + 1]\\n            if l + r in mem:\\n                for candidate in mem[l + r]:\\n                    if j == 0 or (j > 0 and cur_sol[i][j - 1] + candidate in mem):\\n                        if j == n - i - 1 or (j < n - i - 1 and candidate in mem2):\\n                            cur_sol[i].append(candidate)\\n                            if j < n - i - 1:\\n                                next_i, next_j = i, j + 1\\n                            else:\\n                                next_i, next_j = i + 1, 0\\n                            if helper(cur_sol, next_i, next_j):\\n                                return True\\n\\n                            cur_sol[i].pop()\\n\\n            return False\\n\\n        cur_sol = [list(bottom)] + [list() for _ in range(n - 1)]\\n        return helper(cur_sol, 1, 0)            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mem = dict()\\n        mem2 = set()\\n        for a in allowed:\\n            if a[:2] not in mem:\\n                mem[a[:2]] = list()\\n            \\n            mem2.add(a[0])\\n\\n            mem[a[:2]].append(a[-1])\\n        \\n        n = len(bottom)\\n\\n        def helper(cur_sol, i, j):\\n            if i == n:\\n                return True\\n            \\n            l, r = cur_sol[i - 1][j], cur_sol[i - 1][j + 1]\\n            if l + r in mem:\\n                for candidate in mem[l + r]:\\n                    if j == 0 or (j > 0 and cur_sol[i][j - 1] + candidate in mem):\\n                        if j == n - i - 1 or (j < n - i - 1 and candidate in mem2):\\n                            cur_sol[i].append(candidate)\\n                            if j < n - i - 1:\\n                                next_i, next_j = i, j + 1\\n                            else:\\n                                next_i, next_j = i + 1, 0\\n                            if helper(cur_sol, next_i, next_j):\\n                                return True\\n\\n                            cur_sol[i].pop()\\n\\n            return False\\n\\n        cur_sol = [list(bottom)] + [list() for _ in range(n - 1)]\\n        return helper(cur_sol, 1, 0)            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729321,
                "title": "python-memoized-dfs-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    @cache\\n    def dfs(self, level, idx, nxt):\\n        if len(level) == 1:\\n            return True\\n        if len(level) - 1 == len(nxt):\\n            return self.dfs(nxt, 0, \\'\\')\\n        if idx == len(level) - 1:\\n            return False\\n        for char in self.pyramids[level[idx] + level[idx + 1]]:\\n            if self.dfs(level, idx + 1, nxt + char):\\n                return True\\n        return False\\n    \\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        self.pyramids = defaultdict(list)\\n        for pyramid in allowed:\\n            self.pyramids[pyramid[:2]].append(pyramid[2])\\n        return self.dfs(bottom, 0, \\'\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    @cache\\n    def dfs(self, level, idx, nxt):\\n        if len(level) == 1:\\n            return True\\n        if len(level) - 1 == len(nxt):\\n            return self.dfs(nxt, 0, \\'\\')\\n        if idx == len(level) - 1:\\n            return False\\n        for char in self.pyramids[level[idx] + level[idx + 1]]:\\n            if self.dfs(level, idx + 1, nxt + char):\\n                return True\\n        return False\\n    \\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        self.pyramids = defaultdict(list)\\n        for pyramid in allowed:\\n            self.pyramids[pyramid[:2]].append(pyramid[2])\\n        return self.dfs(bottom, 0, \\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683543,
                "title": "python-bfs-solution",
                "content": "```\\ndef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n\\tg = defaultdict(lambda: defaultdict(list))\\n\\tfor a, b, c in allowed:\\n\\t\\tg[a][b].append(c)\\n\\tq = [bottom]\\n\\twhile(q):\\n\\t\\tif len(q[0])==1:\\n\\t\\t\\treturn True\\n\\t\\tnxt_q = set()\\n\\t\\tfor s in q:\\n\\t\\t\\tnxt = [set() for _ in range(len(s)-1)]\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\ta, b = s[i], s[i+1]\\n\\t\\t\\t\\tif a in g and b in g[a]:\\n\\t\\t\\t\\t\\tnxt[i].update(g[a][b])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif all(s for s in nxt):\\n\\t\\t\\t\\tnxt_q.update([\\'\\'.join(s) for s in product(*nxt)])\\n\\t\\tq = list(nxt_q)\\n```",
                "solutionTags": [],
                "code": "```\\ndef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n\\tg = defaultdict(lambda: defaultdict(list))\\n\\tfor a, b, c in allowed:\\n\\t\\tg[a][b].append(c)\\n\\tq = [bottom]\\n\\twhile(q):\\n\\t\\tif len(q[0])==1:\\n\\t\\t\\treturn True\\n\\t\\tnxt_q = set()\\n\\t\\tfor s in q:\\n\\t\\t\\tnxt = [set() for _ in range(len(s)-1)]\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\ta, b = s[i], s[i+1]\\n\\t\\t\\t\\tif a in g and b in g[a]:\\n\\t\\t\\t\\t\\tnxt[i].update(g[a][b])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif all(s for s in nxt):\\n\\t\\t\\t\\tnxt_q.update([\\'\\'.join(s) for s in product(*nxt)])\\n\\t\\tq = list(nxt_q)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2630981,
                "title": "python-top-down-dp",
                "content": "```\\nfrom collections import defaultdict\\nfrom itertools import product\\nfrom functools import cache\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        f = defaultdict(list)\\n        for a, b, c in allowed: f[(a,b)].append(c)\\n        @cache\\n        def dfs(bottom):\\n            if len(bottom) == 1: return True\\n            for i in product(*(f[(a,b)] for a,b in zip(bottom, bottom[1:]))):\\n                if dfs(i): return True\\n            return False\\n        return dfs(bottom)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom itertools import product\\nfrom functools import cache\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        f = defaultdict(list)\\n        for a, b, c in allowed: f[(a,b)].append(c)\\n        @cache\\n        def dfs(bottom):\\n            if len(bottom) == 1: return True\\n            for i in product(*(f[(a,b)] for a,b in zip(bottom, bottom[1:]))):\\n                if dfs(i): return True\\n            return False\\n        return dfs(bottom)",
                "codeTag": "Java"
            },
            {
                "id": 2583955,
                "title": "brute-force-dfs-memoization-c",
                "content": "**Please upvote if you like my solution .**\\n```\\nclass Solution {\\npublic:\\n    map<string,vector<string>> m; // map to store given allowed strings\\n    map<string,bool> dp; // dp to store visited strings\\n    bool dfs(string bot){\\n\\t\\t// passing bottom to dfs\\n\\t\\t// if bot length is 2 then we are at final stage\\n        if(bot.length() == 2){\\n            if(m.find(bot) != m.end() && m[bot].size() > 0) return 1;\\n            return 0;\\n        }\\n        // if we have visited this given string before so return previous result\\n        if(dp.find(bot) != dp.end()) return dp[bot];\\n        // set to store newly generated strings\\n        set<string> nBot;\\n        for(auto x: m[bot.substr(0,2)]){\\n            nBot.insert(x);\\n        }\\n        // have to create all strings and call for every one\\n        for(int i=1;i<bot.length()-1;i++){\\n            set<string> s2;\\n            for(auto x: m[bot.substr(i,2)]){\\n                for(auto y: nBot){\\n                    s2.insert(y + x);\\n                }\\n            }\\n            nBot.clear();\\n            nBot = s2;\\n        }\\n        // calling dfs for all generated strings\\n        for(auto x: nBot){\\n            if(dfs(x)) return dp[x] = true;\\n        }\\n        return dp[bot] = false;\\n    }\\n    \\n    // we only have A B C D E F\\n    bool pyramidTransition(string bt, vector<string>& all) {\\n        int n = bt.length();\\n        set<string> s;\\n        for(auto x: all){\\n            m[x.substr(0,2)].push_back(x.substr(2,1));\\n        }\\n        return dfs(bt);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<string,vector<string>> m; // map to store given allowed strings\\n    map<string,bool> dp; // dp to store visited strings\\n    bool dfs(string bot){\\n\\t\\t// passing bottom to dfs\\n\\t\\t// if bot length is 2 then we are at final stage\\n        if(bot.length() == 2){\\n            if(m.find(bot) != m.end() && m[bot].size() > 0) return 1;\\n            return 0;\\n        }\\n        // if we have visited this given string before so return previous result\\n        if(dp.find(bot) != dp.end()) return dp[bot];\\n        // set to store newly generated strings\\n        set<string> nBot;\\n        for(auto x: m[bot.substr(0,2)]){\\n            nBot.insert(x);\\n        }\\n        // have to create all strings and call for every one\\n        for(int i=1;i<bot.length()-1;i++){\\n            set<string> s2;\\n            for(auto x: m[bot.substr(i,2)]){\\n                for(auto y: nBot){\\n                    s2.insert(y + x);\\n                }\\n            }\\n            nBot.clear();\\n            nBot = s2;\\n        }\\n        // calling dfs for all generated strings\\n        for(auto x: nBot){\\n            if(dfs(x)) return dp[x] = true;\\n        }\\n        return dp[bot] = false;\\n    }\\n    \\n    // we only have A B C D E F\\n    bool pyramidTransition(string bt, vector<string>& all) {\\n        int n = bt.length();\\n        set<string> s;\\n        for(auto x: all){\\n            m[x.substr(0,2)].push_back(x.substr(2,1));\\n        }\\n        return dfs(bt);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564954,
                "title": "javascript-bfs-with-comments",
                "content": "```\\n/**\\n * @param {string} bottom\\n * @param {string[]} allowed\\n * @return {boolean}\\n */\\nlet pyramidTransition = (bottom, allowed) => {\\n    let queue = [bottom];\\n    // next level as a set to remove duplicates\\n    let next_level = new Set();\\n    let map = {};\\n    \\n    for (let a of allowed) {\\n        let head = a.slice(-1);\\n        let base = a.slice(0, 2);\\n        map[base] = map[base] || [];\\n        map[base].push(head);\\n    }\\n\\n    while (queue.length || next_level.size) {\\n        // process everything in the first level\\n        // before moving to the next one\\n        if (!queue.length) {\\n            queue = [...next_level];\\n            next_level = new Set();\\n        }\\n\\n        let base = queue.pop();\\n        let next = [\\'\\'];\\n        let prev = \\'\\';\\n        for(let l of base) {\\n            // we need to letters to get a valid combination\\n            if (!prev) {\\n                prev = l;\\n                continue;\\n            }\\n            prev += l;\\n\\n            if (!map[prev]) {\\n                // this won\\'t lead to any combination\\n                next = [];\\n                break;\\n            }\\n            let temp = [];\\n            for (let h of map[prev]) {\\n                // concat prev letter with new head\\n                for (let n of next) {\\n                    temp.push(n+h);\\n                }\\n            }\\n            next = temp;\\n            prev = l;\\n        }\\n\\n        for (let n of next) {\\n            // found a valid combination\\n            if (n.length === 1) {\\n                return true;\\n            }\\n            next_level.add(n);\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string} bottom\\n * @param {string[]} allowed\\n * @return {boolean}\\n */\\nlet pyramidTransition = (bottom, allowed) => {\\n    let queue = [bottom];\\n    // next level as a set to remove duplicates\\n    let next_level = new Set();\\n    let map = {};\\n    \\n    for (let a of allowed) {\\n        let head = a.slice(-1);\\n        let base = a.slice(0, 2);\\n        map[base] = map[base] || [];\\n        map[base].push(head);\\n    }\\n\\n    while (queue.length || next_level.size) {\\n        // process everything in the first level\\n        // before moving to the next one\\n        if (!queue.length) {\\n            queue = [...next_level];\\n            next_level = new Set();\\n        }\\n\\n        let base = queue.pop();\\n        let next = [\\'\\'];\\n        let prev = \\'\\';\\n        for(let l of base) {\\n            // we need to letters to get a valid combination\\n            if (!prev) {\\n                prev = l;\\n                continue;\\n            }\\n            prev += l;\\n\\n            if (!map[prev]) {\\n                // this won\\'t lead to any combination\\n                next = [];\\n                break;\\n            }\\n            let temp = [];\\n            for (let h of map[prev]) {\\n                // concat prev letter with new head\\n                for (let n of next) {\\n                    temp.push(n+h);\\n                }\\n            }\\n            next = temp;\\n            prev = l;\\n        }\\n\\n        for (let n of next) {\\n            // found a valid combination\\n            if (n.length === 1) {\\n                return true;\\n            }\\n            next_level.add(n);\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2559546,
                "title": "java-multilevel-backtracking-with-visited-set-84-ms",
                "content": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        \\n        Map<String, List<Character>> mapping=new HashMap<>();\\n        for(String str: allowed){\\n            String curr=str.substring(0,2);\\n            if(!mapping.containsKey(curr)){\\n                mapping.put(curr, new ArrayList<>());\\n            }\\n            mapping.get(curr).add(str.charAt(2));\\n        }\\n        \\n        return backtrack(new StringBuilder(bottom), new StringBuilder(), mapping,0,new HashSet<>());\\n    }\\n    \\n    private boolean backtrack(StringBuilder bottom, StringBuilder next, Map<String, List<Character>> mapping, int idx, Set<String> visited){\\n        if(bottom.length()==1){\\n            return true;\\n        }else if(idx==bottom.length()-1){\\n            // improved performance drastically add visited in set, if already visited return false\\n            String str=next.toString();\\n            if(visited.contains(str)){\\n                return false;\\n            }\\n            \\n            visited.add(str);\\n            \\n            return backtrack(next,new StringBuilder(),mapping,0,visited);\\n            \\n        }else{\\n            String curr=bottom.substring(idx,idx+2);\\n            if(!mapping.containsKey(curr)){\\n                return false;\\n            }else{\\n                for(char x: mapping.get(curr)){\\n                    next.append(x);\\n                    boolean found=backtrack(bottom,next,mapping,idx+1,visited);\\n                    if(found){\\n                        return true;\\n                    }\\n                    next.deleteCharAt(next.length()-1);\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        \\n        Map<String, List<Character>> mapping=new HashMap<>();\\n        for(String str: allowed){\\n            String curr=str.substring(0,2);\\n            if(!mapping.containsKey(curr)){\\n                mapping.put(curr, new ArrayList<>());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2550857,
                "title": "cache-for-brute-force-search-c",
                "content": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        brute force dfs\\n        \\n        we can not use a hashmap: string -> bool to cache if bottom succeeds\\n    */\\n    vector<char> block[7][7];\\n    unordered_map<string, bool> f;\\n    \\n    // try to construct up with bottom\\n    // u points to char in the bottom\\n    bool dfs(string bottom, string up, int u) {\\n        if (f.count(bottom)) return f[bottom];\\n        \\n        if (bottom.size() == 1) return f[bottom] = true;\\n        \\n        // we cannot add f[bottom] = dfs(up, \"\", 0)\\n        // since here up is only one kind of possible up made from bottom\\n        if (u == bottom.size() - 1) return dfs(up, \"\", 0);\\n        \\n        auto avail = block[bottom[u] - \\'A\\'][bottom[u + 1] - \\'A\\'];\\n        for (auto ch : avail) {\\n            if (dfs(bottom, up + ch, u + 1)) return f[bottom] = true;\\n        }\\n        \\n        return f[bottom] = false;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        for (auto& s : allowed) {\\n            block[s[0] - \\'A\\'][s[1] - \\'A\\'].push_back(s[2]);\\n        }\\n        \\n        return dfs(bottom, \"\", 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        brute force dfs\\n        \\n        we can not use a hashmap: string -> bool to cache if bottom succeeds\\n    */\\n    vector<char> block[7][7];\\n    unordered_map<string, bool> f;\\n    \\n    // try to construct up with bottom\\n    // u points to char in the bottom\\n    bool dfs(string bottom, string up, int u) {\\n        if (f.count(bottom)) return f[bottom];\\n        \\n        if (bottom.size() == 1) return f[bottom] = true;\\n        \\n        // we cannot add f[bottom] = dfs(up, \"\", 0)\\n        // since here up is only one kind of possible up made from bottom\\n        if (u == bottom.size() - 1) return dfs(up, \"\", 0);\\n        \\n        auto avail = block[bottom[u] - \\'A\\'][bottom[u + 1] - \\'A\\'];\\n        for (auto ch : avail) {\\n            if (dfs(bottom, up + ch, u + 1)) return f[bottom] = true;\\n        }\\n        \\n        return f[bottom] = false;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        for (auto& s : allowed) {\\n            block[s[0] - \\'A\\'][s[1] - \\'A\\'].push_back(s[2]);\\n        }\\n        \\n        return dfs(bottom, \"\", 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529267,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "\\tvar pyramidTransition = function(bottom, allowed) {\\n\\t\\tconst hash = allowed.reduce((map, matrix) => {\\n\\t\\t\\tconst top = matrix.slice(2);\\n\\t\\t\\tconst bootom = matrix.slice(0, 2);\\n\\t\\t\\tconst set = map.get(bootom) ?? new Set();\\n\\n\\t\\t\\tset.add(top);\\n\\t\\t\\tmap.set(bootom, set);\\n\\t\\t\\treturn map;\\n\\t\\t}, new Map());\\n\\n\\t\\tconst transition = (current = bottom, top = \\'\\') => {\\n\\t\\t\\tconst position = top.length;\\n\\t\\t\\tif (current.length === 2 && position === 1) return true;\\n\\t\\t\\tif (current.length - 1 === position) return transition(top);\\n\\t\\t\\tconst base = current.slice(position, position + 2);\\n\\t\\t\\tconst set = hash.get(base);\\n\\t\\t\\tif (!set) return false;\\n\\n\\t\\t\\tfor (const setTop of set) {\\n\\t\\t\\t\\tconst isAllowed = transition(current, `${top}${setTop}`);\\n\\t\\t\\t\\tif (isAllowed) return true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t\\treturn transition();\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar pyramidTransition = function(bottom, allowed) {\\n\\t\\tconst hash = allowed.reduce((map, matrix) => {\\n\\t\\t\\tconst top = matrix.slice(2);\\n\\t\\t\\tconst bootom = matrix.slice(0, 2);\\n\\t\\t\\tconst set = map.get(bootom) ?? new Set();\\n\\n\\t\\t\\tset.add(top);\\n\\t\\t\\tmap.set(bootom, set);\\n\\t\\t\\treturn map;\\n\\t\\t}, new Map());\\n\\n\\t\\tconst transition = (current = bottom, top = \\'\\') => {\\n\\t\\t\\tconst position = top.length;\\n\\t\\t\\tif (current.length === 2 && position === 1) return true;\\n\\t\\t\\tif (current.length - 1 === position) return transition(top);\\n\\t\\t\\tconst base = current.slice(position, position + 2);\\n\\t\\t\\tconst set = hash.get(base);\\n\\t\\t\\tif (!set) return false;\\n\\n\\t\\t\\tfor (const setTop of set) {\\n\\t\\t\\t\\tconst isAllowed = transition(current, `${top}${setTop}`);\\n\\t\\t\\t\\tif (isAllowed) return true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t\\treturn transition();\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2506743,
                "title": "python-simple-dfs",
                "content": "\\n    def pyramidTransition(self, bottom, allowed):\\n        dict1 = defaultdict(list)\\n        \\n        for i in allowed:\\n            dict1[(i[0],i[1])].append(i[2])\\n        \\n        @lru_cache(None)\\n        def dfs(bot, i, nxt):\\n            if len(bot) == 1:\\n                return True\\n            \\n            if len(bot) - 1 == len(nxt):\\n                return dfs(nxt, 0, \"\")\\n            \\n            if i == len(bot) - 1:\\n                return False\\n            \\n            for c in dict1[(bot[i],bot[i+1])]:\\n                if dfs(bot, i+1, nxt + c):\\n                    return True\\n            \\n            return False\\n        \\n        return dfs(bottom, 0, \"\")",
                "solutionTags": [],
                "code": "\\n    def pyramidTransition(self, bottom, allowed):\\n        dict1 = defaultdict(list)\\n        \\n        for i in allowed:\\n            dict1[(i[0],i[1])].append(i[2])\\n        \\n        @lru_cache(None)\\n        def dfs(bot, i, nxt):\\n            if len(bot) == 1:\\n                return True\\n            \\n            if len(bot) - 1 == len(nxt):\\n                return dfs(nxt, 0, \"\")\\n            \\n            if i == len(bot) - 1:\\n                return False\\n            \\n            for c in dict1[(bot[i],bot[i+1])]:\\n                if dfs(bot, i+1, nxt + c):\\n                    return True\\n            \\n            return False\\n        \\n        return dfs(bottom, 0, \"\")",
                "codeTag": "Python3"
            },
            {
                "id": 2501816,
                "title": "dfs-memoization",
                "content": "```\\nclass Solution {    \\n    static boolean dfs(String curr, String res, int idx, HashMap<Integer, String> map, HashMap<String, Boolean> dp) {\\n        //If the length of curr string is 1 then we are at the top of pyramid so return true\\n        if(curr.length() == 1)\\n            return true;\\n        \\n        // If idx reaches the last index of curr string i.e. all blocks of curr strings are visited so move to next level/layer\\n        if(idx == curr.length() - 1)\\n            return dfs(res, \"\", 0, map, dp);\\n        \\n        //check the current state if it is already visited before\\n        String state = curr + \" \" + res + \" \" + idx;\\n        if(dp.containsKey(state))\\n            return dp.get(state);\\n        \\n        //Generate key for the current block and check if it is available in the map\\n        int key = (curr.charAt(idx) - \\'A\\') * 26 + (curr.charAt(idx + 1) - \\'A\\');\\n        if(!map.containsKey(key))\\n            return false;\\n        \\n        //Check for every possible combination using Backtracking and update the state in dp\\n        String str = map.get(key);\\n        for(int i = 0; i < str.length(); ++i) {\\n            if(dfs(curr, res + str.charAt(i), idx + 1, map, dp)) {\\n                dp.put(state, true);\\n                return true;\\n            }\\n        }\\n        \\n        dp.put(state, false);\\n        return false;\\n    }\\n    \\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        //Store all Allowed Strings as key value pair in a hashMap\\n        // key can be created using the first two characters in allowed string\\n        // value can be stores as a String where each character of the string represents valid combination for the key\\n        HashMap<Integer, String> map = new HashMap<Integer, String>();\\n        for(int i = 0; i < allowed.size(); ++i) {\\n            String str = allowed.get(i);\\n            int key = (str.charAt(0) - \\'A\\') * 26 + (str.charAt(1) - \\'A\\');\\n            if(!map.containsKey(key))\\n                map.put(key, \"\");\\n            map.put(key, map.get(key) + str.charAt(2));\\n        }\\n        \\n        return dfs(bottom, \"\", 0, map, new HashMap<String, Boolean>());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {    \\n    static boolean dfs(String curr, String res, int idx, HashMap<Integer, String> map, HashMap<String, Boolean> dp) {\\n        //If the length of curr string is 1 then we are at the top of pyramid so return true\\n        if(curr.length() == 1)\\n            return true;\\n        \\n        // If idx reaches the last index of curr string i.e. all blocks of curr strings are visited so move to next level/layer\\n        if(idx == curr.length() - 1)\\n            return dfs(res, \"\", 0, map, dp);\\n        \\n        //check the current state if it is already visited before\\n        String state = curr + \" \" + res + \" \" + idx;\\n        if(dp.containsKey(state))\\n            return dp.get(state);\\n        \\n        //Generate key for the current block and check if it is available in the map\\n        int key = (curr.charAt(idx) - \\'A\\') * 26 + (curr.charAt(idx + 1) - \\'A\\');\\n        if(!map.containsKey(key))\\n            return false;\\n        \\n        //Check for every possible combination using Backtracking and update the state in dp\\n        String str = map.get(key);\\n        for(int i = 0; i < str.length(); ++i) {\\n            if(dfs(curr, res + str.charAt(i), idx + 1, map, dp)) {\\n                dp.put(state, true);\\n                return true;\\n            }\\n        }\\n        \\n        dp.put(state, false);\\n        return false;\\n    }\\n    \\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        //Store all Allowed Strings as key value pair in a hashMap\\n        // key can be created using the first two characters in allowed string\\n        // value can be stores as a String where each character of the string represents valid combination for the key\\n        HashMap<Integer, String> map = new HashMap<Integer, String>();\\n        for(int i = 0; i < allowed.size(); ++i) {\\n            String str = allowed.get(i);\\n            int key = (str.charAt(0) - \\'A\\') * 26 + (str.charAt(1) - \\'A\\');\\n            if(!map.containsKey(key))\\n                map.put(key, \"\");\\n            map.put(key, map.get(key) + str.charAt(2));\\n        }\\n        \\n        return dfs(bottom, \"\", 0, map, new HashMap<String, Boolean>());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472165,
                "title": "bfs-vs-dfs",
                "content": "Whenever a problem can be modeled as an unweighted graph traversal, I usually tend to pick BFS as BFS finds a destination faster. However in this case BFS was either very slow or gave me TLE. However DFS was much faster. I believe thais is because of very high degree of the word graph which results in slower BFS. Can someone help me understand?\\n\\nAccepted BFS Solution -> https://leetcode.com/submissions/detail/781924060/\\n\\nDFS-\\n```\\nclass Solution {\\n    Map<String, List<Character>> map;\\n    Map<String, Set<String>> memo = new HashMap();\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        map = new HashMap();\\n        for (String s : allowed){\\n                String key = s.substring(0, 2);\\n                char ch= s.charAt(2);\\n                List<Character> val= map.getOrDefault(key, new ArrayList());\\n                val.add(ch);\\n                map.put(key, val);\\n        }\\n       return checkDFS(bottom, new HashSet<String>());\\n    }\\n    \\n    private boolean checkDFS(String word, Set<String> visited){\\n        if (word.length() == 1) return true;\\n        visited.add(word);\\n        for (String nextWord: getNextLevels(word)){\\n            if (!visited.contains(nextWord) && checkDFS(nextWord, visited)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private Set<String> getNextLevels(String word){\\n        if (!memo.containsKey(word)){\\n            Set<String> nextLevels = new HashSet();\\n            if (word.length() <= 2) {\\n                for(char ch : map.getOrDefault(word, new ArrayList<Character>())){\\n                    nextLevels.add(Character.toString(ch));\\n                }\\n            }\\n            else {\\n                Set<String> suffixes = getNextLevels(word.substring(1));\\n                for(char ch : map.getOrDefault(word.substring(0,2), new ArrayList<Character>())){\\n                    for (String suffix : suffixes){\\n                            StringBuilder sb = new StringBuilder();\\n                            sb.append(ch);\\n                            sb.append(suffix);\\n                            nextLevels.add(sb.toString());\\n                    }\\n                }\\n            }\\n            memo.put(word, nextLevels);\\n        }\\n        return memo.get(word);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<String, List<Character>> map;\\n    Map<String, Set<String>> memo = new HashMap();\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        map = new HashMap();\\n        for (String s : allowed){\\n                String key = s.substring(0, 2);\\n                char ch= s.charAt(2);\\n                List<Character> val= map.getOrDefault(key, new ArrayList());\\n                val.add(ch);\\n                map.put(key, val);\\n        }\\n       return checkDFS(bottom, new HashSet<String>());\\n    }\\n    \\n    private boolean checkDFS(String word, Set<String> visited){\\n        if (word.length() == 1) return true;\\n        visited.add(word);\\n        for (String nextWord: getNextLevels(word)){\\n            if (!visited.contains(nextWord) && checkDFS(nextWord, visited)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private Set<String> getNextLevels(String word){\\n        if (!memo.containsKey(word)){\\n            Set<String> nextLevels = new HashSet();\\n            if (word.length() <= 2) {\\n                for(char ch : map.getOrDefault(word, new ArrayList<Character>())){\\n                    nextLevels.add(Character.toString(ch));\\n                }\\n            }\\n            else {\\n                Set<String> suffixes = getNextLevels(word.substring(1));\\n                for(char ch : map.getOrDefault(word.substring(0,2), new ArrayList<Character>())){\\n                    for (String suffix : suffixes){\\n                            StringBuilder sb = new StringBuilder();\\n                            sb.append(ch);\\n                            sb.append(suffix);\\n                            nextLevels.add(sb.toString());\\n                    }\\n                }\\n            }\\n            memo.put(word, nextLevels);\\n        }\\n        return memo.get(word);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342174,
                "title": "simple-dfs-solution-using-memo-java",
                "content": "```\\nclass Solution {\\n    HashMap<String, List<Character>> map = new HashMap<>();\\n    HashMap<String, Boolean> dp = new HashMap<>();\\n    \\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        for(String s:allowed){\\n            String sub = s.substring(0,2);\\n            \\n            char c = s.charAt(2);\\n            \\n            if(!map.containsKey(sub))\\n                map.put(sub, new ArrayList<>());\\n            \\n            map.get(sub).add(c);\\n        }\\n        \\n        return dfs(bottom, \"\", 0);\\n    }\\n    \\n    boolean dfs(String currBottom, String newBottom, int index){\\n        \\n        if(currBottom.length()==1)\\n            return true;\\n        if(index+1>=currBottom.length())\\n            return false;\\n        \\n        String sub = currBottom.substring(index,index+2);\\n        \\n        String state = currBottom+\" \"+newBottom+\" \"+index;\\n        \\n        if(dp.containsKey(state))\\n            return dp.get(state);\\n        \\n        if(map.containsKey(sub)){\\n            List<Character> letters = map.get(sub);\\n            \\n            for(char c:letters){\\n                if(index==currBottom.length()-2){\\n                    if(dfs(newBottom+c, \"\", 0))\\n                    {\\n                        dp.put(state, true);\\n                        return true;\\n                    }\\n                }\\n                else if(dfs(currBottom, newBottom+c, index+1))\\n                {\\n                    dp.put(state, true);\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        dp.put(state, false);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, List<Character>> map = new HashMap<>();\\n    HashMap<String, Boolean> dp = new HashMap<>();\\n    \\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        for(String s:allowed){\\n            String sub = s.substring(0,2);\\n            \\n            char c = s.charAt(2);\\n            \\n            if(!map.containsKey(sub))\\n                map.put(sub, new ArrayList<>());\\n            \\n            map.get(sub).add(c);\\n        }\\n        \\n        return dfs(bottom, \"\", 0);\\n    }\\n    \\n    boolean dfs(String currBottom, String newBottom, int index){\\n        \\n        if(currBottom.length()==1)\\n            return true;\\n        if(index+1>=currBottom.length())\\n            return false;\\n        \\n        String sub = currBottom.substring(index,index+2);\\n        \\n        String state = currBottom+\" \"+newBottom+\" \"+index;\\n        \\n        if(dp.containsKey(state))\\n            return dp.get(state);\\n        \\n        if(map.containsKey(sub)){\\n            List<Character> letters = map.get(sub);\\n            \\n            for(char c:letters){\\n                if(index==currBottom.length()-2){\\n                    if(dfs(newBottom+c, \"\", 0))\\n                    {\\n                        dp.put(state, true);\\n                        return true;\\n                    }\\n                }\\n                else if(dfs(currBottom, newBottom+c, index+1))\\n                {\\n                    dp.put(state, true);\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        dp.put(state, false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333993,
                "title": "faster-than-100-c-backtracking-and-memoize-w-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        string top = \"\";\\n        unordered_map<string, bool> map;\\n        for (int i = 0; i < allowed.size(); i++) {\\n            map[allowed[i].substr(0, 2)] = true;\\n        }\\n        return solve(0, bottom, top, allowed, map);\\n    }\\n    \\n    bool solve(int start, string bottom, string top, vector<string>& allowed, unordered_map<string, bool> &map) {\\n        //new bottom and top\\n        if (start == bottom.size() - 1) {\\n            bottom = top;\\n            start = 0;\\n            top = \"\";\\n        }\\n        if (bottom.size() == 1) {\\n            return true;\\n        }\\n        //loop to try all patterns\\n        for (int i = 0; i < allowed.size(); i++) {\\n            if (map.find(bottom.substr(start, 2)) == map.end()) {\\n                break;\\n            }\\n            //if pattern fits call function again, with next pattern to look for\\n            if ((allowed[i].substr(0, 2)) == (bottom.substr(start, 2))) {\\n                //add to top layer\\n                top.push_back(allowed[i][2]);\\n                //if its the first two in the next layer and not in allowed, break\\n                if (top.size() == 2 && map.find(top) == map.end()) {\\n                    top.pop_back();\\n                    break;\\n                }\\n                //if its last (recent) two in top layer isn\\'t in allowed, continue,\\n                //dont build bottom with this one\\n                else if (top.size() > 2 && map.find(top.substr(top.length() - 2)) == map.end()) {\\n                    top.pop_back();\\n                    continue;\\n                }\\n                if (solve(start + 1, bottom, top, allowed, map)) {\\n                    return true;\\n                }\\n                else {\\n                    top.pop_back();\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        string top = \"\";\\n        unordered_map<string, bool> map;\\n        for (int i = 0; i < allowed.size(); i++) {\\n            map[allowed[i].substr(0, 2)] = true;\\n        }\\n        return solve(0, bottom, top, allowed, map);\\n    }\\n    \\n    bool solve(int start, string bottom, string top, vector<string>& allowed, unordered_map<string, bool> &map) {\\n        //new bottom and top\\n        if (start == bottom.size() - 1) {\\n            bottom = top;\\n            start = 0;\\n            top = \"\";\\n        }\\n        if (bottom.size() == 1) {\\n            return true;\\n        }\\n        //loop to try all patterns\\n        for (int i = 0; i < allowed.size(); i++) {\\n            if (map.find(bottom.substr(start, 2)) == map.end()) {\\n                break;\\n            }\\n            //if pattern fits call function again, with next pattern to look for\\n            if ((allowed[i].substr(0, 2)) == (bottom.substr(start, 2))) {\\n                //add to top layer\\n                top.push_back(allowed[i][2]);\\n                //if its the first two in the next layer and not in allowed, break\\n                if (top.size() == 2 && map.find(top) == map.end()) {\\n                    top.pop_back();\\n                    break;\\n                }\\n                //if its last (recent) two in top layer isn\\'t in allowed, continue,\\n                //dont build bottom with this one\\n                else if (top.size() > 2 && map.find(top.substr(top.length() - 2)) == map.end()) {\\n                    top.pop_back();\\n                    continue;\\n                }\\n                if (solve(start + 1, bottom, top, allowed, map)) {\\n                    return true;\\n                }\\n                else {\\n                    top.pop_back();\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257080,
                "title": "java-dfs-with-memo-4ms-99-5",
                "content": "```java\\n/*\\nbasic idea: dfs to try every possible choice.\\ncache a layer string if that leads to a false answer.\\n\\n----------complexity analysis\\nN = bottom.length().\\nK = allowed.length()\\nX = number of different chars. (A - F. i.e., 6 according to the constraint)\\nmemo size: for string of size N, there are X^N such strings. so all together, the number of memo size:\\nX^N + X^(N - 1) + X^(N - 2) + .. X = O(X^(N + 1)) (Geometric progression sum)\\n\\n\\nto fill each item of memo, it takes K due to the for loop.\\naltogether X^(N + 1) * K\\n\\nActually we also need to consider the time complexity for creating each key in the cache and calculating the hashcode for each key.\\nit\\'s N for each memo key.\\nIn total: X^(N + 1) * (K + N)\\n\\nSpace:\\nmemo:  X^(N + 1) * N\\nfor the \"curLevel\" arrays in the recursive function: N^2\\n\\nin total: X^(N + 1) * N + N^2\\n\\n */\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<Character>> map = new HashMap<>();\\n        for (String pattern: allowed) {\\n            String key = pattern.substring(0, 2);\\n            map.computeIfAbsent(key, x -> new LinkedList<>()).add(pattern.charAt(2));\\n        }\\n        return explore(bottom, new char[bottom.length() - 1], 0, map, new HashSet<>());\\n    }\\n    \\n    private boolean explore(String prevLevel, char[] curLevel, int pos, Map<String, List<Character>> map, Set<String> cache){\\n        \\n        if (cache.contains(prevLevel)) {\\n            return false;\\n        }\\n        if (pos == curLevel.length) {\\n            if (curLevel.length == 1) {\\n                return true;\\n            }\\n            char[] nextLevel = new char[curLevel.length - 1];\\n            return explore(String.valueOf(curLevel), nextLevel, 0, map, cache);\\n        }\\n        \\n        String key = prevLevel.substring(pos, pos + 2);\\n        if (!map.containsKey(key)) {\\n            cache.add(prevLevel);\\n            return false;\\n        }\\n        for (char choice: map.get(key)) {\\n            curLevel[pos] = choice;\\n            if (explore(prevLevel, curLevel, pos + 1, map, cache)) {\\n                return true;\\n            }\\n        }\\n        cache.add(prevLevel);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```java\\n/*\\nbasic idea: dfs to try every possible choice.\\ncache a layer string if that leads to a false answer.\\n\\n----------complexity analysis\\nN = bottom.length().\\nK = allowed.length()\\nX = number of different chars. (A - F. i.e., 6 according to the constraint)\\nmemo size: for string of size N, there are X^N such strings. so all together, the number of memo size:\\nX^N + X^(N - 1) + X^(N - 2) + .. X = O(X^(N + 1)) (Geometric progression sum)\\n\\n\\nto fill each item of memo, it takes K due to the for loop.\\naltogether X^(N + 1) * K\\n\\nActually we also need to consider the time complexity for creating each key in the cache and calculating the hashcode for each key.\\nit\\'s N for each memo key.\\nIn total: X^(N + 1) * (K + N)\\n\\nSpace:\\nmemo:  X^(N + 1) * N\\nfor the \"curLevel\" arrays in the recursive function: N^2\\n\\nin total: X^(N + 1) * N + N^2\\n\\n */\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<Character>> map = new HashMap<>();\\n        for (String pattern: allowed) {\\n            String key = pattern.substring(0, 2);\\n            map.computeIfAbsent(key, x -> new LinkedList<>()).add(pattern.charAt(2));\\n        }\\n        return explore(bottom, new char[bottom.length() - 1], 0, map, new HashSet<>());\\n    }\\n    \\n    private boolean explore(String prevLevel, char[] curLevel, int pos, Map<String, List<Character>> map, Set<String> cache){\\n        \\n        if (cache.contains(prevLevel)) {\\n            return false;\\n        }\\n        if (pos == curLevel.length) {\\n            if (curLevel.length == 1) {\\n                return true;\\n            }\\n            char[] nextLevel = new char[curLevel.length - 1];\\n            return explore(String.valueOf(curLevel), nextLevel, 0, map, cache);\\n        }\\n        \\n        String key = prevLevel.substring(pos, pos + 2);\\n        if (!map.containsKey(key)) {\\n            cache.add(prevLevel);\\n            return false;\\n        }\\n        for (char choice: map.get(key)) {\\n            curLevel[pos] = choice;\\n            if (explore(prevLevel, curLevel, pos + 1, map, cache)) {\\n                return true;\\n            }\\n        }\\n        cache.add(prevLevel);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253334,
                "title": "python3-backtracking",
                "content": "```class Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        store = defaultdict(lambda:defaultdict(list))\\n        for i in allowed:\\n            store[i[0]][i[1]].append(i[2])\\n        \\n        def dfs(bot, i, nxt):\\n            if len(bot) == 1:\\n                return True\\n            \\n            if len(bot) - 1 == len(nxt):\\n                return dfs(nxt, 0, \"\")\\n            \\n            if i == len(bot) - 1:\\n                return False\\n            \\n            for c in store[bot[i]][bot[i+1]]:\\n                if dfs(bot, i+1, nxt + c):\\n                    return True\\n            \\n            return False\\n        \\n        return dfs(bottom, 0, \"\")",
                "solutionTags": [],
                "code": "```class Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        store = defaultdict(lambda:defaultdict(list))\\n        for i in allowed:\\n            store[i[0]][i[1]].append(i[2])\\n        \\n        def dfs(bot, i, nxt):\\n            if len(bot) == 1:\\n                return True\\n            \\n            if len(bot) - 1 == len(nxt):\\n                return dfs(nxt, 0, \"\")\\n            \\n            if i == len(bot) - 1:\\n                return False\\n            \\n            for c in store[bot[i]][bot[i+1]]:\\n                if dfs(bot, i+1, nxt + c):\\n                    return True\\n            \\n            return False\\n        \\n        return dfs(bottom, 0, \"\")",
                "codeTag": "Java"
            },
            {
                "id": 2221488,
                "title": "python-solution-dfs-memoization-pretty-standard",
                "content": "```\\nclass Solution:\\n    # Try DFS to proceed from bottom to top\\n    # DFS function: takes in a string, iterate from left to right consecutive letters to output a list of possible output\\n    # Memoization is used to reduce complexity\\n    def dfs(self, bottom):\\n        if len(bottom) == 1:\\n            return True\\n        top = []\\n        for i in range(len(bottom)-1):\\n            if bottom[i:i+2] not in self.hash_table:\\n                return False\\n            if i == 0:\\n                for j in range(len(self.hash_table[bottom[i:i+2]])):\\n                    top.append(self.hash_table[bottom[i:i+2]][j])\\n            else:\\n                new_top = []\\n                for item in top: \\n                    for j in range(len(self.hash_table[bottom[i:i+2]])):\\n                        new_top.append(item + self.hash_table[bottom[i:i+2]][j])\\n                top = new_top[:]\\n        \\n        for item in top:\\n            if item not in self.memo and self.dfs(item):\\n                return True\\n        self.memo.add(bottom)\\n        return False        \\n    \\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        # Build the correspondence table\\n        self.hash_table = {}\\n        self.memo = set()\\n        for word in allowed:\\n            if word[:2] not in self.hash_table:\\n                self.hash_table[word[:2]] = []\\n            self.hash_table[word[:2]].append(word[2])\\n        return self.dfs(bottom)\\n        \\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Try DFS to proceed from bottom to top\\n    # DFS function: takes in a string, iterate from left to right consecutive letters to output a list of possible output\\n    # Memoization is used to reduce complexity\\n    def dfs(self, bottom):\\n        if len(bottom) == 1:\\n            return True\\n        top = []\\n        for i in range(len(bottom)-1):\\n            if bottom[i:i+2] not in self.hash_table:\\n                return False\\n            if i == 0:\\n                for j in range(len(self.hash_table[bottom[i:i+2]])):\\n                    top.append(self.hash_table[bottom[i:i+2]][j])\\n            else:\\n                new_top = []\\n                for item in top: \\n                    for j in range(len(self.hash_table[bottom[i:i+2]])):\\n                        new_top.append(item + self.hash_table[bottom[i:i+2]][j])\\n                top = new_top[:]\\n        \\n        for item in top:\\n            if item not in self.memo and self.dfs(item):\\n                return True\\n        self.memo.add(bottom)\\n        return False        \\n    \\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        # Build the correspondence table\\n        self.hash_table = {}\\n        self.memo = set()\\n        for word in allowed:\\n            if word[:2] not in self.hash_table:\\n                self.hash_table[word[:2]] = []\\n            self.hash_table[word[:2]].append(word[2])\\n        return self.dfs(bottom)\\n        \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2217917,
                "title": "c-dfs-optimized",
                "content": "As leetcode hhave addded some new test cases and that\\'s why all the old solutions which are in discussion are getting TLE.\\nThis one will not get TLE.\\n```\\nclass Solution {\\npublic:\\n    string res;\\n    bool dfs(string &s, string &ans,vector<vector<char>> &v)\\n    {\\n        if(s.size() == ans.size()+1)\\n        {\\n            if(ans.size()==0) return true;\\n            string p;\\n            if(dfs(ans,p,v)) return true;\\n            return false;\\n        }\\n        int sz = ans.size();\\n        int x = (s[sz]-\\'A\\')*6 + s[sz+1]-\\'A\\';\\n        for(auto &j: v[x])\\n        {\\n            ans += j;\\n            if(dfs(s,ans,v)) return true;\\n            ans.pop_back();\\n        }\\n        return false;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        vector<vector<char>> v(37);\\n        int n = allowed.size();\\n        if(n==0) return false;\\n        for(int i = 0;i<n;i++)\\n        {\\n            int x = (allowed[i][0]-\\'A\\')*6 + allowed[i][1]-\\'A\\';\\n            v[x].push_back(allowed[i][2]);\\n        }\\n        string p;\\n        return dfs(bottom, p, v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string res;\\n    bool dfs(string &s, string &ans,vector<vector<char>> &v)\\n    {\\n        if(s.size() == ans.size()+1)\\n        {\\n            if(ans.size()==0) return true;\\n            string p;\\n            if(dfs(ans,p,v)) return true;\\n            return false;\\n        }\\n        int sz = ans.size();\\n        int x = (s[sz]-\\'A\\')*6 + s[sz+1]-\\'A\\';\\n        for(auto &j: v[x])\\n        {\\n            ans += j;\\n            if(dfs(s,ans,v)) return true;\\n            ans.pop_back();\\n        }\\n        return false;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        vector<vector<char>> v(37);\\n        int n = allowed.size();\\n        if(n==0) return false;\\n        for(int i = 0;i<n;i++)\\n        {\\n            int x = (allowed[i][0]-\\'A\\')*6 + allowed[i][1]-\\'A\\';\\n            v[x].push_back(allowed[i][2]);\\n        }\\n        string p;\\n        return dfs(bottom, p, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202324,
                "title": "description-is-unclear-on-whether-elements-can-be-reused",
                "content": "Please make it clear.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2183261,
                "title": "recursive-solution-with-pruning",
                "content": "\\n```\\nvoid nextPattern(string bottom, string above, unordered_map<string,vector<char>>& mp, int i, int j,bool& pyramid, unordered_set<string>& dp) {\\n        if(pyramid or dp.find(bottom)!=dp.end())\\n            return;\\n        \\n        if(i==1) {\\n            pyramid = true;\\n            return ;\\n        }\\n        \\n        if(j==i) {\\n            nextPattern(above, \"\", mp, i-1, 1, pyramid, dp);\\n            if(pyramid)\\n                return;\\n            dp.insert(above);\\n        }\\n        \\n        string tmp = bottom.substr(j-1,2);\\n        int n = 0;\\n        \\n        if(mp.find(tmp)!=mp.end())\\n            n = mp[tmp].size();\\n        else\\n            return ;\\n        \\n        for(int p=0; p<n; p++) {\\n            nextPattern(bottom, above+mp[tmp][p], mp, i, j+1, pyramid, dp);\\n            if(pyramid)\\n                return;\\n        }\\n        return ;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string,vector<char>> mp;\\n        int n = allowed.size();\\n        string tmp;\\n        for(int i=0; i<n; i++) {\\n            tmp = allowed[i].substr(0,2);\\n            mp[tmp].push_back(allowed[i][2]);\\n        }\\n        unordered_set<string> dp;\\n        bool pyramid = false;\\n        \\n        nextPattern(bottom, \"\", mp, bottom.length(), 1, pyramid, dp);\\n        \\n        return pyramid;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid nextPattern(string bottom, string above, unordered_map<string,vector<char>>& mp, int i, int j,bool& pyramid, unordered_set<string>& dp) {\\n        if(pyramid or dp.find(bottom)!=dp.end())\\n            return;\\n        \\n        if(i==1) {\\n            pyramid = true;\\n            return ;\\n        }\\n        \\n        if(j==i) {\\n            nextPattern(above, \"\", mp, i-1, 1, pyramid, dp);\\n            if(pyramid)\\n                return;\\n            dp.insert(above);\\n        }\\n        \\n        string tmp = bottom.substr(j-1,2);\\n        int n = 0;\\n        \\n        if(mp.find(tmp)!=mp.end())\\n            n = mp[tmp].size();\\n        else\\n            return ;\\n        \\n        for(int p=0; p<n; p++) {\\n            nextPattern(bottom, above+mp[tmp][p], mp, i, j+1, pyramid, dp);\\n            if(pyramid)\\n                return;\\n        }\\n        return ;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string,vector<char>> mp;\\n        int n = allowed.size();\\n        string tmp;\\n        for(int i=0; i<n; i++) {\\n            tmp = allowed[i].substr(0,2);\\n            mp[tmp].push_back(allowed[i][2]);\\n        }\\n        unordered_set<string> dp;\\n        bool pyramid = false;\\n        \\n        nextPattern(bottom, \"\", mp, bottom.length(), 1, pyramid, dp);\\n        \\n        return pyramid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2177835,
                "title": "60-61-tc-passed-need-help-to-optimise-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    #define psi pair<string,int>\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n        unordered_map<string,set<char>>dic;\\n        for(auto ele:allowed){\\n            string s =ele.substr(0,2);\\n            dic[s].insert(ele[2]);\\n        }\\n        \\n        set<psi>Q;\\n        Q.insert({bottom,bottom.size()});\\n        \\n        \\n        while(!Q.empty()){\\n            \\n            set<psi>childQ;\\n            \\n            while(!Q.empty()){\\n                auto frp = *Q.begin();\\n                \\n                string front = frp.first;\\n                int sz = frp.second;\\n                \\n                if(sz==1)\\n                    return true;\\n                \\n                Q.erase(Q.begin());\\n                \\n                bool flag=true;\\n                \\n                set<string>curStrQ={\"\"};\\n                \\n                int i =0;\\n                \\n                while(i<sz-1){\\n                    \\n                    string sub =front.substr(i,2);\\n                    auto chars = dic[sub];\\n                    if(chars.empty()){\\n                        flag=false;\\n                        break;\\n                    }   \\n                    set<string>childCurQ;\\n                    \\n                    while(!curStrQ.empty()){\\n                        auto fr = *curStrQ.begin();\\n                        curStrQ.erase(fr);\\n                        for(auto each:chars){\\n                            if(fr==\"\")\\n                                childCurQ.insert(fr+each);\\n                            else{\\n                                string subs = fr.substr(fr.size()-1,1)+each;\\n                                if(dic.count(subs)!=0){\\n                                    childCurQ.insert(fr+each);        \\n                                }\\n                            }\\n                        }\\n                        \\n                    }\\n                    \\n                    curStrQ = childCurQ;\\n                    i++;\\n                }\\n                \\n                if(flag){\\n                    for(auto ele:curStrQ){\\n                        childQ.insert({ele,sz-1});\\n                    }\\n                }\\n                \\n            }\\n            Q=childQ;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define psi pair<string,int>\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n        unordered_map<string,set<char>>dic;\\n        for(auto ele:allowed){\\n            string s =ele.substr(0,2);\\n            dic[s].insert(ele[2]);\\n        }\\n        \\n        set<psi>Q;\\n        Q.insert({bottom,bottom.size()});\\n        \\n        \\n        while(!Q.empty()){\\n            \\n            set<psi>childQ;\\n            \\n            while(!Q.empty()){\\n                auto frp = *Q.begin();\\n                \\n                string front = frp.first;\\n                int sz = frp.second;\\n                \\n                if(sz==1)\\n                    return true;\\n                \\n                Q.erase(Q.begin());\\n                \\n                bool flag=true;\\n                \\n                set<string>curStrQ={\"\"};\\n                \\n                int i =0;\\n                \\n                while(i<sz-1){\\n                    \\n                    string sub =front.substr(i,2);\\n                    auto chars = dic[sub];\\n                    if(chars.empty()){\\n                        flag=false;\\n                        break;\\n                    }   \\n                    set<string>childCurQ;\\n                    \\n                    while(!curStrQ.empty()){\\n                        auto fr = *curStrQ.begin();\\n                        curStrQ.erase(fr);\\n                        for(auto each:chars){\\n                            if(fr==\"\")\\n                                childCurQ.insert(fr+each);\\n                            else{\\n                                string subs = fr.substr(fr.size()-1,1)+each;\\n                                if(dic.count(subs)!=0){\\n                                    childCurQ.insert(fr+each);        \\n                                }\\n                            }\\n                        }\\n                        \\n                    }\\n                    \\n                    curStrQ = childCurQ;\\n                    i++;\\n                }\\n                \\n                if(flag){\\n                    for(auto ele:curStrQ){\\n                        childQ.insert({ele,sz-1});\\n                    }\\n                }\\n                \\n            }\\n            Q=childQ;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060406,
                "title": "python-dictionary-and-hash-table-solution",
                "content": "\\t\\tdef evalPerms(temp):\\n           # evaluate all the possible next level up words from a single\\n\\t\\t   # starting word temp:\\n\\t\\t   q = [\\'\\']\\n            for jj in range(len(temp)-1):\\n                segment = temp[jj] + temp[jj+1]\\n                new = []        \\n                for string in q:\\n                    try:\\n                        for newChar in hasht[segment]:\\n                            new.append(string + newChar)\\n                    except:\\n                        pass\\n                    \\n                q = new\\n            \\n            return(q)\\n        \\n        ##########\\n\\t\\t# make a dictionary of key, value pairs where key is the first two \\n\\t\\t# strings of a word in allowed, and value is a list of the possible\\n\\t\\t# chars one level up:\\n        hasht = {}\\n        for pyr in allowed:\\n            if pyr[:2] in hasht:\\n                hasht[pyr[:2]].append(pyr[-1])\\n            else:\\n                hasht[pyr[:2]] = [pyr[-1]]\\n        \\n        #########\\n        n = len(bottom)\\n\\t\\t\\n\\t\\t# perms is the possible words at a level:\\n        perms = [bottom]\\n        \\n        for ii in range(n-1):\\n\\t\\t\\t\\n\\t\\t\\t# using a set to efficiently capture unique words one level up \\n\\t\\t\\t# from current level:\\n            nextLevel = set([])\\n            \\n            for word in perms:\\n                nextLevel = nextLevel.union(set(evalPerms(word)))\\n                \\n\\t\\t\\t#  if no words evaluated for the next level up, then \\n\\t\\t\\t# return False\\n            if nextLevel == set([]):\\n                return(False)\\n            else:\\n                perms = nextLevel\\n\\t\\t   \\n\\t\\t# if the top was reached, return True:\\n        return(True)",
                "solutionTags": [],
                "code": "\\t\\tdef evalPerms(temp):\\n           # evaluate all the possible next level up words from a single\\n\\t\\t   # starting word temp:\\n\\t\\t   q = [\\'\\']\\n            for jj in range(len(temp)-1):\\n                segment = temp[jj] + temp[jj+1]\\n                new = []        \\n                for string in q:\\n                    try:\\n                        for newChar in hasht[segment]:\\n                            new.append(string + newChar)\\n                    except:\\n                        pass\\n                    \\n                q = new\\n            \\n            return(q)\\n        \\n        ##########\\n\\t\\t# make a dictionary of key, value pairs where key is the first two \\n\\t\\t# strings of a word in allowed, and value is a list of the possible\\n\\t\\t# chars one level up:\\n        hasht = {}\\n        for pyr in allowed:\\n            if pyr[:2] in hasht:\\n                hasht[pyr[:2]].append(pyr[-1])\\n            else:\\n                hasht[pyr[:2]] = [pyr[-1]]\\n        \\n        #########\\n        n = len(bottom)\\n\\t\\t\\n\\t\\t# perms is the possible words at a level:\\n        perms = [bottom]\\n        \\n        for ii in range(n-1):\\n\\t\\t\\t\\n\\t\\t\\t# using a set to efficiently capture unique words one level up \\n\\t\\t\\t# from current level:\\n            nextLevel = set([])\\n            \\n            for word in perms:\\n                nextLevel = nextLevel.union(set(evalPerms(word)))\\n                \\n\\t\\t\\t#  if no words evaluated for the next level up, then \\n\\t\\t\\t# return False\\n            if nextLevel == set([]):\\n                return(False)\\n            else:\\n                perms = nextLevel\\n\\t\\t   \\n\\t\\t# if the top was reached, return True:\\n        return(True)",
                "codeTag": "Python3"
            },
            {
                "id": 2033426,
                "title": "python3-dfs-solution-not-tle",
                "content": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        # DFS\\n        # tuition: use a dictionary to map from (left, right) to top; for a given bottom row, find every possible next row and then verify.\\n        \\n        dic = collections.defaultdict(set) \\n        for left, right, top in allowed:\\n            dic[(left, right)].add(top)\\n             \\n        def dfs(bottom): # for a given bottom row, return whether a valid pyramid can be built or not\\n            if len(bottom) == 1: return True # reach the top, done\\n            nxt = []\\n            for i in range(len(bottom)-1):\\n                if (bottom[i], bottom[i+1]) not in dic: return False\\n                top = [letter for letter in dic[(bottom[i], bottom[i+1])]]\\n                nxt.append(top)\\n            # recursively verify each possible next row\\n            for nxt_row in itertools.product(*nxt): # returns the cartesian product from the given iterator in lexicographic ordered.\\n                if dfs(nxt_row): return True\\n            return False   \\n        \\n        return dfs(bottom)\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        # DFS\\n        # tuition: use a dictionary to map from (left, right) to top; for a given bottom row, find every possible next row and then verify.\\n        \\n        dic = collections.defaultdict(set) \\n        for left, right, top in allowed:\\n            dic[(left, right)].add(top)\\n             \\n        def dfs(bottom): # for a given bottom row, return whether a valid pyramid can be built or not\\n            if len(bottom) == 1: return True # reach the top, done\\n            nxt = []\\n            for i in range(len(bottom)-1):\\n                if (bottom[i], bottom[i+1]) not in dic: return False\\n                top = [letter for letter in dic[(bottom[i], bottom[i+1])]]\\n                nxt.append(top)\\n            # recursively verify each possible next row\\n            for nxt_row in itertools.product(*nxt): # returns the cartesian product from the given iterator in lexicographic ordered.\\n                if dfs(nxt_row): return True\\n            return False   \\n        \\n        return dfs(bottom)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965124,
                "title": "javascript-backtracking-map",
                "content": "```\\n/**\\n * @param {string} bottom\\n * @param {string[]} allowed\\n * @return {boolean}\\n */\\nvar pyramidTransition = function (bottom, allowed) {\\n  const map = {};\\n  for (const string of allowed) {\\n    const substring = string.slice(0, 2);\\n    const value = string.slice(2);\\n    map[substring] = (map[substring] || []);\\n    map[substring].push(value);\\n  }\\n\\n  return helper(bottom, map);\\n};\\n\\nfunction helper(bottom, map) {\\n  if (bottom.length === 1) return true;\\n\\n  // check if possible\\n  for (let i = 0; i < bottom.length - 1; i++) {\\n    const substring = bottom.slice(i, i + 2);\\n    if (!(substring in map)) return false;\\n  }\\n\\n  const nextBottomLists = []; \\n  fillNextBottomLists(nextBottomLists, 0, bottom, map, \\'\\');\\n\\n  for (const nextBottom of nextBottomLists) {\\n    if (helper(nextBottom, map)) return true;\\n  }\\n\\n  return false;\\n}\\n\\nfunction fillNextBottomLists(nextBottomLists, idx, bottom, map, tempString) {\\n  if (idx === bottom.length - 1) {\\n    nextBottomLists.push(tempString);\\n    return;\\n  }\\n\\n  for (const char of map[bottom.slice(idx, idx + 2)]) {\\n    const nextTempString = tempString + char;\\n    fillNextBottomLists(nextBottomLists, idx + 1, bottom, map, nextTempString);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} bottom\\n * @param {string[]} allowed\\n * @return {boolean}\\n */\\nvar pyramidTransition = function (bottom, allowed) {\\n  const map = {};\\n  for (const string of allowed) {\\n    const substring = string.slice(0, 2);\\n    const value = string.slice(2);\\n    map[substring] = (map[substring] || []);\\n    map[substring].push(value);\\n  }\\n\\n  return helper(bottom, map);\\n};\\n\\nfunction helper(bottom, map) {\\n  if (bottom.length === 1) return true;\\n\\n  // check if possible\\n  for (let i = 0; i < bottom.length - 1; i++) {\\n    const substring = bottom.slice(i, i + 2);\\n    if (!(substring in map)) return false;\\n  }\\n\\n  const nextBottomLists = []; \\n  fillNextBottomLists(nextBottomLists, 0, bottom, map, \\'\\');\\n\\n  for (const nextBottom of nextBottomLists) {\\n    if (helper(nextBottom, map)) return true;\\n  }\\n\\n  return false;\\n}\\n\\nfunction fillNextBottomLists(nextBottomLists, idx, bottom, map, tempString) {\\n  if (idx === bottom.length - 1) {\\n    nextBottomLists.push(tempString);\\n    return;\\n  }\\n\\n  for (const char of map[bottom.slice(idx, idx + 2)]) {\\n    const nextTempString = tempString + char;\\n    fillNextBottomLists(nextBottomLists, idx + 1, bottom, map, nextTempString);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1962948,
                "title": "go-dfs-solution-100",
                "content": "### regular DFS\\n\\n```go\\nfunc pyramidTransition(bottom string, allowed []string) bool {\\n    nexts := map[string][]byte{}\\n    for _, v := range allowed {\\n        nexts[v[:2]] = append(nexts[v[:2]], v[2])\\n    }\\n\\n    var dfs func(cur, next []byte) bool\\n    dfs = func(cur, next []byte) bool {\\n        if len(cur) == 1 {\\n            return true\\n        }\\n        if len(cur) == len(next)+1 {\\n            return dfs(next, nil)\\n        }\\n        i := len(next)\\n        s := string(cur[i : i+2])\\n        for _, c := range nexts[s] {\\n            if dfs(cur, append(next, c)) {\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n\\n    return dfs([]byte(bottom), nil)\\n}\\n```\\n\\n### improved DFS\\n\\n```go\\nfunc pyramidTransition(bottom string, allowed []string) bool {\\n    nexts := map[string][]byte{}\\n    for _, v := range allowed {\\n        nexts[v[:2]] = append(nexts[v[:2]], v[2])\\n    }\\n\\n    var dfs func(cur []byte, i int) bool\\n    dfs = func(cur []byte, i int) bool {\\n        if len(cur) == 1 {\\n            return true\\n        }\\n        if len(cur) == i+1 {\\n            return dfs(cur[:len(cur)-1], 0)\\n        }\\n        s := string(cur[i : i+2])\\n        for _, c := range nexts[s] {\\n            cur[i] = c // no need to backtrack\\n            if dfs(cur, i+1) {\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n\\n    return dfs([]byte(bottom), 0)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc pyramidTransition(bottom string, allowed []string) bool {\\n    nexts := map[string][]byte{}\\n    for _, v := range allowed {\\n        nexts[v[:2]] = append(nexts[v[:2]], v[2])\\n    }\\n\\n    var dfs func(cur, next []byte) bool\\n    dfs = func(cur, next []byte) bool {\\n        if len(cur) == 1 {\\n            return true\\n        }\\n        if len(cur) == len(next)+1 {\\n            return dfs(next, nil)\\n        }\\n        i := len(next)\\n        s := string(cur[i : i+2])\\n        for _, c := range nexts[s] {\\n            if dfs(cur, append(next, c)) {\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n\\n    return dfs([]byte(bottom), nil)\\n}\\n```\n```go\\nfunc pyramidTransition(bottom string, allowed []string) bool {\\n    nexts := map[string][]byte{}\\n    for _, v := range allowed {\\n        nexts[v[:2]] = append(nexts[v[:2]], v[2])\\n    }\\n\\n    var dfs func(cur []byte, i int) bool\\n    dfs = func(cur []byte, i int) bool {\\n        if len(cur) == 1 {\\n            return true\\n        }\\n        if len(cur) == i+1 {\\n            return dfs(cur[:len(cur)-1], 0)\\n        }\\n        s := string(cur[i : i+2])\\n        for _, c := range nexts[s] {\\n            cur[i] = c // no need to backtrack\\n            if dfs(cur, i+1) {\\n                return true\\n            }\\n        }\\n        return false\\n    }\\n\\n    return dfs([]byte(bottom), 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858149,
                "title": "java-solution-with-backtracking-tle",
                "content": "Based on [Pascal\\'s Triangle ](https://leetcode.com/problems/pascals-triangle/)\\n```\\n\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        int level = bottom.length();\\n        List<Character> pyramid = new LinkedList<Character>(); \\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : allowed) {\\n            String key = s.substring(0,2);\\n            if (!map.containsKey(key)){\\n              map.put(key, new ArrayList<String>());  \\n            } \\n            map.get(key).add(s);\\n        }\\n        for(int i=0; i<level; i++){\\n            pyramid.add(bottom.charAt(i));\\n        }        \\n        return compute(pyramid, allowed, map, level-1, level-1);\\n    }\\n    \\n    public boolean compute(List<Character> pyramid, List<String> allowed, Map<String, List<String>> map,  int level, int breadth){\\n        if(level == 0) return true;\\n        int size = pyramid.size();\\n        int prev = level;\\n        List<String> loop = map.get(pyramid.get(size-prev-1)+\"\"+pyramid.get(size-prev));\\n        breadth--;\\n        if(loop != null){\\n            for(String i :loop){\\n                pyramid.add(i.charAt(2));               \\n                int nextLevel = breadth == 0? level-1: level;\\n                breadth = breadth == 0? nextLevel: breadth;   \\n                if(compute(pyramid, allowed,map, nextLevel, breadth)){\\n                    return true;\\n                }\\n                pyramid.remove(pyramid.size()-1);\\n            }\\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        int level = bottom.length();\\n        List<Character> pyramid = new LinkedList<Character>(); \\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : allowed) {\\n            String key = s.substring(0,2);\\n            if (!map.containsKey(key)){\\n              map.put(key, new ArrayList<String>());  \\n            } \\n            map.get(key).add(s);\\n        }\\n        for(int i=0; i<level; i++){\\n            pyramid.add(bottom.charAt(i));\\n        }        \\n        return compute(pyramid, allowed, map, level-1, level-1);\\n    }\\n    \\n    public boolean compute(List<Character> pyramid, List<String> allowed, Map<String, List<String>> map,  int level, int breadth){\\n        if(level == 0) return true;\\n        int size = pyramid.size();\\n        int prev = level;\\n        List<String> loop = map.get(pyramid.get(size-prev-1)+\"\"+pyramid.get(size-prev));\\n        breadth--;\\n        if(loop != null){\\n            for(String i :loop){\\n                pyramid.add(i.charAt(2));               \\n                int nextLevel = breadth == 0? level-1: level;\\n                breadth = breadth == 0? nextLevel: breadth;   \\n                if(compute(pyramid, allowed,map, nextLevel, breadth)){\\n                    return true;\\n                }\\n                pyramid.remove(pyramid.size()-1);\\n            }\\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725181,
                "title": "java-solution-greed-and-memorization-very-slow",
                "content": "```\\nclass Solution {\\n    Set<String> set = new HashSet<>();\\n    boolean f(String b, String t, int sz, int i, Set<String> all) {\\n        if (sz == 1 && t.length() == 1) return true;\\n        String key = b + \" \" + t + \" \" + sz + \" \" + i;\\n        if (set.contains(key)) return false;\\n        if (sz == i) return f(t, \"\", sz - 1, 0, all);\\n        String str = b.charAt(i)+\"\"+b.charAt(i+1); \\n        for (int j = i; j < sz; j++)\\n            for (char c = \\'A\\'; c <= \\'F\\'; c++)\\n                if (all.contains(str + c) && f(b, t + c, sz, i + 1, all)) return true;\\n        set.add(key);\\n        return false;\\n    }\\n\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Set<String> all = new HashSet<>(allowed);\\n        return f(bottom, \"\", bottom.length() - 1, 0, all);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Greedy",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Set<String> set = new HashSet<>();\\n    boolean f(String b, String t, int sz, int i, Set<String> all) {\\n        if (sz == 1 && t.length() == 1) return true;\\n        String key = b + \" \" + t + \" \" + sz + \" \" + i;\\n        if (set.contains(key)) return false;\\n        if (sz == i) return f(t, \"\", sz - 1, 0, all);\\n        String str = b.charAt(i)+\"\"+b.charAt(i+1); \\n        for (int j = i; j < sz; j++)\\n            for (char c = \\'A\\'; c <= \\'F\\'; c++)\\n                if (all.contains(str + c) && f(b, t + c, sz, i + 1, all)) return true;\\n        set.add(key);\\n        return false;\\n    }\\n\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Set<String> all = new HashSet<>(allowed);\\n        return f(bottom, \"\", bottom.length() - 1, 0, all);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714970,
                "title": "dfs-generate-candidates-and-speed-up-by-memo",
                "content": "# 756. Pyramid Transition Matrix\\n\\nWe are stacking blocks to form a pyramid. Each block has a color which is a one letter string.\\n\\nWe are allowed to place any color block `C` on top of two adjacent blocks of colors `A` and `B`, if and only if `ABC` is an allowed triple.\\n\\nWe start with a bottom row of `bottom`, represented as a single string. We also start with a list of allowed triples `allowed`. Each allowed triple is represented as a string of length 3.\\n\\nReturn true if we can build the pyramid all the way to the top, otherwise false.\\n\\n**Example 1:**\\n\\n```\\nInput: bottom = \"BCD\", allowed = [\"BCG\", \"CDE\", \"GEA\", \"FFF\"]\\nOutput: true\\nExplanation:\\nWe can stack the pyramid like this:\\n    A\\n   / \\\\\\n  G   E\\n / \\\\ / \\\\\\nB   C   D\\n\\nWe are allowed to place G on top of B and C because BCG is an allowed triple.  Similarly, we can place E on top of C and D, then A on top of G and E.\\n```\\n\\n \\n\\n**Example 2:**\\n\\n```\\nInput: bottom = \"AABA\", allowed = [\"AAA\", \"AAB\", \"ABA\", \"ABB\", \"BAC\"]\\nOutput: false\\nExplanation:\\nWe can\\'t stack the pyramid to the top.\\nNote that there could be allowed triples (A, B, C) and (A, B, D) with C != D.\\n```\\n\\n \\n\\n**Constraints:**\\n\\n- `bottom` will be a string with length in range `[2, 8]`.\\n- `allowed` will have length in range `[0, 200]`.\\n- Letters in all strings will be chosen from the set `{\\'A\\', \\'B\\', \\'C\\', \\'D\\', \\'E\\', \\'F\\', \\'G\\'}`.\\n\\nSolution\\n\\n```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mapping = collections.defaultdict(list)\\n        for s in allowed:\\n            mapping[s[:2]].append(s[2])\\n        return self.dfs(mapping, bottom)\\n    \\n    def dfs(self, mapping, bottom):\\n        if len(bottom) == 1: \\n            return True\\n        for i in itertools.product(*(mapping[x+y] for x,y in zip(bottom[:-1],bottom[1:]))):\\n            if self.dfs(mapping, i): \\n                return True\\n        return False\\n```\\n\\n```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mapping = collections.defaultdict(list)\\n        for s in allowed:\\n            mapping[s[:2]].append(s[2])\\n        return self.dfs(mapping, bottom)\\n    \\n    def dfs(self, mapping, bottom):\\n        if len(bottom) == 1: \\n            return True\\n        \\n        candidates = [\"\"]\\n        for x, y in zip(bottom[:-1],bottom[1:]):\\n            tmp = []\\n            for ch in mapping[x+y]:\\n                for candidate in candidates:\\n                    tmp.append(candidate+ch)\\n            candidates = tmp\\n        \\n        for candidate in candidates:\\n            if self.dfs(mapping, candidate): \\n                return True\\n        return False\\n```\\n\\nadd memo\\n\\n```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mapping = {}\\n        return self.dfs(mapping, set(allowed), bottom)\\n    \\n    def dfs(self, mapping, allowed, bottom):\\n        if bottom in mapping:\\n            return mapping[bottom]\\n        \\n        if len(bottom) == 1: \\n            return True\\n        \\n        candidates = [\"\"]\\n        for i in range(len(bottom)-1):\\n            tmp = []\\n            for ch in [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]:\\n                if bottom[i:i+2]+ch in allowed:\\n                    for path in candidates:\\n                        tmp.append(path+ch)\\n            candidates = tmp\\n        \\n        for candidate in candidates:\\n            if candidate not in mapping:\\n                mapping[candidate] = self.dfs(mapping, allowed, candidate)\\n            if mapping[candidate]:\\n                return True\\n        return False\\n```\\n\\ndfs another way\\n\\n```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mapping = collections.defaultdict(set)\\n        for s in allowed:\\n            mapping[s[:2]].add(s[2])\\n        return self.dfs(mapping, bottom, 0, \"\")\\n    \\n    def dfs(self, mapping, bottom, i, path):\\n        if len(bottom) == 1: \\n            return True\\n        if i == len(bottom)-1:\\n            return self.dfs(mapping, path, 0, \"\")\\n        if bottom[i:i+2] not in mapping:\\n            return False\\n        for ch in mapping[bottom[i:i+2]]:\\n            if self.dfs(mapping, bottom, i+1, path+ch):\\n                return True\\n        return False\\n```\\n\\nadd memo\\n\\n```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mapping = {}\\n        return self.dfs(mapping, set(allowed), bottom, 0, \"\")\\n    \\n    def dfs(self, mapping, allowed, bottom, i, path):\\n        if bottom in mapping:\\n            return mapping[bottom]\\n        \\n        if len(bottom) == 1: \\n            return True\\n        \\n        if i == len(bottom)-1:\\n            return self.dfs(mapping, allowed, path, 0, \"\")\\n        \\n        for ch in [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]:\\n            if bottom[i:i+2]+ch in allowed:\\n                mapping[path+ch] = self.dfs(mapping, allowed, bottom, i+1, path+ch)\\n                if mapping[path+ch]:\\n                    return True\\n        return False\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nInput: bottom = \"BCD\", allowed = [\"BCG\", \"CDE\", \"GEA\", \"FFF\"]\\nOutput: true\\nExplanation:\\nWe can stack the pyramid like this:\\n    A\\n   / \\\\\\n  G   E\\n / \\\\ / \\\\\\nB   C   D\\n\\nWe are allowed to place G on top of B and C because BCG is an allowed triple.  Similarly, we can place E on top of C and D, then A on top of G and E.\\n```\n```\\nInput: bottom = \"AABA\", allowed = [\"AAA\", \"AAB\", \"ABA\", \"ABB\", \"BAC\"]\\nOutput: false\\nExplanation:\\nWe can\\'t stack the pyramid to the top.\\nNote that there could be allowed triples (A, B, C) and (A, B, D) with C != D.\\n```\n```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mapping = collections.defaultdict(list)\\n        for s in allowed:\\n            mapping[s[:2]].append(s[2])\\n        return self.dfs(mapping, bottom)\\n    \\n    def dfs(self, mapping, bottom):\\n        if len(bottom) == 1: \\n            return True\\n        for i in itertools.product(*(mapping[x+y] for x,y in zip(bottom[:-1],bottom[1:]))):\\n            if self.dfs(mapping, i): \\n                return True\\n        return False\\n```\n```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mapping = collections.defaultdict(list)\\n        for s in allowed:\\n            mapping[s[:2]].append(s[2])\\n        return self.dfs(mapping, bottom)\\n    \\n    def dfs(self, mapping, bottom):\\n        if len(bottom) == 1: \\n            return True\\n        \\n        candidates = [\"\"]\\n        for x, y in zip(bottom[:-1],bottom[1:]):\\n            tmp = []\\n            for ch in mapping[x+y]:\\n                for candidate in candidates:\\n                    tmp.append(candidate+ch)\\n            candidates = tmp\\n        \\n        for candidate in candidates:\\n            if self.dfs(mapping, candidate): \\n                return True\\n        return False\\n```\n```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mapping = {}\\n        return self.dfs(mapping, set(allowed), bottom)\\n    \\n    def dfs(self, mapping, allowed, bottom):\\n        if bottom in mapping:\\n            return mapping[bottom]\\n        \\n        if len(bottom) == 1: \\n            return True\\n        \\n        candidates = [\"\"]\\n        for i in range(len(bottom)-1):\\n            tmp = []\\n            for ch in [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]:\\n                if bottom[i:i+2]+ch in allowed:\\n                    for path in candidates:\\n                        tmp.append(path+ch)\\n            candidates = tmp\\n        \\n        for candidate in candidates:\\n            if candidate not in mapping:\\n                mapping[candidate] = self.dfs(mapping, allowed, candidate)\\n            if mapping[candidate]:\\n                return True\\n        return False\\n```\n```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mapping = collections.defaultdict(set)\\n        for s in allowed:\\n            mapping[s[:2]].add(s[2])\\n        return self.dfs(mapping, bottom, 0, \"\")\\n    \\n    def dfs(self, mapping, bottom, i, path):\\n        if len(bottom) == 1: \\n            return True\\n        if i == len(bottom)-1:\\n            return self.dfs(mapping, path, 0, \"\")\\n        if bottom[i:i+2] not in mapping:\\n            return False\\n        for ch in mapping[bottom[i:i+2]]:\\n            if self.dfs(mapping, bottom, i+1, path+ch):\\n                return True\\n        return False\\n```\n```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        mapping = {}\\n        return self.dfs(mapping, set(allowed), bottom, 0, \"\")\\n    \\n    def dfs(self, mapping, allowed, bottom, i, path):\\n        if bottom in mapping:\\n            return mapping[bottom]\\n        \\n        if len(bottom) == 1: \\n            return True\\n        \\n        if i == len(bottom)-1:\\n            return self.dfs(mapping, allowed, path, 0, \"\")\\n        \\n        for ch in [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]:\\n            if bottom[i:i+2]+ch in allowed:\\n                mapping[path+ch] = self.dfs(mapping, allowed, bottom, i+1, path+ch)\\n                if mapping[path+ch]:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646875,
                "title": "java-solution-dfs",
                "content": "```\\n// DFS (O(V+E))\\n// Time Complexity O(N*(V+E))\\nclass Solution {\\n    public Map<String, Set<Character>> map;\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        map = new HashMap<>();\\n\\t\\t// Build Graph\\n        for (String a : allowed) {\\n            String s = a.substring(0, 2);\\n            Character c = a.charAt(2);\\n            Set<Character> set = map.getOrDefault(s, new HashSet<>());\\n            set.add(c);\\n            map.put(s, set);\\n        }\\n        return pyramid(bottom);\\n    }\\n    private boolean pyramid(String bottom) {\\n        if (bottom.length() == 2) {\\n            return map.containsKey(bottom);\\n        } else {\\n            List<String> current = new ArrayList<>();\\n            dfs(current, bottom, new StringBuilder(), 0);\\n            for (String c : current) {\\n                if (pyramid(c)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\t// DFS to add all strings to current \\n    private void dfs(List<String> current, String bottom, StringBuilder sb, int index) {\\n        if (sb.length() == bottom.length() - 1) {\\n            current.add(sb.toString());\\n            return;\\n        }\\n        for (Character c : map.getOrDefault(bottom.substring(index, index + 2), new HashSet<>())) {\\n            sb.append(c);\\n            dfs(current, bottom, sb, index + 1);\\n            sb.setLength(sb.length() - 1);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public Map<String, Set<Character>> map;\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        map = new HashMap<>();\\n\\t\\t// Build Graph\\n        for (String a : allowed) {\\n            String s = a.substring(0, 2);\\n            Character c = a.charAt(2);\\n            Set<Character> set = map.getOrDefault(s, new HashSet<>());\\n            set.add(c);\\n            map.put(s, set);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1605447,
                "title": "python-using-memoization-without-tle",
                "content": "```\\nfrom collections import defaultdict\\nfrom itertools import product\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        pattern = defaultdict(list)\\n        memo = defaultdict(bool)\\n        for a in allowed: pattern[a[0:2]].append(a[2])\\n        \\n        def dfs(bottom):\\n            \\n            if len(bottom) == 1: return True\\n            \\n            for new_bottom in product(*(\\n                pattern[l+r] for l, r in zip(bottom, bottom[1:]))):\\n                \\n                if new_bottom not in memo: memo[new_bottom] = dfs(new_bottom)\\n                if memo[new_bottom]: return True\\n                \\n            return False\\n        \\n        return dfs(bottom)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nfrom itertools import product\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        pattern = defaultdict(list)\\n        memo = defaultdict(bool)\\n        for a in allowed: pattern[a[0:2]].append(a[2])\\n        \\n        def dfs(bottom):\\n            \\n            if len(bottom) == 1: return True\\n            \\n            for new_bottom in product(*(\\n                pattern[l+r] for l, r in zip(bottom, bottom[1:]))):\\n                \\n                if new_bottom not in memo: memo[new_bottom] = dfs(new_bottom)\\n                if memo[new_bottom]: return True\\n                \\n            return False\\n        \\n        return dfs(bottom)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588310,
                "title": "java-simple-backtracking-without-explanation",
                "content": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        if (bottom.length() < 2) return false;\\n        Map<String, List<Character>> map = new HashMap<>();\\n        for (String block : allowed) {\\n            String prefix = block.substring(0, 2);\\n            if (map.containsKey(prefix)) {\\n                map.get(prefix).add(block.charAt(2));\\n            } else {\\n                List<Character> l = new LinkedList<>();\\n                l.add(block.charAt(2));\\n                map.put(prefix, l);\\n            }\\n        }\\n        return backtrack(bottom, new StringBuilder(), map);\\n\\n    }\\n    public boolean backtrack(String bottom, StringBuilder sb, Map<String, List<Character>> map) {\\n        if (bottom.length() == 2) {\\n            return map.containsKey(bottom);\\n        }\\n        if (sb.length() == bottom.length() - 1) {\\n            return backtrack(sb.toString(), new StringBuilder(), map);\\n        }\\n\\n        String prefix = bottom.substring(sb.length(), sb.length() + 2);\\n        List<Character> cl = map.get(prefix);\\n        if (cl != null) {\\n            for (char c : cl) {\\n                if (sb.length() != 0) { // optimization\\n                    String checkPrefix = \"\" + sb.charAt(sb.length() - 1) + c;\\n                    if (!map.containsKey(checkPrefix)) continue;\\n                }\\n                sb.append(c);\\n                if (backtrack(bottom, sb, map)) {\\n                    return true;\\n                }\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        if (bottom.length() < 2) return false;\\n        Map<String, List<Character>> map = new HashMap<>();\\n        for (String block : allowed) {\\n            String prefix = block.substring(0, 2);\\n            if (map.containsKey(prefix)) {\\n                map.get(prefix).add(block.charAt(2));\\n            } else {\\n                List<Character> l = new LinkedList<>();\\n                l.add(block.charAt(2));\\n                map.put(prefix, l);\\n            }\\n        }\\n        return backtrack(bottom, new StringBuilder(), map);\\n\\n    }\\n    public boolean backtrack(String bottom, StringBuilder sb, Map<String, List<Character>> map) {\\n        if (bottom.length() == 2) {\\n            return map.containsKey(bottom);\\n        }\\n        if (sb.length() == bottom.length() - 1) {\\n            return backtrack(sb.toString(), new StringBuilder(), map);\\n        }\\n\\n        String prefix = bottom.substring(sb.length(), sb.length() + 2);\\n        List<Character> cl = map.get(prefix);\\n        if (cl != null) {\\n            for (char c : cl) {\\n                if (sb.length() != 0) { // optimization\\n                    String checkPrefix = \"\" + sb.charAt(sb.length() - 1) + c;\\n                    if (!map.containsKey(checkPrefix)) continue;\\n                }\\n                sb.append(c);\\n                if (backtrack(bottom, sb, map)) {\\n                    return true;\\n                }\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573739,
                "title": "question-how-is-cde-allowed-in-the-first-example",
                "content": "![image](https://assets.leetcode.com/users/images/2c3a643c-1d76-4e54-b4e7-41d112c9751c_1636708440.5290756.jpeg)\\n\\nIn the first example, we have:\\n\\n```\\nInput: bottom = \"BCD\", allowed = [\"BCC\",\"CDE\",\"CEA\",\"FFF\"]\\n```\\n\\nhow is CED allowed since its not in the allowed list?",
                "solutionTags": [],
                "code": "```\\nInput: bottom = \"BCD\", allowed = [\"BCC\",\"CDE\",\"CEA\",\"FFF\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568573,
                "title": "python-3-solution-using-recursion-backtracking-depth-first-search-whatever-you-may-call-it",
                "content": "```\\ndef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n\\tdic = {}\\n\\tfor a in allowed:\\n\\t\\tif a[:2] not in dic:\\n\\t\\t\\tdic[a[:2]] = []\\n\\t\\tdic[a[:2]].append(a[2])\\n\\n\\tl = len(bottom)\\n\\tstack = [([], bottom, 0, l-1)]\\n\\tdone = set()\\n\\tdone.add(bottom)\\n\\n\\twhile stack:\\n\\t\\ttill, current, pos, limit = stack.pop()\\n\\t\\tif limit==0:\\n\\t\\t\\treturn True\\n\\t\\tif pos==limit:\\n\\t\\t\\tbottom = \"\".join(till)\\n\\t\\t\\t#I got time limit error because of not using this line\\n\\t\\t\\t#if a bottom is already seen, means it\\'s work has already been done\\n\\t\\t\\tif bottom not in done:\\n\\t\\t\\t\\tstack.append(([], bottom, 0, limit-1))\\n\\t\\t\\t\\tdone.add(bottom)\\n\\t\\telse:\\n\\t\\t\\tif current[pos:pos+2] in dic:\\n\\t\\t\\t\\tfor c in dic[current[pos:pos+2]]:\\n\\t\\t\\t\\t\\tstack.append((till+[c], current, pos+1, limit))\\n\\treturn False\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n\\tdic = {}\\n\\tfor a in allowed:\\n\\t\\tif a[:2] not in dic:\\n\\t\\t\\tdic[a[:2]] = []\\n\\t\\tdic[a[:2]].append(a[2])\\n\\n\\tl = len(bottom)\\n\\tstack = [([], bottom, 0, l-1)]\\n\\tdone = set()\\n\\tdone.add(bottom)\\n\\n\\twhile stack:\\n\\t\\ttill, current, pos, limit = stack.pop()\\n\\t\\tif limit==0:\\n\\t\\t\\treturn True\\n\\t\\tif pos==limit:\\n\\t\\t\\tbottom = \"\".join(till)\\n\\t\\t\\t#I got time limit error because of not using this line\\n\\t\\t\\t#if a bottom is already seen, means it\\'s work has already been done\\n\\t\\t\\tif bottom not in done:\\n\\t\\t\\t\\tstack.append(([], bottom, 0, limit-1))\\n\\t\\t\\t\\tdone.add(bottom)\\n\\t\\telse:\\n\\t\\t\\tif current[pos:pos+2] in dic:\\n\\t\\t\\t\\tfor c in dic[current[pos:pos+2]]:\\n\\t\\t\\t\\t\\tstack.append((till+[c], current, pos+1, limit))\\n\\treturn False\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1561164,
                "title": "java-backtracking-with-note",
                "content": "class Solution {\\n    Map<String, List<String>> map;\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        map = new HashMap<>();\\n        for (String as : allowed) {\\n            map.putIfAbsent(as.substring(0, 2), new ArrayList<>());\\n            map.get(\\n                as.substring(0, 2)).add(as.substring(2));\\n        }\\n        // AA [B, C]  BC:[D] BB[E] DE[F]\\n        return backtracking(bottom, 1, \"\");\\n    }\\n    // AA\\n    // AAAA, 2, B   AAAA, 2, C\\n    // AAAA, 3 BB  AAAA, 3 BC   AAAA, 3, CB   AAAA, 3, CC\\n    // AAAA, 4 BBB  AAAA, 4 BBC  AAAA, 4 BCB AAAA, 4 BCC\\n    private boolean backtracking(String cur, int index,\\n                                 String ns) {\\n        if (cur.length() == 1) {\\n            return true;\\n        }\\n        if (index == cur.length()) {\\n            return backtracking(ns, 1, \"\");\\n        }\\n        String s = cur.substring(index-1, index+1);\\n        if (!map.containsKey(s)) {\\n            return false;\\n        }\\n        for (String as: map.get(s)) {\\n            if (backtracking(cur, index+1, ns+as)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n// leftright:top\\n// BC:C  CD:E CE:A FF:F\\n\\n// AA[B,C] BC[D] BB[E] DE[F]",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<String, List<String>> map;\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        map = new HashMap<>();\\n        for (String as : allowed) {\\n            map.putIfAbsent(as.substring(0, 2), new ArrayList<>());\\n            map.get(\\n                as.substring(0, 2)).add(as.substring(2));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1512591,
                "title": "python-backtracking-beats-96-runtime-and-67-memory",
                "content": "Simple idea: backtracking. We try each pair from the curren bottom and keep building up the next level. For each pair, there might be multiple options to choose from, for example `AAC` and `AAB`, we only choose the one that can form a new pattern after appending to the next level. Continuously doing so, until we reach the level with only one element.\\n\\nTo avoid the repeated work, I keep track of all the bottoms that failed. \\n\\n```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        from collections import defaultdict\\n        patterns = defaultdict(list) #map `AAC` to `AA => C`\\n        for pattern in allowed: \\n            patterns[pattern[:2]].append(pattern[2])\\n        failed = set() # record all failed bottoms\\n        def backtracking(curr, next, i):\\n            if curr in failed: return False\\n            if i == len(curr): # if the bottom is being fully processed, use next as the new bottom\\n                curr = next\\n                next = \\'\\'\\n                i = 1\\n            if len(curr) == 1: return True # when reach the top of the pyramid\\n            for option in patterns[curr[i-1] + curr[i]]:\\n                if not next or next[-1] + option in patterns:\\n                    if backtracking(curr, next + option, i + 1):\\n                        return True\\n            failed.add(curr)\\n            return False\\n        return backtracking(bottom, \\'\\', 1)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        from collections import defaultdict\\n        patterns = defaultdict(list) #map `AAC` to `AA => C`\\n        for pattern in allowed: \\n            patterns[pattern[:2]].append(pattern[2])\\n        failed = set() # record all failed bottoms\\n        def backtracking(curr, next, i):\\n            if curr in failed: return False\\n            if i == len(curr): # if the bottom is being fully processed, use next as the new bottom\\n                curr = next\\n                next = \\'\\'\\n                i = 1\\n            if len(curr) == 1: return True # when reach the top of the pyramid\\n            for option in patterns[curr[i-1] + curr[i]]:\\n                if not next or next[-1] + option in patterns:\\n                    if backtracking(curr, next + option, i + 1):\\n                        return True\\n            failed.add(curr)\\n            return False\\n        return backtracking(bottom, \\'\\', 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470168,
                "title": "encoding-memoization-c",
                "content": "```\\nbool pyramidTransition(string bottom, vector<string>& allowed)\\n\\n        unordered_map<string, vector<string>> mp;\\n        for(auto a : allowed) \\n            mp[a.substr(0, 2)].push_back(a.substr(2));\\n        \\n        unordered_map<string, bool> dp;\\n        \\n        return rec(bottom, mp, 0, \"\" ,dp);\\n    }\\n    \\n    bool rec(string s, unordered_map<string, vector<string>>& mp, int i, \\n             string tmp, unordered_map<string, bool> &dp) \\n    {\\n        if(s.size() == 1) return true;\\n        if(i == s.size() - 1) {\\n            return rec(tmp, mp, 0, \"\", dp);\\n        }\\n        \\n        string encode = s + \"-\" + to_string(i) + \"-\" + tmp;\\n        if(dp.count(encode)) return dp[encode];\\n        \\n        int j = i + 1;\\n        string pref = \"\";\\n        pref += s[i]; pref += s[j];\\n        if(!mp.count(pref)) return dp[encode] = false;\\n        \\n        for(auto val : mp[pref]) \\n            if(rec(s, mp, i + 1, tmp + val, dp)) return dp[encode] = true;\\n        \\n        return dp[encode] = false;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool pyramidTransition(string bottom, vector<string>& allowed)\\n\\n        unordered_map<string, vector<string>> mp;\\n        for(auto a : allowed) \\n            mp[a.substr(0, 2)].push_back(a.substr(2));\\n        \\n        unordered_map<string, bool> dp;\\n        \\n        return rec(bottom, mp, 0, \"\" ,dp);\\n    }\\n    \\n    bool rec(string s, unordered_map<string, vector<string>>& mp, int i, \\n             string tmp, unordered_map<string, bool> &dp) \\n    {\\n        if(s.size() == 1) return true;\\n        if(i == s.size() - 1) {\\n            return rec(tmp, mp, 0, \"\", dp);\\n        }\\n        \\n        string encode = s + \"-\" + to_string(i) + \"-\" + tmp;\\n        if(dp.count(encode)) return dp[encode];\\n        \\n        int j = i + 1;\\n        string pref = \"\";\\n        pref += s[i]; pref += s[j];\\n        if(!mp.count(pref)) return dp[encode] = false;\\n        \\n        for(auto val : mp[pref]) \\n            if(rec(s, mp, i + 1, tmp + val, dp)) return dp[encode] = true;\\n        \\n        return dp[encode] = false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1470125,
                "title": "c-trie-bfs-dfs-60-61-passed",
                "content": "Someone please check the code and help me optimize it .\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    typedef struct node{\\n        struct node * dic[26]={NULL};\\n        \\n    }TrieNode;\\n    \\n    TrieNode *root;\\n    \\n    TrieNode *createNode(){\\n        TrieNode * newNode=new TrieNode();\\n        return newNode;\\n    }\\n    \\n    \\n    void addToTrie(string s){\\n        TrieNode *p=root;\\n        \\n        int index=0;\\n        \\n        for(auto ele:s){\\n            int index=ele-\\'A\\';\\n            if(p->dic[index]==NULL){\\n                TrieNode *newNode = createNode();\\n                p->dic[index]=newNode;\\n            }\\n            p=p->dic[index];\\n            \\n            \\n            index++;\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    void traverseTrie(TrieNode *p,string s){\\n        if(s.size()==3){\\n            cout<<s<<endl;\\n        }\\n        int index=0;\\n        \\n        while(index<26){\\n            if(p->dic[index]!=NULL){\\n                traverseTrie(p->dic[index],s+(char)(\\'A\\'+index));\\n            }    \\n            index++;\\n        }\\n    \\n    }\\n    \\n    vector<char> getAtLastElements(string s){\\n        TrieNode* p=root;\\n        vector<char>arr;\\n        \\n        if(p->dic[s[0]-\\'A\\']!=NULL)\\n        {\\n             p=p->dic[s[0]-\\'A\\'];\\n            \\n            if(p->dic[s[1]-\\'A\\']!=NULL)\\n            {\\n                p=p->dic[s[1]-\\'A\\'];\\n                int index=0;\\n                while(index<26){\\n                    if(p->dic[index]!=NULL){\\n                        arr.push_back((char)(\\'A\\'+index));\\n                    }\\n                    index++;\\n                }\\n            }\\n            \\n        }   \\n        return arr;\\n        \\n    }\\n    \\n    \\n    void getNextStrings(string s,int i,int j,string curStr,vector<string>&curArr){\\n        \\n        if(s[j]==\\'\\\\0\\'){\\n            curArr.push_back(curStr);\\n            return ;\\n        }\\n        \\n        \\n        vector<char>lastElements=getAtLastElements(s.substr(i,2));\\n        \\n        for(auto ele:lastElements){\\n            getNextStrings(s,i+1,j+1,curStr+ele,curArr);\\n        }\\n        \\n    }\\n    \\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n        root=createNode();\\n        \\n        for(auto ele:allowed){\\n            addToTrie(ele);\\n        }\\n        \\n        //traverseTrie(root,\"\");\\n        \\n        bool flag=false;\\n        \\n        deque<string>Q;\\n        Q.push_back(bottom);\\n        \\n        unordered_map<string,bool>dp;\\n        \\n        dp[bottom]=true;\\n        \\n        int len=bottom.size();\\n        \\n        \\n        \\n        while(!Q.empty()){\\n            \\n            deque<string>childQ;\\n            \\n            dp={};\\n            \\n            while(!Q.empty()){\\n                \\n                auto frontQ=Q.front();\\n                dp[frontQ]=true;\\n                \\n                Q.pop_front();\\n                \\n                if(len<=1)\\n                    return true;\\n                \\n                vector<string>nextStrings;\\n                getNextStrings(frontQ,0,1,\"\",nextStrings);\\n                \\n                for(auto everyNextString:nextStrings){\\n                    if(dp.count(everyNextString)==0){\\n                        childQ.push_back(everyNextString);\\n                        dp[everyNextString]=true;\\n                        \\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n            Q=childQ;\\n            len--;\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    typedef struct node{\\n        struct node * dic[26]={NULL};\\n        \\n    }TrieNode;\\n    \\n    TrieNode *root;\\n    \\n    TrieNode *createNode(){\\n        TrieNode * newNode=new TrieNode();\\n        return newNode;\\n    }\\n    \\n    \\n    void addToTrie(string s){\\n        TrieNode *p=root;\\n        \\n        int index=0;\\n        \\n        for(auto ele:s){\\n            int index=ele-\\'A\\';\\n            if(p->dic[index]==NULL){\\n                TrieNode *newNode = createNode();\\n                p->dic[index]=newNode;\\n            }\\n            p=p->dic[index];\\n            \\n            \\n            index++;\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    void traverseTrie(TrieNode *p,string s){\\n        if(s.size()==3){\\n            cout<<s<<endl;\\n        }\\n        int index=0;\\n        \\n        while(index<26){\\n            if(p->dic[index]!=NULL){\\n                traverseTrie(p->dic[index],s+(char)(\\'A\\'+index));\\n            }    \\n            index++;\\n        }\\n    \\n    }\\n    \\n    vector<char> getAtLastElements(string s){\\n        TrieNode* p=root;\\n        vector<char>arr;\\n        \\n        if(p->dic[s[0]-\\'A\\']!=NULL)\\n        {\\n             p=p->dic[s[0]-\\'A\\'];\\n            \\n            if(p->dic[s[1]-\\'A\\']!=NULL)\\n            {\\n                p=p->dic[s[1]-\\'A\\'];\\n                int index=0;\\n                while(index<26){\\n                    if(p->dic[index]!=NULL){\\n                        arr.push_back((char)(\\'A\\'+index));\\n                    }\\n                    index++;\\n                }\\n            }\\n            \\n        }   \\n        return arr;\\n        \\n    }\\n    \\n    \\n    void getNextStrings(string s,int i,int j,string curStr,vector<string>&curArr){\\n        \\n        if(s[j]==\\'\\\\0\\'){\\n            curArr.push_back(curStr);\\n            return ;\\n        }\\n        \\n        \\n        vector<char>lastElements=getAtLastElements(s.substr(i,2));\\n        \\n        for(auto ele:lastElements){\\n            getNextStrings(s,i+1,j+1,curStr+ele,curArr);\\n        }\\n        \\n    }\\n    \\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n        root=createNode();\\n        \\n        for(auto ele:allowed){\\n            addToTrie(ele);\\n        }\\n        \\n        //traverseTrie(root,\"\");\\n        \\n        bool flag=false;\\n        \\n        deque<string>Q;\\n        Q.push_back(bottom);\\n        \\n        unordered_map<string,bool>dp;\\n        \\n        dp[bottom]=true;\\n        \\n        int len=bottom.size();\\n        \\n        \\n        \\n        while(!Q.empty()){\\n            \\n            deque<string>childQ;\\n            \\n            dp={};\\n            \\n            while(!Q.empty()){\\n                \\n                auto frontQ=Q.front();\\n                dp[frontQ]=true;\\n                \\n                Q.pop_front();\\n                \\n                if(len<=1)\\n                    return true;\\n                \\n                vector<string>nextStrings;\\n                getNextStrings(frontQ,0,1,\"\",nextStrings);\\n                \\n                for(auto everyNextString:nextStrings){\\n                    if(dp.count(everyNextString)==0){\\n                        childQ.push_back(everyNextString);\\n                        dp[everyNextString]=true;\\n                        \\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n            Q=childQ;\\n            len--;\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1394952,
                "title": "python-dfs-and-bfs",
                "content": "DFS Solution - TLE\\n```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        \\n        allowed = set(allowed)\\n        \\n        def combinations(available, i, path, combs):\\n            \"\"\"\\n            Function to generate all the possible valid combinations\\n            \"\"\"\\n            if i == len(available):\\n                combs.add(\"\".join(path))\\n            else:\\n                for j in range(len(available[i])):\\n                    path.append(available[i][j])\\n                    combinations(available, i+1, path, combs)\\n                    path.pop()\\n                   \\n        def dfs(bottom):\\n\\n            if len(bottom) == 1:\\n                return True\\n            else:\\n                \\n                levels = []\\n                # Check the allowed characters for every two characters\\n                for i in range(len(bottom)-1):\\n                    first_char = bottom[i]\\n                    second_char = bottom[i+1]\\n                    \\n                    levels.append([])\\n                    for char in \"ABCDEFG\":\\n                        tmp = first_char + second_char + char\\n                        if tmp in allowed:\\n                            levels[i].append(char)\\n                \\n                # If the are not enough characters to work in the next level return False\\n                if len(levels) != len(bottom)-1:\\n                    return False\\n                \\n                # Create and check all the combinations\\n                combs = set()\\n                combinations(levels, 0, [], combs)\\n\\n                if len(combs) != 0:\\n                    for combination in combs:\\n                        if dfs(combination):\\n                            return True\\n                    \\n                    \\n                return False\\n                \\n            \\n        return dfs(bottom)\\n```\\n\\nBFS solution - TLE\\n```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        \\n        allowed = set(allowed)\\n      \\n        def combinations(available, i, path, combs):\\n            \"\"\"\\n            Function to generate all the possible valid combinations\\n            \"\"\"\\n            if i == len(available):\\n                combs.add(\"\".join(path))\\n            else:\\n                for j in range(len(available[i])):\\n                    path.append(available[i][j])\\n                    combinations(available, i+1, path, combs)\\n                    path.pop()\\n            \\n        allowed = set(allowed)\\n        \\n        queue = deque([bottom])\\n        \\n        # BCD -> GE\\n        while len(queue) != 0:\\n            \\n            for _ in range(len(queue)):\\n                \\n                bottom = queue.popleft()\\n                \\n                if len(bottom) == 1:\\n                    return True\\n                \\n                levels = []\\n                # Check the allowed characters for every two characters\\n                for i in range(len(bottom)-1):\\n                    first_char = bottom[i]\\n                    second_char = bottom[i+1]\\n                    \\n                    levels.append([])\\n                    for char in \"ABCDEFG\":\\n                        tmp = first_char + second_char + char\\n                        if tmp in allowed:\\n                            levels[i].append(char)\\n                # If the are not enough characters to work in the next level return False            \\n                if len(levels) != len(bottom)-1:\\n                    continue\\n                \\n                # Create and check all the combinations\\n                combs = set()\\n                combinations(levels, 0, [], combs)\\n\\n                if len(combs) != 0:\\n                    for combination in combs:\\n                        queue.append(combination)\\n        \\n        return False\\n        \\n                            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        \\n        allowed = set(allowed)\\n        \\n        def combinations(available, i, path, combs):\\n            \"\"\"\\n            Function to generate all the possible valid combinations\\n            \"\"\"\\n            if i == len(available):\\n                combs.add(\"\".join(path))\\n            else:\\n                for j in range(len(available[i])):\\n                    path.append(available[i][j])\\n                    combinations(available, i+1, path, combs)\\n                    path.pop()\\n                   \\n        def dfs(bottom):\\n\\n            if len(bottom) == 1:\\n                return True\\n            else:\\n                \\n                levels = []\\n                # Check the allowed characters for every two characters\\n                for i in range(len(bottom)-1):\\n                    first_char = bottom[i]\\n                    second_char = bottom[i+1]\\n                    \\n                    levels.append([])\\n                    for char in \"ABCDEFG\":\\n                        tmp = first_char + second_char + char\\n                        if tmp in allowed:\\n                            levels[i].append(char)\\n                \\n                # If the are not enough characters to work in the next level return False\\n                if len(levels) != len(bottom)-1:\\n                    return False\\n                \\n                # Create and check all the combinations\\n                combs = set()\\n                combinations(levels, 0, [], combs)\\n\\n                if len(combs) != 0:\\n                    for combination in combs:\\n                        if dfs(combination):\\n                            return True\\n                    \\n                    \\n                return False\\n                \\n            \\n        return dfs(bottom)\\n```\n```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        \\n        allowed = set(allowed)\\n      \\n        def combinations(available, i, path, combs):\\n            \"\"\"\\n            Function to generate all the possible valid combinations\\n            \"\"\"\\n            if i == len(available):\\n                combs.add(\"\".join(path))\\n            else:\\n                for j in range(len(available[i])):\\n                    path.append(available[i][j])\\n                    combinations(available, i+1, path, combs)\\n                    path.pop()\\n            \\n        allowed = set(allowed)\\n        \\n        queue = deque([bottom])\\n        \\n        # BCD -> GE\\n        while len(queue) != 0:\\n            \\n            for _ in range(len(queue)):\\n                \\n                bottom = queue.popleft()\\n                \\n                if len(bottom) == 1:\\n                    return True\\n                \\n                levels = []\\n                # Check the allowed characters for every two characters\\n                for i in range(len(bottom)-1):\\n                    first_char = bottom[i]\\n                    second_char = bottom[i+1]\\n                    \\n                    levels.append([])\\n                    for char in \"ABCDEFG\":\\n                        tmp = first_char + second_char + char\\n                        if tmp in allowed:\\n                            levels[i].append(char)\\n                # If the are not enough characters to work in the next level return False            \\n                if len(levels) != len(bottom)-1:\\n                    continue\\n                \\n                # Create and check all the combinations\\n                combs = set()\\n                combinations(levels, 0, [], combs)\\n\\n                if len(combs) != 0:\\n                    for combination in combs:\\n                        queue.append(combination)\\n        \\n        return False\\n        \\n                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288670,
                "title": "c-dfs-with-memorization-bfs-tle",
                "content": "DFS follows idea from https://leetcode.com/problems/pyramid-transition-matrix/discuss/170870/concise-C%2B%2B-recursive-solution-(10-line)\\nsmart ways to construct next level recursively\\n\\n```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        if (allowed.empty()) return false;\\n        unordered_map<string, vector<char>> allowed_map;\\n        for (int i = 0; i < allowed.size(); ++i) {\\n            allowed_map[allowed[i].substr(0, 2)].push_back(allowed[i][2]);\\n        }\\n        return DFS_walk(bottom, allowed_map, 0, \"\");\\n    }\\n    unordered_map<string, bool> memo;\\n    bool DFS_walk(string& current_level, unordered_map<string, vector<char>>& allowed_map, int index, string next_level) {\\n        if (current_level.size() == 1) return true;\\n        if (index ==  current_level.size()-1) return DFS_walk(next_level, allowed_map, 0, \"\");\\n        if (index ==0 && memo.count(current_level)) return memo[current_level];\\n        bool ans = false;\\n        for (const char& c : allowed_map[current_level.substr(index, 2)]) {\\n            next_level.append(1, c);\\n            ans = DFS_walk(current_level, allowed_map, index+1, next_level);\\n            next_level.pop_back();\\n            if (ans) break;\\n        }\\n        if (index == 0) memo[current_level] = ans;\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nBFS solution for archive:\\n```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        if (allowed.empty()) return false;\\n        unordered_map<string, vector<char>> allowed_map;\\n        for (int i = 0; i < allowed.size(); ++i) {\\n            allowed_map[allowed[i].substr(0, 2)].push_back(allowed[i][2]);\\n        }\\n        vector<string> queue;\\n        queue.push_back(bottom);\\n\\n        int level = bottom.size();\\n        while(queue.size() && level > 1) {\\n            unordered_set<string> visited;\\n            vector<string> new_queue;\\n            for (int i = 0; i < queue.size(); ++i) {\\n                unordered_set<string> words;\\n                bool is_valid = true;\\n                for (int j = 0; j < queue[i].size()-1; ++j) {\\n                    if (allowed_map.count(queue[i].substr(j, 2)) == 0) {\\n                        is_valid = false;\\n                        break;\\n                    }\\n                }\\n                if (!is_valid) continue;\\n                for (int j = 0; j < queue[i].size()-1; ++j) {\\n                    unordered_set<string> new_words;\\n                    if (words.empty()) {\\n                        for (const char& c : allowed_map[queue[i].substr(j, 2)]) {\\n                            new_words.insert(string(1, c));\\n                        }\\n                    } else {\\n                        for (const char& c : allowed_map[queue[i].substr(j, 2)]) {\\n                            for (const string& w : words) {\\n                                string new_word = w; new_word.append(1, c);\\n                                new_words.insert(new_word);\\n                            }\\n                        }\\n                    }\\n                    swap(words, new_words);\\n                }\\n                if (words.empty()) continue;\\n                for (const string& w : words) {\\n                    if (visited.count(w)) continue;\\n                    visited.insert(w);\\n                    new_queue.push_back(w);\\n                }\\n            }\\n            if (new_queue.empty()) return false;\\n            swap(queue, new_queue);\\n            --level;\\n        }\\n        return level == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        if (allowed.empty()) return false;\\n        unordered_map<string, vector<char>> allowed_map;\\n        for (int i = 0; i < allowed.size(); ++i) {\\n            allowed_map[allowed[i].substr(0, 2)].push_back(allowed[i][2]);\\n        }\\n        return DFS_walk(bottom, allowed_map, 0, \"\");\\n    }\\n    unordered_map<string, bool> memo;\\n    bool DFS_walk(string& current_level, unordered_map<string, vector<char>>& allowed_map, int index, string next_level) {\\n        if (current_level.size() == 1) return true;\\n        if (index ==  current_level.size()-1) return DFS_walk(next_level, allowed_map, 0, \"\");\\n        if (index ==0 && memo.count(current_level)) return memo[current_level];\\n        bool ans = false;\\n        for (const char& c : allowed_map[current_level.substr(index, 2)]) {\\n            next_level.append(1, c);\\n            ans = DFS_walk(current_level, allowed_map, index+1, next_level);\\n            next_level.pop_back();\\n            if (ans) break;\\n        }\\n        if (index == 0) memo[current_level] = ans;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        if (allowed.empty()) return false;\\n        unordered_map<string, vector<char>> allowed_map;\\n        for (int i = 0; i < allowed.size(); ++i) {\\n            allowed_map[allowed[i].substr(0, 2)].push_back(allowed[i][2]);\\n        }\\n        vector<string> queue;\\n        queue.push_back(bottom);\\n\\n        int level = bottom.size();\\n        while(queue.size() && level > 1) {\\n            unordered_set<string> visited;\\n            vector<string> new_queue;\\n            for (int i = 0; i < queue.size(); ++i) {\\n                unordered_set<string> words;\\n                bool is_valid = true;\\n                for (int j = 0; j < queue[i].size()-1; ++j) {\\n                    if (allowed_map.count(queue[i].substr(j, 2)) == 0) {\\n                        is_valid = false;\\n                        break;\\n                    }\\n                }\\n                if (!is_valid) continue;\\n                for (int j = 0; j < queue[i].size()-1; ++j) {\\n                    unordered_set<string> new_words;\\n                    if (words.empty()) {\\n                        for (const char& c : allowed_map[queue[i].substr(j, 2)]) {\\n                            new_words.insert(string(1, c));\\n                        }\\n                    } else {\\n                        for (const char& c : allowed_map[queue[i].substr(j, 2)]) {\\n                            for (const string& w : words) {\\n                                string new_word = w; new_word.append(1, c);\\n                                new_words.insert(new_word);\\n                            }\\n                        }\\n                    }\\n                    swap(words, new_words);\\n                }\\n                if (words.empty()) continue;\\n                for (const string& w : words) {\\n                    if (visited.count(w)) continue;\\n                    visited.insert(w);\\n                    new_queue.push_back(w);\\n                }\\n            }\\n            if (new_queue.empty()) return false;\\n            swap(queue, new_queue);\\n            --level;\\n        }\\n        return level == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280975,
                "title": "sol-n-by-just-using-backtracking",
                "content": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        if (bottom.length() == 1) return true;\\n        \\n        List<List<Integer>> bottomLists = createBottom(bottom, allowed, 1);\\n        \\n        boolean found = false;\\n        for (List<Integer> newBottomIndices : bottomLists) {\\n            List<String> newAllowed =  new ArrayList<>(allowed);\\n            String newBottom = \"\";\\n            for (int i : newBottomIndices)\\n                newBottom += allowed.get(i).charAt(2);\\n\\n            found = found || pyramidTransition(newBottom, newAllowed);\\n        }\\n        return found;\\n    }\\n    public List<List<Integer>> createBottom(String bottom, List<String> allowed, int index) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        if (index == bottom.length()) return ans;\\n\\n        String current = bottom.substring(index - 1, index + 1);\\n\\n        // Get the matching string and go ahead\\n        for (int j = 0; j < allowed.size(); j++) {\\n            if (allowed.get(j).startsWith(current)) {\\n                List<List<Integer>> smallerAns = createBottom(bottom, allowed, index + 1);\\n\\n                for (List<Integer> smallerList : smallerAns) {\\n                    smallerList.add(0, j);\\n                    ans.add(new ArrayList<Integer>(smallerList));\\n                }\\n\\n                // Base case will return empty list of lists\\n                if(index == bottom.length() - 1) {\\n                    List<Integer> smallerList = new ArrayList<Integer>();\\n                    smallerList.add(j);\\n                    ans.add(smallerList);\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        if (bottom.length() == 1) return true;\\n        \\n        List<List<Integer>> bottomLists = createBottom(bottom, allowed, 1);\\n        \\n        boolean found = false;\\n        for (List<Integer> newBottomIndices : bottomLists) {\\n            List<String> newAllowed =  new ArrayList<>(allowed);\\n            String newBottom = \"\";\\n            for (int i : newBottomIndices)\\n                newBottom += allowed.get(i).charAt(2);\\n\\n            found = found || pyramidTransition(newBottom, newAllowed);\\n        }\\n        return found;\\n    }\\n    public List<List<Integer>> createBottom(String bottom, List<String> allowed, int index) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        if (index == bottom.length()) return ans;\\n\\n        String current = bottom.substring(index - 1, index + 1);\\n\\n        // Get the matching string and go ahead\\n        for (int j = 0; j < allowed.size(); j++) {\\n            if (allowed.get(j).startsWith(current)) {\\n                List<List<Integer>> smallerAns = createBottom(bottom, allowed, index + 1);\\n\\n                for (List<Integer> smallerList : smallerAns) {\\n                    smallerList.add(0, j);\\n                    ans.add(new ArrayList<Integer>(smallerList));\\n                }\\n\\n                // Base case will return empty list of lists\\n                if(index == bottom.length() - 1) {\\n                    List<Integer> smallerList = new ArrayList<Integer>();\\n                    smallerList.add(j);\\n                    ans.add(smallerList);\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270444,
                "title": "go-0-ms",
                "content": "```\\ntype base struct {\\n    left, right byte\\n}\\n\\nfunc isPossibleToBuild(bottom, nextLevel []byte, index map[base][]byte) bool {    \\n    if len(bottom) == 1 {\\n        if len(nextLevel) == 0 {\\n            return true\\n        }\\n        \\n        return isPossibleToBuild(nextLevel, []byte{}, index)\\n    }\\n    \\n    b := base{left:bottom[0], right:bottom[1]}\\n    tt, _ := index[b]\\n    for _, t := range tt {\\n        if isPossibleToBuild(bottom[1:], append(nextLevel, t), index) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc pyramidTransition(bottom string, allowed []string) bool {\\n    index := make(map[base][]byte)\\n    \\n    for _, triple := range allowed {\\n        b := base{left:triple[0], right:triple[1]}\\n        t := triple[2]\\n        \\n        index[b] = append(index[b], t)\\n    }\\n        \\n    return isPossibleToBuild(([]byte)(bottom), []byte{}, index)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype base struct {\\n    left, right byte\\n}\\n\\nfunc isPossibleToBuild(bottom, nextLevel []byte, index map[base][]byte) bool {    \\n    if len(bottom) == 1 {\\n        if len(nextLevel) == 0 {\\n            return true\\n        }\\n        \\n        return isPossibleToBuild(nextLevel, []byte{}, index)\\n    }\\n    \\n    b := base{left:bottom[0], right:bottom[1]}\\n    tt, _ := index[b]\\n    for _, t := range tt {\\n        if isPossibleToBuild(bottom[1:], append(nextLevel, t), index) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc pyramidTransition(bottom string, allowed []string) bool {\\n    index := make(map[base][]byte)\\n    \\n    for _, triple := range allowed {\\n        b := base{left:triple[0], right:triple[1]}\\n        t := triple[2]\\n        \\n        index[b] = append(index[b], t)\\n    }\\n        \\n    return isPossibleToBuild(([]byte)(bottom), []byte{}, index)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270075,
                "title": "a-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<String>> map = new HashMap();\\n        for(String entry: allowed) {\\n            String key = entry.substring(0,2);\\n            String value = entry.substring(2);\\n            if(map.containsKey(key)) {\\n                map.get(key).add(value);\\n            }else {\\n                List<String> list = new ArrayList<>();\\n                list.add(value);\\n                map.put(key, list);\\n            }\\n        }\\n        return find(bottom, allowed, map);\\n    }\\n    \\n    public boolean find(String level, List<String> allowed, Map<String, List<String>> map) {\\n        //base case\\n        if(level.length() == 1) return true;\\n        \\n        //if any of the pairs dont exist at this level, reutrn false\\n        for(int i = 0; i < level.length() - 1; i++) {\\n            String s = constructPair(level, i);\\n            if(!map.containsKey(s)) {\\n                return false;\\n            }\\n        } \\n        \\n        //get all possible nextlevels constructs, as one level can converge to many levels\\n        // Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D. \\n        List<String> nextLevels = new ArrayList<>();\\n        backtrack(0, level, new StringBuilder(), map, nextLevels);\\n        \\n        for(String nextLevel: nextLevels) {\\n            //check if any of the next levels converge\\n            if(find(nextLevel, allowed, map)) return true;\\n        }\\n        \\n        //default false\\n        return false;\\n    }\\n    \\n    //Backtrack function to collect all possible next levels\\n    public void backtrack(int index, String level, StringBuilder sb, Map<String, List<String>> map, List<String> nextLevels) {\\n        if(index == level.length() -1) {\\n            nextLevels.add(sb.toString());\\n            return;\\n        }\\n        \\n        String s = constructPair(level, index);\\n        for(String possibleValue: map.get(s)) {\\n            sb.append(possibleValue); //add\\n            backtrack(index+1, level, sb, map, nextLevels);\\n            sb.deleteCharAt(sb.length()-1); //remove last\\n        }\\n    }\\n    \\n    public String constructPair(String level, int index) {\\n        char first = level.charAt(index);\\n        char second = level.charAt(index+1);\\n        String s = String.valueOf(first) + String.valueOf(second);\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<String>> map = new HashMap();\\n        for(String entry: allowed) {\\n            String key = entry.substring(0,2);\\n            String value = entry.substring(2);\\n            if(map.containsKey(key)) {\\n                map.get(key).add(value);\\n            }else {\\n                List<String> list = new ArrayList<>();\\n                list.add(value);\\n                map.put(key, list);\\n            }\\n        }\\n        return find(bottom, allowed, map);\\n    }\\n    \\n    public boolean find(String level, List<String> allowed, Map<String, List<String>> map) {\\n        //base case\\n        if(level.length() == 1) return true;\\n        \\n        //if any of the pairs dont exist at this level, reutrn false\\n        for(int i = 0; i < level.length() - 1; i++) {\\n            String s = constructPair(level, i);\\n            if(!map.containsKey(s)) {\\n                return false;\\n            }\\n        } \\n        \\n        //get all possible nextlevels constructs, as one level can converge to many levels\\n        // Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D. \\n        List<String> nextLevels = new ArrayList<>();\\n        backtrack(0, level, new StringBuilder(), map, nextLevels);\\n        \\n        for(String nextLevel: nextLevels) {\\n            //check if any of the next levels converge\\n            if(find(nextLevel, allowed, map)) return true;\\n        }\\n        \\n        //default false\\n        return false;\\n    }\\n    \\n    //Backtrack function to collect all possible next levels\\n    public void backtrack(int index, String level, StringBuilder sb, Map<String, List<String>> map, List<String> nextLevels) {\\n        if(index == level.length() -1) {\\n            nextLevels.add(sb.toString());\\n            return;\\n        }\\n        \\n        String s = constructPair(level, index);\\n        for(String possibleValue: map.get(s)) {\\n            sb.append(possibleValue); //add\\n            backtrack(index+1, level, sb, map, nextLevels);\\n            sb.deleteCharAt(sb.length()-1); //remove last\\n        }\\n    }\\n    \\n    public String constructPair(String level, int index) {\\n        char first = level.charAt(index);\\n        char second = level.charAt(index+1);\\n        String s = String.valueOf(first) + String.valueOf(second);\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265152,
                "title": "javascript-dfs",
                "content": "```\\n/**\\n * @param {string} bottom\\n * @param {string[]} allowed\\n * @return {boolean}\\n */\\nvar pyramidTransition = function(bottom, allowed) {\\n    // key (bottomA, bottomB) => val list (top)\\n    const map = new Map()\\n    for (const triplet of allowed.values()) {\\n        const key = triplet.slice(0, 2), val = triplet.slice(-1)\\n        if (!map.has(key))  map.set(key, [])\\n        \\n        const list = map.get(key)\\n        list.push(val)\\n    }\\n    \\n    \\n    bottom = [...bottom]\\n    \\n    function getRows(matrix, fromIndex) {\\n        const len = matrix.length\\n        if (fromIndex === -1 + len) {\\n            const lastList = matrix[fromIndex]\\n            return lastList.map(ch => [ch])\\n        }\\n        \\n        let subresult = getRows(matrix, 1 + fromIndex)\\n        const list = matrix[fromIndex]\\n        let result = []\\n        for (const ch of list.values()) {\\n            for (const prevOutcome of subresult.values()) {\\n                let outcome = [ch, ...prevOutcome]\\n                result.push(outcome)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    function isOK(bottom) {\\n        const len = bottom.length\\n        if (len === 1)  return true\\n        \\n        const matrix = []\\n        for (let i = 0; i < -1 + len; i++) {\\n            const chA = bottom[i]\\n            const chB = bottom[1 + i]\\n            const key = chA + chB\\n            const list = map.get(key)\\n            if (!list)  return false\\n            \\n            matrix[i] = list\\n        }\\n        \\n        const rows = getRows(matrix, 0)\\n        for (const row of rows.values()) {\\n            if (isOK(row))  return true\\n        }\\n        \\n        return false\\n    }\\n\\n    \\n    let result = isOK(bottom)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} bottom\\n * @param {string[]} allowed\\n * @return {boolean}\\n */\\nvar pyramidTransition = function(bottom, allowed) {\\n    // key (bottomA, bottomB) => val list (top)\\n    const map = new Map()\\n    for (const triplet of allowed.values()) {\\n        const key = triplet.slice(0, 2), val = triplet.slice(-1)\\n        if (!map.has(key))  map.set(key, [])\\n        \\n        const list = map.get(key)\\n        list.push(val)\\n    }\\n    \\n    \\n    bottom = [...bottom]\\n    \\n    function getRows(matrix, fromIndex) {\\n        const len = matrix.length\\n        if (fromIndex === -1 + len) {\\n            const lastList = matrix[fromIndex]\\n            return lastList.map(ch => [ch])\\n        }\\n        \\n        let subresult = getRows(matrix, 1 + fromIndex)\\n        const list = matrix[fromIndex]\\n        let result = []\\n        for (const ch of list.values()) {\\n            for (const prevOutcome of subresult.values()) {\\n                let outcome = [ch, ...prevOutcome]\\n                result.push(outcome)\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    function isOK(bottom) {\\n        const len = bottom.length\\n        if (len === 1)  return true\\n        \\n        const matrix = []\\n        for (let i = 0; i < -1 + len; i++) {\\n            const chA = bottom[i]\\n            const chB = bottom[1 + i]\\n            const key = chA + chB\\n            const list = map.get(key)\\n            if (!list)  return false\\n            \\n            matrix[i] = list\\n        }\\n        \\n        const rows = getRows(matrix, 0)\\n        for (const row of rows.values()) {\\n            if (isOK(row))  return true\\n        }\\n        \\n        return false\\n    }\\n\\n    \\n    let result = isOK(bottom)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256843,
                "title": "c-recursive-solution-90-faster-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n         unordered_map<string,vector<char>>mp;\\n    \\n    bool recurs1(string& s,int i,string& fin)\\n    {\\n        int level=s.length();\\n        int a=0;\\n        \\n         if(level<=0)\\n        {\\n           return 1;    \\n        }\\n        if(fin.length()==s.length()-1)\\n        {\\n            string g=\"\";\\n            a=recurs1(fin,1,g);\\n        }\\n        \\n\\n        if(i>=s.length())\\n        {\\n            return a;\\n        }\\n        \\n           if(a==1)\\n                {\\n                    return 1;\\n                }\\n        \\n            string t=\"\";\\n            t+=s[i-1];t+=s[i];\\n            for(auto x:mp[t])\\n            {\\n                string temp=fin;\\n                temp+=x;\\n                a=a|recurs1(s,i+1,temp);\\n                if(a==1)\\n                {\\n                    return 1;\\n                }\\n            }\\n        \\n        \\n        return a;\\n    }\\n    \\n\\n    \\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n   \\n        \\n        for(auto x: allowed)\\n        {\\n            string t=\"\";\\n            t+=x[0];t+=x[1];\\n            mp[t].push_back(x[2]);\\n        }\\n        string fin=\"\";\\n        return recurs1(bottom,1,fin);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n         unordered_map<string,vector<char>>mp;\\n    \\n    bool recurs1(string& s,int i,string& fin)\\n    {\\n        int level=s.length();\\n        int a=0;\\n        \\n         if(level<=0)\\n        {\\n           return 1;    \\n        }\\n        if(fin.length()==s.length()-1)\\n        {\\n            string g=\"\";\\n            a=recurs1(fin,1,g);\\n        }\\n        \\n\\n        if(i>=s.length())\\n        {\\n            return a;\\n        }\\n        \\n           if(a==1)\\n                {\\n                    return 1;\\n                }\\n        \\n            string t=\"\";\\n            t+=s[i-1];t+=s[i];\\n            for(auto x:mp[t])\\n            {\\n                string temp=fin;\\n                temp+=x;\\n                a=a|recurs1(s,i+1,temp);\\n                if(a==1)\\n                {\\n                    return 1;\\n                }\\n            }\\n        \\n        \\n        return a;\\n    }\\n    \\n\\n    \\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n   \\n        \\n        for(auto x: allowed)\\n        {\\n            string t=\"\";\\n            t+=x[0];t+=x[1];\\n            mp[t].push_back(x[2]);\\n        }\\n        string fin=\"\";\\n        return recurs1(bottom,1,fin);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249482,
                "title": "build-rows-with-sets-of-allowed-letters-93-speed",
                "content": "Runtime: 32 ms, faster than 93.02%\\nMemory Usage: 14.2 MB, less than 98.26%\\n```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed) -> bool:\\n        dict_allowed = dict()\\n        for s in allowed:\\n            key = tuple(s[:2])\\n            if key in dict_allowed:\\n                dict_allowed[key].add(s[2])\\n            else:\\n                dict_allowed[key] = {s[2]}\\n        row = [{c} for c in bottom]\\n        while len(row) > 1:\\n            new_row = [set() for _ in range(len(row) - 1)]\\n            for i in range(len(row) - 1):\\n                for tpl in product(row[i], row[i + 1]):\\n                    if tpl in dict_allowed:\\n                        new_row[i].update(dict_allowed[tpl])\\n                if not new_row[i]:\\n                    return False\\n            row = new_row\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed) -> bool:\\n        dict_allowed = dict()\\n        for s in allowed:\\n            key = tuple(s[:2])\\n            if key in dict_allowed:\\n                dict_allowed[key].add(s[2])\\n            else:\\n                dict_allowed[key] = {s[2]}\\n        row = [{c} for c in bottom]\\n        while len(row) > 1:\\n            new_row = [set() for _ in range(len(row) - 1)]\\n            for i in range(len(row) - 1):\\n                for tpl in product(row[i], row[i + 1]):\\n                    if tpl in dict_allowed:\\n                        new_row[i].update(dict_allowed[tpl])\\n                if not new_row[i]:\\n                    return False\\n            row = new_row\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243449,
                "title": "no-explanation-generate-all-possible-next-levels-each-index-has-many-choices-cross-product",
                "content": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        root = dict()\\n        for a,b,c in allowed:\\n            if a+b not in root: root[a+b] = list()\\n            root[a+b].append(c)\\n        \\n        # now a relation...from this level, what is possible parents \\'up\\' is any of them valid??\\n        def dp(s):\\n            if len(s) == 1: return True\\n            up = [\\'\\'] # store all possible next levels\\n            \\n            \\n            for i in range(1,len(s)):\\n                nextup = []\\n                # try all the choices for first position\\n                if s[i-1]+s[i] not in root: return False\\n                # cross product \\n                for choice in root[s[i-1]+s[i]]:\\n                    for prefix in up:\\n                        nextup.append(prefix+choice)\\n                up, nextup = nextup, up\\n            \\n            \\n            return any(dp(x) for x in up)\\n        return dp(bottom)\\n    \\n    \\n    \\n    \\n    \"\"\"\\n    if i have some choices for a char at each index, \\n    \\n   BC= {a,d,g,f} CD = {s,d} \\n    {a,d,g,f}*{s,d} = as ds gs fs ad dd gd fd\\n    \\n    a \\n      as  \\n         ask\\n         ash\\n         asf\\n         adk\\n         adh\\n         adf\\n         dsk\\n         dsh\\n         \\n    \"\"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        root = dict()\\n        for a,b,c in allowed:\\n            if a+b not in root: root[a+b] = list()\\n            root[a+b].append(c)\\n        \\n        # now a relation...from this level, what is possible parents \\'up\\' is any of them valid??\\n        def dp(s):\\n            if len(s) == 1: return True\\n            up = [\\'\\'] # store all possible next levels\\n            \\n            \\n            for i in range(1,len(s)):\\n                nextup = []\\n                # try all the choices for first position\\n                if s[i-1]+s[i] not in root: return False\\n                # cross product \\n                for choice in root[s[i-1]+s[i]]:\\n                    for prefix in up:\\n                        nextup.append(prefix+choice)\\n                up, nextup = nextup, up\\n            \\n            \\n            return any(dp(x) for x in up)\\n        return dp(bottom)\\n    \\n    \\n    \\n    \\n    \"\"\"\\n    if i have some choices for a char at each index, \\n    \\n   BC= {a,d,g,f} CD = {s,d} \\n    {a,d,g,f}*{s,d} = as ds gs fs ad dd gd fd\\n    \\n    a \\n      as  \\n         ask\\n         ash\\n         asf\\n         adk\\n         adh\\n         adf\\n         dsk\\n         dsh\\n         \\n    \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242186,
                "title": "c-recursive-solution",
                "content": "```cpp\\nclass Solution {\\n    bool canBuildPyramid(string bottom, int si, string nxtBottom, map<string, vector<char>> &blocksMap) {\\n        if(bottom.size() == 1) // Reached the top of the Pyramid\\n            return true;\\n        if(bottom.size()-1 == si)  // Move Up the Pyramid & Process Next bricks set\\n            return canBuildPyramid(nxtBottom, 0, \"\", blocksMap);\\n        for(auto ch:blocksMap[bottom.substr(si, 2)]) { // Recursively check best block\\n            if(canBuildPyramid(bottom, si+1, nxtBottom+ch, blocksMap) == true)\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        map<string, vector<char>> blocksMap;\\n\\n\\t\\t// Construct Map\\n        for(auto allowStr:allowed) {\\n            blocksMap[allowStr.substr(0, 2)].push_back(allowStr.back());\\n        }\\n        \\n        return canBuildPyramid(bottom, 0, \"\", blocksMap);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n    bool canBuildPyramid(string bottom, int si, string nxtBottom, map<string, vector<char>> &blocksMap) {\\n        if(bottom.size() == 1) // Reached the top of the Pyramid\\n            return true;\\n        if(bottom.size()-1 == si)  // Move Up the Pyramid & Process Next bricks set\\n            return canBuildPyramid(nxtBottom, 0, \"\", blocksMap);\\n        for(auto ch:blocksMap[bottom.substr(si, 2)]) { // Recursively check best block\\n            if(canBuildPyramid(bottom, si+1, nxtBottom+ch, blocksMap) == true)\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        map<string, vector<char>> blocksMap;\\n\\n\\t\\t// Construct Map\\n        for(auto allowStr:allowed) {\\n            blocksMap[allowStr.substr(0, 2)].push_back(allowStr.back());\\n        }\\n        \\n        return canBuildPyramid(bottom, 0, \"\", blocksMap);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239339,
                "title": "c-soln-recursion-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string a, string b){\\n        return a.substr(0,2)==b;\\n    }\\n    unordered_map<string,vector<char>> mp;\\n    bool make(vector<string> &trip,vector<string> &botm, int i,string temp){\\n        if(i>=trip.size()){botm.push_back(temp);return true;}\\n        bool flag=false;\\n        for(auto &c:mp[trip[i]]){\\n            flag=true;\\n            if(!make(trip,botm,i+1,temp+c))return false;\\n        }\\n        if(!flag)return false;\\n        return true;\\n    }\\n    bool sol(int h, string bot){\\n        if(h==0)return true;\\n        string newbot=\"\";\\n        vector<string> trip;\\n        for(int i=0;i<bot.length()-1;i++){\\n            trip.push_back(bot.substr(i,2));\\n        }\\n        vector<string> bottm;\\n        if(!make(trip,bottm,0,\"\"))return false;\\n        for(auto &t:bottm){\\n            if(sol(h-1,t))return true;\\n        }\\n        return false;\\n        \\n    }\\n    bool pyramidTransition(string bottom, vector<string>& all) {\\n        int h=bottom.length();\\n        //so total supposed height will be h;\\n        for(auto &w:all){\\n            mp[w.substr(0,2)].push_back(w[2]);\\n        }\\n        return sol(h,bottom);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string a, string b){\\n        return a.substr(0,2)==b;\\n    }\\n    unordered_map<string,vector<char>> mp;\\n    bool make(vector<string> &trip,vector<string> &botm, int i,string temp){\\n        if(i>=trip.size()){botm.push_back(temp);return true;}\\n        bool flag=false;\\n        for(auto &c:mp[trip[i]]){\\n            flag=true;\\n            if(!make(trip,botm,i+1,temp+c))return false;\\n        }\\n        if(!flag)return false;\\n        return true;\\n    }\\n    bool sol(int h, string bot){\\n        if(h==0)return true;\\n        string newbot=\"\";\\n        vector<string> trip;\\n        for(int i=0;i<bot.length()-1;i++){\\n            trip.push_back(bot.substr(i,2));\\n        }\\n        vector<string> bottm;\\n        if(!make(trip,bottm,0,\"\"))return false;\\n        for(auto &t:bottm){\\n            if(sol(h-1,t))return true;\\n        }\\n        return false;\\n        \\n    }\\n    bool pyramidTransition(string bottom, vector<string>& all) {\\n        int h=bottom.length();\\n        //so total supposed height will be h;\\n        for(auto &w:all){\\n            mp[w.substr(0,2)].push_back(w[2]);\\n        }\\n        return sol(h,bottom);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220098,
                "title": "4ms-faster-than-91-simple",
                "content": "```\\nclass Solution {\\n    unordered_set<string>ust;\\n    const string letters = \"ABCDEFG\";\\n    bool func(const string& s, list<char>l = {}, int i = 0) {\\n        /* if (!i)\\n            cout << s << \\'\\\\n\\';\\n        for (const char& ch : l)\\n            cout << ch << \\' \\';\\n        cout << i << \\'\\\\n\\'; */\\n        if (s.length() == 1)\\n            return true;\\n        if (i == s.length() - 1)\\n            return func(string(l.begin(), l.end()));\\n        if (i >= s.length())\\n            i = 0;\\n        string abc = s.substr(i, 2);\\n        for (const char& ch : letters) {\\n            abc.push_back(ch);\\n            if (ust.find(abc) != ust.end()) {\\n                l.push_back(ch);\\n                if (func(s, l, i + 1))\\n                    return true;\\n                l.pop_back();\\n            }\\n            abc.pop_back();\\n        }\\n        return false;\\n    }\\npublic:\\n    bool pyramidTransition(string& s, vector<string>& v) {\\n        if (v.empty())\\n            return s.length() == 1;\\n        ust = unordered_set<string>(v.begin(), v.end());\\n        return func(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    unordered_set<string>ust;\\n    const string letters = \"ABCDEFG\";\\n    bool func(const string& s, list<char>l = {}, int i = 0) {\\n        /* if (!i)\\n            cout << s << \\'\\\\n\\';\\n        for (const char& ch : l)\\n            cout << ch << \\' \\';\\n        cout << i << \\'\\\\n\\'; */\\n        if (s.length() == 1)\\n            return true;\\n        if (i == s.length() - 1)\\n            return func(string(l.begin(), l.end()));\\n        if (i >= s.length())\\n            i = 0;\\n        string abc = s.substr(i, 2);\\n        for (const char& ch : letters) {\\n            abc.push_back(ch);\\n            if (ust.find(abc) != ust.end()) {\\n                l.push_back(ch);\\n                if (func(s, l, i + 1))\\n                    return true;\\n                l.pop_back();\\n            }\\n            abc.pop_back();\\n        }\\n        return false;\\n    }\\npublic:\\n    bool pyramidTransition(string& s, vector<string>& v) {\\n        if (v.empty())\\n            return s.length() == 1;\\n        ust = unordered_set<string>(v.begin(), v.end());\\n        return func(s);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1217750,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n\\nunordered_map<string,vector<char>>m;\\nbool solve(vector<char>&v,int i,int n){\\n    \\n    if(n==1) return true;\\n    \\n    string s=\"\";\\n    s+=v[i];\\n    s+=v[i+1];\\n    bool flag=false;\\n    \\n    for(auto &x:m[s]){\\n       char ch=v[i];\\n        v[i]=x;\\n        if(i==n-2){\\n          if(solve(v,0,n-1))return true;\\n        }else{\\n          if(solve(v,i+1,n)) return true;\\n        }\\n      v[i]=ch;\\n    }\\n    return false;\\n\\n}\\n  \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n  \\n      \\n      for(int i=0;i<allowed.size();i++){\\n        m[allowed[i].substr(0,2)].push_back(allowed[i][2]);\\n      }\\n      \\n      vector<char>v;\\n      for(int i=0;i<bottom.length();i++){\\n        v.push_back(bottom[i]);\\n      }\\n      int n= v.size();\\n      return solve(v,0,n);\\n      \\n      \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nunordered_map<string,vector<char>>m;\\nbool solve(vector<char>&v,int i,int n){\\n    \\n    if(n==1) return true;\\n    \\n    string s=\"\";\\n    s+=v[i];\\n    s+=v[i+1];\\n    bool flag=false;\\n    \\n    for(auto &x:m[s]){\\n       char ch=v[i];\\n        v[i]=x;\\n        if(i==n-2){\\n          if(solve(v,0,n-1))return true;\\n        }else{\\n          if(solve(v,i+1,n)) return true;\\n        }\\n      v[i]=ch;\\n    }\\n    return false;\\n\\n}\\n  \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n  \\n      \\n      for(int i=0;i<allowed.size();i++){\\n        m[allowed[i].substr(0,2)].push_back(allowed[i][2]);\\n      }\\n      \\n      vector<char>v;\\n      for(int i=0;i<bottom.length();i++){\\n        v.push_back(bottom[i]);\\n      }\\n      int n= v.size();\\n      return solve(v,0,n);\\n      \\n      \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181379,
                "title": "recurse-like-a-for-loop-layer-by-layer",
                "content": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        allowed_dict = collections.defaultdict(list)\\n        for i in range(len(allowed)):\\n            triple = allowed[i]\\n            allowed_dict[triple[:2]].append(triple[-1])\\n        def dfs(i,cur_level,prev_level):\\n            if i == len(prev_level)-1:\\n                prev_level = cur_level\\n                cur_level = \"\"\\n                i = 0\\n            if len(prev_level) == 1:\\n                return True\\n            for c in allowed_dict[prev_level[i] + prev_level[i+1]]:\\n                if dfs(i+1, cur_level + c, prev_level):\\n                    return True\\n            return False\\n        return dfs(0,\"\",bottom)\\n```\\nuse dict to quickly get valid values for a triangle. hardest part of this was figuring out how to turn it into a recursion problem. initially tried creating all possible values layer by layer but that resulted in TLE. recursion strategy use an index and try every possible value one by one. once a layer is finished, set the current layer as the previous layer and continue until the prev layer is only len 1 in which you are done",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        allowed_dict = collections.defaultdict(list)\\n        for i in range(len(allowed)):\\n            triple = allowed[i]\\n            allowed_dict[triple[:2]].append(triple[-1])\\n        def dfs(i,cur_level,prev_level):\\n            if i == len(prev_level)-1:\\n                prev_level = cur_level\\n                cur_level = \"\"\\n                i = 0\\n            if len(prev_level) == 1:\\n                return True\\n            for c in allowed_dict[prev_level[i] + prev_level[i+1]]:\\n                if dfs(i+1, cur_level + c, prev_level):\\n                    return True\\n            return False\\n        return dfs(0,\"\",bottom)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174405,
                "title": "java-solution-map-backtracking-very-easy-to-understand-beat-94",
                "content": "```\\nclass Solution {\\n    \\n    Map<String, List<String>> lookup = new HashMap();\\n    \\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        \\n        StringBuilder newBottom = new StringBuilder();\\n        for(String str : allowed)\\n        {\\n            String bottom1 = str.substring(0,2);\\n            String top = str.substring(2);\\n            if(!lookup.containsKey(bottom1))\\n            {\\n                lookup.put(bottom1, new ArrayList<String>());\\n            }\\n            lookup.get(bottom1).add(top);\\n            \\n        }\\n            \\n        \\n        if(dfs(bottom, newBottom, 1))\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    public boolean dfs(String bottom, StringBuilder newAllowed, int index)\\n    {\\n        if(bottom.length()==1)\\n        {\\n            return true;\\n        }\\n        if(index >= bottom.length())\\n        {\\n            return dfs(newAllowed.toString(), new StringBuilder(), 1);\\n        }\\n        \\n        List<String> blocks = lookup.get(bottom.substring(index-1,index+1));\\n        if(blocks == null || blocks.size() ==0)\\n        {\\n            \\n            \\n            return false;\\n        }\\n        \\n        for(String block : blocks)\\n        {\\n            if(dfs(bottom, newAllowed.append(block), index+1))\\n            {\\n                return true;\\n            }\\n            if(newAllowed.length() >=1)\\n            {\\n                \\n                newAllowed.setLength(newAllowed.length()-1);  \\n            }    \\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    Map<String, List<String>> lookup = new HashMap();\\n    \\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        \\n        StringBuilder newBottom = new StringBuilder();\\n        for(String str : allowed)\\n        {\\n            String bottom1 = str.substring(0,2);\\n            String top = str.substring(2);\\n            if(!lookup.containsKey(bottom1))\\n            {\\n                lookup.put(bottom1, new ArrayList<String>());\\n            }\\n            lookup.get(bottom1).add(top);\\n            \\n        }\\n            \\n        \\n        if(dfs(bottom, newBottom, 1))\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    public boolean dfs(String bottom, StringBuilder newAllowed, int index)\\n    {\\n        if(bottom.length()==1)\\n        {\\n            return true;\\n        }\\n        if(index >= bottom.length())\\n        {\\n            return dfs(newAllowed.toString(), new StringBuilder(), 1);\\n        }\\n        \\n        List<String> blocks = lookup.get(bottom.substring(index-1,index+1));\\n        if(blocks == null || blocks.size() ==0)\\n        {\\n            \\n            \\n            return false;\\n        }\\n        \\n        for(String block : blocks)\\n        {\\n            if(dfs(bottom, newAllowed.append(block), index+1))\\n            {\\n                return true;\\n            }\\n            if(newAllowed.length() >=1)\\n            {\\n                \\n                newAllowed.setLength(newAllowed.length()-1);  \\n            }    \\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165936,
                "title": "c-backtracking-clean-easy-to-read-code",
                "content": "```\\nclass Solution {\\n    unordered_map<string, vector<char>> tracker;\\n    \\n    bool dfs(int index, string currentLevel, string nextLevel) {        \\n        if (currentLevel.length() == 1)\\n            return true;\\n        \\n        if (index == currentLevel.length() - 1)\\n            return dfs(0, nextLevel, \"\");\\n        \\n        string curBase = currentLevel.substr(index, 2);\\n        \\n        if (not tracker.count(curBase))\\n            return false;\\n        \\n        for (auto candidate : tracker[curBase]) {\\n            nextLevel += candidate;\\n\\n            if (dfs(index + 1, currentLevel, nextLevel))\\n                return true;\\n            \\n            nextLevel.pop_back();\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        string currentLevel = bottom;\\n        string nextLevel = \"\";        \\n        \\n        for (auto str: allowed)\\n            tracker[str.substr(0, 2)].push_back(str[2]);\\n        \\n        return dfs(0, currentLevel, nextLevel);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    unordered_map<string, vector<char>> tracker;\\n    \\n    bool dfs(int index, string currentLevel, string nextLevel) {        \\n        if (currentLevel.length() == 1)\\n            return true;\\n        \\n        if (index == currentLevel.length() - 1)\\n            return dfs(0, nextLevel, \"\");\\n        \\n        string curBase = currentLevel.substr(index, 2);\\n        \\n        if (not tracker.count(curBase))\\n            return false;\\n        \\n        for (auto candidate : tracker[curBase]) {\\n            nextLevel += candidate;\\n\\n            if (dfs(index + 1, currentLevel, nextLevel))\\n                return true;\\n            \\n            nextLevel.pop_back();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1107276,
                "title": "backtrackig-with-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<char>>m;\\n    unordered_map<string,unordered_map<string,unordered_map<int,int>>>vis;\\n    \\n    int dfs(string crr,string fut,int k)\\n    {\\n        if(crr.length()==1&&k==0)\\n            return vis[crr][fut][k]=1;\\n        \\n        else if(vis.find(crr)!=vis.end()&&vis[crr].find(fut)!=vis[crr].end()&&vis[crr]               [fut].find(k)!=vis[crr][fut].end())\\n        {\\n                        return vis[crr][fut][k];\\n        }\\n        \\n        else if(k+2==crr.length())\\n        {\\n            \\n            string h=crr.substr(k,2);\\n            int ans=0;\\n            \\n            for(int i=0;i<m[h].size();i++)\\n            {\\n                string tt=fut+m[h][i];\\n                fut=tt;\\n                  ans=ans|dfs(fut,\"\",0);\\n                 fut.pop_back();\\n            }\\n            \\n            return vis[crr][fut][k]=ans;\\n            \\n        }\\n        else\\n        {\\n            int ans=0;\\n            \\n            string h=crr.substr(k,2);\\n            \\n            if(m.find(h)==m.end())\\n                ans=0;\\n            else\\n            {\\n                \\n             for(int i=0;i<m[h].size();i++)\\n            {\\n                 \\n            string tt=fut+m[h][i];\\n            fut=tt;\\n             ans=ans|dfs(crr,fut,k+1);\\n                 if(ans==1)\\n                     return vis[crr][fut][k]=1;\\n            fut.pop_back();\\n            }\\n            \\n            }\\n            \\n            return vis[crr][fut][k]=ans;\\n        }\\n        \\n        return 0;\\n    }\\n\\n    bool pyramidTransition(string bottom, vector<string>& allowed) \\n    {\\n        m.clear();\\n        vis.clear();\\n        \\n        for(int i=0;i<allowed.size();i++)\\n        {\\n            string k=allowed[i];\\n            m[k.substr(0,2)].push_back(k[2]);\\n            \\n        }\\n        \\n        int l=dfs(bottom,\"\",0);\\n        return l;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<char>>m;\\n    unordered_map<string,unordered_map<string,unordered_map<int,int>>>vis;\\n    \\n    int dfs(string crr,string fut,int k)\\n    {\\n        if(crr.length()==1&&k==0)\\n            return vis[crr][fut][k]=1;\\n        \\n        else if(vis.find(crr)!=vis.end()&&vis[crr].find(fut)!=vis[crr].end()&&vis[crr]               [fut].find(k)!=vis[crr][fut].end())\\n        {\\n                        return vis[crr][fut][k];\\n        }\\n        \\n        else if(k+2==crr.length())\\n        {\\n            \\n            string h=crr.substr(k,2);\\n            int ans=0;\\n            \\n            for(int i=0;i<m[h].size();i++)\\n            {\\n                string tt=fut+m[h][i];\\n                fut=tt;\\n                  ans=ans|dfs(fut,\"\",0);\\n                 fut.pop_back();\\n            }\\n            \\n            return vis[crr][fut][k]=ans;\\n            \\n        }\\n        else\\n        {\\n            int ans=0;\\n            \\n            string h=crr.substr(k,2);\\n            \\n            if(m.find(h)==m.end())\\n                ans=0;\\n            else\\n            {\\n                \\n             for(int i=0;i<m[h].size();i++)\\n            {\\n                 \\n            string tt=fut+m[h][i];\\n            fut=tt;\\n             ans=ans|dfs(crr,fut,k+1);\\n                 if(ans==1)\\n                     return vis[crr][fut][k]=1;\\n            fut.pop_back();\\n            }\\n            \\n            }\\n            \\n            return vis[crr][fut][k]=ans;\\n        }\\n        \\n        return 0;\\n    }\\n\\n    bool pyramidTransition(string bottom, vector<string>& allowed) \\n    {\\n        m.clear();\\n        vis.clear();\\n        \\n        for(int i=0;i<allowed.size();i++)\\n        {\\n            string k=allowed[i];\\n            m[k.substr(0,2)].push_back(k[2]);\\n            \\n        }\\n        \\n        int l=dfs(bottom,\"\",0);\\n        return l;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104630,
                "title": "c-solution-backtracking",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool solve(int l,int i, map<string,vector<char>> mp,string str,string next)\\n    {\\n  \\n     if(l==2 && mp.find(str)!=mp.end())\\n     {\\n         return true;\\n     }\\n      \\n    \\n       \\n        if(i==l)\\n        {\\n            return solve(next.size(),1,mp,next,\"\");\\n        }\\n        else\\n        {\\n            \\n        \\n        \\n      string w=next;\\n       \\n      for(char p:mp[str.substr(i-1,2)])\\n      {\\n          string w1=w+p;\\n        \\n          if(solve(l,i+1,mp,str,w1))\\n              return true;\\n          \\n          \\n      }\\n             return false;\\n        }\\n        \\n       \\n         return false;\\n        \\n    }\\n    \\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n        int n=allowed.size();\\n        map<string,vector<char>> mp;\\n        \\n        if(bottom.size()==1)\\n            return false;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[allowed[i].substr(0,2)].push_back(allowed[i][2]);\\n        }\\n        \\n        return solve(bottom.size(),1,mp,bottom,\"\");\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool solve(int l,int i, map<string,vector<char>> mp,string str,string next)\\n    {\\n  \\n     if(l==2 && mp.find(str)!=mp.end())\\n     {\\n         return true;\\n     }\\n      \\n    \\n       \\n        if(i==l)\\n        {\\n            return solve(next.size(),1,mp,next,\"\");\\n        }\\n        else\\n        {\\n            \\n        \\n        \\n      string w=next;\\n       \\n      for(char p:mp[str.substr(i-1,2)])\\n      {\\n          string w1=w+p;\\n        \\n          if(solve(l,i+1,mp,str,w1))\\n              return true;\\n          \\n          \\n      }\\n             return false;\\n        }\\n        \\n       \\n         return false;\\n        \\n    }\\n    \\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        \\n        int n=allowed.size();\\n        map<string,vector<char>> mp;\\n        \\n        if(bottom.size()==1)\\n            return false;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[allowed[i].substr(0,2)].push_back(allowed[i][2]);\\n        }\\n        \\n        return solve(bottom.size(),1,mp,bottom,\"\");\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081671,
                "title": "python-iterative-dfs-28-ms",
                "content": "```\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        d = defaultdict(list)\\n        for x in allowed:\\n            d[x[:-1]]  += [x[-1]]\\n        stack = [bottom]\\n        while stack:\\n            x = stack.pop()\\n            if x in d: return True\\n            nxt = []\\n            for i in range(len(x) - 1):\\n                if x[i: i + 2] in d:\\n                    nxt += [d[x[i: i + 2]]]\\n                else:\\n                    break\\n            if len(nxt) != len(x) - 1: continue\\n            stack += list(set([\\'\\'.join(y) for y in itertools.product(*nxt)]))\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        d = defaultdict(list)\\n        for x in allowed:\\n            d[x[:-1]]  += [x[-1]]\\n        stack = [bottom]\\n        while stack:\\n            x = stack.pop()\\n            if x in d: return True\\n            nxt = []\\n            for i in range(len(x) - 1):\\n                if x[i: i + 2] in d:\\n                    nxt += [d[x[i: i + 2]]]\\n                else:\\n                    break\\n            if len(nxt) != len(x) - 1: continue\\n            stack += list(set([\\'\\'.join(y) for y in itertools.product(*nxt)]))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074507,
                "title": "kotlin-solution",
                "content": "you can use StringBuilder to fruther optimize the solution\\n```\\n    fun pyramidTransition(bottom: String, allowed: List<String>): Boolean {\\n        if (bottom.isEmpty()) return false\\n        val aMap = mutableMapOf<String, MutableList<Char>>()\\n        for (triple in allowed){\\n            aMap.getOrPut(triple.slice(0..1),{mutableListOf()}).add(triple[2])\\n        }\\n        \\n        val checkedRows = mutableSetOf<String>()\\n        fun buildRow(bottom : String, i : Int, row : String) : Boolean {\\n            if (i == 0 && bottom in checkedRows) return false //skip this as it was checked\\n            if ( bottom.length == 1) return true\\n            if ( i >= bottom.lastIndex){\\n                checkedRows.add(bottom)\\n                return buildRow(row, 0, \"\")  \\n            } \\n            val base = bottom.slice(i..i+1)\\n            if (base !in aMap) return false\\n            for (c in aMap[base]!!){\\n                if (buildRow(bottom, i+1, row + c)) return true\\n            }\\n            return false\\n        }\\n        \\n        return buildRow(bottom, 0, \"\")\\n    }\\n\\t```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun pyramidTransition(bottom: String, allowed: List<String>): Boolean {\\n        if (bottom.isEmpty()) return false\\n        val aMap = mutableMapOf<String, MutableList<Char>>()\\n        for (triple in allowed){\\n            aMap.getOrPut(triple.slice(0..1),{mutableListOf()}).add(triple[2])\\n        }\\n        \\n        val checkedRows = mutableSetOf<String>()\\n        fun buildRow(bottom : String, i : Int, row : String) : Boolean {\\n            if (i == 0 && bottom in checkedRows) return false //skip this as it was checked\\n            if ( bottom.length == 1) return true\\n            if ( i >= bottom.lastIndex){\\n                checkedRows.add(bottom)\\n                return buildRow(row, 0, \"\")  \\n            } \\n            val base = bottom.slice(i..i+1)\\n            if (base !in aMap) return false\\n            for (c in aMap[base]!!){\\n                if (buildRow(bottom, i+1, row + c)) return true\\n            }\\n            return false\\n        }\\n        \\n        return buildRow(bottom, 0, \"\")\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1065093,
                "title": "c-backtracking-beats-100",
                "content": "\\n```\\npublic class Solution {\\n    \\n    bool found = false;\\n    \\n    HashSet<string> visited = new HashSet<string>();\\n    \\n    public Dictionary<string, List<string>> Map = \\n        new Dictionary<string, List<string>>();\\n    \\n    public bool PyramidTransition(\\n        string bottom, \\n        IList<string> allowed) {\\n        \\n        foreach(string s in allowed)\\n        {\\n            if (!Map.ContainsKey(s.Substring(0,2)))\\n            {\\n                Map[s.Substring(0,2)] = new List<string>();\\n            }\\n            \\n            Map[s.Substring(0,2)].Add(s.Substring(2, 1));\\n        }\\n        \\n        BackTrack(bottom, \\n            bottom.Length, \\n            new StringBuilder(), \\n            0);\\n        \\n        return found;\\n    }\\n    \\n    public void BackTrack(string currS, \\n                    int bottomLen, \\n                    StringBuilder newS,\\n                    int index)\\n    {\\n        if (found) return;\\n        \\n        if (newS.Length == bottomLen - 1)\\n        {\\n            if(visited.Contains(newS.ToString())) return;\\n            \\n            visited.Add(newS.ToString());\\n            \\n            if (newS.Length == 1)\\n            {\\n                found = true;\\n                return;\\n            }\\n                \\n            currS = newS.ToString();\\n            bottomLen = currS.Length;\\n            newS = new StringBuilder();\\n            index = 0;\\n        }\\n        \\n        if (index > currS.Length - 1) return;\\n        \\n        if (Map.ContainsKey(currS.Substring(index, 2)))\\n        {\\n            foreach(string suffix in Map[currS.Substring(index, 2)])\\n            {\\n                newS.Append(suffix);\\n                BackTrack(currS, bottomLen, newS, index + 1);\\n                newS.Remove(newS.Length - 1, 1);\\n            }   \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    bool found = false;\\n    \\n    HashSet<string> visited = new HashSet<string>();\\n    \\n    public Dictionary<string, List<string>> Map = \\n        new Dictionary<string, List<string>>();\\n    \\n    public bool PyramidTransition(\\n        string bottom, \\n        IList<string> allowed) {\\n        \\n        foreach(string s in allowed)\\n        {\\n            if (!Map.ContainsKey(s.Substring(0,2)))\\n            {\\n                Map[s.Substring(0,2)] = new List<string>();\\n            }\\n            \\n            Map[s.Substring(0,2)].Add(s.Substring(2, 1));\\n        }\\n        \\n        BackTrack(bottom, \\n            bottom.Length, \\n            new StringBuilder(), \\n            0);\\n        \\n        return found;\\n    }\\n    \\n    public void BackTrack(string currS, \\n                    int bottomLen, \\n                    StringBuilder newS,\\n                    int index)\\n    {\\n        if (found) return;\\n        \\n        if (newS.Length == bottomLen - 1)\\n        {\\n            if(visited.Contains(newS.ToString())) return;\\n            \\n            visited.Add(newS.ToString());\\n            \\n            if (newS.Length == 1)\\n            {\\n                found = true;\\n                return;\\n            }\\n                \\n            currS = newS.ToString();\\n            bottomLen = currS.Length;\\n            newS = new StringBuilder();\\n            index = 0;\\n        }\\n        \\n        if (index > currS.Length - 1) return;\\n        \\n        if (Map.ContainsKey(currS.Substring(index, 2)))\\n        {\\n            foreach(string suffix in Map[currS.Substring(index, 2)])\\n            {\\n                newS.Append(suffix);\\n                BackTrack(currS, bottomLen, newS, index + 1);\\n                newS.Remove(newS.Length - 1, 1);\\n            }   \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056629,
                "title": "recursion-memoization-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, vector<string>> mp, helper_memo;\\n    \\n    \\n    vector<string> helper (string s){\\n        \\n        if(s.size()==2){\\n            helper_memo[s]=mp[s];\\n            return mp[s];\\n        }\\n        \\n        string str=\"\";\\n        str+=s[0];\\n        str+=s[1];\\n        \\n        vector<string> front = mp[str];\\n        \\n         vector<string> vtr;\\n        if( helper_memo.find(s.substr(1))!=helper_memo.end())\\n            vtr =  helper_memo[s.substr(1)];\\n        else\\n            vtr = helper(s.substr(1));\\n\\n        \\n        if(front.size()==0 || vtr.size()==0){\\n            helper_memo[s]={};\\n            return {};\\n        }\\n        \\n        vector<string> ret;\\n        \\n        for(auto a : front){\\n            for(auto b : vtr){\\n                ret.push_back(a+b);\\n            }\\n        }\\n        helper_memo[s]=ret;\\n        return ret;\\n        \\n    }\\n    \\n    bool helper2(string s){\\n        if(s.size()==2){\\n            return mp[s].size();\\n        }\\n        \\n        vector<string> vtr;\\n        if( helper_memo.find(s)!=helper_memo.end())\\n            vtr =  helper_memo[s];\\n        else\\n            vtr = helper(s);\\n        \\n        if(vtr.size()==0)\\n            return false;\\n        \\n        bool res = false;\\n        for(auto x : vtr){\\n            res |= helper2(x);\\n            if(res) return res;\\n        }\\n        return res;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        for(auto s:allowed){\\n            mp[s.substr(0,2)].push_back(s.substr(2));\\n        }\\n        \\n        //helper function : returns-> all posssible allowed combinations on a level above   \\n        //helper2 function : there exists at least one solution or not\\n        \\n        return helper2(bottom);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, vector<string>> mp, helper_memo;\\n    \\n    \\n    vector<string> helper (string s){\\n        \\n        if(s.size()==2){\\n            helper_memo[s]=mp[s];\\n            return mp[s];\\n        }\\n        \\n        string str=\"\";\\n        str+=s[0];\\n        str+=s[1];\\n        \\n        vector<string> front = mp[str];\\n        \\n         vector<string> vtr;\\n        if( helper_memo.find(s.substr(1))!=helper_memo.end())\\n            vtr =  helper_memo[s.substr(1)];\\n        else\\n            vtr = helper(s.substr(1));\\n\\n        \\n        if(front.size()==0 || vtr.size()==0){\\n            helper_memo[s]={};\\n            return {};\\n        }\\n        \\n        vector<string> ret;\\n        \\n        for(auto a : front){\\n            for(auto b : vtr){\\n                ret.push_back(a+b);\\n            }\\n        }\\n        helper_memo[s]=ret;\\n        return ret;\\n        \\n    }\\n    \\n    bool helper2(string s){\\n        if(s.size()==2){\\n            return mp[s].size();\\n        }\\n        \\n        vector<string> vtr;\\n        if( helper_memo.find(s)!=helper_memo.end())\\n            vtr =  helper_memo[s];\\n        else\\n            vtr = helper(s);\\n        \\n        if(vtr.size()==0)\\n            return false;\\n        \\n        bool res = false;\\n        for(auto x : vtr){\\n            res |= helper2(x);\\n            if(res) return res;\\n        }\\n        return res;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        for(auto s:allowed){\\n            mp[s.substr(0,2)].push_back(s.substr(2));\\n        }\\n        \\n        //helper function : returns-> all posssible allowed combinations on a level above   \\n        //helper2 function : there exists at least one solution or not\\n        \\n        return helper2(bottom);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039296,
                "title": "python-solution-divide-and-conquer-algorithm",
                "content": "you can divide row into left and right substring, and then just process each of them.\\n```\\ndef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        helper = dict()\\n        for allow in allowed:\\n            val = helper.setdefault(allow[:2], set())\\n            val.add(allow[2])\\n        def fun(row, res):\\n            n = len(row)\\n            if n == 2:\\n                if row in helper:\\n                    res.update(helper[row])\\n            else:\\n                m = n // 2\\n                resL, resR = set(), set()\\n                fun(row[:m + 1], resL)\\n                if len(resL) == 0:\\n                    return\\n                if n % 2 == 1:\\n                    fun(row[m:], resR)\\n                else:\\n                    fun(row[m - 1:], resR)\\n                if len(resR) == 0:\\n                    return\\n                [res.update(helper[l + r]) for l in resL for r in resR if l + r in helper]\\n        res = set()\\n        fun(bottom, res)\\n        return len(res) != 0\\n```\\nhere the \\'fun\\' return all the possible letters in the top of sub pyramid",
                "solutionTags": [],
                "code": "```\\ndef pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        helper = dict()\\n        for allow in allowed:\\n            val = helper.setdefault(allow[:2], set())\\n            val.add(allow[2])\\n        def fun(row, res):\\n            n = len(row)\\n            if n == 2:\\n                if row in helper:\\n                    res.update(helper[row])\\n            else:\\n                m = n // 2\\n                resL, resR = set(), set()\\n                fun(row[:m + 1], resL)\\n                if len(resL) == 0:\\n                    return\\n                if n % 2 == 1:\\n                    fun(row[m:], resR)\\n                else:\\n                    fun(row[m - 1:], resR)\\n                if len(resR) == 0:\\n                    return\\n                [res.update(helper[l + r]) for l in resL for r in resR if l + r in helper]\\n        res = set()\\n        fun(bottom, res)\\n        return len(res) != 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1005712,
                "title": "with-deque",
                "content": "```\\nclass Solution {\\n    bool cal(deque<char> q,int times , vector<string>&allow)\\n    {\\n        if(q.size() == 1) return true;\\n\\n        if(times==0) {\\n            q.pop_front();\\n            return cal(q,q.size()-1,allow);\\n        }\\n        char a = q.front();\\n        q.pop_front();\\n        char b = q.front();\\n        for(auto s : allow)\\n        {\\n            if(s[0] == a && s[1] == b){\\n                q.push_back(s[2]);\\n                if(cal(q,times-1,allow)) return true;\\n                q.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        deque<char> q;\\n        for(char i : bottom) q.push_back(i);\\n        return cal(q,q.size()-1,allowed);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool cal(deque<char> q,int times , vector<string>&allow)\\n    {\\n        if(q.size() == 1) return true;\\n\\n        if(times==0) {\\n            q.pop_front();\\n            return cal(q,q.size()-1,allow);\\n        }\\n        char a = q.front();\\n        q.pop_front();\\n        char b = q.front();\\n        for(auto s : allow)\\n        {\\n            if(s[0] == a && s[1] == b){\\n                q.push_back(s[2]);\\n                if(cal(q,times-1,allow)) return true;\\n                q.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        deque<char> q;\\n        for(char i : bottom) q.push_back(i);\\n        return cal(q,q.size()-1,allowed);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986648,
                "title": "dfs-divide-to-subproblem-o-n-8",
                "content": "build upper level string from current level string, until upper len == 1.\\n\\nTime: O(n^8)\\n\\n```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        ba = defaultdict(list)\\n        for a in allowed:\\n            ba[a[:2]].append(a[2])\\n        ans = self.dfs(bottom, 0, \"\", ba)\\n        return ans\\n    \\n    def dfs(self, b, i, r, ba):\\n        n = len(b)\\n        if i == n-1:\\n            if len(r) == 1:\\n                return True\\n            return self.dfs(r, 0, \"\", ba)\\n        bt = b[i:i+2]\\n        if bt not in ba:\\n            return False\\n        for c in ba[bt]:\\n            if self.dfs(b, i+1, r+c, ba):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        ba = defaultdict(list)\\n        for a in allowed:\\n            ba[a[:2]].append(a[2])\\n        ans = self.dfs(bottom, 0, \"\", ba)\\n        return ans\\n    \\n    def dfs(self, b, i, r, ba):\\n        n = len(b)\\n        if i == n-1:\\n            if len(r) == 1:\\n                return True\\n            return self.dfs(r, 0, \"\", ba)\\n        bt = b[i:i+2]\\n        if bt not in ba:\\n            return False\\n        for c in ba[bt]:\\n            if self.dfs(b, i+1, r+c, ba):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982919,
                "title": "c-dfs-and-backtracing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool trans(string s, unordered_map<string, vector<char>>& m, int start, string t){\\n        if(s.length() == 1) return true;\\n        if(start == s.length()-1){\\n            return trans(t, m, 0, \"\");\\n        }\\n        string temp = s.substr(start, 2);\\n        if(!m.count(temp)) return false;\\n        for(int i=0; i<m[temp].size(); i++){\\n            t.push_back(m[temp][i]);\\n            if(trans(s, m, start+1, t)) \\n                return true;\\n            t.pop_back();\\n        }\\n        return false;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string, vector<char>> m;\\n        for(auto s : allowed){\\n            m[s.substr(0, 2)].push_back(s[2]);\\n        }\\n        return trans(bottom, m, 0, \"\");\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool trans(string s, unordered_map<string, vector<char>>& m, int start, string t){\\n        if(s.length() == 1) return true;\\n        if(start == s.length()-1){\\n            return trans(t, m, 0, \"\");\\n        }\\n        string temp = s.substr(start, 2);\\n        if(!m.count(temp)) return false;\\n        for(int i=0; i<m[temp].size(); i++){\\n            t.push_back(m[temp][i]);\\n            if(trans(s, m, start+1, t)) \\n                return true;\\n            t.pop_back();\\n        }\\n        return false;\\n    }\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        unordered_map<string, vector<char>> m;\\n        for(auto s : allowed){\\n            m[s.substr(0, 2)].push_back(s[2]);\\n        }\\n        return trans(bottom, m, 0, \"\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982102,
                "title": "bit-manipulation-and-backtracking-in-c-beats-95",
                "content": "class Solution {\\npublic:\\n\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        vector<vector<char>> v2d(255, vector<char>());\\n        for (auto& s : allowed)\\n        {\\n            v2d[getIndex(s[0], s[1])].push_back(s[2]);\\n        }\\n        \\n        return helper(bottom, \"\", 0, bottom.size(), v2d);\\n    }\\n    \\n    bool helper(string & bottom, string top, int index, int n, vector<vector<char>>& v2d)\\n    {\\n        if (bottom.size() == 1)\\n            return true;\\n        \\n        if (index == n - 1)\\n            return helper(top, \"\", 0, top.size(), v2d);\\n        \\n        auto& v = v2d[getIndex(bottom[index], bottom[index+1])];\\n        if (v.empty())\\n            return false;        \\n        \\n         for (auto ch : v)\\n         {\\n             if (helper(bottom, top+ch, index+1, n, v2d))\\n                 return true;\\n         }\\n        return false;\\n    }\\n    \\n    inline int getIndex(char p, char q)\\n    {\\n        return ((p-\\'A\\')<<4) + (q-\\'A\\');\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        vector<vector<char>> v2d(255, vector<char>());\\n        for (auto& s : allowed)\\n        {\\n            v2d[getIndex(s[0], s[1])].push_back(s[2]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 962022,
                "title": "go-brute",
                "content": "```\\nfunc pyramidTransition(bottom string, allowed []string) bool {\\n    dict := make(map[string][]string)\\n    for _, v := range allowed {\\n        dict[v[:2]] = append(dict[v[:2]], string(v[2]))\\n    }\\n    return dfs(bottom, dict)\\n}\\n\\nfunc dfs(bottom string, dict map[string][]string) bool {\\n    if len(bottom) == 1 {\\n        return true\\n    }\\n    for _, s := range combination(bottom, dict) {\\n        if dfs(s, dict) {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc combination(bottom string, dict map[string][]string) []string { \\n    s1 := bottom[:2]\\n    s2 := bottom[1:]\\n    \\n    head := dict[s1]\\n    if head == nil {\\n        return nil\\n    }\\n    if len(s2) == 1 {\\n        return head\\n    }\\n    tail := combination(s2, dict)\\n    if tail == nil {\\n        return nil\\n    }\\n    \\n    res := []string{}\\n    for i := 0; i < len(head); i++ {\\n        for j := 0; j < len(tail); j++ {\\n            res = append(res, head[i] + tail[j])\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc pyramidTransition(bottom string, allowed []string) bool {\\n    dict := make(map[string][]string)\\n    for _, v := range allowed {\\n        dict[v[:2]] = append(dict[v[:2]], string(v[2]))\\n    }\\n    return dfs(bottom, dict)\\n}\\n\\nfunc dfs(bottom string, dict map[string][]string) bool {\\n    if len(bottom) == 1 {\\n        return true\\n    }\\n    for _, s := range combination(bottom, dict) {\\n        if dfs(s, dict) {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc combination(bottom string, dict map[string][]string) []string { \\n    s1 := bottom[:2]\\n    s2 := bottom[1:]\\n    \\n    head := dict[s1]\\n    if head == nil {\\n        return nil\\n    }\\n    if len(s2) == 1 {\\n        return head\\n    }\\n    tail := combination(s2, dict)\\n    if tail == nil {\\n        return nil\\n    }\\n    \\n    res := []string{}\\n    for i := 0; i < len(head); i++ {\\n        for j := 0; j < len(tail); j++ {\\n            res = append(res, head[i] + tail[j])\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 948344,
                "title": "java-map-backtracking-dfs",
                "content": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<Character>> validTriangles = new HashMap<>();\\n        for (String str : allowed) {\\n            validTriangles.computeIfAbsent(str.substring(0, 2), l -> new ArrayList<>()).add(str.charAt(2));\\n        }\\n        return helper(bottom, validTriangles);\\n    }\\n    \\n    private boolean helper(String bottom, Map<String, List<Character>> validTriangles) {\\n        if (bottom.length() == 1) {\\n            return true;\\n        }\\n        int n = bottom.length();\\n        List<String> comb = new ArrayList<>();\\n        List<List<Character>> possible = new ArrayList<>();\\n        for (int i = 0; i < n - 1; i++) {\\n            if (!validTriangles.containsKey(bottom.charAt(i) + \"\" + bottom.charAt(i + 1))) {\\n                return false;\\n            }\\n            possible.add(validTriangles.get(bottom.charAt(i) + \"\" + bottom.charAt(i + 1)));\\n        }\\n        dfs(possible, 0, \"\", comb);\\n        for (String next : comb) {\\n            if (helper(next, validTriangles)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void dfs(List<List<Character>> possible, int index, String cur, List<String> comb) {\\n        if (index == possible.size()) {\\n            comb.add(cur);\\n            return;\\n        }\\n        for (char ch : possible.get(index)) {\\n            dfs(possible, index + 1, cur + ch, comb);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\\n        Map<String, List<Character>> validTriangles = new HashMap<>();\\n        for (String str : allowed) {\\n            validTriangles.computeIfAbsent(str.substring(0, 2), l -> new ArrayList<>()).add(str.charAt(2));\\n        }\\n        return helper(bottom, validTriangles);\\n    }\\n    \\n    private boolean helper(String bottom, Map<String, List<Character>> validTriangles) {\\n        if (bottom.length() == 1) {\\n            return true;\\n        }\\n        int n = bottom.length();\\n        List<String> comb = new ArrayList<>();\\n        List<List<Character>> possible = new ArrayList<>();\\n        for (int i = 0; i < n - 1; i++) {\\n            if (!validTriangles.containsKey(bottom.charAt(i) + \"\" + bottom.charAt(i + 1))) {\\n                return false;\\n            }\\n            possible.add(validTriangles.get(bottom.charAt(i) + \"\" + bottom.charAt(i + 1)));\\n        }\\n        dfs(possible, 0, \"\", comb);\\n        for (String next : comb) {\\n            if (helper(next, validTriangles)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void dfs(List<List<Character>> possible, int index, String cur, List<String> comb) {\\n        if (index == possible.size()) {\\n            comb.add(cur);\\n            return;\\n        }\\n        for (char ch : possible.get(index)) {\\n            dfs(possible, index + 1, cur + ch, comb);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939885,
                "title": "python-8-lines-dfs",
                "content": "```\\n    def pyramidTransition(self, bottom, allowed):\\n        allow_map = defaultdict(list)\\n        for s in allowed: allow_map[s[0]+s[1]].append(s[2])\\n        \\n        def dfs(layer):\\n            if len(layer) == 2 and layer in allow_map: return True\\n            for l, r in zip(layer, layer[1:]):\\n                if l + r not in allow_map: return False\\n\\n            return any(dfs(next_layer) for next_layer in list(map(lambda cand: \"\".join(cand), itertools.product(*[allow_map[l + r] for l, r in zip(layer, layer[1:])]))))\\n            \\n        return dfs(bottom)\\n```",
                "solutionTags": [],
                "code": "```\\n    def pyramidTransition(self, bottom, allowed):\\n        allow_map = defaultdict(list)\\n        for s in allowed: allow_map[s[0]+s[1]].append(s[2])\\n        \\n        def dfs(layer):\\n            if len(layer) == 2 and layer in allow_map: return True\\n            for l, r in zip(layer, layer[1:]):\\n                if l + r not in allow_map: return False\\n\\n            return any(dfs(next_layer) for next_layer in list(map(lambda cand: \"\".join(cand), itertools.product(*[allow_map[l + r] for l, r in zip(layer, layer[1:])]))))\\n            \\n        return dfs(bottom)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935777,
                "title": "python-simulation",
                "content": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        \\n        def helper(layer):\\n            if len(layer) == 1:\\n                return True\\n            return any(helper(next_layer) for next_layer in builder(layer, 0))\\n\\n        def builder(l, index):\\n            if index == len(l) - 2:\\n                return [c[2] for c in allowed if l[index:index + 2] == c[:2]]\\n            comb = builder(l, index + 1)\\n            if not comb:\\n                return []\\n            else:\\n                new_comb = []\\n                cans = [c[2] for c in allowed if l[index:index + 2] == c[:2]]\\n                for c in cans:\\n                    for com in comb:\\n                        new_comb.append(c + com)\\n                return new_comb\\n\\n        return helper(bottom)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\\n        \\n        def helper(layer):\\n            if len(layer) == 1:\\n                return True\\n            return any(helper(next_layer) for next_layer in builder(layer, 0))\\n\\n        def builder(l, index):\\n            if index == len(l) - 2:\\n                return [c[2] for c in allowed if l[index:index + 2] == c[:2]]\\n            comb = builder(l, index + 1)\\n            if not comb:\\n                return []\\n            else:\\n                new_comb = []\\n                cans = [c[2] for c in allowed if l[index:index + 2] == c[:2]]\\n                for c in cans:\\n                    for com in comb:\\n                        new_comb.append(c + com)\\n                return new_comb\\n\\n        return helper(bottom)\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 930298,
                "title": "java-backtracking-with-map",
                "content": "```\\nclass Solution {\\n  String s = \"ABCDEFG\";\\n  HashSet<String> visited = new HashSet<>();\\n  Set<String> set = new HashSet<>();\\n\\n  public boolean pyramidTransition(String str, List<String> allowed) {\\n    if (str.length() == 1) {\\n      return true;\\n    }\\n    if (set.isEmpty()) {\\n      set = new HashSet<>(allowed);\\n    }\\n    boolean found = false;\\n    for (String next : getNext(str, set)) {\\n      if (!visited.contains(next)) {\\n        found = found || pyramidTransition(next, allowed);\\n      }\\n    }\\n    return found;\\n  }\\n\\n  private Set<String> getNext(String curr, Set<String> allowed) {\\n    HashMap<Integer, List<Character>> map = new HashMap<>();\\n    for (int i = 1; i < curr.length(); i++) {\\n      for (int j = 0; j < s.length(); j++) {\\n        String str = curr.charAt(i - 1) + \"\" + curr.charAt(i) + s.charAt(j);\\n        if (allowed.contains(str)) {\\n          List<Character> list = map.getOrDefault(i - 1, new ArrayList<>());\\n          list.add(s.charAt(j));\\n          map.put(i - 1, list);\\n        }\\n      }\\n    }\\n    HashSet<String> next = new HashSet<>();\\n    getNext(map, 0, new StringBuffer(), curr.length() - 1, next);\\n    return next;\\n  }\\n\\n  private void getNext(HashMap<Integer, List<Character>> map, int curr, StringBuffer stringBuffer,\\n      int max, Set<String> next) {\\n    if (curr == max) {\\n      next.add(stringBuffer.toString());\\n      return;\\n    }\\n    List<Character> list = map.get(curr);\\n    if (list != null) {\\n      for (int i = 0; i < list.size(); i++) {\\n        stringBuffer.append(list.get(i));\\n        getNext(map, curr + 1, stringBuffer, max, next);\\n        stringBuffer.deleteCharAt(stringBuffer.length() - 1);\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  String s = \"ABCDEFG\";\\n  HashSet<String> visited = new HashSet<>();\\n  Set<String> set = new HashSet<>();\\n\\n  public boolean pyramidTransition(String str, List<String> allowed) {\\n    if (str.length() == 1) {\\n      return true;\\n    }\\n    if (set.isEmpty()) {\\n      set = new HashSet<>(allowed);\\n    }\\n    boolean found = false;\\n    for (String next : getNext(str, set)) {\\n      if (!visited.contains(next)) {\\n        found = found || pyramidTransition(next, allowed);\\n      }\\n    }\\n    return found;\\n  }\\n\\n  private Set<String> getNext(String curr, Set<String> allowed) {\\n    HashMap<Integer, List<Character>> map = new HashMap<>();\\n    for (int i = 1; i < curr.length(); i++) {\\n      for (int j = 0; j < s.length(); j++) {\\n        String str = curr.charAt(i - 1) + \"\" + curr.charAt(i) + s.charAt(j);\\n        if (allowed.contains(str)) {\\n          List<Character> list = map.getOrDefault(i - 1, new ArrayList<>());\\n          list.add(s.charAt(j));\\n          map.put(i - 1, list);\\n        }\\n      }\\n    }\\n    HashSet<String> next = new HashSet<>();\\n    getNext(map, 0, new StringBuffer(), curr.length() - 1, next);\\n    return next;\\n  }\\n\\n  private void getNext(HashMap<Integer, List<Character>> map, int curr, StringBuffer stringBuffer,\\n      int max, Set<String> next) {\\n    if (curr == max) {\\n      next.add(stringBuffer.toString());\\n      return;\\n    }\\n    List<Character> list = map.get(curr);\\n    if (list != null) {\\n      for (int i = 0; i < list.size(); i++) {\\n        stringBuffer.append(list.get(i));\\n        getNext(map, curr + 1, stringBuffer, max, next);\\n        stringBuffer.deleteCharAt(stringBuffer.length() - 1);\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929478,
                "title": "swift-backtracking-solution",
                "content": "```\\nclass Solution756 {\\n\\n    // left right root\\n    func pyramidTransition(_ bottom: String, _ allowed: [String]) -> Bool {\\n        var map = [String: [String]]()\\n        for str in allowed {\\n            let startIndex = str.startIndex\\n            let endIndex = str.index(startIndex, offsetBy: 2)\\n            let key = String(str[startIndex..<endIndex])\\n\\n            let value = String(str[endIndex..<str.endIndex])\\n\\n            map[key, default: [String]()].append(value)\\n        }\\n\\n        return backtracking(bottom, map)\\n    }\\n\\n    private func backtracking(_ bottom: String, _ map: [String: [String]]) -> Bool {\\n        if bottom.count == 1 {\\n            return true\\n        }\\n\\n        var temp = [[String]]()\\n\\n        for i in 0..<bottom.count - 1 {\\n            let startIndex = bottom.index(bottom.startIndex, offsetBy: i)\\n            let endIndex = bottom.index(bottom.startIndex, offsetBy: i + 1)\\n\\n            let key = String(bottom[startIndex...endIndex])\\n            guard let value = map[key] else { return false }\\n\\n            temp.append(value)\\n        }\\n\\n        let nextWords = getCandidates(temp)\\n        for word in nextWords {\\n            if backtracking(word, map) { return true }\\n        }\\n        return false\\n    }\\n\\n    private func getCandidates(_ strs: [[String]]) -> [String] {\\n        var ans = strs[0]\\n        for i in 1..<strs.count {\\n            let subArray = strs[i]\\n\\n            var next = [String]()\\n            for txt in subArray {\\n                for s in ans {\\n                    next.append(s + txt)\\n                }\\n            }\\n            ans = next\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution756 {\\n\\n    // left right root\\n    func pyramidTransition(_ bottom: String, _ allowed: [String]) -> Bool {\\n        var map = [String: [String]]()\\n        for str in allowed {\\n            let startIndex = str.startIndex\\n            let endIndex = str.index(startIndex, offsetBy: 2)\\n            let key = String(str[startIndex..<endIndex])\\n\\n            let value = String(str[endIndex..<str.endIndex])\\n\\n            map[key, default: [String]()].append(value)\\n        }\\n\\n        return backtracking(bottom, map)\\n    }\\n\\n    private func backtracking(_ bottom: String, _ map: [String: [String]]) -> Bool {\\n        if bottom.count == 1 {\\n            return true\\n        }\\n\\n        var temp = [[String]]()\\n\\n        for i in 0..<bottom.count - 1 {\\n            let startIndex = bottom.index(bottom.startIndex, offsetBy: i)\\n            let endIndex = bottom.index(bottom.startIndex, offsetBy: i + 1)\\n\\n            let key = String(bottom[startIndex...endIndex])\\n            guard let value = map[key] else { return false }\\n\\n            temp.append(value)\\n        }\\n\\n        let nextWords = getCandidates(temp)\\n        for word in nextWords {\\n            if backtracking(word, map) { return true }\\n        }\\n        return false\\n    }\\n\\n    private func getCandidates(_ strs: [[String]]) -> [String] {\\n        var ans = strs[0]\\n        for i in 1..<strs.count {\\n            let subArray = strs[i]\\n\\n            var next = [String]()\\n            for txt in subArray {\\n                for s in ans {\\n                    next.append(s + txt)\\n                }\\n            }\\n            ans = next\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914296,
                "title": "c-backtrack-solution",
                "content": "Runtime: 4 ms, faster than 97.81% of C++ online submissions for Pyramid Transition Matrix.\\nMemory Usage: 8.9 MB, less than 6.20% of C++ online submissions for Pyramid Transition Matrix.\\n\\nWe create pyramids till we reach to the top, if we can not reach to the top then backtrack and try different triples.\\nAs soon as we reach to the pyramid top return true.\\nIf no possible combination found to reach to the top then return false.\\n\\nTime Complexity: Exponential\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // check all possible combiantion to reach to the pyramid top \\n    bool dfs(string bottom, int index, string nbottom, vector<vector<vector<bool>>>&track)\\n    {\\n        // pyramid top reached as bottom has 1 element and nbottom is empty, so return true\\n        if(bottom.length()==1 && nbottom.empty()) return true;\\n        \\n        // bottom processed but len(nbottom) ! = len(bottom)-1, so not valid and return false\\n        if(index==bottom.length() && nbottom.length()!=index-1)\\n            return false;\\n        \\n        // bottom processed and nbottom valid so call new DFS with nbottom as bottom\\n        if(index==bottom.length() && nbottom.length()==index-1)\\n            return dfs(nbottom,1,\"\",track);\\n        \\n        // check if triple <bottom[index-1],bottom[index],c> is allowed, then call DFS\\n        // If no DFS call reach to the top then return false\\n        for(int c=0;c<7 && index < bottom.length();c++)\\n        {\\n            char x = c + \\'A\\';     \\n\\n            if(track[bottom[index-1]-\\'A\\'][bottom[index]-\\'A\\'][c])\\n            {\\n                if(dfs(bottom,index+1,nbottom+x,track)) return true;\\n            }\\n        }            \\n        \\n        // no possible combination to reach top\\n        return false;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n\\n        // 3D vector to track allowed triples\\n        vector<vector<vector<bool>>>track(7,vector<vector<bool>>(7,vector<bool>(7,false)));\\n\\n        // populate allowed triples in track vector\\n        for(int i=0;i<allowed.size();i++)\\n            track[allowed[i][0]-\\'A\\'][allowed[i][1]-\\'A\\'][allowed[i][2]-\\'A\\'] = true;\\n        \\n        // call DFS from the start\\n        return dfs(bottom,1,\"\",track);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // check all possible combiantion to reach to the pyramid top \\n    bool dfs(string bottom, int index, string nbottom, vector<vector<vector<bool>>>&track)\\n    {\\n        // pyramid top reached as bottom has 1 element and nbottom is empty, so return true\\n        if(bottom.length()==1 && nbottom.empty()) return true;\\n        \\n        // bottom processed but len(nbottom) ! = len(bottom)-1, so not valid and return false\\n        if(index==bottom.length() && nbottom.length()!=index-1)\\n            return false;\\n        \\n        // bottom processed and nbottom valid so call new DFS with nbottom as bottom\\n        if(index==bottom.length() && nbottom.length()==index-1)\\n            return dfs(nbottom,1,\"\",track);\\n        \\n        // check if triple <bottom[index-1],bottom[index],c> is allowed, then call DFS\\n        // If no DFS call reach to the top then return false\\n        for(int c=0;c<7 && index < bottom.length();c++)\\n        {\\n            char x = c + \\'A\\';     \\n\\n            if(track[bottom[index-1]-\\'A\\'][bottom[index]-\\'A\\'][c])\\n            {\\n                if(dfs(bottom,index+1,nbottom+x,track)) return true;\\n            }\\n        }            \\n        \\n        // no possible combination to reach top\\n        return false;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n\\n        // 3D vector to track allowed triples\\n        vector<vector<vector<bool>>>track(7,vector<vector<bool>>(7,vector<bool>(7,false)));\\n\\n        // populate allowed triples in track vector\\n        for(int i=0;i<allowed.size();i++)\\n            track[allowed[i][0]-\\'A\\'][allowed[i][1]-\\'A\\'][allowed[i][2]-\\'A\\'] = true;\\n        \\n        // call DFS from the start\\n        return dfs(bottom,1,\"\",track);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881975,
                "title": "c-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, vector<char>> mp;\\n    \\n    bool helper(int level, int idx, string &temp, string &bottom){\\n        if(level == 1 && idx == 1) return true;\\n        \\n        if(level == idx){ \\n            string p = \"\";\\n            return helper(level-1, 0, p, temp);\\n        }\\n        \\n        string s = bottom.substr(idx, 2);\\n        \\n        if(mp.count(s) == 0) return false;\\n        \\n        for(int i=0;i<mp[s].size();i++){\\n            temp.push_back(mp[s][i]);\\n            if(helper(level, idx+1, temp, bottom)) return true;\\n            temp.pop_back();\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        mp.clear();\\n        \\n        for(string s:allowed){\\n            mp[s.substr(0,2)].push_back(s[2]);\\n        }\\n        \\n        string temp = \"\";\\n        \\n        return helper(bottom.size()-1, 0, temp, bottom);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, vector<char>> mp;\\n    \\n    bool helper(int level, int idx, string &temp, string &bottom){\\n        if(level == 1 && idx == 1) return true;\\n        \\n        if(level == idx){ \\n            string p = \"\";\\n            return helper(level-1, 0, p, temp);\\n        }\\n        \\n        string s = bottom.substr(idx, 2);\\n        \\n        if(mp.count(s) == 0) return false;\\n        \\n        for(int i=0;i<mp[s].size();i++){\\n            temp.push_back(mp[s][i]);\\n            if(helper(level, idx+1, temp, bottom)) return true;\\n            temp.pop_back();\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        mp.clear();\\n        \\n        for(string s:allowed){\\n            mp[s.substr(0,2)].push_back(s[2]);\\n        }\\n        \\n        string temp = \"\";\\n        \\n        return helper(bottom.size()-1, 0, temp, bottom);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874509,
                "title": "c-octal-encoding-solution-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        vector<vector<int>> trans(64, vector<int>());\\n        auto num = [&](char& c) {\\n            return int(c) - int(\\'A\\') + 1;\\n        };\\n        for (auto &triple : allowed) trans[num(triple[0]) * 8 + num(triple[1])].push_back(num(triple[2]));\\n        auto convert = [&](string& s) {\\n            int ans = 0;\\n            for (auto &c : s) ans = 8 * ans + num(c);\\n            return ans;\\n        };\\n        function<bool(int, int, int)> dfs = [&](int curr, int next, int offset) {\\n            if (0 < curr && curr <= 7 && !next) return true;\\n            while (curr > 7) {\\n                for (auto n : trans[curr % 64]) {\\n                    if (dfs(curr / 8, next + (n << (3 * offset)), offset + 1)) return true;\\n                }\\n                return false;\\n            }\\n            return dfs(next, 0, 0);\\n        };\\n        return dfs(convert(bottom), 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\\n        vector<vector<int>> trans(64, vector<int>());\\n        auto num = [&](char& c) {\\n            return int(c) - int(\\'A\\') + 1;\\n        };\\n        for (auto &triple : allowed) trans[num(triple[0]) * 8 + num(triple[1])].push_back(num(triple[2]));\\n        auto convert = [&](string& s) {\\n            int ans = 0;\\n            for (auto &c : s) ans = 8 * ans + num(c);\\n            return ans;\\n        };\\n        function<bool(int, int, int)> dfs = [&](int curr, int next, int offset) {\\n            if (0 < curr && curr <= 7 && !next) return true;\\n            while (curr > 7) {\\n                for (auto n : trans[curr % 64]) {\\n                    if (dfs(curr / 8, next + (n << (3 * offset)), offset + 1)) return true;\\n                }\\n                return false;\\n            }\\n            return dfs(next, 0, 0);\\n        };\\n        return dfs(convert(bottom), 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860777,
                "title": "python-solution-easy-backtracking",
                "content": "```\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        dic = {}\\n        for i in allowed:\\n            if i[:2] not in dic:\\n                dic[i[:2]] = [i[2]]\\n            else:\\n                dic[i[:2]].append(i[2])\\n        def backtrack(strg, res):\\n            if len(strg) == 1 and len(res) == 1:\\n                return True\\n            if len(strg) == 1 and len(res) > 1:\\n                strg = res\\n                res = \\'\\'\\n            if strg[0] + strg[1] in dic:\\n                for i in dic[strg[0] + strg[1]]:\\n                    out = backtrack(strg[1:], res + i)\\n                    if out == True:\\n                        return True\\n            return False\\n        return backtrack(bottom, \\'\\')\\n```",
                "solutionTags": [],
                "code": "```\\n    def pyramidTransition(self, bottom, allowed):\\n        \"\"\"\\n        :type bottom: str\\n        :type allowed: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        dic = {}\\n        for i in allowed:\\n            if i[:2] not in dic:\\n                dic[i[:2]] = [i[2]]\\n            else:\\n                dic[i[:2]].append(i[2])\\n        def backtrack(strg, res):\\n            if len(strg) == 1 and len(res) == 1:\\n                return True\\n            if len(strg) == 1 and len(res) > 1:\\n                strg = res\\n                res = \\'\\'\\n            if strg[0] + strg[1] in dic:\\n                for i in dic[strg[0] + strg[1]]:\\n                    out = backtrack(strg[1:], res + i)\\n                    if out == True:\\n                        return True\\n            return False\\n        return backtrack(bottom, \\'\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 856735,
                "title": "100ms-c-faster-than-100-of-c-solution-using-recursion-with-memo",
                "content": "````\\npublic class Solution {\\n    Dictionary<string, List<char>> map = null;\\n    \\n    Dictionary<string, bool> memo = new Dictionary<string, bool>();\\n    \\n    \\n    public bool PyramidTransition(string bottom, IList<string> allowed) {\\n        \\n         map = new Dictionary<string, List<char>>();\\n        \\n        foreach (string s in allowed)\\n        {\\n            var key = s.Substring(0, 2);\\n            var val = s[2];\\n            \\n            if (!map.TryGetValue(key, out List<char> list))\\n            {\\n                list = new List<char>();\\n                map[key] = list;\\n            }\\n            \\n            list.Add(val);\\n        }\\n        \\n        \\n        return Util(bottom);\\n        \\n    }\\n    \\n    bool Util(string bottom)\\n    {\\n        if (bottom.Length == 1)\\n        {\\n            return true;\\n        }\\n        \\n        if (memo.TryGetValue(bottom, out bool ret))\\n        {\\n            return ret;\\n        }       \\n        \\n        List<string> nextBottoms = null;\\n        \\n        if (!GenNextLevel(bottom, 0, out nextBottoms))\\n        {\\n            memo[bottom] = false;\\n            return false;\\n        }\\n        \\n        foreach (string b in nextBottoms)\\n        {\\n            if (Util(b))            \\n            {\\n                memo[bottom] = true;\\n                return true;\\n            }\\n        }\\n        \\n        memo[bottom] = false;\\n                return false;\\n    }\\n    \\n    bool GenNextLevel(string bottom, int start, out List<string> ans)\\n    {\\n        ans = new List<string>();\\n        if (start == bottom.Length - 1)\\n        {\\n            ans.Add(\"\");\\n            return true;\\n        }\\n        \\n        var key = bottom.Substring(start, 2);\\n        \\n        if (!map.TryGetValue(key, out List<char> chars))\\n        {\\n            return false;\\n        }\\n        \\n        if(!GenNextLevel(bottom, start + 1, out List<string> ret))\\n        {\\n            return false;\\n        }\\n        \\n        foreach (char c in chars)\\n        {\\n            foreach (string s in ret)\\n            {\\n                ans.Add(c+s);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "````\\npublic class Solution {\\n    Dictionary<string, List<char>> map = null;\\n    \\n    Dictionary<string, bool> memo = new Dictionary<string, bool>();\\n    \\n    \\n    public bool PyramidTransition(string bottom, IList<string> allowed) {\\n        \\n         map = new Dictionary<string, List<char>>();\\n        \\n        foreach (string s in allowed)\\n        {\\n            var key = s.Substring(0, 2);\\n            var val = s[2];\\n            \\n            if (!map.TryGetValue(key, out List<char> list))\\n            {\\n                list = new List<char>();\\n                map[key] = list;\\n            }\\n            \\n            list.Add(val);\\n        }\\n        \\n        \\n        return Util(bottom);\\n        \\n    }\\n    \\n    bool Util(string bottom)\\n    {\\n        if (bottom.Length == 1)\\n        {\\n            return true;\\n        }\\n        \\n        if (memo.TryGetValue(bottom, out bool ret))\\n        {\\n            return ret;\\n        }       \\n        \\n        List<string> nextBottoms = null;\\n        \\n        if (!GenNextLevel(bottom, 0, out nextBottoms))\\n        {\\n            memo[bottom] = false;\\n            return false;\\n        }\\n        \\n        foreach (string b in nextBottoms)\\n        {\\n            if (Util(b))            \\n            {\\n                memo[bottom] = true;\\n                return true;\\n            }\\n        }\\n        \\n        memo[bottom] = false;\\n                return false;\\n    }\\n    \\n    bool GenNextLevel(string bottom, int start, out List<string> ans)\\n    {\\n        ans = new List<string>();\\n        if (start == bottom.Length - 1)\\n        {\\n            ans.Add(\"\");\\n            return true;\\n        }\\n        \\n        var key = bottom.Substring(start, 2);\\n        \\n        if (!map.TryGetValue(key, out List<char> chars))\\n        {\\n            return false;\\n        }\\n        \\n        if(!GenNextLevel(bottom, start + 1, out List<string> ret))\\n        {\\n            return false;\\n        }\\n        \\n        foreach (char c in chars)\\n        {\\n            foreach (string s in ret)\\n            {\\n                ans.Add(c+s);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564975,
                "content": [
                    {
                        "username": "freshnewegg",
                        "content": "you\\'re probably gonna read this 1 like 5 times. I\\'m skipping this one"
                    },
                    {
                        "username": "figurative",
                        "content": "For the following example:\\n\"ABCD\"\\n[\"BCE\",\"BCF\",\"ABA\",\"CDA\",\"AEG\",\"FAG\",\"GGG\"]\\nShould we output false (if I am interpreting the problem correctly)?\\nBut the standard code outputs true. Could anyone explain this?"
                    },
                    {
                        "username": "wisdompeak",
                        "content": "Please refer to the discussion here https://leetcode.com/articles/pyramid-transition-matrix/\\nI can easily find a few submitted solutions are DP-based, which must fail on this test case. \\n\"AAAA\"\\n[\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\\nThe correct answer should be \"false\".\\nUnfortunately, the 1st, 2nd and 3rd winners in this contest are ALL WRONG for this problem."
                    },
                    {
                        "username": "thekensai",
                        "content": "For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`. \\n\\n.........wtf is this supposed to mean"
                    },
                    {
                        "username": "awice",
                        "content": "**Background**\\n\\nI care about Leetcode Contest quite a lot, and I understand it is frustrating for competitors to be unfairly penalized due to errors in the contest, as it has happened to me before.\\n\\nIn the previous contest, the judge and tester solution to \"Pyramid Transition Matrix\" incorrectly assumed that state transitions were all independent, which is false.  As such, the limits presented for the question were harder than they should be, and did not include \"Non-independent States\" (NIS) test cases, which caused frustration to competitors in the contest.  I regret the error.\\n\\n**Issues Raised**\\n\\n> Solutions which recieved AC on the contest that do not pass NIS test cases should be rejudged false.\\n\\nThe precedent is that for contests that are not unrated, for solutions that receive AC to keep that AC.  This is based on the principle that it would be unfair for a competitor getting AC to then be judged WA with no opportunity to correct the solution - ie. an AC is always an AC.\\n\\n> People that coded a correct solution (under the new limits) got TLE.\\n\\nWe rejudged every submission that received TLE, to give AC to any correct solution under the new test cases (eg. DFS approaches).\\n\\n> People that would have coded a correct solution but did not code/submit one because of the limits presented.\\n\\nIt is unfortunate for any competitor that would have passed if the problem was presented better, but we have no ability to correct this error without invalidating the contest entirely.  The decision based on the level, severity, and estimated impact of the error was that the contest would stand and we would instead try to mitigate the damage as much as possible.\\n\\n**Steps Taken**\\n\\nThe problem was edited to change the limits to len(bottom) <= 8, and NIS test cases were added.  The article was edited to reflect the new solution possible.  All TLE solutions have been rejudged and results will appear shortly.  All previously-AC solutions will stand (as usual, and even if they would now be WA.)\\n\\n---\\n@yaoxiang3.1g  @guan.huifeng @mail.kuuy  @chrislzm @devilhtc @flowmemo @dbelange @pedro @wjli"
                    },
                    {
                        "username": "Iamyxx",
                        "content": "\"ABCD\"\\n[\"ABE\",\"BCE\",\"BCF\",\"CDF\",\"EEG\",\"FFA\",\"GAA\"]\\n\\n EEF\\nABCD\\n\\nor \\n\\n EFF\\nABCD\\n\\ncan't not continue to go up any more"
                    },
                    {
                        "username": "anurag852001",
                        "content": "IF U FIND ANY BIT MANIPULATION APPROACH POST IT."
                    },
                    {
                        "username": "usernameharsh",
                        "content": "theek bhai"
                    },
                    {
                        "username": "R4Ks",
                        "content": "Omg i hate this"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "7 months ago, I tried this for the first time had no idea, how to move forward, Today I was able to do so :)"
                    }
                ]
            },
            {
                "id": 1565484,
                "content": [
                    {
                        "username": "freshnewegg",
                        "content": "you\\'re probably gonna read this 1 like 5 times. I\\'m skipping this one"
                    },
                    {
                        "username": "figurative",
                        "content": "For the following example:\\n\"ABCD\"\\n[\"BCE\",\"BCF\",\"ABA\",\"CDA\",\"AEG\",\"FAG\",\"GGG\"]\\nShould we output false (if I am interpreting the problem correctly)?\\nBut the standard code outputs true. Could anyone explain this?"
                    },
                    {
                        "username": "wisdompeak",
                        "content": "Please refer to the discussion here https://leetcode.com/articles/pyramid-transition-matrix/\\nI can easily find a few submitted solutions are DP-based, which must fail on this test case. \\n\"AAAA\"\\n[\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\\nThe correct answer should be \"false\".\\nUnfortunately, the 1st, 2nd and 3rd winners in this contest are ALL WRONG for this problem."
                    },
                    {
                        "username": "thekensai",
                        "content": "For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`. \\n\\n.........wtf is this supposed to mean"
                    },
                    {
                        "username": "awice",
                        "content": "**Background**\\n\\nI care about Leetcode Contest quite a lot, and I understand it is frustrating for competitors to be unfairly penalized due to errors in the contest, as it has happened to me before.\\n\\nIn the previous contest, the judge and tester solution to \"Pyramid Transition Matrix\" incorrectly assumed that state transitions were all independent, which is false.  As such, the limits presented for the question were harder than they should be, and did not include \"Non-independent States\" (NIS) test cases, which caused frustration to competitors in the contest.  I regret the error.\\n\\n**Issues Raised**\\n\\n> Solutions which recieved AC on the contest that do not pass NIS test cases should be rejudged false.\\n\\nThe precedent is that for contests that are not unrated, for solutions that receive AC to keep that AC.  This is based on the principle that it would be unfair for a competitor getting AC to then be judged WA with no opportunity to correct the solution - ie. an AC is always an AC.\\n\\n> People that coded a correct solution (under the new limits) got TLE.\\n\\nWe rejudged every submission that received TLE, to give AC to any correct solution under the new test cases (eg. DFS approaches).\\n\\n> People that would have coded a correct solution but did not code/submit one because of the limits presented.\\n\\nIt is unfortunate for any competitor that would have passed if the problem was presented better, but we have no ability to correct this error without invalidating the contest entirely.  The decision based on the level, severity, and estimated impact of the error was that the contest would stand and we would instead try to mitigate the damage as much as possible.\\n\\n**Steps Taken**\\n\\nThe problem was edited to change the limits to len(bottom) <= 8, and NIS test cases were added.  The article was edited to reflect the new solution possible.  All TLE solutions have been rejudged and results will appear shortly.  All previously-AC solutions will stand (as usual, and even if they would now be WA.)\\n\\n---\\n@yaoxiang3.1g  @guan.huifeng @mail.kuuy  @chrislzm @devilhtc @flowmemo @dbelange @pedro @wjli"
                    },
                    {
                        "username": "Iamyxx",
                        "content": "\"ABCD\"\\n[\"ABE\",\"BCE\",\"BCF\",\"CDF\",\"EEG\",\"FFA\",\"GAA\"]\\n\\n EEF\\nABCD\\n\\nor \\n\\n EFF\\nABCD\\n\\ncan't not continue to go up any more"
                    },
                    {
                        "username": "anurag852001",
                        "content": "IF U FIND ANY BIT MANIPULATION APPROACH POST IT."
                    },
                    {
                        "username": "usernameharsh",
                        "content": "theek bhai"
                    },
                    {
                        "username": "R4Ks",
                        "content": "Omg i hate this"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "7 months ago, I tried this for the first time had no idea, how to move forward, Today I was able to do so :)"
                    }
                ]
            },
            {
                "id": 1565956,
                "content": [
                    {
                        "username": "freshnewegg",
                        "content": "you\\'re probably gonna read this 1 like 5 times. I\\'m skipping this one"
                    },
                    {
                        "username": "figurative",
                        "content": "For the following example:\\n\"ABCD\"\\n[\"BCE\",\"BCF\",\"ABA\",\"CDA\",\"AEG\",\"FAG\",\"GGG\"]\\nShould we output false (if I am interpreting the problem correctly)?\\nBut the standard code outputs true. Could anyone explain this?"
                    },
                    {
                        "username": "wisdompeak",
                        "content": "Please refer to the discussion here https://leetcode.com/articles/pyramid-transition-matrix/\\nI can easily find a few submitted solutions are DP-based, which must fail on this test case. \\n\"AAAA\"\\n[\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\\nThe correct answer should be \"false\".\\nUnfortunately, the 1st, 2nd and 3rd winners in this contest are ALL WRONG for this problem."
                    },
                    {
                        "username": "thekensai",
                        "content": "For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`. \\n\\n.........wtf is this supposed to mean"
                    },
                    {
                        "username": "awice",
                        "content": "**Background**\\n\\nI care about Leetcode Contest quite a lot, and I understand it is frustrating for competitors to be unfairly penalized due to errors in the contest, as it has happened to me before.\\n\\nIn the previous contest, the judge and tester solution to \"Pyramid Transition Matrix\" incorrectly assumed that state transitions were all independent, which is false.  As such, the limits presented for the question were harder than they should be, and did not include \"Non-independent States\" (NIS) test cases, which caused frustration to competitors in the contest.  I regret the error.\\n\\n**Issues Raised**\\n\\n> Solutions which recieved AC on the contest that do not pass NIS test cases should be rejudged false.\\n\\nThe precedent is that for contests that are not unrated, for solutions that receive AC to keep that AC.  This is based on the principle that it would be unfair for a competitor getting AC to then be judged WA with no opportunity to correct the solution - ie. an AC is always an AC.\\n\\n> People that coded a correct solution (under the new limits) got TLE.\\n\\nWe rejudged every submission that received TLE, to give AC to any correct solution under the new test cases (eg. DFS approaches).\\n\\n> People that would have coded a correct solution but did not code/submit one because of the limits presented.\\n\\nIt is unfortunate for any competitor that would have passed if the problem was presented better, but we have no ability to correct this error without invalidating the contest entirely.  The decision based on the level, severity, and estimated impact of the error was that the contest would stand and we would instead try to mitigate the damage as much as possible.\\n\\n**Steps Taken**\\n\\nThe problem was edited to change the limits to len(bottom) <= 8, and NIS test cases were added.  The article was edited to reflect the new solution possible.  All TLE solutions have been rejudged and results will appear shortly.  All previously-AC solutions will stand (as usual, and even if they would now be WA.)\\n\\n---\\n@yaoxiang3.1g  @guan.huifeng @mail.kuuy  @chrislzm @devilhtc @flowmemo @dbelange @pedro @wjli"
                    },
                    {
                        "username": "Iamyxx",
                        "content": "\"ABCD\"\\n[\"ABE\",\"BCE\",\"BCF\",\"CDF\",\"EEG\",\"FFA\",\"GAA\"]\\n\\n EEF\\nABCD\\n\\nor \\n\\n EFF\\nABCD\\n\\ncan't not continue to go up any more"
                    },
                    {
                        "username": "anurag852001",
                        "content": "IF U FIND ANY BIT MANIPULATION APPROACH POST IT."
                    },
                    {
                        "username": "usernameharsh",
                        "content": "theek bhai"
                    },
                    {
                        "username": "R4Ks",
                        "content": "Omg i hate this"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "7 months ago, I tried this for the first time had no idea, how to move forward, Today I was able to do so :)"
                    }
                ]
            },
            {
                "id": 1567363,
                "content": [
                    {
                        "username": "freshnewegg",
                        "content": "you\\'re probably gonna read this 1 like 5 times. I\\'m skipping this one"
                    },
                    {
                        "username": "figurative",
                        "content": "For the following example:\\n\"ABCD\"\\n[\"BCE\",\"BCF\",\"ABA\",\"CDA\",\"AEG\",\"FAG\",\"GGG\"]\\nShould we output false (if I am interpreting the problem correctly)?\\nBut the standard code outputs true. Could anyone explain this?"
                    },
                    {
                        "username": "wisdompeak",
                        "content": "Please refer to the discussion here https://leetcode.com/articles/pyramid-transition-matrix/\\nI can easily find a few submitted solutions are DP-based, which must fail on this test case. \\n\"AAAA\"\\n[\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\\nThe correct answer should be \"false\".\\nUnfortunately, the 1st, 2nd and 3rd winners in this contest are ALL WRONG for this problem."
                    },
                    {
                        "username": "thekensai",
                        "content": "For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`. \\n\\n.........wtf is this supposed to mean"
                    },
                    {
                        "username": "awice",
                        "content": "**Background**\\n\\nI care about Leetcode Contest quite a lot, and I understand it is frustrating for competitors to be unfairly penalized due to errors in the contest, as it has happened to me before.\\n\\nIn the previous contest, the judge and tester solution to \"Pyramid Transition Matrix\" incorrectly assumed that state transitions were all independent, which is false.  As such, the limits presented for the question were harder than they should be, and did not include \"Non-independent States\" (NIS) test cases, which caused frustration to competitors in the contest.  I regret the error.\\n\\n**Issues Raised**\\n\\n> Solutions which recieved AC on the contest that do not pass NIS test cases should be rejudged false.\\n\\nThe precedent is that for contests that are not unrated, for solutions that receive AC to keep that AC.  This is based on the principle that it would be unfair for a competitor getting AC to then be judged WA with no opportunity to correct the solution - ie. an AC is always an AC.\\n\\n> People that coded a correct solution (under the new limits) got TLE.\\n\\nWe rejudged every submission that received TLE, to give AC to any correct solution under the new test cases (eg. DFS approaches).\\n\\n> People that would have coded a correct solution but did not code/submit one because of the limits presented.\\n\\nIt is unfortunate for any competitor that would have passed if the problem was presented better, but we have no ability to correct this error without invalidating the contest entirely.  The decision based on the level, severity, and estimated impact of the error was that the contest would stand and we would instead try to mitigate the damage as much as possible.\\n\\n**Steps Taken**\\n\\nThe problem was edited to change the limits to len(bottom) <= 8, and NIS test cases were added.  The article was edited to reflect the new solution possible.  All TLE solutions have been rejudged and results will appear shortly.  All previously-AC solutions will stand (as usual, and even if they would now be WA.)\\n\\n---\\n@yaoxiang3.1g  @guan.huifeng @mail.kuuy  @chrislzm @devilhtc @flowmemo @dbelange @pedro @wjli"
                    },
                    {
                        "username": "Iamyxx",
                        "content": "\"ABCD\"\\n[\"ABE\",\"BCE\",\"BCF\",\"CDF\",\"EEG\",\"FFA\",\"GAA\"]\\n\\n EEF\\nABCD\\n\\nor \\n\\n EFF\\nABCD\\n\\ncan't not continue to go up any more"
                    },
                    {
                        "username": "anurag852001",
                        "content": "IF U FIND ANY BIT MANIPULATION APPROACH POST IT."
                    },
                    {
                        "username": "usernameharsh",
                        "content": "theek bhai"
                    },
                    {
                        "username": "R4Ks",
                        "content": "Omg i hate this"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "7 months ago, I tried this for the first time had no idea, how to move forward, Today I was able to do so :)"
                    }
                ]
            },
            {
                "id": 1566806,
                "content": [
                    {
                        "username": "freshnewegg",
                        "content": "you\\'re probably gonna read this 1 like 5 times. I\\'m skipping this one"
                    },
                    {
                        "username": "figurative",
                        "content": "For the following example:\\n\"ABCD\"\\n[\"BCE\",\"BCF\",\"ABA\",\"CDA\",\"AEG\",\"FAG\",\"GGG\"]\\nShould we output false (if I am interpreting the problem correctly)?\\nBut the standard code outputs true. Could anyone explain this?"
                    },
                    {
                        "username": "wisdompeak",
                        "content": "Please refer to the discussion here https://leetcode.com/articles/pyramid-transition-matrix/\\nI can easily find a few submitted solutions are DP-based, which must fail on this test case. \\n\"AAAA\"\\n[\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\\nThe correct answer should be \"false\".\\nUnfortunately, the 1st, 2nd and 3rd winners in this contest are ALL WRONG for this problem."
                    },
                    {
                        "username": "thekensai",
                        "content": "For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`. \\n\\n.........wtf is this supposed to mean"
                    },
                    {
                        "username": "awice",
                        "content": "**Background**\\n\\nI care about Leetcode Contest quite a lot, and I understand it is frustrating for competitors to be unfairly penalized due to errors in the contest, as it has happened to me before.\\n\\nIn the previous contest, the judge and tester solution to \"Pyramid Transition Matrix\" incorrectly assumed that state transitions were all independent, which is false.  As such, the limits presented for the question were harder than they should be, and did not include \"Non-independent States\" (NIS) test cases, which caused frustration to competitors in the contest.  I regret the error.\\n\\n**Issues Raised**\\n\\n> Solutions which recieved AC on the contest that do not pass NIS test cases should be rejudged false.\\n\\nThe precedent is that for contests that are not unrated, for solutions that receive AC to keep that AC.  This is based on the principle that it would be unfair for a competitor getting AC to then be judged WA with no opportunity to correct the solution - ie. an AC is always an AC.\\n\\n> People that coded a correct solution (under the new limits) got TLE.\\n\\nWe rejudged every submission that received TLE, to give AC to any correct solution under the new test cases (eg. DFS approaches).\\n\\n> People that would have coded a correct solution but did not code/submit one because of the limits presented.\\n\\nIt is unfortunate for any competitor that would have passed if the problem was presented better, but we have no ability to correct this error without invalidating the contest entirely.  The decision based on the level, severity, and estimated impact of the error was that the contest would stand and we would instead try to mitigate the damage as much as possible.\\n\\n**Steps Taken**\\n\\nThe problem was edited to change the limits to len(bottom) <= 8, and NIS test cases were added.  The article was edited to reflect the new solution possible.  All TLE solutions have been rejudged and results will appear shortly.  All previously-AC solutions will stand (as usual, and even if they would now be WA.)\\n\\n---\\n@yaoxiang3.1g  @guan.huifeng @mail.kuuy  @chrislzm @devilhtc @flowmemo @dbelange @pedro @wjli"
                    },
                    {
                        "username": "Iamyxx",
                        "content": "\"ABCD\"\\n[\"ABE\",\"BCE\",\"BCF\",\"CDF\",\"EEG\",\"FFA\",\"GAA\"]\\n\\n EEF\\nABCD\\n\\nor \\n\\n EFF\\nABCD\\n\\ncan't not continue to go up any more"
                    },
                    {
                        "username": "anurag852001",
                        "content": "IF U FIND ANY BIT MANIPULATION APPROACH POST IT."
                    },
                    {
                        "username": "usernameharsh",
                        "content": "theek bhai"
                    },
                    {
                        "username": "R4Ks",
                        "content": "Omg i hate this"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "7 months ago, I tried this for the first time had no idea, how to move forward, Today I was able to do so :)"
                    }
                ]
            },
            {
                "id": 1569176,
                "content": [
                    {
                        "username": "freshnewegg",
                        "content": "you\\'re probably gonna read this 1 like 5 times. I\\'m skipping this one"
                    },
                    {
                        "username": "figurative",
                        "content": "For the following example:\\n\"ABCD\"\\n[\"BCE\",\"BCF\",\"ABA\",\"CDA\",\"AEG\",\"FAG\",\"GGG\"]\\nShould we output false (if I am interpreting the problem correctly)?\\nBut the standard code outputs true. Could anyone explain this?"
                    },
                    {
                        "username": "wisdompeak",
                        "content": "Please refer to the discussion here https://leetcode.com/articles/pyramid-transition-matrix/\\nI can easily find a few submitted solutions are DP-based, which must fail on this test case. \\n\"AAAA\"\\n[\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\\nThe correct answer should be \"false\".\\nUnfortunately, the 1st, 2nd and 3rd winners in this contest are ALL WRONG for this problem."
                    },
                    {
                        "username": "thekensai",
                        "content": "For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`. \\n\\n.........wtf is this supposed to mean"
                    },
                    {
                        "username": "awice",
                        "content": "**Background**\\n\\nI care about Leetcode Contest quite a lot, and I understand it is frustrating for competitors to be unfairly penalized due to errors in the contest, as it has happened to me before.\\n\\nIn the previous contest, the judge and tester solution to \"Pyramid Transition Matrix\" incorrectly assumed that state transitions were all independent, which is false.  As such, the limits presented for the question were harder than they should be, and did not include \"Non-independent States\" (NIS) test cases, which caused frustration to competitors in the contest.  I regret the error.\\n\\n**Issues Raised**\\n\\n> Solutions which recieved AC on the contest that do not pass NIS test cases should be rejudged false.\\n\\nThe precedent is that for contests that are not unrated, for solutions that receive AC to keep that AC.  This is based on the principle that it would be unfair for a competitor getting AC to then be judged WA with no opportunity to correct the solution - ie. an AC is always an AC.\\n\\n> People that coded a correct solution (under the new limits) got TLE.\\n\\nWe rejudged every submission that received TLE, to give AC to any correct solution under the new test cases (eg. DFS approaches).\\n\\n> People that would have coded a correct solution but did not code/submit one because of the limits presented.\\n\\nIt is unfortunate for any competitor that would have passed if the problem was presented better, but we have no ability to correct this error without invalidating the contest entirely.  The decision based on the level, severity, and estimated impact of the error was that the contest would stand and we would instead try to mitigate the damage as much as possible.\\n\\n**Steps Taken**\\n\\nThe problem was edited to change the limits to len(bottom) <= 8, and NIS test cases were added.  The article was edited to reflect the new solution possible.  All TLE solutions have been rejudged and results will appear shortly.  All previously-AC solutions will stand (as usual, and even if they would now be WA.)\\n\\n---\\n@yaoxiang3.1g  @guan.huifeng @mail.kuuy  @chrislzm @devilhtc @flowmemo @dbelange @pedro @wjli"
                    },
                    {
                        "username": "Iamyxx",
                        "content": "\"ABCD\"\\n[\"ABE\",\"BCE\",\"BCF\",\"CDF\",\"EEG\",\"FFA\",\"GAA\"]\\n\\n EEF\\nABCD\\n\\nor \\n\\n EFF\\nABCD\\n\\ncan't not continue to go up any more"
                    },
                    {
                        "username": "anurag852001",
                        "content": "IF U FIND ANY BIT MANIPULATION APPROACH POST IT."
                    },
                    {
                        "username": "usernameharsh",
                        "content": "theek bhai"
                    },
                    {
                        "username": "R4Ks",
                        "content": "Omg i hate this"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "7 months ago, I tried this for the first time had no idea, how to move forward, Today I was able to do so :)"
                    }
                ]
            },
            {
                "id": 1568702,
                "content": [
                    {
                        "username": "freshnewegg",
                        "content": "you\\'re probably gonna read this 1 like 5 times. I\\'m skipping this one"
                    },
                    {
                        "username": "figurative",
                        "content": "For the following example:\\n\"ABCD\"\\n[\"BCE\",\"BCF\",\"ABA\",\"CDA\",\"AEG\",\"FAG\",\"GGG\"]\\nShould we output false (if I am interpreting the problem correctly)?\\nBut the standard code outputs true. Could anyone explain this?"
                    },
                    {
                        "username": "wisdompeak",
                        "content": "Please refer to the discussion here https://leetcode.com/articles/pyramid-transition-matrix/\\nI can easily find a few submitted solutions are DP-based, which must fail on this test case. \\n\"AAAA\"\\n[\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\\nThe correct answer should be \"false\".\\nUnfortunately, the 1st, 2nd and 3rd winners in this contest are ALL WRONG for this problem."
                    },
                    {
                        "username": "thekensai",
                        "content": "For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`. \\n\\n.........wtf is this supposed to mean"
                    },
                    {
                        "username": "awice",
                        "content": "**Background**\\n\\nI care about Leetcode Contest quite a lot, and I understand it is frustrating for competitors to be unfairly penalized due to errors in the contest, as it has happened to me before.\\n\\nIn the previous contest, the judge and tester solution to \"Pyramid Transition Matrix\" incorrectly assumed that state transitions were all independent, which is false.  As such, the limits presented for the question were harder than they should be, and did not include \"Non-independent States\" (NIS) test cases, which caused frustration to competitors in the contest.  I regret the error.\\n\\n**Issues Raised**\\n\\n> Solutions which recieved AC on the contest that do not pass NIS test cases should be rejudged false.\\n\\nThe precedent is that for contests that are not unrated, for solutions that receive AC to keep that AC.  This is based on the principle that it would be unfair for a competitor getting AC to then be judged WA with no opportunity to correct the solution - ie. an AC is always an AC.\\n\\n> People that coded a correct solution (under the new limits) got TLE.\\n\\nWe rejudged every submission that received TLE, to give AC to any correct solution under the new test cases (eg. DFS approaches).\\n\\n> People that would have coded a correct solution but did not code/submit one because of the limits presented.\\n\\nIt is unfortunate for any competitor that would have passed if the problem was presented better, but we have no ability to correct this error without invalidating the contest entirely.  The decision based on the level, severity, and estimated impact of the error was that the contest would stand and we would instead try to mitigate the damage as much as possible.\\n\\n**Steps Taken**\\n\\nThe problem was edited to change the limits to len(bottom) <= 8, and NIS test cases were added.  The article was edited to reflect the new solution possible.  All TLE solutions have been rejudged and results will appear shortly.  All previously-AC solutions will stand (as usual, and even if they would now be WA.)\\n\\n---\\n@yaoxiang3.1g  @guan.huifeng @mail.kuuy  @chrislzm @devilhtc @flowmemo @dbelange @pedro @wjli"
                    },
                    {
                        "username": "Iamyxx",
                        "content": "\"ABCD\"\\n[\"ABE\",\"BCE\",\"BCF\",\"CDF\",\"EEG\",\"FFA\",\"GAA\"]\\n\\n EEF\\nABCD\\n\\nor \\n\\n EFF\\nABCD\\n\\ncan't not continue to go up any more"
                    },
                    {
                        "username": "anurag852001",
                        "content": "IF U FIND ANY BIT MANIPULATION APPROACH POST IT."
                    },
                    {
                        "username": "usernameharsh",
                        "content": "theek bhai"
                    },
                    {
                        "username": "R4Ks",
                        "content": "Omg i hate this"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "7 months ago, I tried this for the first time had no idea, how to move forward, Today I was able to do so :)"
                    }
                ]
            },
            {
                "id": 2049116,
                "content": [
                    {
                        "username": "freshnewegg",
                        "content": "you\\'re probably gonna read this 1 like 5 times. I\\'m skipping this one"
                    },
                    {
                        "username": "figurative",
                        "content": "For the following example:\\n\"ABCD\"\\n[\"BCE\",\"BCF\",\"ABA\",\"CDA\",\"AEG\",\"FAG\",\"GGG\"]\\nShould we output false (if I am interpreting the problem correctly)?\\nBut the standard code outputs true. Could anyone explain this?"
                    },
                    {
                        "username": "wisdompeak",
                        "content": "Please refer to the discussion here https://leetcode.com/articles/pyramid-transition-matrix/\\nI can easily find a few submitted solutions are DP-based, which must fail on this test case. \\n\"AAAA\"\\n[\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\\nThe correct answer should be \"false\".\\nUnfortunately, the 1st, 2nd and 3rd winners in this contest are ALL WRONG for this problem."
                    },
                    {
                        "username": "thekensai",
                        "content": "For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`. \\n\\n.........wtf is this supposed to mean"
                    },
                    {
                        "username": "awice",
                        "content": "**Background**\\n\\nI care about Leetcode Contest quite a lot, and I understand it is frustrating for competitors to be unfairly penalized due to errors in the contest, as it has happened to me before.\\n\\nIn the previous contest, the judge and tester solution to \"Pyramid Transition Matrix\" incorrectly assumed that state transitions were all independent, which is false.  As such, the limits presented for the question were harder than they should be, and did not include \"Non-independent States\" (NIS) test cases, which caused frustration to competitors in the contest.  I regret the error.\\n\\n**Issues Raised**\\n\\n> Solutions which recieved AC on the contest that do not pass NIS test cases should be rejudged false.\\n\\nThe precedent is that for contests that are not unrated, for solutions that receive AC to keep that AC.  This is based on the principle that it would be unfair for a competitor getting AC to then be judged WA with no opportunity to correct the solution - ie. an AC is always an AC.\\n\\n> People that coded a correct solution (under the new limits) got TLE.\\n\\nWe rejudged every submission that received TLE, to give AC to any correct solution under the new test cases (eg. DFS approaches).\\n\\n> People that would have coded a correct solution but did not code/submit one because of the limits presented.\\n\\nIt is unfortunate for any competitor that would have passed if the problem was presented better, but we have no ability to correct this error without invalidating the contest entirely.  The decision based on the level, severity, and estimated impact of the error was that the contest would stand and we would instead try to mitigate the damage as much as possible.\\n\\n**Steps Taken**\\n\\nThe problem was edited to change the limits to len(bottom) <= 8, and NIS test cases were added.  The article was edited to reflect the new solution possible.  All TLE solutions have been rejudged and results will appear shortly.  All previously-AC solutions will stand (as usual, and even if they would now be WA.)\\n\\n---\\n@yaoxiang3.1g  @guan.huifeng @mail.kuuy  @chrislzm @devilhtc @flowmemo @dbelange @pedro @wjli"
                    },
                    {
                        "username": "Iamyxx",
                        "content": "\"ABCD\"\\n[\"ABE\",\"BCE\",\"BCF\",\"CDF\",\"EEG\",\"FFA\",\"GAA\"]\\n\\n EEF\\nABCD\\n\\nor \\n\\n EFF\\nABCD\\n\\ncan't not continue to go up any more"
                    },
                    {
                        "username": "anurag852001",
                        "content": "IF U FIND ANY BIT MANIPULATION APPROACH POST IT."
                    },
                    {
                        "username": "usernameharsh",
                        "content": "theek bhai"
                    },
                    {
                        "username": "R4Ks",
                        "content": "Omg i hate this"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "7 months ago, I tried this for the first time had no idea, how to move forward, Today I was able to do so :)"
                    }
                ]
            },
            {
                "id": 2068234,
                "content": [
                    {
                        "username": "freshnewegg",
                        "content": "you\\'re probably gonna read this 1 like 5 times. I\\'m skipping this one"
                    },
                    {
                        "username": "figurative",
                        "content": "For the following example:\\n\"ABCD\"\\n[\"BCE\",\"BCF\",\"ABA\",\"CDA\",\"AEG\",\"FAG\",\"GGG\"]\\nShould we output false (if I am interpreting the problem correctly)?\\nBut the standard code outputs true. Could anyone explain this?"
                    },
                    {
                        "username": "wisdompeak",
                        "content": "Please refer to the discussion here https://leetcode.com/articles/pyramid-transition-matrix/\\nI can easily find a few submitted solutions are DP-based, which must fail on this test case. \\n\"AAAA\"\\n[\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\\nThe correct answer should be \"false\".\\nUnfortunately, the 1st, 2nd and 3rd winners in this contest are ALL WRONG for this problem."
                    },
                    {
                        "username": "thekensai",
                        "content": "For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`. \\n\\n.........wtf is this supposed to mean"
                    },
                    {
                        "username": "awice",
                        "content": "**Background**\\n\\nI care about Leetcode Contest quite a lot, and I understand it is frustrating for competitors to be unfairly penalized due to errors in the contest, as it has happened to me before.\\n\\nIn the previous contest, the judge and tester solution to \"Pyramid Transition Matrix\" incorrectly assumed that state transitions were all independent, which is false.  As such, the limits presented for the question were harder than they should be, and did not include \"Non-independent States\" (NIS) test cases, which caused frustration to competitors in the contest.  I regret the error.\\n\\n**Issues Raised**\\n\\n> Solutions which recieved AC on the contest that do not pass NIS test cases should be rejudged false.\\n\\nThe precedent is that for contests that are not unrated, for solutions that receive AC to keep that AC.  This is based on the principle that it would be unfair for a competitor getting AC to then be judged WA with no opportunity to correct the solution - ie. an AC is always an AC.\\n\\n> People that coded a correct solution (under the new limits) got TLE.\\n\\nWe rejudged every submission that received TLE, to give AC to any correct solution under the new test cases (eg. DFS approaches).\\n\\n> People that would have coded a correct solution but did not code/submit one because of the limits presented.\\n\\nIt is unfortunate for any competitor that would have passed if the problem was presented better, but we have no ability to correct this error without invalidating the contest entirely.  The decision based on the level, severity, and estimated impact of the error was that the contest would stand and we would instead try to mitigate the damage as much as possible.\\n\\n**Steps Taken**\\n\\nThe problem was edited to change the limits to len(bottom) <= 8, and NIS test cases were added.  The article was edited to reflect the new solution possible.  All TLE solutions have been rejudged and results will appear shortly.  All previously-AC solutions will stand (as usual, and even if they would now be WA.)\\n\\n---\\n@yaoxiang3.1g  @guan.huifeng @mail.kuuy  @chrislzm @devilhtc @flowmemo @dbelange @pedro @wjli"
                    },
                    {
                        "username": "Iamyxx",
                        "content": "\"ABCD\"\\n[\"ABE\",\"BCE\",\"BCF\",\"CDF\",\"EEG\",\"FFA\",\"GAA\"]\\n\\n EEF\\nABCD\\n\\nor \\n\\n EFF\\nABCD\\n\\ncan't not continue to go up any more"
                    },
                    {
                        "username": "anurag852001",
                        "content": "IF U FIND ANY BIT MANIPULATION APPROACH POST IT."
                    },
                    {
                        "username": "usernameharsh",
                        "content": "theek bhai"
                    },
                    {
                        "username": "R4Ks",
                        "content": "Omg i hate this"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "7 months ago, I tried this for the first time had no idea, how to move forward, Today I was able to do so :)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Set Intersection Size At Least Two",
        "question_content": "<p>You are given a 2D integer array <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represents all the integers from <code>start<sub>i</sub></code> to <code>end<sub>i</sub></code> inclusively.</p>\n\n<p>A <strong>containing set</strong> is an array <code>nums</code> where each interval from <code>intervals</code> has <strong>at least two</strong> integers in <code>nums</code>.</p>\n\n<ul>\n\t<li>For example, if <code>intervals = [[1,3], [3,7], [8,9]]</code>, then <code>[1,2,4,7,8,9]</code> and <code>[2,3,4,8,9]</code> are <strong>containing sets</strong>.</li>\n</ul>\n\n<p>Return <em>the minimum possible size of a containing set</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[3,7],[8,9]]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> let nums = [2, 3, 4, 8, 9].\nIt can be shown that there cannot be any containing array of size 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[1,4],[2,5],[3,5]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> let nums = [2, 3, 4].\nIt can be shown that there cannot be any containing array of size 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[2,3],[2,4],[4,5]]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> let nums = [1, 2, 3, 4, 5].\nIt can be shown that there cannot be any containing array of size 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 3000</code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 113085,
                "title": "ever-wonder-why-the-greedy-algorithm-works-here-is-the-explanation",
                "content": "The greedy algorithm for constructing the minimum intersection set is not easy to come up with, as it replies on two properties of the minimum intersection set. In this post, I will explain what these properties are and how to find the size of the minimum intersection set using these properties.\\n\\n---\\n\\n`I -- Definitions and notations`\\n\\nTo ease the explanation, we first spell out some definitions and notations that will be used in this post.\\n\\n**Intersection set**: we define an intersection set for a given array (containing intervals) as a set `S` such that for every interval `A` in the given array, the intersection of `S` with `A` has size at least `2`. \\n\\n**Minimum intersection set**: of all the intersection sets for a given array, let `m` be the minimum value of their sizes, then any one of the intersection sets with size `m` will be referred to as a minimum intersection set.\\n\\n**Notations**: let `intervals` be the input array with length `n`; `intervals[0, i]` denote the subarray containing intervals of indices from `0` up to `i`; `S_i` be  the minimum intersection set for the subarray `intervals[0, i]`; `m_i` be the size of `S_i`.\\n\\n---\\n\\n`II -- Properties of the minimum intersection set`\\n\\nFrom the notations in part `I`, our goal is to figure out `m_(n-1)`, the size of `S_(n-1)`, which is the minimum intersection set for the whole input array. To apply the greedy algorithm, we need to take advantage of the following two properties of `S_i`:\\n\\n1. `S_i` **does not** depend on the order of the intervals in the subarray `intervals[0, i]`.\\n\\n2. `m_i` is **non-decreasing** with increasing `i`, that is, we always have `m_(i-1) <= m_i`.\\n\\nThe first property is straightforward from the definition of an intersection set, where the intersection requirement (i.e., `intersection size >= 2`) does not depend on the order of the intervals in the given array.\\n\\nThe second property comes from the fact that if `S_i` is a minimum intersection set for subarray `intervals[0, i]`, then it will also be an intersection set for subarray `intervals[0, i-1]` (but not necessarily a minimum intersection set). Since both `S_(i-1)` and `S_i` are intersection sets for the subarray `intervals[0, i-1]`, but the former is a minimum intersection set, by definition we conclude: `m_(i-1) <= m_i`.\\n\\n---\\n\\n`III -- The greedy algorithm for constructing the minimum intersection set`\\n\\nThe first property above suggests we are free to rearrange the intervals in the input array, which means the intervals can be sorted to our advantage. There are two choices for sorting: we can sort the intervals either with ascending start points or with ascending end points. Both will work but here we will sort them with ascending end points, and if two intervals have the same end points, the one with larger start point will come first (we want to process the shorter interval before the longer one).\\n\\nThe second property above suggests to minimize `m_i`, we need to minimize `m_(i-1)`, which in turn requires minimization of `m_(i-2)`, and so on. This is actually where the greedy idea comes from. So assume for now we have minimized `m_(i-1)`, how can we minimize `m_i`?\\n\\nWe know that `m_(i-1) <= m_i`, so the minimum value of `m_i` we can achieve is `m_(i-1)`. If this is the case, what does it imply? It means `S_(i-1)` is not only a minimum intersection set for the subarray `intervals[0, i-1]`, but also a minimum intersection set for the subarray `intervals[0, i]`. This is equivalent to saying that we can find two different elements from `S_(i-1)` such that both elements intersect with the interval `intervals[i]`.\\n\\nBut how do we find such two elements? If the intervals come in arbitrary order, we probably have to check each element in `S_(i-1)` one by one and see if it intersects with `intervals[i]`, which is rather inefficient. Fortunately, the intervals can be sorted. In our case, they are sorted in ascending order according to their end points. This means all elements in `S_(i-1)` will be no greater than the end point of the interval `intervals[i]`. This is because every element `e` in `S_(i-1)` will intersect with at least one interval in the subarray `intervals[0, i-1]` (otherwise, we can remove `e` to make `S_(i-1)` smaller without violating the intersection requirement). Without loss of generality, assume the interval intersecting with `e` has index `j`, where `0 <= j <= i - 1 < i`, then we have `e <= intervals[j][1] <= intervals[i][1]`.\\n\\nTherefore we only need to check the largest two elements (denoted as `largest` and `second`) in `S_(i-1)` to see if they intersect with the interval `intervals[i]`. This is because if they don\\'t, other elements won\\'t either. Note this also implies that of all the minimum intersection sets for the subarray `intervals[0, i-1]`, we will choose `S_(i-1)` to be the one with its largest two elements maximized. That is, for the subarray `intervals[0, i-1]`, we not only **minimize** the size of the intersection set, but also **maximize** its largest two elements (after the size is minimized).\\n\\nChecking if the largest two elements intersect with `interval[i]` is equivalent to comparing them with the start point of `interval[i]`. There are three cases here: \\n\\n1. **Case 1**: both elements intersect with `intervals[i]`. For this case, we show `m_i = m_(i-1)`, and no updates are needed for the largest two elements of `S_i`.\\n\\n2. **Case 2**: only the largest element intersects with `intervals[i]`. For this case, we show `m_i = 1 + m_(i-1)`, and the largest two elements of `S_i` need to be updated.\\n\\n3. **Case 3**: neither of them intersects with `intervals[i]`. For this case, we show `m_i = 2 + m_(i-1)`, and the largest two elements of `S_i` need to be updated.\\n\\nConsider **Case 1** first. From our analyses above, we know `S_(i-1)` is also a minimum intersection set for subarray `intervals[0, i]`, therefore we can choose `S_i` to be the same as `S_(i-1)` and get `m_i = m_(i-1)`. Can we make the largest two elements of `S_i` even larger? Negative. It is because if such a set `S_i` exists, it will also be a minimum intersection set for the subarray `intervals[0, i-1]`, so its largest two elements cannot exceed those of `S_(i-1)` (note we\\'ve already chosen `S_(i-1)` to be the minimum intersection set for `intervals[0, i-1]` with the largest two elements maximized), contradicting the assumption.\\n\\nConsider **Case 2** next. Can we still have `m_i = m_(i-1)`? Nope. If this is true, then `S_i` will also be a minimum intersection set for `intervals[0, i-1]`, indicating its two largest elements won\\'t exceed those of `S_(i-1)`. Since the largest two elements of `S_i` intersect with `intervals[i]`, the largest two elements of `S_(i-1)` must also intersect with `intervals[i]`, contradicting the fact that only one of them intersects with `intervals[i]`. Therefore we conclude: `m_i >= 1 + m_(i-1)`. Can we have `m_i = 1 + m_(i-1)`? Yes. `S_i` can be constructed by simply adding the end point of `intervals[i]` to `S_(i-1)`. This not only makes `S_i` a minimum intersection set for the subarray `intervals[0, i]`, but also maximizes its largest two elements.\\n\\nConsider **Case 3** last. Can we have either `m_i = m_(i-1)` or `m_i = 1 + m_(i-1)`? No, with the same reasoning in **Case 2**. So we conclude: `m_i >= 2 + m_(i-1)`. Can we have `m_i = 2 + m_(i-1)`? Yes. `S_i` can be constructed by simply adding the end point and the point immediately before the end point of `intervals[i]` to `S_(i-1)`. This will turn `S_i` into a minimum intersection set for the subarray `intervals[0, i]`, meanwhile maximize its largest two elements.\\n\\nFor all the three cases, `S_i` is constructed in such a way that its size is minimized first, then its largest two elements are maximized. When all the intervals are processed, `S_(n-1)` will be a minimum intersection set of the whole input array and `m_(n-1)` is the minimum size we are looking for.\\n\\n---\\n\\n`IV -- The solution`\\n\\nHere is the actual code for the finding the size of the minimum intersection set. We first sort the intervals as described above, then build the minimum intersection set for each of the subarrays one by one (take different measures depending on which case it is). Space complexity is `O(1)` while the time complexity is bound by the sorting part, which is `O(nlogn)`.\\n\\n```\\npublic int intersectionSizeTwo(int[][] intervals) {\\n    Arrays.sort(intervals, new Comparator<int[]>() {\\n    \\tpublic int compare(int[] a, int[] b) {\\n    \\t    return (a[1] != b[1] ? Integer.compare(a[1], b[1]) : Integer.compare(b[0], a[0]));\\n    \\t}\\n    });\\n    \\n    int m = 0, largest = -1, second = -1;\\n    \\n    for (int[] interval : intervals) {\\n        int a = interval[0], b = interval[1];\\n\\t\\n\\t    boolean is_largest_in = (a <= largest);\\n        boolean is_second_in = (a <= second);\\n\\t\\n\\t    if (is_largest_in && is_second_in) continue;\\n        \\n        m += (is_largest_in ? 1 : 2);\\n        \\n\\t    second = (is_largest_in ? largest : b - 1);\\n\\t    largest = b;\\n    }\\n    \\n    return m;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int intersectionSizeTwo(int[][] intervals) {\\n    Arrays.sort(intervals, new Comparator<int[]>() {\\n    \\tpublic int compare(int[] a, int[] b) {\\n    \\t    return (a[1] != b[1] ? Integer.compare(a[1], b[1]) : Integer.compare(b[0], a[0]));\\n    \\t}\\n    });\\n    \\n    int m = 0, largest = -1, second = -1;\\n    \\n    for (int[] interval : intervals) {\\n        int a = interval[0], b = interval[1];\\n\\t\\n\\t    boolean is_largest_in = (a <= largest);\\n        boolean is_second_in = (a <= second);\\n\\t\\n\\t    if (is_largest_in && is_second_in) continue;\\n        \\n        m += (is_largest_in ? 1 : 2);\\n        \\n\\t    second = (is_largest_in ? largest : b - 1);\\n\\t    largest = b;\\n    }\\n    \\n    return m;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113086,
                "title": "hope-you-enjoy-this-problem-o-nlogn-java-greedy-easy-to-understand-solution",
                "content": "A few of points:\\n1. Sort the array according to their end point in ascending order, AND if two intervals have same end, sort them according to their start point in descending order. e.g   [[1,5],[4,5],[5,9],[7,9],[9,10]]  =>  [[4,5], [1,5], [7,9], [5,9] , [9,10]]\\n2. Greedy to get the rightmost two point\\n\\nAccording to the adjustment of the **LeetCode** admin, this is the accepted version\\n```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        int res = 0;\\n        if (intervals == null || intervals.length == 0) {\\n            return res;\\n        }\\n        Arrays.sort(intervals, (a, b)-> a[1] != b[1] ? a[1] - b[1] : b[0] - a[0]);\\n        // known two rightmost point in the set/res\\n        int left = intervals[0][1] - 1;\\n        int right = intervals[0][1];\\n        res += 2;\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] curr = intervals[i];\\n            // 1. one element of the set is in the interval\\n            // 2. no elemnet of the set is in the interval\\n            if (left < curr[0] && curr[0] <= right) {\\n                res++;\\n                left = right;\\n                right = curr[1];\\n            } else if (curr[0] > right) {\\n                res += 2;\\n                left = curr[1] - 1;\\n                right = curr[1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nThe **Original** problem I contributed asked for all the elements of the qualified set, but the idea is same. This is for original question\\n```\\nclass Interval {\\n    int start;\\n    int end;\\n    Interval() { start = 0; end = 0; }\\n    Interval(int s, int e) { start = s; end = e; }\\n}\\n\\npublic List<Integer> findSet(List<Interval> intervals) {\\n        List<Integer> res = new ArrayList<>();\\n        if (intervals == null || intervals.size() == 0) {\\n            return res;\\n        }\\n        Collections.sort(intervals, (a, b)-> a.end != b.end ? a.end - b.end : b.start - a.start);\\n        int left = intervals.get(0).end - 1;\\n        int right = intervals.get(0).end;\\n        res.add(left);\\n        res.add(right);\\n        for (int i = 1; i < intervals.size(); i++) {\\n            Interval curr = intervals.get(i);\\n            // 1. one element of the set is in the interval\\n            // 2. no elemnet of the set is in the interval\\n            if (left < curr.start && curr.start <= right) {\\n                res.add(curr.end);\\n                left = right;\\n                right = curr.end;\\n            } else if (curr.start > right) {\\n                res.add(curr.end - 1);\\n                res.add(curr.end);\\n                left = curr.end - 1;\\n                right = curr.end;\\n            }\\n        }\\n        return res;\\n    }\\n```\\nThanks **tyuan73** for pointing out the error and providing the case. @tyuan73 \\n@administrators  hope adding the case to the test case set at your earliest convenience please, thank you :) **[[1,5],[4,5],[5,9],[7,9],[9,10]]**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        int res = 0;\\n        if (intervals == null || intervals.length == 0) {\\n            return res;\\n        }\\n        Arrays.sort(intervals, (a, b)-> a[1] != b[1] ? a[1] - b[1] : b[0] - a[0]);\\n        // known two rightmost point in the set/res\\n        int left = intervals[0][1] - 1;\\n        int right = intervals[0][1];\\n        res += 2;\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] curr = intervals[i];\\n            // 1. one element of the set is in the interval\\n            // 2. no elemnet of the set is in the interval\\n            if (left < curr[0] && curr[0] <= right) {\\n                res++;\\n                left = right;\\n                right = curr[1];\\n            } else if (curr[0] > right) {\\n                res += 2;\\n                left = curr[1] - 1;\\n                right = curr[1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Interval {\\n    int start;\\n    int end;\\n    Interval() { start = 0; end = 0; }\\n    Interval(int s, int e) { start = s; end = e; }\\n}\\n\\npublic List<Integer> findSet(List<Interval> intervals) {\\n        List<Integer> res = new ArrayList<>();\\n        if (intervals == null || intervals.size() == 0) {\\n            return res;\\n        }\\n        Collections.sort(intervals, (a, b)-> a.end != b.end ? a.end - b.end : b.start - a.start);\\n        int left = intervals.get(0).end - 1;\\n        int right = intervals.get(0).end;\\n        res.add(left);\\n        res.add(right);\\n        for (int i = 1; i < intervals.size(); i++) {\\n            Interval curr = intervals.get(i);\\n            // 1. one element of the set is in the interval\\n            // 2. no elemnet of the set is in the interval\\n            if (left < curr.start && curr.start <= right) {\\n                res.add(curr.end);\\n                left = right;\\n                right = curr.end;\\n            } else if (curr.start > right) {\\n                res.add(curr.end - 1);\\n                res.add(curr.end);\\n                left = curr.end - 1;\\n                right = curr.end;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113076,
                "title": "java-o-nlogn-solution-greedy",
                "content": "First sort the intervals, with their starting points from low to high\\nThen use a stack to eliminate the intervals which fully overlap another interval. \\nFor example, if we have [2,9] and [1,10], we can get rid of [1,10]. Because as long as we pick up two numbers in [2,9], the requirement for [1,10] can be achieved automatically.\\n\\nFinally we deal with the sorted intervals one by one.\\n(1) If there is no number in this interval being chosen before, we pick up 2 biggest number in this interval. (the biggest number have the most possibility to be used by next interval)\\n(2) If there is one number in this interval being chosen before, we pick up the biggest number in this interval.\\n(3) If there are already two numbers in this interval being chosen before, we can skip this interval since the requirement has been fulfilled.\\n\\n```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b)->((a[0]==b[0])?(-a[1]+b[1]):(a[0]-b[0])));\\n        Stack<int[]> st=new Stack<>();\\n        for (int[] in:intervals)\\n        {\\n            while (!st.isEmpty() && st.peek()[1]>=in[1]) st.pop();\\n            st.push(in);\\n        }\\n        int n=st.size();\\n        int[][] a=new int[n][2];\\n        for (int i=n-1;i>=0;i--)\\n        {\\n            a[i][0]=st.peek()[0];\\n            a[i][1]=st.pop()[1];\\n        }\\n        int ans=2;\\n        int p1=a[0][1]-1,p2=a[0][1];\\n        for (int i=1;i<n;i++)\\n        {\\n            boolean bo1=(p1>=a[i][0] && p1<=a[i][1]),bo2=(p2>=a[i][0] && p2<=a[i][1]);\\n            if (bo1 && bo2) continue;\\n            if (bo2)\\n            {\\n                p1=p2;\\n                p2=a[i][1];\\n                ans++;\\n                continue;\\n            }\\n            p1=a[i][1]-1;\\n            p2=a[i][1];\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b)->((a[0]==b[0])?(-a[1]+b[1]):(a[0]-b[0])));\\n        Stack<int[]> st=new Stack<>();\\n        for (int[] in:intervals)\\n        {\\n            while (!st.isEmpty() && st.peek()[1]>=in[1]) st.pop();\\n            st.push(in);\\n        }\\n        int n=st.size();\\n        int[][] a=new int[n][2];\\n        for (int i=n-1;i>=0;i--)\\n        {\\n            a[i][0]=st.peek()[0];\\n            a[i][1]=st.pop()[1];\\n        }\\n        int ans=2;\\n        int p1=a[0][1]-1,p2=a[0][1];\\n        for (int i=1;i<n;i++)\\n        {\\n            boolean bo1=(p1>=a[i][0] && p1<=a[i][1]),bo2=(p2>=a[i][0] && p2<=a[i][1]);\\n            if (bo1 && bo2) continue;\\n            if (bo2)\\n            {\\n                p1=p2;\\n                p2=a[i][1];\\n                ans++;\\n                continue;\\n            }\\n            p1=a[i][1]-1;\\n            p2=a[i][1];\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113089,
                "title": "c-concise-solution-o-nlogn-greedy-39-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[1] < b[1] || (a[1] == b[1] && a[0] > b[0]); \\n        });\\n        int n = intervals.size(), ans = 0, p1 = -1, p2 = -1;\\n        for (int i = 0; i < n; i++) {\\n            // current p1, p2 works for intervals[i]\\n            if (intervals[i][0] <= p1) continue;\\n            // Neither of p1, p2 works for intervals[i]\\n            // replace p1, p2 by ending numbers\\n            if (intervals[i][0] > p2) {\\n                ans += 2;\\n                p2 = intervals[i][1];\\n                p1 = p2-1;\\n            }\\n            // only p2 works;  \\n            else {\\n                ans++;\\n                p1 = p2;\\n                p2 = intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[1] < b[1] || (a[1] == b[1] && a[0] > b[0]); \\n        });\\n        int n = intervals.size(), ans = 0, p1 = -1, p2 = -1;\\n        for (int i = 0; i < n; i++) {\\n            // current p1, p2 works for intervals[i]\\n            if (intervals[i][0] <= p1) continue;\\n            // Neither of p1, p2 works for intervals[i]\\n            // replace p1, p2 by ending numbers\\n            if (intervals[i][0] > p2) {\\n                ans += 2;\\n                p2 = intervals[i][1];\\n                p1 = p2-1;\\n            }\\n            // only p2 works;  \\n            else {\\n                ans++;\\n                p1 = p2;\\n                p2 = intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439986,
                "title": "python-keep-track-of-the-right-most-2-points",
                "content": "Sort intervals by end. The right-most 2 points are the one we are interested in. When a new interval comes, reuse the current right-most 2 points as much as possible. If can\\'t reuse, then introduce new points to the right-most side of new interval.\\n\\n```\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:x[1])\\n        res=0\\n        cur=[]\\n        for start,end in intervals:\\n            if not cur or start>cur[1]:\\n                res+=2\\n                cur=[end-1,end]\\n            elif start>cur[0]:\\n                res+=1\\n                cur=[cur[1],end]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:x[1])\\n        res=0\\n        cur=[]\\n        for start,end in intervals:\\n            if not cur or start>cur[1]:\\n                res+=2\\n                cur=[end-1,end]\\n            elif start>cur[0]:\\n                res+=1\\n                cur=[cur[1],end]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1050159,
                "title": "java-13-lines-of-code-based-on-sorting-the-intervals-tc-o-nlogn",
                "content": "Firstly, we need to sort the intervals. Then, we add the end and end-1 of the first interval. Then, we look at the boundaries of the current interval. We need to either add zero, one, or at most two points to make the current interval fit the problem condition. \\n\\n```\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        int n = intervals.length;\\n        Arrays.sort(intervals, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]); // Sort intervals: 1- end 2- start- O(nlogn)\\n        List<Integer> res = new ArrayList<>();\\n        res.add(intervals[0][1] - 1); // Add one before end\\n        res.add(intervals[0][1]); // Add end\\n        for (int i = 1; i < n; i++) { // O(n)\\n            int start = intervals[i][0], end = intervals[i][1], size = res.size(), last = res.get(size - 1), secondLast = res.get(size - 2);\\n            if (start > last) { // We need to add two fresh points\\n                res.add(end - 1);\\n                res.add(end);\\n            } else if (start == last) res.add(end); // We already added one. We need to add the end of this interval\\n            else if (start > secondLast) res.add(end); // We already added last. We need one more\\n        }\\n        return res.size();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        int n = intervals.length;\\n        Arrays.sort(intervals, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]); // Sort intervals: 1- end 2- start- O(nlogn)\\n        List<Integer> res = new ArrayList<>();\\n        res.add(intervals[0][1] - 1); // Add one before end\\n        res.add(intervals[0][1]); // Add end\\n        for (int i = 1; i < n; i++) { // O(n)\\n            int start = intervals[i][0], end = intervals[i][1], size = res.size(), last = res.get(size - 1), secondLast = res.get(size - 2);\\n            if (start > last) { // We need to add two fresh points\\n                res.add(end - 1);\\n                res.add(end);\\n            } else if (start == last) res.add(end); // We already added one. We need to add the end of this interval\\n            else if (start > secondLast) res.add(end); // We already added last. We need one more\\n        }\\n        return res.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 298379,
                "title": "python3-beat-100",
                "content": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x:x[1]) # sort by end-point\\n        ans = 0\\n        pre = []\\n        for (s, t) in intervals:\\n            if not pre or pre[1] < s:\\n                ans += 2\\n                pre = [t-1, t]\\n            elif pre[0] < s:\\n\\t\\t\\t\\tpre = [pre[1], t]\\n\\t\\t\\t\\tans += 1\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x:x[1]) # sort by end-point\\n        ans = 0\\n        pre = []\\n        for (s, t) in intervals:\\n            if not pre or pre[1] < s:\\n                ans += 2\\n                pre = [t-1, t]\\n            elif pre[0] < s:\\n\\t\\t\\t\\tpre = [pre[1], t]\\n\\t\\t\\t\\tans += 1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2700915,
                "title": "python-explained-o-nlogn",
                "content": "# Intuition :\\n- This problem is similar to [Meeting rooms II](https://leetcode.com/problems/meeting-rooms-ii/) in which we have to find the minimum number of rooms required to organize all the conferences.\\n- Similarly in this problem we have to find the minimum size of set that contain atleast two integers from each interval.\\n- -----------------\\n\\n# Approach :\\n- Suppose we have two intervals `[start1, end1]` and `[start2, end2]`.\\n- Now let\\'s consider three cases here :\\n- 1. when these two intervals do not overlap :\\n    - `end1 < start2`, means `start2-end1 > 0` --> we will select two integers from both sets.\\n- 2. when these two intervals overlap edge to edge :\\n    - `end1 == start2`, means `start2-end1 == 0`--> we will select one common element from the sets and one distinct element from previous interval.\\n- 3. when these two intervals overlap(not edge to edge) :\\n    - `end1 > start2`, means `start2-end1 < 0` --> we will select two elements that will be common from both the sets.\\n--------------------\\n\\n- To make this approach working first we have to sort all the intervals on the basis of ending time of the intervals.\\n- If intervals overlap we will select only one element from the previous interval because in the next iteration second(common) element will be picked up from the current interval.\\n- If intervals do not overlap then we will select two elements from previous interval only, because elements form the current interval will be selected automatically in the next iteration.\\n-------------------\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n- -------------------\\n\\n# Code\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x:x[1])\\n        size = 0\\n        prev_start = -1\\n        prev_end = -1\\n\\n        for curr_start, curr_end in intervals:\\n            if prev_start == -1 or prev_end < curr_start: #if intervals do not overlap\\n                size += 2\\n                prev_start = curr_end-1\\n                prev_end = curr_end\\n\\n            elif prev_start < curr_start: #if intervals overlap\\n                if prev_end != curr_end:\\n                    prev_start = prev_end\\n                    prev_end = curr_end\\n                    \\n                else:\\n                    prev_start = curr_end-1\\n                    prev_end = curr_end\\n\\n                size += 1\\n\\n        return size\\n\\n        \\n```\\n---------------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x:x[1])\\n        size = 0\\n        prev_start = -1\\n        prev_end = -1\\n\\n        for curr_start, curr_end in intervals:\\n            if prev_start == -1 or prev_end < curr_start: #if intervals do not overlap\\n                size += 2\\n                prev_start = curr_end-1\\n                prev_end = curr_end\\n\\n            elif prev_start < curr_start: #if intervals overlap\\n                if prev_end != curr_end:\\n                    prev_start = prev_end\\n                    prev_end = curr_end\\n                    \\n                else:\\n                    prev_start = curr_end-1\\n                    prev_end = curr_end\\n\\n                size += 1\\n\\n        return size\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482010,
                "title": "java-explained-the-ques-explained-in-detail-the-greedy-process-tc-sc-explained",
                "content": "// In this question, we need to find the SIZE of a SET of numbers which will satisfy the following situation:\\n// The SET should contain ATLEAST 2 numbers from EACH interval\\n\\n// SO we need to make a SET which will have some numbers and amongst those numbers, ATLEAST 2 numbers should be present from EACH interval\\n\\n// Approach\\n// I sorted the intervals[][] array in Increasing order of END Time and if END TIME is same then Decreasing order of START time as well\\n// Ex: [[1,3],[3,7],[5,7],[7,8]]\\n// After sort : [[1,3],[5,7],[3,7],[7,8]]\\n\\n// The best chance of any 2(since minimum 2 needs to be there from each interval) numbers that could possibly be present in ALL the intervals is for the HIGHEST 2 numbers in an interval (if the highest 2 cannot overlap in ALL then no chance that lowest can)\\n// So I store the second highest number and then highest number(these needs to be updated ALL the time)\\n\\n// Inside for loop, I have 3 motives:\\n// 1. if the START of new Interval is HIGHER than the MAX element, this means there was NO common numbers between previous intervals and curr interval, so I UPDATE the 2 max numbers from this interval\\n// 2. If there was 1 OVERLAPPING number, then I UPDATE 1 MAX number from this interval\\n// 3. If there were 2 overlapping numbers, then we DO NOT add anything\\n// AFTER each interval, keep updating max and second max\\n\\n// TC : O(nlogn); sort()\\n// SC : O(1) -> if unable to understand the solution, try looking at this solution with LIST : https://leetcode.com/problems/set-intersection-size-at-least-two/discuss/1050159/Java-13-lines-of-code-Based-on-sorting-the-intervals-TC%3A-O(nlogn)\\n```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        int n = intervals.length;\\n        int res = 2; // minimum 2 sized SET should be there\\n        \\n        // in Increasing order of END Time and if END TIME is same then Decreasing order of START time as well\\n        Arrays.sort(intervals, (a,b) -> a[1] != b[1] ? a[1] - b[1] : b[0] - a[0]);\\n        \\n        int highestValInSet = intervals[0][1]; // max value of first interval\\n        int secondHighestValueInSet = intervals[0][1] - 1; // second max value from first interval\\n        \\n        for(int i = 1; i < n; i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            \\n            if(start > highestValInSet) { // means ther is no common between curr interval and intervals before this\\n                // add 2 new values\\n                // end - 1 first and then end to make the SET SORTED\\n                res += 2;\\n                highestValInSet = intervals[i][1];\\n                secondHighestValueInSet = intervals[i][1] - 1;\\n            } else if(start > secondHighestValueInSet && start <= highestValInSet) { // atleast 1 value from current interval matches with previosu sets\\n                // just add 1 max value\\n                res += 1;\\n                secondHighestValueInSet = highestValInSet; // now second max becomes previous max\\n                highestValInSet = intervals[i][1]; // new max for current interval\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        int n = intervals.length;\\n        int res = 2; // minimum 2 sized SET should be there\\n        \\n        // in Increasing order of END Time and if END TIME is same then Decreasing order of START time as well\\n        Arrays.sort(intervals, (a,b) -> a[1] != b[1] ? a[1] - b[1] : b[0] - a[0]);\\n        \\n        int highestValInSet = intervals[0][1]; // max value of first interval\\n        int secondHighestValueInSet = intervals[0][1] - 1; // second max value from first interval\\n        \\n        for(int i = 1; i < n; i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            \\n            if(start > highestValInSet) { // means ther is no common between curr interval and intervals before this\\n                // add 2 new values\\n                // end - 1 first and then end to make the SET SORTED\\n                res += 2;\\n                highestValInSet = intervals[i][1];\\n                secondHighestValueInSet = intervals[i][1] - 1;\\n            } else if(start > secondHighestValueInSet && start <= highestValInSet) { // atleast 1 value from current interval matches with previosu sets\\n                // just add 1 max value\\n                res += 1;\\n                secondHighestValueInSet = highestValInSet; // now second max becomes previous max\\n                highestValInSet = intervals[i][1]; // new max for current interval\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113082,
                "title": "python-105ms-greedy-clear-and-commented-code",
                "content": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        picks = []\\n        # Sort intervals by ending points\\n        # Greedily select two largest numbers in interval as needed\\n        # KEY: We only need to look at the two largest numbers added thus far (last added) to our picks list.\\n        intervals = sorted(intervals, key=lambda x: x[1])\\n\\n        for start, end in intervals:\\n            if len(picks) == 0 or picks[-1] < start: # No numbers already selected\\n                picks.append(end-1)\\n                picks.append(end)\\n            elif picks[-2] < start:     # One number already selected\\n                if picks[-1] == end:\\n                    picks.append(end-1)\\n                else:\\n                    picks.append(end)\\n            else:                       # picks[-2] and picks[-1] already in picks\\n                continue    \\n\\n        return len(picks)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        picks = []\\n        # Sort intervals by ending points\\n        # Greedily select two largest numbers in interval as needed\\n        # KEY: We only need to look at the two largest numbers added thus far (last added) to our picks list.\\n        intervals = sorted(intervals, key=lambda x: x[1])\\n\\n        for start, end in intervals:\\n            if len(picks) == 0 or picks[-1] < start: # No numbers already selected\\n                picks.append(end-1)\\n                picks.append(end)\\n            elif picks[-2] < start:     # One number already selected\\n                if picks[-1] == end:\\n                    picks.append(end-1)\\n                else:\\n                    picks.append(end)\\n            else:                       # picks[-2] and picks[-1] already in picks\\n                continue    \\n\\n        return len(picks)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240928,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sorting And Greedy***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // sort wrt. end value\\n    \\n    static bool compare(vector<int>& a, vector<int>& b)\\n    {\\n        if(a[1] == b[1])\\n            return a[0] < b[0];\\n        else\\n            return a[1] < b[1];\\n    }\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        \\n        int n = intervals.size();\\n        \\n        // sort the array\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        vector<int> res;\\n        \\n        res.push_back(intervals[0][1] - 1);\\n        \\n        res.push_back(intervals[0][1]);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            int start = intervals[i][0];\\n            \\n            int end = intervals[i][1];\\n            \\n            if(start > res.back())\\n            {\\n                res.push_back(end - 1);\\n                \\n                res.push_back(end);\\n            }\\n            else if(start == res.back())\\n            {\\n                res.push_back(end);\\n            }\\n            else if(start > res[res.size() - 2])\\n            {\\n                res.push_back(end);\\n            }\\n        }\\n        \\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // sort wrt. end value\\n    \\n    static bool compare(vector<int>& a, vector<int>& b)\\n    {\\n        if(a[1] == b[1])\\n            return a[0] < b[0];\\n        else\\n            return a[1] < b[1];\\n    }\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        \\n        int n = intervals.size();\\n        \\n        // sort the array\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        \\n        vector<int> res;\\n        \\n        res.push_back(intervals[0][1] - 1);\\n        \\n        res.push_back(intervals[0][1]);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            int start = intervals[i][0];\\n            \\n            int end = intervals[i][1];\\n            \\n            if(start > res.back())\\n            {\\n                res.push_back(end - 1);\\n                \\n                res.push_back(end);\\n            }\\n            else if(start == res.back())\\n            {\\n                res.push_back(end);\\n            }\\n            else if(start > res[res.size() - 2])\\n            {\\n                res.push_back(end);\\n            }\\n        }\\n        \\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600527,
                "title": "clean-code-with-comments",
                "content": "```\\n/** \\nTaking example of [[1,3],[1,4],[2,5],[3,5]]\\n\\n1) Sort them by end points, if end points match place bigger start point first use this example to understand why ([[1,3],[3,7],[5,7],[7,8]])\\n2) Make an interval of first elements ending and ending - 1\\n3) Traverse the array and total 3 cases can be there:\\n    Case 1:\\n        The starting point of current interval is less than our chosen interval\\'s start (head)\\n        Total overlap, move on\\n    Case 2:\\n        The starting point of current interval is less than our chosen interval\\'s end (tail)\\n        Half overlap, head becomes tail, tail becomes ending of current interval\\'s end\\n    Case 3:\\n        The starting point of current interval is greater than our chosen interval\\'s end\\n        No overlap, we need to reset we again use same strategy of giving ending two points\\n\\n    Diagram:\\n    0  1  2  3  4  5  6  7  8  9 10 11\\n    |--|--|--|--|--|--|--|--|--|--|--|\\n\\n       |-----|\\n       |--------|\\n             |-----|\\n          |--------|\\n\\t\\t  \\n\\tInitial Interval\\n          |--|\\n\\t   head  tail\\n*/\\nint intersectionSizeTwo(vector<vector<int>>& intervals) {\\n    sort(begin(intervals), end(intervals), [] (const auto &l, const auto &r) {\\n        if(l[1] != r[1]) {\\n            return l[1] < r[1];\\n        } else {\\n            return l[0] > r[0];   \\n        }\\n    });\\n    int count = 2;\\n    int head = intervals[0][1] - 1;\\n    int tail = intervals[0][1];\\n    for(const auto &i: intervals) {\\n        if(i[0] <= head) {\\n            continue;\\n        } else if(i[0] <= tail) {\\n            head = tail;\\n            tail = i[1];\\n            count++;\\n        } else {\\n            head = i[1] - 1;\\n            tail = i[1];\\n            count += 2;\\n        }\\n    } \\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n/** \\nTaking example of [[1,3],[1,4],[2,5],[3,5]]\\n\\n1) Sort them by end points, if end points match place bigger start point first use this example to understand why ([[1,3],[3,7],[5,7],[7,8]])\\n2) Make an interval of first elements ending and ending - 1\\n3) Traverse the array and total 3 cases can be there:\\n    Case 1:\\n        The starting point of current interval is less than our chosen interval\\'s start (head)\\n        Total overlap, move on\\n    Case 2:\\n        The starting point of current interval is less than our chosen interval\\'s end (tail)\\n        Half overlap, head becomes tail, tail becomes ending of current interval\\'s end\\n    Case 3:\\n        The starting point of current interval is greater than our chosen interval\\'s end\\n        No overlap, we need to reset we again use same strategy of giving ending two points\\n\\n    Diagram:\\n    0  1  2  3  4  5  6  7  8  9 10 11\\n    |--|--|--|--|--|--|--|--|--|--|--|\\n\\n       |-----|\\n       |--------|\\n             |-----|\\n          |--------|\\n\\t\\t  \\n\\tInitial Interval\\n          |--|\\n\\t   head  tail\\n*/\\nint intersectionSizeTwo(vector<vector<int>>& intervals) {\\n    sort(begin(intervals), end(intervals), [] (const auto &l, const auto &r) {\\n        if(l[1] != r[1]) {\\n            return l[1] < r[1];\\n        } else {\\n            return l[0] > r[0];   \\n        }\\n    });\\n    int count = 2;\\n    int head = intervals[0][1] - 1;\\n    int tail = intervals[0][1];\\n    for(const auto &i: intervals) {\\n        if(i[0] <= head) {\\n            continue;\\n        } else if(i[0] <= tail) {\\n            head = tail;\\n            tail = i[1];\\n            count++;\\n        } else {\\n            head = i[1] - 1;\\n            tail = i[1];\\n            count += 2;\\n        }\\n    } \\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1188366,
                "title": "python-3-compute-o-nlogn-beats-98-see-why-sorting-once-doesn-t-work",
                "content": "The idea is to sort the intervals by end time, then again by start time.\\n\\nAlternatively this can be done in one pass in python.\\n\\n\\nTake <end1, end2> as markers with value -1.\\nAfter that go over the sorted intervals, two cases when you are comparing the intervals\\n1. <..end1,..end2,..s..e> --> adds two new unique items\\n2. <..end1,..s..end2..e>  --> adds one new unique items\\n\\n\\nIf you want to beat 90% you just have to submit several time until one of them shows you are at 98%\\n\\n```\\n\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        ans, end1, end2 = 0, -1, -1\\n\\n        #Option 1 -  Sorting\\n        intervals = sorted(intervals, key=lambda x:(x[1], -x[0]))\\n        \\n        #option 2 - Sorting twice\\n        #intervals = sorted(intervals, key =lambda x:x[0]) #--> Sorting once doesnt work\\n        #intervals = sorted(intervals, key =lambda x:x[1]) #--> Sorting once doesnt work\\n        \\n        for s, e in intervals:\\n            if s > end2 :         #<..end1,..end2,..s..e>\\n                end1, end2 = e-1, e\\n                ans+=2\\n            elif s > end1:         #<..end1,.s..end2..e>\\n                end1, end2 = end2, e\\n                ans+=1\\n        return ans\\n```\\n\\nAll the complexity comes from sorting the intervals.",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        ans, end1, end2 = 0, -1, -1\\n\\n        #Option 1 -  Sorting\\n        intervals = sorted(intervals, key=lambda x:(x[1], -x[0]))\\n        \\n        #option 2 - Sorting twice\\n        #intervals = sorted(intervals, key =lambda x:x[0]) #--> Sorting once doesnt work\\n        #intervals = sorted(intervals, key =lambda x:x[1]) #--> Sorting once doesnt work\\n        \\n        for s, e in intervals:\\n            if s > end2 :         #<..end1,..end2,..s..e>\\n                end1, end2 = e-1, e\\n                ans+=2\\n            elif s > end1:         #<..end1,.s..end2..e>\\n                end1, end2 = end2, e\\n                ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230716,
                "title": "python-5-lines-o-nlogn",
                "content": "```python\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        res, p1, p2 = 0, -float(\\'inf\\'), -float(\\'inf\\') # res is the result, p1 and p2 is 2 current points\\n        for s, e in sorted(intervals, key = lambda i: i[1]): # sort the intervals ascending by their end point\\n            if s > p2: res, p1, p2 = res + 2, e - 1, e\\n            elif p1 < s <= p2: res, p1, p2 = res + 1, p2, e\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        res, p1, p2 = 0, -float(\\'inf\\'), -float(\\'inf\\') # res is the result, p1 and p2 is 2 current points\\n        for s, e in sorted(intervals, key = lambda i: i[1]): # sort the intervals ascending by their end point\\n            if s > p2: res, p1, p2 = res + 2, e - 1, e\\n            elif p1 < s <= p2: res, p1, p2 = res + 1, p2, e\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113090,
                "title": "could-someone-explain-the-expected-output",
                "content": "My code is as below:\\n\\n```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        \\n        vector<pair<int,int>> vec;\\n        int setSize=0;\\n        for (const auto& vecInt: intervals)\\n        {\\n            vec.push_back(make_pair(vecInt[1], vecInt[0]));\\n        }\\n        sort(vec.begin(), vec.end());\\n        // l1 is first element of the set and l2 is the last element in the set.\\n        int l1 = -1, l2 = -1;\\n        for (const auto& Int: vec)\\n        {\\n            if (Int.second >= l2)\\n            {\\n                if (l1 == -1)\\n                {\\n                    l1 = Int.first-1;\\n                    l2 = Int.first;\\n                    setSize+=2;\\n                }\\n                else\\n                {\\n                    setSize+=(Int.second + 1 - l2);\\n                    l2 = Int.second+1;                    \\n                }\\n            }            \\n        }\\n        \\n        return setSize;\\n    }\\n};\\n```\\n\\nCan someone help me understand why the desired output is 5 for this case?\\n[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\n\\nMy code produces 7 and when I manually try, it feels as though the set {6,7,8,9,10,11,12} is the desired one? What is 5 size set for this case?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        \\n        vector<pair<int,int>> vec;\\n        int setSize=0;\\n        for (const auto& vecInt: intervals)\\n        {\\n            vec.push_back(make_pair(vecInt[1], vecInt[0]));\\n        }\\n        sort(vec.begin(), vec.end());\\n        // l1 is first element of the set and l2 is the last element in the set.\\n        int l1 = -1, l2 = -1;\\n        for (const auto& Int: vec)\\n        {\\n            if (Int.second >= l2)\\n            {\\n                if (l1 == -1)\\n                {\\n                    l1 = Int.first-1;\\n                    l2 = Int.first;\\n                    setSize+=2;\\n                }\\n                else\\n                {\\n                    setSize+=(Int.second + 1 - l2);\\n                    l2 = Int.second+1;                    \\n                }\\n            }            \\n        }\\n        \\n        return setSize;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089954,
                "title": "c-easy-solution-sort-by-end-of-interval-time-o-nlogn-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool com(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[1]==b[1])\\n            return a[0]<b[0];\\n        return a[1]<b[1];\\n    }\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& a) {\\n        \\n        int n = a.size(),h,m,f;\\n        vector<int> ans;\\n        sort(a.begin(),a.end(),com);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            h = a[i][1];\\n            m = upper_bound(ans.begin(),ans.end(),h)-ans.begin();\\n            if(m==0)\\n            {\\n                ans.push_back(a[i][1]-1);\\n                ans.push_back(a[i][1]);\\n            }\\n            else\\n            {\\n                m--;\\n                f=0;\\n                while(f!=2&&ans[m]>=a[i][0]&&ans[m]<=a[i][1])\\n                {\\n                    f++;\\n                    m--;\\n                }\\n                if(f==0)\\n                {\\n                    ans.push_back(a[i][1]-1);\\n                    ans.push_back(a[i][1]);\\n                }\\n                else if(f==1)\\n                {\\n                    if(binary_search(ans.begin(),ans.end(),a[i][1]))\\n                    {\\n                        ans.pop_back();\\n                        ans.push_back(a[i][1]-1);\\n                        ans.push_back(a[i][1]);\\n                    }\\n                    else\\n                        ans.push_back(a[i][1]);\\n                }\\n            }\\n        }\\n        int res = ans.size();\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool com(vector<int> &a,vector<int> &b)\\n    {\\n        if(a[1]==b[1])\\n            return a[0]<b[0];\\n        return a[1]<b[1];\\n    }\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& a) {\\n        \\n        int n = a.size(),h,m,f;\\n        vector<int> ans;\\n        sort(a.begin(),a.end(),com);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            h = a[i][1];\\n            m = upper_bound(ans.begin(),ans.end(),h)-ans.begin();\\n            if(m==0)\\n            {\\n                ans.push_back(a[i][1]-1);\\n                ans.push_back(a[i][1]);\\n            }\\n            else\\n            {\\n                m--;\\n                f=0;\\n                while(f!=2&&ans[m]>=a[i][0]&&ans[m]<=a[i][1])\\n                {\\n                    f++;\\n                    m--;\\n                }\\n                if(f==0)\\n                {\\n                    ans.push_back(a[i][1]-1);\\n                    ans.push_back(a[i][1]);\\n                }\\n                else if(f==1)\\n                {\\n                    if(binary_search(ans.begin(),ans.end(),a[i][1]))\\n                    {\\n                        ans.pop_back();\\n                        ans.push_back(a[i][1]-1);\\n                        ans.push_back(a[i][1]);\\n                    }\\n                    else\\n                        ans.push_back(a[i][1]);\\n                }\\n            }\\n        }\\n        int res = ans.size();\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694428,
                "title": "javascript-solution-o-nlogn",
                "content": "\\nOriginal solution is credited to [@yuanzhi247012\\'s Python solution](https://leetcode.com/problems/set-intersection-size-at-least-two/discuss/439986/Python-keep-track-of-the-right-most-2-points) from which I adapted it for JS:\\n\\n```\\n/**\\n * @param {number[][]} intervals\\n * @return {number}\\n */\\nvar intersectionSizeTwo = function(intervals) {\\n    const sortedIntervals = intervals.sort(sortEndsThenStarts)\\n    let currentTail = []\\n    let answer = 0\\n    sortedIntervals.forEach(interval => {\\n        const start = interval[0]\\n        const end = interval[1]\\n        const startPoint = currentTail[0]\\n        const lastPoint = currentTail[1]\\n        \\n        if (!currentTail.length || lastPoint < start){\\n            currentTail = [end -1, end]\\n            answer += 2\\n        } else if ( startPoint < start){\\n            currentTail = [currentTail[1], end]\\n            answer += 1\\n        }\\n\\n    })\\n    return answer\\n\\n};\\n\\nfunction sortEndsThenStarts(intervalA, intervalB){\\n    return intervalA[1] < intervalB[1] ? -1 : 1\\n}\\n```\\n\\nThe intuition here, which I did _not_ find immediately obvious from the description of the problem _or_ the example test cases is that what\\'s of concern is the final numbers that are included and then _minimizing_ the overlap, but not creating a full set between the edges and minimizing _that_.\\n\\nFor example,\\n- The test case of `[[1, 2], [2, 3], [2, 4], [4, 5]]` ends up creating a set `{1,2,3,4,5}` of which the size is `5`.\\n- Contrast that with the example case of `[[1,2],[6,7]]` This creates a set of `{1,2,6,7}` which has a size of `4`. Notably, we do _not_ care about the numbers _between_. \\n\\nThis is why when we get a totally distinct new set (the `start` of the interval is greater than the `lastPoint` of the \"tracked interval\"), we increment by 2 (the smallest amount for which _any_ new set can be tracked), but if it\\'s overlapping, we only increment one to account for the new extension.\\n\\nAlso, peculiarly, the sort function is particular:\\nWhile this work: \\n```\\n\\nfunction sortEndsThenStarts(intervalA, intervalB){\\n    return intervalA[1] < intervalB[1] ? -1 : 1\\n}\\n``` \\nThis fails on one of the tests:\\n```\\n\\nfunction sortEndsThenStarts(intervalA, intervalB){\\n    if(interval[1] === interval[1]){\\n\\t  return intervalA[0] < intervalB[0] ? -1 : 1 \\n\\t}\\n\\treturn intervalA[1] < intervalB[1] ? -1 : 1\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @return {number}\\n */\\nvar intersectionSizeTwo = function(intervals) {\\n    const sortedIntervals = intervals.sort(sortEndsThenStarts)\\n    let currentTail = []\\n    let answer = 0\\n    sortedIntervals.forEach(interval => {\\n        const start = interval[0]\\n        const end = interval[1]\\n        const startPoint = currentTail[0]\\n        const lastPoint = currentTail[1]\\n        \\n        if (!currentTail.length || lastPoint < start){\\n            currentTail = [end -1, end]\\n            answer += 2\\n        } else if ( startPoint < start){\\n            currentTail = [currentTail[1], end]\\n            answer += 1\\n        }\\n\\n    })\\n    return answer\\n\\n};\\n\\nfunction sortEndsThenStarts(intervalA, intervalB){\\n    return intervalA[1] < intervalB[1] ? -1 : 1\\n}\\n```\n```\\n\\nfunction sortEndsThenStarts(intervalA, intervalB){\\n    return intervalA[1] < intervalB[1] ? -1 : 1\\n}\\n```\n```\\n\\nfunction sortEndsThenStarts(intervalA, intervalB){\\n    if(interval[1] === interval[1]){\\n\\t  return intervalA[0] < intervalB[0] ? -1 : 1 \\n\\t}\\n\\treturn intervalA[1] < intervalB[1] ? -1 : 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227116,
                "title": "c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [&](const auto& a, const auto& b) {\\n            if (a[1] != b[1]) {\\n                return a[1] < b[1];\\n            }\\n            else {\\n                return a[0] > b[0]; // (*)\\n            }\\n        });\\n\\n        int count = 2;\\n        int x = intervals[0][1] - 1;\\n        int y = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            const auto start = intervals[i][0];\\n            const auto end = intervals[i][1];\\n            if (y < start) {\\n                count += 2;\\n                x = end - 1;\\n                y = end;\\n            }\\n            else if (x < start) {\\n                assert(y != end); // Guaranteed by sorting left endpoints in reverse (*)\\n                count++;\\n                x = y;\\n                y = end;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [&](const auto& a, const auto& b) {\\n            if (a[1] != b[1]) {\\n                return a[1] < b[1];\\n            }\\n            else {\\n                return a[0] > b[0]; // (*)\\n            }\\n        });\\n\\n        int count = 2;\\n        int x = intervals[0][1] - 1;\\n        int y = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            const auto start = intervals[i][0];\\n            const auto end = intervals[i][1];\\n            if (y < start) {\\n                count += 2;\\n                x = end - 1;\\n                y = end;\\n            }\\n            else if (x < start) {\\n                assert(y != end); // Guaranteed by sorting left endpoints in reverse (*)\\n                count++;\\n                x = y;\\n                y = end;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113088,
                "title": "c-greedy-o-nlogn-with-explanations",
                "content": "Sort the intervals by left endpoints and then remove those that contain others. Greedily pick integers in S as follows: for each interval that does not have enough integers in commons with S, pick the integers at the right end of that interval to be in S because that maximize the chance later intervals already contain them.\\n```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& v) {\\n        //sort by endpoints\\n        sort(v.begin(),v.end(), [](const vector<int>& a1, const vector<int> &a2) {\\n            if (a1[0] != a2[0]) return a1[0] < a2[0];\\n            return a1[1] > a2[1];\\n        });\\n        \\n        //remove intervals that conain others\\n        vector<vector<int>> w;\\n        for (int i = 0; i < v.size(); ++i) {\\n            while (w.size() && w.back()[1] >= v[i][1]) w.pop_back();\\n            w.push_back(v[i]);\\n        }\\n        \\n        //greedily choose integers that are at the right end of intervals that don't have two commont points with S yet.\\n        int x=-1,y=-1;\\n        int ans = 0;\\n        for (auto &b:w) {\\n            int c = 0;\\n            if (x >= b[0] && x <= b[1]) ++c;\\n            if (y >= b[0] && y <= b[1]) ++c;\\n            if (c < 2) {\\n                x = y;\\n                y = b[1];\\n                ++ans;\\n                if (c < 1) {\\n                    if (y-1 < b[0]) return -1;\\n                    x = y - 1;\\n                    ++ans;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& v) {\\n        //sort by endpoints\\n        sort(v.begin(),v.end(), [](const vector<int>& a1, const vector<int> &a2) {\\n            if (a1[0] != a2[0]) return a1[0] < a2[0];\\n            return a1[1] > a2[1];\\n        });\\n        \\n        //remove intervals that conain others\\n        vector<vector<int>> w;\\n        for (int i = 0; i < v.size(); ++i) {\\n            while (w.size() && w.back()[1] >= v[i][1]) w.pop_back();\\n            w.push_back(v[i]);\\n        }\\n        \\n        //greedily choose integers that are at the right end of intervals that don't have two commont points with S yet.\\n        int x=-1,y=-1;\\n        int ans = 0;\\n        for (auto &b:w) {\\n            int c = 0;\\n            if (x >= b[0] && x <= b[1]) ++c;\\n            if (y >= b[0] && y <= b[1]) ++c;\\n            if (c < 2) {\\n                x = y;\\n                y = b[1];\\n                ++ans;\\n                if (c < 1) {\\n                    if (y-1 < b[0]) return -1;\\n                    x = y - 1;\\n                    ++ans;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373169,
                "title": "set-intersection-size-at-least-two-solution-java",
                "content": "class Solution {\\n  public int intersectionSizeTwo(int[][] intervals) {\\n    int ans = 0;\\n    int max = -1;\\n    int secondMax = -1;\\n\\n    Arrays.sort(intervals, (a, b) -> a[1] == b[1] ? b[0] - a[0] : a[1] - b[1]);\\n\\n    for (int[] interval : intervals) {\\n      final int a = interval[0];\\n      final int b = interval[1];\\n      // max and 2nd max still satisfy\\n      if (max >= a && secondMax >= a)\\n        continue;\\n      if (max >= a) { // max still satisfy\\n        secondMax = max;\\n        max = b; // add b to the set S\\n        ans += 1;\\n      } else {             // max and 2nd max can\\'t satisfy\\n        max = b;           // add b to the set S\\n        secondMax = b - 1; // add b - 1 to the set S\\n        ans += 2;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n  public int intersectionSizeTwo(int[][] intervals) {\\n    int ans = 0;\\n    int max = -1;\\n    int secondMax = -1;\\n\\n    Arrays.sort(intervals, (a, b) -> a[1] == b[1] ? b[0] - a[0] : a[1] - b[1]);\\n\\n    for (int[] interval : intervals) {\\n      final int a = interval[0];\\n      final int b = interval[1];\\n      // max and 2nd max still satisfy\\n      if (max >= a && secondMax >= a)\\n        continue;\\n      if (max >= a) { // max still satisfy\\n        secondMax = max;\\n        max = b; // add b to the set S\\n        ans += 1;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2291856,
                "title": "python-2-sorting-orders-with-thought-process-when-being-asked-during-interviews",
                "content": "### Sorting + Greedy\\nThe idea behind this greedy solution is to connect each interval using overlapping intervals, and update the count when there is no overlapping or the number of overlapping elements is less than 2 (equals to 1). \\nHow can we connnect intervals using overlapping? In order to iterate each interval that is potentially overlapping, we can sort intervals first so that the intervals that are close to each other can appear together. \\n\\nBut which orde should we use for the sorting? based on in `start` or `end`? We have to sort in ascending order if based on `end` value, while desending order if based on `start` value. Why? because we need iterate the smallers intervals prior to those intervals covering them. For example, `[2, 5], [3,4]`, if we choose 2 elements from `[3,4]`, we don\\'t need more elements for `[2,5]`. \\nSo we can only care about one side that is decreasing. With this, we have to choose the 2 largest elements that have the most possibiity of overlapping with the next intervals.\\n\\nWhen there is no overlapping, we can just ignor all of elements we have chosen and use the next interval as the initial interval to connect the rest by adding `2` to the count.\\nWhen there is only one overalapping, we ignore the second largest element since it\\'s not overlapping with the next interval. In order to find one more for the next interval, we choose the largest element of the next interval, and then continue the process.\\nThe last case is there is overlapping with more than 1 element, then we don\\'t need to add more elements to intersection, and continue.\\n\\nsort based on `end` point\\n```python\\ndef intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n\\tintervals.sort(key=lambda i: (i[1], -i[0]))\\n\\tcount = 2\\n\\tfirst, second = intervals[0][1] - 1, intervals[0][1]\\n\\tfor a, b in intervals[1:]:\\n\\t\\tif a > second:     \\n\\t\\t\\tcount += 2\\n\\t\\t\\tsecond = max(second, b)\\n\\t\\t\\tfirst = second - 1\\n\\t\\telif first < a <= second:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tfirst = second\\n\\t\\t\\tsecond = max(second, b)\\n\\treturn count       \\n```\\n\\nsort with `start` point, basic symmetic to the solution above\\n```python\\ndef intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n\\tintervals.sort(key=lambda i: (-i[0], i[1]))\\n\\tcount = 2\\n\\tfirst, second = intervals[0][0], intervals[0][0] + 1\\n\\tfor a, b in intervals[1:]:\\n\\t\\tif b < first:     \\n\\t\\t\\tcount += 2\\n\\t\\t\\tfirst = min(first, a)\\n\\t\\t\\tsecond = first + 1\\n\\t\\telif first <= b < second:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tsecond = first\\n\\t\\t\\tfirst = min(first, a)\\n\\treturn count       \\n```\\n\\n*Time Complexity*= **O(NlgN)**\\n*Space Complexity*= **O(1)**",
                "solutionTags": [],
                "code": "```python\\ndef intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n\\tintervals.sort(key=lambda i: (i[1], -i[0]))\\n\\tcount = 2\\n\\tfirst, second = intervals[0][1] - 1, intervals[0][1]\\n\\tfor a, b in intervals[1:]:\\n\\t\\tif a > second:     \\n\\t\\t\\tcount += 2\\n\\t\\t\\tsecond = max(second, b)\\n\\t\\t\\tfirst = second - 1\\n\\t\\telif first < a <= second:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tfirst = second\\n\\t\\t\\tsecond = max(second, b)\\n\\treturn count       \\n```\n```python\\ndef intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n\\tintervals.sort(key=lambda i: (-i[0], i[1]))\\n\\tcount = 2\\n\\tfirst, second = intervals[0][0], intervals[0][0] + 1\\n\\tfor a, b in intervals[1:]:\\n\\t\\tif b < first:     \\n\\t\\t\\tcount += 2\\n\\t\\t\\tfirst = min(first, a)\\n\\t\\t\\tsecond = first + 1\\n\\t\\telif first <= b < second:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tsecond = first\\n\\t\\t\\tfirst = min(first, a)\\n\\treturn count       \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1973256,
                "title": "my-java-solution",
                "content": "```\\n//Time Complexity O(Nlog(N)) - N is the number of intervals\\n//Space Complexity O(N) - N is the number of intervals, can be reduced to O(1) if needed\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        //corner case: can intervals be null or empty? No\\n        \\n        //First, sort the intervals by end, then by reverse order start\\n        Arrays.sort(intervals, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                if (a[1] == b[1]) {\\n                    return b[0] - a[0];\\n                }\\n                return a[1] - b[1];\\n            }\\n        });\\n        \\n        //Second, for each two intervals, greedily find if the previous interval would satisfy next interval\\'s request\\n        List<Integer> list = new ArrayList<>(); //basically the ending set S, btw, we actually do not need this but I use it here for better intuition\\n        \\n        //add last two nums within the range\\n        list.add(intervals[0][1] - 1);\\n        list.add(intervals[0][1]);\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            int lastOne = list.get(list.size() - 1);\\n            int lastTwo = list.get(list.size() - 2);\\n            \\n            int[] interval = intervals[i];\\n            int start = interval[0];\\n            int end = interval[1];\\n            \\n            //if overlaps at least 2\\n            if (lastOne >= start && lastTwo >= start) {\\n                continue;\\n            } else if (lastOne >= start) { //if overlaps 1\\n                list.add(end);\\n            } else { //if not overlapping\\n                list.add(end - 1);\\n                list.add(end);\\n            }\\n        }\\n        \\n        return list.size();        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Time Complexity O(Nlog(N)) - N is the number of intervals\\n//Space Complexity O(N) - N is the number of intervals, can be reduced to O(1) if needed\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        //corner case: can intervals be null or empty? No\\n        \\n        //First, sort the intervals by end, then by reverse order start\\n        Arrays.sort(intervals, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                if (a[1] == b[1]) {\\n                    return b[0] - a[0];\\n                }\\n                return a[1] - b[1];\\n            }\\n        });\\n        \\n        //Second, for each two intervals, greedily find if the previous interval would satisfy next interval\\'s request\\n        List<Integer> list = new ArrayList<>(); //basically the ending set S, btw, we actually do not need this but I use it here for better intuition\\n        \\n        //add last two nums within the range\\n        list.add(intervals[0][1] - 1);\\n        list.add(intervals[0][1]);\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            int lastOne = list.get(list.size() - 1);\\n            int lastTwo = list.get(list.size() - 2);\\n            \\n            int[] interval = intervals[i];\\n            int start = interval[0];\\n            int end = interval[1];\\n            \\n            //if overlaps at least 2\\n            if (lastOne >= start && lastTwo >= start) {\\n                continue;\\n            } else if (lastOne >= start) { //if overlaps 1\\n                list.add(end);\\n            } else { //if not overlapping\\n                list.add(end - 1);\\n                list.add(end);\\n            }\\n        }\\n        \\n        return list.size();        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957577,
                "title": "python-with-explanation",
                "content": "\\n\\n```\\ndef intersectionSizeTwo(self, a: List[List[int]]) -> int:\\n        if len(a)==1:\\n            return 2\\n        a.sort(key=lambda x:x[1])\\n        ans=[a[0][-1]-1,a[0][-1]]\\n        for x in range(1,len(a)):\\n            if a[x][0]<=ans[-2]:\\n                continue\\n\\t\\t    elif a[x][0]<=ans[-1]:\\n                ans.append(a[x][-1])\\n            else:\\n                ans.extend([a[x][-1]-1,a[x][-1]])\\n        return len(ans)\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndef intersectionSizeTwo(self, a: List[List[int]]) -> int:\\n        if len(a)==1:\\n            return 2\\n        a.sort(key=lambda x:x[1])\\n        ans=[a[0][-1]-1,a[0][-1]]\\n        for x in range(1,len(a)):\\n            if a[x][0]<=ans[-2]:\\n                continue\\n\\t\\t    elif a[x][0]<=ans[-1]:\\n                ans.append(a[x][-1])\\n            else:\\n                ans.extend([a[x][-1]-1,a[x][-1]])\\n        return len(ans)\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 524036,
                "title": "java-greedy-solution",
                "content": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals,(a1,a2)->{\\n            if(a1[1]==a2[1]){\\n                return a1[0]-a2[0];\\n            }\\n            return a1[1]-a2[1];\\n        });\\n        List<Integer>res=new ArrayList<>();\\n        res.add(intervals[0][1]-1);res.add(intervals[0][1]);\\n        for(int i=1;i<intervals.length;i++){\\n            int start=intervals[i][0];\\n            int end=intervals[i][1];\\n            if(start>res.get(res.size()-1)){\\n                res.add(end-1);res.add(end);\\n                continue;\\n            } //pass\\n            if(start==res.get(res.size()-1)){\\n                res.add(end);\\n                continue;\\n            }\\n            if(start<res.get(res.size()-1)){\\n                if(res.get(res.size()-1)>=start&&res.get(res.size()-2)>=start){\\n                    continue;\\n                }else{\\n                    res.add(end);\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals,(a1,a2)->{\\n            if(a1[1]==a2[1]){\\n                return a1[0]-a2[0];\\n            }\\n            return a1[1]-a2[1];\\n        });\\n        List<Integer>res=new ArrayList<>();\\n        res.add(intervals[0][1]-1);res.add(intervals[0][1]);\\n        for(int i=1;i<intervals.length;i++){\\n            int start=intervals[i][0];\\n            int end=intervals[i][1];\\n            if(start>res.get(res.size()-1)){\\n                res.add(end-1);res.add(end);\\n                continue;\\n            } //pass\\n            if(start==res.get(res.size()-1)){\\n                res.add(end);\\n                continue;\\n            }\\n            if(start<res.get(res.size()-1)){\\n                if(res.get(res.size()-1)>=start&&res.get(res.size()-2)>=start){\\n                    continue;\\n                }else{\\n                    res.add(end);\\n                }\\n            }\\n        }\\n        return res.size();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178769,
                "title": "9-line-python-solution-o-1-extra-space-detailed-explanation",
                "content": "Basic idea:\\n* 1 Sort\\n\\t* 1.a Sort the array according to their end point in ascending order,\\n  * 1.b If two intervals have same end, sort them according to their start point in descending order.\\n    Example to show why we need 1.b:\\n        We have [1,2], [2, 100] and [99, 100].\\n        Without 1.b, we may get a sorted array like this: [1,2], [2,100], [99,100]\\n        So after processing [1,2], S = [1, 2]\\n        When processing [2, 100] because 2 is already covered in S, we only need to add 100 to S. So we have [1, 2, 100]\\n        Attention: When processing [99, 100] we have to add 99 into S. However, this will break the monotonicity of S, and it would make the algorithm more unefficient and ugly...\\n        \\n       So with 1.b, the sorted array is [1,2], [99,100], [2,100].\\n        Now after processing the first two, we have S = [1, 2, 99, 100]\\n        When processing the third one, we know it\\'s already covered by checking the last two numbers of S.\\n* 2  Greedy to get the rightmost two point.\\n```\\nclass Solution: # O(1) space\\n    def intersectionSizeTwo(self, intervals):\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n        a, b = intervals[0][1]-1, intervals[0][1]\\n        ans = 2\\n        for left, right in intervals:\\n            if a >= left: continue\\n            elif b >= left:\\n                a, b = b, right\\n                ans += 1\\n            else:\\n                a, b = right-1, right\\n                ans += 2\\n        return ans\\n```\\nA more concise solution:\\n```\\nclass Solution: # Concise, but extra space\\n    def intersectionSizeTwo(self, intervals):\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n        S = [intervals[0][1]-1, intervals[0][1]]\\n        for left, right in intervals:\\n            if S[-2] >= left: continue\\n            elif S[-1] >= left: S += [right]\\n            else: S += [right-1, right]\\n        return len(S)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution: # O(1) space\\n    def intersectionSizeTwo(self, intervals):\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n        a, b = intervals[0][1]-1, intervals[0][1]\\n        ans = 2\\n        for left, right in intervals:\\n            if a >= left: continue\\n            elif b >= left:\\n                a, b = b, right\\n                ans += 1\\n            else:\\n                a, b = right-1, right\\n                ans += 2\\n        return ans\\n```\n```\\nclass Solution: # Concise, but extra space\\n    def intersectionSizeTwo(self, intervals):\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n        S = [intervals[0][1]-1, intervals[0][1]]\\n        for left, right in intervals:\\n            if S[-2] >= left: continue\\n            elif S[-1] >= left: S += [right]\\n            else: S += [right-1, right]\\n        return len(S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152106,
                "title": "c-o-nlogn-sort-and-o-n-greedy-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        // sort the intervals\\n        vector<pair<int, int>> v;\\n        for (auto& p : intervals) v.push_back(make_pair(p[0], p[1]));\\n        sort(v.begin(), v.end());\\n        \\n        // remove useless intervals\\n        vector<pair<int, int>> u;\\n        for (auto& p : v) {\\n            while (!u.empty() && p.second <= u.back().second) u.pop_back();\\n            u.push_back(p);\\n        }\\n        \\n        // greedy\\n        // first, select the last two number in interval u[0]\\n        vector<int> result(2, u[0].second);\\n        result[0]--;\\n        \\n        for (auto& p : u) {\\n            //for each interval, discuss whether the last two numbers in [result] would make current interval \"valid\". if not, add the last one or two numbers of the current interval\\n            int a = *(result.end() - 2);\\n            int b = *(result.end() - 1);\\n            if (a >= p.first) continue;\\n            if (b < p.first) {\\n                // push the last two numbers\\n                result.push_back(p.second - 1);\\n            }\\n            // else push the last one number\\n            result.push_back(p.second);\\n        }\\n        return result.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        // sort the intervals\\n        vector<pair<int, int>> v;\\n        for (auto& p : intervals) v.push_back(make_pair(p[0], p[1]));\\n        sort(v.begin(), v.end());\\n        \\n        // remove useless intervals\\n        vector<pair<int, int>> u;\\n        for (auto& p : v) {\\n            while (!u.empty() && p.second <= u.back().second) u.pop_back();\\n            u.push_back(p);\\n        }\\n        \\n        // greedy\\n        // first, select the last two number in interval u[0]\\n        vector<int> result(2, u[0].second);\\n        result[0]--;\\n        \\n        for (auto& p : u) {\\n            //for each interval, discuss whether the last two numbers in [result] would make current interval \"valid\". if not, add the last one or two numbers of the current interval\\n            int a = *(result.end() - 2);\\n            int b = *(result.end() - 1);\\n            if (a >= p.first) continue;\\n            if (b < p.first) {\\n                // push the last two numbers\\n                result.push_back(p.second - 1);\\n            }\\n            // else push the last one number\\n            result.push_back(p.second);\\n        }\\n        return result.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113080,
                "title": "python-o-nlogn",
                "content": "````\\nclass Solution(object):\\n    def intersectionSizeTwo(self, intervals):\\n        max2 = [float('-inf')] * 2\\n        cnt = 0\\n        for lo, hi in sorted(intervals, key=lambda t:t[1]):\\n            intcnt = sum(x>=lo for x in max2)\\n            cnt += 2 - intcnt\\n            if intcnt == 0:\\n                max2 = hi-1, hi\\n            elif intcnt == 1:\\n                max2 = max2[1], hi\\n        return cnt\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution(object):\\n    def intersectionSizeTwo(self, intervals):\\n        max2 = [float('-inf')] * 2\\n        cnt = 0\\n        for lo, hi in sorted(intervals, key=lambda t:t[1]):\\n            intcnt = sum(x>=lo for x in max2)\\n            cnt += 2 - intcnt\\n            if intcnt == 0:\\n                max2 = hi-1, hi\\n            elif intcnt == 1:\\n                max2 = max2[1], hi\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688425,
                "title": "c-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    static bool compare(vector<int>&a, vector<int>&b){\\n        if(a[1]==b[1])return a[0]<b[0];\\n        else return a[1]<b[1];\\n    }\\n\\n    int intersectionSizeTwo(vector<vector<int>>& inter) {\\n        int n = inter.size();\\n\\n        sort(inter.begin(), inter.end(), compare);\\n        vector<int>res;\\n\\n        res.push_back(inter[0][1]-1);\\n        res.push_back(inter[0][1]);\\n\\n        for(int i=1;i<n;i++){\\n            int strt = inter[i][0];\\n            int end = inter[i][1];\\n\\n            if(strt>res.back()){\\n                res.push_back(end-1);\\n                res.push_back(end);\\n            }else if(strt == res.back()){\\n                res.push_back(end);\\n            }else if(strt > res[res.size()-2]){\\n                res.push_back(end);\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    static bool compare(vector<int>&a, vector<int>&b){\\n        if(a[1]==b[1])return a[0]<b[0];\\n        else return a[1]<b[1];\\n    }\\n\\n    int intersectionSizeTwo(vector<vector<int>>& inter) {\\n        int n = inter.size();\\n\\n        sort(inter.begin(), inter.end(), compare);\\n        vector<int>res;\\n\\n        res.push_back(inter[0][1]-1);\\n        res.push_back(inter[0][1]);\\n\\n        for(int i=1;i<n;i++){\\n            int strt = inter[i][0];\\n            int end = inter[i][1];\\n\\n            if(strt>res.back()){\\n                res.push_back(end-1);\\n                res.push_back(end);\\n            }else if(strt == res.back()){\\n                res.push_back(end);\\n            }else if(strt > res[res.size()-2]){\\n                res.push_back(end);\\n            }\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453195,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[1] < b[1] || (a[1] == b[1] && a[0] > b[0]); \\n        });\\n        int n = intervals.size(), ans = 0, p1 = -1, p2 = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (intervals[i][0] <= p1) continue;\\n            if (intervals[i][0] > p2) {\\n                ans += 2;\\n                p2 = intervals[i][1];\\n                p1 = p2-1;\\n            }\\n            else {\\n                ans++;\\n                p1 = p2;\\n                p2 = intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n   def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n      intervals = sorted(intervals, key=lambda x:(x[1], -x[0]))\\n      e1, e2 = -1, -1\\n      ans = 0\\n      for s, e in intervals:\\n         if s > e2:\\n            e1, e2 = e-1, e\\n            ans += 2\\n         elif s > e1:\\n            e1, e2 = e2, e\\n            ans += 1\\n      return ans\\n```\\n\\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        int n = 0;\\n        long[] endStartPairs = new long[intervals.length];\\n        for (int[] interval : intervals) {\\n            endStartPairs[n] = -interval[0] & 0xFFFFFFFFL;\\n            endStartPairs[n++] |= (long) (interval[1]) << 32;\\n        }\\n        Arrays.sort(endStartPairs);\\n        int min = -2;\\n        int max = -1;\\n        int curStart;\\n        int curEnd;\\n        int res = 0;\\n        for (long endStartPair : endStartPairs) {\\n            curStart = -(int) endStartPair;\\n            curEnd = (int) (endStartPair >> 32);\\n            if (curStart <= min) {\\n                continue;\\n            }\\n            if (curStart <= max) {\\n                res += 1;\\n                min = max;\\n            } else {\\n                res += 2;\\n                min = curEnd - 1;\\n            }\\n            max = curEnd;\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[1] < b[1] || (a[1] == b[1] && a[0] > b[0]); \\n        });\\n        int n = intervals.size(), ans = 0, p1 = -1, p2 = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (intervals[i][0] <= p1) continue;\\n            if (intervals[i][0] > p2) {\\n                ans += 2;\\n                p2 = intervals[i][1];\\n                p1 = p2-1;\\n            }\\n            else {\\n                ans++;\\n                p1 = p2;\\n                p2 = intervals[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n   def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n      intervals = sorted(intervals, key=lambda x:(x[1], -x[0]))\\n      e1, e2 = -1, -1\\n      ans = 0\\n      for s, e in intervals:\\n         if s > e2:\\n            e1, e2 = e-1, e\\n            ans += 2\\n         elif s > e1:\\n            e1, e2 = e2, e\\n            ans += 1\\n      return ans\\n```\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        int n = 0;\\n        long[] endStartPairs = new long[intervals.length];\\n        for (int[] interval : intervals) {\\n            endStartPairs[n] = -interval[0] & 0xFFFFFFFFL;\\n            endStartPairs[n++] |= (long) (interval[1]) << 32;\\n        }\\n        Arrays.sort(endStartPairs);\\n        int min = -2;\\n        int max = -1;\\n        int curStart;\\n        int curEnd;\\n        int res = 0;\\n        for (long endStartPair : endStartPairs) {\\n            curStart = -(int) endStartPair;\\n            curEnd = (int) (endStartPair >> 32);\\n            if (curStart <= min) {\\n                continue;\\n            }\\n            if (curStart <= max) {\\n                res += 1;\\n                min = max;\\n            } else {\\n                res += 2;\\n                min = curEnd - 1;\\n            }\\n            max = curEnd;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898177,
                "title": "python-simplest-o-nlogn-sort-and-greedy",
                "content": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda e: (e[1], -e[0]))\\n        res = [intervals[0][1]-1, intervals[0][1]]\\n        for e in intervals[1:]:\\n            if res[-2] < e[0] and res[-1] >= e[0]:\\n                res.append(e[1])\\n            elif e[0] > res[-1]:\\n                res.extend([e[1]-1,e[1]])\\n        return len(res)",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda e: (e[1], -e[0]))\\n        res = [intervals[0][1]-1, intervals[0][1]]\\n        for e in intervals[1:]:\\n            if res[-2] < e[0] and res[-1] >= e[0]:\\n                res.append(e[1])\\n            elif e[0] > res[-1]:\\n                res.extend([e[1]-1,e[1]])\\n        return len(res)",
                "codeTag": "Java"
            },
            {
                "id": 1569350,
                "title": "c-757-set-intersection-size-at-least-two",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](auto& lhs, auto& rhs) {return lhs[1] < rhs[1] || (lhs[1] == rhs[1] && lhs[0] > rhs[0]);}); \\n        int ans = 0, y0 = -1, y1 = -1; \\n        for (auto& interval : intervals) {\\n            int x = interval[0], y = interval[1]; \\n            if (y0 < x && x <= y1) ++ans, y0 = y1, y1 = y; \\n            else if (y1 < x) ans += 2, y0 = y-1, y1 = y; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](auto& lhs, auto& rhs) {return lhs[1] < rhs[1] || (lhs[1] == rhs[1] && lhs[0] > rhs[0]);}); \\n        int ans = 0, y0 = -1, y1 = -1; \\n        for (auto& interval : intervals) {\\n            int x = interval[0], y = interval[1]; \\n            if (y0 < x && x <= y1) ++ans, y0 = y1, y1 = y; \\n            else if (y1 < x) ans += 2, y0 = y-1, y1 = y; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569334,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        ans = []\\n        for x, y in sorted(intervals, key=lambda x: (x[1], -x[0])): \\n            if not ans or ans[-2] < x: \\n                if ans and x <= ans[-1]: ans.append(y)\\n                else: ans.extend([y-1, y])\\n        return len(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        ans = []\\n        for x, y in sorted(intervals, key=lambda x: (x[1], -x[0])): \\n            if not ans or ans[-2] < x: \\n                if ans and x <= ans[-1]: ans.append(y)\\n                else: ans.extend([y-1, y])\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225678,
                "title": "o-nlogn-solution-in-cpp",
                "content": "Sort the intervals upon their lastIndex. Hold the last 2 numbers of the Set. Check the startIndex of the incoming intervals with the lastNumber and secondLastNumber, update them and increase the count accordingly.\\n\\nGreedy Approach is to take as large number as possible in the Set.\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b) {\\n        return a[1] < b[1];    \\n    }\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int count = 2;\\n        int secondLastNumber = intervals[0][1] - 1;\\n        int lastNumber = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] <= secondLastNumber) {\\n                continue;\\n            } else if (intervals[i][0] <= lastNumber) {\\n                count++;\\n                if (lastNumber != intervals[i][1]) {\\n                    secondLastNumber = lastNumber;\\n                    lastNumber = intervals[i][1];                  \\n                } else {\\n                    secondLastNumber = lastNumber - 1;\\n                }\\n\\n            } else {\\n                count += 2;\\n                lastNumber = intervals[i][1];\\n                secondLastNumber = intervals[i][1] - 1;\\n            }   \\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b) {\\n        return a[1] < b[1];    \\n    }\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int count = 2;\\n        int secondLastNumber = intervals[0][1] - 1;\\n        int lastNumber = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] <= secondLastNumber) {\\n                continue;\\n            } else if (intervals[i][0] <= lastNumber) {\\n                count++;\\n                if (lastNumber != intervals[i][1]) {\\n                    secondLastNumber = lastNumber;\\n                    lastNumber = intervals[i][1];                  \\n                } else {\\n                    secondLastNumber = lastNumber - 1;\\n                }\\n\\n            } else {\\n                count += 2;\\n                lastNumber = intervals[i][1];\\n                secondLastNumber = intervals[i][1] - 1;\\n            }   \\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966290,
                "title": "python-solution-o-n-log-n",
                "content": "The old solution of https://leetcode.com/problems/set-intersection-size-at-least-two/discuss/298379/Python3-beat-100 is no longer working so tried to fix it by correctly sorting. \\n```\\nclass Solution(object):\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        intervals.sort(key = lambda (p,q):(q,-p)) #not supported in python3  \\n\\t\\tintervals.sort(key = lambda p:(p[1],-p[0])) #python 3 supported\\n        ans = 0\\n        pre = []\\n        for (s,t) in intervals:\\n            \\n            if not pre or pre[1] < s:\\n                pre = [t-1,t]\\n                ans += 2\\n                \\n            elif pre[0] < s:\\n                pre = [pre[1],t]\\n                ans += 1\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        intervals.sort(key = lambda (p,q):(q,-p)) #not supported in python3  \\n\\t\\tintervals.sort(key = lambda p:(p[1],-p[0])) #python 3 supported\\n        ans = 0\\n        pre = []\\n        for (s,t) in intervals:\\n            \\n            if not pre or pre[1] < s:\\n                pre = [t-1,t]\\n                ans += 2\\n                \\n            elif pre[0] < s:\\n                pre = [pre[1],t]\\n                ans += 1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767649,
                "title": "java-o-nlogn-greedy-fast-solution-sort-the-intervals-beforehand",
                "content": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[1] == b[1] ? b[0] - a[0] : a[1] - b[1]);\\n        \\n        int count = 0;\\n        int first = Integer.MIN_VALUE;\\n        int second = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            int[] interval = intervals[i];\\n            \\n            if (first >= interval[0]) {\\n                continue;\\n            } else if (second >= interval[0]) {\\n                first = second;\\n                second = interval[1];\\n                count += 1;\\n            } else {\\n                first = interval[1] - 1;\\n                second = interval[1];\\n                count += 2;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[1] == b[1] ? b[0] - a[0] : a[1] - b[1]);\\n        \\n        int count = 0;\\n        int first = Integer.MIN_VALUE;\\n        int second = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            int[] interval = intervals[i];\\n            \\n            if (first >= interval[0]) {\\n                continue;\\n            } else if (second >= interval[0]) {\\n                first = second;\\n                second = interval[1];\\n                count += 1;\\n            } else {\\n                first = interval[1] - 1;\\n                second = interval[1];\\n                count += 2;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727840,
                "title": "java-greedy",
                "content": "Ref: https://leetcode.com/problems/set-intersection-size-at-least-two/discuss/113076/Java-O(nlogn)-Solution-Greedy\\n```\\n    public int intersectionSizeTwo(int[][] is) {\\n        Arrays.sort(is, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        Stack<int[]> st = new Stack<>();\\n        for (int[] i : is ) {\\n            while (!st.isEmpty() && st.peek()[1] >= i[1]) st.pop();\\n            st.push(i);\\n        }\\n        LinkedList<int[]> l = new LinkedList<>();\\n        while (!st.isEmpty()) l.addFirst(st.pop());\\n        int res = 2, p1 = l.get(0)[1] - 1, p2 = p1 + 1;\\n        for (int i = 1; i < l.size(); i++) {\\n            boolean c1 = p1 >= l.get(i)[0] && p1 <= l.get(i)[1], c2 = p2 >= l.get(i)[0] && p2 <= l.get(i)[1];\\n            if (c1 && c2) continue;\\n            if (c2) {\\n                p1 = p2;\\n                res++;\\n            } else {\\n                p1 = l.get(i)[1] - 1;\\n                res += 2;\\n            }\\n            p2 = l.get(i)[1];\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int intersectionSizeTwo(int[][] is) {\\n        Arrays.sort(is, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        Stack<int[]> st = new Stack<>();\\n        for (int[] i : is ) {\\n            while (!st.isEmpty() && st.peek()[1] >= i[1]) st.pop();\\n            st.push(i);\\n        }\\n        LinkedList<int[]> l = new LinkedList<>();\\n        while (!st.isEmpty()) l.addFirst(st.pop());\\n        int res = 2, p1 = l.get(0)[1] - 1, p2 = p1 + 1;\\n        for (int i = 1; i < l.size(); i++) {\\n            boolean c1 = p1 >= l.get(i)[0] && p1 <= l.get(i)[1], c2 = p2 >= l.get(i)[0] && p2 <= l.get(i)[1];\\n            if (c1 && c2) continue;\\n            if (c2) {\\n                p1 = p2;\\n                res++;\\n            } else {\\n                p1 = l.get(i)[1] - 1;\\n                res += 2;\\n            }\\n            p2 = l.get(i)[1];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201263,
                "title": "not-most-efficient-but-easy-to-understand",
                "content": "I will give a brief explaination of my idea first.\\nHere are two conclusions that my solution is based on,\\n1. In the interval list, assume A is included in B, then we can simply remove B, since the intersaction between A&S must be a part of the intersaction of B&S.\\n2. Assume the interval list is sorted, and none is fully included in another one. Then currently we have a set S, if the size of the overlapping between S and new interval, we always want to include the largest element from the interval into our set S, which are more likely to be included in the following intervals.\\n\\nTo get the processed interval list, we just need to sort the intervals, and go through the list. After the processing, we just need to go through the whole list. At each time, only two largest elements from the set S need to be tracked. And the size of the set S as well. Since we are using only 3 variables to represent the set S, so we are using O(1) space. And it involves sorting, so the running time should be O(nlogn), in terms of the length of the interval list.\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        sort_interval = sorted(intervals, key = lambda v:(v[0], -v[1]))\\n        \\n        processed_interval = list()\\n        for a, b in sort_interval:\\n            while len(processed_interval) > 0 and b <= processed_interval[-1][-1]:\\n                processed_interval.pop()\\n            processed_interval.append((a, b))\\n            \\n        size = 0\\n        second_last = -1\\n        last_one = -1\\n        for a, b in processed_interval:\\n            if a == b:\\n                return None\\n            else:\\n                if size == 0:\\n                    # first interval encountered\\n                    second_last = b - 1\\n                    last_one = b\\n                    size = 2\\n                else:\\n\\t\\t    # whole interval non-overlap with S, \\n\\t\\t    # include last two from the interval\\n                    if a > last_one:\\n                        last_one = b\\n                        second_last = b - 1\\n                        size += 2\\n    \\t            # the largest one from S is included already\\n                    elif a > second_last:\\n                        second_last = last_one\\n                        last_one = b\\n                        size += 1\\n            \\n        return size\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "I will give a brief explaination of my idea first.\\nHere are two conclusions that my solution is based on,\\n1. In the interval list, assume A is included in B, then we can simply remove B, since the intersaction between A&S must be a part of the intersaction of B&S.\\n2. Assume the interval list is sorted, and none is fully included in another one. Then currently we have a set S, if the size of the overlapping between S and new interval, we always want to include the largest element from the interval into our set S, which are more likely to be included in the following intervals.\\n\\nTo get the processed interval list, we just need to sort the intervals, and go through the list. After the processing, we just need to go through the whole list. At each time, only two largest elements from the set S need to be tracked. And the size of the set S as well. Since we are using only 3 variables to represent the set S, so we are using O(1) space. And it involves sorting, so the running time should be O(nlogn), in terms of the length of the interval list.\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        sort_interval = sorted(intervals, key = lambda v:(v[0], -v[1]))\\n        \\n        processed_interval = list()\\n        for a, b in sort_interval:\\n            while len(processed_interval) > 0 and b <= processed_interval[-1][-1]:\\n                processed_interval.pop()\\n            processed_interval.append((a, b))\\n            \\n        size = 0\\n        second_last = -1\\n        last_one = -1\\n        for a, b in processed_interval:\\n            if a == b:\\n                return None\\n            else:\\n                if size == 0:\\n                    # first interval encountered\\n                    second_last = b - 1\\n                    last_one = b\\n                    size = 2\\n                else:\\n\\t\\t    # whole interval non-overlap with S, \\n\\t\\t    # include last two from the interval\\n                    if a > last_one:\\n                        last_one = b\\n                        second_last = b - 1\\n                        size += 2\\n    \\t            # the largest one from S is included already\\n                    elif a > second_last:\\n                        second_last = last_one\\n                        last_one = b\\n                        size += 1\\n            \\n        return size\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 191344,
                "title": "java-treeset-easy-to-understand",
                "content": "1. Sort by interval\\'s end\\n2. Iterate over intervals checking if set contains two integers in interval\\'s range.\\n2.a If not cotains any, add 2 last integers from the range (highest chance that further interval will contain them)\\n2.b If contains only one integer from the range, add the last integer from the current interval or if it\\'s already there add last - 1.\\n\\nTime: O(n logn), Space: O(n)\\n```\\n public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, Comparator.comparingInt(o -> o[1]));\\n        TreeSet<Integer> set = new TreeSet<>();\\n\\n        for(int[] interval: intervals) {\\n            int start = interval[0];\\n            int end = interval[1];\\n            Integer higher = set.floor(end);                            // lower or equal to end or null\\n            Integer lower = higher != null ? set.lower(higher) : null;  // lower than higher or null\\n\\n            if(higher == null || higher < start) {  // zero integers of that range in set\\n                set.add(end);\\n                set.add(end - 1);\\n            } else if(higher >= start && lower != null && lower < start) { // one element from that range in set\\n                if(set.contains(end)) {\\n                    set.add(end - 1);\\n                } else {\\n                    set.add(end);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n```\\t\\t\\n",
                "solutionTags": [],
                "code": "```\\n public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, Comparator.comparingInt(o -> o[1]));\\n        TreeSet<Integer> set = new TreeSet<>();\\n\\n        for(int[] interval: intervals) {\\n            int start = interval[0];\\n            int end = interval[1];\\n            Integer higher = set.floor(end);                            // lower or equal to end or null\\n            Integer lower = higher != null ? set.lower(higher) : null;  // lower than higher or null\\n\\n            if(higher == null || higher < start) {  // zero integers of that range in set\\n                set.add(end);\\n                set.add(end - 1);\\n            } else if(higher >= start && lower != null && lower < start) { // one element from that range in set\\n                if(set.contains(end)) {\\n                    set.add(end - 1);\\n                } else {\\n                    set.add(end);\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 154209,
                "title": "clean-and-short-python-solution",
                "content": "```\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        intervals.sort(key=lambda x:x[1])\\n        ans=0\\n        l=r=-1\\n        for x,y in intervals:\\n            if x>r:\\n                ans+=2\\n                l,r=y-1,y\\n            elif l<x<=r:\\n                ans+=1\\n                l,r=r,y\\n            else:\\n                pass\\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        intervals.sort(key=lambda x:x[1])\\n        ans=0\\n        l=r=-1\\n        for x,y in intervals:\\n            if x>r:\\n                ans+=2\\n                l,r=y-1,y\\n            elif l<x<=r:\\n                ans+=1\\n                l,r=r,y\\n            else:\\n                pass\\n        return ans\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 114960,
                "title": "java-o-nlogn-solution",
                "content": "1. Sort the array on end value of the range in increasing order. \n2. Keep track of the two elements from each range in a list.\n3. Return the size of the list\n```\nclass Solution {\n    public int intersectionSizeTwo(int[][] intervals) {\n        if(intervals.length == 0) return 0;\n        Arrays.sort(intervals, new Comparator<int[]>(){\n           public int compare(int[] a, int[] b){\n               return a[1]-b[1];\n           } \n        });\n        \n        List<Integer> res = new ArrayList<>();\n        res.add(intervals[0][1]-1);\n        res.add(intervals[0][1]);\n        for(int i=1;i<intervals.length;i++){\n            int lastButOne = res.get(res.size()-2);\n            int last = res.get(res.size()-1);\n            \n            if(lastButOne >= intervals[i][0] && last <= intervals[i][1])\n                continue;\n            if(last<intervals[i][0]){\n                res.add(intervals[i][1]-1);\n                res.add(intervals[i][1]);\n            }else if(lastButOne<intervals[i][0]){\n                res.add(intervals[i][1]);\n            }\n        }\n        \n        return res.size();\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int intersectionSizeTwo(int[][] intervals) {\n        if(intervals.length == 0) return 0;\n        Arrays.sort(intervals, new Comparator<int[]>(){\n           public int compare(int[] a, int[] b){\n               return a[1]-b[1];\n           } \n        });\n        \n        List<Integer> res = new ArrayList<>();\n        res.add(intervals[0][1]-1);\n        res.add(intervals[0][1]);\n        for(int i=1;i<intervals.length;i++){\n            int lastButOne = res.get(res.size()-2);\n            int last = res.get(res.size()-1);\n            \n            if(lastButOne >= intervals[i][0] && last <= intervals[i][1])\n                continue;\n            if(last<intervals[i][0]){\n                res.add(intervals[i][1]-1);\n                res.add(intervals[i][1]);\n            }else if(lastButOne<intervals[i][0]){\n                res.add(intervals[i][1]);\n            }\n        }\n        \n        return res.size();\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 113083,
                "title": "python-99ms-solution-greedy",
                "content": "\\nThis is Python version @JohnsonTau \\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        re = 0\\n        intervals_sorted = sorted(intervals,key=lambda x:x[1])\\n        select_begin,select_end = -1,-1\\n        for interval in intervals_sorted:\\n            cur_begin = interval[0]\\n            cur_end = interval[1]\\n            if cur_begin > select_end:\\n                re += 2\\n                select_begin,select_end = cur_end-1,cur_end\\n            elif cur_begin > select_begin:\\n                re += 1\\n                if select_end==cur_end:\\n                    select_begin = cur_end-1\\n                else:\\n                    select_begin = select_end\\n                select_end = cur_end\\n        return re\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        re = 0\\n        intervals_sorted = sorted(intervals,key=lambda x:x[1])\\n        select_begin,select_end = -1,-1\\n        for interval in intervals_sorted:\\n            cur_begin = interval[0]\\n            cur_end = interval[1]\\n            if cur_begin > select_end:\\n                re += 2\\n                select_begin,select_end = cur_end-1,cur_end\\n            elif cur_begin > select_begin:\\n                re += 1\\n                if select_end==cur_end:\\n                    select_begin = cur_end-1\\n                else:\\n                    select_begin = select_end\\n                select_end = cur_end\\n        return re\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113084,
                "title": "easy-understanding-c-solution-by-maintaining-two-best-points",
                "content": "```\\npublic class Solution\\n{\\n    public int IntersectionSizeTwo(int[,] intervals)\\n    {\\n        List<int[]> input = Load(intervals);\\n        Sort(input);\\n        return Exam(input);\\n    }\\n    \\n    private List<int[]> Load(int[,] intervals)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        for (int i = 0; i < intervals.GetLength(0); i++)\\n        {\\n            result.Add(new int[]{intervals[i, 0], intervals[i, 1]});\\n        }\\n        return result;\\n    }\\n    \\n    private void Sort(List<int[]> list)\\n    {\\n        list.Sort((x1, x2) => {\\n            if (x1[1] == x2[1])\\n            {\\n                return x1[0] - x2[0];\\n            }\\n            return x1[1] - x2[1];\\n        });\\n    }\\n    \\n    private int Exam(List<int[]> list)\\n    {\\n        int result = 2;\\n\\n        // maintain the best two points\\n        int left = list[0][1] - 1, right = list[0][1];\\n        for (int i = 1; i < list.Count; i++)\\n        {\\n            int[] current = list[i];\\n\\n            // check the changes brought by the new interval\\n            int start = current[0], end = current[1];\\n            if (start < right && start > left)\\n            {\\n                result++;\\n                if (end == right)\\n                {\\n                    left = right - 1;\\n                }\\n                else\\n                {\\n                    left = right;\\n                    right = end;\\n                }\\n            }\\n            else if (start == right)\\n            {\\n                result++;\\n                left = right;\\n                right = end;\\n            }\\n            else if (start > right)\\n            {\\n                result += 2;\\n                left = end - 1;\\n                right = end;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int IntersectionSizeTwo(int[,] intervals)\\n    {\\n        List<int[]> input = Load(intervals);\\n        Sort(input);\\n        return Exam(input);\\n    }\\n    \\n    private List<int[]> Load(int[,] intervals)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        for (int i = 0; i < intervals.GetLength(0); i++)\\n        {\\n            result.Add(new int[]{intervals[i, 0], intervals[i, 1]});\\n        }\\n        return result;\\n    }\\n    \\n    private void Sort(List<int[]> list)\\n    {\\n        list.Sort((x1, x2) => {\\n            if (x1[1] == x2[1])\\n            {\\n                return x1[0] - x2[0];\\n            }\\n            return x1[1] - x2[1];\\n        });\\n    }\\n    \\n    private int Exam(List<int[]> list)\\n    {\\n        int result = 2;\\n\\n        // maintain the best two points\\n        int left = list[0][1] - 1, right = list[0][1];\\n        for (int i = 1; i < list.Count; i++)\\n        {\\n            int[] current = list[i];\\n\\n            // check the changes brought by the new interval\\n            int start = current[0], end = current[1];\\n            if (start < right && start > left)\\n            {\\n                result++;\\n                if (end == right)\\n                {\\n                    left = right - 1;\\n                }\\n                else\\n                {\\n                    left = right;\\n                    right = end;\\n                }\\n            }\\n            else if (start == right)\\n            {\\n                result++;\\n                left = right;\\n                right = end;\\n            }\\n            else if (start > right)\\n            {\\n                result += 2;\\n                left = end - 1;\\n                right = end;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113091,
                "title": "c-o-nlogn-greedy-binary-search",
                "content": "```\\nconst int N = 6000 + 10;\\nclass Solution {\\n    int a[N];\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const vector<int> &a, const vector<int> &b){ return a[1] < b[1]; });\\n        int n = 0;\\n        for (auto e : intervals){\\n            //cout << \"(\" << e[0] << \",\" << e[1] << \")\" << endl;\\n            if(n == 0 || e[0] > a[n - 1]){\\n                a[n ++] = e[1] - 1;\\n                a[n ++] = e[1];\\n            }\\n            else{\\n                int l = 0, r = n - 1;\\n                while(l < r){\\n                    int mid = l + ((r -l) >> 1);\\n                    if(a[mid] < e[0])\\n                        l = mid + 1;\\n                    else\\n                        r = mid;\\n                }\\n                if(n - l < 2){\\n                    a[n ++] = e[1];\\n                    int i = n - 1;\\n                    while(i - 1 >= 0 && a[i - 1] == a[i]){\\n                        a[i - 1] --; i--;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nconst int N = 6000 + 10;\\nclass Solution {\\n    int a[N];\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const vector<int> &a, const vector<int> &b){ return a[1] < b[1]; });\\n        int n = 0;\\n        for (auto e : intervals){\\n            //cout << \"(\" << e[0] << \",\" << e[1] << \")\" << endl;\\n            if(n == 0 || e[0] > a[n - 1]){\\n                a[n ++] = e[1] - 1;\\n                a[n ++] = e[1];\\n            }\\n            else{\\n                int l = 0, r = n - 1;\\n                while(l < r){\\n                    int mid = l + ((r -l) >> 1);\\n                    if(a[mid] < e[0])\\n                        l = mid + 1;\\n                    else\\n                        r = mid;\\n                }\\n                if(n - l < 2){\\n                    a[n ++] = e[1];\\n                    int i = n - 1;\\n                    while(i - 1 >= 0 && a[i - 1] == a[i]){\\n                        a[i - 1] --; i--;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3938739,
                "title": "unbeatable-python-code-for-intersection-size-accepted-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem seems to be about finding the minimum number of points that intersect all the given intervals. The code sorts the intervals based on their end points and then iteratively checks the intersections.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Sorting Intervals:** The intervals are sorted by their end points in ascending order, and if two intervals have the same end point, the one with the larger start point comes first. This is done using the lambda function in the sort method.\\nIterating through Intervals: The code then iterates through the sorted intervals and keeps track of the last two points that were added to the result (p1 and p2). Depending on the start and end points of the current interval, the code decides whether to add one or two new points to the result.\\n\\n**Checking Intersection:** If the start of the current interval is greater than p2, two new points are added. If the start is greater than p1 but less than or equal to p2, only one new point is added.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(nlogn),where n is the number of intervals. Sorting the intervals takesO(nlogn) time, and the subsequent iteration takes O(n) time.\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity isO(1), as no additional space is used that grows with the input size.\\n\\n# Code\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n        res = 0\\n        p1, p2 = -1, -1\\n        for s, e in intervals:\\n            if s > p2:\\n                res += 2\\n                p1, p2 = e - 1, e\\n            elif s > p1:\\n                res += 1\\n                p1, p2 = p2, e\\n        return res\\n```\\n# Code Explanation :\\n\\nCode Explanation\\n- intervals.sort(key=lambda x: (x[1], -x[0])): Sorts the intervals by end points, and if two end points are the same, the one with the larger start point comes first.\\n- res = 0; p1, p2 = -1, -1: Initializes the result and the last two points added to the result.\\n- for s, e in intervals: Iterates through the sorted intervals.\\n- if s > p2: If the start of the current interval is greater than p2, two new points are added.\\n- elif s > p1: If the start is greater than p1 but less than or equal to p2, one new point is added.\\n- return res: Returns the result, which is the minimum number of points that intersect all the intervals.\\n- I hope this explanation helps you understand the code! If you have any specific questions or need further clarification on any part, please let me know!\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n        res = 0\\n        p1, p2 = -1, -1\\n        for s, e in intervals:\\n            if s > p2:\\n                res += 2\\n                p1, p2 = e - 1, e\\n            elif s > p1:\\n                res += 1\\n                p1, p2 = p2, e\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810304,
                "title": "91-in-runtime-and-100-in-memory-unique-solution-using-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        # Sort intervals by their end values and start values in descending order\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n\\n        # Initialize the result variable and the last two elements of the containing set\\n        result, last1, last2 = 0, -1, -1\\n\\n        for start, end in intervals:\\n            # Check if the current interval has at least two uncovered numbers\\n            if start > last2:\\n                result += 2\\n                last1, last2 = end - 1, end\\n            # Check if the current interval has only one uncovered number\\n            elif start > last1:\\n                result += 1\\n                last1, last2 = last2, end\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        # Sort intervals by their end values and start values in descending order\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n\\n        # Initialize the result variable and the last two elements of the containing set\\n        result, last1, last2 = 0, -1, -1\\n\\n        for start, end in intervals:\\n            # Check if the current interval has at least two uncovered numbers\\n            if start > last2:\\n                result += 2\\n                last1, last2 = end - 1, end\\n            # Check if the current interval has only one uncovered number\\n            elif start > last1:\\n                result += 1\\n                last1, last2 = last2, end\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630458,
                "title": "sorting-and-arraylist",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the intervals, we add the (end) and (end-1) of the first interval. Then, we look at the boundaries of the interval.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int IntersectionSizeTwo(int[][] intervals) {\\n        Array.Sort(intervals, (a, b) => {\\n            if (a[1] == b[1])\\n                return b[0] - a[0];\\n\\n            return a[1] - b[1];\\n        });\\n\\n        List<int> list = new List<int>\\n        {\\n            intervals[0][1] - 1,\\n            intervals[0][1]\\n        };\\n\\n        for (int i = 1; i < intervals.Length; i++) {\\n            int[] interval = intervals[i];\\n            int start = interval[0];\\n            int end = interval[1];\\n\\n            int lastOne = list[list.Count - 1];\\n            int lastTwo = list[list.Count - 2];\\n\\n            if (start > lastOne) {\\n                list.Add(end - 1);\\n                list.Add(end);\\n            }\\n            else if (start == lastOne || start > lastTwo) \\n                list.Add(end);\\n        }\\n\\n        return list.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IntersectionSizeTwo(int[][] intervals) {\\n        Array.Sort(intervals, (a, b) => {\\n            if (a[1] == b[1])\\n                return b[0] - a[0];\\n\\n            return a[1] - b[1];\\n        });\\n\\n        List<int> list = new List<int>\\n        {\\n            intervals[0][1] - 1,\\n            intervals[0][1]\\n        };\\n\\n        for (int i = 1; i < intervals.Length; i++) {\\n            int[] interval = intervals[i];\\n            int start = interval[0];\\n            int end = interval[1];\\n\\n            int lastOne = list[list.Count - 1];\\n            int lastTwo = list[list.Count - 2];\\n\\n            if (start > lastOne) {\\n                list.Add(end - 1);\\n                list.Add(end);\\n            }\\n            else if (start == lastOne || start > lastTwo) \\n                list.Add(end);\\n        }\\n\\n        return list.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596536,
                "title": "c-detailed-explanation-greedy-sort",
                "content": "In this problem, we need to find a series of non-overlapping intervals such that we collect at least two points within each interval. Therefore, the minimum number of points we need to collect is at least twice the maximum number of non-overlapping intervals. To tackle this problem, we can borrow the approach used in problem 435, \"Non-overlapping Intervals,\" which involves sorting the intervals by their ending points.\\n\\nBy sorting the intervals in ascending order of their ending points (in cases of equal ending points, we consider the interval with the shortest span), we can start by considering the first interval. For this interval, we would select the last two points to add to the set \"S\" because they are the most likely points to overlap with subsequent intervals and are the most efficient choices.\\n\\nNext, we consider the next interval [p,q]. How should we update the set \"S\" at this point?\\n**The most important  and clear observation is that \"q\", which is the right boundary of the interval [p,q] must be greater than or equal to the largest point in the set \"S\".**\\nTherefore, the most influential factor is the starting point of the interval, i.e \"p\".\\n\\nLet\\'s examine the impact of point \"p\" on the set S:\\n1.**If [p, q] covers the last two points in the set S, there is no need to update the set S.**\\n2.**If [p, q] only covers the last point in the set S, that point must be the boundary of the set S. In this case, S needs to add an additional point. The best choice for this additional point is the last point of [p, q], which is q. This approach is the most \"greedy\" because it maximizes the chance of overlap with intervals that come after [p, q].**\\n3.**If [p,q] does not cover S at all, we simply need to add the last two points of [p, q] to S, again using a greedy strategy,i.e q and q-1.**\\nIn summary, we only need to pay attention to the last two points in the set S. By continuously comparing them with the next interval [p, q] and updating S accordingly, we can solve the problem.\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a,vector<int>& b){\\n        if(a[1]!=b[1]){\\n            return a[1]<b[1];\\n        }\\n        else{\\n            return a[0]>b[0];\\n        }\\n    }\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        \\n        int ct=2;\\n        int i=0;\\n        int a=intervals[0][1]-1,b=intervals[0][1];\\n        for(;i<intervals.size();i++){\\n            if(intervals[i][0]<=a){\\n               continue;\\n            }\\n            else if(intervals[i][0]>b){\\n                ct+=2;\\n                a=intervals[i][1]-1;\\n                b=intervals[i][1];\\n            }\\n            \\n            else if(intervals[i][0]<=b){\\n                ct+=1;\\n                a=b;\\n                b=intervals[i][1];\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        \\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a,vector<int>& b){\\n        if(a[1]!=b[1]){\\n            return a[1]<b[1];\\n        }\\n        else{\\n            return a[0]>b[0];\\n        }\\n    }\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        \\n        int ct=2;\\n        int i=0;\\n        int a=intervals[0][1]-1,b=intervals[0][1];\\n        for(;i<intervals.size();i++){\\n            if(intervals[i][0]<=a){\\n               continue;\\n            }\\n            else if(intervals[i][0]>b){\\n                ct+=2;\\n                a=intervals[i][1]-1;\\n                b=intervals[i][1];\\n            }\\n            \\n            else if(intervals[i][0]<=b){\\n                ct+=1;\\n                a=b;\\n                b=intervals[i][1];\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        \\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562197,
                "title": "c-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy approach.\\nAlways keeping an account of two largest elements in the intermediate subset and use these to check for any overlap with next interval in ordered intervals.\\n\\n# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(begin(intervals), end(intervals), [](const vector<int>& v1, const vector<int>& v2){\\n            return v1[1] < v2[1] || (v2[1] == v1[1] && v2[0] < v1[0]);\\n        });\\n\\n        vector<int> largest{intervals.front()[1]-1, intervals.front()[1]};\\n        int setsize = 2;\\n        for(int i=1;i<intervals.size();++i) {\\n            //  check how many of largest / second largest overlap with the new set\\n            int overlapCount = getOverlap(intervals[i], largest);\\n\\n            switch(overlapCount) {\\n                case 0:\\n                    largest[1] = intervals[i][1];\\n                    largest[0] = intervals[i][1]-1;\\n                    setsize +=2;\\n                    break;\\n\\n                case 1:\\n                    largest[0] = largest[1];\\n                    largest[1] = intervals[i][1];\\n                    setsize += 1;\\n                    break;\\n                case 2:\\n                default:\\n                    break;\\n            }\\n        }\\n        return setsize;\\n    }\\n\\n    int getOverlap(const vector<int>& interval,const vector<int>& largest) {\\n        if(largest[1] < interval[0])\\n            return 0;\\n\\n        if(largest[0] < interval[0])\\n            return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(begin(intervals), end(intervals), [](const vector<int>& v1, const vector<int>& v2){\\n            return v1[1] < v2[1] || (v2[1] == v1[1] && v2[0] < v1[0]);\\n        });\\n\\n        vector<int> largest{intervals.front()[1]-1, intervals.front()[1]};\\n        int setsize = 2;\\n        for(int i=1;i<intervals.size();++i) {\\n            //  check how many of largest / second largest overlap with the new set\\n            int overlapCount = getOverlap(intervals[i], largest);\\n\\n            switch(overlapCount) {\\n                case 0:\\n                    largest[1] = intervals[i][1];\\n                    largest[0] = intervals[i][1]-1;\\n                    setsize +=2;\\n                    break;\\n\\n                case 1:\\n                    largest[0] = largest[1];\\n                    largest[1] = intervals[i][1];\\n                    setsize += 1;\\n                    break;\\n                case 2:\\n                default:\\n                    break;\\n            }\\n        }\\n        return setsize;\\n    }\\n\\n    int getOverlap(const vector<int>& interval,const vector<int>& largest) {\\n        if(largest[1] < interval[0])\\n            return 0;\\n\\n        if(largest[0] < interval[0])\\n            return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509693,
                "title": "done",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        # Sort intervals by their end values and start values in descending order\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n\\n        # Initialize the result variable and the last two elements of the containing set\\n        result, last1, last2 = 0, -1, -1\\n\\n        for start, end in intervals:\\n            # Check if the current interval has at least two uncovered numbers\\n            if start > last2:\\n                result += 2\\n                last1, last2 = end - 1, end\\n            # Check if the current interval has only one uncovered number\\n            elif start > last1:\\n                result += 1\\n                last1, last2 = last2, end\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        # Sort intervals by their end values and start values in descending order\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n\\n        # Initialize the result variable and the last two elements of the containing set\\n        result, last1, last2 = 0, -1, -1\\n\\n        for start, end in intervals:\\n            # Check if the current interval has at least two uncovered numbers\\n            if start > last2:\\n                result += 2\\n                last1, last2 = end - 1, end\\n            # Check if the current interval has only one uncovered number\\n            elif start > last1:\\n                result += 1\\n                last1, last2 = last2, end\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453761,
                "title": "golang-sort-and-greedy-18ms",
                "content": "```\\npackage main\\n\\nimport \"sort\"\\n\\nfunc intersectionSizeTwo(intervals [][]int) int {\\n\\tsort.Slice(intervals, func(i, j int) bool {\\n\\t\\tif intervals[i][1] == intervals[j][1] {\\n\\t\\t\\treturn intervals[i][0] > intervals[j][0]\\n\\t\\t}\\n\\t\\treturn intervals[i][1] < intervals[j][1]\\n\\t})\\n\\n\\ta := -1\\n\\tb := -1\\n\\n\\tans := 0\\n\\tfor _, interval := range intervals {\\n\\t\\tstart := interval[0]\\n\\t\\tend := interval[1]\\n\\n\\t\\tif start > b {\\n\\t\\t\\t// If the current interval start is greater than the last recorded end, record new 2 points (end-1, end)\\n\\t\\t\\ta, b = end-1, end\\n\\t\\t\\tans += 2\\n\\t\\t} else if start > a {\\n\\t\\t\\t// If current interval start lies in (a,b], we can update b to the current end, and update a to b.  \\n\\t\\t\\ta, b = b, end\\n\\t\\t\\tans++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport \"sort\"\\n\\nfunc intersectionSizeTwo(intervals [][]int) int {\\n\\tsort.Slice(intervals, func(i, j int) bool {\\n\\t\\tif intervals[i][1] == intervals[j][1] {\\n\\t\\t\\treturn intervals[i][0] > intervals[j][0]\\n\\t\\t}\\n\\t\\treturn intervals[i][1] < intervals[j][1]\\n\\t})\\n\\n\\ta := -1\\n\\tb := -1\\n\\n\\tans := 0\\n\\tfor _, interval := range intervals {\\n\\t\\tstart := interval[0]\\n\\t\\tend := interval[1]\\n\\n\\t\\tif start > b {\\n\\t\\t\\t// If the current interval start is greater than the last recorded end, record new 2 points (end-1, end)\\n\\t\\t\\ta, b = end-1, end\\n\\t\\t\\tans += 2\\n\\t\\t} else if start > a {\\n\\t\\t\\t// If current interval start lies in (a,b], we can update b to the current end, and update a to b.  \\n\\t\\t\\ta, b = b, end\\n\\t\\t\\tans++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3399152,
                "title": "time-o-nlog-n-o-nlogn-space-o-1-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n    int ans = 0;\\n    int max = -1;\\n    int secondMax = -1;\\n\\n    sort(begin(intervals), end(intervals), [](const auto& a, const auto& b) {\\n      return a[1] == b[1] ? a[0] > b[0] : a[1] < b[1];\\n    });\\n\\n    for (const vector<int>& interval : intervals) {\\n      const int a = interval[0];\\n      const int b = interval[1];\\n      // Max and 2nd max still satisfy\\n      if (max >= a && secondMax >= a)\\n        continue;\\n      if (max >= a) {  // Max still satisfy\\n        secondMax = max;\\n        max = b;  // Add b to the set S\\n        ans += 1;\\n      } else {              // Max and 2nd max can\\'t satisfy\\n        max = b;            // Add b to the set S\\n        secondMax = b - 1;  // Add b - 1 to the set S\\n        ans += 2;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n    int ans = 0;\\n    int max = -1;\\n    int secondMax = -1;\\n\\n    sort(begin(intervals), end(intervals), [](const auto& a, const auto& b) {\\n      return a[1] == b[1] ? a[0] > b[0] : a[1] < b[1];\\n    });\\n\\n    for (const vector<int>& interval : intervals) {\\n      const int a = interval[0];\\n      const int b = interval[1];\\n      // Max and 2nd max still satisfy\\n      if (max >= a && secondMax >= a)\\n        continue;\\n      if (max >= a) {  // Max still satisfy\\n        secondMax = max;\\n        max = b;  // Add b to the set S\\n        ans += 1;\\n      } else {              // Max and 2nd max can\\'t satisfy\\n        max = b;            // Add b to the set S\\n        secondMax = b - 1;  // Add b - 1 to the set S\\n        ans += 2;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329673,
                "title": "greedy-using-treeset",
                "content": "```\\npublic int intersectionSizeTwo(int[][] intervals) {\\n        //similar to https://leetcode.com/problems/minimum-time-to-complete-all-tasks/\\n        /* the best strategy is to finish it as late as possible.\\n        That way, we have the best chance for the num to be reused by intervals that end later.\\n        */\\n        TreeSet<Integer> set = new TreeSet<>();\\n        Arrays.sort(intervals,(a,b)->(a[1] - b[1]));\\n        int ans = 0;\\n        for(int[] i : intervals){\\n            int s = i[0];\\n            int e = i[1];\\n            int contains = 0;\\n            Integer key = set.ceiling(s);\\n            while(key != null && key <= e){\\n                contains++;\\n                key = set.higher(key);\\n            }\\n            int add = e;\\n            while(contains < 2){\\n                while(set.contains(add)) add--;\\n                while(!set.contains(add) && contains < 2) {\\n                    set.add(add--);\\n                    ans++;\\n                    contains++;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\npublic int intersectionSizeTwo(int[][] intervals) {\\n        //similar to https://leetcode.com/problems/minimum-time-to-complete-all-tasks/\\n        /* the best strategy is to finish it as late as possible.\\n        That way, we have the best chance for the num to be reused by intervals that end later.\\n        */\\n        TreeSet<Integer> set = new TreeSet<>();\\n        Arrays.sort(intervals,(a,b)->(a[1] - b[1]));\\n        int ans = 0;\\n        for(int[] i : intervals){\\n            int s = i[0];\\n            int e = i[1];\\n            int contains = 0;\\n            Integer key = set.ceiling(s);\\n            while(key != null && key <= e){\\n                contains++;\\n                key = set.higher(key);\\n            }\\n            int add = e;\\n            while(contains < 2){\\n                while(set.contains(add)) add--;\\n                while(!set.contains(add) && contains < 2) {\\n                    set.add(add--);\\n                    ans++;\\n                    contains++;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3251484,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        if len(intervals) == 1:\\n            return 2\\n\\n        intervals.sort(key = lambda x:(x[1],-x[0]))\\n\\n        total, ans = 0, []\\n\\n        for s,e in intervals:\\n            if not ans or s > ans[1]:\\n                total += 2\\n                ans = [e-1,e]\\n            elif ans[0] < s <= ans[1]:\\n                total += 1\\n                ans = [ans[1],e]\\n\\n        return total\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        if len(intervals) == 1:\\n            return 2\\n\\n        intervals.sort(key = lambda x:(x[1],-x[0]))\\n\\n        total, ans = 0, []\\n\\n        for s,e in intervals:\\n            if not ans or s > ans[1]:\\n                total += 2\\n                ans = [e-1,e]\\n            elif ans[0] < s <= ans[1]:\\n                total += 1\\n                ans = [ans[1],e]\\n\\n        return total\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217596,
                "title": "alternative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis problem can be considered a shooting game, use minimum bullet to shoot all balloons(intervals)\\nin the first round, each interval is shot once.\\nin the second round, each interval is shot again.\\nyou should shoot minimum bullets in each round.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\u5148\\u628A\\u5168\\u90E8\\u5340\\u9593\\u7528\\u6700\\u5C11\\u6B21\\u6578\\u5C04\\u4E00\\u6B21\\n\\u628A\\u5C04\\u7684\\u5730\\u65B9\\u8A18\\u8D77\\u4F86\\uFF0C\\u4E4B\\u5F8C\\u4E0D\\u53EF\\u5C04\\n\\u518D\\u7528\\u6700\\u5C0F\\u6B21\\u6578\\u5C04\\u4E00\\u6B21\\n\\u53EF\\u4EE5\\u8B49\\u660E\\u9019\\u6A23\\u662Fminimum\\u7684\\nshoot all intervals with least bullet\\nthen put the shootplaces in vector, you can\\'t shoot anypalce in vector\\nthen shoot all intervals again with least bullet\\nthis greedy algorithm can be proveed to be correct\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        vector<pair<int,int>> inter1;\\n         vector<pair<int,int>> inter2;\\n        for(auto i:intervals){\\n            inter1.push_back(make_pair(i[0],i[1]));\\n        }\\n        sort(inter1.begin(),inter1.end());\\n        int start=0;\\n       vector<int> cut;\\n        int ans=0;\\n        int minf=200000000;\\n        for(int i=0;i<inter1.size();i++){\\n            minf=min(minf,inter1[i].second);\\n            if(minf<inter1[i].first){\\n                \\n                ans++;\\n                cut.push_back(minf);\\n                minf=inter1[i].second;\\n  \\n                start=i;\\n            }\\n        }\\n        cut.push_back(minf);\\n        ans++;\\n        start=0;\\n        for(int i=0;i<inter1.size();i++){\\n            minf=min(minf,inter1[i].second);\\n            for (auto j:cut){\\n                if(j==minf){\\n                    minf--;\\n                    break;\\n                }\\n            }\\n            if(minf<inter1[i].first){\\n                \\n                ans++;\\n                \\n                minf=inter1[i].second;\\n             for (auto j:cut){\\n                if(j==minf){\\n                    minf--;\\n                    break;\\n                }\\n            }\\n                start=i;\\n            }\\n        }\\n        ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        vector<pair<int,int>> inter1;\\n         vector<pair<int,int>> inter2;\\n        for(auto i:intervals){\\n            inter1.push_back(make_pair(i[0],i[1]));\\n        }\\n        sort(inter1.begin(),inter1.end());\\n        int start=0;\\n       vector<int> cut;\\n        int ans=0;\\n        int minf=200000000;\\n        for(int i=0;i<inter1.size();i++){\\n            minf=min(minf,inter1[i].second);\\n            if(minf<inter1[i].first){\\n                \\n                ans++;\\n                cut.push_back(minf);\\n                minf=inter1[i].second;\\n  \\n                start=i;\\n            }\\n        }\\n        cut.push_back(minf);\\n        ans++;\\n        start=0;\\n        for(int i=0;i<inter1.size();i++){\\n            minf=min(minf,inter1[i].second);\\n            for (auto j:cut){\\n                if(j==minf){\\n                    minf--;\\n                    break;\\n                }\\n            }\\n            if(minf<inter1[i].first){\\n                \\n                ans++;\\n                \\n                minf=inter1[i].second;\\n             for (auto j:cut){\\n                if(j==minf){\\n                    minf--;\\n                    break;\\n                }\\n            }\\n                start=i;\\n            }\\n        }\\n        ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068473,
                "title": "hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n^)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals,new Comparator<int[]>(){\\n            public int compare(int[]a,int[]b)\\n            {\\n                return a[1]-b[1];\\n            }\\n        });\\n        Set<Integer>set=new HashSet<>();\\n        for(int[]arr:intervals)\\n        {\\n            int l=arr[0];\\n            int r=arr[1];\\n            int count=0;\\n            //System.out.println(arr[0]+\" \"+arr[1]);\\n            //System.out.println(set);\\n            for(Integer ele:set)\\n            {\\n                if(l<=ele&&r>=ele) count++;\\n                if(count==2) break;\\n            }\\n            while(count<2) \\n            {\\n                if(set.contains(r)) {r--; continue;}\\n                set.add(r);\\n                r--;\\n                count++;\\n            }\\n        }\\n        //System.out.println(\"At exit \"+set);\\n        return set.size();\\n    }\\n}\\n// 2 3 4\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals,new Comparator<int[]>(){\\n            public int compare(int[]a,int[]b)\\n            {\\n                return a[1]-b[1];\\n            }\\n        });\\n        Set<Integer>set=new HashSet<>();\\n        for(int[]arr:intervals)\\n        {\\n            int l=arr[0];\\n            int r=arr[1];\\n            int count=0;\\n            //System.out.println(arr[0]+\" \"+arr[1]);\\n            //System.out.println(set);\\n            for(Integer ele:set)\\n            {\\n                if(l<=ele&&r>=ele) count++;\\n                if(count==2) break;\\n            }\\n            while(count<2) \\n            {\\n                if(set.contains(r)) {r--; continue;}\\n                set.add(r);\\n                r--;\\n                count++;\\n            }\\n        }\\n        //System.out.println(\"At exit \"+set);\\n        return set.size();\\n    }\\n}\\n// 2 3 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042438,
                "title": "o-nlogn-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is that we need to find a way to maximize the number of points that are included in the intersection of all intervals. We can do this by selecting the intervals that have the most overlap with other intervals, and then selecting the points that have the most overlap with other intervals within those intervals.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to first sort the intervals based on their end points, and then iterate through the intervals and select the points that have the most overlap with other intervals. We can do this by keeping track of the last two points selected in the intersection, and only adding a new point if it is not already covered by the last two points.\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n        ans = []\\n        for i in intervals:\\n            if not ans or ans[-1] < i[0]:\\n                ans.append(i[1]-1)\\n                ans.append(i[1])\\n            elif ans[-2] < i[0]:\\n                ans.append(i[1])\\n        return len(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n        ans = []\\n        for i in intervals:\\n            if not ans or ans[-1] < i[0]:\\n                ans.append(i[1]-1)\\n                ans.append(i[1])\\n            elif ans[-2] < i[0]:\\n                ans.append(i[1])\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934198,
                "title": "python3-concise-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        ans = []\\n        for x, y in sorted(intervals, key=lambda x: (x[1], -x[0])): \\n            if not ans or ans[-2] < x: \\n                if ans and x <= ans[-1]: ans.append(y)\\n                else: ans.extend([y-1, y])\\n        return len(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        ans = []\\n        for x, y in sorted(intervals, key=lambda x: (x[1], -x[0])): \\n            if not ans or ans[-2] < x: \\n                if ans and x <= ans[-1]: ans.append(y)\\n                else: ans.extend([y-1, y])\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911951,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn intersection_size_two(intervals: Vec<Vec<i32>>) -> i32 {\\n        fn inside(x: i32, interval: &[i32]) -> bool {\\n            interval[0] <= x && x <= interval[1]\\n        }\\n\\n        let mut intervals = intervals;\\n        intervals.sort_by(|a, b| if a[0] != b[0] { a[0].cmp(&b[0]) } else { b[1].cmp(&a[1]) });\\n        let mut n = 0;\\n        for interval in intervals.clone() {\\n            while n > 0 && interval[1] <= intervals[n - 1][1] {\\n                n -= 1;\\n            }\\n            intervals[n] = interval;\\n            n += 1;\\n        }\\n        let mut cnt = 0;\\n        let mut x = -1;\\n        let mut y = -1;\\n        for item in intervals.iter().take(n) {\\n            if !inside(y, item) {\\n                cnt += 2;\\n                x = item[1] - 1;\\n                y = x + 1;\\n            } else if !inside(x, item) {\\n                cnt += 1;\\n                x = y;\\n                y = item[1];\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn intersection_size_two(intervals: Vec<Vec<i32>>) -> i32 {\\n        fn inside(x: i32, interval: &[i32]) -> bool {\\n            interval[0] <= x && x <= interval[1]\\n        }\\n\\n        let mut intervals = intervals;\\n        intervals.sort_by(|a, b| if a[0] != b[0] { a[0].cmp(&b[0]) } else { b[1].cmp(&a[1]) });\\n        let mut n = 0;\\n        for interval in intervals.clone() {\\n            while n > 0 && interval[1] <= intervals[n - 1][1] {\\n                n -= 1;\\n            }\\n            intervals[n] = interval;\\n            n += 1;\\n        }\\n        let mut cnt = 0;\\n        let mut x = -1;\\n        let mut y = -1;\\n        for item in intervals.iter().take(n) {\\n            if !inside(y, item) {\\n                cnt += 2;\\n                x = item[1] - 1;\\n                y = x + 1;\\n            } else if !inside(x, item) {\\n                cnt += 1;\\n                x = y;\\n                y = item[1];\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2906224,
                "title": "python-greedy-fast-short-documented",
                "content": "# Intuition\\r\\n- If A contains B, A is fulfilled as long as B is fulfilled, ignore A\\r\\n- now we have only partially overlapped (or not) intervals, sorted\\r\\n- what needs to be done should be done, just greedily choose number to added to `nums` from each intervals\\r\\n- according to `nums` we can know how much shortage we need\\r\\n- we can choose any numbers in current interval, but the right most one may have change to reduce shortage of next interval, so.\\r\\n\\r\\n# Approach\\r\\n- make a equivalent simpliest intervals, sorted\\r\\n- from sorted intervals, we do:\\r\\n  - check previous two num in `nums`\\r\\n  - find out how much shortage we need (compare to current interval)\\r\\n  - add right most numbers (#shortage) to `nums`\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n$$O(nlogn)$$ COZ sorted\\r\\n- Space complexity:\\r\\n$$O(n)$$\\r\\n\\r\\n```Vote if you think it\\'s usefull``` \\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def intersectionSizeTwo(self, intervals):\\r\\n        # make a equivalent simpliest intervals\\r\\n        itvls = []\\r\\n        for itvl in sorted(intervals, key=lambda e: (e[0], -e[1])):\\r\\n            while itvls and itvls[-1][1] >= itvl[1]:\\r\\n                itvls.pop()\\r\\n            itvls.append(itvl)\\r\\n\\r\\n        # greedily choose right most number from each interval to form nums\\r\\n        # according to two most possible number to fulfill current interval in nums\\r\\n        # we can determine how much shortage current interval needs\\r\\n        nums = []\\r\\n        for l, r in itvls:\\r\\n            lack = 2\\r\\n            if nums: lack -= (l <= nums[-2] <= r) + (l <= nums[-1] <= r)\\r\\n\\r\\n            for i in range(lack): nums.append(r - i)\\r\\n\\r\\n        return len(nums)\\r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```Vote if you think it\\'s usefull```\n```\\r\\nclass Solution:\\r\\n    def intersectionSizeTwo(self, intervals):\\r\\n        # make a equivalent simpliest intervals\\r\\n        itvls = []\\r\\n        for itvl in sorted(intervals, key=lambda e: (e[0], -e[1])):\\r\\n            while itvls and itvls[-1][1] >= itvl[1]:\\r\\n                itvls.pop()\\r\\n            itvls.append(itvl)\\r\\n\\r\\n        # greedily choose right most number from each interval to form nums\\r\\n        # according to two most possible number to fulfill current interval in nums\\r\\n        # we can determine how much shortage current interval needs\\r\\n        nums = []\\r\\n        for l, r in itvls:\\r\\n            lack = 2\\r\\n            if nums: lack -= (l <= nums[-2] <= r) + (l <= nums[-1] <= r)\\r\\n\\r\\n            for i in range(lack): nums.append(r - i)\\r\\n\\r\\n        return len(nums)\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876186,
                "title": "python3-using-sorting",
                "content": "class Solution:\\n\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x:x[1])\\n        prev_start = prev_end = -1\\n        res = 0\\n        for curr_start,curr_end in intervals:\\n            if prev_start == -1 or prev_end<curr_start: #no overlap\\n                res+=2\\n                prev_end = curr_end\\n                prev_start = curr_end - 1\\n            elif prev_start<curr_start: #overlap but not subset\\n                res+=1\\n                if prev_end == curr_end:\\n                    prev_start = curr_end - 1\\n                else:\\n                    prev_start = prev_end\\n                prev_end = curr_end\\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x:x[1])\\n        prev_start = prev_end = -1\\n        res = 0\\n        for curr_start,curr_end in intervals:\\n            if prev_start == -1 or prev_end<curr_start: #no overlap\\n                res+=2\\n                prev_end = curr_end\\n                prev_start = curr_end - 1\\n            elif prev_start<curr_start: #overlap but not subset\\n                res+=1\\n                if prev_end == curr_end:\\n                    prev_start = curr_end - 1\\n                else:\\n                    prev_start = prev_end\\n                prev_end = curr_end\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2781392,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    bool static cmp(vector<int> &a, vector<int> &b)\\n    {\\n        return (a[1] < b[1] || (a[1] == b[1] && a[0] > b[0]));\\n    }\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) \\n    {\\n        \\n        sort(intervals.begin(),intervals.end(),cmp);\\n        \\n        int ans = 0, p1 = -1, p2 = -1, n = intervals.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(intervals[i][0] <= p1)\\n            {\\n                continue;\\n            }\\n            \\n            if(intervals[i][0] > p2)\\n            {\\n                ans = ans + 2;\\n                \\n                p2 = intervals[i][1];\\n                p1 = p2 - 1;\\n            }\\n            else\\n            {\\n                ans++;\\n                p1 = p2;\\n                p2 = intervals[i][1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool static cmp(vector<int> &a, vector<int> &b)\\n    {\\n        return (a[1] < b[1] || (a[1] == b[1] && a[0] > b[0]));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2711760,
                "title": "3-cases-sorting-solution-explained-python",
                "content": "```\\ndef intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n    \\n    #sort intervals by ending\\n    intervals.sort(key=lambda x: x[1])\\n\\n    #p, pp represent the last two points in our set\\n    pp, p = -1, -1\\n    ans = 0\\n    for s,e in intervals:\\n        if s <= pp: #curr interval fully covers both pp, p\\n            continue\\n        elif s <= p: #curr interval only covers p\\n            #pp = min(p, e-1) instead of pp = p doesnt affect the correctness of the solution,\\n            #but if you were trying to gather all the points in a set then it matters.\\n            pp = min(p, e-1)  \\n            p = e\\n            ans += 1\\n        else: #curr interval doesnt cover anything\\n            pp = e-1\\n            p = e\\n            ans += 2\\n    return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\ndef intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n    \\n    #sort intervals by ending\\n    intervals.sort(key=lambda x: x[1])\\n\\n    #p, pp represent the last two points in our set\\n    pp, p = -1, -1\\n    ans = 0\\n    for s,e in intervals:\\n        if s <= pp: #curr interval fully covers both pp, p\\n            continue\\n        elif s <= p: #curr interval only covers p\\n            #pp = min(p, e-1) instead of pp = p doesnt affect the correctness of the solution,\\n            #but if you were trying to gather all the points in a set then it matters.\\n            pp = min(p, e-1)  \\n            p = e\\n            ans += 1\\n        else: #curr interval doesnt cover anything\\n            pp = e-1\\n            p = e\\n            ans += 2\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2624698,
                "title": "easy-greedy-with-bst-in-python",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(list(set((s, e) for s, e in intervals)), key=lambda x: (x[1], x[0]))\\n        tree = SortedList(intervals)\\n        remains = {(s, e): 2 for s, e in intervals}\\n        answer = set()\\n        for s, e in intervals:\\n            if remains[(s, e)] == 2 or (remains[(s, e)] == 1 and e in answer):\\n                to_dec = list(tree.irange((-inf, -inf), (e-1, inf)))\\n                for s2, e2 in to_dec:\\n                    remains[(s2, e2)] -= 1\\n                    if remains[(s2, e2)] == 0:\\n                        tree.remove((s2, e2))\\n                answer.add(e-1)\\n            if remains[(s, e)] == 1:\\n                to_dec = list(tree.irange((-inf, -inf), (e, inf)))\\n                for s2, e2 in to_dec:\\n                    remains[(s2, e2)] -= 1\\n                    if remains[(s2, e2)] == 0:\\n                        tree.remove((s2, e2))\\n                answer.add(e)\\n        return len(answer)\\n            \\n                \\n                \\n        \\n        \\n",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(list(set((s, e) for s, e in intervals)), key=lambda x: (x[1], x[0]))\\n        tree = SortedList(intervals)\\n        remains = {(s, e): 2 for s, e in intervals}",
                "codeTag": "Java"
            },
            {
                "id": 2573951,
                "title": "greedy",
                "content": "```python\\n\\'\\'\\'\\ngreedily select the largest two towards the end of an interval\\nfor the best chance of intersecting with more intervals next\\nO(nlogn), O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        # sort intervals by end\\n        # and by start for the same end, in order to process shorter interval first\\n        # (if an selection of largest two elements satisfies the shorter interval, it will do for the longer for sure)\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n        \\n        res = 0\\n        largest_two = None\\n        for interval in intervals:\\n            # neither of the largest two elements intersect with interval, update largest two elements\\n            if not largest_two or largest_two[1] < interval[0]:\\n                largest_two = [interval[1] - 1, interval[1]]\\n                res += 2\\n            else:\\n                # both of the largest two elements intersect with interval\\n                if largest_two[0] >= interval[0]:\\n                    continue\\n                # only the largest element intersects with interval, update largest two elements\\n                elif largest_two[1] >= interval[0]:\\n                    largest_two = [largest_two[1], interval[1]]\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\n\\'\\'\\'\\ngreedily select the largest two towards the end of an interval\\nfor the best chance of intersecting with more intervals next\\nO(nlogn), O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        # sort intervals by end\\n        # and by start for the same end, in order to process shorter interval first\\n        # (if an selection of largest two elements satisfies the shorter interval, it will do for the longer for sure)\\n        intervals.sort(key=lambda x: (x[1], -x[0]))\\n        \\n        res = 0\\n        largest_two = None\\n        for interval in intervals:\\n            # neither of the largest two elements intersect with interval, update largest two elements\\n            if not largest_two or largest_two[1] < interval[0]:\\n                largest_two = [interval[1] - 1, interval[1]]\\n                res += 2\\n            else:\\n                # both of the largest two elements intersect with interval\\n                if largest_two[0] >= interval[0]:\\n                    continue\\n                # only the largest element intersects with interval, update largest two elements\\n                elif largest_two[1] >= interval[0]:\\n                    largest_two = [largest_two[1], interval[1]]\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550984,
                "title": "greedy-point-cover-c",
                "content": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        greedy:\\n        \\n        1. sort by right end\\n        2. assign points in order\\n        \\n          |------oo|\\n                     -------|\\n                  \\n        for the next interval we have 3 cases:\\n        \\n            |----------| cover two points before\\n                  |---------| cover only one point (add one point to the end of interval)\\n                     |--------| cover no point (add two points to the end of interval)\\n                     \\n        keep track the index of the last two points assigned\\n    */\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& lhs, const vector<int>& rhs) {\\n            // why lhs[0] > rhs[0] when lhs[1] == rhs[1], since if we solve the case for lhs[0] is maximum, those with left\\n            // end less than lhs[0] will be solved. We do not need to check if right end is covered when assigning a new point\\n            if (lhs[1] == rhs[1]) return lhs[0] > rhs[0];\\n            return lhs[1] < rhs[1];\\n        });\\n        \\n        int res = 0, first = -1, second = -1;\\n        for (auto interval : intervals) {\\n            int left = interval[0], right = interval[1];\\n            if (left > first) {\\n                res += 2;\\n                first = right, second = right - 1;\\n            } else if (left > second) {\\n                res += 1;\\n                if (right > first) {\\n                    second = first, first = right;\\n                } else {\\n                    second = right;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        greedy:\\n        \\n        1. sort by right end\\n        2. assign points in order\\n        \\n          |------oo|\\n                     -------|\\n                  \\n        for the next interval we have 3 cases:\\n        \\n            |----------| cover two points before\\n                  |---------| cover only one point (add one point to the end of interval)\\n                     |--------| cover no point (add two points to the end of interval)\\n                     \\n        keep track the index of the last two points assigned\\n    */\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& lhs, const vector<int>& rhs) {\\n            // why lhs[0] > rhs[0] when lhs[1] == rhs[1], since if we solve the case for lhs[0] is maximum, those with left\\n            // end less than lhs[0] will be solved. We do not need to check if right end is covered when assigning a new point\\n            if (lhs[1] == rhs[1]) return lhs[0] > rhs[0];\\n            return lhs[1] < rhs[1];\\n        });\\n        \\n        int res = 0, first = -1, second = -1;\\n        for (auto interval : intervals) {\\n            int left = interval[0], right = interval[1];\\n            if (left > first) {\\n                res += 2;\\n                first = right, second = right - 1;\\n            } else if (left > second) {\\n                res += 1;\\n                if (right > first) {\\n                    second = first, first = right;\\n                } else {\\n                    second = right;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417398,
                "title": "lazy-bitset-sol-add-a-1-and-a-1-1",
                "content": "I use bitset to count the number of elements between an interval, but before I do that, I applied rank transformation to all the elements so that the max element is `<= 6000`. Interestingly, this does not affect the outcome of answer at all.\\n\\nWhy is rank transformation needed for bitset? It is becase bitset\\'s performance is positively correlated to the size of element in it. `1 <= n <= 6000` may be a `O(20)` operation while `n <= 100000000` may be a `O(100000000/32)` operations and will TLE.\\n\\n#### Java\\n```Java\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] A) {\\n        Arrays.sort(A, Comparator.<int[]>comparingInt(o -> o[1]).thenComparingInt(o -> -o[0]));\\n        List<Integer> list = new ArrayList<>();\\n        for (int[] a : A){\\n            list.add(a[0]);\\n            list.add(a[1]);\\n        }\\n        Collections.sort(list);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int l : list){ // this is the rank for each number\\n            map.putIfAbsent(l, map.size());\\n        }\\n        BitSet bit = new BitSet();\\n        for (int[] a : A){\\n            a[0]=map.get(a[0]); // put the rank in\\n            a[1]=map.get(a[1]); // put the rank in\\n            int got = bit.get(a[0],a[1]+1).cardinality();\\n            if (got <= 0){\\n                bit.set(a[1]-1);\\n            }\\n            if (got <= 1){\\n                bit.set(a[1]);\\n            }\\n        }\\n        return bit.cardinality();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] A) {\\n        Arrays.sort(A, Comparator.<int[]>comparingInt(o -> o[1]).thenComparingInt(o -> -o[0]));\\n        List<Integer> list = new ArrayList<>();\\n        for (int[] a : A){\\n            list.add(a[0]);\\n            list.add(a[1]);\\n        }\\n        Collections.sort(list);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int l : list){ // this is the rank for each number\\n            map.putIfAbsent(l, map.size());\\n        }\\n        BitSet bit = new BitSet();\\n        for (int[] a : A){\\n            a[0]=map.get(a[0]); // put the rank in\\n            a[1]=map.get(a[1]); // put the rank in\\n            int got = bit.get(a[0],a[1]+1).cardinality();\\n            if (got <= 0){\\n                bit.set(a[1]-1);\\n            }\\n            if (got <= 1){\\n                bit.set(a[1]);\\n            }\\n        }\\n        return bit.cardinality();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315440,
                "title": "confused-about-the-test-case-and-accepted-solutions",
                "content": "I am confused about one test case [[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]. It seems to me that we at least have to include number 7 and 11, since we have two disjoined set [3, 7] and [11, 12]. This already gives 5 numbers (that is 7, 8, 9, 10, 11). Moreover, since we require \\'the intersection of S with A has a size of at least two.\\', that means, we have more than 5 numbers due to [3, 7] and [11, 12]. However, all the accepted solutions and test answer showed me 5?! Am I missing something? Thanks.",
                "solutionTags": [],
                "code": "I am confused about one test case [[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]. It seems to me that we at least have to include number 7 and 11, since we have two disjoined set [3, 7] and [11, 12]. This already gives 5 numbers (that is 7, 8, 9, 10, 11). Moreover, since we require \\'the intersection of S with A has a size of at least two.\\', that means, we have more than 5 numbers due to [3, 7] and [11, 12]. However, all the accepted solutions and test answer showed me 5?! Am I missing something? Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 2314747,
                "title": "interval-scheduling-by-sorting-should-not-be-a-hard-problem",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](auto& a, auto& b) {\\n\\t\\t\\treturn a[1] == b[1] ? a[0] > b[0] : a[1] < b[1];\\n\\t\\t});\\n\\t\\tint a = -1, b = -1, res = intervals.size() * 2;\\n\\t\\tfor (const auto& s : intervals) {\\n\\t\\t\\tif (a >= s[0] && b <= s[1]) {\\n\\t\\t\\t\\tres -= 2;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (b < s[0]) {\\n\\t\\t\\t\\ta = s[1] - 1, b = s[1];\\n\\t\\t\\t} else if (a < s[0]) {\\n\\t\\t\\t\\ta = b;\\n\\t\\t\\t\\tb = s[1];\\n\\t\\t\\t\\tres--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](auto& a, auto& b) {\\n\\t\\t\\treturn a[1] == b[1] ? a[0] > b[0] : a[1] < b[1];\\n\\t\\t});\\n\\t\\tint a = -1, b = -1, res = intervals.size() * 2;\\n\\t\\tfor (const auto& s : intervals) {\\n\\t\\t\\tif (a >= s[0] && b <= s[1]) {\\n\\t\\t\\t\\tres -= 2;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (b < s[0]) {\\n\\t\\t\\t\\ta = s[1] - 1, b = s[1];\\n\\t\\t\\t} else if (a < s[0]) {\\n\\t\\t\\t\\ta = b;\\n\\t\\t\\t\\tb = s[1];\\n\\t\\t\\t\\tres--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2281243,
                "title": "sorting-time-o-nlogn-space-o-n",
                "content": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, A: List[List[int]]) -> int:\\n        A.sort(key=lambda x:(x[1],-x[0]))\\n        ans = []\\n        ans.append(A[0][1]-1)\\n        ans.append(A[0][1])\\n        n = len(A)\\n        # print(A)\\n        for i in range(1,n):\\n            if A[i][0]>ans[-1]:\\n                ans.append(A[i][1]-1)\\n                ans.append(A[i][1])\\n            elif A[i][0]>ans[-2]:\\n                ans.append(A[i][1])\\n        # print(ans)\\n        return len(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, A: List[List[int]]) -> int:\\n        A.sort(key=lambda x:(x[1],-x[0]))\\n        ans = []\\n        ans.append(A[0][1]-1)\\n        ans.append(A[0][1])\\n        n = len(A)\\n        # print(A)\\n        for i in range(1,n):\\n            if A[i][0]>ans[-1]:\\n                ans.append(A[i][1]-1)\\n                ans.append(A[i][1])\\n            elif A[i][0]>ans[-2]:\\n                ans.append(A[i][1])\\n        # print(ans)\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257963,
                "title": "simple-sort-solution",
                "content": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda s: [s[1], -s[0]])\\n        res, large, small = 0, float(\\'-inf\\'), float(\\'-inf\\')\\n        for inter in intervals:\\n            start, end = inter[0], inter[1]\\n            if large >= start and small >= start: continue\\n            elif large >= start:\\n                res += 1\\n                large, small = end, large\\n            else:\\n                res += 2\\n                large, small = end, end - 1\\n        return res\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda s: [s[1], -s[0]])\\n        res, large, small = 0, float(\\'-inf\\'), float(\\'-inf\\')\\n        for inter in intervals:\\n            start, end = inter[0], inter[1]\\n            if large >= start and small >= start: continue\\n            elif large >= start:\\n                res += 1\\n                large, small = end, large\\n            else:\\n                res += 2\\n                large, small = end, end - 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197271,
                "title": "python-sort-greedy",
                "content": "sort of the interval ending points, greedily pick the last two points for most potential hits.\\nthree scenarios:\\n(1) non-overlap with the previous interval;\\n(2) only one point hit, and need add the second point, end-1;\\n(3) need pay atttention to tht two consecutive intervals with the same ending points;\\n(4)already hit by the last two points.\\n\\n```\\ndef intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:[x[1],x[0]])\\n        s=[]\\n        s.append(intervals[0][1]-1)\\n        s.append(intervals[0][1])\\n        for i in range(1,len(intervals)):\\n            st,ed=intervals[i][0], intervals[i][1]\\n            if st>s[-1]: ## nonoverlap\\n                s.append(ed-1)\\n                s.append(ed)\\n            elif st<=s[-1] and st>s[-2]:\\n                if ed>s[-1]:\\n                    s.append(ed)\\n                elif ed==s[-1]:\\n                    s[-1]=ed-1\\n                    s.append(ed)\\n        return len(s)",
                "solutionTags": [],
                "code": "sort of the interval ending points, greedily pick the last two points for most potential hits.\\nthree scenarios:\\n(1) non-overlap with the previous interval;\\n(2) only one point hit, and need add the second point, end-1;\\n(3) need pay atttention to tht two consecutive intervals with the same ending points;\\n(4)already hit by the last two points.\\n\\n```\\ndef intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:[x[1],x[0]])\\n        s=[]\\n        s.append(intervals[0][1]-1)\\n        s.append(intervals[0][1])\\n        for i in range(1,len(intervals)):\\n            st,ed=intervals[i][0], intervals[i][1]\\n            if st>s[-1]: ## nonoverlap\\n                s.append(ed-1)\\n                s.append(ed)\\n            elif st<=s[-1] and st>s[-2]:\\n                if ed>s[-1]:\\n                    s.append(ed)\\n                elif ed==s[-1]:\\n                    s[-1]=ed-1\\n                    s.append(ed)\\n        return len(s)",
                "codeTag": "Python3"
            },
            {
                "id": 1797570,
                "title": "golang-simple-solution-beat-100-with-comments",
                "content": "```go\\nfunc intersectionSizeTwo(intervals [][]int) int {\\n\\tsort.Slice(intervals, func(i, j int) bool {\\n\\t\\tif intervals[i][1] == intervals[j][1] {\\n\\t\\t\\treturn intervals[i][0] > intervals[j][0]\\n\\t\\t}\\n\\t\\treturn intervals[i][1] < intervals[j][1]\\n\\t})\\n\\tcount := 2\\n\\tfirst, second := intervals[0][1], intervals[0][1]-1\\n\\tfor i := 1; i < len(intervals); i++ {\\n\\t\\tif intervals[i][1] < first || intervals[i][0] > first {\\n\\t\\t\\t// first is invalid, re-assign first\\n\\t\\t\\t// set second by first\\n\\t\\t\\tfirst, second = intervals[i][1], first\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t\\tif intervals[i][1] < second || intervals[i][0] > second {\\n\\t\\t\\t// second is invalid, re-assign second\\n\\t\\t\\tsecond = intervals[i][1]\\n\\t\\t\\tcount++\\n\\t\\t\\tif second == first {\\n\\t\\t\\t\\t// same as first, set by first-1\\n\\t\\t\\t\\tsecond = first-1\\n\\t\\t\\t} else if second > first {\\n\\t\\t\\t\\t// sort\\n\\t\\t\\t\\tfirst, second = second, first\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc intersectionSizeTwo(intervals [][]int) int {\\n\\tsort.Slice(intervals, func(i, j int) bool {\\n\\t\\tif intervals[i][1] == intervals[j][1] {\\n\\t\\t\\treturn intervals[i][0] > intervals[j][0]\\n\\t\\t}\\n\\t\\treturn intervals[i][1] < intervals[j][1]\\n\\t})\\n\\tcount := 2\\n\\tfirst, second := intervals[0][1], intervals[0][1]-1\\n\\tfor i := 1; i < len(intervals); i++ {\\n\\t\\tif intervals[i][1] < first || intervals[i][0] > first {\\n\\t\\t\\t// first is invalid, re-assign first\\n\\t\\t\\t// set second by first\\n\\t\\t\\tfirst, second = intervals[i][1], first\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t\\tif intervals[i][1] < second || intervals[i][0] > second {\\n\\t\\t\\t// second is invalid, re-assign second\\n\\t\\t\\tsecond = intervals[i][1]\\n\\t\\t\\tcount++\\n\\t\\t\\tif second == first {\\n\\t\\t\\t\\t// same as first, set by first-1\\n\\t\\t\\t\\tsecond = first-1\\n\\t\\t\\t} else if second > first {\\n\\t\\t\\t\\t// sort\\n\\t\\t\\t\\tfirst, second = second, first\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796364,
                "title": "c-sweep-line-solution-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    enum { START, END };\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        vector<vector<int>> points;\\n        for (int i = 0; i < intervals.size(); ++i) {\\n            points.push_back({ intervals[i][0], START, i });\\n            points.push_back({ intervals[i][1], END, i });\\n        }        \\n        \\n        sort(points.begin(), points.end());\\n        \\n        vector<int> count(intervals.size(), 0);\\n        unordered_set<int> targetSet; // target set matches the requirment\\n        unordered_set<int> activeSet; // intervals intersecting with current sweeping line\\n\\n        for (int i = 0; i < points.size(); ++i) {\\n            int type = points[i][1];\\n            int pos = points[i][0];\\n            int idx = points[i][2];\\n            \\n            if (type == START) {\\n                activeSet.insert(idx);\\n                continue;\\n            }\\n            // find elements within active intervals\\n            for (int j = pos; j >= intervals[idx][0] && count[idx] < 2; --j) {\\n                if (targetSet.count(j)) continue;\\n\\n                targetSet.insert(j);\\n\\n                for (auto in: activeSet) {\\n                    if (count[in] < 2 && j >= intervals[in][0] && j <= intervals[in][1]) {\\n                        count[in]++;\\n                    }\\n                }\\n            }\\n\\n            activeSet.erase(idx);\\n        }\\n        \\n        return targetSet.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    enum { START, END };\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        vector<vector<int>> points;\\n        for (int i = 0; i < intervals.size(); ++i) {\\n            points.push_back({ intervals[i][0], START, i });\\n            points.push_back({ intervals[i][1], END, i });\\n        }        \\n        \\n        sort(points.begin(), points.end());\\n        \\n        vector<int> count(intervals.size(), 0);\\n        unordered_set<int> targetSet; // target set matches the requirment\\n        unordered_set<int> activeSet; // intervals intersecting with current sweeping line\\n\\n        for (int i = 0; i < points.size(); ++i) {\\n            int type = points[i][1];\\n            int pos = points[i][0];\\n            int idx = points[i][2];\\n            \\n            if (type == START) {\\n                activeSet.insert(idx);\\n                continue;\\n            }\\n            // find elements within active intervals\\n            for (int j = pos; j >= intervals[idx][0] && count[idx] < 2; --j) {\\n                if (targetSet.count(j)) continue;\\n\\n                targetSet.insert(j);\\n\\n                for (auto in: activeSet) {\\n                    if (count[in] < 2 && j >= intervals[in][0] && j <= intervals[in][1]) {\\n                        count[in]++;\\n                    }\\n                }\\n            }\\n\\n            activeSet.erase(idx);\\n        }\\n        \\n        return targetSet.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684774,
                "title": "clear-concise-code",
                "content": "```class Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        \\n        int n = intervals.length;\\n        Arrays.sort(intervals, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[1] != b[1]) return a[1] - b[1];\\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        Set<Integer>[] total = new HashSet[n];\\n        for (int j = 0; j < n; j++) total[j] = new HashSet<>();\\n        int ans = 0;\\n        int i = 0;\\n//         for (int j = 0; j < n; j++) {\\n//             System.out.println(Arrays.toString(intervals[j]));\\n//         }\\n        \\n        while (i < n) {\\n            if (total[i].size() >= 2) {\\n                i++;\\n                continue;\\n            }\\n            if (total[i].size() == 0) {\\n                int val1 = intervals[i][1];\\n                int val2 = intervals[i][1]-1;\\n                //System.out.println(val1 + \" \" + val2);\\n                for (int j = i; j < n; j++) {\\n                    if (intervals[j][0] <= val1 && intervals[j][1] >= val1) {\\n                        total[j].add(val1);\\n                    }\\n                    if (intervals[j][0] <= val2 && intervals[j][1] >= val2) {\\n                        total[j].add(val2);\\n                    }\\n                }\\n                ans += 2;\\n            } else if (total[i].size() == 1) {\\n                int val = !total[i].contains(intervals[i][1]) ? intervals[i][1] : intervals[i][1]-1;\\n                //System.out.println(val);\\n                for (int j = i; j < n; j++) {\\n                    if (intervals[j][0] <= val && intervals[j][1] >= val) {\\n                        total[j].add(val);\\n                    }\\n                }\\n                ans += 1;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        \\n        int n = intervals.length;\\n        Arrays.sort(intervals, new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[1] != b[1]) return a[1] - b[1];\\n                return a[0] - b[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1206760,
                "title": "scala-o-nlogn-solution",
                "content": "```\\nimport scala.util.Sorting\\n\\nobject Solution {\\n    def intersectionSizeTwo(intervals: Array[Array[Int]]): Int = {\\n        \\n        Sorting.quickSort(intervals)(new Ordering[Array[Int]]{\\n            def compare(x: Array[Int], y: Array[Int]) = {\\n                if(x(1)==y(1)){\\n                    y(0) compare x(0)\\n                }else{\\n                    x(1) compare y(1)\\n                }\\n            }\\n            \\n        })\\n        \\n        val n = intervals.length\\n        \\n        var min=0\\n        var largest = -1\\n        var second = -1\\n        \\n        (0 until n).foreach(i=>{\\n            var a = intervals(i)(0)\\n            var b = intervals(i)(1)\\n            var isLargestIn = a<=largest\\n            var isSecondIn = a<=second\\n            if(!isLargestIn||(!isSecondIn)){\\n                min = if(isLargestIn) min+1 else min+2\\n                second = if(isLargestIn) largest else b-1\\n                largest = b\\n            }\\n        })\\n        \\n        min\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nimport scala.util.Sorting\\n\\nobject Solution {\\n    def intersectionSizeTwo(intervals: Array[Array[Int]]): Int = {\\n        \\n        Sorting.quickSort(intervals)(new Ordering[Array[Int]]{\\n            def compare(x: Array[Int], y: Array[Int]) = {\\n                if(x(1)==y(1)){\\n                    y(0) compare x(0)\\n                }else{\\n                    x(1) compare y(1)\\n                }\\n            }\\n            \\n        })\\n        \\n        val n = intervals.length\\n        \\n        var min=0\\n        var largest = -1\\n        var second = -1\\n        \\n        (0 until n).foreach(i=>{\\n            var a = intervals(i)(0)\\n            var b = intervals(i)(1)\\n            var isLargestIn = a<=largest\\n            var isSecondIn = a<=second\\n            if(!isLargestIn||(!isSecondIn)){\\n                min = if(isLargestIn) min+1 else min+2\\n                second = if(isLargestIn) largest else b-1\\n                largest = b\\n            }\\n        })\\n        \\n        min\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1163623,
                "title": "a-simple-solution-with-proper-naming",
                "content": "We can sort intervals with end and simply keep two pointers. We need to figure out whenever we must any of two pointers and increment result;\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic int intersectionSizeTwo(int[][] intervals) {\\n        \\n        Arrays.sort(intervals,(a1,a2)->a1[1]-a2[1]);\\n        \\n        // always keep check of last two elements in result set\\n        int secondLast = intervals[0][1]-1;\\n        int last = secondLast+1;\\n        int ans = 2;\\n        for(int i=1;i<intervals.length;i++){\\n            int start=intervals[i][0];\\n            int end=intervals[i][1];\\n            if(start>last){\\n                last = end;\\n                secondLast = end-1;\\n                ans +=2;\\n            }\\n            else if(start==last || (start<last && start > secondLast)){\\n                secondLast = last;\\n                last = end;\\n                ans += 1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n\\t}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic int intersectionSizeTwo(int[][] intervals) {\\n        \\n        Arrays.sort(intervals,(a1,a2)->a1[1]-a2[1]);\\n        \\n        // always keep check of last two elements in result set\\n        int secondLast = intervals[0][1]-1;\\n        int last = secondLast+1;\\n        int ans = 2;\\n        for(int i=1;i<intervals.length;i++){\\n            int start=intervals[i][0];\\n            int end=intervals[i][1];\\n            if(start>last){\\n                last = end;\\n                secondLast = end-1;\\n                ans +=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1110439,
                "title": "python-greedy-solution",
                "content": "```\\nclass Solution(object):\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        intervals = sorted(intervals, key = lambda t: (t[1], -t[0]))\\n        left, right = intervals[0][1] - 1, intervals[0][1]\\n        res = 2\\n        for i in range(1,len(intervals)):\\n            this_l, this_r = intervals[i][0], intervals[i][1]\\n            if right < this_l:\\n                left, right = intervals[i][1] - 1, intervals[i][1]\\n                res += 2\\n            elif left >= this_l:\\n                continue\\n            else:\\n                left, right = right, intervals[i][1]\\n                res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        intervals = sorted(intervals, key = lambda t: (t[1], -t[0]))\\n        left, right = intervals[0][1] - 1, intervals[0][1]\\n        res = 2\\n        for i in range(1,len(intervals)):\\n            this_l, this_r = intervals[i][0], intervals[i][1]\\n            if right < this_l:\\n                left, right = intervals[i][1] - 1, intervals[i][1]\\n                res += 2\\n            elif left >= this_l:\\n                continue\\n            else:\\n                left, right = right, intervals[i][1]\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035793,
                "title": "javascript-simple-greedy-o-n-logn",
                "content": "```javascript\\n/**\\n * @param {number[][]} intervals\\n * @return {number}\\n */\\n\\n\\n\\nvar intersectionSizeTwo = function(intervals) {\\n    if (intervals.length === 0) {\\n        return 0;\\n    }\\n    \\n\\n    //sort by end of the interval in ascending order\\n\\t//when we traverse the array we\\'ll be able to greedily add elements\\n    //near the ends because no other elements would be more likely\\n    //to intersect with the remaining intervals that all end later than\\n    //the current one\\n    intervals.sort((a, b) => a[1] - b[1])\\n\\n    //add intersection for first interval\\n    const [_, firstEnd] = intervals[0];\\n\\t//we will keep this in sorted order\\n    const minimalIntersection = [firstEnd - 1, firstEnd];\\n    \\n    //for each remaining interval, add enough elemnts to the set to ensure\\n    //an intersection of size 2 or greater\\n    for (let i = 1; i < intervals.length; i++) {\\n        const [s, e] = intervals[i];\\n    \\n        if (s > minimalIntersection[minimalIntersection.length - 1]) {\\n\\t\\t\\t//smallest element of interval is greater than largest element of set\\n            //so the set does not intersect with interval, add e and e - 1 to maximize\\n            //intersection with remaining intervals\\n            minimalIntersection.push(e - 1)\\n            minimalIntersection.push(e)\\n        } else if (\\n\\t\\t\\ts > minimalIntersection[minimalIntersection.length - 2]\\n\\t\\t\\t&& e ===  minimalIntersection[minimalIntersection.length - 1]\\n\\t\\t) {\\n\\t\\t\\t//if the current e is already in the set, we need to add e - 1\\n\\t\\t\\t//but we wish to do so while retaining a sorted order\\n\\t\\t    minimalIntersection.pop()\\n            minimalIntersection.push(e - 1)        \\n            minimalIntersection.push(e)        \\n        } else if (s > minimalIntersection[minimalIntersection.length - 2]) {\\n\\t\\t\\t//the greatest element is the set intersects with the interval\\n\\t\\t\\t//but the current e is not in the set, add to maximize intersections\\n\\t\\t\\t// with subsequent intervals\\n\\t\\t\\tminimalIntersection.push(e)        \\n\\t\\t} else; //intersection is of size 2, no need to add anything\\n\\t}\\n    \\n    return minimalIntersection.length;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[][]} intervals\\n * @return {number}\\n */\\n\\n\\n\\nvar intersectionSizeTwo = function(intervals) {\\n    if (intervals.length === 0) {\\n        return 0;\\n    }\\n    \\n\\n    //sort by end of the interval in ascending order\\n\\t//when we traverse the array we\\'ll be able to greedily add elements\\n    //near the ends because no other elements would be more likely\\n    //to intersect with the remaining intervals that all end later than\\n    //the current one\\n    intervals.sort((a, b) => a[1] - b[1])\\n\\n    //add intersection for first interval\\n    const [_, firstEnd] = intervals[0];\\n\\t//we will keep this in sorted order\\n    const minimalIntersection = [firstEnd - 1, firstEnd];\\n    \\n    //for each remaining interval, add enough elemnts to the set to ensure\\n    //an intersection of size 2 or greater\\n    for (let i = 1; i < intervals.length; i++) {\\n        const [s, e] = intervals[i];\\n    \\n        if (s > minimalIntersection[minimalIntersection.length - 1]) {\\n\\t\\t\\t//smallest element of interval is greater than largest element of set\\n            //so the set does not intersect with interval, add e and e - 1 to maximize\\n            //intersection with remaining intervals\\n            minimalIntersection.push(e - 1)\\n            minimalIntersection.push(e)\\n        } else if (\\n\\t\\t\\ts > minimalIntersection[minimalIntersection.length - 2]\\n\\t\\t\\t&& e ===  minimalIntersection[minimalIntersection.length - 1]\\n\\t\\t) {\\n\\t\\t\\t//if the current e is already in the set, we need to add e - 1\\n\\t\\t\\t//but we wish to do so while retaining a sorted order\\n\\t\\t    minimalIntersection.pop()\\n            minimalIntersection.push(e - 1)        \\n            minimalIntersection.push(e)        \\n        } else if (s > minimalIntersection[minimalIntersection.length - 2]) {\\n\\t\\t\\t//the greatest element is the set intersects with the interval\\n\\t\\t\\t//but the current e is not in the set, add to maximize intersections\\n\\t\\t\\t// with subsequent intervals\\n\\t\\t\\tminimalIntersection.push(e)        \\n\\t\\t} else; //intersection is of size 2, no need to add anything\\n\\t}\\n    \\n    return minimalIntersection.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1005968,
                "title": "javascript-explain-comments",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @return {number}\\n */\\nvar intersectionSizeTwo = function (intervals) {\\n  // sort by left edge\\n  intervals.sort((a, b) => a[0] - b[0])\\n  // loop each interval,and an extra loop to finish counting\\n  let setSize = 0, stack = [], i = 0\\n  while (true) {\\n    let l = i == intervals.length ? Number.MAX_SAFE_INTEGER : intervals[i][0]\\n    let r = i == intervals.length ? Number.MAX_SAFE_INTEGER : intervals[i][1]\\n    // loop till last n elements that must add to set, e.g. right two elements \\n    while (stack.length) {\\n      let min = stack.reduce((prev, item) => Math.min(prev, item[1] - item[2] + 1), Number.MAX_SAFE_INTEGER)\\n      // if can not wait next interval, add this element to set \\n      if (min < l) {\\n        setSize++\\n        // remove those have 2 intersects \\n        stack = stack.filter(item => {\\n          if (item[2] == 1) return false\\n          // and mark those who have 1\\n          item[2]--\\n          return true\\n        })\\n        continue\\n      }\\n      // can wait \\n      break\\n    }\\n    // this is the extra loop? then return\\n    if (i == intervals.length) return setSize\\n    // normal loop and add this interval to stack\\n    stack.push([l, r, 2])\\n    i++\\n  }\\n  \\n};\\n\\n// console.log(intersectionSizeTwo([[1, 3], [1, 4], [2, 5], [3, 5]]))\\n// console.log(intersectionSizeTwo([[1, 2], [2, 3], [2, 4], [4, 5]]))\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @return {number}\\n */\\nvar intersectionSizeTwo = function (intervals) {\\n  // sort by left edge\\n  intervals.sort((a, b) => a[0] - b[0])\\n  // loop each interval,and an extra loop to finish counting\\n  let setSize = 0, stack = [], i = 0\\n  while (true) {\\n    let l = i == intervals.length ? Number.MAX_SAFE_INTEGER : intervals[i][0]\\n    let r = i == intervals.length ? Number.MAX_SAFE_INTEGER : intervals[i][1]\\n    // loop till last n elements that must add to set, e.g. right two elements \\n    while (stack.length) {\\n      let min = stack.reduce((prev, item) => Math.min(prev, item[1] - item[2] + 1), Number.MAX_SAFE_INTEGER)\\n      // if can not wait next interval, add this element to set \\n      if (min < l) {\\n        setSize++\\n        // remove those have 2 intersects \\n        stack = stack.filter(item => {\\n          if (item[2] == 1) return false\\n          // and mark those who have 1\\n          item[2]--\\n          return true\\n        })\\n        continue\\n      }\\n      // can wait \\n      break\\n    }\\n    // this is the extra loop? then return\\n    if (i == intervals.length) return setSize\\n    // normal loop and add this interval to stack\\n    stack.push([l, r, 2])\\n    i++\\n  }\\n  \\n};\\n\\n// console.log(intersectionSizeTwo([[1, 3], [1, 4], [2, 5], [3, 5]]))\\n// console.log(intersectionSizeTwo([[1, 2], [2, 3], [2, 4], [4, 5]]))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998942,
                "title": "rust-o-nlogn-solution",
                "content": "Sort the intervals. \\nThen for each interval that needs to be satisfied, choose the last two elements in the interval.\\nUpdate the num satisfied for all intervals that are common for these last two elements.\\nIf we come across an interval that is completely overlaped by our current interval, satisfy this smaller interval. Since the interval is completely overlapped by previous intervals, satisfying this smaller interval is guaranteed to satisfy the previous intervals.\\n\\n```\\n// We assume `start != end`.\\n#[derive(Debug, Copy, Clone)]\\nstruct Interval {\\n    start: i32,\\n    end: i32,\\n}\\n\\n fn intersection_size_two(mut intervals: Vec<Vec<i32>>) -> i32 {\\n    intervals.sort();\\n    let intervals: Vec<Interval> = intervals\\n        .into_iter()\\n        .map(|xs| Interval {\\n            start: xs[0],\\n            end: xs[1],\\n        })\\n        .collect();\\n    let mut num_satisfied = intervals.iter().map(|_| 0).collect::<Vec<i32>>();\\n    let mut set_size = 0;\\n    let mut i = 0;\\n\\n    while i < intervals.len() {\\n        assert!(num_satisfied[i] <= 2);\\n        if num_satisfied[i] == 2 {\\n            i += 1;\\n            continue;\\n        }\\n\\n        let mut overlapped = false;\\n        let mut j = i + 1;\\n        while j < intervals.len() && intervals[j].start <= intervals[i].end {\\n            // The interval at `j` start and ends within the interval at `i`.\\n            // Therefore, if we satisfy the interval at `j`, we satisfy all intervals in `[i, j]`.\\n            if intervals[j].end <= intervals[i].end {\\n                i = j;\\n            }\\n            j += 1;\\n        }\\n\\n        let to_satisfy = 2 - num_satisfied[i];\\n        set_size += to_satisfy;\\n        for k in i..j {\\n            let k_satisfied = std::cmp::min(to_satisfy, intervals[i].end - intervals[k].start + 1);\\n            num_satisfied[k] += k_satisfied;\\n        }\\n\\n        i += 1;\\n    }\\n\\n    set_size\\n}\\n\\nimpl Solution {\\n    pub fn intersection_size_two(mut intervals: Vec<Vec<i32>>) -> i32 {\\n        intersection_size_two(intervals)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// We assume `start != end`.\\n#[derive(Debug, Copy, Clone)]\\nstruct Interval {\\n    start: i32,\\n    end: i32,\\n}\\n\\n fn intersection_size_two(mut intervals: Vec<Vec<i32>>) -> i32 {\\n    intervals.sort();\\n    let intervals: Vec<Interval> = intervals\\n        .into_iter()\\n        .map(|xs| Interval {\\n            start: xs[0],\\n            end: xs[1],\\n        })\\n        .collect();\\n    let mut num_satisfied = intervals.iter().map(|_| 0).collect::<Vec<i32>>();\\n    let mut set_size = 0;\\n    let mut i = 0;\\n\\n    while i < intervals.len() {\\n        assert!(num_satisfied[i] <= 2);\\n        if num_satisfied[i] == 2 {\\n            i += 1;\\n            continue;\\n        }\\n\\n        let mut overlapped = false;\\n        let mut j = i + 1;\\n        while j < intervals.len() && intervals[j].start <= intervals[i].end {\\n            // The interval at `j` start and ends within the interval at `i`.\\n            // Therefore, if we satisfy the interval at `j`, we satisfy all intervals in `[i, j]`.\\n            if intervals[j].end <= intervals[i].end {\\n                i = j;\\n            }\\n            j += 1;\\n        }\\n\\n        let to_satisfy = 2 - num_satisfied[i];\\n        set_size += to_satisfy;\\n        for k in i..j {\\n            let k_satisfied = std::cmp::min(to_satisfy, intervals[i].end - intervals[k].start + 1);\\n            num_satisfied[k] += k_satisfied;\\n        }\\n\\n        i += 1;\\n    }\\n\\n    set_size\\n}\\n\\nimpl Solution {\\n    pub fn intersection_size_two(mut intervals: Vec<Vec<i32>>) -> i32 {\\n        intersection_size_two(intervals)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 990129,
                "title": "python-99-40-o-nlogn-runtime-o-1-space",
                "content": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: (x[1], -x[0]))\\n        answer = start = end = 0\\n        for b, a in intervals:\\n            if start == end == 0 or end < b:\\n                answer += 2\\n                start = a - 1\\n                end = a\\n            elif start < b:\\n                answer += 1\\n                start = end\\n                end = a\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: (x[1], -x[0]))\\n        answer = start = end = 0\\n        for b, a in intervals:\\n            if start == end == 0 or end < b:\\n                answer += 2\\n                start = a - 1\\n                end = a\\n            elif start < b:\\n                answer += 1\\n                start = end\\n                end = a\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986968,
                "title": "python3-greedy-o-nlogn",
                "content": "Here is a concise version: keep track newly added (1 or 2) end points, and update result whenever needed.\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        res, end1, end2 = 0, -1, -1\\n        for s, e in sorted(intervals, key=lambda x:(x[1], -x[0])):\\n            if s > end2:\\n                res += 2\\n                end1, end2 = e - 1, e\\n            elif s > end1:\\n                res += 1\\n                end1, end2 = end2, e\\n                \\n        return res\\n```\\n\\nHere is the verbose version that is easy to understand.\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        res, end1, end2 = 0, -1, -1\\n        for s, e in sorted(intervals, key=lambda x:(x[1], -x[0])):\\n            if s <= end1:\\n                pass\\n            if end1 < s <= end2:\\n                res += 1\\n                end1, end2 = end2, e\\n            if s > end2:\\n                res += 2\\n                end1, end2 = e - 1, e\\n                \\n        return res\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        res, end1, end2 = 0, -1, -1\\n        for s, e in sorted(intervals, key=lambda x:(x[1], -x[0])):\\n            if s > end2:\\n                res += 2\\n                end1, end2 = e - 1, e\\n            elif s > end1:\\n                res += 1\\n                end1, end2 = end2, e\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986640,
                "title": "java-o-n-log-n-greedy-solution-maintain-s-yourself",
                "content": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[1] == b[1] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\\n        List<Integer> S = new ArrayList<>();\\n        S.add(intervals[0][1] - 1);\\n        S.add(intervals[0][1]);\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] cur = intervals[i];\\n            if (cur[0] <= S.get(S.size() - 2) && S.get(S.size() - 1) <= cur[1]) {\\n                continue;\\n            }\\n            else {\\n                if (cur[0] <= S.get(S.size() - 1)) {\\n                    if (cur[1] == S.get(S.size() - 1)) {\\n                        S.remove(S.size() - 1);\\n                        S.add(cur[1] - 1);\\n                    }\\n                    S.add(cur[1]);\\n                }\\n                else {\\n                    S.add(cur[1] - 1);\\n                    S.add(cur[1]);\\n                }\\n            }\\n        }\\n        return S.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[1] == b[1] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\\n        List<Integer> S = new ArrayList<>();\\n        S.add(intervals[0][1] - 1);\\n        S.add(intervals[0][1]);\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] cur = intervals[i];\\n            if (cur[0] <= S.get(S.size() - 2) && S.get(S.size() - 1) <= cur[1]) {\\n                continue;\\n            }\\n            else {\\n                if (cur[0] <= S.get(S.size() - 1)) {\\n                    if (cur[1] == S.get(S.size() - 1)) {\\n                        S.remove(S.size() - 1);\\n                        S.add(cur[1] - 1);\\n                    }\\n                    S.add(cur[1]);\\n                }\\n                else {\\n                    S.add(cur[1] - 1);\\n                    S.add(cur[1]);\\n                }\\n            }\\n        }\\n        return S.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961545,
                "title": "java-clean",
                "content": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)->(a[1]-b[1]));\\n        int len = intervals.length;\\n        int cnt = 0;\\n        //range of last two numbers picked\\n        int[] range = new int[]{-1, -1};\\n        for(int i=0; i<len; i++){\\n            int[] cur = intervals[i];\\n            if(cur[0] > range[1]){\\n                cnt += 2;\\n                range[0] = cur[1]-1;\\n                range[1] = cur[1];\\n            }else if(cur[0] == range[1] || cur[0] > range[0]){\\n                cnt++;\\n                range[0] = range[1];\\n                range[1] = cur[1];\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\nmore straightforward version:\\n```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)->(a[1]-b[1]));\\n        int len = intervals.length;\\n        int cnt = 0;\\n        //range of last two numbers picked\\n        int[] range = new int[]{-1, -1};\\n        for(int i=0; i<len; i++){\\n            int[] cur = intervals[i];\\n            if(cur[0] > range[1]){\\n                cnt += 2;\\n                range[0] = cur[1]-1;\\n                range[1] = cur[1];\\n            }else if(cur[0] == range[1]){\\n                cnt++;\\n                range[0] = range[1];\\n                range[1] = cur[1];\\n            }else if(cur[0] > range[0]){\\n                if(cur[1] == range[1]){\\n                    cnt++;\\n                    range[0] = cur[1]-1;\\n                    range[1] = cur[1];\\n                }else if(cur[1] > range[1]){\\n                    cnt++;\\n                    range[0] = range[1];\\n                    range[1] = cur[1];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)->(a[1]-b[1]));\\n        int len = intervals.length;\\n        int cnt = 0;\\n        //range of last two numbers picked\\n        int[] range = new int[]{-1, -1};\\n        for(int i=0; i<len; i++){\\n            int[] cur = intervals[i];\\n            if(cur[0] > range[1]){\\n                cnt += 2;\\n                range[0] = cur[1]-1;\\n                range[1] = cur[1];\\n            }else if(cur[0] == range[1] || cur[0] > range[0]){\\n                cnt++;\\n                range[0] = range[1];\\n                range[1] = cur[1];\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948222,
                "title": "python-greedy-o-nlogn-87",
                "content": "See explanation in the code\\n```\\n\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        \\n        intervals.sort(key=lambda x:x[1]) #sort by end time\\n        \\n        res = 2\\n        left, right = intervals[0][1]-1, intervals[0][1]\\n    \\n        for i in range(1, len(intervals)):\\n\\n            #condition 1\\n            # interval :   ****************\\n            #  range:        left***right\\n            if left >= intervals[i][0]: \\n                continue\\n            #condition 2\\n            # interval :           **********\\n            #  range:        left******right            \\n            if right >= intervals[i][0] and left < intervals[i][0]:\\n                res += 1\\n                left = right\\n                right = intervals[i][1]\\n                continue\\n            #condition 3\\n            # interval :                      **********\\n            #  range:        left******right            \\n            if right < intervals[i][0]:\\n                res += 2\\n                \\n                right = intervals[i][1]\\n                left = right - 1\\n                continue\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        \\n        intervals.sort(key=lambda x:x[1]) #sort by end time\\n        \\n        res = 2\\n        left, right = intervals[0][1]-1, intervals[0][1]\\n    \\n        for i in range(1, len(intervals)):\\n\\n            #condition 1\\n            # interval :   ****************\\n            #  range:        left***right\\n            if left >= intervals[i][0]: \\n                continue\\n            #condition 2\\n            # interval :           **********\\n            #  range:        left******right            \\n            if right >= intervals[i][0] and left < intervals[i][0]:\\n                res += 1\\n                left = right\\n                right = intervals[i][1]\\n                continue\\n            #condition 3\\n            # interval :                      **********\\n            #  range:        left******right            \\n            if right < intervals[i][0]:\\n                res += 2\\n                \\n                right = intervals[i][1]\\n                left = right - 1\\n                continue\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 883105,
                "title": "rust-translated-binaryheap-sort-4ms-100",
                "content": "BinaryHeap\\n\\n```rust\\nimpl Solution {\\n    pub fn intersection_size_two(intervals: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::BinaryHeap;\\n\\n        let mut heap = BinaryHeap::<(i32, i32)>::new();\\n        // pop with right smallest then left largest first\\n        for v in &intervals {\\n            heap.push((-v[1], v[0]));\\n        }\\n        let mut ans = 0;\\n        let mut hi = -1;\\n        let mut lo = -1;\\n\\n        while let Some((right, left)) = heap.pop() {\\n            let right = -right;\\n            if left <= lo {\\n                continue;\\n            };\\n            if left > hi {\\n                ans += 2;\\n                hi = right;\\n                lo = hi - 1;\\n            } else {\\n                ans += 1;\\n                lo = hi;\\n                hi = right;\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_intersection_size_two() {\\n        assert_eq!(\\n            Solution::intersection_size_two(vec![vec![1, 3], vec![1, 4], vec![2, 5], vec![3, 5]]),\\n            3\\n        );\\n    }\\n\\n    #[test]\\n    fn test_intersection_size_two_02() {\\n        assert_eq!(\\n            Solution::intersection_size_two(vec![vec![1, 2], vec![2, 3], vec![2, 4], vec![4, 5]]),\\n            5\\n        );\\n    }\\n\\n    #[test]\\n    fn test_intersection_size_two_03() {\\n        assert_eq!(\\n            Solution::intersection_size_two(vec![\\n                vec![3, 14],\\n                vec![4, 14],\\n                vec![3, 9],\\n                vec![5, 13],\\n                vec![10, 17],\\n                vec![8, 20],\\n                vec![7, 12],\\n                vec![15, 19],\\n                vec![11, 17],\\n                vec![6, 18],\\n                vec![16, 20],\\n                vec![2, 18],\\n                vec![3, 5],\\n                vec![15, 18],\\n                vec![9, 12],\\n                vec![3, 14],\\n                vec![10, 15],\\n                vec![1, 13],\\n                vec![8, 10],\\n                vec![0, 20]\\n            ]),\\n            7\\n        );\\n    }\\n}\\n```\\n\\nSort:\\n```rust\\nimpl Solution {\\n    pub fn intersection_size_two(mut intervals: Vec<Vec<i32>>) -> i32 {\\n        intervals.sort_by_key(|v| (v[1], -v[0]));\\n\\n        let mut ans = 0;\\n        let mut hi = -1;\\n        let mut lo = -1;\\n\\n        for v in &intervals {\\n            let left = v[0];\\n            let right = v[1];\\n            if left <= lo {\\n                continue;\\n            };\\n            if left > hi {\\n                ans += 2;\\n                hi = right;\\n                lo = hi - 1;\\n            } else {\\n                ans += 1;\\n                lo = hi;\\n                hi = right;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn intersection_size_two(intervals: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::BinaryHeap;\\n\\n        let mut heap = BinaryHeap::<(i32, i32)>::new();\\n        // pop with right smallest then left largest first\\n        for v in &intervals {\\n            heap.push((-v[1], v[0]));\\n        }\\n        let mut ans = 0;\\n        let mut hi = -1;\\n        let mut lo = -1;\\n\\n        while let Some((right, left)) = heap.pop() {\\n            let right = -right;\\n            if left <= lo {\\n                continue;\\n            };\\n            if left > hi {\\n                ans += 2;\\n                hi = right;\\n                lo = hi - 1;\\n            } else {\\n                ans += 1;\\n                lo = hi;\\n                hi = right;\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_intersection_size_two() {\\n        assert_eq!(\\n            Solution::intersection_size_two(vec![vec![1, 3], vec![1, 4], vec![2, 5], vec![3, 5]]),\\n            3\\n        );\\n    }\\n\\n    #[test]\\n    fn test_intersection_size_two_02() {\\n        assert_eq!(\\n            Solution::intersection_size_two(vec![vec![1, 2], vec![2, 3], vec![2, 4], vec![4, 5]]),\\n            5\\n        );\\n    }\\n\\n    #[test]\\n    fn test_intersection_size_two_03() {\\n        assert_eq!(\\n            Solution::intersection_size_two(vec![\\n                vec![3, 14],\\n                vec![4, 14],\\n                vec![3, 9],\\n                vec![5, 13],\\n                vec![10, 17],\\n                vec![8, 20],\\n                vec![7, 12],\\n                vec![15, 19],\\n                vec![11, 17],\\n                vec![6, 18],\\n                vec![16, 20],\\n                vec![2, 18],\\n                vec![3, 5],\\n                vec![15, 18],\\n                vec![9, 12],\\n                vec![3, 14],\\n                vec![10, 15],\\n                vec![1, 13],\\n                vec![8, 10],\\n                vec![0, 20]\\n            ]),\\n            7\\n        );\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn intersection_size_two(mut intervals: Vec<Vec<i32>>) -> i32 {\\n        intervals.sort_by_key(|v| (v[1], -v[0]));\\n\\n        let mut ans = 0;\\n        let mut hi = -1;\\n        let mut lo = -1;\\n\\n        for v in &intervals {\\n            let left = v[0];\\n            let right = v[1];\\n            if left <= lo {\\n                continue;\\n            };\\n            if left > hi {\\n                ans += 2;\\n                hi = right;\\n                lo = hi - 1;\\n            } else {\\n                ans += 1;\\n                lo = hi;\\n                hi = right;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 829451,
                "title": "straight-forward-greedy-o-n-after-sorting-faster-than-98-43",
                "content": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: x[1])\\n        \\n        one, two = intervals[0][1] - 1, intervals[0][1]\\n        ans = 2\\n        \\n        def overlapdegree(interval):\\n            s, e = interval\\n            overlaps = 0\\n            \\n            overlaps += 1 if s <= one <= e else 0\\n            overlaps += 1 if s <= two <= e else 0\\n            return overlaps\\n\\n        \\n        i = 1\\n        while i < len(intervals):\\n            overlap = overlapdegree(intervals[i])\\n            \\n            if overlap >= 2:\\n                pass\\n            elif overlap == 1:\\n                one, two = two, intervals[i][1]\\n                ans += 1\\n            else:\\n                one, two = intervals[i][1] - 1, intervals[i][1]\\n                ans += 2\\n            i += 1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: x[1])\\n        \\n        one, two = intervals[0][1] - 1, intervals[0][1]\\n        ans = 2\\n        \\n        def overlapdegree(interval):\\n            s, e = interval\\n            overlaps = 0\\n            \\n            overlaps += 1 if s <= one <= e else 0\\n            overlaps += 1 if s <= two <= e else 0\\n            return overlaps\\n\\n        \\n        i = 1\\n        while i < len(intervals):\\n            overlap = overlapdegree(intervals[i])\\n            \\n            if overlap >= 2:\\n                pass\\n            elif overlap == 1:\\n                one, two = two, intervals[i][1]\\n                ans += 1\\n            else:\\n                one, two = intervals[i][1] - 1, intervals[i][1]\\n                ans += 2\\n            i += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803977,
                "title": "c-greedy",
                "content": "```\\nint intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const auto & lhs, const auto & rhs){\\n            return lhs[1] < rhs[1];\\n        });\\n        \\n        set<int> s;\\n        \\n        \\n        \\n        int small = intervals[0][1]-1;\\n        int big = intervals[0][1];\\n        s.insert(small);\\n        s.insert(big);\\n        \\n        for(int i=1;i<intervals.size(); i++){\\n            if(intervals[i][0] <= small && intervals[i][1] >= big)\\n                continue;\\n            else if(intervals[i][0] > big){\\n                small = intervals[i][1]-1;\\n                big = intervals[i][1];\\n                s.insert(small);\\n                s.insert(big);\\n            }\\n            else if(intervals[i][0] > small){\\n                if(big!= intervals[i][1]){\\n                    small = big;\\n                    big = intervals[i][1];\\n                    s.insert(big);\\n                }\\n                else{\\n                    small = intervals[i][0];\\n                    s.insert(small);\\n                }\\n            }\\n            \\n        }\\n        \\n        return s.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const auto & lhs, const auto & rhs){\\n            return lhs[1] < rhs[1];\\n        });\\n        \\n        set<int> s;\\n        \\n        \\n        \\n        int small = intervals[0][1]-1;\\n        int big = intervals[0][1];\\n        s.insert(small);\\n        s.insert(big);\\n        \\n        for(int i=1;i<intervals.size(); i++){\\n            if(intervals[i][0] <= small && intervals[i][1] >= big)\\n                continue;\\n            else if(intervals[i][0] > big){\\n                small = intervals[i][1]-1;\\n                big = intervals[i][1];\\n                s.insert(small);\\n                s.insert(big);\\n            }\\n            else if(intervals[i][0] > small){\\n                if(big!= intervals[i][1]){\\n                    small = big;\\n                    big = intervals[i][1];\\n                    s.insert(big);\\n                }\\n                else{\\n                    small = intervals[i][0];\\n                    s.insert(small);\\n                }\\n            }\\n            \\n        }\\n        \\n        return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799458,
                "title": "simple-c-greedy-using-sorting",
                "content": "```\\nint intersectionSizeTwo(vector<vector<int>>& intervals) {\\n\\n\\tsort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b){\\n\\t\\treturn (a[1] < b[1] || (a[0] > b[0] && a[1] == b[1]));});\\n\\n\\tvector<int> m;\\n\\tfor (vector<int>& interval : intervals) {\\n\\n\\t\\tif (m.empty() || m.back() < interval[0]) {\\n\\t\\t\\tm.push_back(interval[1] - 1);\\n\\t\\t\\tm.push_back(interval[1]);\\n\\t\\t} else if (m.back() >= interval[0] && (m.size() == 1 || m[m.size() - 2] < interval[0])) {\\n\\t\\t\\tm.push_back(interval[1]);\\n\\t\\t}\\n\\t}\\n\\n\\treturn (int)m.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint intersectionSizeTwo(vector<vector<int>>& intervals) {\\n\\n\\tsort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b){\\n\\t\\treturn (a[1] < b[1] || (a[0] > b[0] && a[1] == b[1]));});\\n\\n\\tvector<int> m;\\n\\tfor (vector<int>& interval : intervals) {\\n\\n\\t\\tif (m.empty() || m.back() < interval[0]) {\\n\\t\\t\\tm.push_back(interval[1] - 1);\\n\\t\\t\\tm.push_back(interval[1]);\\n\\t\\t} else if (m.back() >= interval[0] && (m.size() == 1 || m[m.size() - 2] < interval[0])) {\\n\\t\\t\\tm.push_back(interval[1]);\\n\\t\\t}\\n\\t}\\n\\n\\treturn (int)m.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 789764,
                "title": "java-stack-o-nlogn-n-intervals-length",
                "content": "This solution also returns the desired set S in st\\n\\nclass Solution {\\n\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (A, B) -> \\n            A[0]!=B[0]? A[0]-B[0]: B[1]-A[1]\\n        );\\n        int N = intervals.length;\\n        Stack<Integer> st = new Stack<>();\\n\\t\\tStack<Integer> temp = new Stack<>();\\n        st.push(intervals[N-1][0]+1);\\n        st.push(intervals[N-1][0]);\\n        for(int i = N-1; i>=0; i--){\\n            int[] interval = intervals[i];\\n            while(temp.size()<2&&st.peek()<=interval[1]&&st.peek()>=interval[0]){\\n                temp.push(st.pop());\\n            }\\n            if(temp.size()<2){\\n                if(temp.size()==1){\\n                    st.push(temp.pop());\\n                    st.push(interval[0]);\\n                } else{\\n                    st.push(interval[0]+1);\\n                    st.push(interval[0]);\\n                }\\n            } else {\\n                st.push(temp.pop());\\n                st.push(temp.pop());\\n            }\\n        }\\n        return st.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (A, B) -> \\n            A[0]!=B[0]? A[0]-B[0]: B[1]-A[1]\\n        );\\n        int N = intervals.length;\\n        Stack<Integer> st = new Stack<>();\\n\\t\\tStack<Integer> temp = new Stack<>();\\n        st.push(intervals[N-1][0]+1);\\n        st.push(intervals[N-1][0]);\\n        for(int i = N-1; i>=0; i--){\\n            int[] interval = intervals[i];\\n            while(temp.size()<2&&st.peek()<=interval[1]&&st.peek()>=interval[0]){\\n                temp.push(st.pop());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 754307,
                "title": "o-n-log-n-c-solution-by-sorting-the-intervals-by-start-points",
                "content": "Reference: [link](https://leetcode.com/problems/set-intersection-size-at-least-two/discuss/113085/Ever-wonder-why-the-greedy-algorithm-works-Here-is-the-explanation!)\\n\\nThe above post gives a solution by sorting end points but in case you are wondering about sorting start points, this post may help you:)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool mySort(vector<int>& v1, vector<int>& v2){\\n        if(v1[0]<v2[0])\\n            return true;\\n        else if(v1[0]==v2[0] && v1[1]>v2[1])\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& inv) {\\n        int n=inv.size(), ans=0;\\n        sort(inv.begin(), inv.end(), mySort);\\n        int f=1e9, s=1e9;\\n        for(int i=n-1; i>=0; i--){\\n            if(inv[i][1]>=f && inv[i][1]>=s)\\n                continue;\\n            if(inv[i][1]<f){\\n                ans+=2;\\n                f=inv[i][0];\\n                s=inv[i][0]+1;\\n            }\\n            else{\\n                s=f;\\n                f=inv[i][0];\\n                ans+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool mySort(vector<int>& v1, vector<int>& v2){\\n        if(v1[0]<v2[0])\\n            return true;\\n        else if(v1[0]==v2[0] && v1[1]>v2[1])\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& inv) {\\n        int n=inv.size(), ans=0;\\n        sort(inv.begin(), inv.end(), mySort);\\n        int f=1e9, s=1e9;\\n        for(int i=n-1; i>=0; i--){\\n            if(inv[i][1]>=f && inv[i][1]>=s)\\n                continue;\\n            if(inv[i][1]<f){\\n                ans+=2;\\n                f=inv[i][0];\\n                s=inv[i][0]+1;\\n            }\\n            else{\\n                s=f;\\n                f=inv[i][0];\\n                ans+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691484,
                "title": "java-solution-greedy-nlonn",
                "content": "class Solution {\\n    public int intersectionSizeTwo(int[][] a) {\\n        \\n        int n = a.length;\\n        \\n        if(n==0){\\n            return 0;\\n        }\\n\\t\\t// sort on the basis of end point\\n        Arrays.sort(a, (x,y)->x[1]!=y[1]?x[1]-y[1]:x[0]-y[0]);\\n        \\n      \\n        \\n        int min = a[0][1]-1;\\n        int max = a[0][1];\\n        \\n        int res = 2;\\n        for(int i=1;i<n;i++){\\n            \\n            int temp = a[i][0];\\n          \\n            if(temp>max){\\n              \\n                min = a[i][1]-1;\\n                max = a[i][1];\\n                res+=2;\\n          \\n            }else if(temp==max){\\n                min = max;\\n                max = a[i][1];\\n                res+=1;\\n            }else{\\n                if(min>=temp && max<=a[i][1]){\\n                    continue;\\n                }else{\\n                    min = max;\\n                    max = a[i][1];\\n                    res+=1;\\n                }\\n            }\\n        }\\n    \\n    return res;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int intersectionSizeTwo(int[][] a) {\\n        \\n        int n = a.length;\\n        \\n        if(n==0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 638471,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int>&a, vector<int>&b) {\\n            if(a[1] != b[1]) {\\n                return a[1] < b[1];\\n            } else {\\n                return a[0] > b[0];\\n            }\\n        });\\n        \\n        int ans = 0;\\n        int pre_left = -1, pre_right = -1;\\n        for(int i = 0; i < intervals.size(); i++) {\\n            if(intervals[i][0] <= pre_left) continue;\\n            \\n            if(intervals[i][0] > pre_right) {\\n                ans += 2;\\n                pre_right = intervals[i][1];\\n                pre_left = pre_right - 1;\\n            } else {\\n                ans += 1;\\n                pre_left = pre_right;\\n                pre_right = intervals[i][1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int>&a, vector<int>&b) {\\n            if(a[1] != b[1]) {\\n                return a[1] < b[1];\\n            } else {\\n                return a[0] > b[0];\\n            }\\n        });\\n        \\n        int ans = 0;\\n        int pre_left = -1, pre_right = -1;\\n        for(int i = 0; i < intervals.size(); i++) {\\n            if(intervals[i][0] <= pre_left) continue;\\n            \\n            if(intervals[i][0] > pre_right) {\\n                ans += 2;\\n                pre_right = intervals[i][1];\\n                pre_left = pre_right - 1;\\n            } else {\\n                ans += 1;\\n                pre_left = pre_right;\\n                pre_right = intervals[i][1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633698,
                "title": "java-gready-solution-o-n-log-n-beats-99-easy-to-read",
                "content": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> {\\n           if (a[1] == b[1]) {\\n               return Integer.compare(b[0], a[0]);\\n           }\\n            \\n            return Integer.compare(a[1], b[1]);\\n        });\\n        \\n        int prevPoint = intervals[0][1] - 1;\\n        int lastPoint = intervals[0][1];\\n        int answer = 2;\\n        \\n        for (int[] interval : intervals) {\\n            if (lastPoint - interval[0] < 0) {\\n                lastPoint = interval[1];\\n                prevPoint = lastPoint - 1;\\n                answer += 2;\\n            } else if (lastPoint >= interval[0] && prevPoint < interval[0]) {\\n                prevPoint = lastPoint;\\n                lastPoint = interval[1];\\n                answer += 1;\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> {\\n           if (a[1] == b[1]) {\\n               return Integer.compare(b[0], a[0]);\\n           }\\n            \\n            return Integer.compare(a[1], b[1]);\\n        });\\n        \\n        int prevPoint = intervals[0][1] - 1;\\n        int lastPoint = intervals[0][1];\\n        int answer = 2;\\n        \\n        for (int[] interval : intervals) {\\n            if (lastPoint - interval[0] < 0) {\\n                lastPoint = interval[1];\\n                prevPoint = lastPoint - 1;\\n                answer += 2;\\n            } else if (lastPoint >= interval[0] && prevPoint < interval[0]) {\\n                prevPoint = lastPoint;\\n                lastPoint = interval[1];\\n                answer += 1;\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581637,
                "title": "golang-find-the-set",
                "content": "```\\nfunc intersectionSizeTwo(intervals [][]int) int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        a, b := intervals[i], intervals[j]\\n        if a[1] != b[1] {\\n            return a[1] < b[1]\\n        }\\n        return a[0] > b[0]\\n    })\\n    res := append(make([]int, 0), -1, -1)\\n    for _, in := range intervals {\\n        begin, end := in[0], in[1]\\n        if begin <= res[len(res) - 2] {\\n            continue\\n        } else if begin <= res[len(res) - 1] {\\n            res = append(res, end)\\n        } else {\\n            res = append(res, end - 1, end)\\n        }\\n    }\\n    return len(res) - 2\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc intersectionSizeTwo(intervals [][]int) int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        a, b := intervals[i], intervals[j]\\n        if a[1] != b[1] {\\n            return a[1] < b[1]\\n        }\\n        return a[0] > b[0]\\n    })\\n    res := append(make([]int, 0), -1, -1)\\n    for _, in := range intervals {\\n        begin, end := in[0], in[1]\\n        if begin <= res[len(res) - 2] {\\n            continue\\n        } else if begin <= res[len(res) - 1] {\\n            res = append(res, end)\\n        } else {\\n            res = append(res, end - 1, end)\\n        }\\n    }\\n    return len(res) - 2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354297,
                "title": "share-my-3ms-beat-100-java-solution",
                "content": "```\\npublic int intersectionSizeTwo(int[][] intervals) {\\n        int n = 0;\\n        long[] endStartPairs = new long[intervals.length];\\n\\n        for (int[] interval : intervals) {\\n            endStartPairs[n] = (long)(-interval[0]) & 0xFFFFFFFFL;\\n            endStartPairs[n++] |= (long)(interval[1]) << 32;\\n        }\\n        Arrays.sort(endStartPairs);\\n        int min = -2, max = -1;\\n        int curStart, curEnd;\\n        int res = 0;\\n        for (long endStartPair : endStartPairs) {\\n            curStart = -(int)endStartPair;\\n            curEnd = (int)(endStartPair >> 32);\\n            if (curStart <= min) {\\n                continue;\\n            }\\n            if (curStart <= max) {\\n                res += 1;\\n                min = max;\\n            } else {\\n                res += 2;\\n                min = curEnd - 1;\\n            }\\n            max = curEnd;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int intersectionSizeTwo(int[][] intervals) {\\n        int n = 0;\\n        long[] endStartPairs = new long[intervals.length];\\n\\n        for (int[] interval : intervals) {\\n            endStartPairs[n] = (long)(-interval[0]) & 0xFFFFFFFFL;\\n            endStartPairs[n++] |= (long)(interval[1]) << 32;\\n        }\\n        Arrays.sort(endStartPairs);\\n        int min = -2, max = -1;\\n        int curStart, curEnd;\\n        int res = 0;\\n        for (long endStartPair : endStartPairs) {\\n            curStart = -(int)endStartPair;\\n            curEnd = (int)(endStartPair >> 32);\\n            if (curStart <= min) {\\n                continue;\\n            }\\n            if (curStart <= max) {\\n                res += 1;\\n                min = max;\\n            } else {\\n                res += 2;\\n                min = curEnd - 1;\\n            }\\n            max = curEnd;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285627,
                "title": "python-intuitive-o-nlogn-with-minheap",
                "content": "The basic idea\\n1. sort the intervals by start time\\n2. iterate through intervals and push ( end time, -1 * (# of needed intersections) ) into the heap\\n3. when start time >= smallest end time in heap, add points to set S and update the entire heap\\n\\n```\\nimport heapq\\nimport collections\\nclass Solution(object):\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        H = []\\n        D = collections.defaultdict(list)\\n        \\n        # store interval with same starting time together\\n        for start, end in intervals:\\n            D[start].append(end)\\n        starts = sorted(D)\\n        \\n        # store (end, -1 * # of needed intersections)\\n        for start in starts:\\n            if not H:\\n                for end in D[start]:\\n                    heapq.heappush(H, (end, -2))\\n            else:\\n                if H[0][0] <= start:\\n                    pend, t = heapq.heappop(H)\\n                    res -= t\\n                    newH = []\\n                    while H:\\n                        curend, curt = heapq.heappop(H)\\n                        curt -= t\\n                        if curt < 0:\\n                            heapq.heappush(newH, (curend, curt))\\n                    H = newH\\n                    if pend == start:\\n                        for end in D[start]:\\n                            heapq.heappush(H, (end, -1))\\n                    else:\\n                        for end in D[start]:\\n                            heapq.heappush(H, (end, -2))\\n                else:\\n                    for end in D[start]:\\n                        heapq.heappush(H, (end, -2))\\n\\n        # clean up incompleted intervals\\n        if H:\\n            end, t = heapq.heappop(H)\\n            res -= t\\n            while H:\\n                curend, curt = heapq.heappop(H)\\n                if curt - t < 0: \\n\\t\\t\\t\\t\\t# have to add one more intersection to remove everything in the heap\\n                    return res + 1\\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nimport collections\\nclass Solution(object):\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        H = []\\n        D = collections.defaultdict(list)\\n        \\n        # store interval with same starting time together\\n        for start, end in intervals:\\n            D[start].append(end)\\n        starts = sorted(D)\\n        \\n        # store (end, -1 * # of needed intersections)\\n        for start in starts:\\n            if not H:\\n                for end in D[start]:\\n                    heapq.heappush(H, (end, -2))\\n            else:\\n                if H[0][0] <= start:\\n                    pend, t = heapq.heappop(H)\\n                    res -= t\\n                    newH = []\\n                    while H:\\n                        curend, curt = heapq.heappop(H)\\n                        curt -= t\\n                        if curt < 0:\\n                            heapq.heappush(newH, (curend, curt))\\n                    H = newH\\n                    if pend == start:\\n                        for end in D[start]:\\n                            heapq.heappush(H, (end, -1))\\n                    else:\\n                        for end in D[start]:\\n                            heapq.heappush(H, (end, -2))\\n                else:\\n                    for end in D[start]:\\n                        heapq.heappush(H, (end, -2))\\n\\n        # clean up incompleted intervals\\n        if H:\\n            end, t = heapq.heappop(H)\\n            res -= t\\n            while H:\\n                curend, curt = heapq.heappop(H)\\n                if curt - t < 0: \\n\\t\\t\\t\\t\\t# have to add one more intersection to remove everything in the heap\\n                    return res + 1\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 279406,
                "title": "python-o-nlogn-always-peek-the-top-two-elements-of-maxheap",
                "content": "```\\nclass Solution(object):\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        intervals.sort(key=lambda x:x[1])\\n        hp = []\\n        heapq.heappush(hp, -intervals[0][1])\\n        heapq.heappush(hp, -intervals[0][1]+1)\\n        for i in xrange(1, len(intervals)):\\n            t1 = -heapq.heappop(hp)\\n            t2 = -heapq.heappop(hp)\\n            if not intervals[i][0]<=t1<=intervals[i][1]:\\n                heapq.heappush(hp, -intervals[i][1])\\n                if not intervals[i][0]<=t2<=intervals[i][1]:\\n                    heapq.heappush(hp, -intervals[i][1]+1)\\n            else:\\n                if not intervals[i][0]<=t2<=intervals[i][1]:\\n                    heapq.heappush(hp, -intervals[i][1])\\n            heapq.heappush(hp, -t1)\\n            heapq.heappush(hp, -t2)\\n        return len(hp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        intervals.sort(key=lambda x:x[1])\\n        hp = []\\n        heapq.heappush(hp, -intervals[0][1])\\n        heapq.heappush(hp, -intervals[0][1]+1)\\n        for i in xrange(1, len(intervals)):\\n            t1 = -heapq.heappop(hp)\\n            t2 = -heapq.heappop(hp)\\n            if not intervals[i][0]<=t1<=intervals[i][1]:\\n                heapq.heappush(hp, -intervals[i][1])\\n                if not intervals[i][0]<=t2<=intervals[i][1]:\\n                    heapq.heappush(hp, -intervals[i][1]+1)\\n            else:\\n                if not intervals[i][0]<=t2<=intervals[i][1]:\\n                    heapq.heappush(hp, -intervals[i][1])\\n            heapq.heappush(hp, -t1)\\n            heapq.heappush(hp, -t2)\\n        return len(hp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226997,
                "title": "28-ms-c-beats-100",
                "content": "```\\n#define pi pair<int,int>\\n#define f first\\n#define s second\\n\\nclass Solution {\\npublic:\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& A) {\\n                \\n        vector<pi> B;\\n        for(auto x : A) B.push_back({x[0],x[1]});\\n        \\n        auto comp = [&](const pi& a,const pi& b){\\n            if(a.f==b.f)    return a.s<b.s;\\n            return a.f<b.f;\\n        };\\n        \\n        sort(B.begin(),B.end(),comp);\\n        \\n        int a=B.back().first;\\n        int b=a+1;\\n        \\n        unordered_set<int> cur{a,b};\\n        \\n        \\n        for(int i=B.size()-1 ; i>0 ; i--){\\n            \\n            if(B[i-1].s < B[i].f){\\n                a=B[i-1].f;\\n                b=a+1;\\n                cur.insert(a);\\n                cur.insert(b);\\n            }\\n            else{\\n                bool present_a = B[i-1].f<=a && a<=B[i-1].s;\\n                bool present_b = B[i-1].f<=b && b<=B[i-1].s;\\n                \\n                if(present_a && present_b){\\n                    continue;\\n                }else if(present_a){\\n                    b = (a == B[i-1].f ? a+1 : B[i-1].f); \\n                    cur.insert(b);\\n                }else if(present_b){\\n                    a = (b == B[i-1].f ? b+1 : B[i-1].f);  \\n                    cur.insert(a);\\n                }else{ //none present\\n                    a = B[i-1].f;\\n                    b = a+1;\\n                    cur.insert(a);\\n                    cur.insert(b);\\n                }\\n            }\\n        }\\n        //for(auto x: cur) cout<<x<<\" \";\\n        return cur.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pi pair<int,int>\\n#define f first\\n#define s second\\n\\nclass Solution {\\npublic:\\n    \\n    int intersectionSizeTwo(vector<vector<int>>& A) {\\n                \\n        vector<pi> B;\\n        for(auto x : A) B.push_back({x[0],x[1]});\\n        \\n        auto comp = [&](const pi& a,const pi& b){\\n            if(a.f==b.f)    return a.s<b.s;\\n            return a.f<b.f;\\n        };\\n        \\n        sort(B.begin(),B.end(),comp);\\n        \\n        int a=B.back().first;\\n        int b=a+1;\\n        \\n        unordered_set<int> cur{a,b};\\n        \\n        \\n        for(int i=B.size()-1 ; i>0 ; i--){\\n            \\n            if(B[i-1].s < B[i].f){\\n                a=B[i-1].f;\\n                b=a+1;\\n                cur.insert(a);\\n                cur.insert(b);\\n            }\\n            else{\\n                bool present_a = B[i-1].f<=a && a<=B[i-1].s;\\n                bool present_b = B[i-1].f<=b && b<=B[i-1].s;\\n                \\n                if(present_a && present_b){\\n                    continue;\\n                }else if(present_a){\\n                    b = (a == B[i-1].f ? a+1 : B[i-1].f); \\n                    cur.insert(b);\\n                }else if(present_b){\\n                    a = (b == B[i-1].f ? b+1 : B[i-1].f);  \\n                    cur.insert(a);\\n                }else{ //none present\\n                    a = B[i-1].f;\\n                    b = a+1;\\n                    cur.insert(a);\\n                    cur.insert(b);\\n                }\\n            }\\n        }\\n        //for(auto x: cur) cout<<x<<\" \";\\n        return cur.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 172835,
                "title": "solution-summary",
                "content": "Sort by end based on ascending order\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        intervals.sort(key = lambda x: (x[1]))\\n        largest = second = -1\\n        res = 0\\n        for p in intervals:\\n            islargest = p[0] <= largest\\n            issecond = p[0] <= second\\n            if islargest and issecond: continue\\n            \\n            second =  p[1] -1 if islargest is False or p[1] == largest else largest  \\n            largest = p[1]\\n            res += 1 if islargest else 2\\n        return res\\n```\\n\\nSort by end based on ascending order and start on descending order\\nIdea from [@xllllx](https://leetcode.com/problems/set-intersection-size-at-least-two/discuss/113080/Python-O(nlogn))\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        max2 = [float(\\'-inf\\')] * 2\\n        cnt = 0\\n        for lo, hi in sorted(intervals, key=lambda t:(t[1], -t[0])):\\n            intcnt = sum(x>=lo for x in max2)\\n            cnt += 2 - intcnt\\n            if intcnt == 0:\\n                max2 = hi-1, hi\\n            elif intcnt == 1:\\n                max2 = max2[1], hi\\n        return cnt\\n```\\n\\nSort on start point on ascending order\\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        max2 = [float(\\'-inf\\')] * 2\\n        cnt = 0\\n        for lo, hi in sorted(intervals, key=lambda t:(t[0])):\\n            intcnt = sum(x>=lo for x in max2) \\n            cnt += 2 - intcnt\\n            if intcnt == 0:\\n                max2 = hi-1, hi\\n            elif intcnt == 1 and hi<max2[1]:\\n                max2 = hi-1, hi\\n            elif intcnt == 1:\\n                max2 = max2[1], hi\\n            elif intcnt == 2 and hi<max2[1]: #shrink the interval\\n                max2 = min(max2[0], hi-1), hi \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        intervals.sort(key = lambda x: (x[1]))\\n        largest = second = -1\\n        res = 0\\n        for p in intervals:\\n            islargest = p[0] <= largest\\n            issecond = p[0] <= second\\n            if islargest and issecond: continue\\n            \\n            second =  p[1] -1 if islargest is False or p[1] == largest else largest  \\n            largest = p[1]\\n            res += 1 if islargest else 2\\n        return res\\n```\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        max2 = [float(\\'-inf\\')] * 2\\n        cnt = 0\\n        for lo, hi in sorted(intervals, key=lambda t:(t[1], -t[0])):\\n            intcnt = sum(x>=lo for x in max2)\\n            cnt += 2 - intcnt\\n            if intcnt == 0:\\n                max2 = hi-1, hi\\n            elif intcnt == 1:\\n                max2 = max2[1], hi\\n        return cnt\\n```\n```\\nclass Solution:\\n    def intersectionSizeTwo(self, intervals):\\n        max2 = [float(\\'-inf\\')] * 2\\n        cnt = 0\\n        for lo, hi in sorted(intervals, key=lambda t:(t[0])):\\n            intcnt = sum(x>=lo for x in max2) \\n            cnt += 2 - intcnt\\n            if intcnt == 0:\\n                max2 = hi-1, hi\\n            elif intcnt == 1 and hi<max2[1]:\\n                max2 = hi-1, hi\\n            elif intcnt == 1:\\n                max2 = max2[1], hi\\n            elif intcnt == 2 and hi<max2[1]: #shrink the interval\\n                max2 = min(max2[0], hi-1), hi \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147538,
                "title": "java-solution-beats-100-of-the-solutions",
                "content": "\\nclass Solution {\\n    \\n    class spComparator implements Comparator<int[]>\\n    {\\n        public int compare(int[] a, int[] b)\\n        {\\n            return a[1]-b[1];\\n        }\\n    }\\n    \\n    \\n    public int intersectionSizeTwo(int[][] intervals) \\n    {\\n        \\n        // Arrays.sort(intervals, (a,b) -> a[1]!=b[1] ? a[1]-b[1] : a[0]-b[0] );\\n\\n        Arrays.sort(intervals, new spComparator());\\n        \\n        \\n        int n= intervals.length;\\n        if(n==0)\\n            return 0;\\n        \\n        int count=2;\\n        int last=intervals[0][1];\\n        int sec_last=intervals[0][1]-1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(intervals[i][0]<=sec_last)\\n                continue;\\n            else if(intervals[i][0]<=last)\\n            {\\n                sec_last=last;\\n                last=intervals[i][1];\\n                count++;\\n            }\\n            else\\n            {\\n                last=intervals[i][1];\\n                sec_last=intervals[i][1]-1;\\n                count+=2;\\n            }\\n        }\\n          \\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    class spComparator implements Comparator<int[]>\\n    {\\n        public int compare(int[] a, int[] b)\\n        {\\n            return a[1]-b[1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 139302,
                "title": "is-this-testcase-wrong",
                "content": "Input:\\n[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\nOutput:\\n7\\nExpected:\\n5\\nmy code \\n```\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        //find the smallest right boundary which is the left boundary\\n        //find the biggest left boundary which is the right boundary.\\n        int minRightIdx=0;\\n        int maxLeftIdx=0;\\n        for(int i=1;i< intervals.length;i++){\\n            if( intervals[i][0] > intervals[maxLeftIdx][0]){\\n                maxLeftIdx=i;\\n            }\\n            if( intervals[i][1] < intervals[minRightIdx][1]){\\n                minRightIdx=i;\\n            }\\n        }\\n        int gap = (intervals[maxLeftIdx][0]+1) - (intervals[minRightIdx][1]-1);\\n        return  gap>0?gap+1:2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        //find the smallest right boundary which is the left boundary\\n        //find the biggest left boundary which is the right boundary.\\n        int minRightIdx=0;\\n        int maxLeftIdx=0;\\n        for(int i=1;i< intervals.length;i++){\\n            if( intervals[i][0] > intervals[maxLeftIdx][0]){\\n                maxLeftIdx=i;\\n            }\\n            if( intervals[i][1] < intervals[minRightIdx][1]){\\n                minRightIdx=i;\\n            }\\n        }\\n        int gap = (intervals[maxLeftIdx][0]+1) - (intervals[minRightIdx][1]-1);\\n        return  gap>0?gap+1:2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132483,
                "title": "wrong-expected-answer-for-2-3-5-6",
                "content": "The right answer is 5, but the OJ prints wrong answer of 4.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 132198,
                "title": "dynamic-programming-works-fine",
                "content": "object Solution {\\n    \\n    /*\\n    Dynamic Programming\\n    take combination of two elements from each intercal and recursively build a set \\n    publish the set with minimum size at the end of each tree\\n    */\\n    \\n    \\n  var arrIntervals : Array[Interval] = _\\n  var minSetLengthAtEnd = Integer.MAX_VALUE\\n  var outSet : Set[Int] = _\\n    \\n    \\n     def intersectionSizeTwo(intervals: Array[Array[Int]]): Int = {\\n\\n    arrIntervals = intervals.map(x=> Interval(x(0),x(1)))\\n    getMinSet(0,Set.empty[Int])\\n    minSetLengthAtEnd\\n  }\\n\\n\\n  def getTwoCombinations(intvl:Interval) : List[Set[Int]] = {\\n\\n    var lst : List[Set[Int]] = Nil\\n\\n    for(i<- intvl.start to intvl.end)\\n      for (j<- i + 1 to intvl.end)\\n        {\\n          if(i!=j)\\n            lst = lst ::: List(Set(i,j))\\n        }\\n\\n    lst\\n\\n  }\\n\\n  def return2MinEachSet(set1:Set[Int], set2: Set[Int] ) : Set[Int] = {\\n\\n    set1 union  set2\\n\\n  }\\n\\n\\n  def getMinSet(indx:Int, s:Set[Int] ) : Unit = {\\n\\n    if(indx == arrIntervals.length )\\n      {\\n\\n        if(s.size < minSetLengthAtEnd && s.size >= 2)\\n          {\\n            minSetLengthAtEnd = s.size\\n            outSet = s\\n          }\\n\\n      }\\n    else {\\n\\n      val sets = getTwoCombinations(arrIntervals(indx))\\n      sets.foreach( x => getMinSet(indx + 1, s.union(x) ) )\\n\\n    }\\n\\n  }\\n    \\n}",
                "solutionTags": [],
                "code": "object Solution {\\n    \\n    /*\\n    Dynamic Programming\\n    take combination of two elements from each intercal and recursively build a set \\n    publish the set with minimum size at the end of each tree\\n    */\\n    \\n    \\n  var arrIntervals : Array[Interval] = _\\n  var minSetLengthAtEnd = Integer.MAX_VALUE\\n  var outSet : Set[Int] = _\\n    \\n    \\n     def intersectionSizeTwo(intervals: Array[Array[Int]]): Int = {\\n\\n    arrIntervals = intervals.map(x=> Interval(x(0),x(1)))\\n    getMinSet(0,Set.empty[Int])\\n    minSetLengthAtEnd\\n  }\\n\\n\\n  def getTwoCombinations(intvl:Interval) : List[Set[Int]] = {\\n\\n    var lst : List[Set[Int]] = Nil\\n\\n    for(i<- intvl.start to intvl.end)\\n      for (j<- i + 1 to intvl.end)\\n        {\\n          if(i!=j)\\n            lst = lst ::: List(Set(i,j))\\n        }\\n\\n    lst\\n\\n  }\\n\\n  def return2MinEachSet(set1:Set[Int], set2: Set[Int] ) : Set[Int] = {\\n\\n    set1 union  set2\\n\\n  }\\n\\n\\n  def getMinSet(indx:Int, s:Set[Int] ) : Unit = {\\n\\n    if(indx == arrIntervals.length )\\n      {\\n\\n        if(s.size < minSetLengthAtEnd && s.size >= 2)\\n          {\\n            minSetLengthAtEnd = s.size\\n            outSet = s\\n          }\\n\\n      }\\n    else {\\n\\n      val sets = getTwoCombinations(arrIntervals(indx))\\n      sets.foreach( x => getMinSet(indx + 1, s.union(x) ) )\\n\\n    }\\n\\n  }\\n    \\n}",
                "codeTag": "Python3"
            },
            {
                "id": 126863,
                "title": "what-s-wrong-with-this-code",
                "content": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        int minR = Integer.MAX_VALUE;\\n        int maxL = Integer.MIN_VALUE;\\n        for(int i=0; i<intervals.length; i++) {\\n            maxL = Math.max(maxL, intervals[i][0]);\\n            minR = Math.min(minR, intervals[i][1]);\\n            System.out.println(\"For i : \" + i + \" -> maxL : \" + maxL + \", minR : \" + minR);\\n        }\\n        return (maxL-minR+3);\\n    }\\n}\\n```\\n\\nDont\\' understand why this code is wrong.\\n\\nIt fails for following test case. But I feel that my answer is correct. The required set S {6,7,8,9,10,11,12} should be of size 7 to satisfy [3,7] and [11,12] to have intersection of size 2 atleast. Can someone help me understand what is wrong here?\\n\\n```\\nInput: [[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\nOutput: 7\\nExpected: 5\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int intersectionSizeTwo(int[][] intervals) {\\n        int minR = Integer.MAX_VALUE;\\n        int maxL = Integer.MIN_VALUE;\\n        for(int i=0; i<intervals.length; i++) {\\n            maxL = Math.max(maxL, intervals[i][0]);\\n            minR = Math.min(minR, intervals[i][1]);\\n            System.out.println(\"For i : \" + i + \" -> maxL : \" + maxL + \", minR : \" + minR);\\n        }\\n        return (maxL-minR+3);\\n    }\\n}\\n```\n```\\nInput: [[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\nOutput: 7\\nExpected: 5\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565710,
                "content": [
                    {
                        "username": "sase1017",
                        "content": "I even have issue with understanding the question, can someone explain?"
                    },
                    {
                        "username": "warres",
                        "content": "Wrote a solution to find the smallest *interval* instead of an actual mathematical *set*. And since the test cases all seemed continuous as well [2-3], [1-5], that increased my belief."
                    },
                    {
                        "username": "FayazAhmedUW",
                        "content": "Input:\\n[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\n\\nOutput:\\n7\\n\\nExpected Output:\\n5\\n\\nIn this test case, i think the smallest interval that makese sense is [6, 7, 8, 9, 10, 11, 12]. It overlaps with [3,7] and overlaps with [11,12]. How could any smaller interval (e.g. size 5) work?"
                    },
                    {
                        "username": "ashish_coder5",
                        "content": "Set of length 5 is\\n[3,7,8,11,12],\\n[4,7,8,11,12],\\n[5,7,8,11,12],\\n[6,7,8,11,12]."
                    },
                    {
                        "username": "saahilhameed",
                        "content": "For those you don\\'t understand the question , let me explain using the examples\\n\\n**Example 1:**\\nInput: intervals = [[1,3], [3,7], [8,9]]\\n\\nIn this example, the given intervals are [1,3], [3,7], and [8,9]. We need to find a containing set that includes at least **two integers** from each interval. Let\\'s analyze this step by step:\\n\\n1. Interval [1,3]: We need at least two integers from this interval. We can choose [2, 3].\\n2. Interval [3,7]: We need at least two integers from this interval. We can choose [3, 4].\\n3. Interval [8,9]: We need at least two integers from this interval. We can choose [8, 9].\\n\\nSo, the containing set that meets the criteria is [2, 3, 4, 8, 9], and its minimum size is 5.\\n\\n**Example 2:**\\nInput: intervals = [[1,3], [1,4], [2,5], [3,5]]\\n\\nIn this example, the given intervals are [1,3], [1,4], [2,5], and [3,5]. Let\\'s find a containing set with at least two integers from each interval:\\n\\n1. Interval [1,3]: We need at least two integers from this interval. We can choose [2, 3].\\n2. Interval [1,4]: We need at least two integers from this interval. We can choose [2, 3].\\n3. Interval [2,5]: We need at least two integers from this interval. We can choose [3, 4].\\n4. Interval [3,5]: We need at least two integers from this interval. We can choose [4, 5].\\n\\nThe containing set that meets the criteria is [2, 3, 4], and its minimum size is 3.\\n\\n**Example 3:**\\nInput: intervals = [[1,2], [2,3], [2,4], [4,5]]\\n\\nIn this example, the given intervals are [1,2], [2,3], [2,4], and [4,5]:\\n\\n1. Interval [1,2]: We need at least two integers from this interval. We can choose [1, 2].\\n2. Interval [2,3]: We need at least two integers from this interval. We can choose [2, 3].\\n3. Interval [2,4]: We need at least two integers from this interval. We can choose [3, 4].\\n4. Interval [4,5]: We need at least two integers from this interval. We can choose [4, 5].\\n\\nThe containing set that meets the criteria is [1, 2, 3, 4, 5], and its minimum size is 5.\\n\\nThe goal is to find a containing set that includes at least two integers from each interval and has the smallest possible size."
                    },
                    {
                        "username": "Krishna-iwnl",
                        "content": "[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\n\\nsolution  : 7  -  [6,12]\\n\\nExpected  :  5  - ??\\n\\nfor [3,7] to have atleast 2 elements we need minimum 6 in range.\\nfor [11,12] to have 2 we need 12 as max for our range.\\n\\nHow is a range of 5 even possible.\\n\\nI hope i didnt miss somthing too obvious."
                    },
                    {
                        "username": "SMYL",
                        "content": "[6, 7, 8, 11, 12] The result doesn\\'t have to be an interval."
                    }
                ]
            },
            {
                "id": 1566892,
                "content": [
                    {
                        "username": "sase1017",
                        "content": "I even have issue with understanding the question, can someone explain?"
                    },
                    {
                        "username": "warres",
                        "content": "Wrote a solution to find the smallest *interval* instead of an actual mathematical *set*. And since the test cases all seemed continuous as well [2-3], [1-5], that increased my belief."
                    },
                    {
                        "username": "FayazAhmedUW",
                        "content": "Input:\\n[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\n\\nOutput:\\n7\\n\\nExpected Output:\\n5\\n\\nIn this test case, i think the smallest interval that makese sense is [6, 7, 8, 9, 10, 11, 12]. It overlaps with [3,7] and overlaps with [11,12]. How could any smaller interval (e.g. size 5) work?"
                    },
                    {
                        "username": "ashish_coder5",
                        "content": "Set of length 5 is\\n[3,7,8,11,12],\\n[4,7,8,11,12],\\n[5,7,8,11,12],\\n[6,7,8,11,12]."
                    },
                    {
                        "username": "saahilhameed",
                        "content": "For those you don\\'t understand the question , let me explain using the examples\\n\\n**Example 1:**\\nInput: intervals = [[1,3], [3,7], [8,9]]\\n\\nIn this example, the given intervals are [1,3], [3,7], and [8,9]. We need to find a containing set that includes at least **two integers** from each interval. Let\\'s analyze this step by step:\\n\\n1. Interval [1,3]: We need at least two integers from this interval. We can choose [2, 3].\\n2. Interval [3,7]: We need at least two integers from this interval. We can choose [3, 4].\\n3. Interval [8,9]: We need at least two integers from this interval. We can choose [8, 9].\\n\\nSo, the containing set that meets the criteria is [2, 3, 4, 8, 9], and its minimum size is 5.\\n\\n**Example 2:**\\nInput: intervals = [[1,3], [1,4], [2,5], [3,5]]\\n\\nIn this example, the given intervals are [1,3], [1,4], [2,5], and [3,5]. Let\\'s find a containing set with at least two integers from each interval:\\n\\n1. Interval [1,3]: We need at least two integers from this interval. We can choose [2, 3].\\n2. Interval [1,4]: We need at least two integers from this interval. We can choose [2, 3].\\n3. Interval [2,5]: We need at least two integers from this interval. We can choose [3, 4].\\n4. Interval [3,5]: We need at least two integers from this interval. We can choose [4, 5].\\n\\nThe containing set that meets the criteria is [2, 3, 4], and its minimum size is 3.\\n\\n**Example 3:**\\nInput: intervals = [[1,2], [2,3], [2,4], [4,5]]\\n\\nIn this example, the given intervals are [1,2], [2,3], [2,4], and [4,5]:\\n\\n1. Interval [1,2]: We need at least two integers from this interval. We can choose [1, 2].\\n2. Interval [2,3]: We need at least two integers from this interval. We can choose [2, 3].\\n3. Interval [2,4]: We need at least two integers from this interval. We can choose [3, 4].\\n4. Interval [4,5]: We need at least two integers from this interval. We can choose [4, 5].\\n\\nThe containing set that meets the criteria is [1, 2, 3, 4, 5], and its minimum size is 5.\\n\\nThe goal is to find a containing set that includes at least two integers from each interval and has the smallest possible size."
                    },
                    {
                        "username": "Krishna-iwnl",
                        "content": "[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\n\\nsolution  : 7  -  [6,12]\\n\\nExpected  :  5  - ??\\n\\nfor [3,7] to have atleast 2 elements we need minimum 6 in range.\\nfor [11,12] to have 2 we need 12 as max for our range.\\n\\nHow is a range of 5 even possible.\\n\\nI hope i didnt miss somthing too obvious."
                    },
                    {
                        "username": "SMYL",
                        "content": "[6, 7, 8, 11, 12] The result doesn\\'t have to be an interval."
                    }
                ]
            },
            {
                "id": 1570815,
                "content": [
                    {
                        "username": "sase1017",
                        "content": "I even have issue with understanding the question, can someone explain?"
                    },
                    {
                        "username": "warres",
                        "content": "Wrote a solution to find the smallest *interval* instead of an actual mathematical *set*. And since the test cases all seemed continuous as well [2-3], [1-5], that increased my belief."
                    },
                    {
                        "username": "FayazAhmedUW",
                        "content": "Input:\\n[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\n\\nOutput:\\n7\\n\\nExpected Output:\\n5\\n\\nIn this test case, i think the smallest interval that makese sense is [6, 7, 8, 9, 10, 11, 12]. It overlaps with [3,7] and overlaps with [11,12]. How could any smaller interval (e.g. size 5) work?"
                    },
                    {
                        "username": "ashish_coder5",
                        "content": "Set of length 5 is\\n[3,7,8,11,12],\\n[4,7,8,11,12],\\n[5,7,8,11,12],\\n[6,7,8,11,12]."
                    },
                    {
                        "username": "saahilhameed",
                        "content": "For those you don\\'t understand the question , let me explain using the examples\\n\\n**Example 1:**\\nInput: intervals = [[1,3], [3,7], [8,9]]\\n\\nIn this example, the given intervals are [1,3], [3,7], and [8,9]. We need to find a containing set that includes at least **two integers** from each interval. Let\\'s analyze this step by step:\\n\\n1. Interval [1,3]: We need at least two integers from this interval. We can choose [2, 3].\\n2. Interval [3,7]: We need at least two integers from this interval. We can choose [3, 4].\\n3. Interval [8,9]: We need at least two integers from this interval. We can choose [8, 9].\\n\\nSo, the containing set that meets the criteria is [2, 3, 4, 8, 9], and its minimum size is 5.\\n\\n**Example 2:**\\nInput: intervals = [[1,3], [1,4], [2,5], [3,5]]\\n\\nIn this example, the given intervals are [1,3], [1,4], [2,5], and [3,5]. Let\\'s find a containing set with at least two integers from each interval:\\n\\n1. Interval [1,3]: We need at least two integers from this interval. We can choose [2, 3].\\n2. Interval [1,4]: We need at least two integers from this interval. We can choose [2, 3].\\n3. Interval [2,5]: We need at least two integers from this interval. We can choose [3, 4].\\n4. Interval [3,5]: We need at least two integers from this interval. We can choose [4, 5].\\n\\nThe containing set that meets the criteria is [2, 3, 4], and its minimum size is 3.\\n\\n**Example 3:**\\nInput: intervals = [[1,2], [2,3], [2,4], [4,5]]\\n\\nIn this example, the given intervals are [1,2], [2,3], [2,4], and [4,5]:\\n\\n1. Interval [1,2]: We need at least two integers from this interval. We can choose [1, 2].\\n2. Interval [2,3]: We need at least two integers from this interval. We can choose [2, 3].\\n3. Interval [2,4]: We need at least two integers from this interval. We can choose [3, 4].\\n4. Interval [4,5]: We need at least two integers from this interval. We can choose [4, 5].\\n\\nThe containing set that meets the criteria is [1, 2, 3, 4, 5], and its minimum size is 5.\\n\\nThe goal is to find a containing set that includes at least two integers from each interval and has the smallest possible size."
                    },
                    {
                        "username": "Krishna-iwnl",
                        "content": "[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\n\\nsolution  : 7  -  [6,12]\\n\\nExpected  :  5  - ??\\n\\nfor [3,7] to have atleast 2 elements we need minimum 6 in range.\\nfor [11,12] to have 2 we need 12 as max for our range.\\n\\nHow is a range of 5 even possible.\\n\\nI hope i didnt miss somthing too obvious."
                    },
                    {
                        "username": "SMYL",
                        "content": "[6, 7, 8, 11, 12] The result doesn\\'t have to be an interval."
                    }
                ]
            },
            {
                "id": 2011434,
                "content": [
                    {
                        "username": "sase1017",
                        "content": "I even have issue with understanding the question, can someone explain?"
                    },
                    {
                        "username": "warres",
                        "content": "Wrote a solution to find the smallest *interval* instead of an actual mathematical *set*. And since the test cases all seemed continuous as well [2-3], [1-5], that increased my belief."
                    },
                    {
                        "username": "FayazAhmedUW",
                        "content": "Input:\\n[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\n\\nOutput:\\n7\\n\\nExpected Output:\\n5\\n\\nIn this test case, i think the smallest interval that makese sense is [6, 7, 8, 9, 10, 11, 12]. It overlaps with [3,7] and overlaps with [11,12]. How could any smaller interval (e.g. size 5) work?"
                    },
                    {
                        "username": "ashish_coder5",
                        "content": "Set of length 5 is\\n[3,7,8,11,12],\\n[4,7,8,11,12],\\n[5,7,8,11,12],\\n[6,7,8,11,12]."
                    },
                    {
                        "username": "saahilhameed",
                        "content": "For those you don\\'t understand the question , let me explain using the examples\\n\\n**Example 1:**\\nInput: intervals = [[1,3], [3,7], [8,9]]\\n\\nIn this example, the given intervals are [1,3], [3,7], and [8,9]. We need to find a containing set that includes at least **two integers** from each interval. Let\\'s analyze this step by step:\\n\\n1. Interval [1,3]: We need at least two integers from this interval. We can choose [2, 3].\\n2. Interval [3,7]: We need at least two integers from this interval. We can choose [3, 4].\\n3. Interval [8,9]: We need at least two integers from this interval. We can choose [8, 9].\\n\\nSo, the containing set that meets the criteria is [2, 3, 4, 8, 9], and its minimum size is 5.\\n\\n**Example 2:**\\nInput: intervals = [[1,3], [1,4], [2,5], [3,5]]\\n\\nIn this example, the given intervals are [1,3], [1,4], [2,5], and [3,5]. Let\\'s find a containing set with at least two integers from each interval:\\n\\n1. Interval [1,3]: We need at least two integers from this interval. We can choose [2, 3].\\n2. Interval [1,4]: We need at least two integers from this interval. We can choose [2, 3].\\n3. Interval [2,5]: We need at least two integers from this interval. We can choose [3, 4].\\n4. Interval [3,5]: We need at least two integers from this interval. We can choose [4, 5].\\n\\nThe containing set that meets the criteria is [2, 3, 4], and its minimum size is 3.\\n\\n**Example 3:**\\nInput: intervals = [[1,2], [2,3], [2,4], [4,5]]\\n\\nIn this example, the given intervals are [1,2], [2,3], [2,4], and [4,5]:\\n\\n1. Interval [1,2]: We need at least two integers from this interval. We can choose [1, 2].\\n2. Interval [2,3]: We need at least two integers from this interval. We can choose [2, 3].\\n3. Interval [2,4]: We need at least two integers from this interval. We can choose [3, 4].\\n4. Interval [4,5]: We need at least two integers from this interval. We can choose [4, 5].\\n\\nThe containing set that meets the criteria is [1, 2, 3, 4, 5], and its minimum size is 5.\\n\\nThe goal is to find a containing set that includes at least two integers from each interval and has the smallest possible size."
                    },
                    {
                        "username": "Krishna-iwnl",
                        "content": "[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\n\\nsolution  : 7  -  [6,12]\\n\\nExpected  :  5  - ??\\n\\nfor [3,7] to have atleast 2 elements we need minimum 6 in range.\\nfor [11,12] to have 2 we need 12 as max for our range.\\n\\nHow is a range of 5 even possible.\\n\\nI hope i didnt miss somthing too obvious."
                    },
                    {
                        "username": "SMYL",
                        "content": "[6, 7, 8, 11, 12] The result doesn\\'t have to be an interval."
                    }
                ]
            },
            {
                "id": 1572796,
                "content": [
                    {
                        "username": "sase1017",
                        "content": "I even have issue with understanding the question, can someone explain?"
                    },
                    {
                        "username": "warres",
                        "content": "Wrote a solution to find the smallest *interval* instead of an actual mathematical *set*. And since the test cases all seemed continuous as well [2-3], [1-5], that increased my belief."
                    },
                    {
                        "username": "FayazAhmedUW",
                        "content": "Input:\\n[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\n\\nOutput:\\n7\\n\\nExpected Output:\\n5\\n\\nIn this test case, i think the smallest interval that makese sense is [6, 7, 8, 9, 10, 11, 12]. It overlaps with [3,7] and overlaps with [11,12]. How could any smaller interval (e.g. size 5) work?"
                    },
                    {
                        "username": "ashish_coder5",
                        "content": "Set of length 5 is\\n[3,7,8,11,12],\\n[4,7,8,11,12],\\n[5,7,8,11,12],\\n[6,7,8,11,12]."
                    },
                    {
                        "username": "saahilhameed",
                        "content": "For those you don\\'t understand the question , let me explain using the examples\\n\\n**Example 1:**\\nInput: intervals = [[1,3], [3,7], [8,9]]\\n\\nIn this example, the given intervals are [1,3], [3,7], and [8,9]. We need to find a containing set that includes at least **two integers** from each interval. Let\\'s analyze this step by step:\\n\\n1. Interval [1,3]: We need at least two integers from this interval. We can choose [2, 3].\\n2. Interval [3,7]: We need at least two integers from this interval. We can choose [3, 4].\\n3. Interval [8,9]: We need at least two integers from this interval. We can choose [8, 9].\\n\\nSo, the containing set that meets the criteria is [2, 3, 4, 8, 9], and its minimum size is 5.\\n\\n**Example 2:**\\nInput: intervals = [[1,3], [1,4], [2,5], [3,5]]\\n\\nIn this example, the given intervals are [1,3], [1,4], [2,5], and [3,5]. Let\\'s find a containing set with at least two integers from each interval:\\n\\n1. Interval [1,3]: We need at least two integers from this interval. We can choose [2, 3].\\n2. Interval [1,4]: We need at least two integers from this interval. We can choose [2, 3].\\n3. Interval [2,5]: We need at least two integers from this interval. We can choose [3, 4].\\n4. Interval [3,5]: We need at least two integers from this interval. We can choose [4, 5].\\n\\nThe containing set that meets the criteria is [2, 3, 4], and its minimum size is 3.\\n\\n**Example 3:**\\nInput: intervals = [[1,2], [2,3], [2,4], [4,5]]\\n\\nIn this example, the given intervals are [1,2], [2,3], [2,4], and [4,5]:\\n\\n1. Interval [1,2]: We need at least two integers from this interval. We can choose [1, 2].\\n2. Interval [2,3]: We need at least two integers from this interval. We can choose [2, 3].\\n3. Interval [2,4]: We need at least two integers from this interval. We can choose [3, 4].\\n4. Interval [4,5]: We need at least two integers from this interval. We can choose [4, 5].\\n\\nThe containing set that meets the criteria is [1, 2, 3, 4, 5], and its minimum size is 5.\\n\\nThe goal is to find a containing set that includes at least two integers from each interval and has the smallest possible size."
                    },
                    {
                        "username": "Krishna-iwnl",
                        "content": "[[2,10],[3,7],[3,15],[4,11],[6,12],[6,16],[7,8],[7,11],[7,15],[11,12]]\\n\\nsolution  : 7  -  [6,12]\\n\\nExpected  :  5  - ??\\n\\nfor [3,7] to have atleast 2 elements we need minimum 6 in range.\\nfor [11,12] to have 2 we need 12 as max for our range.\\n\\nHow is a range of 5 even possible.\\n\\nI hope i didnt miss somthing too obvious."
                    },
                    {
                        "username": "SMYL",
                        "content": "[6, 7, 8, 11, 12] The result doesn\\'t have to be an interval."
                    }
                ]
            }
        ]
    },
    {
        "title": "Bold Words in String",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564991,
                "content": [
                    {
                        "username": "ccwei",
                        "content": "Look the same to me, am I missing something?"
                    },
                    {
                        "username": "venendroid",
                        "content": "This question seems to me like Medium or Hard. Any one feel the same?"
                    }
                ]
            },
            {
                "id": 1573933,
                "content": [
                    {
                        "username": "ccwei",
                        "content": "Look the same to me, am I missing something?"
                    },
                    {
                        "username": "venendroid",
                        "content": "This question seems to me like Medium or Hard. Any one feel the same?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Employee Free Time",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1709547,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "IMO should go to \"Medium\" category."
                    },
                    {
                        "username": "as9vd2",
                        "content": "[@krex0r](/krex0r) Haha yeah, it\\'s always a bit of a blow when you do a hard problem, are proud of yourself, but the majority of the comment section is calling it a joke. But yeah, I think this one should be medium."
                    },
                    {
                        "username": "breadreamyum",
                        "content": "I\\'d agree "
                    },
                    {
                        "username": "krex0r",
                        "content": "First `Hard` I did in less than 20 minutes, I was happy until I read this comment (I agree with you though)"
                    },
                    {
                        "username": "yelun",
                        "content": "This is almost the same as the first merge intervals question, once identified. \\n\\nThe only trick is to use a heap. You can even shove it into a gigantic List and then sort the list after. Its the same time complexity and space.\\n\\nThen take the open windows (gaps) of the merged list"
                    },
                    {
                        "username": "ginchang",
                        "content": "Tip: \\nConsider all intervals are from one person - reduce this problem to interval merge topic where the only difference is to output the free slots."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I think it would be better to make a slight change to this problem description and add at the end.\n\nFollow-up: Can you solve this problem in O(N log K) time where K = schedule.size(). \n\nI think that would allow people who come up the O(N Log N) time solutions to walk away with a win but also hint that there is an optimized solution which in turn justifies why this is a hard vs a mislabeled medium. "
                    },
                    {
                        "username": "h4o4",
                        "content": "LeetCode 23 - Merge k Sorted Lists\\n+\\nLeetCode 57 - Insert Interval"
                    },
                    {
                        "username": "prayag",
                        "content": "There are Mediums more challenging than this Hard."
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "No editorial solution by June 2023. Looks like a medium"
                    }
                ]
            },
            {
                "id": 1570450,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "IMO should go to \"Medium\" category."
                    },
                    {
                        "username": "as9vd2",
                        "content": "[@krex0r](/krex0r) Haha yeah, it\\'s always a bit of a blow when you do a hard problem, are proud of yourself, but the majority of the comment section is calling it a joke. But yeah, I think this one should be medium."
                    },
                    {
                        "username": "breadreamyum",
                        "content": "I\\'d agree "
                    },
                    {
                        "username": "krex0r",
                        "content": "First `Hard` I did in less than 20 minutes, I was happy until I read this comment (I agree with you though)"
                    },
                    {
                        "username": "yelun",
                        "content": "This is almost the same as the first merge intervals question, once identified. \\n\\nThe only trick is to use a heap. You can even shove it into a gigantic List and then sort the list after. Its the same time complexity and space.\\n\\nThen take the open windows (gaps) of the merged list"
                    },
                    {
                        "username": "ginchang",
                        "content": "Tip: \\nConsider all intervals are from one person - reduce this problem to interval merge topic where the only difference is to output the free slots."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I think it would be better to make a slight change to this problem description and add at the end.\n\nFollow-up: Can you solve this problem in O(N log K) time where K = schedule.size(). \n\nI think that would allow people who come up the O(N Log N) time solutions to walk away with a win but also hint that there is an optimized solution which in turn justifies why this is a hard vs a mislabeled medium. "
                    },
                    {
                        "username": "h4o4",
                        "content": "LeetCode 23 - Merge k Sorted Lists\\n+\\nLeetCode 57 - Insert Interval"
                    },
                    {
                        "username": "prayag",
                        "content": "There are Mediums more challenging than this Hard."
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "No editorial solution by June 2023. Looks like a medium"
                    }
                ]
            },
            {
                "id": 1575109,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "IMO should go to \"Medium\" category."
                    },
                    {
                        "username": "as9vd2",
                        "content": "[@krex0r](/krex0r) Haha yeah, it\\'s always a bit of a blow when you do a hard problem, are proud of yourself, but the majority of the comment section is calling it a joke. But yeah, I think this one should be medium."
                    },
                    {
                        "username": "breadreamyum",
                        "content": "I\\'d agree "
                    },
                    {
                        "username": "krex0r",
                        "content": "First `Hard` I did in less than 20 minutes, I was happy until I read this comment (I agree with you though)"
                    },
                    {
                        "username": "yelun",
                        "content": "This is almost the same as the first merge intervals question, once identified. \\n\\nThe only trick is to use a heap. You can even shove it into a gigantic List and then sort the list after. Its the same time complexity and space.\\n\\nThen take the open windows (gaps) of the merged list"
                    },
                    {
                        "username": "ginchang",
                        "content": "Tip: \\nConsider all intervals are from one person - reduce this problem to interval merge topic where the only difference is to output the free slots."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I think it would be better to make a slight change to this problem description and add at the end.\n\nFollow-up: Can you solve this problem in O(N log K) time where K = schedule.size(). \n\nI think that would allow people who come up the O(N Log N) time solutions to walk away with a win but also hint that there is an optimized solution which in turn justifies why this is a hard vs a mislabeled medium. "
                    },
                    {
                        "username": "h4o4",
                        "content": "LeetCode 23 - Merge k Sorted Lists\\n+\\nLeetCode 57 - Insert Interval"
                    },
                    {
                        "username": "prayag",
                        "content": "There are Mediums more challenging than this Hard."
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "No editorial solution by June 2023. Looks like a medium"
                    }
                ]
            },
            {
                "id": 1800518,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "IMO should go to \"Medium\" category."
                    },
                    {
                        "username": "as9vd2",
                        "content": "[@krex0r](/krex0r) Haha yeah, it\\'s always a bit of a blow when you do a hard problem, are proud of yourself, but the majority of the comment section is calling it a joke. But yeah, I think this one should be medium."
                    },
                    {
                        "username": "breadreamyum",
                        "content": "I\\'d agree "
                    },
                    {
                        "username": "krex0r",
                        "content": "First `Hard` I did in less than 20 minutes, I was happy until I read this comment (I agree with you though)"
                    },
                    {
                        "username": "yelun",
                        "content": "This is almost the same as the first merge intervals question, once identified. \\n\\nThe only trick is to use a heap. You can even shove it into a gigantic List and then sort the list after. Its the same time complexity and space.\\n\\nThen take the open windows (gaps) of the merged list"
                    },
                    {
                        "username": "ginchang",
                        "content": "Tip: \\nConsider all intervals are from one person - reduce this problem to interval merge topic where the only difference is to output the free slots."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I think it would be better to make a slight change to this problem description and add at the end.\n\nFollow-up: Can you solve this problem in O(N log K) time where K = schedule.size(). \n\nI think that would allow people who come up the O(N Log N) time solutions to walk away with a win but also hint that there is an optimized solution which in turn justifies why this is a hard vs a mislabeled medium. "
                    },
                    {
                        "username": "h4o4",
                        "content": "LeetCode 23 - Merge k Sorted Lists\\n+\\nLeetCode 57 - Insert Interval"
                    },
                    {
                        "username": "prayag",
                        "content": "There are Mediums more challenging than this Hard."
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "No editorial solution by June 2023. Looks like a medium"
                    }
                ]
            },
            {
                "id": 1743277,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "IMO should go to \"Medium\" category."
                    },
                    {
                        "username": "as9vd2",
                        "content": "[@krex0r](/krex0r) Haha yeah, it\\'s always a bit of a blow when you do a hard problem, are proud of yourself, but the majority of the comment section is calling it a joke. But yeah, I think this one should be medium."
                    },
                    {
                        "username": "breadreamyum",
                        "content": "I\\'d agree "
                    },
                    {
                        "username": "krex0r",
                        "content": "First `Hard` I did in less than 20 minutes, I was happy until I read this comment (I agree with you though)"
                    },
                    {
                        "username": "yelun",
                        "content": "This is almost the same as the first merge intervals question, once identified. \\n\\nThe only trick is to use a heap. You can even shove it into a gigantic List and then sort the list after. Its the same time complexity and space.\\n\\nThen take the open windows (gaps) of the merged list"
                    },
                    {
                        "username": "ginchang",
                        "content": "Tip: \\nConsider all intervals are from one person - reduce this problem to interval merge topic where the only difference is to output the free slots."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I think it would be better to make a slight change to this problem description and add at the end.\n\nFollow-up: Can you solve this problem in O(N log K) time where K = schedule.size(). \n\nI think that would allow people who come up the O(N Log N) time solutions to walk away with a win but also hint that there is an optimized solution which in turn justifies why this is a hard vs a mislabeled medium. "
                    },
                    {
                        "username": "h4o4",
                        "content": "LeetCode 23 - Merge k Sorted Lists\\n+\\nLeetCode 57 - Insert Interval"
                    },
                    {
                        "username": "prayag",
                        "content": "There are Mediums more challenging than this Hard."
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "No editorial solution by June 2023. Looks like a medium"
                    }
                ]
            },
            {
                "id": 2016364,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "IMO should go to \"Medium\" category."
                    },
                    {
                        "username": "as9vd2",
                        "content": "[@krex0r](/krex0r) Haha yeah, it\\'s always a bit of a blow when you do a hard problem, are proud of yourself, but the majority of the comment section is calling it a joke. But yeah, I think this one should be medium."
                    },
                    {
                        "username": "breadreamyum",
                        "content": "I\\'d agree "
                    },
                    {
                        "username": "krex0r",
                        "content": "First `Hard` I did in less than 20 minutes, I was happy until I read this comment (I agree with you though)"
                    },
                    {
                        "username": "yelun",
                        "content": "This is almost the same as the first merge intervals question, once identified. \\n\\nThe only trick is to use a heap. You can even shove it into a gigantic List and then sort the list after. Its the same time complexity and space.\\n\\nThen take the open windows (gaps) of the merged list"
                    },
                    {
                        "username": "ginchang",
                        "content": "Tip: \\nConsider all intervals are from one person - reduce this problem to interval merge topic where the only difference is to output the free slots."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I think it would be better to make a slight change to this problem description and add at the end.\n\nFollow-up: Can you solve this problem in O(N log K) time where K = schedule.size(). \n\nI think that would allow people who come up the O(N Log N) time solutions to walk away with a win but also hint that there is an optimized solution which in turn justifies why this is a hard vs a mislabeled medium. "
                    },
                    {
                        "username": "h4o4",
                        "content": "LeetCode 23 - Merge k Sorted Lists\\n+\\nLeetCode 57 - Insert Interval"
                    },
                    {
                        "username": "prayag",
                        "content": "There are Mediums more challenging than this Hard."
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "No editorial solution by June 2023. Looks like a medium"
                    }
                ]
            },
            {
                "id": 1946165,
                "content": [
                    {
                        "username": "sorokus-dev",
                        "content": "IMO should go to \"Medium\" category."
                    },
                    {
                        "username": "as9vd2",
                        "content": "[@krex0r](/krex0r) Haha yeah, it\\'s always a bit of a blow when you do a hard problem, are proud of yourself, but the majority of the comment section is calling it a joke. But yeah, I think this one should be medium."
                    },
                    {
                        "username": "breadreamyum",
                        "content": "I\\'d agree "
                    },
                    {
                        "username": "krex0r",
                        "content": "First `Hard` I did in less than 20 minutes, I was happy until I read this comment (I agree with you though)"
                    },
                    {
                        "username": "yelun",
                        "content": "This is almost the same as the first merge intervals question, once identified. \\n\\nThe only trick is to use a heap. You can even shove it into a gigantic List and then sort the list after. Its the same time complexity and space.\\n\\nThen take the open windows (gaps) of the merged list"
                    },
                    {
                        "username": "ginchang",
                        "content": "Tip: \\nConsider all intervals are from one person - reduce this problem to interval merge topic where the only difference is to output the free slots."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I think it would be better to make a slight change to this problem description and add at the end.\n\nFollow-up: Can you solve this problem in O(N log K) time where K = schedule.size(). \n\nI think that would allow people who come up the O(N Log N) time solutions to walk away with a win but also hint that there is an optimized solution which in turn justifies why this is a hard vs a mislabeled medium. "
                    },
                    {
                        "username": "h4o4",
                        "content": "LeetCode 23 - Merge k Sorted Lists\\n+\\nLeetCode 57 - Insert Interval"
                    },
                    {
                        "username": "prayag",
                        "content": "There are Mediums more challenging than this Hard."
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "No editorial solution by June 2023. Looks like a medium"
                    }
                ]
            }
        ]
    }
]