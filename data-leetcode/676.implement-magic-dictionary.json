[
    {
        "title": "Sort Colors",
        "question_content": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.\n&nbsp;\nExample 1:\n\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n\nExample 2:\n\nInput: nums = [2,0,1]\nOutput: [0,1,2]\n\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\t1 <= n <= 300\n\tnums[i] is either 0, 1, or 2.\n\n&nbsp;\nFollow up:&nbsp;Could you come up with a one-pass algorithm using only&nbsp;constant extra space?",
        "solutions": [
            {
                "id": 26481,
                "title": "python-o-n-1-pass-in-place-solution-with-explanation",
                "content": "This is a [dutch partitioning problem][1]. We are classifying the array into four groups: red, white, unclassified, and blue. Initially we group all elements into unclassified. We iterate from the beginning as long as the white pointer is less than the blue pointer. \\n\\nIf the white pointer is red (nums[white] == 0), we swap with the red pointer and move both white and red pointer forward. If the pointer is white (nums[white] == 1), the element is already in correct place, so we don't have to swap, just move the white pointer forward. If the white pointer is blue, we swap with the latest unclassified element.\\n\\n\\n    def sortColors(self, nums):\\n        red, white, blue = 0, 0, len(nums)-1\\n        \\n        while white <= blue:\\n            if nums[white] == 0:\\n                nums[red], nums[white] = nums[white], nums[red]\\n                white += 1\\n                red += 1\\n            elif nums[white] == 1:\\n                white += 1\\n            else:\\n                nums[white], nums[blue] = nums[blue], nums[white]\\n                blue -= 1\\n                \\n                \\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Dutch_national_flag_problem",
                "solutionTags": [
                    "Python"
                ],
                "code": "This is a [dutch partitioning problem][1]. We are classifying the array into four groups: red, white, unclassified, and blue. Initially we group all elements into unclassified. We iterate from the beginning as long as the white pointer is less than the blue pointer. \\n\\nIf the white pointer is red (nums[white] == 0), we swap with the red pointer and move both white and red pointer forward. If the pointer is white (nums[white] == 1), the element is already in correct place, so we don't have to swap, just move the white pointer forward. If the white pointer is blue, we swap with the latest unclassified element.\\n\\n\\n    def sortColors(self, nums):\\n        red, white, blue = 0, 0, len(nums)-1\\n        \\n        while white <= blue:\\n            if nums[white] == 0:\\n                nums[red], nums[white] = nums[white], nums[red]\\n                white += 1\\n                red += 1\\n            elif nums[white] == 1:\\n                white += 1\\n            else:\\n                nums[white], nums[blue] = nums[blue], nums[white]\\n                blue -= 1\\n                \\n                \\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Dutch_national_flag_problem",
                "codeTag": "Java"
            },
            {
                "id": 26472,
                "title": "share-my-at-most-two-pass-constant-space-10-line-solution",
                "content": "The idea is to sweep all 0s to the left and all 2s to the right, then all 1s are left in the middle.\\n\\nIt is hard to define what is a \"one-pass\" solution but this algorithm is bounded by O(2n), meaning that at most each element will be seen and operated twice (in the case of all 0s). You may be able to write an algorithm which goes through the list only once, but each step requires multiple operations, leading the total operations larger than O(2n).\\n\\n        class Solution {\\n        public:\\n            void sortColors(int A[], int n) {\\n                int second=n-1, zero=0;\\n                for (int i=0; i<=second; i++) {\\n                    while (A[i]==2 && i<second) swap(A[i], A[second--]);\\n                    while (A[i]==0 && i>zero) swap(A[i], A[zero++]);\\n                }\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            void sortColors(int A[], int n) {\\n                int second=n-1, zero=0;\\n                for (int i=0; i<=second; i++) {\\n                    while (A[i]==2 && i<second) swap(A[i], A[second--]);\\n                    while (A[i]==0 && i>zero) swap(A[i], A[zero++]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 26474,
                "title": "sharing-c-solution-with-good-explanation",
                "content": "The solution requires the use of tracking 3 positions, the Low, Mid and High.\\n\\nWe assume that the mid is the \"Unknown\" area that we must evaluate.\\n\\nIf we encounter a 0, we know that it will be on the low end of the array, and if we encounter a 2, we know it will be on the high end of the array.\\n\\nTo achieve this in one pass without preprocessing (counting), we simply traverse the unknown will generating the low and high ends.\\n\\nTake this example:\\n\\nAssume our input is: 1 0 2 2 1 0 (short for simplicity).\\n\\nRunning the algorithm by hand would look something like:\\n\\n        1 0 2 2 1 0\\n        ^         ^\\n        L         H\\n        M\\n\\n        Mid != 0 || 2\\n        Mid++\\n\\n        1 0 2 2 1 0\\n        ^ ^       ^\\n        L M       H\\n\\n        Mid == 0\\n        Swap Low and Mid\\n        Mid++\\n        Low++\\n\\n        0 1 2 2 1 0\\n          ^ ^     ^\\n          L M     H\\n\\n        Mid == 2\\n        Swap High and Mid\\n        High--\\n\\n        0 1 0 2 1 2\\n          ^ ^   ^\\n          L M   H\\n\\n        Mid == 0\\n        Swap Low and Mid\\n        Mid++\\n        Low++\\n\\n        0 0 1 2 1 2\\n            ^ ^ ^\\n            L M H\\n\\n        Mid == 2\\n        Swap High and Mid\\n        High--\\n\\n        0 0 1 1 2 2\\n            ^ ^\\n            L M\\n              H\\n\\n        Mid <= High is our exit case\\n\\nImplemented in C++, it looks like:\\n\\n    class Solution {\\n        public:\\n        void sortColors(vector<int>& nums) \\n        {\\n            int tmp = 0, low = 0, mid = 0, high = nums.size() - 1;\\n        \\n            while(mid <= high)\\n            {\\n                if(nums[mid] == 0)\\n                {\\n                    tmp = nums[low];\\n                    nums[low] = nums[mid];\\n                    nums[mid] = tmp;\\n                    low++;\\n                    mid++;\\n                }\\n                else if(nums[mid] == 1)\\n                {\\n                    mid++;\\n                }\\n                else if(nums[mid] == 2)\\n                {\\n                    tmp = nums[high];\\n                    nums[high] = nums[mid];\\n                    nums[mid] = tmp;\\n                    high--;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        void sortColors(vector<int>& nums) \\n        {\\n            int tmp = 0, low = 0, mid = 0, high = nums.size() - 1;\\n        \\n            while(mid <= high)\\n            {\\n                if(nums[mid] == 0)\\n                {\\n                    tmp = nums[low];\\n                    nums[low] = nums[mid];\\n                    nums[mid] = tmp;\\n                    low++;\\n                    mid++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 26500,
                "title": "four-different-solutions",
                "content": "    // two pass O(m+n) space\\n    void sortColors(int A[], int n) {\\n        int num0 = 0, num1 = 0, num2 = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if (A[i] == 0) ++num0;\\n            else if (A[i] == 1) ++num1;\\n            else if (A[i] == 2) ++num2;\\n        }\\n        \\n        for(int i = 0; i < num0; ++i) A[i] = 0;\\n        for(int i = 0; i < num1; ++i) A[num0+i] = 1;\\n        for(int i = 0; i < num2; ++i) A[num0+num1+i] = 2;\\n    }\\n    \\n    // one pass in place solution\\n    void sortColors(int A[], int n) {\\n        int n0 = -1, n1 = -1, n2 = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] == 0) \\n            {\\n                A[++n2] = 2; A[++n1] = 1; A[++n0] = 0;\\n            }\\n            else if (A[i] == 1) \\n            {\\n                A[++n2] = 2; A[++n1] = 1;\\n            }\\n            else if (A[i] == 2) \\n            {\\n                A[++n2] = 2;\\n            }\\n        }\\n    }\\n    \\n    // one pass in place solution\\n    void sortColors(int A[], int n) {\\n        int j = 0, k = n - 1;\\n        for (int i = 0; i <= k; ++i){\\n            if (A[i] == 0 && i != j)\\n                swap(A[i--], A[j++]);\\n            else if (A[i] == 2 && i != k)\\n                swap(A[i--], A[k--]);\\n        }\\n    }\\n    \\n    // one pass in place solution\\n    void sortColors(int A[], int n) {\\n        int j = 0, k = n-1;\\n        for (int i=0; i <= k; i++) {\\n            if (A[i] == 0)\\n                swap(A[i], A[j++]);\\n            else if (A[i] == 2)\\n                swap(A[i--], A[k--]);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    // two pass O(m+n) space\\n    void sortColors(int A[], int n) {\\n        int num0 = 0, num1 = 0, num2 = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if (A[i] == 0) ++num0;\\n            else if (A[i] == 1) ++num1;\\n            else if (A[i] == 2) ++num2;\\n        }\\n        \\n        for(int i = 0; i < num0; ++i) A[i] = 0;\\n        for(int i = 0; i < num1; ++i) A[num0+i] = 1;\\n        for(int i = 0; i < num2; ++i) A[num0+num1+i] = 2;\\n    }\\n    \\n    // one pass in place solution\\n    void sortColors(int A[], int n) {\\n        int n0 = -1, n1 = -1, n2 = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] == 0) \\n            {\\n                A[++n2] = 2; A[++n1] = 1; A[++n0] = 0;\\n            }\\n            else if (A[i] == 1) \\n            {\\n                A[++n2] = 2; A[++n1] = 1;\\n            }\\n            else if (A[i] == 2) \\n            {\\n                A[++n2] = 2;\\n            }\\n        }\\n    }\\n    \\n    // one pass in place solution\\n    void sortColors(int A[], int n) {\\n        int j = 0, k = n - 1;\\n        for (int i = 0; i <= k; ++i){\\n            if (A[i] == 0 && i != j)\\n                swap(A[i--], A[j++]);\\n            else if (A[i] == 2 && i != k)\\n                swap(A[i--], A[k--]);\\n        }\\n    }\\n    \\n    // one pass in place solution\\n    void sortColors(int A[], int n) {\\n        int j = 0, k = n-1;\\n        for (int i=0; i <= k; i++) {\\n            if (A[i] == 0)\\n                swap(A[i], A[j++]);\\n            else if (A[i] == 2)\\n                swap(A[i--], A[k--]);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3164333,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int l = 0;\\n        int m = 0;\\n        int h = nums.size()-1;\\n\\n        while(m<=h){\\n            if(nums[m]==0){\\n                swap(nums[l], nums[m]);\\n                l++;\\n                m++;\\n            }\\n            else if(nums[m]==1){\\n                m++;\\n            }\\n            else if(nums[m]==2){\\n                swap(nums[m], nums[h]);\\n                h--;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n\\n        red, white, blue = 0, 0, len(nums) - 1\\n\\n        while white <= blue:\\n            if nums[white] == 0:\\n                nums[white], nums[red] = nums[red], nums[white]\\n                red += 1\\n                white += 1\\n            elif nums[white] == 1:\\n                white += 1\\n            else:\\n                nums[white], nums[blue] = nums[blue], nums[white]\\n                blue -= 1\\n```\\n\\n```Java []\\nclass Solution {\\n  public void sortColors(int[] nums) {\\n    int l = 0;\\n    int r = nums.length - 1;\\n\\n    for (int i = 0; i <= r;)\\n      if (nums[i] == 0)\\n        swap(nums, i++, l++);\\n      else if (nums[i] == 1)\\n        ++i;\\n      else\\n        swap(nums, i, r--);\\n  }\\n\\n  private void swap(int[] nums, int i, int j) {\\n    final int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int l = 0;\\n        int m = 0;\\n        int h = nums.size()-1;\\n\\n        while(m<=h){\\n            if(nums[m]==0){\\n                swap(nums[l], nums[m]);\\n                l++;\\n                m++;\\n            }\\n            else if(nums[m]==1){\\n                m++;\\n            }\\n            else if(nums[m]==2){\\n                swap(nums[m], nums[h]);\\n                h--;\\n            }\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n\\n        red, white, blue = 0, 0, len(nums) - 1\\n\\n        while white <= blue:\\n            if nums[white] == 0:\\n                nums[white], nums[red] = nums[red], nums[white]\\n                red += 1\\n                white += 1\\n            elif nums[white] == 1:\\n                white += 1\\n            else:\\n                nums[white], nums[blue] = nums[blue], nums[white]\\n                blue -= 1\\n```\n```Java []\\nclass Solution {\\n  public void sortColors(int[] nums) {\\n    int l = 0;\\n    int r = nums.length - 1;\\n\\n    for (int i = 0; i <= r;)\\n      if (nums[i] == 0)\\n        swap(nums, i++, l++);\\n      else if (nums[i] == 1)\\n        ++i;\\n      else\\n        swap(nums, i, r--);\\n  }\\n\\n  private void swap(int[] nums, int i, int j) {\\n    final int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464652,
                "title": "beats-100-c-java-python-javascript-two-pointer-dutch-national-flag-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*The problem requires us to sort an array of integers representing colors in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We are given that the colors red, white, and blue are represented by the integers 0, 1, and 2 respectively.*\\n\\n# Approach : ***Dutch National Flag algorithm***\\n<!-- Describe your approach to solving the problem. -->\\n\\n- The Dutch National Flag algorithm, also known as 3-way partitioning, is an algorithm for sorting an array containing three distinct values. The algorithm was designed to solve the problem of sorting an array containing only 0s, 1s, and 2s, which is similar to the problem in the given question.\\n\\n- The algorithm works by maintaining three pointers: low, mid, and high. The low pointer points to the beginning of the array, the high pointer points to the end of the array, and the mid pointer starts at the beginning of the array and moves through it.\\n\\n- The idea behind the algorithm is to keep all the 0s before the low pointer, all the 2s after the high pointer, and all the 1s between the low and high pointers. The algorithm moves the mid pointer through the array, comparing the value at each position with 1. If the value is 0, the element is swapped with the element at the low pointer, and the low and mid pointers are incremented. If the value is 2, the element is swapped with the element at the high pointer, and the high pointer is decremented. If the value is 1, the mid pointer is simply incremented.\\n\\n- The algorithm terminates when the mid pointer crosses the high pointer, indicating that all the elements have been processed and the array is sorted.\\n\\n> The Dutch National Flag algorithm is called one-pass because it sorts the array in a single pass through the elements. The time complexity of the algorithm is O(n), where n is the size of the array.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low = 0, mid = 0, high = nums.size()-1;\\n        while(mid <= high){\\n            if(nums[mid] == 0){\\n                swap(nums[low], nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            else if(nums[mid] == 1){\\n                mid++;\\n            }\\n            else{\\n                swap(nums[mid], nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0, mid = 0, high = nums.length - 1;\\n        while (mid <= high) {\\n            if (nums[mid] == 0) {\\n                swap(nums, low, mid);\\n                low++;\\n                mid++;\\n            } else if (nums[mid] == 1) {\\n                mid++;\\n            } else {\\n                swap(nums, mid, high);\\n                high--;\\n            }\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution(object):\\n    def sortColors(self, nums):\\n        low, mid, high = 0, 0, len(nums)-1\\n        while mid <= high:\\n            if nums[mid] == 0:\\n                nums[low], nums[mid] = nums[mid], nums[low]\\n                low += 1\\n                mid += 1\\n            elif nums[mid] == 1:\\n                mid += 1\\n            else:\\n                nums[mid], nums[high] = nums[high], nums[mid]\\n                high -= 1\\n```\\n```JavaScript []\\nvar sortColors = function(nums) {\\n    let low = 0, mid = 0, high = nums.length - 1;\\n    while (mid <= high) {\\n        if (nums[mid] === 0) {\\n            [nums[low], nums[mid]] = [nums[mid], nums[low]];\\n            low++;\\n            mid++;\\n        } else if (nums[mid] === 1) {\\n            mid++;\\n        } else {\\n            [nums[mid], nums[high]] = [nums[high], nums[mid]];\\n            high--;\\n        }\\n    }\\n};\\n\\n```\\n\\n\\n---\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/5cb823aa-2bf3-4976-80cf-5101b6c9fab2_1682716375.659027.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low = 0, mid = 0, high = nums.size()-1;\\n        while(mid <= high){\\n            if(nums[mid] == 0){\\n                swap(nums[low], nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            else if(nums[mid] == 1){\\n                mid++;\\n            }\\n            else{\\n                swap(nums[mid], nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0, mid = 0, high = nums.length - 1;\\n        while (mid <= high) {\\n            if (nums[mid] == 0) {\\n                swap(nums, low, mid);\\n                low++;\\n                mid++;\\n            } else if (nums[mid] == 1) {\\n                mid++;\\n            } else {\\n                swap(nums, mid, high);\\n                high--;\\n            }\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution(object):\\n    def sortColors(self, nums):\\n        low, mid, high = 0, 0, len(nums)-1\\n        while mid <= high:\\n            if nums[mid] == 0:\\n                nums[low], nums[mid] = nums[mid], nums[low]\\n                low += 1\\n                mid += 1\\n            elif nums[mid] == 1:\\n                mid += 1\\n            else:\\n                nums[mid], nums[high] = nums[high], nums[mid]\\n                high -= 1\\n```\n```JavaScript []\\nvar sortColors = function(nums) {\\n    let low = 0, mid = 0, high = nums.length - 1;\\n    while (mid <= high) {\\n        if (nums[mid] === 0) {\\n            [nums[low], nums[mid]] = [nums[mid], nums[low]];\\n            low++;\\n            mid++;\\n        } else if (nums[mid] === 1) {\\n            mid++;\\n        } else {\\n            [nums[mid], nums[high]] = [nums[high], nums[mid]];\\n            high--;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26479,
                "title": "ac-python-in-place-one-pass-solution-o-n-time-o-1-space-no-swap-no-count",
                "content": "    def sortColors(self, nums):\\n        i = j = 0\\n        for k in xrange(len(nums)):\\n            v = nums[k]\\n            nums[k] = 2\\n            if v < 2:\\n                nums[j] = 1\\n                j += 1\\n            if v == 0:\\n                nums[i] = 0\\n                i += 1\\n\\n    # 86 / 86 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 84.03%\\n\\n\\nJust like the Lomuto partition algorithm usually used in quick sort. We keep a loop invariant that [0,i) [i, j) [j, k) are 0s, 1s and 2s sorted in place for [0,k). Here \")\" means exclusive. We don't need to swap because we know the values we want.",
                "solutionTags": [],
                "code": "    def sortColors(self, nums):\\n        i = j = 0\\n        for k in xrange(len(nums)):\\n            v = nums[k]\\n            nums[k] = 2\\n            if v < 2:\\n                nums[j] = 1\\n                j += 1\\n            if v == 0:\\n                nums[i] = 0\\n                i += 1\\n\\n    # 86 / 86 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 84.03%\\n\\n\\nJust like the Lomuto partition algorithm usually used in quick sort. We keep a loop invariant that [0,i) [i, j) [j, k) are 0s, 1s and 2s sorted in place for [0,k). Here \")\" means exclusive. We don't need to swap because we know the values we want.",
                "codeTag": "Python3"
            },
            {
                "id": 1256365,
                "title": "c-easy-to-understand-full-explanation",
                "content": "## **Sort array of 0\\'s 1\\'s and 2\\'s**\\n\\n### constraints:\\n* O(1) extra space\\n* `nums[]` contain only 0, 1 and 2\\n\\n### Algorithm:\\n* Consider three pointers `low = 0, mid = 0, high = nums.size() - 1`\\n* The algorithm ensures that at any point, every element **before low is 0**, every element **after high is 2**, every element **in between are either 0, 1 or 2** i.e. unprocessed.\\n* We\\'ll use `mid` pointer to traverse and check the array elements i.e. `while(mid <= high)`. Three cases are possible:\\n\\t* `nums[mid] == 0` In this case `swap(nums[low], nums[mid])` and increment both low and mid pointer i.e. `low++ mid++`\\n\\t* `nums[mid] == 1` In this case `mid++`\\n\\t* `nums[mid] == 2` In this case `swap(nums[mid], nums[high])` and decrement high pointer i.e. `high--`\\n\\n### Example:\\n* Consider `nums[] = [0 1 1 0 1 2 1]`\\n* Iteration 1: \\n\\t* `low = 0, mid = 0, high = 6`\\n\\t*  `nums[mid] == 0` \\n\\t*   `swap(nums[low++], nums[mid++]` \\n\\t*   [**0** 1 1 0 1 2 1]\\n* Iteration 2: \\n\\t* `low = 1, mid = 1, high = 6`\\n\\t* `nums[mid] == 1`\\n\\t* `mid++`\\n\\t* [0 1 1 0 1 2 1]\\n* Iteration 3: \\n\\t* `low = 1, mid = 2, high = 6`\\n\\t* `nums[mid] == 1`\\n\\t* `mid++`\\n\\t* [0 1 1 0 1 2 1]\\n* Iteration 4: \\n\\t* `low = 1, mid = 3, high = 6`\\n\\t* `nums[mid] == 0`\\n\\t* `swap(nums[low++], nums[mid++]` \\n\\t* [0 **0** 1 **1** 1 2 1]\\n* Iteration 5: \\n\\t* `low = 2, mid = 4, high = 6`\\n\\t* `nums[mid] == 1`\\n\\t* `mid++`\\n\\t* [0 0 1 1 1 2 1]\\n* Iteration 6: \\n\\t* `low = 2, mid = 5, high = 6`\\n\\t* `nums[mid] == 2`\\n\\t* `swap(nums[mid], nums[high--]` \\n\\t* [0 0 1 1 1 **1** **2**]\\n* Iteration 7: \\n\\t* `low = 2, mid = 5, high = 5`\\n\\t* `nums[mid] == 1`\\n\\t* `mid++`\\n\\t* [0 0 1 1 1 1 2]\\n* Iteration 8:\\n\\t* `low = 2, mid = 6, high = 5`\\n\\t* `mid > high`\\n\\t* Exit the loop\\n\\n**code:**\\n\\n```\\n    void sortColors(vector<int>& nums) {\\n        \\n        // initialize variables:\\n        int low = 0, mid = 0, high = nums.size() - 1;\\n        \\n        // logic:\\n        while(mid <= high)\\n        {\\n            switch(nums[mid])\\n            {\\n                case 0: swap(nums[low++], nums[mid++]); break;\\n                \\n                case 1: mid++; break;\\n                \\n                case 2: swap(nums[mid], nums[high--]); break;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    void sortColors(vector<int>& nums) {\\n        \\n        // initialize variables:\\n        int low = 0, mid = 0, high = nums.size() - 1;\\n        \\n        // logic:\\n        while(mid <= high)\\n        {\\n            switch(nums[mid])\\n            {\\n                case 0: swap(nums[low++], nums[mid++]); break;\\n                \\n                case 1: mid++; break;\\n                \\n                case 2: swap(nums[mid], nums[high--]); break;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26549,
                "title": "java-solution-both-2-pass-and-1-pass",
                "content": "\\n    public void sortColors(int[] nums) {\\n        // 1-pass\\n        int p1 = 0, p2 = nums.length - 1, index = 0;\\n        while (index <= p2) {\\n            if (nums[index] == 0) {\\n                nums[index] = nums[p1];\\n                nums[p1] = 0;\\n                p1++;\\n            }\\n            if (nums[index] == 2) {\\n                nums[index] = nums[p2];\\n                nums[p2] = 2;\\n                p2--;\\n                index--;\\n            }\\n            index++;\\n        }\\n    }\\n\\n\\n----------\\n\\n    public void sortColors(int[] nums) {\\n        // 2-pass\\n        int count0 = 0, count1 = 0, count2 = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {count0++;}\\n            if (nums[i] == 1) {count1++;}\\n            if (nums[i] == 2) {count2++;}\\n        }\\n        for(int i = 0; i < nums.length; i++) {\\n            if (i < count0) {nums[i] = 0;}\\n            else if (i < count0 + count1) {nums[i] = 1;}\\n            else {nums[i] = 2;}\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public void sortColors(int[] nums) {\\n        // 1-pass\\n        int p1 = 0, p2 = nums.length - 1, index = 0;\\n        while (index <= p2) {\\n            if (nums[index] == 0) {\\n                nums[index] = nums[p1];\\n                nums[p1] = 0;\\n                p1++;\\n            }\\n            if (nums[index] == 2) {\\n                nums[index] = nums[p2];\\n                nums[p2] = 2;\\n                p2--;\\n                index--;\\n            }\\n            index++;\\n        }\\n    }\\n\\n\\n----------\\n\\n    public void sortColors(int[] nums) {\\n        // 2-pass\\n        int count0 = 0, count1 = 0, count2 = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {count0++;}\\n            if (nums[i] == 1) {count1++;}\\n            if (nums[i] == 2) {count2++;}\\n        }\\n        for(int i = 0; i < nums.length; i++) {\\n            if (i < count0) {nums[i] = 0;}\\n            else if (i < count0 + count1) {nums[i] = 1;}\\n            else {nums[i] = 2;}\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 681526,
                "title": "python-o-n-3-pointers-in-place-approach-explained",
                "content": "This problem is called Dutch national flag problem: https://en.wikipedia.org/wiki/Dutch_national_flag_problem\\n\\nThe idea here is the following: we keep 3 pointers: for each of colors (numbers). I called them\\n`beg = 0`, `mid = 0`, `end =  len(nums) - 1`. The **idea** here is to put sorted `0` and `1` to the **beginning** and sorted `2`s to the **end**.  Then we iterate over all elements and process each new element in the following way. Imagine, that we already sorted some of the elements, our invariant will be `00...0011...11......22....22`, where we already put some `0` and `1` in the beggining and some `2` to the end. Then there are 3 possible optinos for new element `?`:\\n\\n1. `00...0011...11?......22....22`, where `? = 1`, then we do not need to change any elements, just move `mid` pointer by `1` to the right.\\n2. `00...0011...11?......22....22`, where `? = 2`, then we need to put this element befor the first already sorted `2`, so we change these elements and then move pointer `end` by `1` to the left.\\n3. `00...0011...11?......22....22`, where `? = 0`, then we need to swap this element with the last  sorted `0` and also move two pointers `mid` and `beg` by 1.\\n\\nWe can see it this way, that pointers `beg`, `mid` and `end` always point at elements just `after` the last `0`, `after` the last `1` and `before` the first `2`.\\n\\n**Complexity**: Time complexity is `O(n)`, because each moment of time we move at least one of the pointers. Additional space complexity is `O(1)`: to keep only 3 variables: `beg`, `mid` and `end`.\\n\\n```\\nclass Solution:\\n    def sortColors(self, nums):\\n        beg, mid, end = 0, 0, len(nums) - 1\\n        \\n        while mid <= end:\\n            if nums[mid] == 0:\\n                nums[beg], nums[mid] = nums[mid], nums[beg]\\n                mid += 1\\n                beg += 1\\n            elif nums[mid] == 2:\\n                nums[mid], nums[end] = nums[end], nums[mid]\\n                end -= 1\\n            else:  #nums[mid] == 1:\\n                mid += 1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortColors(self, nums):\\n        beg, mid, end = 0, 0, len(nums) - 1\\n        \\n        while mid <= end:\\n            if nums[mid] == 0:\\n                nums[beg], nums[mid] = nums[mid], nums[beg]\\n                mid += 1\\n                beg += 1\\n            elif nums[mid] == 2:\\n                nums[mid], nums[end] = nums[end], nums[mid]\\n                end -= 1\\n            else:  #nums[mid] == 1:\\n                mid += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273597,
                "title": "java-0ms-two-pointer-solution-with-detailed-explanation",
                "content": "We traverse the array and use two variables:\\n1. ```zeroIndex``` to indicate the index where we should put ```0``` \\n2. ```twoIndex``` to indicate the index where we should put ```2``` \\n\\nIf current element ```a[i]``` is ```0```, we swap ```a[i]``` and ```a[zeroIndex]```, if ```a[i]``` is ```2```, we swap ```a[i]``` and ```a[twoIndex]```, if ```a[i]``` is ```one```, we do nothing and continue to process next element.\\n```\\npublic void sortColors(int[] nums) {\\n\\tint zeroIndex = 0, twoIndex = nums.length - 1, i = 0;\\n\\twhile( i <= twoIndex ) {\\n\\t\\tif( nums[i] == 0 ) \\n\\t\\t\\tswap(nums, zeroIndex++, i++);\\n\\t\\telse if( nums[i] == 2)\\n\\t\\t\\tswap(nums, twoIndex--, i);    \\n\\t\\telse\\n\\t\\t\\ti++;\\n\\t}\\n}\\n\\npublic void swap(int[] nums, int i, int j) {\\n\\tint temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```zeroIndex```\n```0```\n```twoIndex```\n```2```\n```a[i]```\n```0```\n```a[i]```\n```a[zeroIndex]```\n```a[i]```\n```2```\n```a[i]```\n```a[twoIndex]```\n```a[i]```\n```one```\n```\\npublic void sortColors(int[] nums) {\\n\\tint zeroIndex = 0, twoIndex = nums.length - 1, i = 0;\\n\\twhile( i <= twoIndex ) {\\n\\t\\tif( nums[i] == 0 ) \\n\\t\\t\\tswap(nums, zeroIndex++, i++);\\n\\t\\telse if( nums[i] == 2)\\n\\t\\t\\tswap(nums, twoIndex--, i);    \\n\\t\\telse\\n\\t\\t\\ti++;\\n\\t}\\n}\\n\\npublic void swap(int[] nums, int i, int j) {\\n\\tint temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26518,
                "title": "4ms-and-only-5-lines-c-code-without-delete-and-insert",
                "content": "Here I label the end of same colour, and update for every item in nums.\\n\\n    void sortColors(vector<int>& nums) {\\n        int r=0, w=0, b=0; // label the end of different colors;\\n        for(int num: nums){\\n            if(num==0) {nums[b++]=2; nums[w++]=1; nums[r++]=0; } \\n            else if(num==1) {nums[b++]=2; nums[w++]=1;}\\n            else if(num==2) b++;\\n        }\\n    }",
                "solutionTags": [],
                "code": "Here I label the end of same colour, and update for every item in nums.\\n\\n    void sortColors(vector<int>& nums) {\\n        int r=0, w=0, b=0; // label the end of different colors;\\n        for(int num: nums){\\n            if(num==0) {nums[b++]=2; nums[w++]=1; nums[r++]=0; } \\n            else if(num==1) {nums[b++]=2; nums[w++]=1;}\\n            else if(num==2) b++;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1408321,
                "title": "3-solutions-from-brute-force-to-optimization-c-solution",
                "content": "**Here I will Give Three solutions to give to your Interviewer:**\\n**Method 1: Sorting the nums vector (PS. total scam)**\\n**Time complexity - O(n log n)**\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n       sort(nums.begin(), nums.end());\\n    }\\n};\\n```\\n**Method 2: keep a count of 0\\'s 1\\'s and 2\\'s**\\nTime complexity - O(2N)\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int count0 = 0;\\n        int count1 = 0; \\n        int count2  = 0;\\n        for(int i =0; i< nums.size(); i++){\\n            if(nums[i] == 0){\\n                count0++;\\n            }else if (nums[i] == 1){\\n                count1++;\\n            }else if (nums[i] ==2 ){\\n                count2++;\\n            }\\n            \\n         }\\n        for(int i =0; i< count0; i++){\\n            nums[i] =0;\\n        }\\n        for(int i =count0; i< (count1 + count0); i++){\\n            nums[i] =1;\\n        }\\n        for(int i =(count1 + count0); i< nums.size(); i++){\\n            nums[i] =2;\\n        }\\n        \\n    }\\n};\\n```\\n**Method 3: using 3 pointers**\\nTime complexity - O(N)\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low =0; \\n        int high = nums.size()-1;\\n        int mid =0;\\n        \\n        while(mid <= high){\\n            if(nums[mid] == 0){\\n                swap(nums[mid], nums[low]);\\n                low++;\\n                mid++;\\n            }\\n            else if(nums[mid] == 1){\\n                mid++;\\n            }\\n            else {\\n                swap(nums[mid], nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n       sort(nums.begin(), nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int count0 = 0;\\n        int count1 = 0; \\n        int count2  = 0;\\n        for(int i =0; i< nums.size(); i++){\\n            if(nums[i] == 0){\\n                count0++;\\n            }else if (nums[i] == 1){\\n                count1++;\\n            }else if (nums[i] ==2 ){\\n                count2++;\\n            }\\n            \\n         }\\n        for(int i =0; i< count0; i++){\\n            nums[i] =0;\\n        }\\n        for(int i =count0; i< (count1 + count0); i++){\\n            nums[i] =1;\\n        }\\n        for(int i =(count1 + count0); i< nums.size(); i++){\\n            nums[i] =2;\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low =0; \\n        int high = nums.size()-1;\\n        int mid =0;\\n        \\n        while(mid <= high){\\n            if(nums[mid] == 0){\\n                swap(nums[mid], nums[low]);\\n                low++;\\n                mid++;\\n            }\\n            else if(nums[mid] == 1){\\n                mid++;\\n            }\\n            else {\\n                swap(nums[mid], nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148221,
                "title": "java-2-pass-counting-sort-and-1-pass-quick-partition-with-video-tutorial-links",
                "content": "This problem is a testing of your \"sorting\" skills. Especially with ur understanding of counting sort and quicksort\\n**2-pass** is essentially counting sort [geeksforgeeks video tutorial for counting sort](https://www.youtube.com/watch?v=7zuGmKfUt7s&feature=youtu.be)\\n**1-pass**  is essentially the 3-way quick partition method in quicksort. check this [gret video demo](https://www.youtube.com/watch?v=WBFzOYJ5ybM&t=177s) from Professor Robert Sedgewick\\n```\\n    //-------------  SOLUTION 1: 2 SCANs ----------------//\\n    // counting sort\\n    public void sortColors(int[] A) {\\n        // count\\n        int[] counts = new int[3];\\n        for (int i: A) {\\n            counts[i]++;\\n        }\\n        // fill\\n        for (int i = 0; i < A.length; i++) {\\n            if (i < counts[0]) {\\n                A[i] = 0;\\n            } else if (i < counts[0] + counts[1]) {\\n                A[i] = 1;\\n            } else {\\n                A[i] = 2;\\n            }\\n        }\\n    }\\n```\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n```\\nquicksort 3-way partition\\n+------+---------+-------------+-------+\\n|  <p  |  =p     |  unseen .  |   > p  |\\n+------+---------+------------+-------+\\n        \\u2191          \\u2191           \\u2191\\n        lt         i            gt \\nlt: 1st elem == pivot\\ni:  1st unseen elem\\ngt: last unseen elem\\n```\\n```\\n    //-------------  SOLUTION 2: 1 SCAN ----------------//\\n    // 3-way partition used in quick sort\\n    public void sortColors(int[] nums) {\\n        int lt = 0, i = 0, gt = nums.length - 1;\\n        while (i <= gt) {\\n            if (nums[i] == 0) {\\n                swap(nums, lt++, i++);\\n            } else if (nums[i] == 2) {\\n                swap(nums, i, gt--);\\n            } else { // nums[i] == 1\\n                i++;\\n            }\\n        }\\n    }\\n    private void swap(int[] nums, int p1, int p2) {\\n        int temp = nums[p1];\\n        nums[p1] = nums[p2];\\n        nums[p2] = temp;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    //-------------  SOLUTION 1: 2 SCANs ----------------//\\n    // counting sort\\n    public void sortColors(int[] A) {\\n        // count\\n        int[] counts = new int[3];\\n        for (int i: A) {\\n            counts[i]++;\\n        }\\n        // fill\\n        for (int i = 0; i < A.length; i++) {\\n            if (i < counts[0]) {\\n                A[i] = 0;\\n            } else if (i < counts[0] + counts[1]) {\\n                A[i] = 1;\\n            } else {\\n                A[i] = 2;\\n            }\\n        }\\n    }\\n```\n```\\nquicksort 3-way partition\\n+------+---------+-------------+-------+\\n|  <p  |  =p     |  unseen .  |   > p  |\\n+------+---------+------------+-------+\\n        \\u2191          \\u2191           \\u2191\\n        lt         i            gt \\nlt: 1st elem == pivot\\ni:  1st unseen elem\\ngt: last unseen elem\\n```\n```\\n    //-------------  SOLUTION 2: 1 SCAN ----------------//\\n    // 3-way partition used in quick sort\\n    public void sortColors(int[] nums) {\\n        int lt = 0, i = 0, gt = nums.length - 1;\\n        while (i <= gt) {\\n            if (nums[i] == 0) {\\n                swap(nums, lt++, i++);\\n            } else if (nums[i] == 2) {\\n                swap(nums, i, gt--);\\n            } else { // nums[i] == 1\\n                i++;\\n            }\\n        }\\n    }\\n    private void swap(int[] nums, int p1, int p2) {\\n        int temp = nums[p1];\\n        nums[p1] = nums[p2];\\n        nums[p2] = temp;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26760,
                "title": "c-solution-in-8-lines-an-instance-of-the-dutch-national-flag-problem-by-edsger-dijkstra",
                "content": "A more general problem is the [Dutch national flag problem][1] by Edsger Dijkstra, which can be used to solve this problem, as well as partition in quicksort.\\n\\n    class Solution {\\n    public:\\n        void sortColors(int A[], int n) {\\n            int i = 0, lo = 0, hi = n - 1;\\n            // invariants: A[0..lo-1] are less than pivot 1, A[lo..i-1] equal, A[hi+1..end] greater\\n            while (i <= hi)\\n                if (A[i] < 1)\\n                    swap(A[i++], A[lo++]);\\n                else if (A[i] > 1)\\n                    swap(A[i], A[hi--]);\\n                else\\n                    i++;\\n        }\\n    };\\n\\n  [1]: http://en.wikipedia.org/wiki/Quicksort#Repeated_elements",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void sortColors(int A[], int n) {\\n            int i = 0, lo = 0, hi = n - 1;\\n            // invariants: A[0..lo-1] are less than pivot 1, A[lo..i-1] equal, A[hi+1..end] greater\\n            while (i <= hi)\\n                if (A[i] < 1)\\n                    swap(A[i++], A[lo++]);\\n                else if (A[i] > 1)\\n                    swap(A[i], A[hi--]);\\n                else\\n                    i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1049327,
                "title": "4-approaches-for-your-interview",
                "content": "### Approach 1: brute force checking \\n\\n**step1:** iterate and count each elem\\n**step2:** make the existing arr null to make this algo inplace\\n**step3:** print number of 0,1,2 w,r,t count value\\n\\n```\\nvar sortColors = function(arr) {\\n    \\n    let one=0, zero=0, two=0\\n    \\n\\n    // step1 \\n    for(let elem of arr){\\n        if(elem == 0) zero++\\n        else if ( elem == 1) one ++\\n        else two ++\\n    }\\n\\n\\n\\n\\n    // step2\\n    arr.length=0\\n\\n\\n\\n\\n    // step3\\n    for(let i=0;i<zero;i++) arr.push(0)\\n    for(let i=0;i<one;i++) arr.push(1)\\n    for(let i=0;i<two;i++) arr.push(2)    \\n    \\n\\n};\\n```\\n<hr> <hr> <br> <br> <br> \\n\\n### approach 1.2: Brute force checking  with one modification\\n\\n***IDEA** :  lets calc for 0 and 1 alone, and based on it, 2 will get autocalculated*\\n\\n\\n**step1:** iterate and count 0and 1 alone ( skip counting 2)\\n**step2:** two\\'s count is : (arr.length) - (one\\'s count) - (zero\\'s count)\\n**step3:** make the existing arr null to make this algo inplace\\n**step4:** print number of 0,1,2 w,r,t count value\\n\\n\\n***NOTE :***  this idea saves more than 50% memory for me ( from 30% in previous approach to, 86% efficient in this approach \\n\\n\\n<br>\\n\\n```\\nvar sortColors = function(arr) {\\n    \\n    let one=0, zero=0, two=0\\n    \\n\\n    // step1 \\n    for(let elem of arr){\\n        if(elem == 0) zero++\\n        else if ( elem == 1) one ++\\n    }\\n\\n\\n\\n\\n    // step2\\n    two = (arr.length) - (zero) - (one) \\n\\n\\n\\t// step3\\n    arr.length=0\\n\\n\\n\\n\\n    // step4\\n    for(let i=0;i<zero;i++) arr.push(0)\\n    for(let i=0;i<one;i++) arr.push(1)\\n    for(let i=0;i<two;i++) arr.push(2)    \\n    \\n\\n};\\n```\\n<hr> <hr> <br> <br> <br> \\n\\n### Approach 2: One pass algorithm\\n\\n<br>\\n\\n```\\nvar sortColors = function(arr) {\\n    \\n    let low=0, mid=0, high=arr.length-1\\n\\n\\n    while ( mid <= high ) { \\n    \\n        if( arr[mid] == 0 ){ \\n            swap( low, mid ); \\n            mid++; \\n            low++ ;\\n        } \\n    \\n        else if( arr[mid] == 1 ) {   \\n            mid++ ;  \\n        } \\n\\n\\n        else if( arr[mid] == 2 ) {\\n            swap( mid,high ); \\n            high--  \\n        } \\n    }\\n\\n\\n    function swap(a,b) {\\n        [arr[b], arr[a]] = [arr[a], arr[b]]\\n    }\\n\\n\\n};\\n```\\n<hr> <hr> <br> <br> <br> \\n\\n### Approach 3: intuitive approach \\ntwo pass algorithm \\n\\n<br>\\n\\n```\\nvar sortColors = function(arr) {\\n    \\n    let i=0\\n    for( let j=0; j<arr.length; j++){\\n        if(arr[j]==0){ \\n            [arr[i], arr[j]] = [arr[j], arr[i]]\\n            i++\\n        }\\n    \\n    }\\n\\n    let k=i\\n    for( let m=0; m<arr.length; m++){\\n        if(arr[m]==1){\\n             [arr[m], arr[k]] = [arr[k], arr[m]]\\n             k++\\n        }\\n       \\n    }   \\n\\n};\\n\\n// dry run this to get the approach \\n```\\n\\n<hr> <hr> <br> <br> <br> \\n\\n### Approach 4: Ninja Technique to get rejected\\uD83E\\uDD10\\noffcourse u can sort the array using inbuilt sort function\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar sortColors = function(arr) {\\n    \\n    let one=0, zero=0, two=0\\n    \\n\\n    // step1 \\n    for(let elem of arr){\\n        if(elem == 0) zero++\\n        else if ( elem == 1) one ++\\n        else two ++\\n    }\\n\\n\\n\\n\\n    // step2\\n    arr.length=0\\n\\n\\n\\n\\n    // step3\\n    for(let i=0;i<zero;i++) arr.push(0)\\n    for(let i=0;i<one;i++) arr.push(1)\\n    for(let i=0;i<two;i++) arr.push(2)    \\n    \\n\\n};\\n```\n```\\nvar sortColors = function(arr) {\\n    \\n    let one=0, zero=0, two=0\\n    \\n\\n    // step1 \\n    for(let elem of arr){\\n        if(elem == 0) zero++\\n        else if ( elem == 1) one ++\\n    }\\n\\n\\n\\n\\n    // step2\\n    two = (arr.length) - (zero) - (one) \\n\\n\\n\\t// step3\\n    arr.length=0\\n\\n\\n\\n\\n    // step4\\n    for(let i=0;i<zero;i++) arr.push(0)\\n    for(let i=0;i<one;i++) arr.push(1)\\n    for(let i=0;i<two;i++) arr.push(2)    \\n    \\n\\n};\\n```\n```\\nvar sortColors = function(arr) {\\n    \\n    let low=0, mid=0, high=arr.length-1\\n\\n\\n    while ( mid <= high ) { \\n    \\n        if( arr[mid] == 0 ){ \\n            swap( low, mid ); \\n            mid++; \\n            low++ ;\\n        } \\n    \\n        else if( arr[mid] == 1 ) {   \\n            mid++ ;  \\n        } \\n\\n\\n        else if( arr[mid] == 2 ) {\\n            swap( mid,high ); \\n            high--  \\n        } \\n    }\\n\\n\\n    function swap(a,b) {\\n        [arr[b], arr[a]] = [arr[a], arr[b]]\\n    }\\n\\n\\n};\\n```\n```\\nvar sortColors = function(arr) {\\n    \\n    let i=0\\n    for( let j=0; j<arr.length; j++){\\n        if(arr[j]==0){ \\n            [arr[i], arr[j]] = [arr[j], arr[i]]\\n            i++\\n        }\\n    \\n    }\\n\\n    let k=i\\n    for( let m=0; m<arr.length; m++){\\n        if(arr[m]==1){\\n             [arr[m], arr[k]] = [arr[k], arr[m]]\\n             k++\\n        }\\n       \\n    }   \\n\\n};\\n\\n// dry run this to get the approach \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26706,
                "title": "python-count-sort-and-one-pass-sort",
                "content": "        \\n    # count sort    \\n    def sortColors1(self, nums):\\n        c0 = c1 = c2 = 0\\n        for num in nums:\\n            if num == 0:\\n                c0 += 1\\n            elif num == 1:\\n                c1 += 1\\n            else:\\n                c2 += 1\\n        nums[:c0] = [0] * c0\\n        nums[c0:c0+c1] = [1] * c1\\n        nums[c0+c1:] = [2] * c2\\n       \\n    # one pass \\n    def sortColors(self, nums):\\n        # zero and r record the position of \"0\" and \"2\" respectively\\n        l, r, zero = 0, len(nums)-1, 0\\n        while l <= r:\\n            if nums[l] == 0:\\n                nums[l], nums[zero] = nums[zero], nums[l]\\n                l += 1; zero += 1\\n            elif nums[l] == 2:\\n                nums[l], nums[r] = nums[r], nums[l]\\n                r -= 1\\n            else:\\n                l += 1",
                "solutionTags": [
                    "Python",
                    "Counting Sort"
                ],
                "code": "        \\n    # count sort    \\n    def sortColors1(self, nums):\\n        c0 = c1 = c2 = 0\\n        for num in nums:\\n            if num == 0:\\n                c0 += 1\\n            elif num == 1:\\n                c1 += 1\\n            else:\\n                c2 += 1\\n        nums[:c0] = [0] * c0\\n        nums[c0:c0+c1] = [1] * c1\\n        nums[c0+c1:] = [2] * c2\\n       \\n    # one pass \\n    def sortColors(self, nums):\\n        # zero and r record the position of \"0\" and \"2\" respectively\\n        l, r, zero = 0, len(nums)-1, 0\\n        while l <= r:\\n            if nums[l] == 0:\\n                nums[l], nums[zero] = nums[zero], nums[l]\\n                l += 1; zero += 1\\n            elif nums[l] == 2:\\n                nums[l], nums[r] = nums[r], nums[l]\\n                r -= 1\\n            else:\\n                l += 1",
                "codeTag": "Python3"
            },
            {
                "id": 26635,
                "title": "short-c-5-line-solution-dutch-national-flag-problem",
                "content": "It's actually [Dutch national flag problem][1].\\n\\n    [, i): 0 \\n    [i, j]: 1\\n    (k, ...]: 2\\n    Once j meets k, the sorting is complete\\n\\nCode\\n\\n    class Solution { \\n    public:\\n        void sortColors(vector<int>& nums) {\\n            int i = 0, j = i, k = nums.size() - 1;\\n            \\n            while(j <= k){\\n                if(nums[j] == 0) swap(nums[i++], nums[j++]);\\n                else if(nums[j] == 1) j++;\\n                else swap(nums[k--], nums[j]);\\n            }\\n        }\\n    }; \\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Dutch_national_flag_problem",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution { \\n    public:\\n        void sortColors(vector<int>& nums) {\\n            int i = 0, j = i, k = nums.size() - 1;\\n            \\n            while(j <= k){\\n                if(nums[j] == 0) swap(nums[i++], nums[j++]);\\n                else if(nums[j] == 1) j++;\\n                else swap(nums[k--], nums[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 26679,
                "title": "c-one-pass-concise-solution",
                "content": "        \\n    void sortColors(vector<int>& nums) {\\n        int zero =0, l = 0, r = nums.size()-1;\\n        while (l <= r) {\\n            if (nums[l] == 0) \\n                swap(nums[l++], nums[zero++]);\\n            else if (nums[l] == 2) \\n                swap(nums[l], nums[r--]);\\n            else\\n                l++;\\n        }\\n    }",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "        \\n    void sortColors(vector<int>& nums) {\\n        int zero =0, l = 0, r = nums.size()-1;\\n        while (l <= r) {\\n            if (nums[l] == 0) \\n                swap(nums[l++], nums[zero++]);\\n            else if (nums[l] == 2) \\n                swap(nums[l], nums[r--]);\\n            else\\n                l++;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26700,
                "title": "my-c-solution-with-one-pass-and-o-n-time-and-o-n-space",
                "content": "    class Solution {\\n    public:\\n    //use counting sort\\n    void sortColors(int A[], int n) {\\n    int red = -1, white = -1, blue = -1;\\n\\n    for(int i = 0; i < n; i++){\\n        if(A[i] == 0){   \\n            A[++blue] = 2;\\n            A[++white] = 1;\\n            A[++red] = 0;\\n        }\\n        else if(A[i] == 1){\\n            A[++blue] = 2;\\n            A[++white] = 1;\\n        }\\n        else if(A[i] == 2)   \\n            A[++blue] = 2;\\n    }\\n    }\\n    };\\n\\nthe clever thing is that use three variable to store the three colors' index position.\\nWhen you face A[i] == 0, all the variables add 1 because 0 is former.\\nDo the same thing to other 2 situation.\\n\\nEx:\\nIf you just face 2, just need to assign 2 to the A[++blue], and \"++blue\" will increase \"blue\" with 1.\\nNext if you face 0, you will increase 3 variable and assign the number to A!\\n\\nIt will make sure you always get the right sorted array when you run the for loop.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    //use counting sort\\n    void sortColors(int A[], int n) {\\n    int red = -1, white = -1, blue = -1;\\n\\n    for(int i = 0; i < n; i++){\\n        if(A[i] == 0){   \\n            A[++blue] = 2;\\n            A[++white] = 1;\\n            A[++red] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 751942,
                "title": "easy-python-solution-for-beginners-with-explanation",
                "content": "You might already have seen from others that this is a [Dutch National Flag](https://en.wikipedia.org/wiki/Dutch_national_flag_problem) problem. My solution below uses the same logic but I will make an attempt to explain it so that you dont have to memorize this algorithm.\\n\\nBasically, we need 3 pointers.\\n\\n* Pointer (i) representing the index in our iteration over the array.\\n* Pointer (p0) repesenting the index we have to replace into if we found a 0.\\n* Pointer (p2) representing the index we have to replace into if we found a 2.\\n\\nBy placing 0\\'s and 2\\'s into correct positions, there is no need to specially reorder 1\\'s. All 1\\'s will eventually be left in correct positions. So we dont worry when we see a 1, we just move on to the next index in our iteration.\\n\\nSince we are arranging the numbers in ascending order, p0 should be initialized to 0 and p2 should be initialized to the last index of the array. So whenever we first find a 0, it will be put into the leftmost position, and p0 will be incremented. So the next time we find a 0, we place it into the index 1.\\n\\nSimilarly, whenever we first find a 2, it will be put into the rightmost position of the array, and p2 will be decremented.\\n\\n```python\\n# Time: O(n), space: O(1)\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        p0 = 0\\n        p2 = len(nums) - 1\\n        \\n        i = 0 # index being checked\\n        count = 0 # number of elements already sorted\\n        while count < len(nums):\\n            if nums[i] == 0: # if 0 is found, place it in p0\\n                nums[i], nums[p0] = nums[p0], nums[i]\\n                p0 += 1 # increment p0 so that next time when 0 is found, it will be put into correct position\\n                i += 1 # move on to the next element in iteration\\n            elif nums[i] == 1: # if it is a 1, do nothing, just move on to next element\\n                i += 1\\n            else: # if it is a 2, swap the elements and decrement p2. Since we dont know what elements we got swapped with from p2, it still needs to be checked. So dont increment i. \\n                nums[i], nums[p2] = nums[p2], nums[i]\\n\\t\\t\\t\\tp2 -= 1\\n            count += 1 # every iteration of while loop puts one element at correct position\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n# Time: O(n), space: O(1)\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        p0 = 0\\n        p2 = len(nums) - 1\\n        \\n        i = 0 # index being checked\\n        count = 0 # number of elements already sorted\\n        while count < len(nums):\\n            if nums[i] == 0: # if 0 is found, place it in p0\\n                nums[i], nums[p0] = nums[p0], nums[i]\\n                p0 += 1 # increment p0 so that next time when 0 is found, it will be put into correct position\\n                i += 1 # move on to the next element in iteration\\n            elif nums[i] == 1: # if it is a 1, do nothing, just move on to next element\\n                i += 1\\n            else: # if it is a 2, swap the elements and decrement p2. Since we dont know what elements we got swapped with from p2, it still needs to be checked. So dont increment i. \\n                nums[i], nums[p2] = nums[p2], nums[i]\\n\\t\\t\\t\\tp2 -= 1\\n            count += 1 # every iteration of while loop puts one element at correct position\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139809,
                "title": "clean-javascript-one-pass-solution",
                "content": "```js\\n// Example\\n// 0 0 | 1 | 2 1 | 2\\n//   l       i     r\\nfunction sortColors(nums) {\\n  function swap(i, j) {\\n    [nums[i], nums[j]] = [nums[j], nums[i]];\\n  }\\n\\n  let l = 0;\\n  let r = nums.length - 1;\\n  let i = 0;\\n\\n  while (i <= r) {\\n    const n = nums[i];\\n    if (n === 0) {\\n      swap(i, l);\\n      l++;\\n      i++;\\n    } else if (n === 2) {\\n      swap(i, r);\\n      r--;\\n    } else {\\n      i++;\\n    }\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n// Example\\n// 0 0 | 1 | 2 1 | 2\\n//   l       i     r\\nfunction sortColors(nums) {\\n  function swap(i, j) {\\n    [nums[i], nums[j]] = [nums[j], nums[i]];\\n  }\\n\\n  let l = 0;\\n  let r = nums.length - 1;\\n  let i = 0;\\n\\n  while (i <= r) {\\n    const n = nums[i];\\n    if (n === 0) {\\n      swap(i, l);\\n      l++;\\n      i++;\\n    } else if (n === 2) {\\n      swap(i, r);\\n      r--;\\n    } else {\\n      i++;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2358550,
                "title": "3-different-approaches-uber-sde-1-interview",
                "content": "# \\u2714 **Approach-1 Dutch National Flag Algo.**\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {            // Dutch National Flag Algo.\\n        int i=0,j=0,k=nums.size()-1;\\n        while(i<=k){                                // One pass\\n            if(nums[i]==0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums[i]==1){\\n                i++;\\n            }\\n            else{\\n                swap(nums[i],nums[k]);\\n                k--;\\n            }\\n        }\\n    }\\n};\\n\\n// TC: O(n) SC: O(1)\\n// Try yourself with 0 1 2 0 1 2 using this algo to understand it fully :)\\n```\\n# \\u2714 **Approach-2 Beginner Friendly 3 Pass O(2n) Soln.**\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int one=0,two=0,zero=0;\\n        for(int i=0;i<nums.size();i++){     //O(n)\\n           if(nums[i]==0)\\n               zero++;\\n            else if(nums[i]==1)\\n                one++;\\n            else\\n                two++;\\n        }\\n        nums.clear();                       //O(n)\\n        for(int i=0;i<zero;i++)             ///\\n            nums.emplace_back(0);           \\n        for(int i=0;i<one;i++)              ///  All 3 for loops altogether O(n)\\n            nums.emplace_back(1);\\n        for(int i=0;i<two;i++)              ///\\n            nums.emplace_back(2);\\n    }\\n};\\n//Total TC:O(n) SC:O(1)\\n```\\n# \\u2714 **Approach-3 One pass O(n) Soln.**\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {         //One pass\\n        int j = 0, k = nums.size()-1;\\n        for (int i=0; i <= k; i++) {                //O(n)\\n            if (nums[i] == 0)\\n                swap(nums[i], nums[j++]);\\n            else if (nums[i] == 2)\\n                swap(nums[i--], nums[k--]);\\n        }\\n    }\\n};\\n// Total TC:O(n) SC:\\n```\\n# **Please do upvote if it helps !  \\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {            // Dutch National Flag Algo.\\n        int i=0,j=0,k=nums.size()-1;\\n        while(i<=k){                                // One pass\\n            if(nums[i]==0){\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums[i]==1){\\n                i++;\\n            }\\n            else{\\n                swap(nums[i],nums[k]);\\n                k--;\\n            }\\n        }\\n    }\\n};\\n\\n// TC: O(n) SC: O(1)\\n// Try yourself with 0 1 2 0 1 2 using this algo to understand it fully :)\\n```\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int one=0,two=0,zero=0;\\n        for(int i=0;i<nums.size();i++){     //O(n)\\n           if(nums[i]==0)\\n               zero++;\\n            else if(nums[i]==1)\\n                one++;\\n            else\\n                two++;\\n        }\\n        nums.clear();                       //O(n)\\n        for(int i=0;i<zero;i++)             ///\\n            nums.emplace_back(0);           \\n        for(int i=0;i<one;i++)              ///  All 3 for loops altogether O(n)\\n            nums.emplace_back(1);\\n        for(int i=0;i<two;i++)              ///\\n            nums.emplace_back(2);\\n    }\\n};\\n//Total TC:O(n) SC:O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {         //One pass\\n        int j = 0, k = nums.size()-1;\\n        for (int i=0; i <= k; i++) {                //O(n)\\n            if (nums[i] == 0)\\n                swap(nums[i], nums[j++]);\\n            else if (nums[i] == 2)\\n                swap(nums[i--], nums[k--]);\\n        }\\n    }\\n};\\n// Total TC:O(n) SC:\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543059,
                "title": "c-0ms-simple-and-optimal-approach-dutch-flag-algo",
                "content": "### Simple Solution\\n\\n**Using Count Variables** *(RunTime : 0 ms (100%) & Memory Usage : 44.69%)*\\n\\tAs the constraint given that ```nums[i] is 0, 1, or 2.```, we can count number of 0,1 and 2. And fill it in given `nums` array.\\n\\t\\n\\tCODE:\\n\\t    void sortColors(vector<int>& nums) {\\n        int zero=0,one=0,two=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n           //count 0s,1s and 2s \\n            if(nums[i]==0){\\n                zero++;\\n            }else if(nums[i]==1)\\n            {\\n                one++;\\n            }else{\\n                two++;\\n            }\\n            \\n        }\\n        //final filling\\n        int i=0;\\n        while(zero){\\n            nums[i++]=0;\\n            zero--;\\n        }\\n        \\n        while(one){\\n            nums[i++]=1;\\n            one--;\\n        }\\n        \\n        while(two){\\n            nums[i++]=2;\\n            two--;\\n        }\\n    }\\n\\n### Optimal Solution\\n**Using Dutch Flag Algo** *(RunTime : 0 ms (100%) & Memory Usage : 91.24%)*\\n\\nExplanation:\\n1. Initailize three pointers `zero, one and two`.\\n2. Traverse pointer `two` in backward.\\n3. when 2 is encountered, just move to next step by decreamenting pointer `two`.\\n4. when 1 is encountered , swap with pointer `one` and increament pointer `one`\\n5. when 0 is encountered , swap with pointer `zero` and increament pointer `zero`.\\n6. Repeated from `Step 3` until pointer `one` and `two` cross each other (means sorted).\\n\\nCODE:\\n```\\nvoid sortColors(vector<int>& nums) {\\n        //pointers initailization.\\n        int zero = 0,one = 0,two =nums.size()-1;\\n        //move pointer two in reverse order\\n        \\n        while(one<=two){\\n            \\n            if(nums[two]==2){//means \\'2\\' is in correct place, so moving to previous element\\n                two--;\\n            }\\n            else if(nums[two]==1){//swaping element with pointer one\\n                nums[two]=nums[one];\\n                nums[one] = 1;\\n                one++;\\n            }\\n            else{//swaping element with pointer zero\\n                nums[two] = nums[zero];\\n                nums[zero]=0;\\n                \\n                if(zero==one)//when no ones encounter, zero and one will be same, so increasing one pointer when zero pointer is increasing.\\n                    one++;\\n                zero++;\\n            } \\n        }\\n    }\\n```\\n\\nThanks!!!\\n\\n```\\n\\tUseful == true ? Upvote() : Comment();   \\n```\\n\\nBy \\uD83D\\uDC93 JS",
                "solutionTags": [],
                "code": "```nums[i] is 0, 1, or 2.```\n```\\nvoid sortColors(vector<int>& nums) {\\n        //pointers initailization.\\n        int zero = 0,one = 0,two =nums.size()-1;\\n        //move pointer two in reverse order\\n        \\n        while(one<=two){\\n            \\n            if(nums[two]==2){//means \\'2\\' is in correct place, so moving to previous element\\n                two--;\\n            }\\n            else if(nums[two]==1){//swaping element with pointer one\\n                nums[two]=nums[one];\\n                nums[one] = 1;\\n                one++;\\n            }\\n            else{//swaping element with pointer zero\\n                nums[two] = nums[zero];\\n                nums[zero]=0;\\n                \\n                if(zero==one)//when no ones encounter, zero and one will be same, so increasing one pointer when zero pointer is increasing.\\n                    one++;\\n                zero++;\\n            } \\n        }\\n    }\\n```\n```\\n\\tUseful == true ? Upvote() : Comment();   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 682156,
                "title": "c-two-pointer-and-100-coverage-in-checking",
                "content": "**Idea:**\\nUse two pointers to indicate the sorted bounds of 0-color and 2-color, respectively.\\n**Special Note1:**\\nCheck each single item once and only once. Nothing more and nothing less.\\n\\n**Special Note2:**\\nI prefere for-loop than while-loop since I want to be a mean person in variable lifespan control:\\n1) A variable should be alive only when it\\'s necessary. They should perish asap. Remeber the Mobiv Ave in the movie \\'Matrix\\' [1]?\\n2) Few lines programmers\\' life much easier in debugging.\\n\\nTime/Space: O(N); O(1)\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        for(int i = 0, left = 0, right = nums.size() - 1; i <= right;i++){ // \\'right\\' is one smaller than index of last checked \\'2\\', need to be checked, but do not go beyond it\\n            if(nums[i] ==0) swap(nums[i], nums[left++]);         //before swapping, num[left]  is already checked, so i++ later\\n            else if(nums[i] ==2) swap(nums[i--], nums[right--]); //before swapping, num[right] is not     checked, so i-- now, to enasure stay in the same index after i++ operation\\n            //else continue;                                     // nums[i] is 1, just continue to next index\\n        }\\n    }\\n};\\n\\n```\\n\\nReference:\\n[1]\\nMobil Ave\\nInside the Matrix, Neo is trapped in a subway station named Mobil Ave (an anagram for limbo), a transition zone between the Matrix and the Machine City. He meets a \"family\" of programs, including a girl named Sati.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        for(int i = 0, left = 0, right = nums.size() - 1; i <= right;i++){ // \\'right\\' is one smaller than index of last checked \\'2\\', need to be checked, but do not go beyond it\\n            if(nums[i] ==0) swap(nums[i], nums[left++]);         //before swapping, num[left]  is already checked, so i++ later\\n            else if(nums[i] ==2) swap(nums[i--], nums[right--]); //before swapping, num[right] is not     checked, so i-- now, to enasure stay in the same index after i++ operation\\n            //else continue;                                     // nums[i] is 1, just continue to next index\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953415,
                "title": "easy-java-solution-single-pass-3-pointers-o-n-in-place-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution here is do it in a single pass with 3 pointers.\\n1. low pointer = 0 , this check all the entries before it are 0\\n2. mid pointer = 0, this will be used to iterate the array\\n3. high pointer = array length -1, this checkk all the entries after it are 2.\\n\\n- Now, we will iterate the array and check if the element is 0 then swap with low pointer and increment both low pointer and mid pointer.\\n- If the element is 1 just increment the mid pointer\\n- if the element is 2 swap with high pointer and decrement high but do not increment mid.( This is because if the number swapped from high pointer was 0 then we need to re swap it with low pointer).\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Take 3 Pointers low = 0, mid = 0 and high = nums.length -1;\\n- Use loop to iterate the array with condition mid <= high.(Since we only need to check middle elements of low and high).\\n- if element is 0 swap with low and low++, mid++.\\n- if element is 1 then mid++.\\n- if element is 2 then swap with high and high--.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLinear O(N), here N is number of elements in the array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0, mid = 0, high = nums.length-1;\\n\\n        while(mid <= high){\\n            if(nums[mid] == 0 ){\\n                //swap with left\\n                swap(nums,low, mid );\\n                low++;\\n                mid++;\\n            }else if(nums[mid] == 2){\\n                swap(nums, mid, high);\\n                high--;\\n            }else{\\n                mid++;\\n            }\\n        }\\n    }\\n\\n    public static void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0, mid = 0, high = nums.length-1;\\n\\n        while(mid <= high){\\n            if(nums[mid] == 0 ){\\n                //swap with left\\n                swap(nums,low, mid );\\n                low++;\\n                mid++;\\n            }else if(nums[mid] == 2){\\n                swap(nums, mid, high);\\n                high--;\\n            }else{\\n                mid++;\\n            }\\n        }\\n    }\\n\\n    public static void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543338,
                "title": "c-simple-and-easy-solution-5-lines-o-n-tc-o-1-sc-detailed-explanation",
                "content": "**Idea:**\\nWe hold three pointers: `zero_ptr` which points to the one after the last zero, `one_ptr` which points to the last one, and `two_ptr` which points to the first two.\\n`one_ptr` and `zero_ptr` both start from zero, so when `one_ptr` reaches `two_ptr` we are done.\\nSo we loop `while (one_ptr <= two_ptr)`.\\n1. If we find a zero in `one_ptr`, we swap `nums[zero_ptr]` and `nums[one_ptr]` and advance both, so now we added another zero to the beginning, and `nums[zero_ptr` is supposed to be a one so we pushed it to the end of all the ones.\\n2. If we already have a one in `nums[one_ptr]`, we just move on.\\n3. If we see a two, we swap `nums[two_ptr]` and `nums[one_ptr]`, so we added another two to the end.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int zero_ptr = 0, one_ptr = 0, two_ptr = nums.size()-1;\\n\\n        while (one_ptr <= two_ptr) {\\n            if (nums[one_ptr] == 0) swap(nums[zero_ptr++], nums[one_ptr++]);\\n            else if (nums[one_ptr] == 1) one_ptr++;\\n            else swap(nums[two_ptr--], nums[one_ptr]);\\n        }\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int zero_ptr = 0, one_ptr = 0, two_ptr = nums.size()-1;\\n\\n        while (one_ptr <= two_ptr) {\\n            if (nums[one_ptr] == 0) swap(nums[zero_ptr++], nums[one_ptr++]);\\n            else if (nums[one_ptr] == 1) one_ptr++;\\n            else swap(nums[two_ptr--], nums[one_ptr]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212485,
                "title": "c-100-faster-without-counting-0-s-1-s-and-2-s",
                "content": "\\nclass Solution {\\npublic:\\n\\n    void sortColors(vector<int>& nums) {\\n        int left=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                swap(nums[i],nums[left]);\\n                left++;\\n            }\\n        }\\n        //upper for loop will put all zeroes at the start\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                swap(nums[i],nums[left]);\\n                left++;\\n            }\\n        }\\n        //this for loop will put all ones after all zeroes and hence array is sorted now\\n    }\\n};\\n//**Upvote if you find it useful**",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    void sortColors(vector<int>& nums) {\\n        int left=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                swap(nums[i],nums[left]);\\n                left++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 681863,
                "title": "one-pass-memory-98-with-comments-and-explanation",
                "content": "Because you have only 3 values, 0, 1, 2, you can do it in one pass with 3 pointers.\\nYou know that if you encounter a 0, you can move it to the left group, and if a 2, to the right group. \\nTwo of the pointers are the edges of those 2 groups, while your third pointer is to the element that you will iterate and check values of.\\n\\nSo, checking one element at a time, swap it with the left edge if it\\'s a zero, and right side if it\\'s a 2.  If it\\'s a 1, leave it and go next (it will be moved/swapped later if necessary).\\n```\\nvar sortColors = function(nums) {\\n    let left = 0;\\n    let curr = 0;\\n    let right = nums.length-1;\\n    while (curr<=right) \\n       if (nums[curr] == 0) \\n        [nums[curr++], nums[left++]] = [nums[left], nums[curr]]; //swap values, you are always putting the 0 to the left edge, can increment new current since we have already looked at it before (curr>=left so we have already evaluated it)\\n       else if (nums[curr] == 2) \\n        [nums[curr], nums[right--]] = [nums[right], nums[curr]]; //swap, so right side always has 2\\'s, do not increment current yet because don\\'t know what value it was.\\n       else\\n        curr++; // current was a 1, so you don\\'t move it to either side, go next\\n};\\n```\\n\\nIf this explanation helped, please upvote it so others can notice as well, thanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortColors = function(nums) {\\n    let left = 0;\\n    let curr = 0;\\n    let right = nums.length-1;\\n    while (curr<=right) \\n       if (nums[curr] == 0) \\n        [nums[curr++], nums[left++]] = [nums[left], nums[curr]]; //swap values, you are always putting the 0 to the left edge, can increment new current since we have already looked at it before (curr>=left so we have already evaluated it)\\n       else if (nums[curr] == 2) \\n        [nums[curr], nums[right--]] = [nums[right], nums[curr]]; //swap, so right side always has 2\\'s, do not increment current yet because don\\'t know what value it was.\\n       else\\n        curr++; // current was a 1, so you don\\'t move it to either side, go next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26647,
                "title": "share-one-pass-java-solution",
                "content": "The concept is simple. Maintain two pointer, pointer \"one\" indicates the begging of all ones and pointer \"two\" indicates the begging of all twos. When we meet 1, we move 1 to the end of 1 sequence which is begging of two sequence then move begging of 2 forward 1. Doing the same to the 2.\\n\\n    public class Solution {\\n    public void sortColors(int[] A) {\\n        int one = 0; \\n        int two = 0;\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==0){\\n                A[i] = A[two];\\n                A[two] = A[one];\\n                A[one] = 0;\\n                one++;\\n                two++;\\n            }\\n            else if(A[i]==1){\\n                A[i] = A[two];\\n                A[two] = 1;\\n                two++;\\n            }\\n        }\\n    }}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public void sortColors(int[] A) {\\n        int one = 0; \\n        int two = 0;\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==0){\\n                A[i] = A[two];\\n                A[two] = A[one];\\n                A[one] = 0;\\n                one++;\\n                two++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1918849,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func sortColors(_ nums: inout [Int]) {\\n        var zeroIndex = 0\\n        var twoIndex = nums.count - 1\\n        var i = 0\\n\\n        while i <= twoIndex {\\n            if nums[i] == 0, i > zeroIndex {\\n                nums.swapAt(i, zeroIndex)\\n                zeroIndex += 1\\n\\n            } else if nums[i] == 2, i < twoIndex {\\n                nums.swapAt(i, twoIndex)\\n                twoIndex -= 1\\n\\n            } else {\\n                i += 1\\n            }\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func sortColors(_ nums: inout [Int]) {\\n        var zeroIndex = 0\\n        var twoIndex = nums.count - 1\\n        var i = 0\\n\\n        while i <= twoIndex {\\n            if nums[i] == 0, i > zeroIndex {\\n                nums.swapAt(i, zeroIndex)\\n                zeroIndex += 1\\n\\n            } else if nums[i] == 2, i < twoIndex {\\n                nums.swapAt(i, twoIndex)\\n                twoIndex -= 1\\n\\n            } else {\\n                i += 1\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26605,
                "title": "javascript-one-pass-with-explaination",
                "content": "![0_1474676686328_75. Sort Colors.jpg](/uploads/files/1474676687419-75.sort-colors.jpg) \\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar sortColors = function(nums) {\\n    var low = 0,\\n        high = nums.length - 1,\\n        temp;\\n    \\n    for (var i = 0; i <= high; ) {\\n        if (nums[i] === 0) {\\n            temp = nums[i];\\n            nums[i] = nums[low];\\n            nums[low] = temp;\\n            i++;\\n            low++;\\n        } else if (nums[i] == 2) {\\n            temp = nums[i];\\n            nums[i] = nums[high];\\n            nums[high] = temp;\\n            high--;\\n        } else {\\n            i++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar sortColors = function(nums) {\\n    var low = 0,\\n        high = nums.length - 1,\\n        temp;\\n    \\n    for (var i = 0; i <= high; ) {\\n        if (nums[i] === 0) {\\n            temp = nums[i];\\n            nums[i] = nums[low];\\n            nums[low] = temp;\\n            i++;\\n            low++;\\n        } else if (nums[i] == 2) {\\n            temp = nums[i];\\n            nums[i] = nums[high];\\n            nums[high] = temp;\\n            high--;\\n        } else {\\n            i++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1078865,
                "title": "one-pass-o-n-time-o-1-space-3-pointer-approach",
                "content": "```\\nclass Solution:\\n    def sortColors(self, a: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        runner = 0\\n        left_partition = 0\\n        right_partition = len(a) - 1\\n        while runner <= right_partition:\\n            if a[runner] == 0:\\n                a[runner], a[left_partition] = a[left_partition], a[runner]\\n                runner += 1\\n                left_partition += 1\\n            elif a[runner] == 1:\\n                runner += 1\\n            else:\\n                a[runner], a[right_partition] = a[right_partition], a[runner]\\n                right_partition -= 1\\n        return a\\n```\\nFor more such problems: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortColors(self, a: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        runner = 0\\n        left_partition = 0\\n        right_partition = len(a) - 1\\n        while runner <= right_partition:\\n            if a[runner] == 0:\\n                a[runner], a[left_partition] = a[left_partition], a[runner]\\n                runner += 1\\n                left_partition += 1\\n            elif a[runner] == 1:\\n                runner += 1\\n            else:\\n                a[runner], a[right_partition] = a[right_partition], a[runner]\\n                right_partition -= 1\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697569,
                "title": "java-striver-easy-understanding",
                "content": "```\\n# Better Approach\\n\\n* Time Complexity : O(2*N)\\n* Space Complexity : O(1) \\n\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int count0 = 0;\\n        int count1 = 0;\\n        int count2 = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) count0++;\\n            else if (nums[i] == 1) count1++;\\n            else count2++;\\n        }\\n        for (int i = 0; i < count0; i++) nums[i] = 0;\\n        for (int i = count0; i < count0 + count1; i++) nums[i] = 1;\\n        for (int i = count0 + count1; i < nums.length; i++) nums[i] = 2;\\n\\n    }\\n}\\n```\\n\\n```\\n# Optimal Approach #\\n\\nDUTCH NATIONAL FLAG ALGORITHM\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(1) \\n\\nclass Solution {\\n\\n    public void sortColors(int[] nums) {\\n        int low = 0, mid = 0, high = nums.length - 1;\\n        while (mid <= high) {\\n            if (nums[mid] == 0) {\\n                int temp = nums[low];\\n                nums[low] = nums[mid];\\n                nums[mid] = temp;\\n                low++;\\n                mid++;\\n            } else if (nums[mid] == 1) mid++;\\n            else {\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--;\\n            }\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/7243bb39-3484-4bc1-83e6-16a90cf64fd2_1688563566.56007.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n# Better Approach\\n\\n* Time Complexity : O(2*N)\\n* Space Complexity : O(1) \\n\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int count0 = 0;\\n        int count1 = 0;\\n        int count2 = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) count0++;\\n            else if (nums[i] == 1) count1++;\\n            else count2++;\\n        }\\n        for (int i = 0; i < count0; i++) nums[i] = 0;\\n        for (int i = count0; i < count0 + count1; i++) nums[i] = 1;\\n        for (int i = count0 + count1; i < nums.length; i++) nums[i] = 2;\\n\\n    }\\n}\\n```\n```\\n# Optimal Approach #\\n\\nDUTCH NATIONAL FLAG ALGORITHM\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(1) \\n\\nclass Solution {\\n\\n    public void sortColors(int[] nums) {\\n        int low = 0, mid = 0, high = nums.length - 1;\\n        while (mid <= high) {\\n            if (nums[mid] == 0) {\\n                int temp = nums[low];\\n                nums[low] = nums[mid];\\n                nums[mid] = temp;\\n                low++;\\n                mid++;\\n            } else if (nums[mid] == 1) mid++;\\n            else {\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834862,
                "title": "one-pass-c-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is the classic problem known as **\\'Dutch National Flag Problem\\'** due to 0, 1 and 2 representing red, white and blue of the nation\\'s flag.\\n\\nHere, the intuition is to partition the array into regions using iterators such that all the elements to the left of an iterator (low), i.e. ending of first region, are equal to 0, and all the elements to the right of another iterator (high), indicate the start of region C, which contain the number 2. The third region B contains all 1\\'s and the entire array is traversed using a third iterator (mid).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBoth low and mid point to the start of the array, while high points to the end of array. All the swapping done in the array is based on the element pointed by mid.\\n\\n*If mid is equal to 0, swap low and mid and then increment both.\\nIf mid is equal to 1, simply increment it.\\nIf mid is equal to 2, swap high and mid and finally, decrement high.*\\n\\nContinue this process till mid is less than or equal to high.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low=0, mid=0, high=nums.size()-1;\\n\\n        //All numbers to left of low are 0\\n        //All numbers to right of high are 2\\n\\n        while(mid<=high){\\n            if(nums[mid]==0)\\n                swap(nums[low++], nums[mid++]);\\n            else if(nums[mid]==1)\\n                mid++;\\n            else\\n                swap(nums[mid], nums[high--]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low=0, mid=0, high=nums.size()-1;\\n\\n        //All numbers to left of low are 0\\n        //All numbers to right of high are 2\\n\\n        while(mid<=high){\\n            if(nums[mid]==0)\\n                swap(nums[low++], nums[mid++]);\\n            else if(nums[mid]==1)\\n                mid++;\\n            else\\n                swap(nums[mid], nums[high--]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681964,
                "title": "c-o-n-one-pass-o-1-space-with-explanation",
                "content": "Three pointers => \\np0:  right boundary of 0\\npn:  left boundary of 2\\ncurr :  current pointer\\n\\n![image](https://assets.leetcode.com/users/frostcs/image_1591883944.png)\\npic courtesy editorial.\\n\\n\\n```  \\nint n = nums.size();\\n        int p0=0;\\n        int pn =n-1;\\n        int curr =0;\\n        while(curr<=pn){\\n            if(nums[curr] == 0){\\n                swap(nums[p0], nums[curr]);\\n                p0++;\\n                curr++;\\n            } else if(nums[curr] == 2){\\n                 swap(nums[pn], nums[curr]);\\n                pn--;\\n            } else{\\n                curr++;\\n            }\\n        }\\n   ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```  \\nint n = nums.size();\\n        int p0=0;\\n        int pn =n-1;\\n        int curr =0;\\n        while(curr<=pn){\\n            if(nums[curr] == 0){\\n                swap(nums[p0], nums[curr]);\\n                p0++;\\n                curr++;\\n            } else if(nums[curr] == 2){\\n                 swap(nums[pn], nums[curr]);\\n                pn--;\\n            } else{\\n                curr++;\\n            }\\n        }\\n   ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3649859,
                "title": "3-pointer-approach-dutch-national-flag-algorithm-most-efficient-solution-tc-o-n-sc-o-1",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,k=nums.size()-1;\\n        while(j<=k){\\n            if(nums[j]==0) {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }else if(nums[j]==1){\\n               \\n                j++;\\n            }else{\\n                swap(nums[j],nums[k]);\\n                \\n                k--;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,k=nums.size()-1;\\n        while(j<=k){\\n            if(nums[j]==0) {\\n                swap(nums[i],nums[j]);\\n                i++;\\n                j++;\\n            }else if(nums[j]==1){\\n               \\n                j++;\\n            }else{\\n                swap(nums[j],nums[k]);\\n                \\n                k--;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519937,
                "title": "c-java-python-javascript-using-bubble-sort-algorithm",
                "content": "# Intuition:\\nThis solution is based on the bubble sort algorithm, which is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares adjacent elements and swaps them if they are in the wrong order. The algorithm gets its name from the way smaller elements \"bubble\" to the top of the list. \\n\\n# Approach:\\n1. Traverse the array from the end to the beginning with a loop variable \\'i\\'.\\n2. For each iteration of the outer loop, traverse the array from the beginning to \\'i-1\\' with a loop variable \\'j\\'.\\n3. Compare adjacent elements and swap them if they are in the wrong order, i.e., if nums[j]>nums[j+1].\\n4. Repeat steps 2-3 for all iterations of the outer loop, until the array is sorted in ascending order.\\n5. The resulting array will be sorted in non-decreasing order.\\n\\n# Complexity:\\n- The time complexity of this algorithm is O(n^2), where \\'n\\' is the length of the input array. This is because we are using nested loops to traverse the array. \\n- The space complexity of this algorithm is O(1), because we are not using any extra space and we are sorting the input array in-place.\\n\\n---\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        for(int i=nums.size()-1;i>0;i--){\\n            for(int j=0;j<=i-1;j++){\\n                if(nums[j]>nums[j+1]){\\n                    int temp = nums[j+1];\\n                    nums[j+1]=nums[j];\\n                    nums[j]=temp;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n---\\n\\n# JAVA\\n```java\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        for (int i = nums.length - 1; i > 0; i--) {\\n            for (int j = 0; j <= i - 1; j++) {\\n                if (nums[j] > nums[j + 1]) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n```\\n---\\n\\n# Python\\n```py\\nclass Solution(object):\\n    def sortColors(self, nums):\\n        for i in range(len(nums) - 1, 0, -1):\\n            for j in range(i):\\n                if nums[j] > nums[j + 1]:\\n                    temp = nums[j + 1]\\n                    nums[j + 1] = nums[j]\\n                    nums[j] = temp\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar sortColors = function(nums) {\\n    for (let i = nums.length - 1; i > 0; i--) {\\n        for (let j = 0; j <= i - 1; j++) {\\n            if (nums[j] > nums[j + 1]) {\\n                let temp = nums[j + 1];\\n                nums[j + 1] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        for(int i=nums.size()-1;i>0;i--){\\n            for(int j=0;j<=i-1;j++){\\n                if(nums[j]>nums[j+1]){\\n                    int temp = nums[j+1];\\n                    nums[j+1]=nums[j];\\n                    nums[j]=temp;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        for (int i = nums.length - 1; i > 0; i--) {\\n            for (int j = 0; j <= i - 1; j++) {\\n                if (nums[j] > nums[j + 1]) {\\n                    int temp = nums[j + 1];\\n                    nums[j + 1] = nums[j];\\n                    nums[j] = temp;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n```\n```py\\nclass Solution(object):\\n    def sortColors(self, nums):\\n        for i in range(len(nums) - 1, 0, -1):\\n            for j in range(i):\\n                if nums[j] > nums[j + 1]:\\n                    temp = nums[j + 1]\\n                    nums[j + 1] = nums[j]\\n                    nums[j] = temp\\n\\n```\n```\\nvar sortColors = function(nums) {\\n    for (let i = nums.length - 1; i > 0; i--) {\\n        for (let j = 0; j <= i - 1; j++) {\\n            if (nums[j] > nums[j + 1]) {\\n                let temp = nums[j + 1];\\n                nums[j + 1] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410189,
                "title": "easy-100-fully-explained-java-c-python-javascript-c-python3",
                "content": "# **# The Dutch National Flag Problem!! #**\\n\\n# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Sort Colors.\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        // Keep three counter to count 0s, 1s and 2s...\\n        int idx, count0s = 0, count1s = 0, count2s = 0;\\n        // Traverse the array & Count the number of 0s, 1s and 2s in the array...\\n        for (idx = 0; idx < nums.length ; idx++) {\\n            switch (nums[idx]) {\\n            // If the element is 0 then increase count0s...\\n            case 0:\\n                count0s++;\\n                break;\\n            // If the element is 1 then increase count1s...\\n            case 1:\\n                count1s++;\\n                break;\\n            // If the element is 2 then increase count2s...\\n            case 2:\\n                count2s++;\\n                break;\\n            }\\n        }\\n        // Update the array\\n        idx = 0;\\n        // Store all the 0s in the beginning...\\n        while (count0s > 0) {\\n            nums[idx++] = 0;\\n            count0s--;\\n        }\\n        // Then store all the 1s...\\n        while (count1s > 0) {\\n            nums[idx++] = 1;\\n            count1s--;\\n        }\\n        // Finally store all the 2s...\\n        while (count2s > 0) {\\n            nums[idx++] = 2;\\n            count2s--;\\n        }\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 3 ms, faster than 87.97% of C++ online submissions for Sort Colors.\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        // Keep three indices beg = 0, mid = 0 and end = nums.size()-1...\\n        // There are four ranges, 1 to beg (the range containing 0), beg to mid (the range containing 1), mid to end (the range containing unknown elements) and end to nums.size() (the range containing 2)...\\n        int beg = 0, mid = 0, end = nums.size()-1;\\n        // Traverse the array from start to end and mid is less than end...\\n        while(mid <= end) {\\n            // If the element is 0 then swap the element with the element at index beg...\\n            // & Update beg = beg + 1 and mid = mid + 1...\\n            if(nums[mid] == 0) {\\n                swap(nums[mid], nums[beg]);\\n                beg++;\\n                mid++;\\n            }\\n            // If the element is 1 then update mid = mid + 1...\\n            else if(nums[mid] == 1)\\n                mid++;\\n            // If the element is 2 then swap the element with the element at index end...\\n            // & Update end = end \\u2013 1...\\n            else {\\n                swap(nums[mid], nums[end]);\\n                end--;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 28 ms, faster than 85.50% of Python online submissions for Sort Colors.\\n```\\nclass Solution(object):\\n    def sortColors(self, nums):\\n        # Keep three counter to count 0s, 1s and 2s...\\n        count0s = 0\\n        count1s = 0\\n        count2s = 0\\n        # Traverse the array & Count the number of 0s, 1s and 2s in the array...\\n        for idx in range(len(nums)):\\n            # If the element is 0 then increase count0s...\\n            if nums[idx] == 0:\\n                count0s += 1\\n            # If the element is 1 then increase count1s...\\n            elif nums[idx] == 1:\\n                count1s += 1\\n            # If the element is 2 then increase count2s...\\n            elif nums[idx] == 2:\\n                count2s += 1\\n        # Update the array\\n        idx = 0;\\n        # Store all the 0s in the beginning...\\n        while (count0s > 0):\\n            nums[idx] = 0\\n            idx += 1\\n            count0s -= 1\\n        # Then store all the 1s...\\n        while (count1s > 0):\\n            nums[idx] = 1\\n            idx += 1\\n            count1s -= 1\\n        # Finally store all the 2s...\\n        while (count2s > 0):\\n            nums[idx] = 2\\n            idx += 1\\n            count2s -= 1\\n```\\n\\n# **JavaScript Solution:**\\n```\\nvar sortColors = function(nums) {\\n    // Keep three indices beg = 0, mid = 0 and end = nums.length-1...\\n    // There are four ranges, 1 to beg (the range containing 0), beg to mid (the range containing 1), mid to end (the range containing unknown elements) and end to nums.length (the range containing 2)...\\n    let beg = 0; \\n    let end = nums.length - 1; \\n    let mid = 0;\\n    let temp = 0;\\n    // Traverse the array from start to end and mid is less than end...\\n    while (mid <= end) {\\n        // If the element is 0...\\n        if(nums[mid] == 0) {\\n            // swap the element with the element at index beg...\\n            temp = nums[beg]; \\n            nums[beg] = nums[mid]; \\n            nums[mid] = temp;\\n            // Update beg = beg + 1 and mid = mid + 1...\\n            beg++; \\n            mid++; \\n        }\\n        // If the element is 1 then update mid = mid + 1...\\n        else if(nums[mid] == 1) {\\n            mid++; \\n        }\\n        // If the element is 2...\\n        else {\\n            // Swap the element with the element at index end...\\n            temp = nums[mid]; \\n            nums[mid] = nums[end]; \\n            nums[end] = temp;\\n            // Update end = end \\u2013 1...\\n            end--;\\n        }      \\n    }\\n};\\n```\\n\\n# **C Language:**\\n```\\nvoid sortColors(int* nums, int numsSize){\\n    // Keep three counter to count 0s, 1s and 2s...\\n    int idx, count0s = 0, count1s = 0, count2s = 0;\\n    // Traverse the array & Count the number of 0s, 1s and 2s in the array...\\n    for (idx = 0; idx < numsSize ; idx++) {\\n        switch (nums[idx]) {\\n        // If the element is 0 then increase count0s...\\n        case 0:\\n            count0s++;\\n            break;\\n        // If the element is 1 then increase count1s...\\n        case 1:\\n            count1s++;\\n            break;\\n        // If the element is 2 then increase count2s...\\n        case 2:\\n            count2s++;\\n            break;\\n        }\\n    }\\n    // Update the array\\n    idx = 0;\\n    // Store all the 0s in the beginning...\\n    while (count0s > 0) {\\n        nums[idx++] = 0;\\n        count0s--;\\n    }\\n    // Then store all the 1s...\\n    while (count1s > 0) {\\n        nums[idx++] = 1;\\n        count1s--;\\n    }\\n    // Finally store all the 2s...\\n    while (count2s > 0) {\\n        nums[idx++] = 2;\\n        count2s--;\\n    }\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        # Keep three indices beg = 0, mid = 0 and end = len(nums)-1...\\n        # There are four ranges, 1 to beg (the range containing 0), beg to mid (the range containing 1), mid to end (the range containing unknown elements) and end to len(nums) (the range containing 2)...\\n        beg = 0\\n        end = len(nums) - 1\\n        mid = 0\\n        # Traverse the array from start to end and mid is less than end...\\n        while mid <= end:\\n            # If the element is 0...\\n            if nums[mid] == 0:\\n                # swap the element with the element at index beg...\\n                nums[beg], nums[mid] = nums[mid], nums[beg]\\n                # Update beg = beg + 1 and mid = mid + 1...\\n                beg = beg + 1\\n                mid = mid + 1\\n            # If the element is 1 then update mid = mid + 1...\\n            elif nums[mid] == 1:\\n                mid = mid + 1\\n            # If the element is 2...\\n            else:\\n                # Swap the element with the element at index end...\\n                nums[mid], nums[end] = nums[end], nums[mid]\\n                # Update end = end \\u2013 1...\\n                end = end - 1\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        // Keep three counter to count 0s, 1s and 2s...\\n        int idx, count0s = 0, count1s = 0, count2s = 0;\\n        // Traverse the array & Count the number of 0s, 1s and 2s in the array...\\n        for (idx = 0; idx < nums.length ; idx++) {\\n            switch (nums[idx]) {\\n            // If the element is 0 then increase count0s...\\n            case 0:\\n                count0s++;\\n                break;\\n            // If the element is 1 then increase count1s...\\n            case 1:\\n                count1s++;\\n                break;\\n            // If the element is 2 then increase count2s...\\n            case 2:\\n                count2s++;\\n                break;\\n            }\\n        }\\n        // Update the array\\n        idx = 0;\\n        // Store all the 0s in the beginning...\\n        while (count0s > 0) {\\n            nums[idx++] = 0;\\n            count0s--;\\n        }\\n        // Then store all the 1s...\\n        while (count1s > 0) {\\n            nums[idx++] = 1;\\n            count1s--;\\n        }\\n        // Finally store all the 2s...\\n        while (count2s > 0) {\\n            nums[idx++] = 2;\\n            count2s--;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        // Keep three indices beg = 0, mid = 0 and end = nums.size()-1...\\n        // There are four ranges, 1 to beg (the range containing 0), beg to mid (the range containing 1), mid to end (the range containing unknown elements) and end to nums.size() (the range containing 2)...\\n        int beg = 0, mid = 0, end = nums.size()-1;\\n        // Traverse the array from start to end and mid is less than end...\\n        while(mid <= end) {\\n            // If the element is 0 then swap the element with the element at index beg...\\n            // & Update beg = beg + 1 and mid = mid + 1...\\n            if(nums[mid] == 0) {\\n                swap(nums[mid], nums[beg]);\\n                beg++;\\n                mid++;\\n            }\\n            // If the element is 1 then update mid = mid + 1...\\n            else if(nums[mid] == 1)\\n                mid++;\\n            // If the element is 2 then swap the element with the element at index end...\\n            // & Update end = end \\u2013 1...\\n            else {\\n                swap(nums[mid], nums[end]);\\n                end--;\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def sortColors(self, nums):\\n        # Keep three counter to count 0s, 1s and 2s...\\n        count0s = 0\\n        count1s = 0\\n        count2s = 0\\n        # Traverse the array & Count the number of 0s, 1s and 2s in the array...\\n        for idx in range(len(nums)):\\n            # If the element is 0 then increase count0s...\\n            if nums[idx] == 0:\\n                count0s += 1\\n            # If the element is 1 then increase count1s...\\n            elif nums[idx] == 1:\\n                count1s += 1\\n            # If the element is 2 then increase count2s...\\n            elif nums[idx] == 2:\\n                count2s += 1\\n        # Update the array\\n        idx = 0;\\n        # Store all the 0s in the beginning...\\n        while (count0s > 0):\\n            nums[idx] = 0\\n            idx += 1\\n            count0s -= 1\\n        # Then store all the 1s...\\n        while (count1s > 0):\\n            nums[idx] = 1\\n            idx += 1\\n            count1s -= 1\\n        # Finally store all the 2s...\\n        while (count2s > 0):\\n            nums[idx] = 2\\n            idx += 1\\n            count2s -= 1\\n```\n```\\nvar sortColors = function(nums) {\\n    // Keep three indices beg = 0, mid = 0 and end = nums.length-1...\\n    // There are four ranges, 1 to beg (the range containing 0), beg to mid (the range containing 1), mid to end (the range containing unknown elements) and end to nums.length (the range containing 2)...\\n    let beg = 0; \\n    let end = nums.length - 1; \\n    let mid = 0;\\n    let temp = 0;\\n    // Traverse the array from start to end and mid is less than end...\\n    while (mid <= end) {\\n        // If the element is 0...\\n        if(nums[mid] == 0) {\\n            // swap the element with the element at index beg...\\n            temp = nums[beg]; \\n            nums[beg] = nums[mid]; \\n            nums[mid] = temp;\\n            // Update beg = beg + 1 and mid = mid + 1...\\n            beg++; \\n            mid++; \\n        }\\n        // If the element is 1 then update mid = mid + 1...\\n        else if(nums[mid] == 1) {\\n            mid++; \\n        }\\n        // If the element is 2...\\n        else {\\n            // Swap the element with the element at index end...\\n            temp = nums[mid]; \\n            nums[mid] = nums[end]; \\n            nums[end] = temp;\\n            // Update end = end \\u2013 1...\\n            end--;\\n        }      \\n    }\\n};\\n```\n```\\nvoid sortColors(int* nums, int numsSize){\\n    // Keep three counter to count 0s, 1s and 2s...\\n    int idx, count0s = 0, count1s = 0, count2s = 0;\\n    // Traverse the array & Count the number of 0s, 1s and 2s in the array...\\n    for (idx = 0; idx < numsSize ; idx++) {\\n        switch (nums[idx]) {\\n        // If the element is 0 then increase count0s...\\n        case 0:\\n            count0s++;\\n            break;\\n        // If the element is 1 then increase count1s...\\n        case 1:\\n            count1s++;\\n            break;\\n        // If the element is 2 then increase count2s...\\n        case 2:\\n            count2s++;\\n            break;\\n        }\\n    }\\n    // Update the array\\n    idx = 0;\\n    // Store all the 0s in the beginning...\\n    while (count0s > 0) {\\n        nums[idx++] = 0;\\n        count0s--;\\n    }\\n    // Then store all the 1s...\\n    while (count1s > 0) {\\n        nums[idx++] = 1;\\n        count1s--;\\n    }\\n    // Finally store all the 2s...\\n    while (count2s > 0) {\\n        nums[idx++] = 2;\\n        count2s--;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        # Keep three indices beg = 0, mid = 0 and end = len(nums)-1...\\n        # There are four ranges, 1 to beg (the range containing 0), beg to mid (the range containing 1), mid to end (the range containing unknown elements) and end to len(nums) (the range containing 2)...\\n        beg = 0\\n        end = len(nums) - 1\\n        mid = 0\\n        # Traverse the array from start to end and mid is less than end...\\n        while mid <= end:\\n            # If the element is 0...\\n            if nums[mid] == 0:\\n                # swap the element with the element at index beg...\\n                nums[beg], nums[mid] = nums[mid], nums[beg]\\n                # Update beg = beg + 1 and mid = mid + 1...\\n                beg = beg + 1\\n                mid = mid + 1\\n            # If the element is 1 then update mid = mid + 1...\\n            elif nums[mid] == 1:\\n                mid = mid + 1\\n            # If the element is 2...\\n            else:\\n                # Swap the element with the element at index end...\\n                nums[mid], nums[end] = nums[end], nums[mid]\\n                # Update end = end \\u2013 1...\\n                end = end - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555767,
                "title": "java-tc-o-n-sc-o-1-simple-one-pass-constant-space-w-o-using-a-swap-function",
                "content": "**One-Pass Constant Space solution (Without using a Swap Function)**\\n```java\\n/**\\n * One-Pass Constant Space solution (Without using a Swap Function)\\n *\\n * Move all 0s to the left and all 2s to the right, then all 1s are left in the middle. Without using a swap function.\\n *\\n * Time Complexity: O(N). N = Length of input array.\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        if (nums == null || nums.length <= 1) {\\n            return;\\n        }\\n\\n        int zeros = 0;\\n        int twos = nums.length - 1;\\n        int i = 0;\\n\\n        while (i <= twos) {\\n            switch (nums[i]) {\\n                case 2:\\n                    if (i != twos) {\\n                        nums[i] = nums[twos];\\n                        nums[twos] = 2;\\n                    }\\n                    twos--;\\n                    // Cannot increment i. The number at i can now be a zero.\\n                    break;\\n                case 1:\\n                    i++;\\n                    break;\\n                case 0:\\n                    if (i != zeros) {\\n                        nums[i] = 1;\\n                        nums[zeros] = 0;\\n                    }\\n                    zeros++;\\n                    // Can increment i. As only 0s and 1s are present between zero and i.\\n                    i++;\\n                    break;\\n                default:\\n                    throw new IllegalArgumentException(\"Invalid color\");\\n            }\\n        }\\n    }\\n}\\n```\\n\\n---\\n**One-Pass Constant Space solution (Using a Swap Function)**\\n```java\\n/**\\n * One-Pass Constant Space solution (Using a Swap Function)\\n *\\n * Move all 0s to the left and all 2s to the right, then all 1s are left in the middle. Using a Swap function\\n *\\n * Time Complexity: O(N). N = Length of input array.\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        if (nums == null || nums.length <= 1) {\\n            return;\\n        }\\n\\n        int zeros = 0;\\n        int twos = nums.length - 1;\\n        int i = 0;\\n\\n        while (i <= twos) {\\n            if (nums[i] == 0) {\\n                swap(nums, i, zeros);\\n                zeros++;\\n                // Can increment i. As only 0s and 1s are present between zero and i.\\n                i++;\\n            } else if (nums[i] == 2) {\\n                swap(nums, i, twos);\\n                twos--;\\n                // Cannot increment i. The number at i can now be a zero.\\n            } else {\\n                // Its a one.. so we do not need to move it.\\n                i++;\\n            }\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        if (i != j) {\\n            int temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * One-Pass Constant Space solution (Without using a Swap Function)\\n *\\n * Move all 0s to the left and all 2s to the right, then all 1s are left in the middle. Without using a swap function.\\n *\\n * Time Complexity: O(N). N = Length of input array.\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        if (nums == null || nums.length <= 1) {\\n            return;\\n        }\\n\\n        int zeros = 0;\\n        int twos = nums.length - 1;\\n        int i = 0;\\n\\n        while (i <= twos) {\\n            switch (nums[i]) {\\n                case 2:\\n                    if (i != twos) {\\n                        nums[i] = nums[twos];\\n                        nums[twos] = 2;\\n                    }\\n                    twos--;\\n                    // Cannot increment i. The number at i can now be a zero.\\n                    break;\\n                case 1:\\n                    i++;\\n                    break;\\n                case 0:\\n                    if (i != zeros) {\\n                        nums[i] = 1;\\n                        nums[zeros] = 0;\\n                    }\\n                    zeros++;\\n                    // Can increment i. As only 0s and 1s are present between zero and i.\\n                    i++;\\n                    break;\\n                default:\\n                    throw new IllegalArgumentException(\"Invalid color\");\\n            }\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * One-Pass Constant Space solution (Using a Swap Function)\\n *\\n * Move all 0s to the left and all 2s to the right, then all 1s are left in the middle. Using a Swap function\\n *\\n * Time Complexity: O(N). N = Length of input array.\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        if (nums == null || nums.length <= 1) {\\n            return;\\n        }\\n\\n        int zeros = 0;\\n        int twos = nums.length - 1;\\n        int i = 0;\\n\\n        while (i <= twos) {\\n            if (nums[i] == 0) {\\n                swap(nums, i, zeros);\\n                zeros++;\\n                // Can increment i. As only 0s and 1s are present between zero and i.\\n                i++;\\n            } else if (nums[i] == 2) {\\n                swap(nums, i, twos);\\n                twos--;\\n                // Cannot increment i. The number at i can now be a zero.\\n            } else {\\n                // Its a one.. so we do not need to move it.\\n                i++;\\n            }\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        if (i != j) {\\n            int temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681637,
                "title": "python-js-go-one-pass-by-two-pointers-w-comment",
                "content": "Python/JS/Go one-pass by two-pointers.\\n\\n---\\n\\n**Implementation** in Python:\\n\\n```\\nclass Solution:\\n    \\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        # constant for colors\\n        RED, WHITE, BLUE = 0, 1, 2\\n        \\n        # two pointers for RED as well as BLUE\\n        idx_red, idx_blue = 0, len(nums)-1\\n        \\n        i = 0\\n        while i <= idx_blue :\\n            \\n            if nums[i] == RED:\\n                \\n                nums[idx_red], nums[i] = nums[i], nums[idx_red]\\n                \\n                # update idx for red\\n                idx_red += 1\\n            \\n            \\n            elif nums[i] == BLUE:\\n            \\n                nums[idx_blue], nums[i] = nums[i], nums[idx_blue]\\n                \\n                # update idx for blue\\n                idx_blue -= 1\\n                \\n                # i-1 in order to stay and do one more color check on next iteration\\n                i -= 1\\n            \\n            \\n            # i move forward\\n            i += 1                \\n        \\n```\\n\\n---\\n\\n**Implementation** in JavaScript:\\n\\n```\\nvar sortColors = function(nums) {\\n  \\n    const [RED, WHITE, BLUE] = [0, 1, 2];\\n    \\n    let i = 0;\\n    let [idx_red, idx_blue] = [0, nums.length-1];\\n    \\n    while(i <= idx_blue ){\\n        \\n        if(nums[i] == RED){\\n            \\n            // Swap red element to lefthand side\\n            [ nums[i], nums[idx_red] ] = [ nums[idx_red], nums[i] ];\\n            idx_red++;\\n            \\n        }else if(nums[i] == BLUE ){\\n            \\n            // Swap blue element to righthand side\\n            [ nums[i], nums[idx_blue] ] = [ nums[idx_blue], nums[i] ];\\n            idx_blue--;\\n            \\n            // i stay here for one more check on next iteration\\n            i -= 1;\\n        }\\n        \\n        \\n        // i moves from left to right\\n        i += 1;\\n    } \\n    \\n};\\n```\\n\\n---\\n\\n**Implementation** in Go:\\n\\n```\\nfunc sortColors(nums []int)  {\\n    \\n    const RED, WHITE, BLUE = 0, 1, 2\\n    \\n    i, idx_red, idx_blue := 0, 0, len(nums)-1\\n    \\n    for ;i <= idx_blue; i+=1{\\n        \\n        if nums[i] == RED{\\n            nums[i], nums[idx_red] = nums[idx_red], nums[i]\\n            idx_red += 1\\n            \\n        }else if nums[i] == BLUE{\\n            nums[i], nums[idx_blue] = nums[idx_blue], nums[i]\\n            idx_blue -= 1\\n            \\n            // i stay here for one more check on next iteration\\n            i -= 1\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    return\\n    \\n}\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Go",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        # constant for colors\\n        RED, WHITE, BLUE = 0, 1, 2\\n        \\n        # two pointers for RED as well as BLUE\\n        idx_red, idx_blue = 0, len(nums)-1\\n        \\n        i = 0\\n        while i <= idx_blue :\\n            \\n            if nums[i] == RED:\\n                \\n                nums[idx_red], nums[i] = nums[i], nums[idx_red]\\n                \\n                # update idx for red\\n                idx_red += 1\\n            \\n            \\n            elif nums[i] == BLUE:\\n            \\n                nums[idx_blue], nums[i] = nums[i], nums[idx_blue]\\n                \\n                # update idx for blue\\n                idx_blue -= 1\\n                \\n                # i-1 in order to stay and do one more color check on next iteration\\n                i -= 1\\n            \\n            \\n            # i move forward\\n            i += 1                \\n        \\n```\n```\\nvar sortColors = function(nums) {\\n  \\n    const [RED, WHITE, BLUE] = [0, 1, 2];\\n    \\n    let i = 0;\\n    let [idx_red, idx_blue] = [0, nums.length-1];\\n    \\n    while(i <= idx_blue ){\\n        \\n        if(nums[i] == RED){\\n            \\n            // Swap red element to lefthand side\\n            [ nums[i], nums[idx_red] ] = [ nums[idx_red], nums[i] ];\\n            idx_red++;\\n            \\n        }else if(nums[i] == BLUE ){\\n            \\n            // Swap blue element to righthand side\\n            [ nums[i], nums[idx_blue] ] = [ nums[idx_blue], nums[i] ];\\n            idx_blue--;\\n            \\n            // i stay here for one more check on next iteration\\n            i -= 1;\\n        }\\n        \\n        \\n        // i moves from left to right\\n        i += 1;\\n    } \\n    \\n};\\n```\n```\\nfunc sortColors(nums []int)  {\\n    \\n    const RED, WHITE, BLUE = 0, 1, 2\\n    \\n    i, idx_red, idx_blue := 0, 0, len(nums)-1\\n    \\n    for ;i <= idx_blue; i+=1{\\n        \\n        if nums[i] == RED{\\n            nums[i], nums[idx_red] = nums[idx_red], nums[i]\\n            idx_red += 1\\n            \\n        }else if nums[i] == BLUE{\\n            nums[i], nums[idx_blue] = nums[idx_blue], nums[i]\\n            idx_blue -= 1\\n            \\n            // i stay here for one more check on next iteration\\n            i -= 1\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    return\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171105,
                "title": "c-solution-count-0-s-1-s-2-s-0ms-faster-than-100-tc-o-n",
                "content": "**Explaination:**\\n* Make variable count0, count1, count2 for 0\\'s, 1\\'s and 2\\'s respectively.\\n* Traverse the array and count the number of 0\\'s 1\\'s and 2\\'s.\\n* Now overwrite the original array in order of 0\\'s, 1\\'s and 2\\'s using the count variables.\\n```\\n// Keeping a count of 0\\'s 1\\'s and 2\\'s and updating the original array\\n//Time complexity - O(2N)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int count0 = 0, count1 = 0, count2 = 0;\\n        \\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                count0++;\\n            if(nums[i]==1)\\n                count1++;\\n            if(nums[i]==2)\\n                count2++;\\n        }\\n        \\n        int i = 0;\\n        while(count0)\\n        {\\n            nums[i] = 0;\\n            i++;\\n            count0--;\\n        }\\n        while(count1)\\n        {\\n            nums[i] = 1;\\n            i++;\\n            count1--;\\n        }\\n        while(count2)\\n        {\\n            nums[i] = 2;\\n            i++;\\n            count2--;\\n        }\\n    }\\n};\\n```\\nTime Complexity ->`O(n)`\\n**Please upvote if you find the solution useful, means a lot.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Keeping a count of 0\\'s 1\\'s and 2\\'s and updating the original array\\n//Time complexity - O(2N)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int count0 = 0, count1 = 0, count2 = 0;\\n        \\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                count0++;\\n            if(nums[i]==1)\\n                count1++;\\n            if(nums[i]==2)\\n                count2++;\\n        }\\n        \\n        int i = 0;\\n        while(count0)\\n        {\\n            nums[i] = 0;\\n            i++;\\n            count0--;\\n        }\\n        while(count1)\\n        {\\n            nums[i] = 1;\\n            i++;\\n            count1--;\\n        }\\n        while(count2)\\n        {\\n            nums[i] = 2;\\n            i++;\\n            count2--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484840,
                "title": "simple-python-solution-o-n-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \\n        low, high, i = 0, len(nums) - 1, 0\\n        \\n        while i <= high:\\n            if nums[i] == 0:\\n                nums[low], nums[i] = nums[i], nums[low]\\n                low += 1\\n                i += 1\\n            elif nums[i] == 2:\\n                nums[high], nums[i] = nums[i], nums[high]\\n                high -= 1\\n            else: i += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \\n        low, high, i = 0, len(nums) - 1, 0\\n        \\n        while i <= high:\\n            if nums[i] == 0:\\n                nums[low], nums[i] = nums[i], nums[low]\\n                low += 1\\n                i += 1\\n            elif nums[i] == 2:\\n                nums[high], nums[i] = nums[i], nums[high]\\n                high -= 1\\n            else: i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383604,
                "title": "beats-100-c-snowball-approach",
                "content": "\\n# Approach\\n This solution implements the Dutch National Flag algorithm to sort an array nums containing only 0, 1, and 2. The algorithm consists of three pointers, low, mid, and high, and two partitions, one for 0\\'s and another for 1\\'s. The idea is to iterate over the array and move the 0\\'s to the left partition, the 1\\'s to the middle partition, and the 2\\'s to the right partition.\\n\\nIn this implementation, the algorithm is modified slightly to only have two partitions, one for 0\\'s and 1\\'s, and another for 2\\'s. The variable sb keeps track of the number of 2\\'s encountered so far, and the first loop moves all the 2\\'s to the right partition. The variable so keeps track of the number of 1\\'s encountered in the remaining part of the array, and the second loop moves all the 1\\'s to the middle partition.\\n\\nThe algorithm does not explicitly move the 0\\'s to the left partition, since all the 0\\'s are already in their correct position after the two loops. This is because any 0 encountered during the loops is automatically moved to the left partition by the previous iteration.\\n\\nThis solution has a time complexity of O(n) and a space complexity of O(1), since it only requires a constant amount of additional memory to store the two pointers sb and so.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int sb = 0 ;\\n\\n        for(int i = 0 ; i< nums.size(); i++){\\n            if(nums[i] == 2)\\n             sb++;\\n\\n            else if(sb > 0){\\n                nums[i - sb] = nums[i];\\n                nums[i] = 2; \\n            }\\n        }\\n\\n        int so = 0;\\n\\n        for(int i = 0 ; i< nums.size() - sb; i++){\\n            if(nums[i] == 1)\\n             so++;\\n\\n            else if(so > 0){\\n                nums[i - so] = nums[i];\\n                nums[i] = 1; \\n            }\\n        }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int sb = 0 ;\\n\\n        for(int i = 0 ; i< nums.size(); i++){\\n            if(nums[i] == 2)\\n             sb++;\\n\\n            else if(sb > 0){\\n                nums[i - sb] = nums[i];\\n                nums[i] = 2; \\n            }\\n        }\\n\\n        int so = 0;\\n\\n        for(int i = 0 ; i< nums.size() - sb; i++){\\n            if(nums[i] == 1)\\n             so++;\\n\\n            else if(so > 0){\\n                nums[i - so] = nums[i];\\n                nums[i] = 1; \\n            }\\n        }\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949581,
                "title": "100-fast-java-solution-easy-explanation-dry-run",
                "content": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\\nRed - 0\\nWhite - 1\\nBlue - 2\\n\\nInput: nums = [2,0,2,1,1,0]\\nWe  need to arrange the color in order like  :- [0,0,1,1,2,2]\\n\\n**Solution:-**\\n```/**\\n * Move all 0s to the left and all 2s to the right, then all 1s are left in the middle. Using a Swaping of two number.\\n *\\n * Time Complexity: O(N). N = Length of input array.\\n * \\n */\\n```\\n```\\n  public void sortColors(int[] nums) {\\n       int length = nums.length;\\n        if(length==0)\\n         {   return;  }\\n        int l=0;\\n\\t\\tint m=0;\\n\\t\\tint h= length-1;\\n\\t\\tint temp;\\n            while(m <= h)\\n            {\\n                if(nums[m] == 1)\\n                    m++;\\n                else if(nums[m] == 0)\\n                {\\n                    temp = nums[l];\\n                    nums[l] = nums[m];\\n                    nums[m] = temp;\\n                    m++;\\n                    l++;\\n                }\\n                else if(nums[m] == 2)\\n                {                                \\n                    temp = nums[h];\\n                    nums[h] = nums[m];\\n                    nums[m] = temp;\\n                    h--;\\n                }\\n            }  \\n       }\\n```\\n###  # ** Dry Run:- ******\\n```\\n\\n  Given array is :-  [2,0,2,1,1,0]  and length = 6;\\n  \\n   [2,0,2,1,1,0]   and    l=0, m=0, h=length-1 = 5\\n\\t   nums[m]=> nums[0] = 2\\n\\t   swap=> nums[m] to nums[h] => nums[0] to nums[5] \\n\\t   and decrease h value i.e h=5-1 = 4\\n\\t   \\n   [0,0,2,1,1,2]  and  l=0, m=0, h=4\\n\\t   nums[m]=> nums[0] = 0\\n\\t   Increase the value of l and m by 1.\\n\\t   now, l=0+1=1,m=0+1=1,h=4\\n\\t   \\n   [0,0,2,1,1,2]   and  l=1, m=1, h=4\\n\\t\\tnums[m]=> nums[1] = 0\\n\\t\\tnow our array is => [0,0,2,1,1,2]\\n\\t\\tnow, l=1+1=2 ,m=1+1=2, h=4\\n\\t\\t\\n   [0,0,2,1,1,2] and  l=2, m=2, h=4\\n        nums[m]=> nums[2] = 2\\n\\t\\tswap=> nums[m] to nums[h] => nums[2] to nums[4] \\n\\t    now our array is => [0,0,1,1,2,2]\\n\\t    and decrease h value i.e h=4-1 = 3\\n\\t   \\n\\t[0,0,1,1,2,2] and  l=2 ,m=2, h=3\\n\\t   nums[m]=> nums[2] = 1\\n\\t   Increase the value of m by 1. \\n\\t   now, l=2 ,m=2+1=3, h=3\\n\\t   \\n\\t[0,0,1,1,2,2] and  l=2 ,m=3, h=3  \\n\\t   nums[m]=> nums[3] = 1\\n\\t   Increase the value of m by 1. \\n\\t   now, l=2 ,m=3+1=4, h=3\\n\\t    \\n```\\n      Upvote \\u2764\\uFE0F if it useful!!\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```/**\\n * Move all 0s to the left and all 2s to the right, then all 1s are left in the middle. Using a Swaping of two number.\\n *\\n * Time Complexity: O(N). N = Length of input array.\\n * \\n */\\n```\n```\\n  public void sortColors(int[] nums) {\\n       int length = nums.length;\\n        if(length==0)\\n         {   return;  }\\n        int l=0;\\n\\t\\tint m=0;\\n\\t\\tint h= length-1;\\n\\t\\tint temp;\\n            while(m <= h)\\n            {\\n                if(nums[m] == 1)\\n                    m++;\\n                else if(nums[m] == 0)\\n                {\\n                    temp = nums[l];\\n                    nums[l] = nums[m];\\n                    nums[m] = temp;\\n                    m++;\\n                    l++;\\n                }\\n                else if(nums[m] == 2)\\n                {                                \\n                    temp = nums[h];\\n                    nums[h] = nums[m];\\n                    nums[m] = temp;\\n                    h--;\\n                }\\n            }  \\n       }\\n```\n```\\n\\n  Given array is :-  [2,0,2,1,1,0]  and length = 6;\\n  \\n   [2,0,2,1,1,0]   and    l=0, m=0, h=length-1 = 5\\n\\t   nums[m]=> nums[0] = 2\\n\\t   swap=> nums[m] to nums[h] => nums[0] to nums[5] \\n\\t   and decrease h value i.e h=5-1 = 4\\n\\t   \\n   [0,0,2,1,1,2]  and  l=0, m=0, h=4\\n\\t   nums[m]=> nums[0] = 0\\n\\t   Increase the value of l and m by 1.\\n\\t   now, l=0+1=1,m=0+1=1,h=4\\n\\t   \\n   [0,0,2,1,1,2]   and  l=1, m=1, h=4\\n\\t\\tnums[m]=> nums[1] = 0\\n\\t\\tnow our array is => [0,0,2,1,1,2]\\n\\t\\tnow, l=1+1=2 ,m=1+1=2, h=4\\n\\t\\t\\n   [0,0,2,1,1,2] and  l=2, m=2, h=4\\n        nums[m]=> nums[2] = 2\\n\\t\\tswap=> nums[m] to nums[h] => nums[2] to nums[4] \\n\\t    now our array is => [0,0,1,1,2,2]\\n\\t    and decrease h value i.e h=4-1 = 3\\n\\t   \\n\\t[0,0,1,1,2,2] and  l=2 ,m=2, h=3\\n\\t   nums[m]=> nums[2] = 1\\n\\t   Increase the value of m by 1. \\n\\t   now, l=2 ,m=2+1=3, h=3\\n\\t   \\n\\t[0,0,1,1,2,2] and  l=2 ,m=3, h=3  \\n\\t   nums[m]=> nums[3] = 1\\n\\t   Increase the value of m by 1. \\n\\t   now, l=2 ,m=3+1=4, h=3\\n\\t    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1553062,
                "title": "75-sort-colors-java-solution",
                "content": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0, mid = 0, high = nums.length - 1, temp;\\n        while(mid <= high){\\n            switch(nums[mid]){\\n                case 0:\\n                    temp = nums[low];\\n                    nums[low] = nums[mid];\\n                    nums[mid] = temp;\\n                    low++;\\n                    mid++;\\n                    break;\\n                case 1:\\n                    mid++;\\n                    break;\\n                case 2:\\n                    temp = nums[mid];\\n                    nums[mid] = nums[high];\\n                    nums[high] = temp;\\n                    high--;\\n                    break;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0, mid = 0, high = nums.length - 1, temp;\\n        while(mid <= high){\\n            switch(nums[mid]){\\n                case 0:\\n                    temp = nums[low];\\n                    nums[low] = nums[mid];\\n                    nums[mid] = temp;\\n                    low++;\\n                    mid++;\\n                    break;\\n                case 1:\\n                    mid++;\\n                    break;\\n                case 2:\\n                    temp = nums[mid];\\n                    nums[mid] = nums[high];\\n                    nums[high] = temp;\\n                    high--;\\n                    break;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542956,
                "title": "c-two-pointers-0ms-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& v) {\\n        int i, j, k, n = v.size();\\n        for(i = 0; i < n && v[i] == 0; i++); // Loop from front until first non-zero element\\n        for(j = n - 1; j >= 0 && v[j] == 2; j--); // Loop from back until first non-two element\\n\\t\\t// i -> first non-zero index\\n\\t\\t// j -> last non-two index\\n        for(k = i; k <= j; k++){\\n            if(v[k] == 0){\\n\\t\\t\\t\\t// If 0, swap it with first non-zero index and increment i\\n                swap(v[k], v[i]);\\n                i++;\\n            }\\n            else if(v[k] == 2){\\n\\t\\t\\t\\t// If 2, swap it with last non-two index and decrement j\\n                swap(v[k], v[j]);\\n                j--;\\n                k--; // To not increment k in the next iteration\\n            }\\n        }\\n    }\\n};\\n```\\n\\n`Upvote \\u2764\\uFE0F if useful!!`",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& v) {\\n        int i, j, k, n = v.size();\\n        for(i = 0; i < n && v[i] == 0; i++); // Loop from front until first non-zero element\\n        for(j = n - 1; j >= 0 && v[j] == 2; j--); // Loop from back until first non-two element\\n\\t\\t// i -> first non-zero index\\n\\t\\t// j -> last non-two index\\n        for(k = i; k <= j; k++){\\n            if(v[k] == 0){\\n\\t\\t\\t\\t// If 0, swap it with first non-zero index and increment i\\n                swap(v[k], v[i]);\\n                i++;\\n            }\\n            else if(v[k] == 2){\\n\\t\\t\\t\\t// If 2, swap it with last non-two index and decrement j\\n                swap(v[k], v[j]);\\n                j--;\\n                k--; // To not increment k in the next iteration\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26529,
                "title": "my-template-for-this-kind-of-problem",
                "content": "One can use this template to handle this kind of \"sorting\" problems. No matter how many colors from 0 to n, or different labels as \"red\", \"blue\", etc.\\n\\nWe can simply put them in the cand array, then do the sorting.\\n\\n```\\npublic class Solution {\\n    public void sortColors(int[] nums) {\\n        int[] cand = {0, 1, 2};\\n        int start=0;\\n        for(int i=0;i<3;i++){\\n            while(start<nums.length && nums[start]==cand[i]) start++;\\n            for(int j=start;j<nums.length;j++){\\n                if(nums[j]==cand[i]){\\n                    swap(nums, j, start++);\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    public void swap(int[] nums, int a, int b){\\n        int t = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = t;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void sortColors(int[] nums) {\\n        int[] cand = {0, 1, 2};\\n        int start=0;\\n        for(int i=0;i<3;i++){\\n            while(start<nums.length && nums[start]==cand[i]) start++;\\n            for(int j=start;j<nums.length;j++){\\n                if(nums[j]==cand[i]){\\n                    swap(nums, j, start++);\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    public void swap(int[] nums, int a, int b){\\n        int t = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168168,
                "title": "best-c-3-solutions-in-place-two-pointers-counting-sorting-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Three Approaches.\\n\\n1. Solved using Array + Sorting.\\n2. Solved using Array + Counting.\\n3. Solved using Array + Two Pointers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(NlonN), As we are doing sorting. Where N is size of the array(nums).\\n\\n    Space Complexity: O(1), Constant space.\\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array equal to two times. Where N is size of the array(nums).\\n\\n    Space Complexity: O(1), Constant space.\\n\\n    Solved using Array + Counting.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int nextZeros = 0, nextOnes = 0, nextTwos = 0;\\n        for(auto it : nums){\\n            if(it == 0) nextZeros++;\\n            else if(it == 1) nextOnes++;\\n            else nextTwos++;\\n        }\\n        int k = 0;\\n        for(int i=0; i<nextZeros; i++) nums[k++] = 0;\\n        for(int i=0; i<nextOnes; i++) nums[k++] = 1;\\n        for(int i=0; i<nextTwos; i++) nums[k++] = 2;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array(nums) one times. Where N is size of the array(nums).\\n\\n    Space Complexity: O(1), Constant space.\\n\\n    Solved using Array + Two Pointers.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int nextZeros = 0, nextTwos = nums.size()-1, i = 0;\\n        while(i <= nextTwos){\\n            if(nums[i] == 0){\\n               swap(nums[i], nums[nextZeros]);\\n               nextZeros++; i++; \\n            }\\n            else if(nums[i] == 2){\\n                swap(nums[i], nums[nextTwos]);\\n                nextTwos--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(NlonN), As we are doing sorting. Where N is size of the array(nums).\\n\\n    Space Complexity: O(1), Constant space.\\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array equal to two times. Where N is size of the array(nums).\\n\\n    Space Complexity: O(1), Constant space.\\n\\n    Solved using Array + Counting.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int nextZeros = 0, nextOnes = 0, nextTwos = 0;\\n        for(auto it : nums){\\n            if(it == 0) nextZeros++;\\n            else if(it == 1) nextOnes++;\\n            else nextTwos++;\\n        }\\n        int k = 0;\\n        for(int i=0; i<nextZeros; i++) nums[k++] = 0;\\n        for(int i=0; i<nextOnes; i++) nums[k++] = 1;\\n        for(int i=0; i<nextTwos; i++) nums[k++] = 2;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array(nums) one times. Where N is size of the array(nums).\\n\\n    Space Complexity: O(1), Constant space.\\n\\n    Solved using Array + Two Pointers.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int nextZeros = 0, nextTwos = nums.size()-1, i = 0;\\n        while(i <= nextTwos){\\n            if(nums[i] == 0){\\n               swap(nums[i], nums[nextZeros]);\\n               nextZeros++; i++; \\n            }\\n            else if(nums[i] == 2){\\n                swap(nums[i], nums[nextTwos]);\\n                nextTwos--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185324,
                "title": "c-dutch-national-flag-algorithm-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        if (nums.size() == 0) return;\\n        int n = nums.size();\\n        int low = 0, mid = 0, high = n-1;\\n        // low should point to a group of 0\\'s\\n        // mid should point to a group of 1\\'s\\n        // high should point to a group of 2\\'s        \\n        while(mid <= high) {\\n            if (nums[mid] == 0) {\\n                swap(nums[mid], nums[low]);\\n                mid++;\\n                low++;\\n            }         \\n            else if (nums[mid] == 1) {\\n                mid++;\\n            }\\n            else if (nums[mid] == 2) {\\n                swap(nums[mid], nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        if (nums.size() == 0) return;\\n        int n = nums.size();\\n        int low = 0, mid = 0, high = n-1;\\n        // low should point to a group of 0\\'s\\n        // mid should point to a group of 1\\'s\\n        // high should point to a group of 2\\'s        \\n        while(mid <= high) {\\n            if (nums[mid] == 0) {\\n                swap(nums[mid], nums[low]);\\n                mid++;\\n                low++;\\n            }         \\n            else if (nums[mid] == 1) {\\n                mid++;\\n            }\\n            else if (nums[mid] == 2) {\\n                swap(nums[mid], nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114639,
                "title": "beats-100-o-n-o-1-c-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply we can do cout number of 0\\'s , 1\\'s and 2\\'s . Then jsut do a simple traverse and insert 0\\'s first in array and then 1\\'s and then 2\\'s  until each one\\'s occurence beomes zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet count of c0 ,c1 ,c2; Then while c0 is >0 keep pushing 0 in array \\nthe after that while c1>0 keep pushing 1\\'s in array and then 2\\'s.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& arr) {\\n        int n=arr.size();\\n        int c0=0,c1=0,c2=0;\\n        for(int i=0;i<n;i++){\\n            c0+=(arr[i]==0);\\n            c1+=(arr[i]==1);\\n            c2+=(arr[i]==2);\\n        }\\n        cout<<c0<<\" \"<<c0<<\" \"<<c2;\\n        for(int i=0;i<n;i++){\\n            if(c0>0)arr[i]=0,c0--;\\n            else if(c1>0)arr[i]=1,c1--;\\n            else arr[i]=2;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& arr) {\\n        int n=arr.size();\\n        int c0=0,c1=0,c2=0;\\n        for(int i=0;i<n;i++){\\n            c0+=(arr[i]==0);\\n            c1+=(arr[i]==1);\\n            c2+=(arr[i]==2);\\n        }\\n        cout<<c0<<\" \"<<c0<<\" \"<<c2;\\n        for(int i=0;i<n;i++){\\n            if(c0>0)arr[i]=0,c0--;\\n            else if(c1>0)arr[i]=1,c1--;\\n            else arr[i]=2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2710736,
                "title": "simple-c-solution-same-like-3-way-quicksort-partitioning",
                "content": "**Idea:** I used 3-Way QuickSort Partitioning Technique which is as follows: we set a pivot, then we keep elements less than pivot on left side and greater than pivot on right side and elements equal to pivot will be in the middle. \\n**For Example:** we have an array [2, 2, 0, 1, 0, 1], we set pivot to 1 then our array will be [0, 0, 1, 1, 2, 2]\\n**Implementation:** How can we implement that? \\n1. Left pointer - so we will keep storing `element < pivot` from left side\\n2. Right pointer - so we will keep storing `element > pivot` from right side\\n\\nsetting left and right pointers\\n```\\nint l = 0, r = a.size() - 1;\\n```\\n\\nWe will go from `0 to r` ... and if we encounter any `element > pivot `  hence decrementing` r `will help us not to evaluate element that is already fixed to the right side\\n```\\nfor(int i = 0; i <= r; i++)\\n```\\n1. If `element < pivot`, put current element on the left side, and increase `l`\\n2. if `element > pivot` put current element on the right side, and decrease `r` and also decrease `i` becasue the element which was on the right with which we swapped current element has to be checked. \\n```\\nif(a[i] < p) {\\n\\tswap(a[i], a[l]);\\n\\tl++;\\n} else if(a[i] > p) {\\n\\tswap(a[i], a[r]);\\n\\tr--;\\n\\ti--;\\n}\\n```\\nFinal Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        // quick sort algo with pivot 1\\n        int p = 1;\\n        int l = 0, r = a.size() - 1;\\n        for(int i = 0; i <= r; i++) {\\n            if(a[i] < p) {\\n                swap(a[i], a[l]);\\n                l++;\\n            } else if(a[i] > p) {\\n                swap(a[i], a[r]);\\n                r--;\\n                i--;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint l = 0, r = a.size() - 1;\\n```\n```\\nfor(int i = 0; i <= r; i++)\\n```\n```\\nif(a[i] < p) {\\n\\tswap(a[i], a[l]);\\n\\tl++;\\n} else if(a[i] > p) {\\n\\tswap(a[i], a[r]);\\n\\tr--;\\n\\ti--;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        // quick sort algo with pivot 1\\n        int p = 1;\\n        int l = 0, r = a.size() - 1;\\n        for(int i = 0; i <= r; i++) {\\n            if(a[i] < p) {\\n                swap(a[i], a[l]);\\n                l++;\\n            } else if(a[i] > p) {\\n                swap(a[i], a[r]);\\n                r--;\\n                i--;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848562,
                "title": "javascript-o-n-time-and-o-1-space-complexity-solution",
                "content": "```\\nvar sortColors = function (nums) {\\n  let i = 0;\\n\\n  let left = 0,\\n    right = nums.length - 1;\\n\\n  while (i <= right && left < right) {\\n    if (nums[i] === 0) {\\n      [nums[i], nums[left]] = [nums[left], nums[i]];\\n      left++;\\n      i++;\\n    } else if (nums[i] === 2) {\\n      [nums[i], nums[right]] = [nums[right], nums[i]];\\n      right--;\\n    } else {\\n      i++;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortColors = function (nums) {\\n  let i = 0;\\n\\n  let left = 0,\\n    right = nums.length - 1;\\n\\n  while (i <= right && left < right) {\\n    if (nums[i] === 0) {\\n      [nums[i], nums[left]] = [nums[left], nums[i]];\\n      left++;\\n      i++;\\n    } else if (nums[i] === 2) {\\n      [nums[i], nums[right]] = [nums[right], nums[i]];\\n      right--;\\n    } else {\\n      i++;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363229,
                "title": "java-beginner-friendly-iterative-solution",
                "content": "```\\n    public void sortColors(int[] nums) {\\n        int l0 = -1;\\n        int l1 = -1;\\n        int l2 = -1;\\n        int n = nums.length;\\n        \\n        // Feel free to post questions in case you have difficulty to undertand the logic behind\\n\\t\\t\\n\\t\\t\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) {\\n                nums[++l0] = 0;\\n                \\n                if (l1 >= 0) {\\n                    nums[++l1] = 1;\\n                }\\n                \\n                if (l2 >= 0) {\\n                    nums[++l2] = 2;\\n                }\\n            } else if (nums[i] == 1) {\\n                l1 = Math.max(l0, l1);\\n                nums[++l1] = 1;\\n                \\n                if (l2 >= 0) {\\n                    nums[++l2] = 2;\\n                }\\n            } else {\\n                l2 = Math.max(Math.max(l0, l1), l2);\\n                nums[++l2] = 2;\\n            }       \\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public void sortColors(int[] nums) {\\n        int l0 = -1;\\n        int l1 = -1;\\n        int l2 = -1;\\n        int n = nums.length;\\n        \\n        // Feel free to post questions in case you have difficulty to undertand the logic behind\\n\\t\\t\\n\\t\\t\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) {\\n                nums[++l0] = 0;\\n                \\n                if (l1 >= 0) {\\n                    nums[++l1] = 1;\\n                }\\n                \\n                if (l2 >= 0) {\\n                    nums[++l2] = 2;\\n                }\\n            } else if (nums[i] == 1) {\\n                l1 = Math.max(l0, l1);\\n                nums[++l1] = 1;\\n                \\n                if (l2 >= 0) {\\n                    nums[++l2] = 2;\\n                }\\n            } else {\\n                l2 = Math.max(Math.max(l0, l1), l2);\\n                nums[++l2] = 2;\\n            }       \\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 195342,
                "title": "o-n-one-pass-java-solution-beat-100",
                "content": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int left = 0, right = nums.length-1, count = 0;\\n        while (count < nums.length) {\\n        \\tif (nums[count] == 0 && count > left) {\\n        \\t\\tnums[count] = nums[left];\\n        \\t\\tnums[left] = 0;\\n        \\t\\tleft++;\\n        \\t}\\n        \\telse if (nums[count] == 2 && count < right) {\\n        \\t\\tnums[count] = nums[right];\\n        \\t\\tnums[right] = 2;\\n        \\t\\tright--;\\n        \\t}\\n        \\telse {\\n        \\t\\tcount ++;\\n        \\t}\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int left = 0, right = nums.length-1, count = 0;\\n        while (count < nums.length) {\\n        \\tif (nums[count] == 0 && count > left) {\\n        \\t\\tnums[count] = nums[left];\\n        \\t\\tnums[left] = 0;\\n        \\t\\tleft++;\\n        \\t}\\n        \\telse if (nums[count] == 2 && count < right) {\\n        \\t\\tnums[count] = nums[right];\\n        \\t\\tnums[right] = 2;\\n        \\t\\tright--;\\n        \\t}\\n        \\telse {\\n        \\t\\tcount ++;\\n        \\t}\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167029,
                "title": "java-one-pass-solution-with-detailed-explanation",
                "content": "If you are not familiar with quick sort partition I suggest you get to know that before you read this solution.\\n#### Main Idea\\nthis solution will partition the array into 3 parts, 0,1,2 instead of just 2 parts like quick sort. We just put 0 on the left side, 2 on the right side. \\nwe have two pointers low and high which indicate the bound of 0s and 2s (low is the right bound of 0 and high is the left bound of 2). At the end of this partiton low and high will be like this.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/surface_handsome/image_1536133070.png)\\nDuring the partition, one thing is for sure: left side of low pointer will be all 0s and right side of high pointer will be all 2s. This is guranteed by swaping nums[mid] with the number[low + 1] when nums[mid] == 0 and with number[high - 1] when nums[mid] == 2\\u3002\\n``` java\\nclass Solution {\\n    private int[] nums;\\n    public void sortColors(int[] nums) {\\n        // one pass\\n        this.nums = nums;\\n        int low = -1;\\n        int high = nums.length;\\n        int mid = 0;\\n        \\n        while(mid < high) {\\n            if (nums[mid] == 1) {\\n                mid++;\\n            } else if (nums[mid] == 0) {\\n                ++low;\\n                swap(mid,low);\\n                // skip one, must be 1 bcz you already go through it\\n                mid++;\\n            } else {\\n                high--;\\n                swap(mid,high);\\n            }\\n        }\\n    }\\n    \\n    private void swap(int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    private int[] nums;\\n    public void sortColors(int[] nums) {\\n        // one pass\\n        this.nums = nums;\\n        int low = -1;\\n        int high = nums.length;\\n        int mid = 0;\\n        \\n        while(mid < high) {\\n            if (nums[mid] == 1) {\\n                mid++;\\n            } else if (nums[mid] == 0) {\\n                ++low;\\n                swap(mid,low);\\n                // skip one, must be 1 bcz you already go through it\\n                mid++;\\n            } else {\\n                high--;\\n                swap(mid,high);\\n            }\\n        }\\n    }\\n    \\n    private void swap(int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26654,
                "title": "sort-colors-and-sort-k-colors-c-solution",
                "content": "Solution:\\n\\n    //3 color sort\\n    //2 partition indexes\\n    //time complexity: O(N)\\n    //space complexity: O(1)\\n    class Solution{\\n    public:\\n        /**\\n         * @param nums: A list of integer which is 0, 1 or 2 \\n         * @return: nothing\\n         */    \\n        void sortColors(vector<int> &nums) {\\n            // write your code here\\n            if (nums.size() == 0) return;\\n            int zeroPartition = 0, twoPartition = nums.size() - 1;\\n            for (int i = 0; i <= twoPartition; ) {\\n                if (nums[i] == 0) {\\n                    swap(nums[zeroPartition], nums[i]); zeroPartition++; i++;\\n                } else if (nums[i] == 2) {\\n                    swap(nums[twoPartition], nums[i]); twoPartition--;\\n                } else {\\n                    i++;\\n                }\\n            }\\n        }\\n        \\n        void swap(int& a, int& b) {\\n            int tmp = a; a = b; b = tmp;\\n        }\\n    };\\n\\n\\nThere is also an extension question on lintcode: sort k colors. http://www.lintcode.com/en/problem/sort-colors-ii/#\\n\\nBasically, the naive solution is a two-pass algorithm using counting sort. That will cost O(k) extra memory. How can you solve it without using extra memory?\\n\\nThe O(1) space solution is just an extension of sort colors:\\n\\n    //sort k colors, extend by sort 3 colors\\n    class Solution{\\n    public:\\n        /**\\n         * @param colors: A list of integer\\n         * @param k: An integer\\n         * @return: nothing\\n         */    \\n        void sortColors2(vector<int> &colors, int k) {\\n            if (colors.size() == 0) return;\\n            // write your code here\\n            int lowColor = 1, highColor = k;\\n            int lpartition = 0, hpartition = colors.size() - 1;\\n            while (lowColor < highColor) {\\n                for (int i = lpartition; i <= hpartition; ) {\\n                    if (colors[i] == lowColor) {\\n                        swap(colors[i], colors[lpartition]); lpartition++; i++;\\n                    } else if (colors[i] == highColor) {\\n                        swap(colors[i], colors[hpartition]); hpartition--;\\n                    } else {\\n                        i++;\\n                    }\\n                }\\n                lowColor++; highColor--;\\n            }\\n        }\\n    };\\n\\nCan someone talks about this solution's time complexity? Thanks",
                "solutionTags": [],
                "code": "class Solution{\\n    public:\\n        /**\\n         * @param nums: A list of integer which is 0, 1 or 2 \\n         * @return: nothing\\n         */    \\n        void sortColors(vector<int> &nums) {\\n            // write your code here\\n            if (nums.size() == 0) return;\\n            int zeroPartition = 0, twoPartition = nums.size() - 1;\\n            for (int i = 0; i <= twoPartition; ) {\\n                if (nums[i] == 0) {\\n                    swap(nums[zeroPartition], nums[i]); zeroPartition++; i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3782495,
                "title": "brute-force-to-optimal-solution",
                "content": "## Brute Force Approach\\n\\nThere are only 3 distinct values in the array so it\\u2019s easy to maintain the count of all, Like the count of 0, 1, and 3.\\n\\n## Code\\uD83D\\uDC47\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int c0=0;\\n        int c1=0;\\n        int c2=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0) c0++;\\n            else if(nums[i]==1) c1++;\\n            else if(nums[i]==2) c2++;\\n        }\\n        for(int i=0;i<c0;i++){\\n            nums[i]=0;\\n        }\\n        for(int i=c0;i<c0+c1;i++){\\n            nums[i]=1;\\n        }\\n        for(int i=c0+c1;i<nums.length;i++){\\n            nums[i]=2;\\n        }\\n\\n        \\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity : O(N) since we are iterating the array only.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1) since we are not not using any extra space. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Optimal Approach\\n\\nIt contains 3 pointers i.e. low, mid, and high.\\n\\narr[0\\u2026.low-1] contains 0, leftmost part.\\narr[low\\u2026.mid-1] contains 1.\\narr[high+1\\u2026.n-1] contains 2, rightmost part\\n\\n# Code\\uD83D\\uDC47\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int l=0,mid=0,h=nums.length-1;\\n        while(mid<=h){\\n            if(nums[mid]==0){\\n                swap(nums,l,mid);\\n                l++;\\n                mid++;\\n            }\\n            else if(nums[mid]==1){\\n                mid++;\\n            }\\n            else{\\n                swap(nums,mid,h);\\n                h--;\\n            }\\n        }\\n        \\n    }\\n    static void swap(int arr[],int a,int b){\\n        int temp=arr[a];\\n        arr[a]=arr[b];\\n        arr[b]=temp;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity : O(N).\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1), not using any extra space. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/e5c88faa-dd01-4bf6-b72f-86b38cec10e7_1689676476.8823164.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int c0=0;\\n        int c1=0;\\n        int c2=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0) c0++;\\n            else if(nums[i]==1) c1++;\\n            else if(nums[i]==2) c2++;\\n        }\\n        for(int i=0;i<c0;i++){\\n            nums[i]=0;\\n        }\\n        for(int i=c0;i<c0+c1;i++){\\n            nums[i]=1;\\n        }\\n        for(int i=c0+c1;i<nums.length;i++){\\n            nums[i]=2;\\n        }\\n\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int l=0,mid=0,h=nums.length-1;\\n        while(mid<=h){\\n            if(nums[mid]==0){\\n                swap(nums,l,mid);\\n                l++;\\n                mid++;\\n            }\\n            else if(nums[mid]==1){\\n                mid++;\\n            }\\n            else{\\n                swap(nums,mid,h);\\n                h--;\\n            }\\n        }\\n        \\n    }\\n    static void swap(int arr[],int a,int b){\\n        int temp=arr[a];\\n        arr[a]=arr[b];\\n        arr[b]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743495,
                "title": "100-easy-and-fast-java-solution",
                "content": "# Intuition\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/7d018af0-65e8-48e9-af40-5883e15de420_1688963090.209322.jpeg)\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n![download.png](https://assets.leetcode.com/users/images/359c8328-2967-4d49-a42a-6a95db401880_1688963046.482525.png)\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        sort(nums,0,nums.length-1);\\n        \\n    }\\n    void sort(int[] nums,int low,int high)\\n    {\\n        if(low >= high) return;\\n        int s=low;\\n        int e=high;\\n        int m=s + (e - s) /2;\\n        int pivot=nums[m];\\n        while(s <= e)\\n        {\\n            while(nums[s] < pivot) s++;\\n            while(nums[e] > pivot) e--;\\n             if(s <= e)\\n             {\\n                int temp=nums[s];\\n                nums[s]=nums[e];\\n                nums[e]=temp;\\n                s++;\\n                e--;\\n             }\\n        }\\n        sort(nums,low,e);\\n        sort(nums,s,high);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        sort(nums,0,nums.length-1);\\n        \\n    }\\n    void sort(int[] nums,int low,int high)\\n    {\\n        if(low >= high) return;\\n        int s=low;\\n        int e=high;\\n        int m=s + (e - s) /2;\\n        int pivot=nums[m];\\n        while(s <= e)\\n        {\\n            while(nums[s] < pivot) s++;\\n            while(nums[e] > pivot) e--;\\n             if(s <= e)\\n             {\\n                int temp=nums[s];\\n                nums[s]=nums[e];\\n                nums[e]=temp;\\n                s++;\\n                e--;\\n             }\\n        }\\n        sort(nums,low,e);\\n        sort(nums,s,high);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009143,
                "title": "beats-98-easy-explained-solution-for-beginners",
                "content": "# Intuition\\nTwo pointers ftw\\n\\n# Approach\\nLeft pointer is where the next 0 will be at\\nRight pointer is where the next 2 will be at\\n\\n- \"Iterate\" through the list from left to right (Before reaching the latest \"2\" that has been swapped)\\n- If the number is a 2, swap with the right pointer number and decrement it by one (As the next 2 will be to the left of the swapped \"2\")\\'\\n- Elif the number is a 0, similarly, swap with the left pointer number and increment it by one.\\n- Else (If the number is a 1), just \"skip\" the number\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        left = count = 0\\n        right = len(nums)-1\\n        while count <= right:\\n            if nums[count] == 2:\\n                nums[count], nums[right] = nums[right], nums[count]\\n                right -= 1\\n            elif nums[count] == 0:\\n                nums[count], nums[left] = nums[left], nums[count]\\n                left += 1\\n                count += 1\\n            else:\\n                count += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        left = count = 0\\n        right = len(nums)-1\\n        while count <= right:\\n            if nums[count] == 2:\\n                nums[count], nums[right] = nums[right], nums[count]\\n                right -= 1\\n            elif nums[count] == 0:\\n                nums[count], nums[left] = nums[left], nums[count]\\n                left += 1\\n                count += 1\\n            else:\\n                count += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805856,
                "title": "c-100-runtime-explained-using-dutch-national-flag",
                "content": "# Easy, Fast and Beginner Friendly \\u2705\\n# Intuition\\nWe can solve this problem using Dutch Flag Algorithm.\\n\\n    Runtime - 100%\\uD83D\\uDD25 \\n    Memory - 91.13%\\uD83D\\uDD25\\n\\n# Approach\\n1. Firstly we will assume that all 0\\'s are on the left of low pointer and all 2\\'s are on right of high pointer.\\n2. Then we apply the above rule for nums array, we will check each element in nums array with the help of mid pointer :\\n3. If nums[mid] = 0 then we will swap it with nums[low](as all 0\\'s should be on left of low) and will increase low and mid.\\n4. If nums[mid] = 1 then it is at its correct position so no need to swap we will just increase mid.\\n5. if nums[mid] = 2 then we will swap it with nums[high](as all 2\\'s should be on right of high) and will decrease high.(But will not update mid as at mid there will be a new value which could be 0).\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n#  If you like the solution and understand it then Please Upvote.\\u2B06\\uFE0F\\u2764\\uFE0F \\n\\t* PEACE OUT LUV\\u270C\\uFE0F*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low = 0; int mid = 0; int high = nums.size()-1;\\n        while(mid<=high){\\n            switch(nums[mid]){\\n                case 0:\\n                    swap(nums[mid++], nums[low++]);\\n                    break;\\n                case 1:\\n                    mid++;\\n                    break;\\n                case 2:\\n                    swap(nums[mid], nums[high--]);\\n                    break;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low = 0; int mid = 0; int high = nums.size()-1;\\n        while(mid<=high){\\n            switch(nums[mid]){\\n                case 0:\\n                    swap(nums[mid++], nums[low++]);\\n                    break;\\n                case 1:\\n                    mid++;\\n                    break;\\n                case 2:\\n                    swap(nums[mid], nums[high--]);\\n                    break;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800235,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int i = -1, j = nums.length;\\n        int ans = 0;\\n        while (ans < j) {\\n            if (nums[ans] == 0) {\\n                swap(nums, ans++, ++i);\\n            } else if (nums[ans] == 1) {\\n                ++ans;\\n            } else {\\n                swap(nums, ans, --j);\\n            }\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int x = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int i = -1, j = nums.length;\\n        int ans = 0;\\n        while (ans < j) {\\n            if (nums[ans] == 0) {\\n                swap(nums, ans++, ++i);\\n            } else if (nums[ans] == 1) {\\n                ++ans;\\n            } else {\\n                swap(nums, ans, --j);\\n            }\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int x = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314707,
                "title": "dutch-national-flag-algo-tc-o-n-sc-o-1-c",
                "content": ",,,,\\n**ALGORITHM**\\nThree pointers are used: low, mid, high.\\n Low and mid pointers point at start and high pointer points at the end of the given array.\\nCases:\\n1. if array [ mid ] = 0, then swap array [ mid ] with array [low] and increment both pointers once.\\n2. if array [ mid] = 1, then no swapping is required, just increment mid pointer once.\\n3. if array [ mid ] = 2, then swap array [ mid ] with array [high] and decrement the high pointer once.\\n\\n\\n\\nvoid sortColors(vector<int>& nums) {\\n        \\n\\t\\t\\n        int n=nums.size();\\n        int low=0;\\n        int mid=0;\\n        int last=n-1;\\n        while(mid<=last)\\n        {\\n            switch(nums[mid])\\n            {\\n                case 0:  \\n                    swap(nums[low++],nums[mid++]);\\n                    break;\\n                case 1:\\n                    mid++;\\n                    break;\\n                case 2:\\n                    swap(nums[mid],nums[last--]);\\n            }\\n        }\\n    }\\n\\t,,,,",
                "solutionTags": [
                    "C"
                ],
                "code": ",,,,\\n**ALGORITHM**\\nThree pointers are used: low, mid, high.\\n Low and mid pointers point at start and high pointer points at the end of the given array.\\nCases:\\n1. if array [ mid ] = 0, then swap array [ mid ] with array [low] and increment both pointers once.\\n2. if array [ mid] = 1, then no swapping is required, just increment mid pointer once.\\n3. if array [ mid ] = 2, then swap array [ mid ] with array [high] and decrement the high pointer once.\\n\\n\\n\\nvoid sortColors(vector<int>& nums) {\\n        \\n\\t\\t\\n        int n=nums.size();\\n        int low=0;\\n        int mid=0;\\n        int last=n-1;\\n        while(mid<=last)\\n        {\\n            switch(nums[mid])\\n            {\\n                case 0:  \\n                    swap(nums[low++],nums[mid++]);\\n                    break;\\n                case 1:\\n                    mid++;\\n                    break;\\n                case 2:\\n                    swap(nums[mid],nums[last--]);\\n            }\\n        }\\n    }\\n\\t,,,,",
                "codeTag": "Unknown"
            },
            {
                "id": 2307871,
                "title": "clean-code-wiith-explaination-two-pointers-java-code",
                "content": "class Solution {\\n\\n    public void sortColors(int[] arr) {\\n\\n        int low = 0, high = arr.length - 1;             //take two pointers low and high and initialize them\\n\\n        int i = 0;                                // a variable i to traverse the array\\n        while (i <= high) {                             \\n            if (arr[i] == 0) {                    //if the value at array of i is zero then\\n                swap(arr, i, low);                //swap with the low index element (because all zeroes must be present at the starting of an array)\\n                low += 1;                         //and increase low & i by 1\\n                i += 1;\\n            }\\n            else if (arr[i] == 2) {                //as we know we have to put all the 2\\'s at the end of an array\\n                swap(arr, i, high);                //So, if array of i is 2 then swap it with the high index element\\n                high -= 1;                         //and decrease index of high by 1\\n            }\\n            else {\\n                i += 1;                             //if array of i is not equal to zero or 2 then just simply increase i by 1\\n            }\\n        }\\n    }\\n\\n    private void swap(int[] arr, int i, int j) {            //swap function\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\n    public void sortColors(int[] arr) {\\n\\n        int low = 0, high = arr.length - 1;             //take two pointers low and high and initialize them\\n\\n        int i = 0;                                // a variable i to traverse the array\\n        while (i <= high) {                             \\n            if (arr[i] == 0) {                    //if the value at array of i is zero then\\n                swap(arr, i, low);                //swap with the low index element (because all zeroes must be present at the starting of an array)\\n                low += 1;                         //and increase low & i by 1\\n                i += 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2003359,
                "title": "c-o-n-time-and-o-1-space-dutch-flag-algo-best-optimized-approach",
                "content": "****upvote if it helps****\\t\\t\\n\\t\\t\\n\\t\\tint i =0,k = nums.size()-1,j = 0;\\n        while(j<=k){\\n            if(nums[j]==0)    swap(nums[i++],nums[j++]);\\n            else if (nums[j]==1)   j++;\\n            else if(nums[j]==2)   swap(nums[j],nums[k--]);\\n        }",
                "solutionTags": [
                    "C"
                ],
                "code": "****upvote if it helps****\\t\\t\\n\\t\\t\\n\\t\\tint i =0,k = nums.size()-1,j = 0;\\n        while(j<=k){\\n            if(nums[j]==0)    swap(nums[i++],nums[j++]);\\n            else if (nums[j]==1)   j++;\\n            else if(nums[j]==2)   swap(nums[j],nums[k--]);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1448160,
                "title": "simple-cpp-0ms-solution-using-dutch-flag-algo",
                "content": "Using Dutch flag algorithm  where below low pointer all 0\\'s exist and after high pointer all 2\\'s exist\\n\\n``` void sortColors(vector<int>& nums) {\\n        int low=0,mid=0,high=nums.size()-1;\\n        while(mid<=high){\\n            if(nums[mid]==1){\\n                mid++;\\n            }\\n            else if(nums[mid]==0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            else{\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n        \\n    }\\n\\t```\\n\\t**I think this post deserve upvote. Thankyou!!**",
                "solutionTags": [],
                "code": "``` void sortColors(vector<int>& nums) {\\n        int low=0,mid=0,high=nums.size()-1;\\n        while(mid<=high){\\n            if(nums[mid]==1){\\n                mid++;\\n            }\\n            else if(nums[mid]==0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            else{\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1017599,
                "title": "c-beats-99-one-pass-detailed-whiteboard-explanation",
                "content": "### Explanation:\\n**Example : [2,0,2,1,1,0]**\\nI\\'ll solve this problem using [Dutch National Flag algorithm](https://en.wikipedia.org/wiki/Dutch_national_flag_problem) where I have solved using inplace values of array.\\n```\\ncurr = current pointer\\nptr1 = start pointer\\nptr2 = end pointer\\n```\\nThere are three cases : namely `case 0`, `case 1`, `case 2`\\nFirst of all I will move the current pointer until `current index is less than equal to end pointer index`.\\n\\n**`case 0`**\\nIn this case if `nums[curr] == 0`, then we\\'ll swap the values of `first pointer` and `current pointer`.\\nThen move start pointer one step ahead & move `current pointer` one step ahead\\n\\n**`case 1`**\\nIn this case if `nums[curr] == 1`, then just move the `current pointer ahead`.\\n\\n**`case 2`**\\nIn this case if `nums[curr] == 2`, then swap values of `current` and `end pointed values`.\\nAfter that` move end pointer one step back` & `current pointer remain at same position`.\\n\\n***Now see the steps :***\\n![image](https://assets.leetcode.com/users/images/82c9c9bf-0d26-4b70-9a4d-23d0b723f451_1610692397.1020772.png)\\n\\n### T = O(n) & S = O(1)\\n\\n```\\n void sortColors(vector<int>& nums) {\\n       int ptr1 = 0;  // starting pointer \\n       int ptr2 = nums.size()-1;  // end pointer\\n       int curr = 0;  // current pointer\\n        while(curr <= ptr2) {  // if current pointer less than equal to end pointer\\n            if(nums[curr] == 0) {\\n                swap(nums[ptr1], nums[curr]);  // if 0 found then swap with current and start pointer values\\n                ptr1++;  // move start pointer one step ahead\\n                curr++;  // move current pointer one step ahead\\n            }\\n            else if(nums[curr] == 1) {\\n                curr++;  // if current pointer at 1 then just move the current pointer ahead\\n            }\\n            else if(nums[curr] == 2) {\\n                swap(nums[ptr2], nums[curr]);  // if current pointer is 2 then swap values of current and end pointed values\\n                ptr2--;  // move end pointer one step back\\n            }\\n        }\\n\\t}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\ncurr = current pointer\\nptr1 = start pointer\\nptr2 = end pointer\\n```\n```\\n void sortColors(vector<int>& nums) {\\n       int ptr1 = 0;  // starting pointer \\n       int ptr2 = nums.size()-1;  // end pointer\\n       int curr = 0;  // current pointer\\n        while(curr <= ptr2) {  // if current pointer less than equal to end pointer\\n            if(nums[curr] == 0) {\\n                swap(nums[ptr1], nums[curr]);  // if 0 found then swap with current and start pointer values\\n                ptr1++;  // move start pointer one step ahead\\n                curr++;  // move current pointer one step ahead\\n            }\\n            else if(nums[curr] == 1) {\\n                curr++;  // if current pointer at 1 then just move the current pointer ahead\\n            }\\n            else if(nums[curr] == 2) {\\n                swap(nums[ptr2], nums[curr]);  // if current pointer is 2 then swap values of current and end pointed values\\n                ptr2--;  // move end pointer one step back\\n            }\\n        }\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26637,
                "title": "simple-one-pass-solution",
                "content": "    public void sortColors(int[] nums) {\\n\\t\\tint startIndex = 0;\\n\\t\\tint endIndex = nums.length - 1;\\n\\t\\tint temp,i =0;\\n\\t\\twhile(i < nums.length) {\\n\\t\\t\\tif (nums[i] == 0 && i != startIndex) {\\n\\t\\t\\t\\ttemp = nums[i];\\n\\t\\t\\t\\tnums[i] = nums[startIndex];\\n\\t\\t\\t\\tnums[startIndex++] = temp;\\n\\t\\t\\t} else if (nums[i] == 2 && i < endIndex) {\\n\\t\\t\\t\\ttemp = nums[i];\\n\\t\\t\\t\\tnums[i] = nums[endIndex];\\n\\t\\t\\t\\tnums[endIndex--] = temp;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void sortColors(int[] nums) {\\n\\t\\tint startIndex = 0;\\n\\t\\tint endIndex = nums.length - 1;\\n\\t\\tint temp,i =0;\\n\\t\\twhile(i < nums.length) {\\n\\t\\t\\tif (nums[i] == 0 && i != startIndex) {\\n\\t\\t\\t\\ttemp = nums[i];\\n\\t\\t\\t\\tnums[i] = nums[startIndex];\\n\\t\\t\\t\\tnums[startIndex++] = temp;\\n\\t\\t\\t} else if (nums[i] == 2 && i < endIndex) {\\n\\t\\t\\t\\ttemp = nums[i];\\n\\t\\t\\t\\tnums[i] = nums[endIndex];\\n\\t\\t\\t\\tnums[endIndex--] = temp;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 26629,
                "title": "extentions-more-clear-explanation-than-previous-posts",
                "content": "First, Let us to solve a simpler problem,   for input like this\\n\\n       Input array   =  [0, 1, 0, 1, 0, 0, 1, 1, 1, 0] \\nWe want the put all the '0' to the left while the '1' to the right.\\n       \\n       Output array =  [0, 0, 0, 0, 0, 1, 1, 1, 1, 1] \\n\\nHow can you do this in only one pass ?\\n\\nHere is a possible implementation:\\n\\n    void segregate0and1(vector<int> arr)\\n    {\\n        int size=arr.size();\\n        /* Initialize left and right indexes */\\n        int left = 0, right = size-1;\\n     \\n        while (left < right)\\n        {\\n            /* Increment left index while we see 0 at left */\\n            while (arr[left] == 0 && left < right)\\n                left++;\\n     \\n            /* Decrement right index while we see 1 at right */\\n            while (arr[right] == 1 && left < right)\\n                right--;\\n     \\n            /* If left is smaller than right then there is a 1 at left\\n              and a 0 at right.  Exchange arr[left] and arr[right]*/\\n            if (left < right)\\n            {\\n                  swap(arr[left++], arr[right--]);\\n            }\\n        }\\n    }\\n\\nNow let us solve the 3 color problem, it is just a easy extension based on the above problem.\\n\\nThe most important thing is to make sure you know that  to solve the above problem, we use 2 pointers.\\n\\nNow this problem need 3 pointers.\\n\\n              L0      array[0...L0-1]  all are 0\\n              L1      array[L0...L1-1]  all are 1\\n              unknown    array[L1...L2] \\n              L2      array[L2+1...N]  all are 2\\n\\nBased on the above definition, it is much more easy to understand the algorithm like this.\\n\\n           L0 := 0; L1:= 0; L2 := N-1;\\n           while L1 <= L2 do\\n           Invariant: a[0..L0-1]=0 and a[L0..L1-1]=1 and a[L2+1..N]=2; a[L1..L2] are unknown.\\n           case a[L1] in\\n               0: swap a[L0] and a[L1]; L0++; L1++\\n               1: L1++\\n               2: swap a[L1] and a[L2];  L2--\\n\\nThe above index explanation can be viewed in this images.\\n\\nL1 means mid   and     L2 means  Hi\\n\\n![enter image description here][1]\\n\\n\\nBased on the above  explanation,  we get the final AC implementation like this \\n\\n\\n    class Solution {\\n    public:\\n        void sortColors(vector<int>& nums) {\\n            int len=nums.size();\\n            if(len<=1)  return;\\n            int one=0, two=len-1, zero=0;\\n            while(one<=two){\\n                if(nums[one]==0)  swap(nums[one++], nums[zero++]);\\n                else if (nums[one]==2)  swap(nums[one], nums[two--]);\\n                else  one++;\\n            }\\n        }\\n    };\\n\\n     \\nThanks the posts from G4G \\n\\n[http://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/][2]\\n\\n\\n\\n**UPDATE @ 2016/03/04**\\n\\nHow to solve the problem if there are K colors ?\\n\\n**Given an array of n objects with k different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, ... k.**\\n\\nWe can use the previous position to store the count of all the K value, use the position K-1  to store the \\noccurrence of the number K.\\n\\nTo distinguish from the recorded number, we use negative number to store the occurrence.\\n\\n    class Solution{\\n    public:\\n        /**\\n         * @param colors: A list of integer\\n         * @param k: An integer\\n         * @return: nothing\\n         */\\n        void sortColors2(vector<int> &colors, int k) {\\n            for (int i = 0; i < colors.size(); ++i) {\\n                if (colors[i] > 0) {\\n                    int pos = colors[i] - 1;\\n                    if (colors[pos] <= 0) {  // Bucket exists.\\n                        --colors[pos];\\n                        colors[i] = 0;\\n                    }\\n                    else {  // Init a new bucket.\\n                        colors[i] = colors[pos];\\n                        colors[pos] = -1;\\n                        --i;\\n                    }\\n                }\\n            }\\n    \\n            for (int i = colors.size() - 1, pos = k - 1; pos >= 0; --pos) {\\n                while (colors[pos] < 0) {  // Reorder the color by count of each bucket.\\n                    ++colors[pos];\\n                    colors[i--] = pos + 1;\\n                }\\n            }\\n        }\\n    };\\n\\n  [1]: http://d1gjlxt8vb0knt.cloudfront.net//wp-content/uploads/DNF1.png\\n  [2]: http://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void sortColors(vector<int>& nums) {\\n            int len=nums.size();\\n            if(len<=1)  return;\\n            int one=0, two=len-1, zero=0;\\n            while(one<=two){\\n                if(nums[one]==0)  swap(nums[one++], nums[zero++]);\\n                else if (nums[one]==2)  swap(nums[one], nums[two--]);\\n                else  one++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 26668,
                "title": "just-one-pass-and-beats-83-15-java-solution-and-easy-to-understand",
                "content": "\\n    public static void sortColors(int[] nums) {\\n\\t\\t  int m=0,n=0,p=nums.length-1;\\n\\t\\t  while(n<=p)\\n\\t\\t   {\\n\\t\\t\\t   if(0==nums[n]){\\n\\t\\t\\t\\t   int temp=0;\\n\\t\\t\\t\\t   temp=nums[n];\\n\\t\\t\\t\\t   nums[n]=nums[m];\\n\\t\\t\\t\\t   nums[m]=temp;\\n\\t\\t\\t\\t   m++;\\n\\t\\t\\t\\t   n++;\\n\\t\\t\\t   }else if(2==nums[n]){\\n\\t\\t\\t\\t   int temp=0;\\n\\t\\t\\t\\t   temp=nums[p];\\n\\t\\t\\t\\t   nums[p]=nums[n];\\n\\t\\t\\t\\t   nums[n]=temp;\\n\\t\\t\\t\\t   p--;\\n\\t\\t\\t   }else{\\n\\t\\t\\t\\t   n++;\\n\\t\\t\\t\\t   \\n\\t\\t\\t   }\\n \\t\\t   \\n\\t\\t   }\\n\\t  }",
                "solutionTags": [],
                "code": "\\n    public static void sortColors(int[] nums) {\\n\\t\\t  int m=0,n=0,p=nums.length-1;\\n\\t\\t  while(n<=p)\\n\\t\\t   {\\n\\t\\t\\t   if(0==nums[n]){\\n\\t\\t\\t\\t   int temp=0;\\n\\t\\t\\t\\t   temp=nums[n];\\n\\t\\t\\t\\t   nums[n]=nums[m];\\n\\t\\t\\t\\t   nums[m]=temp;\\n\\t\\t\\t\\t   m++;\\n\\t\\t\\t\\t   n++;\\n\\t\\t\\t   }else if(2==nums[n]){\\n\\t\\t\\t\\t   int temp=0;\\n\\t\\t\\t\\t   temp=nums[p];\\n\\t\\t\\t\\t   nums[p]=nums[n];\\n\\t\\t\\t\\t   nums[n]=temp;\\n\\t\\t\\t\\t   p--;\\n\\t\\t\\t   }else{\\n\\t\\t\\t\\t   n++;\\n\\t\\t\\t\\t   \\n\\t\\t\\t   }\\n \\t\\t   \\n\\t\\t   }\\n\\t  }",
                "codeTag": "Unknown"
            },
            {
                "id": 26701,
                "title": "4ms-c-solution-with-one-pass",
                "content": "Maintain the tail index for red region, and head index for the blue region. Scan the whole array, and swap the current element with either red tail or blue head respectively. \\n\\n      class Solution {\\n        public:\\n            void sortColors(vector<int>& nums) {\\n                int tail_red = 0;\\n                int head_blue = nums.size() - 1;\\n                int cur = 0;\\n                while( cur <= head_blue){\\n                    if(nums[cur] == 0){\\n                        swap(nums[tail_red], nums[cur]);\\n                        tail_red ++;\\n                        cur ++;\\n                    }else if (nums[cur] == 2){\\n                        swap(nums[head_blue], nums[cur]);\\n                        head_blue = head_blue - 1;\\n                    }else\\n                        cur ++;\\n                }\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            void sortColors(vector<int>& nums) {\\n                int tail_red = 0;\\n                int head_blue = nums.size() - 1;\\n                int cur = 0;\\n                while( cur <= head_blue){\\n                    if(nums[cur] == 0){\\n                        swap(nums[tail_red], nums[cur]);\\n                        tail_red ++;\\n                        cur ++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3460962,
                "title": "very-easy-solution-explained-beats-100-runtime",
                "content": "# Intuition\\nThis problem can be solved by taking three \\'pointers\\' with counting sort approach. \\n\\n# Approach\\nfirst of all we have to work with 3 types of integer (0,1,2).\\nso i took three variables for those (to find out how many time they appear) a for 0,b for 1 and c for 2.\\nthen by a loop I counted how many time a,b,c appers;\\n\\n\\nfor example our array is [2,0,2,1,1,0]. we got\\na=2 (\\'0\\' came 2 times)\\nb=2\\nc=2\\nthen i just took a loop and fill the array \\nfirst a time with 0,\\nthen b time with 1 \\nand c time with 2\\n\\nin our example \\n2 times 0 =[0,0, , , , ]\\n2 times 1 =[0,0,1,1, , ]\\n2 times 2 =[0,0,1,1,2,2]\\n\\nwe got [0,0,1,1,2,2]\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a =0; int b=0,c=0;int i;\\n        for(i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                a++;\\n            }\\n            if(nums[i]==1){\\n                b++;\\n            }\\n            else c++;\\n            \\n        }\\n        for(i=0;i<nums.size();i++){\\n            if(i<a){\\n                nums[i]=0;\\n            }\\n            else if(i<a+b){\\n                nums[i]=1;\\n            }\\n            else nums[i]=2;\\n        }\\n      \\n    }\\n};\\n```\\n#  Please Upvote :(\\n",
                "solutionTags": [
                    "C++",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a =0; int b=0,c=0;int i;\\n        for(i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                a++;\\n            }\\n            if(nums[i]==1){\\n                b++;\\n            }\\n            else c++;\\n            \\n        }\\n        for(i=0;i<nums.size();i++){\\n            if(i<a){\\n                nums[i]=0;\\n            }\\n            else if(i<a+b){\\n                nums[i]=1;\\n            }\\n            else nums[i]=2;\\n        }\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457424,
                "title": "simple-o-n-time-o-1-space-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int count0 = 0, count1 = 0, count2 = 0;\\n        for(int i=0 ;i<nums.size(); i++)\\n        {\\n            if(nums[i] == 0)\\n            count0++;\\n            else if(nums[i] == 1)\\n            count1++;\\n            else\\n            count2++;\\n        }\\n\\n        for(int i=0 ;i<nums.size(); i++)\\n        {\\n            if(count0-- > 0)\\n            nums[i] = 0;\\n            else if(count1-- > 0)\\n            nums[i] = 1;\\n            else\\n            nums[i] = 2;\\n        }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int count0 = 0, count1 = 0, count2 = 0;\\n        for(int i=0 ;i<nums.size(); i++)\\n        {\\n            if(nums[i] == 0)\\n            count0++;\\n            else if(nums[i] == 1)\\n            count1++;\\n            else\\n            count2++;\\n        }\\n\\n        for(int i=0 ;i<nums.size(); i++)\\n        {\\n            if(count0-- > 0)\\n            nums[i] = 0;\\n            else if(count1-- > 0)\\n            nums[i] = 1;\\n            else\\n            nums[i] = 2;\\n        }\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291249,
                "title": "dutch-national-flag-with-notes-and-approach",
                "content": "# Adding the Notes for the above Question\\n[GitHub Link for the Notes](https://github.com/rizonkumar/LeetCode-Notes/blob/main/75.%20Sort%20Colors.pdf)\\n\\n# Intuition\\nThe given code is an implementation of the Dutch national flag problem, where we need to sort an array containing 0\\'s, 1\\'s, and 2\\'s in linear time and in-place.\\n\\nThe code initializes three pointers: low, mid, and high. The low pointer points to the index before which all elements are 0\\'s, the high pointer points to the index after which all elements are 2\\'s, and the mid pointer points to the current index being processed.\\n\\nThe algorithm then loops through the array until mid and high pointers meet. For each element, it checks its value using a switch statement (or if-else statements in the equivalent version) and moves it to the appropriate position in the array.\\n\\nIf the current element is 0, it swaps it with the element pointed by low and increments both low and mid pointers to move forward in the array. If the current element is 1, it simply increments the mid pointer to move forward. If the current element is 2, it swaps it with the element pointed by high and decrements the high pointer to move backward in the array.\\n\\nAfter the loop, the array is sorted in-place, and all 0\\'s will be before all 1\\'s, which will be before all 2\\'s.\\n\\n# Approach\\n1. Initialize three pointers: low, mid, and high. low points to the index before which all elements are 0\\'s, high points to the index after which all elements are 2\\'s, and mid points to the current index being processed.\\n\\n2. Loop through the array until mid and high pointers meet. For each element, check its value using a switch statement (or if-else statements in the equivalent version).\\n\\n3. If the current element is 0, swap it with the element pointed by low and increment both low and mid pointers to move forward in the array. This ensures that all 0\\'s will be before all 1\\'s and 2\\'s.\\n\\n4. If the current element is 1, simply increment the mid pointer to move forward. Since 1\\'s are already in their correct position in a sorted array, we don\\'t need to perform any additional operation on them.\\n\\n5. If the current element is 2, swap it with the element pointed by high and decrement the high pointer to move backward in the array. This ensures that all 2\\'s will be after all 0\\'s and 1\\'s.\\n\\n6. After the loop, the array is sorted in-place, and all 0\\'s will be before all 1\\'s, which will be before all 2\\'s.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ in One Pass\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using Switch Statement\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low = 0;\\n        int mid = 0;\\n        int high = nums.size() - 1;\\n\\n        while(mid <= high){\\n            switch(nums[mid]){\\n\\n                //if the element is 0\\n                case 0:\\n                    swap(nums[low++], nums[mid++]);\\n                    break;\\n                \\n                // if the element is 1\\n                case 1:\\n                    mid++;\\n                    break;\\n                \\n                // if the element is 2\\n                case 2:\\n                    swap(nums[mid], nums[high--]);\\n                    break;\\n            }\\n        }\\n    }\\n};\\n```\\n# Code using If-else Statement\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low = 0;\\n        int mid = 0;\\n        int high = nums.size() - 1;\\n\\n        while(mid <= high){\\n            if(nums[mid] == 0){\\n                swap(nums[low++], nums[mid++]);\\n            } else if(nums[mid] == 1){\\n                mid++;\\n            } else if(nums[mid] == 2){\\n                swap(nums[mid], nums[high--]);\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low = 0;\\n        int mid = 0;\\n        int high = nums.size() - 1;\\n\\n        while(mid <= high){\\n            switch(nums[mid]){\\n\\n                //if the element is 0\\n                case 0:\\n                    swap(nums[low++], nums[mid++]);\\n                    break;\\n                \\n                // if the element is 1\\n                case 1:\\n                    mid++;\\n                    break;\\n                \\n                // if the element is 2\\n                case 2:\\n                    swap(nums[mid], nums[high--]);\\n                    break;\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low = 0;\\n        int mid = 0;\\n        int high = nums.size() - 1;\\n\\n        while(mid <= high){\\n            if(nums[mid] == 0){\\n                swap(nums[low++], nums[mid++]);\\n            } else if(nums[mid] == 1){\\n                mid++;\\n            } else if(nums[mid] == 2){\\n                swap(nums[mid], nums[high--]);\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147118,
                "title": "c-code-without-using-sort-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int one=0,zero=0,two=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){zero++;}\\n            else if(nums[i]==1){one++;}\\n            else {two++;}\\n\\n        }\\n        nums.clear();\\n        for(int i=0;i<zero;i++){nums.emplace_back(0);}\\n        for(int i=0;i<one;i++){nums.emplace_back(1);}\\n        for(int i=0;i<two;i++){nums.emplace_back(2);}\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int one=0,zero=0,two=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){zero++;}\\n            else if(nums[i]==1){one++;}\\n            else {two++;}\\n\\n        }\\n        nums.clear();\\n        for(int i=0;i<zero;i++){nums.emplace_back(0);}\\n        for(int i=0;i<one;i++){nums.emplace_back(1);}\\n        for(int i=0;i<two;i++){nums.emplace_back(2);}\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085526,
                "title": "1-ms-easy-solution-java-easy-to-understand-for-beginner",
                "content": "```\\n//----------------- Don\\'t Forget to Upvote ----------------\\n```\\n# Code\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int x = 0;\\n        for(int i = 0 ; i<nums.length ; i++){\\n            if (nums[i] == 0){\\n                int temp = nums[x];\\n                nums[x] = nums[i];\\n                nums[i] = temp;\\n                x++;\\n            }\\n        }\\n        for(int i = x ; i<nums.length ; i++){\\n            if (nums[i] == 1){\\n                int temp = nums[x];\\n                nums[x] = nums[i];\\n                nums[i] = temp;\\n                x++;\\n            }\\n        }    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//----------------- Don\\'t Forget to Upvote ----------------\\n```\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int x = 0;\\n        for(int i = 0 ; i<nums.length ; i++){\\n            if (nums[i] == 0){\\n                int temp = nums[x];\\n                nums[x] = nums[i];\\n                nums[i] = temp;\\n                x++;\\n            }\\n        }\\n        for(int i = x ; i<nums.length ; i++){\\n            if (nums[i] == 1){\\n                int temp = nums[x];\\n                nums[x] = nums[i];\\n                nums[i] = temp;\\n                x++;\\n            }\\n        }    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080752,
                "title": "best-o-n-solution",
                "content": "\\n\\n# Approach\\nDutch National Flag Algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = 0, mid = 0, high = n - 1;\\n        while (mid <= high) {\\n            if (nums[mid] == 0) {\\n                swap(nums[low], nums[mid]);\\n                low++;\\n                mid++;\\n            } else if (nums[mid] == 1) {\\n                mid++;\\n            } else if (nums[mid] == 2) {\\n                swap(nums[high], nums[mid]);\\n                high--;\\n            }    \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = 0, mid = 0, high = n - 1;\\n        while (mid <= high) {\\n            if (nums[mid] == 0) {\\n                swap(nums[low], nums[mid]);\\n                low++;\\n                mid++;\\n            } else if (nums[mid] == 1) {\\n                mid++;\\n            } else if (nums[mid] == 2) {\\n                swap(nums[high], nums[mid]);\\n                high--;\\n            }    \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053568,
                "title": "c-explained-with-bonus-one-liner",
                "content": "\\n\\n# Approach\\n- Consider three pointers low = 0, mid = 0, high = nums.size() - 1\\n\\n- The algorithm ensures that at any point, every element **before low is 0**, every element **after high is 2**, every element in **between are either 0, 1 or 2** i.e. unprocessed.\\n- We\\'ll use mid pointer to traverse and check the array elements i.e. while(mid <= high). Three cases are possible:\\n  - nums[mid] == 0 In this case swap(nums[low], nums[mid]) and increment both low and mid pointer i.e. low++ mid++\\n  - nums[mid] == 1 In this case mid++\\n  - nums[mid] == 2 In this case swap(nums[mid], nums[high]) and decrement high pointer i.e. high--\\n\\n\\n\\n# Code\\n```\\n    void sortColors(vector<int>& nums) {\\n        \\n        // initialize variables:\\n        int low = 0, mid = 0, high = nums.size() - 1;\\n        \\n        // logic:\\n        while(mid <= high)\\n        {\\n            switch(nums[mid])\\n            {\\n                case 0: swap(nums[low++], nums[mid++]); break;\\n                \\n                case 1: mid++; break;\\n                \\n                case 2: swap(nums[mid], nums[high--]); break;\\n            }\\n        }\\n    }\\n```\\n\\n\\n\\nBonus - One-Liner\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    void sortColors(vector<int>& nums) {\\n        \\n        // initialize variables:\\n        int low = 0, mid = 0, high = nums.size() - 1;\\n        \\n        // logic:\\n        while(mid <= high)\\n        {\\n            switch(nums[mid])\\n            {\\n                case 0: swap(nums[low++], nums[mid++]); break;\\n                \\n                case 1: mid++; break;\\n                \\n                case 2: swap(nums[mid], nums[high--]); break;\\n            }\\n        }\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848411,
                "title": "java-quick-partition-easy-to-understand",
                "content": "- Count the number of balls for each color\\n- Use the given array and place them `red (0)` `white(1)` `blue(2)` order.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\t\\n        int red = 0, white = 0, blue = 0;\\n\\t\\tfor (int i : nums) {\\n\\t\\t\\tif (i == 0) { red++;}\\n\\t\\t\\tif (i == 1) { white++;}\\n\\t\\t\\tif (i == 2) { blue++;}\\n\\t\\t}\\n        int i = 0;\\n\\t\\twhile (red-- > 0) {\\tnums[i++] = 0; }\\n\\t\\twhile (white-- > 0) { nums[i++] = 1;}\\n\\t\\twhile (blue-- > 0) { nums[i++] = 2;}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\t\\n        int red = 0, white = 0, blue = 0;\\n\\t\\tfor (int i : nums) {\\n\\t\\t\\tif (i == 0) { red++;}\\n\\t\\t\\tif (i == 1) { white++;}\\n\\t\\t\\tif (i == 2) { blue++;}\\n\\t\\t}\\n        int i = 0;\\n\\t\\twhile (red-- > 0) {\\tnums[i++] = 0; }\\n\\t\\twhile (white-- > 0) { nums[i++] = 1;}\\n\\t\\twhile (blue-- > 0) { nums[i++] = 2;}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830083,
                "title": "python-solution-using-pointers-explained",
                "content": "```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        l=0 #left pointer\\n        mid=0 #traverse from left\\n        r=len(nums)-1 #right pinter\\n        while mid<=r:\\n            if nums[mid]==0: #if found 0 put it at first of nums, so swap from left pointer\\n                nums[mid],nums[l]=nums[l],nums[mid]\\n                #after swapping move to increment indeces\\n                mid+=1 \\n                l+=1\\n                \\n            #if found 1 leave it as it is (should be bw 0 and 2)\\n            elif nums[mid]==1: \\n                mid+=1\\n                \\n            #if found 2, so swap from right pointer\\n            else: \\n                nums[mid],nums[r]=nums[r],nums[mid]\\n                r-=1 #move the right pointer\\n                \\n            \\n```\\n**PLEASE UPVOTE IF YOU FOUND THE SOLUTION HELPFUL**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        l=0 #left pointer\\n        mid=0 #traverse from left\\n        r=len(nums)-1 #right pinter\\n        while mid<=r:\\n            if nums[mid]==0: #if found 0 put it at first of nums, so swap from left pointer\\n                nums[mid],nums[l]=nums[l],nums[mid]\\n                #after swapping move to increment indeces\\n                mid+=1 \\n                l+=1\\n                \\n            #if found 1 leave it as it is (should be bw 0 and 2)\\n            elif nums[mid]==1: \\n                mid+=1\\n                \\n            #if found 2, so swap from right pointer\\n            else: \\n                nums[mid],nums[r]=nums[r],nums[mid]\\n                r-=1 #move the right pointer\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753230,
                "title": "o-n-with-count-sort",
                "content": "```\\n\\tdef sortColors(self, nums: List[int]) -> None:\\n        counts = [0, 0, 0]\\n        for i in nums:\\n            counts[i] += 1\\n        \\n        i = 0\\n        for k in range(3):\\n            while counts[k] > 0:\\n                nums[i] = k\\n                i += 1\\n                counts[k] -= 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\tdef sortColors(self, nums: List[int]) -> None:\\n        counts = [0, 0, 0]\\n        for i in nums:\\n            counts[i] += 1\\n        \\n        i = 0\\n        for k in range(3):\\n            while counts[k] > 0:\\n                nums[i] = k\\n                i += 1\\n                counts[k] -= 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2184767,
                "title": "easy-to-understand-and-100-fast-solution",
                "content": "the main aim here is to put all 2,s at the last of the array and all 0\\'s at the first...so start iterating in the array and wherever you find 2 send it to the last and as you put 2 at the last then decrease the last index by 1 and similarly when we found zero ,put this at starting of index and then increase there index by 1...by doing so we will be able to sort 0,1,2 without using sort function...\\n\\n\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        \\n        int k=0,j=nums.size()-1;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==2 && i<j)\\n            {\\n                swap(nums[i],nums[j]);\\n                j--;\\n                i--;\\n             }\\n            else if(nums[i]==0)\\n            {\\n                swap(nums[k],nums[i]);\\n                k++;\\n            }\\n            \\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        \\n        int k=0,j=nums.size()-1;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==2 && i<j)\\n            {\\n                swap(nums[i],nums[j]);\\n                j--;\\n                i--;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1796797,
                "title": "python-3-25ms-o-n-count-0s-1s-solution-faster-than-95",
                "content": "```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a,b=nums.count(0),nums.count(1)\\n        for i in range(len(nums)):\\n            if a!=0:\\n                nums[i]=0\\n                a-=1\\n            elif b!=0:\\n                nums[i]=1\\n                b-=1\\n            else:\\n                nums[i]=2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        a,b=nums.count(0),nums.count(1)\\n        for i in range(len(nums)):\\n            if a!=0:\\n                nums[i]=0\\n                a-=1\\n            elif b!=0:\\n                nums[i]=1\\n                b-=1\\n            else:\\n                nums[i]=2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543602,
                "title": "c-python-java-o-n-and-o-n-n-approach-easy-and-clean",
                "content": "**SOLUTIONS** *[Github Repo Link Here](https://github.com/bhaumikmaan/Competitve-Programming-Solutions)*\\n\\n**O(N)** 100% Faster\\n<iframe src=\"https://leetcode.com/playground/J9eKUETX/shared\" frameBorder=\"0\" width=\"500\" height=\"450\"></iframe>\\n\\n**O(N*N)**\\n<iframe src=\"https://leetcode.com/playground/9ZSpPUVn/shared\" frameBorder=\"0\" width=\"500\" height=\"350\"></iframe>\\n\\nUpvote if you found this helpful <3",
                "solutionTags": [],
                "code": "**SOLUTIONS** *[Github Repo Link Here](https://github.com/bhaumikmaan/Competitve-Programming-Solutions)*\\n\\n**O(N)** 100% Faster\\n<iframe src=\"https://leetcode.com/playground/J9eKUETX/shared\" frameBorder=\"0\" width=\"500\" height=\"450\"></iframe>\\n\\n**O(N*N)**\\n<iframe src=\"https://leetcode.com/playground/9ZSpPUVn/shared\" frameBorder=\"0\" width=\"500\" height=\"350\"></iframe>\\n\\nUpvote if you found this helpful <3",
                "codeTag": "Unknown"
            },
            {
                "id": 1543311,
                "title": "dutch-national-flag-algorithm-to-sort-in-one-pass-no-extra-space",
                "content": "1. This algorithm uses 3 pointers : **low** , **mid** and **high**.\\n2. Initially low and mid pointers are placed at starting index of the array whereas high is placed at the end of the array.\\n3. This algorithm is based on the fact that all elements to the left of low are 0 and all elements to the right of high are 2.\\n4. We will use mid pointer to traverse over the array (till it crosses high pointer).\\n5. Their are 3 possibilities :\\n\\t\\t **nums[mid] = 0**  :   We will swap values at index low and mid. Also will increment both low                                                    and mid pointer.\\n\\t\\t **nums[mid] = 1**  : just move mid pointer by 1.\\n\\t\\t**nums[mid] = 2**   : We will swap values at high and mid. Also decrement high pointer.\\n\\t\\t\\n\\t\\t\\n```\\nvoid sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = 0;\\n        int mid = 0;\\n        int high = n-1;\\n        \\n        while(mid <= high){\\n            if(nums[mid] == 0){\\n                swap(nums[low] , nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            \\n            else if(nums[mid] == 1){\\n                mid++;\\n            }\\n            else{\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n```\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)",
                "solutionTags": [],
                "code": "```\\nvoid sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = 0;\\n        int mid = 0;\\n        int high = n-1;\\n        \\n        while(mid <= high){\\n            if(nums[mid] == 0){\\n                swap(nums[low] , nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            \\n            else if(nums[mid] == 1){\\n                mid++;\\n            }\\n            else{\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368805,
                "title": "very-simple-python-o-n-time-o-1-space",
                "content": "```\\ndef sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        p = 0\\n        for n in [0,1,2]: # Integers are fixed so we are allowed\\n            for i in range(len(nums)):\\n                if nums[i] == n:\\n                    nums[p], nums[i] = nums[i], nums[p]\\n                    p += 1\\n```\\n\\nSpace is O(3) -> O(1)\\nTime is O(3 * n) -> O(n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        p = 0\\n        for n in [0,1,2]: # Integers are fixed so we are allowed\\n            for i in range(len(nums)):\\n                if nums[i] == n:\\n                    nums[p], nums[i] = nums[i], nums[p]\\n                    p += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1137080,
                "title": "sort-0-s-1-s-and-2-s",
                "content": "**Simplest and efficient Java Code for Dutch National Flag Problem..**\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low=0;\\n        int high=nums.length-1;\\n        int mid=0;\\n        int temp;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                temp=nums[mid];\\n                nums[mid]=nums[low];\\n                nums[low]=temp;\\n                low++;\\n                mid++;\\n            }else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }else if(nums[mid]==2)\\n            {\\n                temp=nums[high];\\n                nums[high]=nums[mid];\\n                nums[mid]=temp;\\n                high--;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void sortColors(int[] nums) {\\n        int low=0;\\n        int high=nums.length-1;\\n        int mid=0;\\n        int temp;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                temp=nums[mid];\\n                nums[mid]=nums[low];\\n                nums[low]=temp;\\n                low++;\\n                mid++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1049578,
                "title": "python-3-dutch-national-flag-solution",
                "content": "Most optimal approach to solve this problem is Dutch National Flag Solution \\n\\nThis will help us to solve this problem in O(n) time and O(1) space complexity.\\n\\nThe trick is to use three pointers Low, Mid and High and idea is to move 0\\'s to left and 2\\'s to right of the array \\n\\nStep 1. Initialize value for `Low, mid =0,0` , `High=Len(nums) - 1` \\nStep 2. \\n\\t\\tCase 1. \\n\\t\\t\\tWhenever `nums[Mid]` is 0 we should swap nums[Low] and nums[mid] and increment both pointers Low++, Mid++\\n\\t\\tCase 2.\\n\\t\\t\\tWhenever `nums[mid]` is 2 we should swap nums[High] with nums[Mid] and decrement `High --`\\n\\t\\tCase 3:\\n\\t\\t\\tIf `nums[mid]` is 1 just increment mid++\\n\\t\\t\\t\\nSample Solution: \\n\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        low = 0\\n        high = len(nums) - 1\\n        mid = 0\\n        \\n        while mid <= high:\\n            if nums[mid] == 0:\\n                nums[low], nums[mid] = nums[mid], nums[low]\\n                low += 1\\n                mid+=1\\n            elif nums[mid] == 2:\\n                nums[high], nums[mid] = nums[mid], nums[high]\\n                high -= 1\\n            else:\\n                mid += 1\\n        \\n                \\n        \\n        \\n                \\n        \\n\\n",
                "solutionTags": [],
                "code": "Most optimal approach to solve this problem is Dutch National Flag Solution \\n\\nThis will help us to solve this problem in O(n) time and O(1) space complexity.\\n\\nThe trick is to use three pointers Low, Mid and High and idea is to move 0\\'s to left and 2\\'s to right of the array \\n\\nStep 1. Initialize value for `Low, mid =0,0` , `High=Len(nums) - 1` \\nStep 2. \\n\\t\\tCase 1. \\n\\t\\t\\tWhenever `nums[Mid]` is 0 we should swap nums[Low] and nums[mid] and increment both pointers Low++, Mid++\\n\\t\\tCase 2.\\n\\t\\t\\tWhenever `nums[mid]` is 2 we should swap nums[High] with nums[Mid] and decrement `High --`\\n\\t\\tCase 3:\\n\\t\\t\\tIf `nums[mid]` is 1 just increment mid++\\n\\t\\t\\t\\nSample Solution: \\n\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        low = 0\\n        high = len(nums) - 1\\n        mid = 0\\n        \\n        while mid <= high:\\n            if nums[mid] == 0:\\n                nums[low], nums[mid] = nums[mid], nums[low]\\n                low += 1\\n                mid+=1\\n            elif nums[mid] == 2:\\n                nums[high], nums[mid] = nums[mid], nums[high]\\n                high -= 1\\n            else:\\n                mid += 1\\n        \\n                \\n        \\n        \\n                \\n        \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 767480,
                "title": "o-n-c-solution",
                "content": "```\\nvoid sortColors(int* nums, int numsSize){\\n    int two_ptr = numsSize -1;\\n    int zero_ptr = 0;\\n    int one_ptr = 0;\\n    while (one_ptr <= two_ptr)\\n    {\\n        if (nums[one_ptr] == 0)\\n        {\\n            int save = nums[zero_ptr];\\n            nums[zero_ptr] = nums[one_ptr];\\n            nums[one_ptr] = save;\\n            one_ptr++; zero_ptr++;\\n        }\\n        else if (nums[one_ptr] == 1)\\n        {\\n            one_ptr++;\\n        }\\n        else\\n        {\\n            int save = nums[two_ptr];\\n            nums[two_ptr] = nums[one_ptr];\\n            nums[one_ptr] = save;\\n            two_ptr--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid sortColors(int* nums, int numsSize){\\n    int two_ptr = numsSize -1;\\n    int zero_ptr = 0;\\n    int one_ptr = 0;\\n    while (one_ptr <= two_ptr)\\n    {\\n        if (nums[one_ptr] == 0)\\n        {\\n            int save = nums[zero_ptr];\\n            nums[zero_ptr] = nums[one_ptr];\\n            nums[one_ptr] = save;\\n            one_ptr++; zero_ptr++;\\n        }\\n        else if (nums[one_ptr] == 1)\\n        {\\n            one_ptr++;\\n        }\\n        else\\n        {\\n            int save = nums[two_ptr];\\n            nums[two_ptr] = nums[one_ptr];\\n            nums[one_ptr] = save;\\n            two_ptr--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 416304,
                "title": "c-one-pass-beats-100-on-everything-with-explanation",
                "content": "```\\n// Usually the more variables you reserve for yourself with these types of problems \\n// the more you can work with and the more agile you can become.\\n    void sortColors(vector<int>& nums) {\\n        int i = 0, j = nums.size() - 1, x = 0; \\n        while (x <= j) {\\n            if (nums[x] == 0) { // Meet a 0? Send it back !\\n                swap(nums[x++], nums[i++]);\\n            } else if (nums[x] == 2) { // Meet a 2? Send it forward, but don\\'t move forward yourself,\\n                swap(nums[j--], nums[x]); // You might have just swapped a two with a 0.\\n            } else { // In that case, you\\'d need to swap it back. If I wrote nums[x++], I would have missed it!\\n                x++; // Keep walking, x.\\n            }\\n        }\\n        return;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Usually the more variables you reserve for yourself with these types of problems \\n// the more you can work with and the more agile you can become.\\n    void sortColors(vector<int>& nums) {\\n        int i = 0, j = nums.size() - 1, x = 0; \\n        while (x <= j) {\\n            if (nums[x] == 0) { // Meet a 0? Send it back !\\n                swap(nums[x++], nums[i++]);\\n            } else if (nums[x] == 2) { // Meet a 2? Send it forward, but don\\'t move forward yourself,\\n                swap(nums[j--], nums[x]); // You might have just swapped a two with a 0.\\n            } else { // In that case, you\\'d need to swap it back. If I wrote nums[x++], I would have missed it!\\n                x++; // Keep walking, x.\\n            }\\n        }\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26690,
                "title": "java-single-pass",
                "content": "Use two pointers. One for the place to insert 0 ***(zero)*** and another for the place to insert 2 ***(two)***. \\n\\nIterate through this array, if 0 is found, swap its value with ***zero***. if 2 is found, swap its value with ***two***. If 1 is found, go to the next position until it exceeds ***two*** or fall behind by ***zero***. \\n\\n    public class Solution {\\n        public void sortColors(int[] nums) {\\n            if (nums == null || nums.length == 0) return;\\n            int zero = 0, count = 0, two = nums.length - 1;\\n            while (count <= two && count >= zero) {\\n                while (count <= two && count >= zero) {\\n                    if (nums[count] == 0) {\\n                        swap(nums, count, zero);\\n                        zero++;\\n                    }\\n                    if (nums[count] == 2) {\\n                        swap(nums, count, two);\\n                        two--;\\n                    }\\n                    if (nums[count] == 1) break;\\n                }\\n                count++;\\n            }\\n        }\\n        \\n        private void swap(int[] nums, int i, int j) {\\n            int temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void sortColors(int[] nums) {\\n            if (nums == null || nums.length == 0) return;\\n            int zero = 0, count = 0, two = nums.length - 1;\\n            while (count <= two && count >= zero) {\\n                while (count <= two && count >= zero) {\\n                    if (nums[count] == 0) {\\n                        swap(nums, count, zero);\\n                        zero++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3364495,
                "title": "easiest-python-solution-using-just-three-pointers-time-complexity-o-n",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def sortColors(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        r,w,b=0,0,len(nums)-1\\n        while w<=b:\\n            if nums[w]==0:\\n                nums[r],nums[w]=nums[w],nums[r]\\n                r+=1\\n                w+=1\\n            elif nums[w]==1:\\n                w+=1\\n            else:\\n                nums[b],nums[w]=nums[w],nums[b]\\n                b-=1\\n            print(nums)\\n        return nums\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortColors(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        r,w,b=0,0,len(nums)-1\\n        while w<=b:\\n            if nums[w]==0:\\n                nums[r],nums[w]=nums[w],nums[r]\\n                r+=1\\n                w+=1\\n            elif nums[w]==1:\\n                w+=1\\n            else:\\n                nums[b],nums[w]=nums[w],nums[b]\\n                b-=1\\n            print(nums)\\n        return nums\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241599,
                "title": "c-solution-easy-and-simple-explanation-0ms-runtime-o-n-solution-o-1-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are two approaches :  \\n**APPROACH 1:**\\n1. Count the number of zeros, ones and twos as it is already gievn that array contains only these three elements.\\n2. First fill the zeros then ones and at last twos in the array.\\n\\n\\n**APPROACH 2:**\\n This is a three pointer approach \\n1. First pointer is pointing to the index where the next zero is going to be stored.\\n2. Second pointer is pointing to the index where the next one is going to be stored.\\n3. On encountering the zeros and ones swap these elements with the respected pointers which points to their exact positions.\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        // Approach 1\\n        // int z = 0, o = 0, t = 0;\\n        // for (auto i : nums){\\n        //     if (i == 0) z++;\\n        //     else if (i == 1) o++;\\n        //     else t++;\\n        // }\\n        // int i = 0;\\n        // while(z--){\\n        //     nums[i]= 0; i++;\\n        // }\\n        // while(o--){\\n        //     nums[i] = 1; i++;\\n        // }\\n        // while(t--){\\n        //     nums[i] = 2; i++;\\n        // }\\n\\n        // three ponter approach \\n        int n = nums.size(),k = 0, j = 0;\\n        for (int i = 0 ; i < n ; i++){\\n            if (nums[i] == 0){\\n                swap(nums[i],nums[j]);\\n                swap(nums[j],nums[k]);\\n                k++;j++;\\n            }\\n            else if(nums[i] == 1){\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        // Approach 1\\n        // int z = 0, o = 0, t = 0;\\n        // for (auto i : nums){\\n        //     if (i == 0) z++;\\n        //     else if (i == 1) o++;\\n        //     else t++;\\n        // }\\n        // int i = 0;\\n        // while(z--){\\n        //     nums[i]= 0; i++;\\n        // }\\n        // while(o--){\\n        //     nums[i] = 1; i++;\\n        // }\\n        // while(t--){\\n        //     nums[i] = 2; i++;\\n        // }\\n\\n        // three ponter approach \\n        int n = nums.size(),k = 0, j = 0;\\n        for (int i = 0 ; i < n ; i++){\\n            if (nums[i] == 0){\\n                swap(nums[i],nums[j]);\\n                swap(nums[j],nums[k]);\\n                k++;j++;\\n            }\\n            else if(nums[i] == 1){\\n                swap(nums[i], nums[j]);\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200051,
                "title": "c-python-100-faster-using-pointers-o-n",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ [0]\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        for(int i = 0; i <= right; i++) {\\n            while(nums[i] == 2 && i < right) {\\n                swap(nums[i], nums[right--]);\\n            }\\n            while(nums[i] == 0 && i > left) {\\n                swap(nums[i], nums[left++]);\\n            }\\n        }\\n    }\\n};\\n```\\n``` Python [1]\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        left = i = 0\\n        right = len(nums) - 1\\n        while i <= right :\\n            while(nums[i] == 2 and i < right):\\n                nums[i], nums[right] = nums[right], nums[i]\\n                right -= 1\\n            while(nums[i] == 0 and i > left):\\n                nums[i], nums[left] = nums[left], nums[i]\\n                left +=1\\n            i += 1\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` C++ [0]\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        for(int i = 0; i <= right; i++) {\\n            while(nums[i] == 2 && i < right) {\\n                swap(nums[i], nums[right--]);\\n            }\\n            while(nums[i] == 0 && i > left) {\\n                swap(nums[i], nums[left++]);\\n            }\\n        }\\n    }\\n};\\n```\n``` Python [1]\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        left = i = 0\\n        right = len(nums) - 1\\n        while i <= right :\\n            while(nums[i] == 2 and i < right):\\n                nums[i], nums[right] = nums[right], nums[i]\\n                right -= 1\\n            while(nums[i] == 0 and i > left):\\n                nums[i], nums[left] = nums[left], nums[i]\\n                left +=1\\n            i += 1\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595038,
                "title": "java-space-complexity-o-1-time-complexity-o-n",
                "content": "Hi Family,\\n\\nI put the proper comment in the code for your understanding\\nIf you get the code then Please Please Upvote the Solution\\n\\n```\\n\\tpublic void sortColors(int[] nums) {\\n        int zero = 0;\\n        int one = 0;\\n        int two = 0;\\n        // take the frequency of 0\\'s,  1\\'s,  2\\'s\\n        for (int i=0;i<nums.length;i++){\\n            if (nums[i] == 0) zero++;\\n            if (nums[i] == 1) one++;\\n            if (nums[i] == 2) two++;\\n        }\\n        \\n        // put the zero,one,two in the array one - one\\n        \\n        int index = 0;\\n        while (zero-- > 0) nums[index++] = 0;\\n        while (one-- > 0) nums[index++] = 1;\\n        while (two-- > 0) nums[index++] = 2;\\n    }\\n```\\nThanks!!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic void sortColors(int[] nums) {\\n        int zero = 0;\\n        int one = 0;\\n        int two = 0;\\n        // take the frequency of 0\\'s,  1\\'s,  2\\'s\\n        for (int i=0;i<nums.length;i++){\\n            if (nums[i] == 0) zero++;\\n            if (nums[i] == 1) one++;\\n            if (nums[i] == 2) two++;\\n        }\\n        \\n        // put the zero,one,two in the array one - one\\n        \\n        int index = 0;\\n        while (zero-- > 0) nums[index++] = 0;\\n        while (one-- > 0) nums[index++] = 1;\\n        while (two-- > 0) nums[index++] = 2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2264649,
                "title": "java-o-n-dutch-national-flag-algorithm",
                "content": "**If you liked my solution , upvote is highly appreciate\\nIf you have any doubts or suggestions feel free to comment **\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0;\\n        int mid = 0;\\n        int high = nums.length - 1;\\n        while(mid <= high){\\n            if(nums[mid] == 0){\\n                int temp = nums[mid];\\n                nums[mid] = nums[low];\\n                nums[low] = temp;\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid] == 1){\\n                mid++;\\n            }\\n            else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--;\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0;\\n        int mid = 0;\\n        int high = nums.length - 1;\\n        while(mid <= high){\\n            if(nums[mid] == 0){\\n                int temp = nums[mid];\\n                nums[mid] = nums[low];\\n                nums[low] = temp;\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid] == 1){\\n                mid++;\\n            }\\n            else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186646,
                "title": "go-o-n-count-the-number-of-zero-one-two",
                "content": "```\\nfunc sortColors(nums []int)  {\\n    nZeros, nOnes, nTwos := 0, 0, 0\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] == 0 {\\n            nZeros++\\n        } else if nums[i] == 1{\\n            nOnes++\\n        } else {\\n            nTwos++\\n        }\\n    }\\n    \\n    i := 0\\n\\n    for nZeros > 0 {\\n        nums[i] = 0\\n        nZeros--\\n        i++\\n    }\\n    \\n    for nOnes > 0 {\\n        nums[i] = 1\\n        nOnes--\\n        i++\\n    }\\n    \\n    for nTwos > 0 {\\n        nums[i] = 2\\n        nTwos--\\n        i++\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc sortColors(nums []int)  {\\n    nZeros, nOnes, nTwos := 0, 0, 0\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] == 0 {\\n            nZeros++\\n        } else if nums[i] == 1{\\n            nOnes++\\n        } else {\\n            nTwos++\\n        }\\n    }\\n    \\n    i := 0\\n\\n    for nZeros > 0 {\\n        nums[i] = 0\\n        nZeros--\\n        i++\\n    }\\n    \\n    for nOnes > 0 {\\n        nums[i] = 1\\n        nOnes--\\n        i++\\n    }\\n    \\n    for nTwos > 0 {\\n        nums[i] = 2\\n        nTwos--\\n        i++\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141756,
                "title": "c-average-runtime-o-1-memory-two-different-codes",
                "content": "```\\nvoid sortColors(vector<int>& nums) {\\n        int n = nums.size(),zero=0,one=0,two=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0)\\n                zero++;\\n            else if(nums[i]==1)\\n                one++;\\n            else \\n                two++;\\n        }\\n        nums.clear();\\n        // while(zero--)\\n        //     nums.push_back(0);\\n        // while(one--)\\n        //     nums.push_back(1);\\n        // while(two--)\\n        //     nums.push_back(2);\\n        for(int i=0;i<n;i++){\\n            if(zero!=0)\\n                nums.push_back(0),zero--;\\n            else if(one!=0)\\n                nums.push_back(1),one--;\\n            else \\n                nums.push_back(2),two--;\\n        }\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid sortColors(vector<int>& nums) {\\n        int n = nums.size(),zero=0,one=0,two=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0)\\n                zero++;\\n            else if(nums[i]==1)\\n                one++;\\n            else \\n                two++;\\n        }\\n        nums.clear();\\n        // while(zero--)\\n        //     nums.push_back(0);\\n        // while(one--)\\n        //     nums.push_back(1);\\n        // while(two--)\\n        //     nums.push_back(2);\\n        for(int i=0;i<n;i++){\\n            if(zero!=0)\\n                nums.push_back(0),zero--;\\n            else if(one!=0)\\n                nums.push_back(1),one--;\\n            else \\n                nums.push_back(2),two--;\\n        }\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906342,
                "title": "cpp-100-faster",
                "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n    \\n        int low=0;\\n        int mid=0;\\n        int high=n-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else if(nums[mid]==2)\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n    \\n        int low=0;\\n        int mid=0;\\n        int high=n-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1790665,
                "title": "java-100-o-n-solution-3-pointers",
                "content": "//Basically keep putting 2s in the end and 0s in the first position and fixing their positions, then moving forward.\\n//Quite difficult to come up with on the spot, in my opinion, unless you have seen the implementation before. But geniuses do exist. Good luck!\\n\\n//Time complexity : O(N), since it\\'s one pass along the array of length N.\\n//Space complexity : O(1), since it\\'s a constant space solution.\\n\\n//Visualization: (p0 is low & p2 is high)\\n___________________________________________________________________________________________________________________________________\\n![image](https://assets.leetcode.com/users/images/38eeb90d-75d8-4bc7-baa1-2ed5d0ac2805_1645507859.439233.png)\\n![image](https://assets.leetcode.com/users/images/c3c645a2-911c-4cc5-bb57-aa4f81c90e41_1645508098.4051604.png)\\n![image](https://assets.leetcode.com/users/images/4e7e70f2-62d1-4edf-8fc7-17a3000b35a2_1645508365.6535902.png)\\n___________________________________________________________________________________________________________________________________\\n\\n\\n\\n\\n\\nclass Solution {\\n    \\n    public void sortColors(int[] nums) \\n    {\\n        int low=0, high=nums.length-1, cur=0;\\n        while(cur<=high)\\n        {\\n            if(nums[cur]==2)\\n            {\\n                swap(nums,cur,high);\\n                high--;\\n            }\\n            else if(nums[cur]==0)\\n            {\\n                swap(nums,cur,low);\\n                cur++;\\n                low++;\\n            }\\n            else if(nums[cur]==1)\\n                cur++;\\n        }        \\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public void sortColors(int[] nums) \\n    {\\n        int low=0, high=nums.length-1, cur=0;\\n        while(cur<=high)\\n        {\\n            if(nums[cur]==2)\\n            {\\n                swap(nums,cur,high);\\n                high--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1722783,
                "title": "java-intuitive-and-easy-to-understand-one-pass",
                "content": "The idea is to maintain count of zeros, ones and twos seen so far while iterating through an array and then handling special cases of these counts for the current element in the iteration.\\n\\nNOTE: If you found this post helpful then please do upvote! \\n\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n\\t\\t// zeros , ones, twos maintains the count of 0s, 1s and 2s seen so far\\n        int zeros=0,ones=0,twos=0,n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                nums[zeros++]=0;\\n\\t\\t\\t\\t//no ones seen so far - only 0s and 2s are present - 00..22..\\n                if(ones==0 && twos!=0){\\n                    nums[i]=2;\\n                }\\n\\t\\t\\t\\t//no twos seen so far - only 0s and 1s are present - 00..111..\\n                else if(ones!=0 && twos==0){\\n                       nums[i]=1; \\n                }\\n\\t\\t\\t\\t// 0s , 1s, 2s are present - 00..111..22..\\n                else if(ones!=0 && twos!=0){\\n                    nums[zeros+ones-1]=1;\\n                    nums[i]=2;\\n                }\\n            }\\n            else if(nums[i]==1){\\n                ones++;\\n\\t\\t\\t\\t//no twos seen so far - only 0s and 1s are present - 00..111..\\n                if(twos==0){\\n                   nums[i]=1; \\n                }\\n\\t\\t\\t\\t// 0s , 1s, 2s are present - 00..111..22..\\n                else{\\n                    nums[zeros+ones-1]=1;\\n                    nums[i]=2;\\n                }\\n            }\\n            else{\\n                twos++;\\n            }    \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n\\t\\t// zeros , ones, twos maintains the count of 0s, 1s and 2s seen so far\\n        int zeros=0,ones=0,twos=0,n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                nums[zeros++]=0;\\n\\t\\t\\t\\t//no ones seen so far - only 0s and 2s are present - 00..22..\\n                if(ones==0 && twos!=0){\\n                    nums[i]=2;\\n                }\\n\\t\\t\\t\\t//no twos seen so far - only 0s and 1s are present - 00..111..\\n                else if(ones!=0 && twos==0){\\n                       nums[i]=1; \\n                }\\n\\t\\t\\t\\t// 0s , 1s, 2s are present - 00..111..22..\\n                else if(ones!=0 && twos!=0){\\n                    nums[zeros+ones-1]=1;\\n                    nums[i]=2;\\n                }\\n            }\\n            else if(nums[i]==1){\\n                ones++;\\n\\t\\t\\t\\t//no twos seen so far - only 0s and 1s are present - 00..111..\\n                if(twos==0){\\n                   nums[i]=1; \\n                }\\n\\t\\t\\t\\t// 0s , 1s, 2s are present - 00..111..22..\\n                else{\\n                    nums[zeros+ones-1]=1;\\n                    nums[i]=2;\\n                }\\n            }\\n            else{\\n                twos++;\\n            }    \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365429,
                "title": "simple-o-1-space-and-o-n-time-complexity-javascript",
                "content": "```/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar sortColors = function(nums) {\\n    let low= 0, high= nums.length- 1, mid= 0, temp= 0;\\n    \\n    while(mid <= high) {\\n        if(nums[mid] === 0) {\\n            // swap mid and low pointers values\\n            temp= nums[low];\\n            nums[low] = nums[mid];\\n            nums[mid]= temp;\\n            \\n            low++;\\n            mid++;\\n        } else if(nums[mid] === 2) {\\n            // swap mid and high pointers values\\n            temp= nums[high];\\n            nums[high]= nums[mid];\\n            nums[mid]= temp;\\n            \\n            high--;\\n        } else {\\n            mid++\\n        }\\n    }\\n    \\n    return nums;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar sortColors = function(nums) {\\n    let low= 0, high= nums.length- 1, mid= 0, temp= 0;\\n    \\n    while(mid <= high) {\\n        if(nums[mid] === 0) {\\n            // swap mid and low pointers values\\n            temp= nums[low];\\n            nums[low] = nums[mid];\\n            nums[mid]= temp;\\n            \\n            low++;\\n            mid++;\\n        } else if(nums[mid] === 2) {\\n            // swap mid and high pointers values\\n            temp= nums[high];\\n            nums[high]= nums[mid];\\n            nums[mid]= temp;\\n            \\n            high--;\\n        } else {\\n            mid++\\n        }\\n    }\\n    \\n    return nums;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1013892,
                "title": "kotlin-minimalistic-and-beautiful",
                "content": "```\\nclass Solution {\\n    fun sortColors(nums: IntArray): Unit {\\n        val count = IntArray(3)\\n        nums.forEach { count[it]++ }\\n        var k = 0\\n        count.forEachIndexed { i, n ->\\n            repeat(n) { nums[k++] = i }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun sortColors(nums: IntArray): Unit {\\n        val count = IntArray(3)\\n        nums.forEach { count[it]++ }\\n        var k = 0\\n        count.forEachIndexed { i, n ->\\n            repeat(n) { nums[k++] = i }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971167,
                "title": "single-pass-o-n-time-o-1-space-python3",
                "content": "```\\nclass Solution:\\n    def sortColors(self, a: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        i = 0\\n        j = 0\\n        n = len(a)\\n        k = n-1\\n        while(i<=k):\\n            if a[i]==0:\\n                a[i],a[j] = a[j],a[i]\\n                j+=1\\n            if a[i]==2:\\n                a[i],a[k] = a[k],a[i]\\n                k-=1\\n                i-=1\\n            i+=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortColors(self, a: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        i = 0\\n        j = 0\\n        n = len(a)\\n        k = n-1\\n        while(i<=k):\\n            if a[i]==0:\\n                a[i],a[j] = a[j],a[i]\\n                j+=1\\n            if a[i]==2:\\n                a[i],a[k] = a[k],a[i]\\n                k-=1\\n                i-=1\\n            i+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914676,
                "title": "easiest-1-pass-2-pointers-approach-faster-than-100",
                "content": "```\\n\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0, high = nums.length-1;\\n        for(int i=0; i<=high;){\\n            if(nums[i]==0){\\n                swap(nums, i, low);\\n                i++;\\n                low++;\\n            }\\n            else if(nums[i] == 1){\\n                i++;\\n            }\\n            else{\\n                swap(nums, i, high); // this is for nums[i] == 2\\n                 high--;\\n            }\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int store = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = store;\\n    }\\n}\\n\\n```\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(1)\\n\\nIf you like this solution give upvote :)",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0, high = nums.length-1;\\n        for(int i=0; i<=high;){\\n            if(nums[i]==0){\\n                swap(nums, i, low);\\n                i++;\\n                low++;\\n            }\\n            else if(nums[i] == 1){\\n                i++;\\n            }\\n            else{\\n                swap(nums, i, high); // this is for nums[i] == 2\\n                 high--;\\n            }\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int store = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = store;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892170,
                "title": "java-one-pass-and-constant-space-with-picture-and-explanation",
                "content": "# Pointer Explanation\\n* Pointer i (red): everything before it needs to be a 0; aka beginning of 1\\'s\\n* Pointer j (blue): needs to always point to a 1 (the \"iterating\" pointer)\\n* Pointer k (green): everything after it needs to be a 2; aka end of 1\\'s\\n\\n![image](https://assets.leetcode.com/users/images/0459ad7e-937c-4f67-b225-c2de72c6e884_1602561016.9415524.png)\\n\\n\\n\\n\\n# Running through an example\\n![image](https://assets.leetcode.com/users/images/a74c4db2-d5e7-46f3-a756-da5c770cdf35_1602561153.9220176.png)\\n\\n\\n# Code\\n```\\npublic void sortColors(int[] nums) {\\n    int i = 0, j = 0, k = nums.length - 1;\\n    while (j <= k) {    \\n        if (nums[j] == 0)           swap(i++, j++, nums);  \\n        else if (nums[j] == 1)      j++;\\n        else if (nums[j] == 2)      swap(j, k--, nums);\\n    }\\n}",
                "solutionTags": [],
                "code": "# Pointer Explanation\\n* Pointer i (red): everything before it needs to be a 0; aka beginning of 1\\'s\\n* Pointer j (blue): needs to always point to a 1 (the \"iterating\" pointer)\\n* Pointer k (green): everything after it needs to be a 2; aka end of 1\\'s\\n\\n![image](https://assets.leetcode.com/users/images/0459ad7e-937c-4f67-b225-c2de72c6e884_1602561016.9415524.png)\\n\\n\\n\\n\\n# Running through an example\\n![image](https://assets.leetcode.com/users/images/a74c4db2-d5e7-46f3-a756-da5c770cdf35_1602561153.9220176.png)\\n\\n\\n# Code\\n```\\npublic void sortColors(int[] nums) {\\n    int i = 0, j = 0, k = nums.length - 1;\\n    while (j <= k) {    \\n        if (nums[j] == 0)           swap(i++, j++, nums);  \\n        else if (nums[j] == 1)      j++;\\n        else if (nums[j] == 2)      swap(j, k--, nums);\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 849331,
                "title": "rust-one-pass",
                "content": "```rust\\nimpl Solution {\\n    pub fn sort_colors(nums: &mut Vec<i32>) {\\n        /* \\n        The idea is iterating through to push 0s and 2s to sides\\n        Indices i0 and i2 mark the boundary so that\\n            0s over [0, i0)\\n            1s over [i0, i2)\\n            2s over [i2, len)\\n        */\\n        let (mut i, mut i0, mut i2) = (0, 0, nums.len());\\n        \\n        while i < i2 {\\n            match nums[i] {\\n                0 => { nums.swap(i, i0); i0 += 1; i += 1; },\\n                2 => { i2 -= 1; nums.swap(i, i2); },\\n                _ => { i += 1 },\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn sort_colors(nums: &mut Vec<i32>) {\\n        /* \\n        The idea is iterating through to push 0s and 2s to sides\\n        Indices i0 and i2 mark the boundary so that\\n            0s over [0, i0)\\n            1s over [i0, i2)\\n            2s over [i2, len)\\n        */\\n        let (mut i, mut i0, mut i2) = (0, 0, nums.len());\\n        \\n        while i < i2 {\\n            match nums[i] {\\n                0 => { nums.swap(i, i0); i0 += 1; i += 1; },\\n                2 => { i2 -= 1; nums.swap(i, i2); },\\n                _ => { i += 1 },\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499396,
                "title": "c-6-approaches-to-solve-the-dutch-national-flag-problem",
                "content": "This problem can be used to optimize the naive quicksort implementation (group elements into smaller ones, equal ones, larger ones). Smaller ones correspond to 0\\'s, equal ones correspond to 1\\'s, larger ones correspond to 2\\'s.\\n\\nThere are several approaches (different levels of optimization) to solve this problem as shown below: \\n\\n\\n**********************************************************************\\n\\nApproach #1\\n\\ntrivial \\n\\n`O(n)` time, `O(n)` space\\n```c++\\n\\tvoid sortColors(vector<int>& nums) {\\n        vector<int> smaller, equal, larger;\\n        for(auto el: nums){\\n            if(el == 0) smaller.push_back(el);\\n            else if(el == 1) equal.push_back(el);\\n            else larger.push_back(el);\\n        }\\n        nums.clear();\\n        for(auto el: smaller) nums.push_back(el);\\n        for(auto el: equal) nums.push_back(el);\\n        for(auto el: larger) nums.push_back(el);\\n    }\\n```\\n\\n**********************************************************************\\n\\nApproach #2\\n\\nCounting sort (in fact this is equivalent to the above one)\\n\\n`O(n)` time, `O(1)` space\\n\\n```c++\\n\\tvoid sortColors(vector<int>& nums) {\\n        int smaller = 0, equal = 0, larger = 0;\\n        for(auto el: nums){\\n            if(el == 0) smaller++;\\n            else if(el == 1) equal++;\\n            else larger++;\\n        }\\n        nums.clear();\\n        for(int i = 0; i < smaller; i++) nums.push_back(0);\\n        for(int i = 0; i < equal; i++) nums.push_back(1);\\n        for(int i = 0; i < larger; i++) nums.push_back(2);\\n    }\\n```\\n\\n**********************************************************************\\n\\nApproach #3\\n\\nComparison sort (quick sort has been chosen for the implementation)\\n\\n`O(n log(n) )` time, `O( log(n) )` best-case space complexity, `O(n)` average-case space complexity (function call stack)\\n\\n```c++\\n\\tvoid quickSort(vector<int>& nums, int l, int r){\\n        if(l >= r) return;\\n        int i = l;\\n        for(int j = l; j < r; j++)\\n            if(nums[j] <= nums[r]) \\n                swap(nums[i++], nums[j]);\\n        swap(nums[i], nums[r]);\\n        quickSort(nums, l, i - 1);\\n        quickSort(nums, i + 1, r);\\n    }\\n    \\n    void sortColors(vector<int>& nums) {\\n        quickSort(nums, 0, nums.size() - 1);\\n    }\\n```\\n\\n**********************************************************************\\n\\nApproach #4\\n\\nTwo-pass `O(n^2)` time, `O(1)` space\\n\\n```c++\\n\\tvoid sortColors(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++)\\n            for(int j = i + 1; j < nums.size(); j++)\\n                if(nums[j] == 0){\\n                    swap(nums[i], nums[j]);\\n                    break;\\n                }\\n        for(int i = nums.size() - 1; i >= 0; i--)\\n            for(int j = i - 1; j >= 0; j--)\\n                if(nums[j] == 2){\\n                    swap(nums[i], nums[j]);\\n                    break;\\n                }\\n    }\\n```\\n\\n*****************************************************************\\n\\nApproach #5\\n\\nTwo-pass `O(n)` time, `O(1)` space\\n\\n```c++\\n\\tvoid sortColors(vector<int>& nums) {\\n        int i = 0;\\n        for(int j = 0; j < nums.size(); j++)\\n            if(nums[j] == 0)\\n                swap(nums[i++], nums[j]);\\n        i = nums.size() - 1;\\n        for(int j = nums.size() - 1; j >= 0; j--)\\n            if(nums[j] == 2)\\n                swap(nums[i--], nums[j]);\\n    }\\n```\\n\\n*****************************************************************\\n\\nApproach #6\\n\\nOne-pass `O(n)` time, `O(1)` space\\n\\nBy assuming the following: \\n\\n* `[0 : smaller - 1]` smaller part\\n* `[smaller : equal - 1]` equal part\\n* `[equal : larger - 1]` unclassified part\\n* `[larger : nums.size() - 1]` larger part\\n\\n```c++\\n\\tvoid sortColors(vector<int>& nums) {\\n        int smaller = 0, equal = 0, larger = nums.size();\\n        while(equal < larger){\\n            if(nums[equal] == 0) swap(nums[smaller++], nums[equal++]);\\n            else if(nums[equal] == 1) equal++;\\n            else swap(nums[--larger], nums[equal]);\\n        }\\n    }\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\n\\tvoid sortColors(vector<int>& nums) {\\n        vector<int> smaller, equal, larger;\\n        for(auto el: nums){\\n            if(el == 0) smaller.push_back(el);\\n            else if(el == 1) equal.push_back(el);\\n            else larger.push_back(el);\\n        }\\n        nums.clear();\\n        for(auto el: smaller) nums.push_back(el);\\n        for(auto el: equal) nums.push_back(el);\\n        for(auto el: larger) nums.push_back(el);\\n    }\\n```\n```c++\\n\\tvoid sortColors(vector<int>& nums) {\\n        int smaller = 0, equal = 0, larger = 0;\\n        for(auto el: nums){\\n            if(el == 0) smaller++;\\n            else if(el == 1) equal++;\\n            else larger++;\\n        }\\n        nums.clear();\\n        for(int i = 0; i < smaller; i++) nums.push_back(0);\\n        for(int i = 0; i < equal; i++) nums.push_back(1);\\n        for(int i = 0; i < larger; i++) nums.push_back(2);\\n    }\\n```\n```c++\\n\\tvoid quickSort(vector<int>& nums, int l, int r){\\n        if(l >= r) return;\\n        int i = l;\\n        for(int j = l; j < r; j++)\\n            if(nums[j] <= nums[r]) \\n                swap(nums[i++], nums[j]);\\n        swap(nums[i], nums[r]);\\n        quickSort(nums, l, i - 1);\\n        quickSort(nums, i + 1, r);\\n    }\\n    \\n    void sortColors(vector<int>& nums) {\\n        quickSort(nums, 0, nums.size() - 1);\\n    }\\n```\n```c++\\n\\tvoid sortColors(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++)\\n            for(int j = i + 1; j < nums.size(); j++)\\n                if(nums[j] == 0){\\n                    swap(nums[i], nums[j]);\\n                    break;\\n                }\\n        for(int i = nums.size() - 1; i >= 0; i--)\\n            for(int j = i - 1; j >= 0; j--)\\n                if(nums[j] == 2){\\n                    swap(nums[i], nums[j]);\\n                    break;\\n                }\\n    }\\n```\n```c++\\n\\tvoid sortColors(vector<int>& nums) {\\n        int i = 0;\\n        for(int j = 0; j < nums.size(); j++)\\n            if(nums[j] == 0)\\n                swap(nums[i++], nums[j]);\\n        i = nums.size() - 1;\\n        for(int j = nums.size() - 1; j >= 0; j--)\\n            if(nums[j] == 2)\\n                swap(nums[i--], nums[j]);\\n    }\\n```\n```c++\\n\\tvoid sortColors(vector<int>& nums) {\\n        int smaller = 0, equal = 0, larger = nums.size();\\n        while(equal < larger){\\n            if(nums[equal] == 0) swap(nums[smaller++], nums[equal++]);\\n            else if(nums[equal] == 1) equal++;\\n            else swap(nums[--larger], nums[equal]);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 494027,
                "title": "java-easiest-swapping-solution-with-explanation-must-read",
                "content": "So the idea is very simple here. We maintain two pointers, I call them reds and blues. We use them to move all the red colors or 0 to the left and all the blue colors or 2 to the right. We achieve this by swapping elements within the array in place. \\n\\n```\\npublic void sortColors(int[] nums) {\\n\\tint reds = 0, blues = nums.length-1;\\n\\tfor(int i = 0; i <= blues;) {\\n\\t\\tif(nums[i] == 0) swap(nums, i++, reds++);\\n\\t\\telse if(nums[i] == 2) swap(nums, i, blues--);   // see below why i is not incremented\\n\\t\\telse i++;\\n\\t}\\n}\\n\\npublic void swap(int nums[], int i, int j) {\\n\\tint temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n```\\n\\n**NOTE** We cannot increment i after each swap, because the new color 2 is swapped with could be 0 as in the case of [1,2,0] -> [1,0,2] which hence would require another swap operation to get the correct result.",
                "solutionTags": [],
                "code": "```\\npublic void sortColors(int[] nums) {\\n\\tint reds = 0, blues = nums.length-1;\\n\\tfor(int i = 0; i <= blues;) {\\n\\t\\tif(nums[i] == 0) swap(nums, i++, reds++);\\n\\t\\telse if(nums[i] == 2) swap(nums, i, blues--);   // see below why i is not incremented\\n\\t\\telse i++;\\n\\t}\\n}\\n\\npublic void swap(int nums[], int i, int j) {\\n\\tint temp = nums[i];\\n\\tnums[i] = nums[j];\\n\\tnums[j] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329200,
                "title": "shortest-one-pass-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int p0 = 0, p1 = 0, p2 = 0;\\n        for (int num : nums) {\\n            nums[p2++] = 2;\\n            if (num < 2) nums[p1++] = 1;\\n            if (num < 1) nums[p0++] = 0;\\n        }\\n    }\\n}\\n```\\n\\nQuick eplaination:\\n* We always increase pointer p2 because no matter what value we\\'re facing, p2 will go up. **Reason:** if `num == 2` when we must add a new 2, which means p2 goes up. Otherwise, we must add a `0` or a `1` which push p2 to the right, meaning p2 goes up.\\n* If value we\\'re facing is 0 or 1 (<2), p1 will go up. So increase it.\\n* Only increase pointer p0 when we see a 0.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int p0 = 0, p1 = 0, p2 = 0;\\n        for (int num : nums) {\\n            nums[p2++] = 2;\\n            if (num < 2) nums[p1++] = 1;\\n            if (num < 1) nums[p0++] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314052,
                "title": "swift-99-beat-linear-o-n-speed-make-mistakes-when-you-try-this",
                "content": "Mistakes are how U learn. Duh.\\n\\n```\\nclass Solution {\\n    func sortColors(_ nums: inout [Int]) {\\n        var first = 0\\n        var mid = 0\\n        var last = nums.count - 1\\n        var i = 0\\n        while mid <= last {\\n            if nums[mid] < 1 {\\n                nums.swapAt(first, mid)\\n                first += 1\\n                mid += 1\\n            } else if nums[mid] > 1 {\\n                nums.swapAt(last, mid)\\n                last -= 1\\n                \\n            } else {\\n                mid += 1\\n            }\\n            i += 1\\n        }\\n    }\\n}\\n```\\n\\nThe more you fail the bigger you win. Kaboom, baby. This is a great trick.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func sortColors(_ nums: inout [Int]) {\\n        var first = 0\\n        var mid = 0\\n        var last = nums.count - 1\\n        var i = 0\\n        while mid <= last {\\n            if nums[mid] < 1 {\\n                nums.swapAt(first, mid)\\n                first += 1\\n                mid += 1\\n            } else if nums[mid] > 1 {\\n                nums.swapAt(last, mid)\\n                last -= 1\\n                \\n            } else {\\n                mid += 1\\n            }\\n            i += 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170277,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int i = 0;\\n        while (i <= high){\\n            if (nums[i] == 0){\\n                swap(low, i, nums);\\n                low++;\\n                i++;  // first I thought it could be omitted, but consider this situation,[0,0,2,2], i will not increase at all\\n            }         \\n            else if (nums[i] == 2){\\n                swap(high, i, nums);\\n                high--;       // no i++, cause we do not know what is replaced in index i, maybe 0, 1 or 2\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    }\\n    private void swap(int a, int b, int[] nums){  // you have to pass nums with index a and index b, you cannot just pass two \\n        int temp = nums[a];                       // integers\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int i = 0;\\n        while (i <= high){\\n            if (nums[i] == 0){\\n                swap(low, i, nums);\\n                low++;\\n                i++;  // first I thought it could be omitted, but consider this situation,[0,0,2,2], i will not increase at all\\n            }         \\n            else if (nums[i] == 2){\\n                swap(high, i, nums);\\n                high--;       // no i++, cause we do not know what is replaced in index i, maybe 0, 1 or 2\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    }\\n    private void swap(int a, int b, int[] nums){  // you have to pass nums with index a and index b, you cannot just pass two \\n        int temp = nums[a];                       // integers\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26557,
                "title": "c-counting-sort",
                "content": "seems like many solutions are using swapping and calling that 1 pass, but if you are accessing 2 elements on each iteration that is more like 2 pass, no?  In any case counting sort is 2 pass and logically very simple.  For this problem it is also O(1) space as we know we only have 3 values to keep counts for.\\n\\n```\\n\\n    public void SortColors(int[] nums) \\n    {\\n        int[] counts = new int[3];\\n        foreach (int x in nums)\\n        {\\n            counts[x]++;\\n        }\\n        \\n        int index = 0;\\n        for (int x = 0; x <= 2; x++)\\n        {\\n            while (counts[x]-- > 0)\\n            {\\n                nums[index++] = x;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public void SortColors(int[] nums) \\n    {\\n        int[] counts = new int[3];\\n        foreach (int x in nums)\\n        {\\n            counts[x]++;\\n        }\\n        \\n        int index = 0;\\n        for (int x = 0; x <= 2; x++)\\n        {\\n            while (counts[x]-- > 0)\\n            {\\n                nums[index++] = x;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26675,
                "title": "concise-1-pass-java-solution",
                "content": "The basic idea is using two pointers: left boundary, right boundary. Then \\n\\n    1) put 0 to the left of the left boundary;    \\n    2) put 2 to the right of the right boundary.\\n\\nAs the following:\\n\\n\\n     left boundary|         |right boundary\\n            00000 | 1111111 | 22222222\\n\\n**JAVA Code: Time complexity O(n)**\\n\\nAs each element is only checked once, so the time complexity should be O(n).\\n\\n    public void sortColors(int[] nums) { \\n        if (nums == null || nums.length == 0) return;\\n        int left = 0, right = nums.length - 1;// Left, right boundary\\n        for (int i = 0; i <= right; i++) {\\n        \\tif (nums[i] == 0 && i != left)// Only swap if i != left\\n        \\t\\tswap(nums, i--, left++);\\n        \\telse if (nums[i] == 2 && i != right)// Only swap if i != right \\n        \\t\\tswap(nums, i--, right--);        \\t\\n        }        \\n    }\\n    void swap(int[] nums, int i, int j) {\\n    \\tint tmp = nums[i];\\n    \\tnums[i] = nums[j];\\n    \\tnums[j] = tmp;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is using two pointers: left boundary, right boundary. Then \\n\\n    1) put 0 to the left of the left boundary;    \\n    2) put 2 to the right of the right boundary.\\n\\nAs the following:\\n\\n\\n     left boundary|         |right boundary\\n            00000 | 1111111 | 22222222\\n\\n**JAVA Code: Time complexity O(n)**\\n\\nAs each element is only checked once, so the time complexity should be O(n).\\n\\n    public void sortColors(int[] nums) { \\n        if (nums == null || nums.length == 0) return;\\n        int left = 0, right = nums.length - 1;// Left, right boundary\\n        for (int i = 0; i <= right; i++) {\\n        \\tif (nums[i] == 0 && i != left)// Only swap if i != left\\n        \\t\\tswap(nums, i--, left++);\\n        \\telse if (nums[i] == 2 && i != right)// Only swap if i != right \\n        \\t\\tswap(nums, i--, right--);        \\t\\n        }        \\n    }\\n    void swap(int[] nums, int i, int j) {\\n    \\tint tmp = nums[i];\\n    \\tnums[i] = nums[j];\\n    \\tnums[j] = tmp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26692,
                "title": "0ms-and-one-pass-solution-with-c",
                "content": "    void sortColors(int* nums, int numsSize)\\n    {\\n\\t int i = 0;\\n\\tint red = 0;\\n\\tint blue = numsSize - 1;\\n\\twhile (i <= blue)\\n\\t{\\n\\t\\tif (nums[i] == 0)\\n\\t\\t{\\n\\t\\t\\tnums[i] = nums[red];\\n\\t\\t\\tnums[red] = 0;\\n\\t\\t\\tif (i == red)\\n\\t\\t\\t\\ti++;\\n\\t\\t\\tred++;\\n\\t\\t}\\n\\t\\telse if (nums[i] == 2)\\n\\t\\t{\\n\\t\\t\\tnums[i] = nums[blue];\\n\\t\\t\\tnums[blue] = 2;\\n\\t\\t\\tblue--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t}\\n    }",
                "solutionTags": [],
                "code": "    void sortColors(int* nums, int numsSize)\\n    {\\n\\t int i = 0;\\n\\tint red = 0;\\n\\tint blue = numsSize - 1;\\n\\twhile (i <= blue)\\n\\t{\\n\\t\\tif (nums[i] == 0)\\n\\t\\t{\\n\\t\\t\\tnums[i] = nums[red];\\n\\t\\t\\tnums[red] = 0;\\n\\t\\t\\tif (i == red)\\n\\t\\t\\t\\ti++;\\n\\t\\t\\tred++;\\n\\t\\t}\\n\\t\\telse if (nums[i] == 2)\\n\\t\\t{\\n\\t\\t\\tnums[i] = nums[blue];\\n\\t\\t\\tnums[blue] = 2;\\n\\t\\t\\tblue--;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26731,
                "title": "share-my-one-loop-c-solution",
                "content": "    class Solution {\\n    public:\\n        void sortColors(vector<int>& nums) {\\n            int s[3] = {0,0,0};\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (nums[i] == 0) {\\n                    nums[s[2]++] = 2;\\n                    nums[s[1]++] = 1;\\n                    nums[s[0]++] = 0;\\n                } else if (nums[i] == 1) {\\n                    nums[s[2]++] = 2;\\n                    nums[s[1]++] = 1;\\n                } else {\\n                    nums[s[2]++] = 2;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void sortColors(vector<int>& nums) {\\n            int s[3] = {0,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 26767,
                "title": "python-one-pass-solution",
                "content": "The problem is called dutch national flag problem.\\n\\nGist below:\\n\\na) Traverse from left to right\\nb) Maintain the most recent position of 0 and the position of 2.\\nc) When 0 is encountered move to the left and for 2 move to right. (increment/decrement the pointers accordingly)\\nd) When 1 is encountered do nothing.\\n\\nCode below:\\n\\n    def sortColors(self, A):\\n    \\n        leftindex = zeropos = 0\\n        right_index = len(A) - 1\\n    \\n        while left_index <= right_index:\\n            if A[left_index] == 0:\\n               A[left_index], A[zero_pos] = A[zero_pos], A[left_index]\\n               left_index += 1\\n               zero_pos += 1\\n            elif A[left_index] == 2:\\n               A[right_index], A[left_index] = A[left_index], A[right_index]\\n               right_index -= 1\\n            else:\\n               left_index += 1",
                "solutionTags": [],
                "code": "The problem is called dutch national flag problem.\\n\\nGist below:\\n\\na) Traverse from left to right\\nb) Maintain the most recent position of 0 and the position of 2.\\nc) When 0 is encountered move to the left and for 2 move to right. (increment/decrement the pointers accordingly)\\nd) When 1 is encountered do nothing.\\n\\nCode below:\\n\\n    def sortColors(self, A):\\n    \\n        leftindex = zeropos = 0\\n        right_index = len(A) - 1\\n    \\n        while left_index <= right_index:\\n            if A[left_index] == 0:\\n               A[left_index], A[zero_pos] = A[zero_pos], A[left_index]\\n               left_index += 1\\n               zero_pos += 1\\n            elif A[left_index] == 2:\\n               A[right_index], A[left_index] = A[left_index], A[right_index]\\n               right_index -= 1\\n            else:\\n               left_index += 1",
                "codeTag": "Python3"
            },
            {
                "id": 3853294,
                "title": "best-optimised-solution-in-c-using-dutch-national-flag-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to sort an array of integers representing colors in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We are given that the colors red, white, and blue are represented by the integers 0, 1, and 2 respectively.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDutch National Flag algorithm\\nThe Dutch National Flag algorithm, also known as 3-way partitioning, is an algorithm for sorting an array containing three distinct values. The algorithm was designed to solve the problem of sorting an array containing only 0s, 1s, and 2s, which is similar to the problem in the given question.\\n\\nThe algorithm works by maintaining three pointers: low, mid, and high. The low pointer points to the beginning of the array, the high pointer points to the end of the array, and the mid pointer starts at the beginning of the array and moves through it.\\n\\nThe idea behind the algorithm is to keep all the 0s before the low pointer, all the 2s after the high pointer, and all the 1s between the low and high pointers. The algorithm moves the mid pointer through the array, comparing the value at each position with 1. If the value is 0, the element is swapped with the element at the low pointer, and the low and mid pointers are incremented. If the value is 2, the element is swapped with the element at the high pointer, and the high pointer is decremented. If the value is 1, the mid pointer is simply incremented.\\n\\nThe algorithm terminates when the mid pointer crosses the high pointer, indicating that all the elements have been processed and the array is sorted.\\n\\nThe Dutch National Flag algorithm is called one-pass because it sorts the array in a single pass through the elements. The time complexity of the algorithm is O(n), where n is the size of the array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Deutsch National Flag algorithm vaparlay\\n//TC: O(N).     SC:O(1)\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Deutsch National Flag algorithm vaparlay\\n//TC: O(N).     SC:O(1)\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793790,
                "title": "solution-for-sort-colors-leetcode-problem-75",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given Solution class provides a method sortColors that sorts an array containing 0s, 1s, and 2s. The problem is commonly known as the \"Dutch National Flag\" problem. The goal is to sort the array in-place such that all 0s come before all 1s, and all 1s come before all 2s.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution uses the Dutch National Flag algorithm, which is an efficient method to sort an array with three distinct values (0, 1, and 2). The algorithm uses three pointers: start, mid, and end. The start pointer points to the position where the next 0 should be placed, the mid pointer traverses the array, and the end pointer points to the position where the next 2 should be placed. The algorithm follows these steps:\\n\\nInitialize start, mid, and end pointers to the beginning, the beginning, and the end of the array, respectively.\\nWhile the mid pointer is less than or equal to the end pointer:\\nIf the element at mid is 0, swap the elements at start and mid, increment both start and mid pointers.\\nIf the element at mid is 1, just increment the mid pointer.\\nIf the element at mid is 2, swap the elements at mid and end, decrement the end pointer.\\nThe above steps ensure that all 0s move to the left side of the array, all 2s move to the right side of the array, and all 1s are automatically placed in the middle.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the sortColors method is O(n), where n is the number of elements in the array. The algorithm traverses the array once, and each element is visited at most twice during the swapping operations.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the sortColors method is O(1) because it sorts the array in-place without using any additional data structures. The sorting is done by swapping elements within the input array, and the number of extra variables used for the algorithm remains constant, irrespective of the size of the input array.\\n\\n# Code\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) \\n    {\\n        int start = 0;\\n        int mid = 0;\\n        int end = nums.length - 1;\\n\\n        while (mid <= end) {\\n\\n            switch (nums[mid]) {\\n            case 0:\\n                // Swap with start index\\n                swap(nums, start, mid);\\n                mid++;\\n                start++;\\n                break;\\n\\n            case 1:\\n                mid++;\\n                break;\\n\\n            case 2:\\n                // Swap with end index\\n                swap(nums, mid, end);\\n                end--;\\n                break;\\n      }\\n    }\\n    }\\n\\n    private void swap(int[] arr, int pos1, int pos2) {\\n    int temp = arr[pos1];\\n    arr[pos1] = arr[pos2];\\n    arr[pos2] = temp;\\n    }\\n        \\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/b22c06d6-f77a-4d8c-b277-bd6863c69f7e_1689875839.0660408.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) \\n    {\\n        int start = 0;\\n        int mid = 0;\\n        int end = nums.length - 1;\\n\\n        while (mid <= end) {\\n\\n            switch (nums[mid]) {\\n            case 0:\\n                // Swap with start index\\n                swap(nums, start, mid);\\n                mid++;\\n                start++;\\n                break;\\n\\n            case 1:\\n                mid++;\\n                break;\\n\\n            case 2:\\n                // Swap with end index\\n                swap(nums, mid, end);\\n                end--;\\n                break;\\n      }\\n    }\\n    }\\n\\n    private void swap(int[] arr, int pos1, int pos2) {\\n    int temp = arr[pos1];\\n    arr[pos1] = arr[pos2];\\n    arr[pos2] = temp;\\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694023,
                "title": "using-dutch-flag-algorithm-easy-approach",
                "content": "void sortColors(vector<int>& nums) {\\n     int l=0;\\n     int m=0;\\n     int h =nums.size()-1;\\n    while(m<=h){\\n         if(nums[m]==0){\\n           swap(nums[l++],nums[m++]);\\n         }\\n         else if(nums[m]==1){\\n             m++;\\n         }\\n         else{\\n             swap(nums[m],nums[h--]);\\n         }\\n     }\\n         \\n    }\\n\\t\\n# \\t**Please upvote me if you liked the approach",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "void sortColors(vector<int>& nums) {\\n     int l=0;\\n     int m=0;\\n     int h =nums.size()-1;\\n    while(m<=h){\\n         if(nums[m]==0){\\n           swap(nums[l++],nums[m++]);\\n         }\\n         else if(nums[m]==1){\\n             m++;\\n         }\\n         else{\\n             swap(nums[m],nums[h--]);\\n         }\\n     }\\n         \\n    }\\n\\t\\n# \\t**Please upvote me if you liked the approach",
                "codeTag": "Unknown"
            },
            {
                "id": 3652745,
                "title": "java-0ms-100-faster-clean-implementation",
                "content": "# Intuition\\n\\n**DUTCH NATIONAL FLAG ALGORITHM**\\n\\nthere will be 3 pointers \"low\", \"mid\" and \"high\"\\nlow and mid pointing at the begining of the array ,\\nhigh pointing at the end\\nTraverse linearly the \\'mid\\' pointer : \\nfor 0, swap its position with the mid and increament both the mid and low by 1\\nfor 1, continue traversing the mid pointer\\nfor 2, swap its position with high and decrease high by 1\\n\\neverything to the left of low pointer will be 0\\neverything to the right of high pointer will be 2\\neverything between low and mid - 1 will be 1 \\n\\nswitch case is used in case of conditional if because : **A switch statement is significantly faster than an if-else ladder if there are many nested if-else\\'s involved.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0, mid = 0, high = nums.length - 1;\\n        int temp;\\n        while(mid <= high) {\\n            switch(nums[mid]) {\\n                case 0 : {\\n                    temp = nums[low];\\n                    nums[low] = nums[mid];\\n                    nums[mid] = temp;\\n                    mid ++;\\n                    low ++;\\n                    break;\\n                }\\n                case 1 : {\\n                    mid ++;\\n                    break;\\n                }\\n                case 2 : {\\n                    temp = nums[mid];\\n                    nums[mid] = nums[high];\\n                    nums[high] = temp;\\n                    high --;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int low = 0, mid = 0, high = nums.length - 1;\\n        int temp;\\n        while(mid <= high) {\\n            switch(nums[mid]) {\\n                case 0 : {\\n                    temp = nums[low];\\n                    nums[low] = nums[mid];\\n                    nums[mid] = temp;\\n                    mid ++;\\n                    low ++;\\n                    break;\\n                }\\n                case 1 : {\\n                    mid ++;\\n                    break;\\n                }\\n                case 2 : {\\n                    temp = nums[mid];\\n                    nums[mid] = nums[high];\\n                    nums[high] = temp;\\n                    high --;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520780,
                "title": "beats-100-using-dutch-national-flag-algorithm-dnf-algo",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        // Dutch national flag approach\\n        int low=0;\\n        int mid=0;\\n        int high=nums.size()-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else if(nums[mid]==2)\\n            {\\n                swap(nums[high],nums[mid]);\\n                \\n                high--;\\n            }\\n        }\\n        \\n    }\\n};\\n\\n\\n<!-- DO UPVOTE IF YOU FIND IT INTERSTING AND HELPFUL,THANKS **Bold**:) -->\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        // Dutch national flag approach\\n        int low=0;\\n        int mid=0;\\n        int high=nums.size()-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else if(nums[mid]==2)\\n            {\\n                swap(nums[high],nums[mid]);\\n                \\n                high--;\\n            }\\n        }\\n        \\n    }\\n};\\n\\n\\n<!-- DO UPVOTE IF YOU FIND IT INTERSTING AND HELPFUL,THANKS **Bold**:) -->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423847,
                "title": "cpp-beats-100-constant-space",
                "content": "\\n\\n# Approach\\nThis question is a famous Dutch National Flag alogrithm . The Dutch National Flag algorithm is a sorting algorithm that partitions an array containing elements of three distinct values (for example, 0s, 1s, and 2s) into three parts, in a single traversal of the array. The algorithm is named after the Dutch national flag, which has three horizontal stripes of red, white, and blue.\\n\\nThe algorithm uses three pointers to partition the array into three sections:\\n\\n1. A[0...s-1] contains all elements that are smaller than the middle value (in the example above, the 0s).\\n2. A[s...e] contains all elements that are equal to the middle value (in the example above, the 1s).\\n3. A[e+1...n-1] contains all elements that are larger than the middle value (in the example above, the 2s).\\nInitially, the pointer s points to the beginning of the array, and the pointer e points to the end of the array. A third pointer, i, starts at the beginning of the array and moves forward one element at a time.\\n\\nThe algorithm continues until the i pointer reaches the end of the array. If the element at A[i] is smaller than the middle value, it is swapped with the element at A[s], and both pointers i and s are incremented. If the element at A[i] is larger than the middle value, it is swapped with the element at A[e], and the pointer e is decremented. If the element at A[i] is equal to the middle value, the pointer i is incremented.\\n\\nThis algorithm works because, at any point in time during the while loop, the following invariants hold true:\\n\\n1. All elements before s are smaller than the middle value.\\n2. All elements after e are larger than the middle value.\\n3. All elements between s and i-1 are equal to the middle value.\\n4. All elements between i and e are unprocessed.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the given code is O(N), where N is the number of elements in the input array. This is because the code performs a single pass through the array, swapping at most N elements, which takes linear time.\\n\\n- Space complexity:\\nThe space complexity of the code is O(1), which means that it uses constant extra space regardless of the input size. This is because the code does not use any additional data structures or arrays to store elements. It only uses the three pointers s, mid, and e to partition the input array in-place, which requires only constant space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        int mid=0;\\n         while(mid<=e){\\n           if(nums[mid]==0){\\n               swap(nums[s++],nums[mid++]);\\n           }\\n           else if(nums[mid]==1){\\n               mid++;\\n           }\\n           else{\\n               swap(nums[e--],nums[mid]);\\n           }\\n       }\\n\\n    }\\n};\\n<!-- PLEASE UPVOTE :) -->\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-1;\\n        int mid=0;\\n         while(mid<=e){\\n           if(nums[mid]==0){\\n               swap(nums[s++],nums[mid++]);\\n           }\\n           else if(nums[mid]==1){\\n               mid++;\\n           }\\n           else{\\n               swap(nums[e--],nums[mid]);\\n           }\\n       }\\n\\n    }\\n};\\n<!-- PLEASE UPVOTE :) -->\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334741,
                "title": "dutch-national-flag-algorithm-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nApplying Dutch National flag algorithm\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        //  Dutch National flag algorithm\\n        int low = 0 , mid = 0 , high = nums.size() -1 ;\\n        while( mid <= high   )\\n        {\\n            if( nums[mid] == 1)\\n            {\\n                mid++;\\n                continue;\\n            }\\n            if(nums[mid] == 0 )\\n            {\\n                swap( nums[mid] , nums[low]);\\n                mid++ , low++;\\n                continue;\\n            }\\n            if(nums[mid] == 2)\\n            {\\n                swap( nums[mid] , nums[high]);\\n                high-- ;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        //  Dutch National flag algorithm\\n        int low = 0 , mid = 0 , high = nums.size() -1 ;\\n        while( mid <= high   )\\n        {\\n            if( nums[mid] == 1)\\n            {\\n                mid++;\\n                continue;\\n            }\\n            if(nums[mid] == 0 )\\n            {\\n                swap( nums[mid] , nums[low]);\\n                mid++ , low++;\\n                continue;\\n            }\\n            if(nums[mid] == 2)\\n            {\\n                swap( nums[mid] , nums[high]);\\n                high-- ;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181681,
                "title": "75-sort-colors-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # Two pointer approach\\n        # Keep track of the position of 0s and 2s and swap the rest of the elements to their correct positions\\n        left = 0\\n        right = len(nums) - 1\\n        current = 0\\n        \\n        while current <= right:\\n            if nums[current] == 0:\\n                nums[current], nums[left] = nums[left], nums[current]\\n                left += 1\\n                current += 1\\n            elif nums[current] == 2:\\n                nums[current], nums[right] = nums[right], nums[current]\\n                right -= 1\\n            else:\\n                current += 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # Two pointer approach\\n        # Keep track of the position of 0s and 2s and swap the rest of the elements to their correct positions\\n        left = 0\\n        right = len(nums) - 1\\n        current = 0\\n        \\n        while current <= right:\\n            if nums[current] == 0:\\n                nums[current], nums[left] = nums[left], nums[current]\\n                left += 1\\n                current += 1\\n            elif nums[current] == 2:\\n                nums[current], nums[right] = nums[right], nums[current]\\n                right -= 1\\n            else:\\n                current += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085218,
                "title": "c-fast-and-easy-3-pointers",
                "content": "# Intuition\\nIf we bring all 0\\'s to the left side of the array and 2\\'s to the right of the array 1\\'s will automatically get to its correct position. Hence array will be sorted.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int ptr0 = 0, ptr1 = 0, ptr2 = n-1;\\n\\n        while(ptr1<=ptr2){\\n            if(nums[ptr1]==0){\\n                swap(nums[ptr0],nums[ptr1]);\\n                ptr0++,ptr1++;\\n            }\\n            else if(nums[ptr1] == 1){\\n                ptr1++;\\n            }\\n            else{\\n                swap(nums[ptr1],nums[ptr2]);\\n                ptr2--;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int ptr0 = 0, ptr1 = 0, ptr2 = n-1;\\n\\n        while(ptr1<=ptr2){\\n            if(nums[ptr1]==0){\\n                swap(nums[ptr0],nums[ptr1]);\\n                ptr0++,ptr1++;\\n            }\\n            else if(nums[ptr1] == 1){\\n                ptr1++;\\n            }\\n            else{\\n                swap(nums[ptr1],nums[ptr2]);\\n                ptr2--;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080047,
                "title": "with-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                a++;\\n            }\\n            if(nums[i]==1){\\n                b++;\\n            }\\n            if(nums[i]==2){\\n                c++;\\n            }\\n        }\\n        for(int i=0;i<a;i++){\\n            nums[i]=0;\\n        }\\n        for(int i=a;i<a+b;i++){\\n            nums[i]=1;\\n        }\\n        for(int i=a+b;i<a+b+c;i++){\\n            nums[i]=2;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            System.out.print(nums[i]+\" \");\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                a++;\\n            }\\n            if(nums[i]==1){\\n                b++;\\n            }\\n            if(nums[i]==2){\\n                c++;\\n            }\\n        }\\n        for(int i=0;i<a;i++){\\n            nums[i]=0;\\n        }\\n        for(int i=a;i<a+b;i++){\\n            nums[i]=1;\\n        }\\n        for(int i=a+b;i<a+b+c;i++){\\n            nums[i]=2;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            System.out.print(nums[i]+\" \");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988591,
                "title": "c-best-approach-dutch-national-flag-algo-dnf-sort-easy-explained-line-by-line",
                "content": "The Dutch National Flag Algorithm is a linear-time sorting algorithm for sorting elements that can be classified into three different categories. It is commonly used to sort arrays that consist of only 0s, 1s, and 2s.\\n\\nHere are the steps for implementing the Dutch National Flag Algorithm:\\n\\n1. Initialize three pointers, low, mid, and high, to the beginning, middle, and end of the array.\\n2. Set mid to low.\\n3. While mid is less than or equal to high:\\n    - If the element at mid is 0, swap it with the element at low and increment both low and mid.\\n    - If the element at mid is 1, increment only mid.\\n    - If the element at mid is 2, swap it with the element at high and decrement high.\\n4. The array is now sorted.\\n\\n# Code\\n```\\n//Dutch National Flag Sort Algorithm\\n//for sorting problem with 3 unique values \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low = 0 ; //1st mid value ; \\n        //Before which everthing is low(Blue)\\n        int mid = 0 ; //1st Unknown Value :\\n        //low to mid is mid value about which we dont care to swap ;\\n        //mid to high all unknown values\\n        int high = nums.size()-1 ; //last Unknown Value\\n        //after mid all highs(Red) ;\\n\\n\\n        int blue = 0 ;\\n        int white = 1 ;\\n        int red = 2 ;\\n\\n        while(mid <= high) { // as mid crossed high i.e 1st unknow val crossed last unknown val\\n        //i.e no more unknown value remains\\n\\n            if (nums[mid] == blue) {//here\\n                swap(nums[mid] , nums[low]) ;\\n                low++ ; //as low ke peeche saare blue ;\\n                mid++ ;//val at mid was revealed somove it further to continue being 1st unknown\\n            }\\n            else if (nums[mid] == red) {\\n                swap(nums[mid] , nums[high]) ;\\n                high-- ; //as red ke right mai saar red\\n                //here mid wont be updated cause we have swapped it with unknown val at red\\n                //so mid  still 1st unknown ;\\n            }\\n            else if (nums[mid] == white) {\\n                //we dont care about white , no swap ;\\n                //but to maintain mid as the 1st unknown \\n                mid++ ;\\n            }\\n        }\\n\\n    }\\n};\\n```\\n\\n---\\n\\n**For Professional Connect**\\n[LINKEDIN](https://www.linkedin.com/in/piyushbhawsar/)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Dutch National Flag Sort Algorithm\\n//for sorting problem with 3 unique values \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int low = 0 ; //1st mid value ; \\n        //Before which everthing is low(Blue)\\n        int mid = 0 ; //1st Unknown Value :\\n        //low to mid is mid value about which we dont care to swap ;\\n        //mid to high all unknown values\\n        int high = nums.size()-1 ; //last Unknown Value\\n        //after mid all highs(Red) ;\\n\\n\\n        int blue = 0 ;\\n        int white = 1 ;\\n        int red = 2 ;\\n\\n        while(mid <= high) { // as mid crossed high i.e 1st unknow val crossed last unknown val\\n        //i.e no more unknown value remains\\n\\n            if (nums[mid] == blue) {//here\\n                swap(nums[mid] , nums[low]) ;\\n                low++ ; //as low ke peeche saare blue ;\\n                mid++ ;//val at mid was revealed somove it further to continue being 1st unknown\\n            }\\n            else if (nums[mid] == red) {\\n                swap(nums[mid] , nums[high]) ;\\n                high-- ; //as red ke right mai saar red\\n                //here mid wont be updated cause we have swapped it with unknown val at red\\n                //so mid  still 1st unknown ;\\n            }\\n            else if (nums[mid] == white) {\\n                //we dont care about white , no swap ;\\n                //but to maintain mid as the 1st unknown \\n                mid++ ;\\n            }\\n        }\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835464,
                "title": "python-easy-solution-o-1-space",
                "content": "\\n\\t  \\n\\t  \\n\\t  def sortColors(self, nums: List[int]) -> None:\\n        zero=nums.count(0)\\n        one=nums.count(1)\\n        two=nums.count(2)\\n        for x in range(len(nums)):\\n            if two:\\n                nums.pop()\\n                nums.insert(0,2)\\n                two-=1\\n            elif one:\\n                nums.pop()\\n                nums.insert(0,1)\\n                one-=1\\n            else:\\n                nums.pop()\\n                nums.insert(0,0)",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Sorting"
                ],
                "code": "\\n\\t  \\n\\t  \\n\\t  def sortColors(self, nums: List[int]) -> None:\\n        zero=nums.count(0)\\n        one=nums.count(1)\\n        two=nums.count(2)\\n        for x in range(len(nums)):\\n            if two:\\n                nums.pop()\\n                nums.insert(0,2)\\n                two-=1\\n            elif one:\\n                nums.pop()\\n                nums.insert(0,1)\\n                one-=1\\n            else:\\n                nums.pop()\\n                nums.insert(0,0)",
                "codeTag": "Python3"
            },
            {
                "id": 2818098,
                "title": "java-counting-without-counting",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Without Counting | 1 Pass\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int ind0 = 0;\\n        int ind2 = nums.length-1;\\n        int ind = 0;\\n        while(ind <= ind2){\\n            if(nums[ind] == 0){\\n                nums[ind] = 1;\\n                nums[ind0++] = 0;\\n            }else if(nums[ind] == 2){\\n                while(ind2 > ind && nums[ind2] == 2){\\n                    ind2--;\\n                }\\n                if(nums[ind2] == 0){\\n                    nums[ind] = 1;\\n                    nums[ind0++] = 0;\\n                    nums[ind2--] = 2;\\n                }else{\\n                    nums[ind] = 1;\\n                    nums[ind2--] = 2;\\n                }\\n            }\\n            ind++;\\n        }\\n    }\\n}\\n```\\n\\n# Counting | 2 Pass\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int c0 = 0, c1 = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 0){\\n                c0++;\\n            }else if(nums[i] == 1){\\n                c1++;\\n            }\\n            nums[i] = 2;\\n        }\\n        for(int i = 0; i < c0 + c1; i++){\\n            if(i < c0){\\n                nums[i] = 0;\\n            }else{\\n                nums[i] = 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int ind0 = 0;\\n        int ind2 = nums.length-1;\\n        int ind = 0;\\n        while(ind <= ind2){\\n            if(nums[ind] == 0){\\n                nums[ind] = 1;\\n                nums[ind0++] = 0;\\n            }else if(nums[ind] == 2){\\n                while(ind2 > ind && nums[ind2] == 2){\\n                    ind2--;\\n                }\\n                if(nums[ind2] == 0){\\n                    nums[ind] = 1;\\n                    nums[ind0++] = 0;\\n                    nums[ind2--] = 2;\\n                }else{\\n                    nums[ind] = 1;\\n                    nums[ind2--] = 2;\\n                }\\n            }\\n            ind++;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int c0 = 0, c1 = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 0){\\n                c0++;\\n            }else if(nums[i] == 1){\\n                c1++;\\n            }\\n            nums[i] = 2;\\n        }\\n        for(int i = 0; i < c0 + c1; i++){\\n            if(i < c0){\\n                nums[i] = 0;\\n            }else{\\n                nums[i] = 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787787,
                "title": "sort-colors-cpp-easy-o-n-time-and-o-1-extra-space-solution",
                "content": "```class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int l=0,mid=0,r=nums.size()-1;\\n        while(mid<=r)\\n        {\\n            if(nums[mid]==1) mid++;\\n            else if(nums[mid]==0) \\n            {\\n                swap(nums[mid],nums[l]);\\n                l++;mid++;\\n            }\\n            else \\n            {\\n                swap(nums[mid],nums[r]);\\n                r--;           \\n            } \\n        }\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int l=0,mid=0,r=nums.size()-1;\\n        while(mid<=r)\\n        {\\n            if(nums[mid]==1) mid++;\\n            else if(nums[mid]==0) \\n            {\\n                swap(nums[mid],nums[l]);\\n                l++;mid++;\\n            }\\n            else \\n            {\\n                swap(nums[mid],nums[r]);\\n                r--;           \\n            } \\n        }\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2786089,
                "title": "c-dutch-national-flag-problem-o-n",
                "content": "*Dutch National Flag Problem*\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        \\n        int s = 0, e = nums.size() - 1;\\n        int mid = 0;\\n        \\n        while (mid <= e) {\\n            switch(nums[mid]) {\\n                case 0: \\n                    swap(nums[mid++], nums[s++]);\\n                    break;\\n                    \\n                case 1: \\n                    mid++;\\n                    break;\\n                    \\n                case 2:\\n                    swap(nums[mid], nums[e--]);\\n                    break;\\n            }\\n        }\\n \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```\\n\\n_Please upvote if you found it useful!_\\n\\n_Follow my **[Github](https://github.com/HimeshKohad)** for more such solutions and DSA content._",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        \\n        int s = 0, e = nums.size() - 1;\\n        int mid = 0;\\n        \\n        while (mid <= e) {\\n            switch(nums[mid]) {\\n                case 0: \\n                    swap(nums[mid++], nums[s++]);\\n                    break;\\n                    \\n                case 1: \\n                    mid++;\\n                    break;\\n                    \\n                case 2:\\n                    swap(nums[mid], nums[e--]);\\n                    break;\\n            }\\n        }\\n \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558828,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions-for-sort-colors",
                "content": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int start=0;\\n        int end=nums.length-1;\\n        int mid=0;\\n        while(start<=end && mid<=end)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums, start, mid);\\n                mid++;\\n                start++;\\n            }\\n            else if(nums[mid]==2)\\n            {\\n                swap(nums, end, mid);\\n                end--;\\n            }\\n            else mid++;\\n        }\\n    }\\n    public static void swap(int []nums, int i, int j)\\n    {\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n}\\n```\\n// Please vote my solution guys....",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        int start=0;\\n        int end=nums.length-1;\\n        int mid=0;\\n        while(start<=end && mid<=end)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums, start, mid);\\n                mid++;\\n                start++;\\n            }\\n            else if(nums[mid]==2)\\n            {\\n                swap(nums, end, mid);\\n                end--;\\n            }\\n            else mid++;\\n        }\\n    }\\n    public static void swap(int []nums, int i, int j)\\n    {\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509109,
                "title": "javascript-solution-with-3-methods-and-all-are-in-o-n",
                "content": "Two Pointer \\n\\n```\\nvar sortColors = function(nums) {\\n    let i = 0, j =nums.length-1;\\n    while(i <=j) {\\n        if (nums[j] === 0) {\\n            do {\\n                if(i >j) break\\n                nums.splice(j, 1);\\n                nums.unshift(0);\\n                ++i;\\n            } while (nums[j] === 0)\\n        } else if(nums[j] === 2) {\\n            do {\\n                if(i >j) break\\n                nums.splice(j,1);\\n                nums.push(2);\\n                --j;\\n            } while(nums[j] === 2)\\n        } else {\\n            do {\\n                if(i >j) break\\n                --j;\\n            } while(nums[j] === 1)\\n        }\\n    }\\n};\\n```\\n\\n\\nArray\\n```\\nvar sortColors = function(nums) {\\n    let zero = [], one = [], two = [];\\n    for (let num of nums) {\\n        if (num === 0) {\\n            zero.push(0)\\n        } else if (num === 1) {\\n            one.push(1)\\n        } else {\\n            two.push(2)\\n        }\\n    }\\n    nums.length =0\\n    nums.push(...zero)\\n    nums.push(...one)\\n    nums.push(...two)\\n};\\n```\\n\\n\\nHashmap & Array\\n```\\nvar sortColors = function(nums) {\\n    let mapping = {0:0, 1:0, 2:0};\\n    for (let num of nums) {\\n        mapping[num]++\\n    }\\n    nums.length =0\\n    nums.push(... Array(mapping[0]).fill(0))\\n    nums.push(...Array(mapping[1]).fill(1))\\n    nums.push(... Array(mapping[2]).fill(2))\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nvar sortColors = function(nums) {\\n    let i = 0, j =nums.length-1;\\n    while(i <=j) {\\n        if (nums[j] === 0) {\\n            do {\\n                if(i >j) break\\n                nums.splice(j, 1);\\n                nums.unshift(0);\\n                ++i;\\n            } while (nums[j] === 0)\\n        } else if(nums[j] === 2) {\\n            do {\\n                if(i >j) break\\n                nums.splice(j,1);\\n                nums.push(2);\\n                --j;\\n            } while(nums[j] === 2)\\n        } else {\\n            do {\\n                if(i >j) break\\n                --j;\\n            } while(nums[j] === 1)\\n        }\\n    }\\n};\\n```\n```\\nvar sortColors = function(nums) {\\n    let zero = [], one = [], two = [];\\n    for (let num of nums) {\\n        if (num === 0) {\\n            zero.push(0)\\n        } else if (num === 1) {\\n            one.push(1)\\n        } else {\\n            two.push(2)\\n        }\\n    }\\n    nums.length =0\\n    nums.push(...zero)\\n    nums.push(...one)\\n    nums.push(...two)\\n};\\n```\n```\\nvar sortColors = function(nums) {\\n    let mapping = {0:0, 1:0, 2:0};\\n    for (let num of nums) {\\n        mapping[num]++\\n    }\\n    nums.length =0\\n    nums.push(... Array(mapping[0]).fill(0))\\n    nums.push(...Array(mapping[1]).fill(1))\\n    nums.push(... Array(mapping[2]).fill(2))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2233108,
                "title": "c-all-approaches-sort-counting-sort-dutch-national-flag-algo",
                "content": "**Brute Force : Using Sort function (STL) \\nTime Complexity: O(nlogn)\\nSpace Complexity: O(1)**\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n    }\\n};\\n```\\n\\n**Better : using Counting Sort \\nTime Complexity: O(n+n)=O(n) (2 passes one for Frequency array and other for copying back to array)\\nSpace Complexity: O(size of max element in the array)**\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n       int maxx = *max_element(nums.begin(), nums.end());\\n        vector<int> count(maxx + 1, 0);\\n        for (int i = 0; i < nums.size(); i++) // freq array creation\\n        {\\n            count[nums[i]]++;\\n        }\\n        int i = 0, j = 0;\\n        while (i < maxx + 1)\\n        {\\n            if (count[i] > 0)\\n            {\\n                nums[j++] = i; // overwrite with sorted values\\n                count[i]--;\\n            }\\n            else\\n                i++;\\n        }\\n    }\\n};\\n```\\n\\n**Optimal : using Dutch National FLag (variation) \\nTime Complexity: O(n)\\nSpace Complexity: O(1)**\\n\\n**Dutch National Flag Algo (Approach) : 3 pointers used ( low, mid, high ) value\\u2019s left of low are 0\\'s values right of high are 2\\'s values between low and mid-1 are 1\\'s.**\\n\\n**Code :**\\n   ```\\n void sortColors(vector<int>& nums) {\\n        int low=0,high=nums.size()-1,mid=0;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n                swap(nums[mid++],nums[low++]);\\n            else if(nums[mid]==1)\\n                mid++;\\n            else if(nums[mid]==2)\\n                swap(nums[mid],nums[high--]);   \\n        }\\n    }\\n};\\n```\\n\\nPlease Upvote \\uD83D\\uDC4D\\uD83C\\uDFFB and Motivate \\uD83D\\uDD25",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n       int maxx = *max_element(nums.begin(), nums.end());\\n        vector<int> count(maxx + 1, 0);\\n        for (int i = 0; i < nums.size(); i++) // freq array creation\\n        {\\n            count[nums[i]]++;\\n        }\\n        int i = 0, j = 0;\\n        while (i < maxx + 1)\\n        {\\n            if (count[i] > 0)\\n            {\\n                nums[j++] = i; // overwrite with sorted values\\n                count[i]--;\\n            }\\n            else\\n                i++;\\n        }\\n    }\\n};\\n```\n```\\n void sortColors(vector<int>& nums) {\\n        int low=0,high=nums.size()-1,mid=0;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n                swap(nums[mid++],nums[low++]);\\n            else if(nums[mid]==1)\\n                mid++;\\n            else if(nums[mid]==2)\\n                swap(nums[mid],nums[high--]);   \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191923,
                "title": "easiest-solution-in-java-c-o-n-one-pass",
                "content": "**Code in Java**\\n```\\npublic void sortColors(int[] nums) {\\n        int l=0;\\n        int r=nums.length-1;\\n        while(l<r){\\n            if(nums[l] == 2) {\\n                swap(nums, l, r);\\n                r--;\\n            }\\n            else if(nums[l] == 1){\\n                int temp = l+1;\\n                while(temp < r && nums[temp] != 0) temp++;\\n                if(nums[temp] == 0) swap(nums, l, temp);\\n                l++;\\n            }\\n            else l++;\\n        }\\n    }\\n    private void swap(int[] nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n```\\n\\n**Code in C**\\n```\\nvoid swap(int* nums, int a, int b){\\n    int temp = nums[a];\\n    nums[a] = nums[b];\\n    nums[b] = temp;\\n    }\\n\\nvoid sortColors(int* nums, int numsSize){\\n    int l=0;\\n    int r=numsSize-1;\\n    while(l<r){\\n        if(nums[l] == 2) {\\n            swap(nums, l, r);\\n            r--;\\n        }\\n        else if(nums[l] == 1){\\n            int temp = l+1;\\n            while(temp < r && nums[temp] != 0) temp++;\\n            if(nums[temp] == 0) swap(nums, l, temp);\\n            l++;\\n        }\\n        else l++;\\n    }\\n}\\n```\\n\\n**Please upvote if the solution helped you**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\npublic void sortColors(int[] nums) {\\n        int l=0;\\n        int r=nums.length-1;\\n        while(l<r){\\n            if(nums[l] == 2) {\\n                swap(nums, l, r);\\n                r--;\\n            }\\n            else if(nums[l] == 1){\\n                int temp = l+1;\\n                while(temp < r && nums[temp] != 0) temp++;\\n                if(nums[temp] == 0) swap(nums, l, temp);\\n                l++;\\n            }\\n            else l++;\\n        }\\n    }\\n    private void swap(int[] nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n```\n```\\nvoid swap(int* nums, int a, int b){\\n    int temp = nums[a];\\n    nums[a] = nums[b];\\n    nums[b] = temp;\\n    }\\n\\nvoid sortColors(int* nums, int numsSize){\\n    int l=0;\\n    int r=numsSize-1;\\n    while(l<r){\\n        if(nums[l] == 2) {\\n            swap(nums, l, r);\\n            r--;\\n        }\\n        else if(nums[l] == 1){\\n            int temp = l+1;\\n            while(temp < r && nums[temp] != 0) temp++;\\n            if(nums[temp] == 0) swap(nums, l, temp);\\n            l++;\\n        }\\n        else l++;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2185206,
                "title": "javascript-fast-two-pointers-solution",
                "content": "```\\nfunction swap(arr, i, j) {\\n    let temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n}\\n// O(n) time | O(1) space\\nvar sortColors = function(arr) {\\n    let n = arr.length;\\n    let left = 0;\\n    let right = n - 1;\\n    let i = 0;\\n    \\n    while(i <= right) {\\n        // if the number is 2, then place it at the end, swapping it\\n        // with the element in the right index\\n        // decrement right by 1\\n        // here we don\\'t increment i because after the swapping\\n        // the element in position i may be a 0 (or a 2)\\n        // and in that case we should place it at the left index (or at the right)\\n        if(arr[i] == 2) {\\n            swap(arr, i, right);\\n            right--;\\n        }\\n        // if the number is 0, then place it at the beginning, swapping it with the element in the left index\\n        // increment left by 1\\n        // here we increment i by 1 because after the swapping\\n        // the element in position i must be a 1, since the index i\\n        // already went through left position\\n        else if(arr[i] == 0) {\\n            swap(arr, i, left);\\n            left++;\\n            i++;\\n        }\\n        // if the element is 1, just continue\\n        else {\\n            i++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nfunction swap(arr, i, j) {\\n    let temp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = temp;\\n}\\n// O(n) time | O(1) space\\nvar sortColors = function(arr) {\\n    let n = arr.length;\\n    let left = 0;\\n    let right = n - 1;\\n    let i = 0;\\n    \\n    while(i <= right) {\\n        // if the number is 2, then place it at the end, swapping it\\n        // with the element in the right index\\n        // decrement right by 1\\n        // here we don\\'t increment i because after the swapping\\n        // the element in position i may be a 0 (or a 2)\\n        // and in that case we should place it at the left index (or at the right)\\n        if(arr[i] == 2) {\\n            swap(arr, i, right);\\n            right--;\\n        }\\n        // if the number is 0, then place it at the beginning, swapping it with the element in the left index\\n        // increment left by 1\\n        // here we increment i by 1 because after the swapping\\n        // the element in position i must be a 1, since the index i\\n        // already went through left position\\n        else if(arr[i] == 0) {\\n            swap(arr, i, left);\\n            left++;\\n            i++;\\n        }\\n        // if the element is 1, just continue\\n        else {\\n            i++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2154039,
                "title": "best-approach-o-n-time-and-o-1-space-easy-implementation",
                "content": "![image](https://assets.leetcode.com/users/images/53058367-9eec-4739-82bd-d44f641ce0cc_1655278798.7682872.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int curr_element = 0;\\n        int next_zero = 0;\\n        int next_two = nums.size()-1;\\n        while(curr_element<=next_two)\\n        {\\n            if(nums[curr_element]==0)\\n            {\\n                swap(nums[curr_element],nums[next_zero]);\\n                curr_element++;\\n                next_zero++;\\n            }\\n            else if(nums[curr_element]==1)\\n            {\\n                curr_element++;\\n\\n            }\\n            else if(nums[curr_element]==2)\\n            {\\n                swap(nums[curr_element],nums[next_two]);\\n                next_two--;\\n            }\\n        }\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int curr_element = 0;\\n        int next_zero = 0;\\n        int next_two = nums.size()-1;\\n        while(curr_element<=next_two)\\n        {\\n            if(nums[curr_element]==0)\\n            {\\n                swap(nums[curr_element],nums[next_zero]);\\n                curr_element++;\\n                next_zero++;\\n            }\\n            else if(nums[curr_element]==1)\\n            {\\n                curr_element++;\\n\\n            }\\n            else if(nums[curr_element]==2)\\n            {\\n                swap(nums[curr_element],nums[next_two]);\\n                next_two--;\\n            }\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144720,
                "title": "visually-explained-easy-solution-o-n-two-approaches-optimization-using-dutch-flag-algorithm",
                "content": "A simple and fairly easy solution that requires three pointers which holds the number of 0\\'s, 1\\'s and 2\\'s since these are the only visible elements in the array we can count them and increment the respective pointers using if/else or switch cases and the iterate over the same array again and fill it up accordingly with the count from the pointers. \\n\\nMore explaination in the code inline\\n\\n```\\n\\t\\tint zeros = 0;\\n        int ones = 0;\\n        int twos = 0;\\n        \\n\\t\\t//Count the number of 0\\'s, 1\\'s and 2\\'s that appear in the array.\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if(nums[i] == 0)\\n                zeros++;\\n            else if(nums[i] == 1)\\n                ones++;\\n            else if(nums[i] == 2)\\n                twos++;\\n        }\\n        \\n\\t\\t//Now fill up the array with the information from the previous computation.\\n        for(int i = 0; i < nums.length; i++ )\\n        {\\n\\t\\t\\t//Exhaust all 0\\'s first\\n            if(zeros != 0)\\n            {\\n                nums[i] = 0;\\n                zeros--;\\n            }\\n\\t\\t\\t//Exhaust all 1\\'s once all 0\\'s have been exhausted\\n            else if(ones != 0)\\n            {\\n                nums[i] = 1;\\n                ones--;\\n            }\\n\\t\\t\\t//Exhaust all 2\\'s at last\\n            else\\n            {\\n                nums[i] = 2;\\n                twos--;\\n            }\\n        }\\n```\\n\\nIf you look this would be a O(2N) time complexity since we are making two passes.\\n1. To calculate the number of 0\\'s, 1\\'s and 2\\'s\\n2. To fill up the array with the calculated number of 0\\'s,1\\'s and 2\\'s.\\n\\nA better approach to this problem would be using the **Dutch Flag Algorithm**\\n\\nThe solution to this algorithm will require 3 pointers to iterate throughout the array, swapping the necessary elements.\\n\\n1. Create a low pointer at the beginning of the array and a high pointer at the end of the array.\\n2. Create a mid pointer that starts at the beginning of the array and iterates through each element.\\n3. **If the element at arr[mid] is a 2, then swap arr[mid] and arr[high] and decrease the high pointer by 1.**\\n4. **If the element at arr[mid] is a 0, then swap arr[mid] and arr[low] and increase the low and mid pointers by 1.**\\n5. **If the element at arr[mid] is a 1, don\\'t swap anything and just increase the mid pointer by 1.**\\n\\nEverything highlighted in **bold** are three important assumptions to follow above.\\n\\nAfter the entire array is sorted  the thing to look is that high pointer will always be at the start of all 2\\'s and mid pointer, low pointer will always be at the end of 1\\'s and 0\\'s.\\n\\n![image](https://assets.leetcode.com/users/images/0a94332d-f419-418d-84ad-a8714ed39eb0_1655071660.3559823.jpeg)\\n\\nOkay enough talk now lets look at the code -\\n\\n```\\n    public void sortColors(int[] nums) \\n    {\\n        \\n        //Dutch national flag algorithm\\n        \\n        int low = 0;\\n        int mid = 0;\\n        int high = nums.length - 1; \\n        \\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n                swap(mid++,low++,nums);\\n            else if(nums[mid] == 1)\\n                mid++;\\n            else\\n                swap(mid,high--,nums);\\n        }\\n    }\\n    \\n    private void swap(int a , int b, int[] nums)\\n    {\\n        //Neat little code to quickly swap without using the third variable and in one line.\\n        nums[b] = (nums[a] + nums[b]) - (nums[a] = nums[b]);\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint zeros = 0;\\n        int ones = 0;\\n        int twos = 0;\\n        \\n\\t\\t//Count the number of 0\\'s, 1\\'s and 2\\'s that appear in the array.\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if(nums[i] == 0)\\n                zeros++;\\n            else if(nums[i] == 1)\\n                ones++;\\n            else if(nums[i] == 2)\\n                twos++;\\n        }\\n        \\n\\t\\t//Now fill up the array with the information from the previous computation.\\n        for(int i = 0; i < nums.length; i++ )\\n        {\\n\\t\\t\\t//Exhaust all 0\\'s first\\n            if(zeros != 0)\\n            {\\n                nums[i] = 0;\\n                zeros--;\\n            }\\n\\t\\t\\t//Exhaust all 1\\'s once all 0\\'s have been exhausted\\n            else if(ones != 0)\\n            {\\n                nums[i] = 1;\\n                ones--;\\n            }\\n\\t\\t\\t//Exhaust all 2\\'s at last\\n            else\\n            {\\n                nums[i] = 2;\\n                twos--;\\n            }\\n        }\\n```\n```\\n    public void sortColors(int[] nums) \\n    {\\n        \\n        //Dutch national flag algorithm\\n        \\n        int low = 0;\\n        int mid = 0;\\n        int high = nums.length - 1; \\n        \\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n                swap(mid++,low++,nums);\\n            else if(nums[mid] == 1)\\n                mid++;\\n            else\\n                swap(mid,high--,nums);\\n        }\\n    }\\n    \\n    private void swap(int a , int b, int[] nums)\\n    {\\n        //Neat little code to quickly swap without using the third variable and in one line.\\n        nums[b] = (nums[a] + nums[b]) - (nums[a] = nums[b]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2132777,
                "title": "python-counting-sort-o-n",
                "content": "```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        bins = [0 for _ in range(3)]\\n        for col in nums:\\n            bins[col] += 1\\n        for i in range(len(nums)):\\n            if bins[0]:\\n                nums[i] = 0\\n                bins[0] -= 1\\n            elif bins[1]:\\n                nums[i] = 1\\n                bins[1] -= 1\\n            else:\\n                nums[i] = 2\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        bins = [0 for _ in range(3)]\\n        for col in nums:\\n            bins[col] += 1\\n        for i in range(len(nums)):\\n            if bins[0]:\\n                nums[i] = 0\\n                bins[0] -= 1\\n            elif bins[1]:\\n                nums[i] = 1\\n                bins[1] -= 1\\n            else:\\n                nums[i] = 2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074657,
                "title": "o-n-solution-in-cpp-without-any-extra-space",
                "content": "Since we only have 3 cases of input, we can just keep the count of each type of element, that is 0,1 and 2...\\nNow, we simply loop using this three counts and fill our original array...\\n\\n**Pls Upvote this thread if you found this code helpful**\\n\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int count0=0, count1=0, count2=0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]==0) count0++;\\n            if(nums[i]==1) count1++;\\n            if(nums[i]==2) count2++;\\n        }\\n        \\n        for(int i=0;i<count0;i++) nums[i]=0;\\n        for(int i=count0;i<(count1+count0);i++) nums[i]=1;\\n        for(int i=(count1+count0);i<nums.size();i++) nums[i]=2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int count0=0, count1=0, count2=0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]==0) count0++;\\n            if(nums[i]==1) count1++;\\n            if(nums[i]==2) count2++;\\n        }\\n        \\n        for(int i=0;i<count0;i++) nums[i]=0;\\n        for(int i=count0;i<(count1+count0);i++) nums[i]=1;\\n        for(int i=(count1+count0);i<nums.size();i++) nums[i]=2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038657,
                "title": "easiest-and-most-efficient-solution-java-c",
                "content": "class Solution {\\n    public void sortColors(int[] arr) {\\n        \\n        int low = 0;\\n        int mid = 0;\\n        int high = arr.length - 1;\\n        \\n        while(mid<=high){\\n            if(arr[mid] == 0){\\n                int temp = arr[mid];\\n                arr[mid] = arr[low];\\n                arr[low] = temp;\\n                mid++;\\n                low++;\\n            }else if(arr[mid]==1){\\n                mid++;\\n            }else{\\n                int temp = arr[mid];\\n                arr[mid] = arr[high];\\n                arr[high] = temp;\\n                high--;\\n                    \\n            }\\n        }\\n    }\\n}\\n# Press the up button if u understand it",
                "solutionTags": [],
                "code": "class Solution {\\n    public void sortColors(int[] arr) {\\n        \\n        int low = 0;\\n        int mid = 0;\\n        int high = arr.length - 1;\\n        \\n        while(mid<=high){\\n            if(arr[mid] == 0){\\n                int temp = arr[mid];\\n                arr[mid] = arr[low];\\n                arr[low] = temp;\\n                mid++;\\n                low++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1819217,
                "title": "easy-concise-java-solution",
                "content": "```\\nclass Solution {\\n    public void swap(int[] nums,int i,int j)\\n    {\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public void sortColors(int[] nums) {\\n        int n=nums.length;\\n        int i=0,j=0,k=n-1;\\n        \\n        while(j<=k)\\n        {\\n            if(nums[j]==0)\\n            {\\n                swap(nums,i,j);\\n                i++;\\n                j++;\\n            }\\n            else if(nums[j]==1)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                swap(nums,j,k);\\n                k--;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public void swap(int[] nums,int i,int j)\\n    {\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public void sortColors(int[] nums) {\\n        int n=nums.length;\\n        int i=0,j=0,k=n-1;\\n        \\n        while(j<=k)\\n        {\\n            if(nums[j]==0)\\n            {\\n                swap(nums,i,j);\\n                i++;\\n                j++;\\n            }\\n            else if(nums[j]==1)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                swap(nums,j,k);\\n                k--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815602,
                "title": "c-solution-using-dutch-national-flag-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int l=0,mid=0,r=nums.size()-1;\\n        while(mid<=r)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[l],nums[mid]);\\n                l++;\\n            }\\n            else if(nums[mid]==2)\\n            {\\n                swap(nums[r],nums[mid]);\\n                r--;\\n                continue;\\n            }\\n            mid++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int l=0,mid=0,r=nums.size()-1;\\n        while(mid<=r)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[l],nums[mid]);\\n                l++;\\n            }\\n            else if(nums[mid]==2)\\n            {\\n                swap(nums[r],nums[mid]);\\n                r--;\\n                continue;\\n            }\\n            mid++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721447,
                "title": "sort-colors-0ms-solved-in-c-easy-explaination",
                "content": "**Sort Colors**\\nUsed A really simple way to solve it.\\n\\n1. Create A map `map<int,int>m` and then \\n2. traverse the array- count num of zeros, ones and twos.\\n3. then store the value of each value.\\n4. empty the existing vector `v.clear()`\\n5. push_back(0) ,  push_back(1) ,   push_back(2)  and you are done in `O(N)` \\n\\nUPVOTE :)\\n\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& v) {\\n    map<int,int>m;\\n    for(int x:v)\\n    {\\n        m[x]=m[x]+1;\\n    }\\n    int zero=0,one=0,two=0;\\n    for(auto x:m)\\n    { \\n       if(x.first == 0)\\n       {\\n           zero=x.second;\\n       }\\n        else if(x.first == 1)\\n       {\\n           one=x.second;\\n       }\\n         else if(x.first == 2)\\n       {\\n           two=x.second;\\n       }\\n    }\\n    v.clear();\\n    for(int i=0;i<zero;i++)\\n    {\\n        v.push_back(0);\\n    }\\n      for(int i=0;i<one;i++)\\n    {\\n        v.push_back(1);\\n    }\\n      for(int i=0;i<two;i++)\\n    {\\n        v.push_back(2);\\n    }\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& v) {\\n    map<int,int>m;\\n    for(int x:v)\\n    {\\n        m[x]=m[x]+1;\\n    }\\n    int zero=0,one=0,two=0;\\n    for(auto x:m)\\n    { \\n       if(x.first == 0)\\n       {\\n           zero=x.second;\\n       }\\n        else if(x.first == 1)\\n       {\\n           one=x.second;\\n       }\\n         else if(x.first == 2)\\n       {\\n           two=x.second;\\n       }\\n    }\\n    v.clear();\\n    for(int i=0;i<zero;i++)\\n    {\\n        v.push_back(0);\\n    }\\n      for(int i=0;i<one;i++)\\n    {\\n        v.push_back(1);\\n    }\\n      for(int i=0;i<two;i++)\\n    {\\n        v.push_back(2);\\n    }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627248,
                "title": "perfect-walk-through-solutions-for-interviews",
                "content": "Easy walk through for making proper impression on the interviewer.\\nFirstly, talking about the **method 1 : Counting Sort Method**\\n\\n-> In this method, we simply need to traverse the array and count number of occurrences of 0, 1 and 2.\\n-> Then, doing in-place operation by placing 0\\'s upto count0, 1\\'s upto count1 and 2\\'s upto count2.\\n\\n```\\nint c0=0, c1=0, c2=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == 0)\\n                c0++;\\n            else if(nums[i] == 1)\\n                c1++;\\n            else\\n                c2++;\\n        }\\n        int i = 0;\\n        while(c0--)\\n            nums[i++] = 0;\\n        while(c1--)\\n            nums[i++] = 1;\\n        while(c2--)\\n            nums[i++] = 2;\\n```\\n\\n\\n**Method 2 : Dutch National Flag Algorithm**\\n\\n-> In this method, we consider 3 variables vis. low, mid, high\\n-> [0, low) => 0\\n-> [low, mid) => 1\\n-> [high, ) => 2\\n\\n```\\nint low=0, mid=low, high=n-1;\\n        while(mid<=high){\\n            if(nums[mid] == 0)\\n                swap(nums[low++], nums[mid++]);\\n            else if(nums[mid] == 1)\\n                mid++;\\n            else\\n                swap(nums[high--], nums[mid]);\\n        }\\n```\\n\\n\\n**Method 3 : Pure Observational Method**\\n-> This will be very impressive if you tell this approach to interviewer as it is simply based on observation and testing.\\n\\n```\\nint c0=-1, c1=-1, c2=-1;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == 0)\\n                nums[++c2]=2, nums[++c1]=1, nums[++c0]=0;\\n            else if(nums[i] == 1)\\n                nums[++c2]=2, nums[++c1]=1;\\n            else\\n                nums[++c2]=2;\\n        }\\n```\\n\\n\\n**Give an upvote, Good Luck for your Interviews.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint c0=0, c1=0, c2=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == 0)\\n                c0++;\\n            else if(nums[i] == 1)\\n                c1++;\\n            else\\n                c2++;\\n        }\\n        int i = 0;\\n        while(c0--)\\n            nums[i++] = 0;\\n        while(c1--)\\n            nums[i++] = 1;\\n        while(c2--)\\n            nums[i++] = 2;\\n```\n```\\nint low=0, mid=low, high=n-1;\\n        while(mid<=high){\\n            if(nums[mid] == 0)\\n                swap(nums[low++], nums[mid++]);\\n            else if(nums[mid] == 1)\\n                mid++;\\n            else\\n                swap(nums[high--], nums[mid]);\\n        }\\n```\n```\\nint c0=-1, c1=-1, c2=-1;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == 0)\\n                nums[++c2]=2, nums[++c1]=1, nums[++c0]=0;\\n            else if(nums[i] == 1)\\n                nums[++c2]=2, nums[++c1]=1;\\n            else\\n                nums[++c2]=2;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1619943,
                "title": "java-easy-solution-three-pointers",
                "content": "**Upvote if you like the solution :)**\\n```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        //three pointers method/A variation of Dutch National Flag Algorithm\\n        \\n        int low=0;\\n        int mid=0;\\n        int high=nums.length-1;\\n        int temp;\\n        \\n        /*Idea- when nums[mid]=1  --->  increase mid pointer\\n                 when nums[mid]=0 ----> swap it with low pointer and low++ , mid++\\n                 when nums[mid]=2 ----> swap with high and high--,mid++ */\\n        \\n        while(mid<=high){\\n            \\n            switch(nums[mid]){\\n                case 0:\\n                    temp = nums[low];\\n                    nums[low]=nums[mid];\\n                    nums[mid]=temp;\\n                    low+=1;\\n                    mid+=1;\\n                    break;\\n                    \\n                case 1:\\n                    mid+=1;\\n                    break;\\n                    \\n                case 2:\\n                    temp = nums[mid];\\n                    nums[mid]=nums[high];\\n                    nums[high]=temp;\\n                    \\n                    high--;\\n                    \\n                    break;\\n            }\\n        }\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n        //three pointers method/A variation of Dutch National Flag Algorithm\\n        \\n        int low=0;\\n        int mid=0;\\n        int high=nums.length-1;\\n        int temp;\\n        \\n        /*Idea- when nums[mid]=1  --->  increase mid pointer\\n                 when nums[mid]=0 ----> swap it with low pointer and low++ , mid++\\n                 when nums[mid]=2 ----> swap with high and high--,mid++ */\\n        \\n        while(mid<=high){\\n            \\n            switch(nums[mid]){\\n                case 0:\\n                    temp = nums[low];\\n                    nums[low]=nums[mid];\\n                    nums[mid]=temp;\\n                    low+=1;\\n                    mid+=1;\\n                    break;\\n                    \\n                case 1:\\n                    mid+=1;\\n                    break;\\n                    \\n                case 2:\\n                    temp = nums[mid];\\n                    nums[mid]=nums[high];\\n                    nums[high]=temp;\\n                    \\n                    high--;\\n                    \\n                    break;\\n            }\\n        }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604340,
                "title": "0ms-100-faster-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n          int i=0,z=0,o=0;\\n        for( i=0;i<nums.length;i++)\\n            {\\n            if(nums[i]==0)z++;\\n            if(nums[i]==1)o++;\\n            }\\n        for(i=0;i<z;i++)\\n            nums[i]=0;\\n        for(i=z;i<(o+z) ;i++)\\n            nums[i]=1;\\n        for(i=(o+z) ;i<nums.length;i++)\\n            nums[i]=2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void sortColors(int[] nums) {\\n          int i=0,z=0,o=0;\\n        for( i=0;i<nums.length;i++)\\n            {\\n            if(nums[i]==0)z++;\\n            if(nums[i]==1)o++;\\n            }\\n        for(i=0;i<z;i++)\\n            nums[i]=0;\\n        for(i=z;i<(o+z) ;i++)\\n            nums[i]=1;\\n        for(i=(o+z) ;i<nums.length;i++)\\n            nums[i]=2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571854,
                "title": "100-faster-java-solution-with-one-loop-only",
                "content": "**Approach is simple:**\\n\\nif current element= 0 send it to left\\nor\\nif  current element=2 send it to right, \\nor\\nif  current element=1 then do nothing(skip current element).\\n\\n```\\nclass Solution {\\n    \\npublic static void sortColors(int[] arr) {\\nint l=0;\\nint m=0; \\nint h=arr.length-1;\\nwhile(m<=h)\\n{\\n    if(arr[m]==0){ //element is 0\\n        swap(arr,l,m);\\n        l++;\\n        m++;\\n    } else if(arr[m]==2){\\n        swap(arr,m,h);\\n        h--;\\n    }\\n    else m++;\\n}\\n  }\\n  \\n private static void swap(int[] array, int i, int j) {\\n    int temp = array[i];\\n    array[i] = array[j];\\n    array[j] = temp;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic static void sortColors(int[] arr) {\\nint l=0;\\nint m=0; \\nint h=arr.length-1;\\nwhile(m<=h)\\n{\\n    if(arr[m]==0){ //element is 0\\n        swap(arr,l,m);\\n        l++;\\n        m++;\\n    } else if(arr[m]==2){\\n        swap(arr,m,h);\\n        h--;\\n    }\\n    else m++;\\n}\\n  }\\n  \\n private static void swap(int[] array, int i, int j) {\\n    int temp = array[i];\\n    array[i] = array[j];\\n    array[j] = temp;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563366,
                "title": "python-commented-solution",
                "content": "```\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # start => place next to \\'0\\'s end or first \\'1\\' index, mid => place at unknown value from start (after \\'1\\' index) , end => unkown value from end (before 2)\\n        # [00001111XXXXXXX22222]\\n        start = mid = 0\\n        end = len(nums) -1\\n        while mid <= end:\\n            if nums[mid] == 0:\\n                nums[mid],nums[start] = nums[start],nums[mid]\\n                mid+=1 # mid is always at unknown ie. X\\n                start +=1 # start is always at last \\'0\\' index + 1 or first \\'1\\' index\\n            elif nums[mid] == 2:\\n                nums[mid],nums[end] = nums[end],nums[mid]\\n                end -=1 # end is always at unknown ie. X\\n            else:\\n                mid +=1\\n        return nums\\n\\t\\t# like if you find it useful\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # start => place next to \\'0\\'s end or first \\'1\\' index, mid => place at unknown value from start (after \\'1\\' index) , end => unkown value from end (before 2)\\n        # [00001111XXXXXXX22222]\\n        start = mid = 0\\n        end = len(nums) -1\\n        while mid <= end:\\n            if nums[mid] == 0:\\n                nums[mid],nums[start] = nums[start],nums[mid]\\n                mid+=1 # mid is always at unknown ie. X\\n                start +=1 # start is always at last \\'0\\' index + 1 or first \\'1\\' index\\n            elif nums[mid] == 2:\\n                nums[mid],nums[end] = nums[end],nums[mid]\\n                end -=1 # end is always at unknown ie. X\\n            else:\\n                mid +=1\\n        return nums\\n\\t\\t# like if you find it useful\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1568101,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1743445,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1569592,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1576778,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1566548,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1738042,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1804719,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1566068,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1571173,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1568895,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1568101,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1743445,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1569592,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1576778,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1566548,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1738042,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1804719,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1566068,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1571173,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 1568895,
                "content": [
                    {
                        "username": "timkillis",
                        "content": "I had a hard time grasping this one so I thought I\\'d write it down, maybe it will help you too.\\n\\nIterate over the array, maintaining two pointers, one at the \"low\" index, 0, and one at the \"high\", nums.length - 1.\\n\\nEverything to the left of low in the array and everything to the right of high in the array will be assumed sorted. As we iterate through the array, we update our pointers, taking account for two cases\\n\\nIf the index in the array is equal to 0, we swap that with our current low index and then increment the low index, since we know that everything to the left of that index is properly sorted.\\n\\nElse if the index in the array is equal to 2, we swap that with our current high index and decrement the high index, since everything to right of the high index is sorted. Also take care in this case to decrement i since we will want to reconsider the inserted element.\\n\\nWe\\'ve accounted for if the indexes are 0 or 2, the only other option is if the index is a 1, in which case we will just leave it in place.\\n\\nOur loop ends when we meet the high index, since we know everything to the right of high is properly sorted.\\n"
                    },
                    {
                        "username": "SamareshDas",
                        "content": "You became a life saver"
                    },
                    {
                        "username": "knotri",
                        "content": "[@_tarunreddy_](/_tarunreddy_) array[index] == 0"
                    },
                    {
                        "username": "_tarunreddy_",
                        "content": "what do you mean by \"If the index in the array is equal to 0\""
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "the task is to bring all zeros to left and all twos to right. that\\'s it\\n\\ndetailed hint below\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n1)- use three pointers one for left end , one for right end and one for iteration.\\n2)-if you see 0 swap it with left pointer and increase the left pointer by one.\\n3)-if you see 2 swap it with right pointer and decrease right pointer by one.\\n4)-else increase the iterating pointer.\\n5)-run this loop while the iterating pointer<=right pointer.\\nright pointer=n-1\\nleft pointer=0\\niterating pointer =0 runs while it is<=right pointer."
                    },
                    {
                        "username": "SalvadorDali",
                        "content": "Example of overcomplication for a sake of overcomplication.\\n\\nNo matter how the one pass solution is implemented, it will be 2-3 times slower than the intuitive 2 pass solution. It provides zero benefits: being one pass it is not a streaming algorithm as it needs to access elements from some other positions.\\n\\nOn the other hand the drawbacks are clear: complex to understand, non-intuitive, 2-3 times slower. \\n\\nBoth counting and this take O(1) memory."
                    },
                    {
                        "username": "martynov-94",
                        "content": "Like most problems on this site, it's for the sake of training. You don't go to gym because you need to carry some heavy objects from one place to another, right? You lift them because you want to train your muscles.\n\nMost of the times when I open a comment section, I see complaints about how impractical the problem is. But when you're pressed to find some non-obvious solution, you need to tackle the problem from various angles, and you get much better understanding of how things work under the hood. It's good to find different approaches, even if it's not the most optimised. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/8aac4b91-e82f-4123-8239-c390600402d5_1653064303.0474055.jpeg)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "psonlinux",
                        "content": "This post explained the working with proof for O(n) solution .\\nhttp://users.monash.edu/~lloyd/tildeAlgDS/Sort/Flag/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "xAdvitya",
                        "content": "Study about DNF algorithm "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For those who don\\'t know : DNF stands for Dutch National Flag Algorithm"
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "For DNF it shows time limit exeed"
                    },
                    {
                        "username": "betrayy",
                        "content": "I second this. It\\'s a famous algorithm"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "I acually solved it using the library sort().\\n\\nnow i feel bad.  I am going to try to solve it without now."
                    },
                    {
                        "username": "talibmaster99",
                        "content": "[@UNDeF1ND1](/UNDeF1ND1) yay"
                    },
                    {
                        "username": "UNDeF1ND1",
                        "content": "Update:   I did it.  I no longer feel bad  "
                    },
                    {
                        "username": "its_dark",
                        "content": "can someone please post the one-pass solution that uses constant space .\\nI have been able to do it in two pass only."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "lettuce",
                        "content": "It seems as though every time I run the same code I may get a vastly different runtime depending on the time or day I run it."
                    },
                    {
                        "username": "learningToCode",
                        "content": "    def sortColors(self, nums):\\n        nums[:] = [0]*nums.count(0) + [1]*nums.count(1) + [2]*nums.count(2)"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@youpsla](/youpsla) \\nits not inplace you are creating new array"
                    },
                    {
                        "username": "youpsla",
                        "content": "WIth some improvements:\n``` \ndef sortColors(self, nums: List[int]) -> None:\n        len_nums = len(nums)\n        red = nums.count(0)\n        white = nums.count(1)\n\n        nums[:] = [0]*red + [1]*white + [2]*(len_nums - (red+white))\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "jesus...... u make others look stupid"
                    },
                    {
                        "username": "iamrdwn",
                        "content": "This made me chuckle. Genius!\\n"
                    }
                ]
            },
            {
                "id": 2015872,
                "content": [
                    {
                        "username": "GeForceGroot",
                        "content": "I actually solved it using selection sort. it\\'s great and easy approach for this problem."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "i solved it using bubble sort,its fine right?\\n"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[Link to Solution](https://youtu.be/cr1OUfCRuD8):\\n\\n\\n"
                    },
                    {
                        "username": "baojialiang",
                        "content": "In this sort color question, it only tells us to separate the different colors by sorting, but it does not mention we need to sort the colors exactly according to the size of the color numbers.\\n\\nFor instance, if the input is {1, 2, 1,  0}, the result can be {1,1, 2, 0}. But the OJ answer is only {0, 1, 1, 2}, which does not make sense, because {1, 2, 1,  0} has already separated different color, correct?"
                    },
                    {
                        "username": "sabka_bwb",
                        "content": "Problem Statement states tha order in which the colors are to be arranged...\\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, WITH THE COLORS IN THE ORDER RED, WHITE AND BLUE."
                    },
                    {
                        "username": "navneet1083",
                        "content": "normal `sort` would have worked for this problem, isn\\'t it !!!"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        int right=a.size()-1;\\n        int len=a.size();\\n        int left=0;\\n        int i=0;\\n        while(i<=right){\\n                cout<<endl<<\"S T E P\"<<endl;\\n                for(int i=0;i<len;i++){\\n                    cout<<a[i]<<\" \";\\n                }\\n                cout<<endl;\\n\\n                if (a[i] == 0) {\\n                    swap(a[i],a[left]);\\n                    left=left+1;\\n                    i=i+1;\\n                }\\n                else if(a[i]==2){\\n                    swap(a[i],a[right]);\\n                    right=right-1;\\n                }\\n                else{\\n                    i=i+1;\\n                }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "We use the Dutch National Flag Algorithm to solve this question. The steps to the following are given below:\\n\\nStep 1) Take three pointers named low, mid and high, where low and mid=0 and high = a.size()-1.\\n\\nStep 2) Now, we will solve the question in the assumption that a part of the array is already sorted. (low to mid-1 already contains all 0s, high to end of array already contains all 2s and only the mid portion needs to be sorted)\\n\\nStep 3) Hence, we will apply a while loop till mid<=high.\\n\\nStep 4) If element at mid (initially index 0)==0, then we will simply swap mid element with low element(which is also initially at index 0) and increment both mid and low.\\n\\nStep 5) If mid == 1, then we can say that array is already in its sorted position and increment mid.\\n\\nStep 6) If mid == 2 then we will swap mid with high in order to get back 2 to its destined sorted position and decrement high.\\n\\nSolution:\\nhttps://leetcode.com/problems/sort-colors/solutions/4071342/step-by-step-dutch-national-flag-algo/"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "if you don't know any of the approach then use any sorting algorithm to sort it \nin my case I used quicksort(which implemented internally in Collection framework java)"
                    },
                    {
                        "username": "rushichitte1998",
                        "content": "use Doutch National flag algorithm its also known as 3 pointer algorithm"
                    },
                    {
                        "username": "Aditya_179",
                        "content": "i solved this using bubble sort, is this a right approach to solve this problem?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "yes you can solve it using it but it is the brute force approach ......\\nthe better approach is first count all the o\\'s , 1\\'s and 2\\'s then according fill 0,1,2 in the array acc. to their counts in the order 012........\\nthe final most optimal approach is DNF algo (dutch national flag ) refer Stiver on yt for that solution"
                    },
                    {
                        "username": "mattsthilaire1",
                        "content": "Apparently selection sort works here too lol "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Counting sort ftw"
                    }
                ]
            },
            {
                "id": 1573917,
                "content": [
                    {
                        "username": "GeForceGroot",
                        "content": "I actually solved it using selection sort. it\\'s great and easy approach for this problem."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "i solved it using bubble sort,its fine right?\\n"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[Link to Solution](https://youtu.be/cr1OUfCRuD8):\\n\\n\\n"
                    },
                    {
                        "username": "baojialiang",
                        "content": "In this sort color question, it only tells us to separate the different colors by sorting, but it does not mention we need to sort the colors exactly according to the size of the color numbers.\\n\\nFor instance, if the input is {1, 2, 1,  0}, the result can be {1,1, 2, 0}. But the OJ answer is only {0, 1, 1, 2}, which does not make sense, because {1, 2, 1,  0} has already separated different color, correct?"
                    },
                    {
                        "username": "sabka_bwb",
                        "content": "Problem Statement states tha order in which the colors are to be arranged...\\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, WITH THE COLORS IN THE ORDER RED, WHITE AND BLUE."
                    },
                    {
                        "username": "navneet1083",
                        "content": "normal `sort` would have worked for this problem, isn\\'t it !!!"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        int right=a.size()-1;\\n        int len=a.size();\\n        int left=0;\\n        int i=0;\\n        while(i<=right){\\n                cout<<endl<<\"S T E P\"<<endl;\\n                for(int i=0;i<len;i++){\\n                    cout<<a[i]<<\" \";\\n                }\\n                cout<<endl;\\n\\n                if (a[i] == 0) {\\n                    swap(a[i],a[left]);\\n                    left=left+1;\\n                    i=i+1;\\n                }\\n                else if(a[i]==2){\\n                    swap(a[i],a[right]);\\n                    right=right-1;\\n                }\\n                else{\\n                    i=i+1;\\n                }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "We use the Dutch National Flag Algorithm to solve this question. The steps to the following are given below:\\n\\nStep 1) Take three pointers named low, mid and high, where low and mid=0 and high = a.size()-1.\\n\\nStep 2) Now, we will solve the question in the assumption that a part of the array is already sorted. (low to mid-1 already contains all 0s, high to end of array already contains all 2s and only the mid portion needs to be sorted)\\n\\nStep 3) Hence, we will apply a while loop till mid<=high.\\n\\nStep 4) If element at mid (initially index 0)==0, then we will simply swap mid element with low element(which is also initially at index 0) and increment both mid and low.\\n\\nStep 5) If mid == 1, then we can say that array is already in its sorted position and increment mid.\\n\\nStep 6) If mid == 2 then we will swap mid with high in order to get back 2 to its destined sorted position and decrement high.\\n\\nSolution:\\nhttps://leetcode.com/problems/sort-colors/solutions/4071342/step-by-step-dutch-national-flag-algo/"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "if you don't know any of the approach then use any sorting algorithm to sort it \nin my case I used quicksort(which implemented internally in Collection framework java)"
                    },
                    {
                        "username": "rushichitte1998",
                        "content": "use Doutch National flag algorithm its also known as 3 pointer algorithm"
                    },
                    {
                        "username": "Aditya_179",
                        "content": "i solved this using bubble sort, is this a right approach to solve this problem?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "yes you can solve it using it but it is the brute force approach ......\\nthe better approach is first count all the o\\'s , 1\\'s and 2\\'s then according fill 0,1,2 in the array acc. to their counts in the order 012........\\nthe final most optimal approach is DNF algo (dutch national flag ) refer Stiver on yt for that solution"
                    },
                    {
                        "username": "mattsthilaire1",
                        "content": "Apparently selection sort works here too lol "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Counting sort ftw"
                    }
                ]
            },
            {
                "id": 1571174,
                "content": [
                    {
                        "username": "GeForceGroot",
                        "content": "I actually solved it using selection sort. it\\'s great and easy approach for this problem."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "i solved it using bubble sort,its fine right?\\n"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[Link to Solution](https://youtu.be/cr1OUfCRuD8):\\n\\n\\n"
                    },
                    {
                        "username": "baojialiang",
                        "content": "In this sort color question, it only tells us to separate the different colors by sorting, but it does not mention we need to sort the colors exactly according to the size of the color numbers.\\n\\nFor instance, if the input is {1, 2, 1,  0}, the result can be {1,1, 2, 0}. But the OJ answer is only {0, 1, 1, 2}, which does not make sense, because {1, 2, 1,  0} has already separated different color, correct?"
                    },
                    {
                        "username": "sabka_bwb",
                        "content": "Problem Statement states tha order in which the colors are to be arranged...\\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, WITH THE COLORS IN THE ORDER RED, WHITE AND BLUE."
                    },
                    {
                        "username": "navneet1083",
                        "content": "normal `sort` would have worked for this problem, isn\\'t it !!!"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        int right=a.size()-1;\\n        int len=a.size();\\n        int left=0;\\n        int i=0;\\n        while(i<=right){\\n                cout<<endl<<\"S T E P\"<<endl;\\n                for(int i=0;i<len;i++){\\n                    cout<<a[i]<<\" \";\\n                }\\n                cout<<endl;\\n\\n                if (a[i] == 0) {\\n                    swap(a[i],a[left]);\\n                    left=left+1;\\n                    i=i+1;\\n                }\\n                else if(a[i]==2){\\n                    swap(a[i],a[right]);\\n                    right=right-1;\\n                }\\n                else{\\n                    i=i+1;\\n                }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "We use the Dutch National Flag Algorithm to solve this question. The steps to the following are given below:\\n\\nStep 1) Take three pointers named low, mid and high, where low and mid=0 and high = a.size()-1.\\n\\nStep 2) Now, we will solve the question in the assumption that a part of the array is already sorted. (low to mid-1 already contains all 0s, high to end of array already contains all 2s and only the mid portion needs to be sorted)\\n\\nStep 3) Hence, we will apply a while loop till mid<=high.\\n\\nStep 4) If element at mid (initially index 0)==0, then we will simply swap mid element with low element(which is also initially at index 0) and increment both mid and low.\\n\\nStep 5) If mid == 1, then we can say that array is already in its sorted position and increment mid.\\n\\nStep 6) If mid == 2 then we will swap mid with high in order to get back 2 to its destined sorted position and decrement high.\\n\\nSolution:\\nhttps://leetcode.com/problems/sort-colors/solutions/4071342/step-by-step-dutch-national-flag-algo/"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "if you don't know any of the approach then use any sorting algorithm to sort it \nin my case I used quicksort(which implemented internally in Collection framework java)"
                    },
                    {
                        "username": "rushichitte1998",
                        "content": "use Doutch National flag algorithm its also known as 3 pointer algorithm"
                    },
                    {
                        "username": "Aditya_179",
                        "content": "i solved this using bubble sort, is this a right approach to solve this problem?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "yes you can solve it using it but it is the brute force approach ......\\nthe better approach is first count all the o\\'s , 1\\'s and 2\\'s then according fill 0,1,2 in the array acc. to their counts in the order 012........\\nthe final most optimal approach is DNF algo (dutch national flag ) refer Stiver on yt for that solution"
                    },
                    {
                        "username": "mattsthilaire1",
                        "content": "Apparently selection sort works here too lol "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Counting sort ftw"
                    }
                ]
            },
            {
                "id": 1780741,
                "content": [
                    {
                        "username": "GeForceGroot",
                        "content": "I actually solved it using selection sort. it\\'s great and easy approach for this problem."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "i solved it using bubble sort,its fine right?\\n"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[Link to Solution](https://youtu.be/cr1OUfCRuD8):\\n\\n\\n"
                    },
                    {
                        "username": "baojialiang",
                        "content": "In this sort color question, it only tells us to separate the different colors by sorting, but it does not mention we need to sort the colors exactly according to the size of the color numbers.\\n\\nFor instance, if the input is {1, 2, 1,  0}, the result can be {1,1, 2, 0}. But the OJ answer is only {0, 1, 1, 2}, which does not make sense, because {1, 2, 1,  0} has already separated different color, correct?"
                    },
                    {
                        "username": "sabka_bwb",
                        "content": "Problem Statement states tha order in which the colors are to be arranged...\\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, WITH THE COLORS IN THE ORDER RED, WHITE AND BLUE."
                    },
                    {
                        "username": "navneet1083",
                        "content": "normal `sort` would have worked for this problem, isn\\'t it !!!"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        int right=a.size()-1;\\n        int len=a.size();\\n        int left=0;\\n        int i=0;\\n        while(i<=right){\\n                cout<<endl<<\"S T E P\"<<endl;\\n                for(int i=0;i<len;i++){\\n                    cout<<a[i]<<\" \";\\n                }\\n                cout<<endl;\\n\\n                if (a[i] == 0) {\\n                    swap(a[i],a[left]);\\n                    left=left+1;\\n                    i=i+1;\\n                }\\n                else if(a[i]==2){\\n                    swap(a[i],a[right]);\\n                    right=right-1;\\n                }\\n                else{\\n                    i=i+1;\\n                }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "We use the Dutch National Flag Algorithm to solve this question. The steps to the following are given below:\\n\\nStep 1) Take three pointers named low, mid and high, where low and mid=0 and high = a.size()-1.\\n\\nStep 2) Now, we will solve the question in the assumption that a part of the array is already sorted. (low to mid-1 already contains all 0s, high to end of array already contains all 2s and only the mid portion needs to be sorted)\\n\\nStep 3) Hence, we will apply a while loop till mid<=high.\\n\\nStep 4) If element at mid (initially index 0)==0, then we will simply swap mid element with low element(which is also initially at index 0) and increment both mid and low.\\n\\nStep 5) If mid == 1, then we can say that array is already in its sorted position and increment mid.\\n\\nStep 6) If mid == 2 then we will swap mid with high in order to get back 2 to its destined sorted position and decrement high.\\n\\nSolution:\\nhttps://leetcode.com/problems/sort-colors/solutions/4071342/step-by-step-dutch-national-flag-algo/"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "if you don't know any of the approach then use any sorting algorithm to sort it \nin my case I used quicksort(which implemented internally in Collection framework java)"
                    },
                    {
                        "username": "rushichitte1998",
                        "content": "use Doutch National flag algorithm its also known as 3 pointer algorithm"
                    },
                    {
                        "username": "Aditya_179",
                        "content": "i solved this using bubble sort, is this a right approach to solve this problem?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "yes you can solve it using it but it is the brute force approach ......\\nthe better approach is first count all the o\\'s , 1\\'s and 2\\'s then according fill 0,1,2 in the array acc. to their counts in the order 012........\\nthe final most optimal approach is DNF algo (dutch national flag ) refer Stiver on yt for that solution"
                    },
                    {
                        "username": "mattsthilaire1",
                        "content": "Apparently selection sort works here too lol "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Counting sort ftw"
                    }
                ]
            },
            {
                "id": 2075976,
                "content": [
                    {
                        "username": "GeForceGroot",
                        "content": "I actually solved it using selection sort. it\\'s great and easy approach for this problem."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "i solved it using bubble sort,its fine right?\\n"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[Link to Solution](https://youtu.be/cr1OUfCRuD8):\\n\\n\\n"
                    },
                    {
                        "username": "baojialiang",
                        "content": "In this sort color question, it only tells us to separate the different colors by sorting, but it does not mention we need to sort the colors exactly according to the size of the color numbers.\\n\\nFor instance, if the input is {1, 2, 1,  0}, the result can be {1,1, 2, 0}. But the OJ answer is only {0, 1, 1, 2}, which does not make sense, because {1, 2, 1,  0} has already separated different color, correct?"
                    },
                    {
                        "username": "sabka_bwb",
                        "content": "Problem Statement states tha order in which the colors are to be arranged...\\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, WITH THE COLORS IN THE ORDER RED, WHITE AND BLUE."
                    },
                    {
                        "username": "navneet1083",
                        "content": "normal `sort` would have worked for this problem, isn\\'t it !!!"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        int right=a.size()-1;\\n        int len=a.size();\\n        int left=0;\\n        int i=0;\\n        while(i<=right){\\n                cout<<endl<<\"S T E P\"<<endl;\\n                for(int i=0;i<len;i++){\\n                    cout<<a[i]<<\" \";\\n                }\\n                cout<<endl;\\n\\n                if (a[i] == 0) {\\n                    swap(a[i],a[left]);\\n                    left=left+1;\\n                    i=i+1;\\n                }\\n                else if(a[i]==2){\\n                    swap(a[i],a[right]);\\n                    right=right-1;\\n                }\\n                else{\\n                    i=i+1;\\n                }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "We use the Dutch National Flag Algorithm to solve this question. The steps to the following are given below:\\n\\nStep 1) Take three pointers named low, mid and high, where low and mid=0 and high = a.size()-1.\\n\\nStep 2) Now, we will solve the question in the assumption that a part of the array is already sorted. (low to mid-1 already contains all 0s, high to end of array already contains all 2s and only the mid portion needs to be sorted)\\n\\nStep 3) Hence, we will apply a while loop till mid<=high.\\n\\nStep 4) If element at mid (initially index 0)==0, then we will simply swap mid element with low element(which is also initially at index 0) and increment both mid and low.\\n\\nStep 5) If mid == 1, then we can say that array is already in its sorted position and increment mid.\\n\\nStep 6) If mid == 2 then we will swap mid with high in order to get back 2 to its destined sorted position and decrement high.\\n\\nSolution:\\nhttps://leetcode.com/problems/sort-colors/solutions/4071342/step-by-step-dutch-national-flag-algo/"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "if you don't know any of the approach then use any sorting algorithm to sort it \nin my case I used quicksort(which implemented internally in Collection framework java)"
                    },
                    {
                        "username": "rushichitte1998",
                        "content": "use Doutch National flag algorithm its also known as 3 pointer algorithm"
                    },
                    {
                        "username": "Aditya_179",
                        "content": "i solved this using bubble sort, is this a right approach to solve this problem?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "yes you can solve it using it but it is the brute force approach ......\\nthe better approach is first count all the o\\'s , 1\\'s and 2\\'s then according fill 0,1,2 in the array acc. to their counts in the order 012........\\nthe final most optimal approach is DNF algo (dutch national flag ) refer Stiver on yt for that solution"
                    },
                    {
                        "username": "mattsthilaire1",
                        "content": "Apparently selection sort works here too lol "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Counting sort ftw"
                    }
                ]
            },
            {
                "id": 2066737,
                "content": [
                    {
                        "username": "GeForceGroot",
                        "content": "I actually solved it using selection sort. it\\'s great and easy approach for this problem."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "i solved it using bubble sort,its fine right?\\n"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[Link to Solution](https://youtu.be/cr1OUfCRuD8):\\n\\n\\n"
                    },
                    {
                        "username": "baojialiang",
                        "content": "In this sort color question, it only tells us to separate the different colors by sorting, but it does not mention we need to sort the colors exactly according to the size of the color numbers.\\n\\nFor instance, if the input is {1, 2, 1,  0}, the result can be {1,1, 2, 0}. But the OJ answer is only {0, 1, 1, 2}, which does not make sense, because {1, 2, 1,  0} has already separated different color, correct?"
                    },
                    {
                        "username": "sabka_bwb",
                        "content": "Problem Statement states tha order in which the colors are to be arranged...\\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, WITH THE COLORS IN THE ORDER RED, WHITE AND BLUE."
                    },
                    {
                        "username": "navneet1083",
                        "content": "normal `sort` would have worked for this problem, isn\\'t it !!!"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        int right=a.size()-1;\\n        int len=a.size();\\n        int left=0;\\n        int i=0;\\n        while(i<=right){\\n                cout<<endl<<\"S T E P\"<<endl;\\n                for(int i=0;i<len;i++){\\n                    cout<<a[i]<<\" \";\\n                }\\n                cout<<endl;\\n\\n                if (a[i] == 0) {\\n                    swap(a[i],a[left]);\\n                    left=left+1;\\n                    i=i+1;\\n                }\\n                else if(a[i]==2){\\n                    swap(a[i],a[right]);\\n                    right=right-1;\\n                }\\n                else{\\n                    i=i+1;\\n                }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "We use the Dutch National Flag Algorithm to solve this question. The steps to the following are given below:\\n\\nStep 1) Take three pointers named low, mid and high, where low and mid=0 and high = a.size()-1.\\n\\nStep 2) Now, we will solve the question in the assumption that a part of the array is already sorted. (low to mid-1 already contains all 0s, high to end of array already contains all 2s and only the mid portion needs to be sorted)\\n\\nStep 3) Hence, we will apply a while loop till mid<=high.\\n\\nStep 4) If element at mid (initially index 0)==0, then we will simply swap mid element with low element(which is also initially at index 0) and increment both mid and low.\\n\\nStep 5) If mid == 1, then we can say that array is already in its sorted position and increment mid.\\n\\nStep 6) If mid == 2 then we will swap mid with high in order to get back 2 to its destined sorted position and decrement high.\\n\\nSolution:\\nhttps://leetcode.com/problems/sort-colors/solutions/4071342/step-by-step-dutch-national-flag-algo/"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "if you don't know any of the approach then use any sorting algorithm to sort it \nin my case I used quicksort(which implemented internally in Collection framework java)"
                    },
                    {
                        "username": "rushichitte1998",
                        "content": "use Doutch National flag algorithm its also known as 3 pointer algorithm"
                    },
                    {
                        "username": "Aditya_179",
                        "content": "i solved this using bubble sort, is this a right approach to solve this problem?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "yes you can solve it using it but it is the brute force approach ......\\nthe better approach is first count all the o\\'s , 1\\'s and 2\\'s then according fill 0,1,2 in the array acc. to their counts in the order 012........\\nthe final most optimal approach is DNF algo (dutch national flag ) refer Stiver on yt for that solution"
                    },
                    {
                        "username": "mattsthilaire1",
                        "content": "Apparently selection sort works here too lol "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Counting sort ftw"
                    }
                ]
            },
            {
                "id": 2064928,
                "content": [
                    {
                        "username": "GeForceGroot",
                        "content": "I actually solved it using selection sort. it\\'s great and easy approach for this problem."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "i solved it using bubble sort,its fine right?\\n"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[Link to Solution](https://youtu.be/cr1OUfCRuD8):\\n\\n\\n"
                    },
                    {
                        "username": "baojialiang",
                        "content": "In this sort color question, it only tells us to separate the different colors by sorting, but it does not mention we need to sort the colors exactly according to the size of the color numbers.\\n\\nFor instance, if the input is {1, 2, 1,  0}, the result can be {1,1, 2, 0}. But the OJ answer is only {0, 1, 1, 2}, which does not make sense, because {1, 2, 1,  0} has already separated different color, correct?"
                    },
                    {
                        "username": "sabka_bwb",
                        "content": "Problem Statement states tha order in which the colors are to be arranged...\\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, WITH THE COLORS IN THE ORDER RED, WHITE AND BLUE."
                    },
                    {
                        "username": "navneet1083",
                        "content": "normal `sort` would have worked for this problem, isn\\'t it !!!"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        int right=a.size()-1;\\n        int len=a.size();\\n        int left=0;\\n        int i=0;\\n        while(i<=right){\\n                cout<<endl<<\"S T E P\"<<endl;\\n                for(int i=0;i<len;i++){\\n                    cout<<a[i]<<\" \";\\n                }\\n                cout<<endl;\\n\\n                if (a[i] == 0) {\\n                    swap(a[i],a[left]);\\n                    left=left+1;\\n                    i=i+1;\\n                }\\n                else if(a[i]==2){\\n                    swap(a[i],a[right]);\\n                    right=right-1;\\n                }\\n                else{\\n                    i=i+1;\\n                }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "We use the Dutch National Flag Algorithm to solve this question. The steps to the following are given below:\\n\\nStep 1) Take three pointers named low, mid and high, where low and mid=0 and high = a.size()-1.\\n\\nStep 2) Now, we will solve the question in the assumption that a part of the array is already sorted. (low to mid-1 already contains all 0s, high to end of array already contains all 2s and only the mid portion needs to be sorted)\\n\\nStep 3) Hence, we will apply a while loop till mid<=high.\\n\\nStep 4) If element at mid (initially index 0)==0, then we will simply swap mid element with low element(which is also initially at index 0) and increment both mid and low.\\n\\nStep 5) If mid == 1, then we can say that array is already in its sorted position and increment mid.\\n\\nStep 6) If mid == 2 then we will swap mid with high in order to get back 2 to its destined sorted position and decrement high.\\n\\nSolution:\\nhttps://leetcode.com/problems/sort-colors/solutions/4071342/step-by-step-dutch-national-flag-algo/"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "if you don't know any of the approach then use any sorting algorithm to sort it \nin my case I used quicksort(which implemented internally in Collection framework java)"
                    },
                    {
                        "username": "rushichitte1998",
                        "content": "use Doutch National flag algorithm its also known as 3 pointer algorithm"
                    },
                    {
                        "username": "Aditya_179",
                        "content": "i solved this using bubble sort, is this a right approach to solve this problem?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "yes you can solve it using it but it is the brute force approach ......\\nthe better approach is first count all the o\\'s , 1\\'s and 2\\'s then according fill 0,1,2 in the array acc. to their counts in the order 012........\\nthe final most optimal approach is DNF algo (dutch national flag ) refer Stiver on yt for that solution"
                    },
                    {
                        "username": "mattsthilaire1",
                        "content": "Apparently selection sort works here too lol "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Counting sort ftw"
                    }
                ]
            },
            {
                "id": 2063208,
                "content": [
                    {
                        "username": "GeForceGroot",
                        "content": "I actually solved it using selection sort. it\\'s great and easy approach for this problem."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "i solved it using bubble sort,its fine right?\\n"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[Link to Solution](https://youtu.be/cr1OUfCRuD8):\\n\\n\\n"
                    },
                    {
                        "username": "baojialiang",
                        "content": "In this sort color question, it only tells us to separate the different colors by sorting, but it does not mention we need to sort the colors exactly according to the size of the color numbers.\\n\\nFor instance, if the input is {1, 2, 1,  0}, the result can be {1,1, 2, 0}. But the OJ answer is only {0, 1, 1, 2}, which does not make sense, because {1, 2, 1,  0} has already separated different color, correct?"
                    },
                    {
                        "username": "sabka_bwb",
                        "content": "Problem Statement states tha order in which the colors are to be arranged...\\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, WITH THE COLORS IN THE ORDER RED, WHITE AND BLUE."
                    },
                    {
                        "username": "navneet1083",
                        "content": "normal `sort` would have worked for this problem, isn\\'t it !!!"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        int right=a.size()-1;\\n        int len=a.size();\\n        int left=0;\\n        int i=0;\\n        while(i<=right){\\n                cout<<endl<<\"S T E P\"<<endl;\\n                for(int i=0;i<len;i++){\\n                    cout<<a[i]<<\" \";\\n                }\\n                cout<<endl;\\n\\n                if (a[i] == 0) {\\n                    swap(a[i],a[left]);\\n                    left=left+1;\\n                    i=i+1;\\n                }\\n                else if(a[i]==2){\\n                    swap(a[i],a[right]);\\n                    right=right-1;\\n                }\\n                else{\\n                    i=i+1;\\n                }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "We use the Dutch National Flag Algorithm to solve this question. The steps to the following are given below:\\n\\nStep 1) Take three pointers named low, mid and high, where low and mid=0 and high = a.size()-1.\\n\\nStep 2) Now, we will solve the question in the assumption that a part of the array is already sorted. (low to mid-1 already contains all 0s, high to end of array already contains all 2s and only the mid portion needs to be sorted)\\n\\nStep 3) Hence, we will apply a while loop till mid<=high.\\n\\nStep 4) If element at mid (initially index 0)==0, then we will simply swap mid element with low element(which is also initially at index 0) and increment both mid and low.\\n\\nStep 5) If mid == 1, then we can say that array is already in its sorted position and increment mid.\\n\\nStep 6) If mid == 2 then we will swap mid with high in order to get back 2 to its destined sorted position and decrement high.\\n\\nSolution:\\nhttps://leetcode.com/problems/sort-colors/solutions/4071342/step-by-step-dutch-national-flag-algo/"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "if you don't know any of the approach then use any sorting algorithm to sort it \nin my case I used quicksort(which implemented internally in Collection framework java)"
                    },
                    {
                        "username": "rushichitte1998",
                        "content": "use Doutch National flag algorithm its also known as 3 pointer algorithm"
                    },
                    {
                        "username": "Aditya_179",
                        "content": "i solved this using bubble sort, is this a right approach to solve this problem?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "yes you can solve it using it but it is the brute force approach ......\\nthe better approach is first count all the o\\'s , 1\\'s and 2\\'s then according fill 0,1,2 in the array acc. to their counts in the order 012........\\nthe final most optimal approach is DNF algo (dutch national flag ) refer Stiver on yt for that solution"
                    },
                    {
                        "username": "mattsthilaire1",
                        "content": "Apparently selection sort works here too lol "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Counting sort ftw"
                    }
                ]
            },
            {
                "id": 2060247,
                "content": [
                    {
                        "username": "GeForceGroot",
                        "content": "I actually solved it using selection sort. it\\'s great and easy approach for this problem."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "i solved it using bubble sort,its fine right?\\n"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[Link to Solution](https://youtu.be/cr1OUfCRuD8):\\n\\n\\n"
                    },
                    {
                        "username": "baojialiang",
                        "content": "In this sort color question, it only tells us to separate the different colors by sorting, but it does not mention we need to sort the colors exactly according to the size of the color numbers.\\n\\nFor instance, if the input is {1, 2, 1,  0}, the result can be {1,1, 2, 0}. But the OJ answer is only {0, 1, 1, 2}, which does not make sense, because {1, 2, 1,  0} has already separated different color, correct?"
                    },
                    {
                        "username": "sabka_bwb",
                        "content": "Problem Statement states tha order in which the colors are to be arranged...\\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, WITH THE COLORS IN THE ORDER RED, WHITE AND BLUE."
                    },
                    {
                        "username": "navneet1083",
                        "content": "normal `sort` would have worked for this problem, isn\\'t it !!!"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        int right=a.size()-1;\\n        int len=a.size();\\n        int left=0;\\n        int i=0;\\n        while(i<=right){\\n                cout<<endl<<\"S T E P\"<<endl;\\n                for(int i=0;i<len;i++){\\n                    cout<<a[i]<<\" \";\\n                }\\n                cout<<endl;\\n\\n                if (a[i] == 0) {\\n                    swap(a[i],a[left]);\\n                    left=left+1;\\n                    i=i+1;\\n                }\\n                else if(a[i]==2){\\n                    swap(a[i],a[right]);\\n                    right=right-1;\\n                }\\n                else{\\n                    i=i+1;\\n                }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "We use the Dutch National Flag Algorithm to solve this question. The steps to the following are given below:\\n\\nStep 1) Take three pointers named low, mid and high, where low and mid=0 and high = a.size()-1.\\n\\nStep 2) Now, we will solve the question in the assumption that a part of the array is already sorted. (low to mid-1 already contains all 0s, high to end of array already contains all 2s and only the mid portion needs to be sorted)\\n\\nStep 3) Hence, we will apply a while loop till mid<=high.\\n\\nStep 4) If element at mid (initially index 0)==0, then we will simply swap mid element with low element(which is also initially at index 0) and increment both mid and low.\\n\\nStep 5) If mid == 1, then we can say that array is already in its sorted position and increment mid.\\n\\nStep 6) If mid == 2 then we will swap mid with high in order to get back 2 to its destined sorted position and decrement high.\\n\\nSolution:\\nhttps://leetcode.com/problems/sort-colors/solutions/4071342/step-by-step-dutch-national-flag-algo/"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "if you don't know any of the approach then use any sorting algorithm to sort it \nin my case I used quicksort(which implemented internally in Collection framework java)"
                    },
                    {
                        "username": "rushichitte1998",
                        "content": "use Doutch National flag algorithm its also known as 3 pointer algorithm"
                    },
                    {
                        "username": "Aditya_179",
                        "content": "i solved this using bubble sort, is this a right approach to solve this problem?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "yes you can solve it using it but it is the brute force approach ......\\nthe better approach is first count all the o\\'s , 1\\'s and 2\\'s then according fill 0,1,2 in the array acc. to their counts in the order 012........\\nthe final most optimal approach is DNF algo (dutch national flag ) refer Stiver on yt for that solution"
                    },
                    {
                        "username": "mattsthilaire1",
                        "content": "Apparently selection sort works here too lol "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Counting sort ftw"
                    }
                ]
            },
            {
                "id": 2049756,
                "content": [
                    {
                        "username": "GeForceGroot",
                        "content": "I actually solved it using selection sort. it\\'s great and easy approach for this problem."
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "i solved it using bubble sort,its fine right?\\n"
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[Link to Solution](https://youtu.be/cr1OUfCRuD8):\\n\\n\\n"
                    },
                    {
                        "username": "baojialiang",
                        "content": "In this sort color question, it only tells us to separate the different colors by sorting, but it does not mention we need to sort the colors exactly according to the size of the color numbers.\\n\\nFor instance, if the input is {1, 2, 1,  0}, the result can be {1,1, 2, 0}. But the OJ answer is only {0, 1, 1, 2}, which does not make sense, because {1, 2, 1,  0} has already separated different color, correct?"
                    },
                    {
                        "username": "sabka_bwb",
                        "content": "Problem Statement states tha order in which the colors are to be arranged...\\nGiven an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, WITH THE COLORS IN THE ORDER RED, WHITE AND BLUE."
                    },
                    {
                        "username": "navneet1083",
                        "content": "normal `sort` would have worked for this problem, isn\\'t it !!!"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& a) {\\n        int right=a.size()-1;\\n        int len=a.size();\\n        int left=0;\\n        int i=0;\\n        while(i<=right){\\n                cout<<endl<<\"S T E P\"<<endl;\\n                for(int i=0;i<len;i++){\\n                    cout<<a[i]<<\" \";\\n                }\\n                cout<<endl;\\n\\n                if (a[i] == 0) {\\n                    swap(a[i],a[left]);\\n                    left=left+1;\\n                    i=i+1;\\n                }\\n                else if(a[i]==2){\\n                    swap(a[i],a[right]);\\n                    right=right-1;\\n                }\\n                else{\\n                    i=i+1;\\n                }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "We use the Dutch National Flag Algorithm to solve this question. The steps to the following are given below:\\n\\nStep 1) Take three pointers named low, mid and high, where low and mid=0 and high = a.size()-1.\\n\\nStep 2) Now, we will solve the question in the assumption that a part of the array is already sorted. (low to mid-1 already contains all 0s, high to end of array already contains all 2s and only the mid portion needs to be sorted)\\n\\nStep 3) Hence, we will apply a while loop till mid<=high.\\n\\nStep 4) If element at mid (initially index 0)==0, then we will simply swap mid element with low element(which is also initially at index 0) and increment both mid and low.\\n\\nStep 5) If mid == 1, then we can say that array is already in its sorted position and increment mid.\\n\\nStep 6) If mid == 2 then we will swap mid with high in order to get back 2 to its destined sorted position and decrement high.\\n\\nSolution:\\nhttps://leetcode.com/problems/sort-colors/solutions/4071342/step-by-step-dutch-national-flag-algo/"
                    },
                    {
                        "username": "anilbillupati",
                        "content": "if you don't know any of the approach then use any sorting algorithm to sort it \nin my case I used quicksort(which implemented internally in Collection framework java)"
                    },
                    {
                        "username": "rushichitte1998",
                        "content": "use Doutch National flag algorithm its also known as 3 pointer algorithm"
                    },
                    {
                        "username": "Aditya_179",
                        "content": "i solved this using bubble sort, is this a right approach to solve this problem?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "yes you can solve it using it but it is the brute force approach ......\\nthe better approach is first count all the o\\'s , 1\\'s and 2\\'s then according fill 0,1,2 in the array acc. to their counts in the order 012........\\nthe final most optimal approach is DNF algo (dutch national flag ) refer Stiver on yt for that solution"
                    },
                    {
                        "username": "mattsthilaire1",
                        "content": "Apparently selection sort works here too lol "
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Counting sort ftw"
                    }
                ]
            },
            {
                "id": 2039858,
                "content": [
                    {
                        "username": "pijushmondal617",
                        "content": "Use Dutch National Flag Algorithm. whenever  u r given a 3 distinct integer, and asked to sort. "
                    },
                    {
                        "username": "imraklr",
                        "content": "dude this question was just asked in my interview and I could not answer it. I did this question by replicating a code behavior and I forgot the solution. Can anyone suggest a better approach to Competitive Coding and DSA?"
                    },
                    {
                        "username": "125156048",
                        "content": "rip djikstra"
                    },
                    {
                        "username": "RudrSharma",
                        "content": "can we sole this question in O(nlogn)\\nvoid merge (vector<int> & v1 , vector <int> & v2 , vector <int> & nums){\\n    int a  = 0 , b = 0 , k = 0 ; \\n    while(a < v1.size() && b < v2.size() ){\\n        if (v1[a] < v2[b]){\\n            nums[k++] = v1[a++] ; \\n        }\\n        else nums[k++] = v2[b++] ; \\n    }\\n    if (a == v1.size() ) while(b < v2.size() ) nums[k++] = v2[b++] ; \\n    else if ( b == v2.size()) while(a < v1.size() ) nums[k++] = v1[a++] ; \\n}\\n\\nvoid mergesort (vector <int> & nums ){\\n    int n = nums.size() ; \\n    if (n == 1) return ;  \\n    int n1 = n / 2 , n2 = n - (n/2) ; \\n    vector <int> v1(n1) , v2(n2) ;\\n    for (int a = 0 ;a < n1 ;a++){\\n        v1[a] = nums[a] ;\\n    } \\n    for (int b = 0 ;b < n2 ; b++){\\n        v2[b] = nums[b+n1] ;\\n    }\\n    mergesort (v1) ; \\n    mergesort(v2) ; \\n    merge(v1 ,v2, nums) ; \\n    v1.clear () ; \\n    v2.clear () ;   \\n} \\n    void sortColors(vector<int>& nums) {\\n        \\n        return mergesort(nums) ; \\n    }"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "Yes, normal sort will work but that\\'s not the point\\nIf you were to solve with selection sort, nums.sort(), this won\\'t really be medium"
                    },
                    {
                        "username": "dpmax11",
                        "content": "nums.sort()"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "If i use counting sort , would that still be considered O(1) since it\\'s just 3 flags"
                    },
                    {
                        "username": "Pranshu_682",
                        "content": "func sortColors(nums []int)  {\\n    flag0 := false\\n    for i := 0; i<len(nums); i++ {\\n        if flag0 == false {\\n            if nums[i] != 0 {\\n                flag0 = true\\n                i--\\n            }\\n            continue\\n        }\\n        if nums[i] == 1 {\\n            continue\\n        } else if nums[i] == 0 {\\n            if i == 0 {\\n                continue\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append([]int{0}, nums...)\\n            i++\\n        } else if nums[i] == 2 {\\n            if i == len(nums)-1 {\\n                break\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append(nums, 2)\\n            i--\\n        }\\n        fmt.Println(nums)\\n    }\\n    fmt.Println(nums)\\n}\\n\\nCan anyone tell me why this go code doesn\\'t work"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "lol"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "Use simple sorting algorithm. "
                    }
                ]
            },
            {
                "id": 2035752,
                "content": [
                    {
                        "username": "pijushmondal617",
                        "content": "Use Dutch National Flag Algorithm. whenever  u r given a 3 distinct integer, and asked to sort. "
                    },
                    {
                        "username": "imraklr",
                        "content": "dude this question was just asked in my interview and I could not answer it. I did this question by replicating a code behavior and I forgot the solution. Can anyone suggest a better approach to Competitive Coding and DSA?"
                    },
                    {
                        "username": "125156048",
                        "content": "rip djikstra"
                    },
                    {
                        "username": "RudrSharma",
                        "content": "can we sole this question in O(nlogn)\\nvoid merge (vector<int> & v1 , vector <int> & v2 , vector <int> & nums){\\n    int a  = 0 , b = 0 , k = 0 ; \\n    while(a < v1.size() && b < v2.size() ){\\n        if (v1[a] < v2[b]){\\n            nums[k++] = v1[a++] ; \\n        }\\n        else nums[k++] = v2[b++] ; \\n    }\\n    if (a == v1.size() ) while(b < v2.size() ) nums[k++] = v2[b++] ; \\n    else if ( b == v2.size()) while(a < v1.size() ) nums[k++] = v1[a++] ; \\n}\\n\\nvoid mergesort (vector <int> & nums ){\\n    int n = nums.size() ; \\n    if (n == 1) return ;  \\n    int n1 = n / 2 , n2 = n - (n/2) ; \\n    vector <int> v1(n1) , v2(n2) ;\\n    for (int a = 0 ;a < n1 ;a++){\\n        v1[a] = nums[a] ;\\n    } \\n    for (int b = 0 ;b < n2 ; b++){\\n        v2[b] = nums[b+n1] ;\\n    }\\n    mergesort (v1) ; \\n    mergesort(v2) ; \\n    merge(v1 ,v2, nums) ; \\n    v1.clear () ; \\n    v2.clear () ;   \\n} \\n    void sortColors(vector<int>& nums) {\\n        \\n        return mergesort(nums) ; \\n    }"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "Yes, normal sort will work but that\\'s not the point\\nIf you were to solve with selection sort, nums.sort(), this won\\'t really be medium"
                    },
                    {
                        "username": "dpmax11",
                        "content": "nums.sort()"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "If i use counting sort , would that still be considered O(1) since it\\'s just 3 flags"
                    },
                    {
                        "username": "Pranshu_682",
                        "content": "func sortColors(nums []int)  {\\n    flag0 := false\\n    for i := 0; i<len(nums); i++ {\\n        if flag0 == false {\\n            if nums[i] != 0 {\\n                flag0 = true\\n                i--\\n            }\\n            continue\\n        }\\n        if nums[i] == 1 {\\n            continue\\n        } else if nums[i] == 0 {\\n            if i == 0 {\\n                continue\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append([]int{0}, nums...)\\n            i++\\n        } else if nums[i] == 2 {\\n            if i == len(nums)-1 {\\n                break\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append(nums, 2)\\n            i--\\n        }\\n        fmt.Println(nums)\\n    }\\n    fmt.Println(nums)\\n}\\n\\nCan anyone tell me why this go code doesn\\'t work"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "lol"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "Use simple sorting algorithm. "
                    }
                ]
            },
            {
                "id": 2035390,
                "content": [
                    {
                        "username": "pijushmondal617",
                        "content": "Use Dutch National Flag Algorithm. whenever  u r given a 3 distinct integer, and asked to sort. "
                    },
                    {
                        "username": "imraklr",
                        "content": "dude this question was just asked in my interview and I could not answer it. I did this question by replicating a code behavior and I forgot the solution. Can anyone suggest a better approach to Competitive Coding and DSA?"
                    },
                    {
                        "username": "125156048",
                        "content": "rip djikstra"
                    },
                    {
                        "username": "RudrSharma",
                        "content": "can we sole this question in O(nlogn)\\nvoid merge (vector<int> & v1 , vector <int> & v2 , vector <int> & nums){\\n    int a  = 0 , b = 0 , k = 0 ; \\n    while(a < v1.size() && b < v2.size() ){\\n        if (v1[a] < v2[b]){\\n            nums[k++] = v1[a++] ; \\n        }\\n        else nums[k++] = v2[b++] ; \\n    }\\n    if (a == v1.size() ) while(b < v2.size() ) nums[k++] = v2[b++] ; \\n    else if ( b == v2.size()) while(a < v1.size() ) nums[k++] = v1[a++] ; \\n}\\n\\nvoid mergesort (vector <int> & nums ){\\n    int n = nums.size() ; \\n    if (n == 1) return ;  \\n    int n1 = n / 2 , n2 = n - (n/2) ; \\n    vector <int> v1(n1) , v2(n2) ;\\n    for (int a = 0 ;a < n1 ;a++){\\n        v1[a] = nums[a] ;\\n    } \\n    for (int b = 0 ;b < n2 ; b++){\\n        v2[b] = nums[b+n1] ;\\n    }\\n    mergesort (v1) ; \\n    mergesort(v2) ; \\n    merge(v1 ,v2, nums) ; \\n    v1.clear () ; \\n    v2.clear () ;   \\n} \\n    void sortColors(vector<int>& nums) {\\n        \\n        return mergesort(nums) ; \\n    }"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "Yes, normal sort will work but that\\'s not the point\\nIf you were to solve with selection sort, nums.sort(), this won\\'t really be medium"
                    },
                    {
                        "username": "dpmax11",
                        "content": "nums.sort()"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "If i use counting sort , would that still be considered O(1) since it\\'s just 3 flags"
                    },
                    {
                        "username": "Pranshu_682",
                        "content": "func sortColors(nums []int)  {\\n    flag0 := false\\n    for i := 0; i<len(nums); i++ {\\n        if flag0 == false {\\n            if nums[i] != 0 {\\n                flag0 = true\\n                i--\\n            }\\n            continue\\n        }\\n        if nums[i] == 1 {\\n            continue\\n        } else if nums[i] == 0 {\\n            if i == 0 {\\n                continue\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append([]int{0}, nums...)\\n            i++\\n        } else if nums[i] == 2 {\\n            if i == len(nums)-1 {\\n                break\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append(nums, 2)\\n            i--\\n        }\\n        fmt.Println(nums)\\n    }\\n    fmt.Println(nums)\\n}\\n\\nCan anyone tell me why this go code doesn\\'t work"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "lol"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "Use simple sorting algorithm. "
                    }
                ]
            },
            {
                "id": 2031007,
                "content": [
                    {
                        "username": "pijushmondal617",
                        "content": "Use Dutch National Flag Algorithm. whenever  u r given a 3 distinct integer, and asked to sort. "
                    },
                    {
                        "username": "imraklr",
                        "content": "dude this question was just asked in my interview and I could not answer it. I did this question by replicating a code behavior and I forgot the solution. Can anyone suggest a better approach to Competitive Coding and DSA?"
                    },
                    {
                        "username": "125156048",
                        "content": "rip djikstra"
                    },
                    {
                        "username": "RudrSharma",
                        "content": "can we sole this question in O(nlogn)\\nvoid merge (vector<int> & v1 , vector <int> & v2 , vector <int> & nums){\\n    int a  = 0 , b = 0 , k = 0 ; \\n    while(a < v1.size() && b < v2.size() ){\\n        if (v1[a] < v2[b]){\\n            nums[k++] = v1[a++] ; \\n        }\\n        else nums[k++] = v2[b++] ; \\n    }\\n    if (a == v1.size() ) while(b < v2.size() ) nums[k++] = v2[b++] ; \\n    else if ( b == v2.size()) while(a < v1.size() ) nums[k++] = v1[a++] ; \\n}\\n\\nvoid mergesort (vector <int> & nums ){\\n    int n = nums.size() ; \\n    if (n == 1) return ;  \\n    int n1 = n / 2 , n2 = n - (n/2) ; \\n    vector <int> v1(n1) , v2(n2) ;\\n    for (int a = 0 ;a < n1 ;a++){\\n        v1[a] = nums[a] ;\\n    } \\n    for (int b = 0 ;b < n2 ; b++){\\n        v2[b] = nums[b+n1] ;\\n    }\\n    mergesort (v1) ; \\n    mergesort(v2) ; \\n    merge(v1 ,v2, nums) ; \\n    v1.clear () ; \\n    v2.clear () ;   \\n} \\n    void sortColors(vector<int>& nums) {\\n        \\n        return mergesort(nums) ; \\n    }"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "Yes, normal sort will work but that\\'s not the point\\nIf you were to solve with selection sort, nums.sort(), this won\\'t really be medium"
                    },
                    {
                        "username": "dpmax11",
                        "content": "nums.sort()"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "If i use counting sort , would that still be considered O(1) since it\\'s just 3 flags"
                    },
                    {
                        "username": "Pranshu_682",
                        "content": "func sortColors(nums []int)  {\\n    flag0 := false\\n    for i := 0; i<len(nums); i++ {\\n        if flag0 == false {\\n            if nums[i] != 0 {\\n                flag0 = true\\n                i--\\n            }\\n            continue\\n        }\\n        if nums[i] == 1 {\\n            continue\\n        } else if nums[i] == 0 {\\n            if i == 0 {\\n                continue\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append([]int{0}, nums...)\\n            i++\\n        } else if nums[i] == 2 {\\n            if i == len(nums)-1 {\\n                break\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append(nums, 2)\\n            i--\\n        }\\n        fmt.Println(nums)\\n    }\\n    fmt.Println(nums)\\n}\\n\\nCan anyone tell me why this go code doesn\\'t work"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "lol"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "Use simple sorting algorithm. "
                    }
                ]
            },
            {
                "id": 2027494,
                "content": [
                    {
                        "username": "pijushmondal617",
                        "content": "Use Dutch National Flag Algorithm. whenever  u r given a 3 distinct integer, and asked to sort. "
                    },
                    {
                        "username": "imraklr",
                        "content": "dude this question was just asked in my interview and I could not answer it. I did this question by replicating a code behavior and I forgot the solution. Can anyone suggest a better approach to Competitive Coding and DSA?"
                    },
                    {
                        "username": "125156048",
                        "content": "rip djikstra"
                    },
                    {
                        "username": "RudrSharma",
                        "content": "can we sole this question in O(nlogn)\\nvoid merge (vector<int> & v1 , vector <int> & v2 , vector <int> & nums){\\n    int a  = 0 , b = 0 , k = 0 ; \\n    while(a < v1.size() && b < v2.size() ){\\n        if (v1[a] < v2[b]){\\n            nums[k++] = v1[a++] ; \\n        }\\n        else nums[k++] = v2[b++] ; \\n    }\\n    if (a == v1.size() ) while(b < v2.size() ) nums[k++] = v2[b++] ; \\n    else if ( b == v2.size()) while(a < v1.size() ) nums[k++] = v1[a++] ; \\n}\\n\\nvoid mergesort (vector <int> & nums ){\\n    int n = nums.size() ; \\n    if (n == 1) return ;  \\n    int n1 = n / 2 , n2 = n - (n/2) ; \\n    vector <int> v1(n1) , v2(n2) ;\\n    for (int a = 0 ;a < n1 ;a++){\\n        v1[a] = nums[a] ;\\n    } \\n    for (int b = 0 ;b < n2 ; b++){\\n        v2[b] = nums[b+n1] ;\\n    }\\n    mergesort (v1) ; \\n    mergesort(v2) ; \\n    merge(v1 ,v2, nums) ; \\n    v1.clear () ; \\n    v2.clear () ;   \\n} \\n    void sortColors(vector<int>& nums) {\\n        \\n        return mergesort(nums) ; \\n    }"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "Yes, normal sort will work but that\\'s not the point\\nIf you were to solve with selection sort, nums.sort(), this won\\'t really be medium"
                    },
                    {
                        "username": "dpmax11",
                        "content": "nums.sort()"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "If i use counting sort , would that still be considered O(1) since it\\'s just 3 flags"
                    },
                    {
                        "username": "Pranshu_682",
                        "content": "func sortColors(nums []int)  {\\n    flag0 := false\\n    for i := 0; i<len(nums); i++ {\\n        if flag0 == false {\\n            if nums[i] != 0 {\\n                flag0 = true\\n                i--\\n            }\\n            continue\\n        }\\n        if nums[i] == 1 {\\n            continue\\n        } else if nums[i] == 0 {\\n            if i == 0 {\\n                continue\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append([]int{0}, nums...)\\n            i++\\n        } else if nums[i] == 2 {\\n            if i == len(nums)-1 {\\n                break\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append(nums, 2)\\n            i--\\n        }\\n        fmt.Println(nums)\\n    }\\n    fmt.Println(nums)\\n}\\n\\nCan anyone tell me why this go code doesn\\'t work"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "lol"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "Use simple sorting algorithm. "
                    }
                ]
            },
            {
                "id": 2026622,
                "content": [
                    {
                        "username": "pijushmondal617",
                        "content": "Use Dutch National Flag Algorithm. whenever  u r given a 3 distinct integer, and asked to sort. "
                    },
                    {
                        "username": "imraklr",
                        "content": "dude this question was just asked in my interview and I could not answer it. I did this question by replicating a code behavior and I forgot the solution. Can anyone suggest a better approach to Competitive Coding and DSA?"
                    },
                    {
                        "username": "125156048",
                        "content": "rip djikstra"
                    },
                    {
                        "username": "RudrSharma",
                        "content": "can we sole this question in O(nlogn)\\nvoid merge (vector<int> & v1 , vector <int> & v2 , vector <int> & nums){\\n    int a  = 0 , b = 0 , k = 0 ; \\n    while(a < v1.size() && b < v2.size() ){\\n        if (v1[a] < v2[b]){\\n            nums[k++] = v1[a++] ; \\n        }\\n        else nums[k++] = v2[b++] ; \\n    }\\n    if (a == v1.size() ) while(b < v2.size() ) nums[k++] = v2[b++] ; \\n    else if ( b == v2.size()) while(a < v1.size() ) nums[k++] = v1[a++] ; \\n}\\n\\nvoid mergesort (vector <int> & nums ){\\n    int n = nums.size() ; \\n    if (n == 1) return ;  \\n    int n1 = n / 2 , n2 = n - (n/2) ; \\n    vector <int> v1(n1) , v2(n2) ;\\n    for (int a = 0 ;a < n1 ;a++){\\n        v1[a] = nums[a] ;\\n    } \\n    for (int b = 0 ;b < n2 ; b++){\\n        v2[b] = nums[b+n1] ;\\n    }\\n    mergesort (v1) ; \\n    mergesort(v2) ; \\n    merge(v1 ,v2, nums) ; \\n    v1.clear () ; \\n    v2.clear () ;   \\n} \\n    void sortColors(vector<int>& nums) {\\n        \\n        return mergesort(nums) ; \\n    }"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "Yes, normal sort will work but that\\'s not the point\\nIf you were to solve with selection sort, nums.sort(), this won\\'t really be medium"
                    },
                    {
                        "username": "dpmax11",
                        "content": "nums.sort()"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "If i use counting sort , would that still be considered O(1) since it\\'s just 3 flags"
                    },
                    {
                        "username": "Pranshu_682",
                        "content": "func sortColors(nums []int)  {\\n    flag0 := false\\n    for i := 0; i<len(nums); i++ {\\n        if flag0 == false {\\n            if nums[i] != 0 {\\n                flag0 = true\\n                i--\\n            }\\n            continue\\n        }\\n        if nums[i] == 1 {\\n            continue\\n        } else if nums[i] == 0 {\\n            if i == 0 {\\n                continue\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append([]int{0}, nums...)\\n            i++\\n        } else if nums[i] == 2 {\\n            if i == len(nums)-1 {\\n                break\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append(nums, 2)\\n            i--\\n        }\\n        fmt.Println(nums)\\n    }\\n    fmt.Println(nums)\\n}\\n\\nCan anyone tell me why this go code doesn\\'t work"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "lol"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "Use simple sorting algorithm. "
                    }
                ]
            },
            {
                "id": 2020617,
                "content": [
                    {
                        "username": "pijushmondal617",
                        "content": "Use Dutch National Flag Algorithm. whenever  u r given a 3 distinct integer, and asked to sort. "
                    },
                    {
                        "username": "imraklr",
                        "content": "dude this question was just asked in my interview and I could not answer it. I did this question by replicating a code behavior and I forgot the solution. Can anyone suggest a better approach to Competitive Coding and DSA?"
                    },
                    {
                        "username": "125156048",
                        "content": "rip djikstra"
                    },
                    {
                        "username": "RudrSharma",
                        "content": "can we sole this question in O(nlogn)\\nvoid merge (vector<int> & v1 , vector <int> & v2 , vector <int> & nums){\\n    int a  = 0 , b = 0 , k = 0 ; \\n    while(a < v1.size() && b < v2.size() ){\\n        if (v1[a] < v2[b]){\\n            nums[k++] = v1[a++] ; \\n        }\\n        else nums[k++] = v2[b++] ; \\n    }\\n    if (a == v1.size() ) while(b < v2.size() ) nums[k++] = v2[b++] ; \\n    else if ( b == v2.size()) while(a < v1.size() ) nums[k++] = v1[a++] ; \\n}\\n\\nvoid mergesort (vector <int> & nums ){\\n    int n = nums.size() ; \\n    if (n == 1) return ;  \\n    int n1 = n / 2 , n2 = n - (n/2) ; \\n    vector <int> v1(n1) , v2(n2) ;\\n    for (int a = 0 ;a < n1 ;a++){\\n        v1[a] = nums[a] ;\\n    } \\n    for (int b = 0 ;b < n2 ; b++){\\n        v2[b] = nums[b+n1] ;\\n    }\\n    mergesort (v1) ; \\n    mergesort(v2) ; \\n    merge(v1 ,v2, nums) ; \\n    v1.clear () ; \\n    v2.clear () ;   \\n} \\n    void sortColors(vector<int>& nums) {\\n        \\n        return mergesort(nums) ; \\n    }"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "Yes, normal sort will work but that\\'s not the point\\nIf you were to solve with selection sort, nums.sort(), this won\\'t really be medium"
                    },
                    {
                        "username": "dpmax11",
                        "content": "nums.sort()"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "If i use counting sort , would that still be considered O(1) since it\\'s just 3 flags"
                    },
                    {
                        "username": "Pranshu_682",
                        "content": "func sortColors(nums []int)  {\\n    flag0 := false\\n    for i := 0; i<len(nums); i++ {\\n        if flag0 == false {\\n            if nums[i] != 0 {\\n                flag0 = true\\n                i--\\n            }\\n            continue\\n        }\\n        if nums[i] == 1 {\\n            continue\\n        } else if nums[i] == 0 {\\n            if i == 0 {\\n                continue\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append([]int{0}, nums...)\\n            i++\\n        } else if nums[i] == 2 {\\n            if i == len(nums)-1 {\\n                break\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append(nums, 2)\\n            i--\\n        }\\n        fmt.Println(nums)\\n    }\\n    fmt.Println(nums)\\n}\\n\\nCan anyone tell me why this go code doesn\\'t work"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "lol"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "Use simple sorting algorithm. "
                    }
                ]
            },
            {
                "id": 2019279,
                "content": [
                    {
                        "username": "pijushmondal617",
                        "content": "Use Dutch National Flag Algorithm. whenever  u r given a 3 distinct integer, and asked to sort. "
                    },
                    {
                        "username": "imraklr",
                        "content": "dude this question was just asked in my interview and I could not answer it. I did this question by replicating a code behavior and I forgot the solution. Can anyone suggest a better approach to Competitive Coding and DSA?"
                    },
                    {
                        "username": "125156048",
                        "content": "rip djikstra"
                    },
                    {
                        "username": "RudrSharma",
                        "content": "can we sole this question in O(nlogn)\\nvoid merge (vector<int> & v1 , vector <int> & v2 , vector <int> & nums){\\n    int a  = 0 , b = 0 , k = 0 ; \\n    while(a < v1.size() && b < v2.size() ){\\n        if (v1[a] < v2[b]){\\n            nums[k++] = v1[a++] ; \\n        }\\n        else nums[k++] = v2[b++] ; \\n    }\\n    if (a == v1.size() ) while(b < v2.size() ) nums[k++] = v2[b++] ; \\n    else if ( b == v2.size()) while(a < v1.size() ) nums[k++] = v1[a++] ; \\n}\\n\\nvoid mergesort (vector <int> & nums ){\\n    int n = nums.size() ; \\n    if (n == 1) return ;  \\n    int n1 = n / 2 , n2 = n - (n/2) ; \\n    vector <int> v1(n1) , v2(n2) ;\\n    for (int a = 0 ;a < n1 ;a++){\\n        v1[a] = nums[a] ;\\n    } \\n    for (int b = 0 ;b < n2 ; b++){\\n        v2[b] = nums[b+n1] ;\\n    }\\n    mergesort (v1) ; \\n    mergesort(v2) ; \\n    merge(v1 ,v2, nums) ; \\n    v1.clear () ; \\n    v2.clear () ;   \\n} \\n    void sortColors(vector<int>& nums) {\\n        \\n        return mergesort(nums) ; \\n    }"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "Yes, normal sort will work but that\\'s not the point\\nIf you were to solve with selection sort, nums.sort(), this won\\'t really be medium"
                    },
                    {
                        "username": "dpmax11",
                        "content": "nums.sort()"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "If i use counting sort , would that still be considered O(1) since it\\'s just 3 flags"
                    },
                    {
                        "username": "Pranshu_682",
                        "content": "func sortColors(nums []int)  {\\n    flag0 := false\\n    for i := 0; i<len(nums); i++ {\\n        if flag0 == false {\\n            if nums[i] != 0 {\\n                flag0 = true\\n                i--\\n            }\\n            continue\\n        }\\n        if nums[i] == 1 {\\n            continue\\n        } else if nums[i] == 0 {\\n            if i == 0 {\\n                continue\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append([]int{0}, nums...)\\n            i++\\n        } else if nums[i] == 2 {\\n            if i == len(nums)-1 {\\n                break\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append(nums, 2)\\n            i--\\n        }\\n        fmt.Println(nums)\\n    }\\n    fmt.Println(nums)\\n}\\n\\nCan anyone tell me why this go code doesn\\'t work"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "lol"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "Use simple sorting algorithm. "
                    }
                ]
            },
            {
                "id": 2014501,
                "content": [
                    {
                        "username": "pijushmondal617",
                        "content": "Use Dutch National Flag Algorithm. whenever  u r given a 3 distinct integer, and asked to sort. "
                    },
                    {
                        "username": "imraklr",
                        "content": "dude this question was just asked in my interview and I could not answer it. I did this question by replicating a code behavior and I forgot the solution. Can anyone suggest a better approach to Competitive Coding and DSA?"
                    },
                    {
                        "username": "125156048",
                        "content": "rip djikstra"
                    },
                    {
                        "username": "RudrSharma",
                        "content": "can we sole this question in O(nlogn)\\nvoid merge (vector<int> & v1 , vector <int> & v2 , vector <int> & nums){\\n    int a  = 0 , b = 0 , k = 0 ; \\n    while(a < v1.size() && b < v2.size() ){\\n        if (v1[a] < v2[b]){\\n            nums[k++] = v1[a++] ; \\n        }\\n        else nums[k++] = v2[b++] ; \\n    }\\n    if (a == v1.size() ) while(b < v2.size() ) nums[k++] = v2[b++] ; \\n    else if ( b == v2.size()) while(a < v1.size() ) nums[k++] = v1[a++] ; \\n}\\n\\nvoid mergesort (vector <int> & nums ){\\n    int n = nums.size() ; \\n    if (n == 1) return ;  \\n    int n1 = n / 2 , n2 = n - (n/2) ; \\n    vector <int> v1(n1) , v2(n2) ;\\n    for (int a = 0 ;a < n1 ;a++){\\n        v1[a] = nums[a] ;\\n    } \\n    for (int b = 0 ;b < n2 ; b++){\\n        v2[b] = nums[b+n1] ;\\n    }\\n    mergesort (v1) ; \\n    mergesort(v2) ; \\n    merge(v1 ,v2, nums) ; \\n    v1.clear () ; \\n    v2.clear () ;   \\n} \\n    void sortColors(vector<int>& nums) {\\n        \\n        return mergesort(nums) ; \\n    }"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "Yes, normal sort will work but that\\'s not the point\\nIf you were to solve with selection sort, nums.sort(), this won\\'t really be medium"
                    },
                    {
                        "username": "dpmax11",
                        "content": "nums.sort()"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "If i use counting sort , would that still be considered O(1) since it\\'s just 3 flags"
                    },
                    {
                        "username": "Pranshu_682",
                        "content": "func sortColors(nums []int)  {\\n    flag0 := false\\n    for i := 0; i<len(nums); i++ {\\n        if flag0 == false {\\n            if nums[i] != 0 {\\n                flag0 = true\\n                i--\\n            }\\n            continue\\n        }\\n        if nums[i] == 1 {\\n            continue\\n        } else if nums[i] == 0 {\\n            if i == 0 {\\n                continue\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append([]int{0}, nums...)\\n            i++\\n        } else if nums[i] == 2 {\\n            if i == len(nums)-1 {\\n                break\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append(nums, 2)\\n            i--\\n        }\\n        fmt.Println(nums)\\n    }\\n    fmt.Println(nums)\\n}\\n\\nCan anyone tell me why this go code doesn\\'t work"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "lol"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "Use simple sorting algorithm. "
                    }
                ]
            },
            {
                "id": 2012823,
                "content": [
                    {
                        "username": "pijushmondal617",
                        "content": "Use Dutch National Flag Algorithm. whenever  u r given a 3 distinct integer, and asked to sort. "
                    },
                    {
                        "username": "imraklr",
                        "content": "dude this question was just asked in my interview and I could not answer it. I did this question by replicating a code behavior and I forgot the solution. Can anyone suggest a better approach to Competitive Coding and DSA?"
                    },
                    {
                        "username": "125156048",
                        "content": "rip djikstra"
                    },
                    {
                        "username": "RudrSharma",
                        "content": "can we sole this question in O(nlogn)\\nvoid merge (vector<int> & v1 , vector <int> & v2 , vector <int> & nums){\\n    int a  = 0 , b = 0 , k = 0 ; \\n    while(a < v1.size() && b < v2.size() ){\\n        if (v1[a] < v2[b]){\\n            nums[k++] = v1[a++] ; \\n        }\\n        else nums[k++] = v2[b++] ; \\n    }\\n    if (a == v1.size() ) while(b < v2.size() ) nums[k++] = v2[b++] ; \\n    else if ( b == v2.size()) while(a < v1.size() ) nums[k++] = v1[a++] ; \\n}\\n\\nvoid mergesort (vector <int> & nums ){\\n    int n = nums.size() ; \\n    if (n == 1) return ;  \\n    int n1 = n / 2 , n2 = n - (n/2) ; \\n    vector <int> v1(n1) , v2(n2) ;\\n    for (int a = 0 ;a < n1 ;a++){\\n        v1[a] = nums[a] ;\\n    } \\n    for (int b = 0 ;b < n2 ; b++){\\n        v2[b] = nums[b+n1] ;\\n    }\\n    mergesort (v1) ; \\n    mergesort(v2) ; \\n    merge(v1 ,v2, nums) ; \\n    v1.clear () ; \\n    v2.clear () ;   \\n} \\n    void sortColors(vector<int>& nums) {\\n        \\n        return mergesort(nums) ; \\n    }"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "Yes, normal sort will work but that\\'s not the point\\nIf you were to solve with selection sort, nums.sort(), this won\\'t really be medium"
                    },
                    {
                        "username": "dpmax11",
                        "content": "nums.sort()"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "If i use counting sort , would that still be considered O(1) since it\\'s just 3 flags"
                    },
                    {
                        "username": "Pranshu_682",
                        "content": "func sortColors(nums []int)  {\\n    flag0 := false\\n    for i := 0; i<len(nums); i++ {\\n        if flag0 == false {\\n            if nums[i] != 0 {\\n                flag0 = true\\n                i--\\n            }\\n            continue\\n        }\\n        if nums[i] == 1 {\\n            continue\\n        } else if nums[i] == 0 {\\n            if i == 0 {\\n                continue\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append([]int{0}, nums...)\\n            i++\\n        } else if nums[i] == 2 {\\n            if i == len(nums)-1 {\\n                break\\n            }\\n            nums = append(nums[:i], nums[i+1:]...)\\n            nums = append(nums, 2)\\n            i--\\n        }\\n        fmt.Println(nums)\\n    }\\n    fmt.Println(nums)\\n}\\n\\nCan anyone tell me why this go code doesn\\'t work"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "lol"
                    },
                    {
                        "username": "Rohit___mh09",
                        "content": "Use simple sorting algorithm. "
                    }
                ]
            },
            {
                "id": 1995844,
                "content": [
                    {
                        "username": "Shanthinath",
                        "content": "\\nStriver approach \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_Manjunath_Naik",
                        "content": "Selection Sort Application question . \\n\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "The desperate urge to write `nums.sort()`. But not the way to solve this. "
                    },
                    {
                        "username": "iam_gauravkumar",
                        "content": "We can use Dutch National Flag algorithm."
                    },
                    {
                        "username": "apexabim09",
                        "content": "DNF algorithm is the key"
                    },
                    {
                        "username": "aseshbasub1",
                        "content": "This isnt accepted here in leetcode but runs fine on my laptop ide. why?\\na,b,c=[],[],[]\\nfor i in nums:\\n    if i==0:\\n        a.append(i)\\n    elif i==1:\\n        b.append(i)\\n    elif i==2:\\n        c.append(i)\\nnums=a+b+c\\n"
                    },
                    {
                        "username": "4mithm",
                        "content": "If I am creating a new list of a+b+c and sending its reference to the variable \"nums\", there is a possibility that LeetCode is still referring to the old \"nums\" reference."
                    },
                    {
                        "username": "gs9672",
                        "content": "[@JackWoah](/JackWoah) what is difference between both like nums[]=a+b+c and nums[:]=a+b+c"
                    },
                    {
                        "username": "JackWoah",
                        "content": "nums[:]=a+b+c will work"
                    },
                    {
                        "username": "piyush_11",
                        "content": "int low = 0, mid = 0, high = n - 1; // 3 pointers\\n\\n        while (mid <= high) {\\n            if (arr[mid] == 0) {\\n                // swapping arr[low] and arr[mid]\\n                int temp = arr[low];\\n                arr[low] = arr[mid];\\n                arr[mid] = temp;\\n\\n                low++;\\n                mid++;\\n\\n            } else if (arr[mid] == 1) {\\n                mid++;\\n\\n            } else {\\n                // swapping arr[mid] and arr[high]\\n                int temp = arr[mid];\\n                arr[mid] = arr[high];\\n                arr[high] = temp;\\n\\n                high--;\\n            }\\nusing Dutch National Flag Algorithm -- one pas  - O(N) SC - O(1).   (JAVA)\\n"
                    },
                    {
                        "username": "sahil_gpt11",
                        "content": "why can\\'t we use mergesort here?"
                    },
                    {
                        "username": "kokushibo627",
                        "content": "you can use merge sort, but the complexity would be O(nlogn), while by using DNF Algo/3 way partitioning, we do it in O(n) and the array is traversed just once\\nyou can also use 2 pass algorithm to do it in O(n), but that requires to traverse the array twice\\n"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "why is this code giving a wrong output?\\ninstead of taking if ,else,else if conditions i have taken 3 if conditions why is it wrong?\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        //DNF SORT\\n        int low  =0, mid =0;\\n        int high = nums.size() - 1;\\n        while(mid<=high){\\n            if(nums[mid] == 1){\\n                mid++;\\n            }\\n            if(nums[mid] == 0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            if(nums[mid] == 2){\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        } \\n    }\\n};"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "[@mohdsiddiq74432](/mohdsiddiq74432)  if nums[mid] condition evaluates how is mid incremented?\\n "
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "because if u r not using \"else if\" then the code evaluates for nums[mid] after every if statement, where mid is incremented...hence usage of else if avoids re evalution of nums[mid] in the same iteration. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I wonder why two pointer one from beginning and one from end while(l<=r) with swapping and conditions is not sorting the array\\n"
                    }
                ]
            },
            {
                "id": 1973132,
                "content": [
                    {
                        "username": "Shanthinath",
                        "content": "\\nStriver approach \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_Manjunath_Naik",
                        "content": "Selection Sort Application question . \\n\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "The desperate urge to write `nums.sort()`. But not the way to solve this. "
                    },
                    {
                        "username": "iam_gauravkumar",
                        "content": "We can use Dutch National Flag algorithm."
                    },
                    {
                        "username": "apexabim09",
                        "content": "DNF algorithm is the key"
                    },
                    {
                        "username": "aseshbasub1",
                        "content": "This isnt accepted here in leetcode but runs fine on my laptop ide. why?\\na,b,c=[],[],[]\\nfor i in nums:\\n    if i==0:\\n        a.append(i)\\n    elif i==1:\\n        b.append(i)\\n    elif i==2:\\n        c.append(i)\\nnums=a+b+c\\n"
                    },
                    {
                        "username": "4mithm",
                        "content": "If I am creating a new list of a+b+c and sending its reference to the variable \"nums\", there is a possibility that LeetCode is still referring to the old \"nums\" reference."
                    },
                    {
                        "username": "gs9672",
                        "content": "[@JackWoah](/JackWoah) what is difference between both like nums[]=a+b+c and nums[:]=a+b+c"
                    },
                    {
                        "username": "JackWoah",
                        "content": "nums[:]=a+b+c will work"
                    },
                    {
                        "username": "piyush_11",
                        "content": "int low = 0, mid = 0, high = n - 1; // 3 pointers\\n\\n        while (mid <= high) {\\n            if (arr[mid] == 0) {\\n                // swapping arr[low] and arr[mid]\\n                int temp = arr[low];\\n                arr[low] = arr[mid];\\n                arr[mid] = temp;\\n\\n                low++;\\n                mid++;\\n\\n            } else if (arr[mid] == 1) {\\n                mid++;\\n\\n            } else {\\n                // swapping arr[mid] and arr[high]\\n                int temp = arr[mid];\\n                arr[mid] = arr[high];\\n                arr[high] = temp;\\n\\n                high--;\\n            }\\nusing Dutch National Flag Algorithm -- one pas  - O(N) SC - O(1).   (JAVA)\\n"
                    },
                    {
                        "username": "sahil_gpt11",
                        "content": "why can\\'t we use mergesort here?"
                    },
                    {
                        "username": "kokushibo627",
                        "content": "you can use merge sort, but the complexity would be O(nlogn), while by using DNF Algo/3 way partitioning, we do it in O(n) and the array is traversed just once\\nyou can also use 2 pass algorithm to do it in O(n), but that requires to traverse the array twice\\n"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "why is this code giving a wrong output?\\ninstead of taking if ,else,else if conditions i have taken 3 if conditions why is it wrong?\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        //DNF SORT\\n        int low  =0, mid =0;\\n        int high = nums.size() - 1;\\n        while(mid<=high){\\n            if(nums[mid] == 1){\\n                mid++;\\n            }\\n            if(nums[mid] == 0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            if(nums[mid] == 2){\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        } \\n    }\\n};"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "[@mohdsiddiq74432](/mohdsiddiq74432)  if nums[mid] condition evaluates how is mid incremented?\\n "
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "because if u r not using \"else if\" then the code evaluates for nums[mid] after every if statement, where mid is incremented...hence usage of else if avoids re evalution of nums[mid] in the same iteration. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I wonder why two pointer one from beginning and one from end while(l<=r) with swapping and conditions is not sorting the array\\n"
                    }
                ]
            },
            {
                "id": 1964209,
                "content": [
                    {
                        "username": "Shanthinath",
                        "content": "\\nStriver approach \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_Manjunath_Naik",
                        "content": "Selection Sort Application question . \\n\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "The desperate urge to write `nums.sort()`. But not the way to solve this. "
                    },
                    {
                        "username": "iam_gauravkumar",
                        "content": "We can use Dutch National Flag algorithm."
                    },
                    {
                        "username": "apexabim09",
                        "content": "DNF algorithm is the key"
                    },
                    {
                        "username": "aseshbasub1",
                        "content": "This isnt accepted here in leetcode but runs fine on my laptop ide. why?\\na,b,c=[],[],[]\\nfor i in nums:\\n    if i==0:\\n        a.append(i)\\n    elif i==1:\\n        b.append(i)\\n    elif i==2:\\n        c.append(i)\\nnums=a+b+c\\n"
                    },
                    {
                        "username": "4mithm",
                        "content": "If I am creating a new list of a+b+c and sending its reference to the variable \"nums\", there is a possibility that LeetCode is still referring to the old \"nums\" reference."
                    },
                    {
                        "username": "gs9672",
                        "content": "[@JackWoah](/JackWoah) what is difference between both like nums[]=a+b+c and nums[:]=a+b+c"
                    },
                    {
                        "username": "JackWoah",
                        "content": "nums[:]=a+b+c will work"
                    },
                    {
                        "username": "piyush_11",
                        "content": "int low = 0, mid = 0, high = n - 1; // 3 pointers\\n\\n        while (mid <= high) {\\n            if (arr[mid] == 0) {\\n                // swapping arr[low] and arr[mid]\\n                int temp = arr[low];\\n                arr[low] = arr[mid];\\n                arr[mid] = temp;\\n\\n                low++;\\n                mid++;\\n\\n            } else if (arr[mid] == 1) {\\n                mid++;\\n\\n            } else {\\n                // swapping arr[mid] and arr[high]\\n                int temp = arr[mid];\\n                arr[mid] = arr[high];\\n                arr[high] = temp;\\n\\n                high--;\\n            }\\nusing Dutch National Flag Algorithm -- one pas  - O(N) SC - O(1).   (JAVA)\\n"
                    },
                    {
                        "username": "sahil_gpt11",
                        "content": "why can\\'t we use mergesort here?"
                    },
                    {
                        "username": "kokushibo627",
                        "content": "you can use merge sort, but the complexity would be O(nlogn), while by using DNF Algo/3 way partitioning, we do it in O(n) and the array is traversed just once\\nyou can also use 2 pass algorithm to do it in O(n), but that requires to traverse the array twice\\n"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "why is this code giving a wrong output?\\ninstead of taking if ,else,else if conditions i have taken 3 if conditions why is it wrong?\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        //DNF SORT\\n        int low  =0, mid =0;\\n        int high = nums.size() - 1;\\n        while(mid<=high){\\n            if(nums[mid] == 1){\\n                mid++;\\n            }\\n            if(nums[mid] == 0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            if(nums[mid] == 2){\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        } \\n    }\\n};"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "[@mohdsiddiq74432](/mohdsiddiq74432)  if nums[mid] condition evaluates how is mid incremented?\\n "
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "because if u r not using \"else if\" then the code evaluates for nums[mid] after every if statement, where mid is incremented...hence usage of else if avoids re evalution of nums[mid] in the same iteration. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I wonder why two pointer one from beginning and one from end while(l<=r) with swapping and conditions is not sorting the array\\n"
                    }
                ]
            },
            {
                "id": 1957407,
                "content": [
                    {
                        "username": "Shanthinath",
                        "content": "\\nStriver approach \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_Manjunath_Naik",
                        "content": "Selection Sort Application question . \\n\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "The desperate urge to write `nums.sort()`. But not the way to solve this. "
                    },
                    {
                        "username": "iam_gauravkumar",
                        "content": "We can use Dutch National Flag algorithm."
                    },
                    {
                        "username": "apexabim09",
                        "content": "DNF algorithm is the key"
                    },
                    {
                        "username": "aseshbasub1",
                        "content": "This isnt accepted here in leetcode but runs fine on my laptop ide. why?\\na,b,c=[],[],[]\\nfor i in nums:\\n    if i==0:\\n        a.append(i)\\n    elif i==1:\\n        b.append(i)\\n    elif i==2:\\n        c.append(i)\\nnums=a+b+c\\n"
                    },
                    {
                        "username": "4mithm",
                        "content": "If I am creating a new list of a+b+c and sending its reference to the variable \"nums\", there is a possibility that LeetCode is still referring to the old \"nums\" reference."
                    },
                    {
                        "username": "gs9672",
                        "content": "[@JackWoah](/JackWoah) what is difference between both like nums[]=a+b+c and nums[:]=a+b+c"
                    },
                    {
                        "username": "JackWoah",
                        "content": "nums[:]=a+b+c will work"
                    },
                    {
                        "username": "piyush_11",
                        "content": "int low = 0, mid = 0, high = n - 1; // 3 pointers\\n\\n        while (mid <= high) {\\n            if (arr[mid] == 0) {\\n                // swapping arr[low] and arr[mid]\\n                int temp = arr[low];\\n                arr[low] = arr[mid];\\n                arr[mid] = temp;\\n\\n                low++;\\n                mid++;\\n\\n            } else if (arr[mid] == 1) {\\n                mid++;\\n\\n            } else {\\n                // swapping arr[mid] and arr[high]\\n                int temp = arr[mid];\\n                arr[mid] = arr[high];\\n                arr[high] = temp;\\n\\n                high--;\\n            }\\nusing Dutch National Flag Algorithm -- one pas  - O(N) SC - O(1).   (JAVA)\\n"
                    },
                    {
                        "username": "sahil_gpt11",
                        "content": "why can\\'t we use mergesort here?"
                    },
                    {
                        "username": "kokushibo627",
                        "content": "you can use merge sort, but the complexity would be O(nlogn), while by using DNF Algo/3 way partitioning, we do it in O(n) and the array is traversed just once\\nyou can also use 2 pass algorithm to do it in O(n), but that requires to traverse the array twice\\n"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "why is this code giving a wrong output?\\ninstead of taking if ,else,else if conditions i have taken 3 if conditions why is it wrong?\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        //DNF SORT\\n        int low  =0, mid =0;\\n        int high = nums.size() - 1;\\n        while(mid<=high){\\n            if(nums[mid] == 1){\\n                mid++;\\n            }\\n            if(nums[mid] == 0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            if(nums[mid] == 2){\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        } \\n    }\\n};"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "[@mohdsiddiq74432](/mohdsiddiq74432)  if nums[mid] condition evaluates how is mid incremented?\\n "
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "because if u r not using \"else if\" then the code evaluates for nums[mid] after every if statement, where mid is incremented...hence usage of else if avoids re evalution of nums[mid] in the same iteration. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I wonder why two pointer one from beginning and one from end while(l<=r) with swapping and conditions is not sorting the array\\n"
                    }
                ]
            },
            {
                "id": 1944624,
                "content": [
                    {
                        "username": "Shanthinath",
                        "content": "\\nStriver approach \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_Manjunath_Naik",
                        "content": "Selection Sort Application question . \\n\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "The desperate urge to write `nums.sort()`. But not the way to solve this. "
                    },
                    {
                        "username": "iam_gauravkumar",
                        "content": "We can use Dutch National Flag algorithm."
                    },
                    {
                        "username": "apexabim09",
                        "content": "DNF algorithm is the key"
                    },
                    {
                        "username": "aseshbasub1",
                        "content": "This isnt accepted here in leetcode but runs fine on my laptop ide. why?\\na,b,c=[],[],[]\\nfor i in nums:\\n    if i==0:\\n        a.append(i)\\n    elif i==1:\\n        b.append(i)\\n    elif i==2:\\n        c.append(i)\\nnums=a+b+c\\n"
                    },
                    {
                        "username": "4mithm",
                        "content": "If I am creating a new list of a+b+c and sending its reference to the variable \"nums\", there is a possibility that LeetCode is still referring to the old \"nums\" reference."
                    },
                    {
                        "username": "gs9672",
                        "content": "[@JackWoah](/JackWoah) what is difference between both like nums[]=a+b+c and nums[:]=a+b+c"
                    },
                    {
                        "username": "JackWoah",
                        "content": "nums[:]=a+b+c will work"
                    },
                    {
                        "username": "piyush_11",
                        "content": "int low = 0, mid = 0, high = n - 1; // 3 pointers\\n\\n        while (mid <= high) {\\n            if (arr[mid] == 0) {\\n                // swapping arr[low] and arr[mid]\\n                int temp = arr[low];\\n                arr[low] = arr[mid];\\n                arr[mid] = temp;\\n\\n                low++;\\n                mid++;\\n\\n            } else if (arr[mid] == 1) {\\n                mid++;\\n\\n            } else {\\n                // swapping arr[mid] and arr[high]\\n                int temp = arr[mid];\\n                arr[mid] = arr[high];\\n                arr[high] = temp;\\n\\n                high--;\\n            }\\nusing Dutch National Flag Algorithm -- one pas  - O(N) SC - O(1).   (JAVA)\\n"
                    },
                    {
                        "username": "sahil_gpt11",
                        "content": "why can\\'t we use mergesort here?"
                    },
                    {
                        "username": "kokushibo627",
                        "content": "you can use merge sort, but the complexity would be O(nlogn), while by using DNF Algo/3 way partitioning, we do it in O(n) and the array is traversed just once\\nyou can also use 2 pass algorithm to do it in O(n), but that requires to traverse the array twice\\n"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "why is this code giving a wrong output?\\ninstead of taking if ,else,else if conditions i have taken 3 if conditions why is it wrong?\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        //DNF SORT\\n        int low  =0, mid =0;\\n        int high = nums.size() - 1;\\n        while(mid<=high){\\n            if(nums[mid] == 1){\\n                mid++;\\n            }\\n            if(nums[mid] == 0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            if(nums[mid] == 2){\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        } \\n    }\\n};"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "[@mohdsiddiq74432](/mohdsiddiq74432)  if nums[mid] condition evaluates how is mid incremented?\\n "
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "because if u r not using \"else if\" then the code evaluates for nums[mid] after every if statement, where mid is incremented...hence usage of else if avoids re evalution of nums[mid] in the same iteration. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I wonder why two pointer one from beginning and one from end while(l<=r) with swapping and conditions is not sorting the array\\n"
                    }
                ]
            },
            {
                "id": 1937405,
                "content": [
                    {
                        "username": "Shanthinath",
                        "content": "\\nStriver approach \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_Manjunath_Naik",
                        "content": "Selection Sort Application question . \\n\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "The desperate urge to write `nums.sort()`. But not the way to solve this. "
                    },
                    {
                        "username": "iam_gauravkumar",
                        "content": "We can use Dutch National Flag algorithm."
                    },
                    {
                        "username": "apexabim09",
                        "content": "DNF algorithm is the key"
                    },
                    {
                        "username": "aseshbasub1",
                        "content": "This isnt accepted here in leetcode but runs fine on my laptop ide. why?\\na,b,c=[],[],[]\\nfor i in nums:\\n    if i==0:\\n        a.append(i)\\n    elif i==1:\\n        b.append(i)\\n    elif i==2:\\n        c.append(i)\\nnums=a+b+c\\n"
                    },
                    {
                        "username": "4mithm",
                        "content": "If I am creating a new list of a+b+c and sending its reference to the variable \"nums\", there is a possibility that LeetCode is still referring to the old \"nums\" reference."
                    },
                    {
                        "username": "gs9672",
                        "content": "[@JackWoah](/JackWoah) what is difference between both like nums[]=a+b+c and nums[:]=a+b+c"
                    },
                    {
                        "username": "JackWoah",
                        "content": "nums[:]=a+b+c will work"
                    },
                    {
                        "username": "piyush_11",
                        "content": "int low = 0, mid = 0, high = n - 1; // 3 pointers\\n\\n        while (mid <= high) {\\n            if (arr[mid] == 0) {\\n                // swapping arr[low] and arr[mid]\\n                int temp = arr[low];\\n                arr[low] = arr[mid];\\n                arr[mid] = temp;\\n\\n                low++;\\n                mid++;\\n\\n            } else if (arr[mid] == 1) {\\n                mid++;\\n\\n            } else {\\n                // swapping arr[mid] and arr[high]\\n                int temp = arr[mid];\\n                arr[mid] = arr[high];\\n                arr[high] = temp;\\n\\n                high--;\\n            }\\nusing Dutch National Flag Algorithm -- one pas  - O(N) SC - O(1).   (JAVA)\\n"
                    },
                    {
                        "username": "sahil_gpt11",
                        "content": "why can\\'t we use mergesort here?"
                    },
                    {
                        "username": "kokushibo627",
                        "content": "you can use merge sort, but the complexity would be O(nlogn), while by using DNF Algo/3 way partitioning, we do it in O(n) and the array is traversed just once\\nyou can also use 2 pass algorithm to do it in O(n), but that requires to traverse the array twice\\n"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "why is this code giving a wrong output?\\ninstead of taking if ,else,else if conditions i have taken 3 if conditions why is it wrong?\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        //DNF SORT\\n        int low  =0, mid =0;\\n        int high = nums.size() - 1;\\n        while(mid<=high){\\n            if(nums[mid] == 1){\\n                mid++;\\n            }\\n            if(nums[mid] == 0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            if(nums[mid] == 2){\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        } \\n    }\\n};"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "[@mohdsiddiq74432](/mohdsiddiq74432)  if nums[mid] condition evaluates how is mid incremented?\\n "
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "because if u r not using \"else if\" then the code evaluates for nums[mid] after every if statement, where mid is incremented...hence usage of else if avoids re evalution of nums[mid] in the same iteration. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I wonder why two pointer one from beginning and one from end while(l<=r) with swapping and conditions is not sorting the array\\n"
                    }
                ]
            },
            {
                "id": 1930329,
                "content": [
                    {
                        "username": "Shanthinath",
                        "content": "\\nStriver approach \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_Manjunath_Naik",
                        "content": "Selection Sort Application question . \\n\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "The desperate urge to write `nums.sort()`. But not the way to solve this. "
                    },
                    {
                        "username": "iam_gauravkumar",
                        "content": "We can use Dutch National Flag algorithm."
                    },
                    {
                        "username": "apexabim09",
                        "content": "DNF algorithm is the key"
                    },
                    {
                        "username": "aseshbasub1",
                        "content": "This isnt accepted here in leetcode but runs fine on my laptop ide. why?\\na,b,c=[],[],[]\\nfor i in nums:\\n    if i==0:\\n        a.append(i)\\n    elif i==1:\\n        b.append(i)\\n    elif i==2:\\n        c.append(i)\\nnums=a+b+c\\n"
                    },
                    {
                        "username": "4mithm",
                        "content": "If I am creating a new list of a+b+c and sending its reference to the variable \"nums\", there is a possibility that LeetCode is still referring to the old \"nums\" reference."
                    },
                    {
                        "username": "gs9672",
                        "content": "[@JackWoah](/JackWoah) what is difference between both like nums[]=a+b+c and nums[:]=a+b+c"
                    },
                    {
                        "username": "JackWoah",
                        "content": "nums[:]=a+b+c will work"
                    },
                    {
                        "username": "piyush_11",
                        "content": "int low = 0, mid = 0, high = n - 1; // 3 pointers\\n\\n        while (mid <= high) {\\n            if (arr[mid] == 0) {\\n                // swapping arr[low] and arr[mid]\\n                int temp = arr[low];\\n                arr[low] = arr[mid];\\n                arr[mid] = temp;\\n\\n                low++;\\n                mid++;\\n\\n            } else if (arr[mid] == 1) {\\n                mid++;\\n\\n            } else {\\n                // swapping arr[mid] and arr[high]\\n                int temp = arr[mid];\\n                arr[mid] = arr[high];\\n                arr[high] = temp;\\n\\n                high--;\\n            }\\nusing Dutch National Flag Algorithm -- one pas  - O(N) SC - O(1).   (JAVA)\\n"
                    },
                    {
                        "username": "sahil_gpt11",
                        "content": "why can\\'t we use mergesort here?"
                    },
                    {
                        "username": "kokushibo627",
                        "content": "you can use merge sort, but the complexity would be O(nlogn), while by using DNF Algo/3 way partitioning, we do it in O(n) and the array is traversed just once\\nyou can also use 2 pass algorithm to do it in O(n), but that requires to traverse the array twice\\n"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "why is this code giving a wrong output?\\ninstead of taking if ,else,else if conditions i have taken 3 if conditions why is it wrong?\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        //DNF SORT\\n        int low  =0, mid =0;\\n        int high = nums.size() - 1;\\n        while(mid<=high){\\n            if(nums[mid] == 1){\\n                mid++;\\n            }\\n            if(nums[mid] == 0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            if(nums[mid] == 2){\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        } \\n    }\\n};"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "[@mohdsiddiq74432](/mohdsiddiq74432)  if nums[mid] condition evaluates how is mid incremented?\\n "
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "because if u r not using \"else if\" then the code evaluates for nums[mid] after every if statement, where mid is incremented...hence usage of else if avoids re evalution of nums[mid] in the same iteration. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I wonder why two pointer one from beginning and one from end while(l<=r) with swapping and conditions is not sorting the array\\n"
                    }
                ]
            },
            {
                "id": 1927003,
                "content": [
                    {
                        "username": "Shanthinath",
                        "content": "\\nStriver approach \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_Manjunath_Naik",
                        "content": "Selection Sort Application question . \\n\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "The desperate urge to write `nums.sort()`. But not the way to solve this. "
                    },
                    {
                        "username": "iam_gauravkumar",
                        "content": "We can use Dutch National Flag algorithm."
                    },
                    {
                        "username": "apexabim09",
                        "content": "DNF algorithm is the key"
                    },
                    {
                        "username": "aseshbasub1",
                        "content": "This isnt accepted here in leetcode but runs fine on my laptop ide. why?\\na,b,c=[],[],[]\\nfor i in nums:\\n    if i==0:\\n        a.append(i)\\n    elif i==1:\\n        b.append(i)\\n    elif i==2:\\n        c.append(i)\\nnums=a+b+c\\n"
                    },
                    {
                        "username": "4mithm",
                        "content": "If I am creating a new list of a+b+c and sending its reference to the variable \"nums\", there is a possibility that LeetCode is still referring to the old \"nums\" reference."
                    },
                    {
                        "username": "gs9672",
                        "content": "[@JackWoah](/JackWoah) what is difference between both like nums[]=a+b+c and nums[:]=a+b+c"
                    },
                    {
                        "username": "JackWoah",
                        "content": "nums[:]=a+b+c will work"
                    },
                    {
                        "username": "piyush_11",
                        "content": "int low = 0, mid = 0, high = n - 1; // 3 pointers\\n\\n        while (mid <= high) {\\n            if (arr[mid] == 0) {\\n                // swapping arr[low] and arr[mid]\\n                int temp = arr[low];\\n                arr[low] = arr[mid];\\n                arr[mid] = temp;\\n\\n                low++;\\n                mid++;\\n\\n            } else if (arr[mid] == 1) {\\n                mid++;\\n\\n            } else {\\n                // swapping arr[mid] and arr[high]\\n                int temp = arr[mid];\\n                arr[mid] = arr[high];\\n                arr[high] = temp;\\n\\n                high--;\\n            }\\nusing Dutch National Flag Algorithm -- one pas  - O(N) SC - O(1).   (JAVA)\\n"
                    },
                    {
                        "username": "sahil_gpt11",
                        "content": "why can\\'t we use mergesort here?"
                    },
                    {
                        "username": "kokushibo627",
                        "content": "you can use merge sort, but the complexity would be O(nlogn), while by using DNF Algo/3 way partitioning, we do it in O(n) and the array is traversed just once\\nyou can also use 2 pass algorithm to do it in O(n), but that requires to traverse the array twice\\n"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "why is this code giving a wrong output?\\ninstead of taking if ,else,else if conditions i have taken 3 if conditions why is it wrong?\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        //DNF SORT\\n        int low  =0, mid =0;\\n        int high = nums.size() - 1;\\n        while(mid<=high){\\n            if(nums[mid] == 1){\\n                mid++;\\n            }\\n            if(nums[mid] == 0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            if(nums[mid] == 2){\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        } \\n    }\\n};"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "[@mohdsiddiq74432](/mohdsiddiq74432)  if nums[mid] condition evaluates how is mid incremented?\\n "
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "because if u r not using \"else if\" then the code evaluates for nums[mid] after every if statement, where mid is incremented...hence usage of else if avoids re evalution of nums[mid] in the same iteration. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I wonder why two pointer one from beginning and one from end while(l<=r) with swapping and conditions is not sorting the array\\n"
                    }
                ]
            },
            {
                "id": 1915656,
                "content": [
                    {
                        "username": "Shanthinath",
                        "content": "\\nStriver approach \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_Manjunath_Naik",
                        "content": "Selection Sort Application question . \\n\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "The desperate urge to write `nums.sort()`. But not the way to solve this. "
                    },
                    {
                        "username": "iam_gauravkumar",
                        "content": "We can use Dutch National Flag algorithm."
                    },
                    {
                        "username": "apexabim09",
                        "content": "DNF algorithm is the key"
                    },
                    {
                        "username": "aseshbasub1",
                        "content": "This isnt accepted here in leetcode but runs fine on my laptop ide. why?\\na,b,c=[],[],[]\\nfor i in nums:\\n    if i==0:\\n        a.append(i)\\n    elif i==1:\\n        b.append(i)\\n    elif i==2:\\n        c.append(i)\\nnums=a+b+c\\n"
                    },
                    {
                        "username": "4mithm",
                        "content": "If I am creating a new list of a+b+c and sending its reference to the variable \"nums\", there is a possibility that LeetCode is still referring to the old \"nums\" reference."
                    },
                    {
                        "username": "gs9672",
                        "content": "[@JackWoah](/JackWoah) what is difference between both like nums[]=a+b+c and nums[:]=a+b+c"
                    },
                    {
                        "username": "JackWoah",
                        "content": "nums[:]=a+b+c will work"
                    },
                    {
                        "username": "piyush_11",
                        "content": "int low = 0, mid = 0, high = n - 1; // 3 pointers\\n\\n        while (mid <= high) {\\n            if (arr[mid] == 0) {\\n                // swapping arr[low] and arr[mid]\\n                int temp = arr[low];\\n                arr[low] = arr[mid];\\n                arr[mid] = temp;\\n\\n                low++;\\n                mid++;\\n\\n            } else if (arr[mid] == 1) {\\n                mid++;\\n\\n            } else {\\n                // swapping arr[mid] and arr[high]\\n                int temp = arr[mid];\\n                arr[mid] = arr[high];\\n                arr[high] = temp;\\n\\n                high--;\\n            }\\nusing Dutch National Flag Algorithm -- one pas  - O(N) SC - O(1).   (JAVA)\\n"
                    },
                    {
                        "username": "sahil_gpt11",
                        "content": "why can\\'t we use mergesort here?"
                    },
                    {
                        "username": "kokushibo627",
                        "content": "you can use merge sort, but the complexity would be O(nlogn), while by using DNF Algo/3 way partitioning, we do it in O(n) and the array is traversed just once\\nyou can also use 2 pass algorithm to do it in O(n), but that requires to traverse the array twice\\n"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "why is this code giving a wrong output?\\ninstead of taking if ,else,else if conditions i have taken 3 if conditions why is it wrong?\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        //DNF SORT\\n        int low  =0, mid =0;\\n        int high = nums.size() - 1;\\n        while(mid<=high){\\n            if(nums[mid] == 1){\\n                mid++;\\n            }\\n            if(nums[mid] == 0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            if(nums[mid] == 2){\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        } \\n    }\\n};"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "[@mohdsiddiq74432](/mohdsiddiq74432)  if nums[mid] condition evaluates how is mid incremented?\\n "
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "because if u r not using \"else if\" then the code evaluates for nums[mid] after every if statement, where mid is incremented...hence usage of else if avoids re evalution of nums[mid] in the same iteration. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I wonder why two pointer one from beginning and one from end while(l<=r) with swapping and conditions is not sorting the array\\n"
                    }
                ]
            },
            {
                "id": 1902567,
                "content": [
                    {
                        "username": "Shanthinath",
                        "content": "\\nStriver approach \\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0,mid=0,high=n-1;\\n        while(mid<=high)\\n        {\\n            if(nums[mid]==0)\\n            {\\n                swap(nums[low],nums[mid]);\\n                mid++;\\n                low++;\\n            }\\n            else if(nums[mid]==1)\\n            {\\n                mid++;\\n            }\\n            else\\n            {\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_Manjunath_Naik",
                        "content": "Selection Sort Application question . \\n\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "The desperate urge to write `nums.sort()`. But not the way to solve this. "
                    },
                    {
                        "username": "iam_gauravkumar",
                        "content": "We can use Dutch National Flag algorithm."
                    },
                    {
                        "username": "apexabim09",
                        "content": "DNF algorithm is the key"
                    },
                    {
                        "username": "aseshbasub1",
                        "content": "This isnt accepted here in leetcode but runs fine on my laptop ide. why?\\na,b,c=[],[],[]\\nfor i in nums:\\n    if i==0:\\n        a.append(i)\\n    elif i==1:\\n        b.append(i)\\n    elif i==2:\\n        c.append(i)\\nnums=a+b+c\\n"
                    },
                    {
                        "username": "4mithm",
                        "content": "If I am creating a new list of a+b+c and sending its reference to the variable \"nums\", there is a possibility that LeetCode is still referring to the old \"nums\" reference."
                    },
                    {
                        "username": "gs9672",
                        "content": "[@JackWoah](/JackWoah) what is difference between both like nums[]=a+b+c and nums[:]=a+b+c"
                    },
                    {
                        "username": "JackWoah",
                        "content": "nums[:]=a+b+c will work"
                    },
                    {
                        "username": "piyush_11",
                        "content": "int low = 0, mid = 0, high = n - 1; // 3 pointers\\n\\n        while (mid <= high) {\\n            if (arr[mid] == 0) {\\n                // swapping arr[low] and arr[mid]\\n                int temp = arr[low];\\n                arr[low] = arr[mid];\\n                arr[mid] = temp;\\n\\n                low++;\\n                mid++;\\n\\n            } else if (arr[mid] == 1) {\\n                mid++;\\n\\n            } else {\\n                // swapping arr[mid] and arr[high]\\n                int temp = arr[mid];\\n                arr[mid] = arr[high];\\n                arr[high] = temp;\\n\\n                high--;\\n            }\\nusing Dutch National Flag Algorithm -- one pas  - O(N) SC - O(1).   (JAVA)\\n"
                    },
                    {
                        "username": "sahil_gpt11",
                        "content": "why can\\'t we use mergesort here?"
                    },
                    {
                        "username": "kokushibo627",
                        "content": "you can use merge sort, but the complexity would be O(nlogn), while by using DNF Algo/3 way partitioning, we do it in O(n) and the array is traversed just once\\nyou can also use 2 pass algorithm to do it in O(n), but that requires to traverse the array twice\\n"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "why is this code giving a wrong output?\\ninstead of taking if ,else,else if conditions i have taken 3 if conditions why is it wrong?\\n\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        //DNF SORT\\n        int low  =0, mid =0;\\n        int high = nums.size() - 1;\\n        while(mid<=high){\\n            if(nums[mid] == 1){\\n                mid++;\\n            }\\n            if(nums[mid] == 0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            if(nums[mid] == 2){\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        } \\n    }\\n};"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "[@mohdsiddiq74432](/mohdsiddiq74432)  if nums[mid] condition evaluates how is mid incremented?\\n "
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "because if u r not using \"else if\" then the code evaluates for nums[mid] after every if statement, where mid is incremented...hence usage of else if avoids re evalution of nums[mid] in the same iteration. "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I wonder why two pointer one from beginning and one from end while(l<=r) with swapping and conditions is not sorting the array\\n"
                    }
                ]
            },
            {
                "id": 1897980,
                "content": [
                    {
                        "username": "NidhiChaudhary2002",
                        "content": "If anyone wondering about it being a medium level ques .This question aims to make you learn Dutch National Flag Algorithm."
                    },
                    {
                        "username": "BobIAmCalled",
                        "content": "My Python3 code works fine when I run it on my own laptop, but on LeetCode it returns the wrong output. Why is this?\\n\\nCode:\\n\\n    class Solution:\\n        def sortColors(self, nums: List[int]) -> None:\\n            for i in range(len(nums)):\\n                if nums[len(nums) - 1 - i] == 2:\\n                    toAdd = nums.pop(len(nums) - 1 - i)\\n                    nums = nums + [toAdd]\\n            for i in range(len(nums)):\\n                if nums[i] == 0:\\n                    nums = [nums.pop(i)] + nums\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\nSpecifically, with the input [2,0,2,1,1,0] it correctly returns [0,0,1,1,2,2] on my laptop, but returns [2,0,1,1,0] on LeetCode.\\n\\nSimilarly, with the input [2,0,1] it correctly returns [0,1,2] on my laptop, but returns [0,1] on LeetCode.\\n"
                    },
                    {
                        "username": "satyam2303",
                        "content": "i only did\\nsort(nums.begin(),nums.end());\\nand it will get accepted"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "but thats not the way,how it should be done"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "we shouldn\\'t use any inbuilt functions "
                    },
                    {
                        "username": "kalebalti",
                        "content": "Isn\\'t it just fancy type of asking \"do any kind of sorting in increasing order\"?"
                    },
                    {
                        "username": "2004divija",
                        "content": " void sortColors(vector<int>& nums) {\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j =i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    swap(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n        }\\n\\n    }"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "princetiwari97940",
                        "content": "can\\'t we just sort using any sorting algo ?"
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "No sorting Algo can do it in one pass."
                    },
                    {
                        "username": "AmSumit02",
                        "content": "I have implemented it using multiset. I am getting the right answer but still, the editor is saying it\\'s wrong.\\n `class Solution {\\npublic:\\n    \\n    vector<int> sortColors(vector<int>& nums) {\\n    \\n        multiset<int> mult(nums.begin(),nums.end());\\n        vector<int> v;\\n        \\n        for(auto x : mult){\\n           v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n\\'\\n"
                    },
                    {
                        "username": "Hiding_as",
                        "content": "Just count the number of 0s 1s and 2s passing once. Rewrite the original array using the count as reference? "
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Since there are only three numbers in an array,  one type of partitions can guarantee this distribution"
                    }
                ]
            },
            {
                "id": 1897348,
                "content": [
                    {
                        "username": "NidhiChaudhary2002",
                        "content": "If anyone wondering about it being a medium level ques .This question aims to make you learn Dutch National Flag Algorithm."
                    },
                    {
                        "username": "BobIAmCalled",
                        "content": "My Python3 code works fine when I run it on my own laptop, but on LeetCode it returns the wrong output. Why is this?\\n\\nCode:\\n\\n    class Solution:\\n        def sortColors(self, nums: List[int]) -> None:\\n            for i in range(len(nums)):\\n                if nums[len(nums) - 1 - i] == 2:\\n                    toAdd = nums.pop(len(nums) - 1 - i)\\n                    nums = nums + [toAdd]\\n            for i in range(len(nums)):\\n                if nums[i] == 0:\\n                    nums = [nums.pop(i)] + nums\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\nSpecifically, with the input [2,0,2,1,1,0] it correctly returns [0,0,1,1,2,2] on my laptop, but returns [2,0,1,1,0] on LeetCode.\\n\\nSimilarly, with the input [2,0,1] it correctly returns [0,1,2] on my laptop, but returns [0,1] on LeetCode.\\n"
                    },
                    {
                        "username": "satyam2303",
                        "content": "i only did\\nsort(nums.begin(),nums.end());\\nand it will get accepted"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "but thats not the way,how it should be done"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "we shouldn\\'t use any inbuilt functions "
                    },
                    {
                        "username": "kalebalti",
                        "content": "Isn\\'t it just fancy type of asking \"do any kind of sorting in increasing order\"?"
                    },
                    {
                        "username": "2004divija",
                        "content": " void sortColors(vector<int>& nums) {\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j =i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    swap(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n        }\\n\\n    }"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "princetiwari97940",
                        "content": "can\\'t we just sort using any sorting algo ?"
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "No sorting Algo can do it in one pass."
                    },
                    {
                        "username": "AmSumit02",
                        "content": "I have implemented it using multiset. I am getting the right answer but still, the editor is saying it\\'s wrong.\\n `class Solution {\\npublic:\\n    \\n    vector<int> sortColors(vector<int>& nums) {\\n    \\n        multiset<int> mult(nums.begin(),nums.end());\\n        vector<int> v;\\n        \\n        for(auto x : mult){\\n           v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n\\'\\n"
                    },
                    {
                        "username": "Hiding_as",
                        "content": "Just count the number of 0s 1s and 2s passing once. Rewrite the original array using the count as reference? "
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Since there are only three numbers in an array,  one type of partitions can guarantee this distribution"
                    }
                ]
            },
            {
                "id": 1889478,
                "content": [
                    {
                        "username": "NidhiChaudhary2002",
                        "content": "If anyone wondering about it being a medium level ques .This question aims to make you learn Dutch National Flag Algorithm."
                    },
                    {
                        "username": "BobIAmCalled",
                        "content": "My Python3 code works fine when I run it on my own laptop, but on LeetCode it returns the wrong output. Why is this?\\n\\nCode:\\n\\n    class Solution:\\n        def sortColors(self, nums: List[int]) -> None:\\n            for i in range(len(nums)):\\n                if nums[len(nums) - 1 - i] == 2:\\n                    toAdd = nums.pop(len(nums) - 1 - i)\\n                    nums = nums + [toAdd]\\n            for i in range(len(nums)):\\n                if nums[i] == 0:\\n                    nums = [nums.pop(i)] + nums\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\nSpecifically, with the input [2,0,2,1,1,0] it correctly returns [0,0,1,1,2,2] on my laptop, but returns [2,0,1,1,0] on LeetCode.\\n\\nSimilarly, with the input [2,0,1] it correctly returns [0,1,2] on my laptop, but returns [0,1] on LeetCode.\\n"
                    },
                    {
                        "username": "satyam2303",
                        "content": "i only did\\nsort(nums.begin(),nums.end());\\nand it will get accepted"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "but thats not the way,how it should be done"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "we shouldn\\'t use any inbuilt functions "
                    },
                    {
                        "username": "kalebalti",
                        "content": "Isn\\'t it just fancy type of asking \"do any kind of sorting in increasing order\"?"
                    },
                    {
                        "username": "2004divija",
                        "content": " void sortColors(vector<int>& nums) {\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j =i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    swap(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n        }\\n\\n    }"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "princetiwari97940",
                        "content": "can\\'t we just sort using any sorting algo ?"
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "No sorting Algo can do it in one pass."
                    },
                    {
                        "username": "AmSumit02",
                        "content": "I have implemented it using multiset. I am getting the right answer but still, the editor is saying it\\'s wrong.\\n `class Solution {\\npublic:\\n    \\n    vector<int> sortColors(vector<int>& nums) {\\n    \\n        multiset<int> mult(nums.begin(),nums.end());\\n        vector<int> v;\\n        \\n        for(auto x : mult){\\n           v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n\\'\\n"
                    },
                    {
                        "username": "Hiding_as",
                        "content": "Just count the number of 0s 1s and 2s passing once. Rewrite the original array using the count as reference? "
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Since there are only three numbers in an array,  one type of partitions can guarantee this distribution"
                    }
                ]
            },
            {
                "id": 1873492,
                "content": [
                    {
                        "username": "NidhiChaudhary2002",
                        "content": "If anyone wondering about it being a medium level ques .This question aims to make you learn Dutch National Flag Algorithm."
                    },
                    {
                        "username": "BobIAmCalled",
                        "content": "My Python3 code works fine when I run it on my own laptop, but on LeetCode it returns the wrong output. Why is this?\\n\\nCode:\\n\\n    class Solution:\\n        def sortColors(self, nums: List[int]) -> None:\\n            for i in range(len(nums)):\\n                if nums[len(nums) - 1 - i] == 2:\\n                    toAdd = nums.pop(len(nums) - 1 - i)\\n                    nums = nums + [toAdd]\\n            for i in range(len(nums)):\\n                if nums[i] == 0:\\n                    nums = [nums.pop(i)] + nums\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\nSpecifically, with the input [2,0,2,1,1,0] it correctly returns [0,0,1,1,2,2] on my laptop, but returns [2,0,1,1,0] on LeetCode.\\n\\nSimilarly, with the input [2,0,1] it correctly returns [0,1,2] on my laptop, but returns [0,1] on LeetCode.\\n"
                    },
                    {
                        "username": "satyam2303",
                        "content": "i only did\\nsort(nums.begin(),nums.end());\\nand it will get accepted"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "but thats not the way,how it should be done"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "we shouldn\\'t use any inbuilt functions "
                    },
                    {
                        "username": "kalebalti",
                        "content": "Isn\\'t it just fancy type of asking \"do any kind of sorting in increasing order\"?"
                    },
                    {
                        "username": "2004divija",
                        "content": " void sortColors(vector<int>& nums) {\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j =i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    swap(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n        }\\n\\n    }"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "princetiwari97940",
                        "content": "can\\'t we just sort using any sorting algo ?"
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "No sorting Algo can do it in one pass."
                    },
                    {
                        "username": "AmSumit02",
                        "content": "I have implemented it using multiset. I am getting the right answer but still, the editor is saying it\\'s wrong.\\n `class Solution {\\npublic:\\n    \\n    vector<int> sortColors(vector<int>& nums) {\\n    \\n        multiset<int> mult(nums.begin(),nums.end());\\n        vector<int> v;\\n        \\n        for(auto x : mult){\\n           v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n\\'\\n"
                    },
                    {
                        "username": "Hiding_as",
                        "content": "Just count the number of 0s 1s and 2s passing once. Rewrite the original array using the count as reference? "
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Since there are only three numbers in an array,  one type of partitions can guarantee this distribution"
                    }
                ]
            },
            {
                "id": 1865732,
                "content": [
                    {
                        "username": "NidhiChaudhary2002",
                        "content": "If anyone wondering about it being a medium level ques .This question aims to make you learn Dutch National Flag Algorithm."
                    },
                    {
                        "username": "BobIAmCalled",
                        "content": "My Python3 code works fine when I run it on my own laptop, but on LeetCode it returns the wrong output. Why is this?\\n\\nCode:\\n\\n    class Solution:\\n        def sortColors(self, nums: List[int]) -> None:\\n            for i in range(len(nums)):\\n                if nums[len(nums) - 1 - i] == 2:\\n                    toAdd = nums.pop(len(nums) - 1 - i)\\n                    nums = nums + [toAdd]\\n            for i in range(len(nums)):\\n                if nums[i] == 0:\\n                    nums = [nums.pop(i)] + nums\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\nSpecifically, with the input [2,0,2,1,1,0] it correctly returns [0,0,1,1,2,2] on my laptop, but returns [2,0,1,1,0] on LeetCode.\\n\\nSimilarly, with the input [2,0,1] it correctly returns [0,1,2] on my laptop, but returns [0,1] on LeetCode.\\n"
                    },
                    {
                        "username": "satyam2303",
                        "content": "i only did\\nsort(nums.begin(),nums.end());\\nand it will get accepted"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "but thats not the way,how it should be done"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "we shouldn\\'t use any inbuilt functions "
                    },
                    {
                        "username": "kalebalti",
                        "content": "Isn\\'t it just fancy type of asking \"do any kind of sorting in increasing order\"?"
                    },
                    {
                        "username": "2004divija",
                        "content": " void sortColors(vector<int>& nums) {\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j =i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    swap(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n        }\\n\\n    }"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "princetiwari97940",
                        "content": "can\\'t we just sort using any sorting algo ?"
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "No sorting Algo can do it in one pass."
                    },
                    {
                        "username": "AmSumit02",
                        "content": "I have implemented it using multiset. I am getting the right answer but still, the editor is saying it\\'s wrong.\\n `class Solution {\\npublic:\\n    \\n    vector<int> sortColors(vector<int>& nums) {\\n    \\n        multiset<int> mult(nums.begin(),nums.end());\\n        vector<int> v;\\n        \\n        for(auto x : mult){\\n           v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n\\'\\n"
                    },
                    {
                        "username": "Hiding_as",
                        "content": "Just count the number of 0s 1s and 2s passing once. Rewrite the original array using the count as reference? "
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Since there are only three numbers in an array,  one type of partitions can guarantee this distribution"
                    }
                ]
            },
            {
                "id": 1864644,
                "content": [
                    {
                        "username": "NidhiChaudhary2002",
                        "content": "If anyone wondering about it being a medium level ques .This question aims to make you learn Dutch National Flag Algorithm."
                    },
                    {
                        "username": "BobIAmCalled",
                        "content": "My Python3 code works fine when I run it on my own laptop, but on LeetCode it returns the wrong output. Why is this?\\n\\nCode:\\n\\n    class Solution:\\n        def sortColors(self, nums: List[int]) -> None:\\n            for i in range(len(nums)):\\n                if nums[len(nums) - 1 - i] == 2:\\n                    toAdd = nums.pop(len(nums) - 1 - i)\\n                    nums = nums + [toAdd]\\n            for i in range(len(nums)):\\n                if nums[i] == 0:\\n                    nums = [nums.pop(i)] + nums\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\nSpecifically, with the input [2,0,2,1,1,0] it correctly returns [0,0,1,1,2,2] on my laptop, but returns [2,0,1,1,0] on LeetCode.\\n\\nSimilarly, with the input [2,0,1] it correctly returns [0,1,2] on my laptop, but returns [0,1] on LeetCode.\\n"
                    },
                    {
                        "username": "satyam2303",
                        "content": "i only did\\nsort(nums.begin(),nums.end());\\nand it will get accepted"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "but thats not the way,how it should be done"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "we shouldn\\'t use any inbuilt functions "
                    },
                    {
                        "username": "kalebalti",
                        "content": "Isn\\'t it just fancy type of asking \"do any kind of sorting in increasing order\"?"
                    },
                    {
                        "username": "2004divija",
                        "content": " void sortColors(vector<int>& nums) {\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j =i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    swap(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n        }\\n\\n    }"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "princetiwari97940",
                        "content": "can\\'t we just sort using any sorting algo ?"
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "No sorting Algo can do it in one pass."
                    },
                    {
                        "username": "AmSumit02",
                        "content": "I have implemented it using multiset. I am getting the right answer but still, the editor is saying it\\'s wrong.\\n `class Solution {\\npublic:\\n    \\n    vector<int> sortColors(vector<int>& nums) {\\n    \\n        multiset<int> mult(nums.begin(),nums.end());\\n        vector<int> v;\\n        \\n        for(auto x : mult){\\n           v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n\\'\\n"
                    },
                    {
                        "username": "Hiding_as",
                        "content": "Just count the number of 0s 1s and 2s passing once. Rewrite the original array using the count as reference? "
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Since there are only three numbers in an array,  one type of partitions can guarantee this distribution"
                    }
                ]
            },
            {
                "id": 1860568,
                "content": [
                    {
                        "username": "NidhiChaudhary2002",
                        "content": "If anyone wondering about it being a medium level ques .This question aims to make you learn Dutch National Flag Algorithm."
                    },
                    {
                        "username": "BobIAmCalled",
                        "content": "My Python3 code works fine when I run it on my own laptop, but on LeetCode it returns the wrong output. Why is this?\\n\\nCode:\\n\\n    class Solution:\\n        def sortColors(self, nums: List[int]) -> None:\\n            for i in range(len(nums)):\\n                if nums[len(nums) - 1 - i] == 2:\\n                    toAdd = nums.pop(len(nums) - 1 - i)\\n                    nums = nums + [toAdd]\\n            for i in range(len(nums)):\\n                if nums[i] == 0:\\n                    nums = [nums.pop(i)] + nums\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\nSpecifically, with the input [2,0,2,1,1,0] it correctly returns [0,0,1,1,2,2] on my laptop, but returns [2,0,1,1,0] on LeetCode.\\n\\nSimilarly, with the input [2,0,1] it correctly returns [0,1,2] on my laptop, but returns [0,1] on LeetCode.\\n"
                    },
                    {
                        "username": "satyam2303",
                        "content": "i only did\\nsort(nums.begin(),nums.end());\\nand it will get accepted"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "but thats not the way,how it should be done"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "we shouldn\\'t use any inbuilt functions "
                    },
                    {
                        "username": "kalebalti",
                        "content": "Isn\\'t it just fancy type of asking \"do any kind of sorting in increasing order\"?"
                    },
                    {
                        "username": "2004divija",
                        "content": " void sortColors(vector<int>& nums) {\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j =i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    swap(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n        }\\n\\n    }"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "princetiwari97940",
                        "content": "can\\'t we just sort using any sorting algo ?"
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "No sorting Algo can do it in one pass."
                    },
                    {
                        "username": "AmSumit02",
                        "content": "I have implemented it using multiset. I am getting the right answer but still, the editor is saying it\\'s wrong.\\n `class Solution {\\npublic:\\n    \\n    vector<int> sortColors(vector<int>& nums) {\\n    \\n        multiset<int> mult(nums.begin(),nums.end());\\n        vector<int> v;\\n        \\n        for(auto x : mult){\\n           v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n\\'\\n"
                    },
                    {
                        "username": "Hiding_as",
                        "content": "Just count the number of 0s 1s and 2s passing once. Rewrite the original array using the count as reference? "
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Since there are only three numbers in an array,  one type of partitions can guarantee this distribution"
                    }
                ]
            },
            {
                "id": 1856798,
                "content": [
                    {
                        "username": "NidhiChaudhary2002",
                        "content": "If anyone wondering about it being a medium level ques .This question aims to make you learn Dutch National Flag Algorithm."
                    },
                    {
                        "username": "BobIAmCalled",
                        "content": "My Python3 code works fine when I run it on my own laptop, but on LeetCode it returns the wrong output. Why is this?\\n\\nCode:\\n\\n    class Solution:\\n        def sortColors(self, nums: List[int]) -> None:\\n            for i in range(len(nums)):\\n                if nums[len(nums) - 1 - i] == 2:\\n                    toAdd = nums.pop(len(nums) - 1 - i)\\n                    nums = nums + [toAdd]\\n            for i in range(len(nums)):\\n                if nums[i] == 0:\\n                    nums = [nums.pop(i)] + nums\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\nSpecifically, with the input [2,0,2,1,1,0] it correctly returns [0,0,1,1,2,2] on my laptop, but returns [2,0,1,1,0] on LeetCode.\\n\\nSimilarly, with the input [2,0,1] it correctly returns [0,1,2] on my laptop, but returns [0,1] on LeetCode.\\n"
                    },
                    {
                        "username": "satyam2303",
                        "content": "i only did\\nsort(nums.begin(),nums.end());\\nand it will get accepted"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "but thats not the way,how it should be done"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "we shouldn\\'t use any inbuilt functions "
                    },
                    {
                        "username": "kalebalti",
                        "content": "Isn\\'t it just fancy type of asking \"do any kind of sorting in increasing order\"?"
                    },
                    {
                        "username": "2004divija",
                        "content": " void sortColors(vector<int>& nums) {\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j =i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    swap(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n        }\\n\\n    }"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "princetiwari97940",
                        "content": "can\\'t we just sort using any sorting algo ?"
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "No sorting Algo can do it in one pass."
                    },
                    {
                        "username": "AmSumit02",
                        "content": "I have implemented it using multiset. I am getting the right answer but still, the editor is saying it\\'s wrong.\\n `class Solution {\\npublic:\\n    \\n    vector<int> sortColors(vector<int>& nums) {\\n    \\n        multiset<int> mult(nums.begin(),nums.end());\\n        vector<int> v;\\n        \\n        for(auto x : mult){\\n           v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n\\'\\n"
                    },
                    {
                        "username": "Hiding_as",
                        "content": "Just count the number of 0s 1s and 2s passing once. Rewrite the original array using the count as reference? "
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Since there are only three numbers in an array,  one type of partitions can guarantee this distribution"
                    }
                ]
            },
            {
                "id": 1850714,
                "content": [
                    {
                        "username": "NidhiChaudhary2002",
                        "content": "If anyone wondering about it being a medium level ques .This question aims to make you learn Dutch National Flag Algorithm."
                    },
                    {
                        "username": "BobIAmCalled",
                        "content": "My Python3 code works fine when I run it on my own laptop, but on LeetCode it returns the wrong output. Why is this?\\n\\nCode:\\n\\n    class Solution:\\n        def sortColors(self, nums: List[int]) -> None:\\n            for i in range(len(nums)):\\n                if nums[len(nums) - 1 - i] == 2:\\n                    toAdd = nums.pop(len(nums) - 1 - i)\\n                    nums = nums + [toAdd]\\n            for i in range(len(nums)):\\n                if nums[i] == 0:\\n                    nums = [nums.pop(i)] + nums\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\nSpecifically, with the input [2,0,2,1,1,0] it correctly returns [0,0,1,1,2,2] on my laptop, but returns [2,0,1,1,0] on LeetCode.\\n\\nSimilarly, with the input [2,0,1] it correctly returns [0,1,2] on my laptop, but returns [0,1] on LeetCode.\\n"
                    },
                    {
                        "username": "satyam2303",
                        "content": "i only did\\nsort(nums.begin(),nums.end());\\nand it will get accepted"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "but thats not the way,how it should be done"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "we shouldn\\'t use any inbuilt functions "
                    },
                    {
                        "username": "kalebalti",
                        "content": "Isn\\'t it just fancy type of asking \"do any kind of sorting in increasing order\"?"
                    },
                    {
                        "username": "2004divija",
                        "content": " void sortColors(vector<int>& nums) {\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j =i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    swap(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n        }\\n\\n    }"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "princetiwari97940",
                        "content": "can\\'t we just sort using any sorting algo ?"
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "No sorting Algo can do it in one pass."
                    },
                    {
                        "username": "AmSumit02",
                        "content": "I have implemented it using multiset. I am getting the right answer but still, the editor is saying it\\'s wrong.\\n `class Solution {\\npublic:\\n    \\n    vector<int> sortColors(vector<int>& nums) {\\n    \\n        multiset<int> mult(nums.begin(),nums.end());\\n        vector<int> v;\\n        \\n        for(auto x : mult){\\n           v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n\\'\\n"
                    },
                    {
                        "username": "Hiding_as",
                        "content": "Just count the number of 0s 1s and 2s passing once. Rewrite the original array using the count as reference? "
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Since there are only three numbers in an array,  one type of partitions can guarantee this distribution"
                    }
                ]
            },
            {
                "id": 1849471,
                "content": [
                    {
                        "username": "NidhiChaudhary2002",
                        "content": "If anyone wondering about it being a medium level ques .This question aims to make you learn Dutch National Flag Algorithm."
                    },
                    {
                        "username": "BobIAmCalled",
                        "content": "My Python3 code works fine when I run it on my own laptop, but on LeetCode it returns the wrong output. Why is this?\\n\\nCode:\\n\\n    class Solution:\\n        def sortColors(self, nums: List[int]) -> None:\\n            for i in range(len(nums)):\\n                if nums[len(nums) - 1 - i] == 2:\\n                    toAdd = nums.pop(len(nums) - 1 - i)\\n                    nums = nums + [toAdd]\\n            for i in range(len(nums)):\\n                if nums[i] == 0:\\n                    nums = [nums.pop(i)] + nums\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n\\nSpecifically, with the input [2,0,2,1,1,0] it correctly returns [0,0,1,1,2,2] on my laptop, but returns [2,0,1,1,0] on LeetCode.\\n\\nSimilarly, with the input [2,0,1] it correctly returns [0,1,2] on my laptop, but returns [0,1] on LeetCode.\\n"
                    },
                    {
                        "username": "satyam2303",
                        "content": "i only did\\nsort(nums.begin(),nums.end());\\nand it will get accepted"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "but thats not the way,how it should be done"
                    },
                    {
                        "username": "NIRBHAI1729",
                        "content": "we shouldn\\'t use any inbuilt functions "
                    },
                    {
                        "username": "kalebalti",
                        "content": "Isn\\'t it just fancy type of asking \"do any kind of sorting in increasing order\"?"
                    },
                    {
                        "username": "2004divija",
                        "content": " void sortColors(vector<int>& nums) {\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            for(int j =i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    swap(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n            }\\n        }\\n\\n    }"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "princetiwari97940",
                        "content": "can\\'t we just sort using any sorting algo ?"
                    },
                    {
                        "username": "mohdsiddiq74432",
                        "content": "No sorting Algo can do it in one pass."
                    },
                    {
                        "username": "AmSumit02",
                        "content": "I have implemented it using multiset. I am getting the right answer but still, the editor is saying it\\'s wrong.\\n `class Solution {\\npublic:\\n    \\n    vector<int> sortColors(vector<int>& nums) {\\n    \\n        multiset<int> mult(nums.begin(),nums.end());\\n        vector<int> v;\\n        \\n        for(auto x : mult){\\n           v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n\\'\\n"
                    },
                    {
                        "username": "Hiding_as",
                        "content": "Just count the number of 0s 1s and 2s passing once. Rewrite the original array using the count as reference? "
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Since there are only three numbers in an array,  one type of partitions can guarantee this distribution"
                    }
                ]
            },
            {
                "id": 1847038,
                "content": [
                    {
                        "username": "JainSarthak19",
                        "content": "im not able to use frequency method can anyone help me out here.!!"
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Dijkstra three way partition can help to solve in O(n)"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  `   ArrayList<Integer> list= new ArrayList<>();\\n\\n        int fir=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(fir==nums[i]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==2){\\n                list.add(nums[i]);\\n            }\\n        }\\n        System.out.println(list);`\\n\\ncan anyone tell me what is wrong with this solution ,because when i am running it in the intellij it is showing the correct output but here in leet code it is showing wrong output"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "This is the kind of problem you should have solved before going for an interview. Btw it\\'s a really bad interview problem imho."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Why? There are much more complex problems available than this one"
                    },
                    {
                        "username": "Rajmehra09887766",
                        "content": " `your inline code...your inline code...\\n\\n`class Solution {\\n    public void sortColors(int[] nums) {\\n        for(int i=0; i<nums.length;i++){\\n         int j=i-1;\\n         while(j>=0){\\n            if(nums[i]<nums[j]){\\n                int c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            i=j;\\n            \\n            }\\n            \\n            j--;\\n             }\\n        }\\n\\n        \\n    }\\n}\\n\\n\\n\\neasy soln for short an array;"
                    },
                    {
                        "username": "mohitgarg85",
                        "content": "optimal solution of this question will be done by dutch flag algorithm.\\nI am attaching the link of that algorithm within this post.\\n\\nhttps://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/\\nhttps://www.youtube.com/watch?v=oaVa-9wmpns"
                    },
                    {
                        "username": "Ryuk00",
                        "content": "I don\\'t know why this is not working Can Anyone help me by reviewing my solution (in cpp)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n    int l=0,m=0,h=nums.size()-1;\\n    while(m<=h){\\n        if(nums[m]==0)swap(nums[m++],nums[l++]);\\n        if(nums[m]==2)swap(nums[m],nums[h--]);\\n        if(nums[m]==1)m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "using three pointet technique"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": " 100 % beat time\\n\\n\\n\\nclass Solution {\\npublic:\\n      void sortColors(vector<int>&arr)\\n    {\\n    int n= arr.size();\\n\\n    int curr = 0;\\n    int left  =0;\\n    int right = n-1;\\n\\n    while(curr <=right){\\n\\n        if(arr[curr] ==0){\\n            swap(arr[curr],arr[left]);\\n            curr++;\\n            left++;\\n        }else if(arr[curr] ==2){\\n            swap(arr[curr],arr[right]);\\n            right--;\\n        }\\n        else{\\n            curr++;\\n        }\\n    }\\n\\n}   \\n\\n\\n};"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "million dollar code : )\\n sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "ac2147020",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)a++;\\n          if(nums[i]==1)b++;\\n           if(nums[i]==2)c++;\\n        }\\n       \\n        for(int i=0;i<a;i++)\\n        {\\n            nums[i]=0;\\n            \\n\\n        }\\n      \\n         for(int i=0;i<b;i++)\\n        {\\n            nums[i+a]=1;\\n\\n        }\\n for(int i=0;i<c;i++)\\n        {\\n            nums[i+b+a]=2;\\n\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1845968,
                "content": [
                    {
                        "username": "JainSarthak19",
                        "content": "im not able to use frequency method can anyone help me out here.!!"
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Dijkstra three way partition can help to solve in O(n)"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  `   ArrayList<Integer> list= new ArrayList<>();\\n\\n        int fir=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(fir==nums[i]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==2){\\n                list.add(nums[i]);\\n            }\\n        }\\n        System.out.println(list);`\\n\\ncan anyone tell me what is wrong with this solution ,because when i am running it in the intellij it is showing the correct output but here in leet code it is showing wrong output"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "This is the kind of problem you should have solved before going for an interview. Btw it\\'s a really bad interview problem imho."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Why? There are much more complex problems available than this one"
                    },
                    {
                        "username": "Rajmehra09887766",
                        "content": " `your inline code...your inline code...\\n\\n`class Solution {\\n    public void sortColors(int[] nums) {\\n        for(int i=0; i<nums.length;i++){\\n         int j=i-1;\\n         while(j>=0){\\n            if(nums[i]<nums[j]){\\n                int c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            i=j;\\n            \\n            }\\n            \\n            j--;\\n             }\\n        }\\n\\n        \\n    }\\n}\\n\\n\\n\\neasy soln for short an array;"
                    },
                    {
                        "username": "mohitgarg85",
                        "content": "optimal solution of this question will be done by dutch flag algorithm.\\nI am attaching the link of that algorithm within this post.\\n\\nhttps://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/\\nhttps://www.youtube.com/watch?v=oaVa-9wmpns"
                    },
                    {
                        "username": "Ryuk00",
                        "content": "I don\\'t know why this is not working Can Anyone help me by reviewing my solution (in cpp)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n    int l=0,m=0,h=nums.size()-1;\\n    while(m<=h){\\n        if(nums[m]==0)swap(nums[m++],nums[l++]);\\n        if(nums[m]==2)swap(nums[m],nums[h--]);\\n        if(nums[m]==1)m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "using three pointet technique"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": " 100 % beat time\\n\\n\\n\\nclass Solution {\\npublic:\\n      void sortColors(vector<int>&arr)\\n    {\\n    int n= arr.size();\\n\\n    int curr = 0;\\n    int left  =0;\\n    int right = n-1;\\n\\n    while(curr <=right){\\n\\n        if(arr[curr] ==0){\\n            swap(arr[curr],arr[left]);\\n            curr++;\\n            left++;\\n        }else if(arr[curr] ==2){\\n            swap(arr[curr],arr[right]);\\n            right--;\\n        }\\n        else{\\n            curr++;\\n        }\\n    }\\n\\n}   \\n\\n\\n};"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "million dollar code : )\\n sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "ac2147020",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)a++;\\n          if(nums[i]==1)b++;\\n           if(nums[i]==2)c++;\\n        }\\n       \\n        for(int i=0;i<a;i++)\\n        {\\n            nums[i]=0;\\n            \\n\\n        }\\n      \\n         for(int i=0;i<b;i++)\\n        {\\n            nums[i+a]=1;\\n\\n        }\\n for(int i=0;i<c;i++)\\n        {\\n            nums[i+b+a]=2;\\n\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1814236,
                "content": [
                    {
                        "username": "JainSarthak19",
                        "content": "im not able to use frequency method can anyone help me out here.!!"
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Dijkstra three way partition can help to solve in O(n)"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  `   ArrayList<Integer> list= new ArrayList<>();\\n\\n        int fir=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(fir==nums[i]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==2){\\n                list.add(nums[i]);\\n            }\\n        }\\n        System.out.println(list);`\\n\\ncan anyone tell me what is wrong with this solution ,because when i am running it in the intellij it is showing the correct output but here in leet code it is showing wrong output"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "This is the kind of problem you should have solved before going for an interview. Btw it\\'s a really bad interview problem imho."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Why? There are much more complex problems available than this one"
                    },
                    {
                        "username": "Rajmehra09887766",
                        "content": " `your inline code...your inline code...\\n\\n`class Solution {\\n    public void sortColors(int[] nums) {\\n        for(int i=0; i<nums.length;i++){\\n         int j=i-1;\\n         while(j>=0){\\n            if(nums[i]<nums[j]){\\n                int c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            i=j;\\n            \\n            }\\n            \\n            j--;\\n             }\\n        }\\n\\n        \\n    }\\n}\\n\\n\\n\\neasy soln for short an array;"
                    },
                    {
                        "username": "mohitgarg85",
                        "content": "optimal solution of this question will be done by dutch flag algorithm.\\nI am attaching the link of that algorithm within this post.\\n\\nhttps://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/\\nhttps://www.youtube.com/watch?v=oaVa-9wmpns"
                    },
                    {
                        "username": "Ryuk00",
                        "content": "I don\\'t know why this is not working Can Anyone help me by reviewing my solution (in cpp)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n    int l=0,m=0,h=nums.size()-1;\\n    while(m<=h){\\n        if(nums[m]==0)swap(nums[m++],nums[l++]);\\n        if(nums[m]==2)swap(nums[m],nums[h--]);\\n        if(nums[m]==1)m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "using three pointet technique"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": " 100 % beat time\\n\\n\\n\\nclass Solution {\\npublic:\\n      void sortColors(vector<int>&arr)\\n    {\\n    int n= arr.size();\\n\\n    int curr = 0;\\n    int left  =0;\\n    int right = n-1;\\n\\n    while(curr <=right){\\n\\n        if(arr[curr] ==0){\\n            swap(arr[curr],arr[left]);\\n            curr++;\\n            left++;\\n        }else if(arr[curr] ==2){\\n            swap(arr[curr],arr[right]);\\n            right--;\\n        }\\n        else{\\n            curr++;\\n        }\\n    }\\n\\n}   \\n\\n\\n};"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "million dollar code : )\\n sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "ac2147020",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)a++;\\n          if(nums[i]==1)b++;\\n           if(nums[i]==2)c++;\\n        }\\n       \\n        for(int i=0;i<a;i++)\\n        {\\n            nums[i]=0;\\n            \\n\\n        }\\n      \\n         for(int i=0;i<b;i++)\\n        {\\n            nums[i+a]=1;\\n\\n        }\\n for(int i=0;i<c;i++)\\n        {\\n            nums[i+b+a]=2;\\n\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809906,
                "content": [
                    {
                        "username": "JainSarthak19",
                        "content": "im not able to use frequency method can anyone help me out here.!!"
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Dijkstra three way partition can help to solve in O(n)"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  `   ArrayList<Integer> list= new ArrayList<>();\\n\\n        int fir=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(fir==nums[i]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==2){\\n                list.add(nums[i]);\\n            }\\n        }\\n        System.out.println(list);`\\n\\ncan anyone tell me what is wrong with this solution ,because when i am running it in the intellij it is showing the correct output but here in leet code it is showing wrong output"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "This is the kind of problem you should have solved before going for an interview. Btw it\\'s a really bad interview problem imho."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Why? There are much more complex problems available than this one"
                    },
                    {
                        "username": "Rajmehra09887766",
                        "content": " `your inline code...your inline code...\\n\\n`class Solution {\\n    public void sortColors(int[] nums) {\\n        for(int i=0; i<nums.length;i++){\\n         int j=i-1;\\n         while(j>=0){\\n            if(nums[i]<nums[j]){\\n                int c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            i=j;\\n            \\n            }\\n            \\n            j--;\\n             }\\n        }\\n\\n        \\n    }\\n}\\n\\n\\n\\neasy soln for short an array;"
                    },
                    {
                        "username": "mohitgarg85",
                        "content": "optimal solution of this question will be done by dutch flag algorithm.\\nI am attaching the link of that algorithm within this post.\\n\\nhttps://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/\\nhttps://www.youtube.com/watch?v=oaVa-9wmpns"
                    },
                    {
                        "username": "Ryuk00",
                        "content": "I don\\'t know why this is not working Can Anyone help me by reviewing my solution (in cpp)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n    int l=0,m=0,h=nums.size()-1;\\n    while(m<=h){\\n        if(nums[m]==0)swap(nums[m++],nums[l++]);\\n        if(nums[m]==2)swap(nums[m],nums[h--]);\\n        if(nums[m]==1)m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "using three pointet technique"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": " 100 % beat time\\n\\n\\n\\nclass Solution {\\npublic:\\n      void sortColors(vector<int>&arr)\\n    {\\n    int n= arr.size();\\n\\n    int curr = 0;\\n    int left  =0;\\n    int right = n-1;\\n\\n    while(curr <=right){\\n\\n        if(arr[curr] ==0){\\n            swap(arr[curr],arr[left]);\\n            curr++;\\n            left++;\\n        }else if(arr[curr] ==2){\\n            swap(arr[curr],arr[right]);\\n            right--;\\n        }\\n        else{\\n            curr++;\\n        }\\n    }\\n\\n}   \\n\\n\\n};"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "million dollar code : )\\n sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "ac2147020",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)a++;\\n          if(nums[i]==1)b++;\\n           if(nums[i]==2)c++;\\n        }\\n       \\n        for(int i=0;i<a;i++)\\n        {\\n            nums[i]=0;\\n            \\n\\n        }\\n      \\n         for(int i=0;i<b;i++)\\n        {\\n            nums[i+a]=1;\\n\\n        }\\n for(int i=0;i<c;i++)\\n        {\\n            nums[i+b+a]=2;\\n\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1808524,
                "content": [
                    {
                        "username": "JainSarthak19",
                        "content": "im not able to use frequency method can anyone help me out here.!!"
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Dijkstra three way partition can help to solve in O(n)"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  `   ArrayList<Integer> list= new ArrayList<>();\\n\\n        int fir=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(fir==nums[i]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==2){\\n                list.add(nums[i]);\\n            }\\n        }\\n        System.out.println(list);`\\n\\ncan anyone tell me what is wrong with this solution ,because when i am running it in the intellij it is showing the correct output but here in leet code it is showing wrong output"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "This is the kind of problem you should have solved before going for an interview. Btw it\\'s a really bad interview problem imho."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Why? There are much more complex problems available than this one"
                    },
                    {
                        "username": "Rajmehra09887766",
                        "content": " `your inline code...your inline code...\\n\\n`class Solution {\\n    public void sortColors(int[] nums) {\\n        for(int i=0; i<nums.length;i++){\\n         int j=i-1;\\n         while(j>=0){\\n            if(nums[i]<nums[j]){\\n                int c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            i=j;\\n            \\n            }\\n            \\n            j--;\\n             }\\n        }\\n\\n        \\n    }\\n}\\n\\n\\n\\neasy soln for short an array;"
                    },
                    {
                        "username": "mohitgarg85",
                        "content": "optimal solution of this question will be done by dutch flag algorithm.\\nI am attaching the link of that algorithm within this post.\\n\\nhttps://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/\\nhttps://www.youtube.com/watch?v=oaVa-9wmpns"
                    },
                    {
                        "username": "Ryuk00",
                        "content": "I don\\'t know why this is not working Can Anyone help me by reviewing my solution (in cpp)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n    int l=0,m=0,h=nums.size()-1;\\n    while(m<=h){\\n        if(nums[m]==0)swap(nums[m++],nums[l++]);\\n        if(nums[m]==2)swap(nums[m],nums[h--]);\\n        if(nums[m]==1)m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "using three pointet technique"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": " 100 % beat time\\n\\n\\n\\nclass Solution {\\npublic:\\n      void sortColors(vector<int>&arr)\\n    {\\n    int n= arr.size();\\n\\n    int curr = 0;\\n    int left  =0;\\n    int right = n-1;\\n\\n    while(curr <=right){\\n\\n        if(arr[curr] ==0){\\n            swap(arr[curr],arr[left]);\\n            curr++;\\n            left++;\\n        }else if(arr[curr] ==2){\\n            swap(arr[curr],arr[right]);\\n            right--;\\n        }\\n        else{\\n            curr++;\\n        }\\n    }\\n\\n}   \\n\\n\\n};"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "million dollar code : )\\n sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "ac2147020",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)a++;\\n          if(nums[i]==1)b++;\\n           if(nums[i]==2)c++;\\n        }\\n       \\n        for(int i=0;i<a;i++)\\n        {\\n            nums[i]=0;\\n            \\n\\n        }\\n      \\n         for(int i=0;i<b;i++)\\n        {\\n            nums[i+a]=1;\\n\\n        }\\n for(int i=0;i<c;i++)\\n        {\\n            nums[i+b+a]=2;\\n\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1804334,
                "content": [
                    {
                        "username": "JainSarthak19",
                        "content": "im not able to use frequency method can anyone help me out here.!!"
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Dijkstra three way partition can help to solve in O(n)"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  `   ArrayList<Integer> list= new ArrayList<>();\\n\\n        int fir=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(fir==nums[i]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==2){\\n                list.add(nums[i]);\\n            }\\n        }\\n        System.out.println(list);`\\n\\ncan anyone tell me what is wrong with this solution ,because when i am running it in the intellij it is showing the correct output but here in leet code it is showing wrong output"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "This is the kind of problem you should have solved before going for an interview. Btw it\\'s a really bad interview problem imho."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Why? There are much more complex problems available than this one"
                    },
                    {
                        "username": "Rajmehra09887766",
                        "content": " `your inline code...your inline code...\\n\\n`class Solution {\\n    public void sortColors(int[] nums) {\\n        for(int i=0; i<nums.length;i++){\\n         int j=i-1;\\n         while(j>=0){\\n            if(nums[i]<nums[j]){\\n                int c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            i=j;\\n            \\n            }\\n            \\n            j--;\\n             }\\n        }\\n\\n        \\n    }\\n}\\n\\n\\n\\neasy soln for short an array;"
                    },
                    {
                        "username": "mohitgarg85",
                        "content": "optimal solution of this question will be done by dutch flag algorithm.\\nI am attaching the link of that algorithm within this post.\\n\\nhttps://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/\\nhttps://www.youtube.com/watch?v=oaVa-9wmpns"
                    },
                    {
                        "username": "Ryuk00",
                        "content": "I don\\'t know why this is not working Can Anyone help me by reviewing my solution (in cpp)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n    int l=0,m=0,h=nums.size()-1;\\n    while(m<=h){\\n        if(nums[m]==0)swap(nums[m++],nums[l++]);\\n        if(nums[m]==2)swap(nums[m],nums[h--]);\\n        if(nums[m]==1)m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "using three pointet technique"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": " 100 % beat time\\n\\n\\n\\nclass Solution {\\npublic:\\n      void sortColors(vector<int>&arr)\\n    {\\n    int n= arr.size();\\n\\n    int curr = 0;\\n    int left  =0;\\n    int right = n-1;\\n\\n    while(curr <=right){\\n\\n        if(arr[curr] ==0){\\n            swap(arr[curr],arr[left]);\\n            curr++;\\n            left++;\\n        }else if(arr[curr] ==2){\\n            swap(arr[curr],arr[right]);\\n            right--;\\n        }\\n        else{\\n            curr++;\\n        }\\n    }\\n\\n}   \\n\\n\\n};"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "million dollar code : )\\n sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "ac2147020",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)a++;\\n          if(nums[i]==1)b++;\\n           if(nums[i]==2)c++;\\n        }\\n       \\n        for(int i=0;i<a;i++)\\n        {\\n            nums[i]=0;\\n            \\n\\n        }\\n      \\n         for(int i=0;i<b;i++)\\n        {\\n            nums[i+a]=1;\\n\\n        }\\n for(int i=0;i<c;i++)\\n        {\\n            nums[i+b+a]=2;\\n\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1794072,
                "content": [
                    {
                        "username": "JainSarthak19",
                        "content": "im not able to use frequency method can anyone help me out here.!!"
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Dijkstra three way partition can help to solve in O(n)"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  `   ArrayList<Integer> list= new ArrayList<>();\\n\\n        int fir=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(fir==nums[i]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==2){\\n                list.add(nums[i]);\\n            }\\n        }\\n        System.out.println(list);`\\n\\ncan anyone tell me what is wrong with this solution ,because when i am running it in the intellij it is showing the correct output but here in leet code it is showing wrong output"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "This is the kind of problem you should have solved before going for an interview. Btw it\\'s a really bad interview problem imho."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Why? There are much more complex problems available than this one"
                    },
                    {
                        "username": "Rajmehra09887766",
                        "content": " `your inline code...your inline code...\\n\\n`class Solution {\\n    public void sortColors(int[] nums) {\\n        for(int i=0; i<nums.length;i++){\\n         int j=i-1;\\n         while(j>=0){\\n            if(nums[i]<nums[j]){\\n                int c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            i=j;\\n            \\n            }\\n            \\n            j--;\\n             }\\n        }\\n\\n        \\n    }\\n}\\n\\n\\n\\neasy soln for short an array;"
                    },
                    {
                        "username": "mohitgarg85",
                        "content": "optimal solution of this question will be done by dutch flag algorithm.\\nI am attaching the link of that algorithm within this post.\\n\\nhttps://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/\\nhttps://www.youtube.com/watch?v=oaVa-9wmpns"
                    },
                    {
                        "username": "Ryuk00",
                        "content": "I don\\'t know why this is not working Can Anyone help me by reviewing my solution (in cpp)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n    int l=0,m=0,h=nums.size()-1;\\n    while(m<=h){\\n        if(nums[m]==0)swap(nums[m++],nums[l++]);\\n        if(nums[m]==2)swap(nums[m],nums[h--]);\\n        if(nums[m]==1)m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "using three pointet technique"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": " 100 % beat time\\n\\n\\n\\nclass Solution {\\npublic:\\n      void sortColors(vector<int>&arr)\\n    {\\n    int n= arr.size();\\n\\n    int curr = 0;\\n    int left  =0;\\n    int right = n-1;\\n\\n    while(curr <=right){\\n\\n        if(arr[curr] ==0){\\n            swap(arr[curr],arr[left]);\\n            curr++;\\n            left++;\\n        }else if(arr[curr] ==2){\\n            swap(arr[curr],arr[right]);\\n            right--;\\n        }\\n        else{\\n            curr++;\\n        }\\n    }\\n\\n}   \\n\\n\\n};"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "million dollar code : )\\n sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "ac2147020",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)a++;\\n          if(nums[i]==1)b++;\\n           if(nums[i]==2)c++;\\n        }\\n       \\n        for(int i=0;i<a;i++)\\n        {\\n            nums[i]=0;\\n            \\n\\n        }\\n      \\n         for(int i=0;i<b;i++)\\n        {\\n            nums[i+a]=1;\\n\\n        }\\n for(int i=0;i<c;i++)\\n        {\\n            nums[i+b+a]=2;\\n\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1794071,
                "content": [
                    {
                        "username": "JainSarthak19",
                        "content": "im not able to use frequency method can anyone help me out here.!!"
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Dijkstra three way partition can help to solve in O(n)"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  `   ArrayList<Integer> list= new ArrayList<>();\\n\\n        int fir=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(fir==nums[i]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==2){\\n                list.add(nums[i]);\\n            }\\n        }\\n        System.out.println(list);`\\n\\ncan anyone tell me what is wrong with this solution ,because when i am running it in the intellij it is showing the correct output but here in leet code it is showing wrong output"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "This is the kind of problem you should have solved before going for an interview. Btw it\\'s a really bad interview problem imho."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Why? There are much more complex problems available than this one"
                    },
                    {
                        "username": "Rajmehra09887766",
                        "content": " `your inline code...your inline code...\\n\\n`class Solution {\\n    public void sortColors(int[] nums) {\\n        for(int i=0; i<nums.length;i++){\\n         int j=i-1;\\n         while(j>=0){\\n            if(nums[i]<nums[j]){\\n                int c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            i=j;\\n            \\n            }\\n            \\n            j--;\\n             }\\n        }\\n\\n        \\n    }\\n}\\n\\n\\n\\neasy soln for short an array;"
                    },
                    {
                        "username": "mohitgarg85",
                        "content": "optimal solution of this question will be done by dutch flag algorithm.\\nI am attaching the link of that algorithm within this post.\\n\\nhttps://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/\\nhttps://www.youtube.com/watch?v=oaVa-9wmpns"
                    },
                    {
                        "username": "Ryuk00",
                        "content": "I don\\'t know why this is not working Can Anyone help me by reviewing my solution (in cpp)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n    int l=0,m=0,h=nums.size()-1;\\n    while(m<=h){\\n        if(nums[m]==0)swap(nums[m++],nums[l++]);\\n        if(nums[m]==2)swap(nums[m],nums[h--]);\\n        if(nums[m]==1)m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "using three pointet technique"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": " 100 % beat time\\n\\n\\n\\nclass Solution {\\npublic:\\n      void sortColors(vector<int>&arr)\\n    {\\n    int n= arr.size();\\n\\n    int curr = 0;\\n    int left  =0;\\n    int right = n-1;\\n\\n    while(curr <=right){\\n\\n        if(arr[curr] ==0){\\n            swap(arr[curr],arr[left]);\\n            curr++;\\n            left++;\\n        }else if(arr[curr] ==2){\\n            swap(arr[curr],arr[right]);\\n            right--;\\n        }\\n        else{\\n            curr++;\\n        }\\n    }\\n\\n}   \\n\\n\\n};"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "million dollar code : )\\n sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "ac2147020",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)a++;\\n          if(nums[i]==1)b++;\\n           if(nums[i]==2)c++;\\n        }\\n       \\n        for(int i=0;i<a;i++)\\n        {\\n            nums[i]=0;\\n            \\n\\n        }\\n      \\n         for(int i=0;i<b;i++)\\n        {\\n            nums[i+a]=1;\\n\\n        }\\n for(int i=0;i<c;i++)\\n        {\\n            nums[i+b+a]=2;\\n\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1781001,
                "content": [
                    {
                        "username": "JainSarthak19",
                        "content": "im not able to use frequency method can anyone help me out here.!!"
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Dijkstra three way partition can help to solve in O(n)"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  `   ArrayList<Integer> list= new ArrayList<>();\\n\\n        int fir=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(fir==nums[i]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==2){\\n                list.add(nums[i]);\\n            }\\n        }\\n        System.out.println(list);`\\n\\ncan anyone tell me what is wrong with this solution ,because when i am running it in the intellij it is showing the correct output but here in leet code it is showing wrong output"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "This is the kind of problem you should have solved before going for an interview. Btw it\\'s a really bad interview problem imho."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Why? There are much more complex problems available than this one"
                    },
                    {
                        "username": "Rajmehra09887766",
                        "content": " `your inline code...your inline code...\\n\\n`class Solution {\\n    public void sortColors(int[] nums) {\\n        for(int i=0; i<nums.length;i++){\\n         int j=i-1;\\n         while(j>=0){\\n            if(nums[i]<nums[j]){\\n                int c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            i=j;\\n            \\n            }\\n            \\n            j--;\\n             }\\n        }\\n\\n        \\n    }\\n}\\n\\n\\n\\neasy soln for short an array;"
                    },
                    {
                        "username": "mohitgarg85",
                        "content": "optimal solution of this question will be done by dutch flag algorithm.\\nI am attaching the link of that algorithm within this post.\\n\\nhttps://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/\\nhttps://www.youtube.com/watch?v=oaVa-9wmpns"
                    },
                    {
                        "username": "Ryuk00",
                        "content": "I don\\'t know why this is not working Can Anyone help me by reviewing my solution (in cpp)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n    int l=0,m=0,h=nums.size()-1;\\n    while(m<=h){\\n        if(nums[m]==0)swap(nums[m++],nums[l++]);\\n        if(nums[m]==2)swap(nums[m],nums[h--]);\\n        if(nums[m]==1)m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "using three pointet technique"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": " 100 % beat time\\n\\n\\n\\nclass Solution {\\npublic:\\n      void sortColors(vector<int>&arr)\\n    {\\n    int n= arr.size();\\n\\n    int curr = 0;\\n    int left  =0;\\n    int right = n-1;\\n\\n    while(curr <=right){\\n\\n        if(arr[curr] ==0){\\n            swap(arr[curr],arr[left]);\\n            curr++;\\n            left++;\\n        }else if(arr[curr] ==2){\\n            swap(arr[curr],arr[right]);\\n            right--;\\n        }\\n        else{\\n            curr++;\\n        }\\n    }\\n\\n}   \\n\\n\\n};"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "million dollar code : )\\n sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "ac2147020",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)a++;\\n          if(nums[i]==1)b++;\\n           if(nums[i]==2)c++;\\n        }\\n       \\n        for(int i=0;i<a;i++)\\n        {\\n            nums[i]=0;\\n            \\n\\n        }\\n      \\n         for(int i=0;i<b;i++)\\n        {\\n            nums[i+a]=1;\\n\\n        }\\n for(int i=0;i<c;i++)\\n        {\\n            nums[i+b+a]=2;\\n\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1760155,
                "content": [
                    {
                        "username": "JainSarthak19",
                        "content": "im not able to use frequency method can anyone help me out here.!!"
                    },
                    {
                        "username": "nurbolnygmanov",
                        "content": "Dijkstra three way partition can help to solve in O(n)"
                    },
                    {
                        "username": "RECRUITER_1-",
                        "content": "  `   ArrayList<Integer> list= new ArrayList<>();\\n\\n        int fir=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(fir==nums[i]){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                list.add(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==2){\\n                list.add(nums[i]);\\n            }\\n        }\\n        System.out.println(list);`\\n\\ncan anyone tell me what is wrong with this solution ,because when i am running it in the intellij it is showing the correct output but here in leet code it is showing wrong output"
                    },
                    {
                        "username": "hkumar0132",
                        "content": "This is the kind of problem you should have solved before going for an interview. Btw it\\'s a really bad interview problem imho."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Why? There are much more complex problems available than this one"
                    },
                    {
                        "username": "Rajmehra09887766",
                        "content": " `your inline code...your inline code...\\n\\n`class Solution {\\n    public void sortColors(int[] nums) {\\n        for(int i=0; i<nums.length;i++){\\n         int j=i-1;\\n         while(j>=0){\\n            if(nums[i]<nums[j]){\\n                int c=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=c;\\n            i=j;\\n            \\n            }\\n            \\n            j--;\\n             }\\n        }\\n\\n        \\n    }\\n}\\n\\n\\n\\neasy soln for short an array;"
                    },
                    {
                        "username": "mohitgarg85",
                        "content": "optimal solution of this question will be done by dutch flag algorithm.\\nI am attaching the link of that algorithm within this post.\\n\\nhttps://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/\\nhttps://www.youtube.com/watch?v=oaVa-9wmpns"
                    },
                    {
                        "username": "Ryuk00",
                        "content": "I don\\'t know why this is not working Can Anyone help me by reviewing my solution (in cpp)\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n    int l=0,m=0,h=nums.size()-1;\\n    while(m<=h){\\n        if(nums[m]==0)swap(nums[m++],nums[l++]);\\n        if(nums[m]==2)swap(nums[m],nums[h--]);\\n        if(nums[m]==1)m++;\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "using three pointet technique"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": " 100 % beat time\\n\\n\\n\\nclass Solution {\\npublic:\\n      void sortColors(vector<int>&arr)\\n    {\\n    int n= arr.size();\\n\\n    int curr = 0;\\n    int left  =0;\\n    int right = n-1;\\n\\n    while(curr <=right){\\n\\n        if(arr[curr] ==0){\\n            swap(arr[curr],arr[left]);\\n            curr++;\\n            left++;\\n        }else if(arr[curr] ==2){\\n            swap(arr[curr],arr[right]);\\n            right--;\\n        }\\n        else{\\n            curr++;\\n        }\\n    }\\n\\n}   \\n\\n\\n};"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "million dollar code : )\\n sort(nums.begin(),nums.end());"
                    },
                    {
                        "username": "ac2147020",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)a++;\\n          if(nums[i]==1)b++;\\n           if(nums[i]==2)c++;\\n        }\\n       \\n        for(int i=0;i<a;i++)\\n        {\\n            nums[i]=0;\\n            \\n\\n        }\\n      \\n         for(int i=0;i<b;i++)\\n        {\\n            nums[i+a]=1;\\n\\n        }\\n for(int i=0;i<c;i++)\\n        {\\n            nums[i+b+a]=2;\\n\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1757903,
                "content": [
                    {
                        "username": "shivangisinghhappy",
                        "content": "I am very confused with this problem, this is the code which is passing nearly half the test cases.\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        int left = 0;\\n        int right = nums.size()-1;\\n\\n        for (int k=0; k<nums.size(); k++) {\\n\\n            if (right<k) break;\\n\\n            if (nums[left] > nums[right]) {\\n                swap(nums[left], nums[right]);\\n            }\\n\\n            if (k>left && nums[k] < nums[left]) {\\n                swap(nums[k], nums[left]);\\n            }\\n\\n            if (k<left && nums[k] > nums[left]) {\\n                swap(nums[left], nums[k]);\\n            }\\n\\n            if (nums[k] > nums[right]) {\\n                swap(nums[k], nums[right]);\\n            }\\n\\n            if (nums[left] == 0) left++;\\n            if (nums[right] == 2) right--;\\n\\n        }\\n    }\\n};`\\nIf anyone can help how can I improve this code to submit other test cases."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "use bucket sort\\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "question based on quick sort -> partition function \\nsimply simple approch with one extra pointer fixed at end  "
                    },
                    {
                        "username": "tapegun",
                        "content": "I\\'m such a beta I used an ORDERED hashmap lol"
                    },
                    {
                        "username": "ACoder07",
                        "content": "Doing question using simple stack method is a correct approach?"
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "count 0\\'s , 1\\'s , and 2\\'s in array \\nand iterate through array again and chand the index values from start to the count of the respective numbers.\\n"
                    },
                    {
                        "username": "kamdarveer",
                        "content": "Brute force approach with time complexity as O(n)\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n    vector<int> ans;\\n    int n= (int)nums.size();\\n        \\n        int red=0;\\n        int white=0;\\n        int blue=0;\\n\\n        //Counting the number of colors!\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            red++;\\n\\n            else if(nums[i]==1)\\n            white++;\\n\\n            else\\n            blue++;\\n        }\\n\\n        for(int i=0; i<red;i++)\\n        {\\n            nums[i]=0;\\n        }\\n\\n        for(int i=red; i<red+white ; i++)\\n        {\\n            nums[i]=1;\\n        }\\n        \\n        for(int i=red+white; i<n;i++)\\n        {\\n            nums[i]=2;\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "beats 100%  C++"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n     int p1 = 0;\\n     int p2 = 0;\\n\\n     for(int i=0; i<nums.size(); i++)\\n     {\\n         if(nums[i]==0)\\n         {\\n             nums[i] = 2;\\n             nums[p2++] = 1;\\n             nums[p1++] = 0;\\n         }\\n         else if(nums[i]==1)\\n         {\\n                nums[i] = 2;\\n                nums[p2++] =1; \\n         }\\n     }\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754129,
                "content": [
                    {
                        "username": "shivangisinghhappy",
                        "content": "I am very confused with this problem, this is the code which is passing nearly half the test cases.\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        int left = 0;\\n        int right = nums.size()-1;\\n\\n        for (int k=0; k<nums.size(); k++) {\\n\\n            if (right<k) break;\\n\\n            if (nums[left] > nums[right]) {\\n                swap(nums[left], nums[right]);\\n            }\\n\\n            if (k>left && nums[k] < nums[left]) {\\n                swap(nums[k], nums[left]);\\n            }\\n\\n            if (k<left && nums[k] > nums[left]) {\\n                swap(nums[left], nums[k]);\\n            }\\n\\n            if (nums[k] > nums[right]) {\\n                swap(nums[k], nums[right]);\\n            }\\n\\n            if (nums[left] == 0) left++;\\n            if (nums[right] == 2) right--;\\n\\n        }\\n    }\\n};`\\nIf anyone can help how can I improve this code to submit other test cases."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "use bucket sort\\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "question based on quick sort -> partition function \\nsimply simple approch with one extra pointer fixed at end  "
                    },
                    {
                        "username": "tapegun",
                        "content": "I\\'m such a beta I used an ORDERED hashmap lol"
                    },
                    {
                        "username": "ACoder07",
                        "content": "Doing question using simple stack method is a correct approach?"
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "count 0\\'s , 1\\'s , and 2\\'s in array \\nand iterate through array again and chand the index values from start to the count of the respective numbers.\\n"
                    },
                    {
                        "username": "kamdarveer",
                        "content": "Brute force approach with time complexity as O(n)\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n    vector<int> ans;\\n    int n= (int)nums.size();\\n        \\n        int red=0;\\n        int white=0;\\n        int blue=0;\\n\\n        //Counting the number of colors!\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            red++;\\n\\n            else if(nums[i]==1)\\n            white++;\\n\\n            else\\n            blue++;\\n        }\\n\\n        for(int i=0; i<red;i++)\\n        {\\n            nums[i]=0;\\n        }\\n\\n        for(int i=red; i<red+white ; i++)\\n        {\\n            nums[i]=1;\\n        }\\n        \\n        for(int i=red+white; i<n;i++)\\n        {\\n            nums[i]=2;\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "beats 100%  C++"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n     int p1 = 0;\\n     int p2 = 0;\\n\\n     for(int i=0; i<nums.size(); i++)\\n     {\\n         if(nums[i]==0)\\n         {\\n             nums[i] = 2;\\n             nums[p2++] = 1;\\n             nums[p1++] = 0;\\n         }\\n         else if(nums[i]==1)\\n         {\\n                nums[i] = 2;\\n                nums[p2++] =1; \\n         }\\n     }\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1751601,
                "content": [
                    {
                        "username": "shivangisinghhappy",
                        "content": "I am very confused with this problem, this is the code which is passing nearly half the test cases.\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        int left = 0;\\n        int right = nums.size()-1;\\n\\n        for (int k=0; k<nums.size(); k++) {\\n\\n            if (right<k) break;\\n\\n            if (nums[left] > nums[right]) {\\n                swap(nums[left], nums[right]);\\n            }\\n\\n            if (k>left && nums[k] < nums[left]) {\\n                swap(nums[k], nums[left]);\\n            }\\n\\n            if (k<left && nums[k] > nums[left]) {\\n                swap(nums[left], nums[k]);\\n            }\\n\\n            if (nums[k] > nums[right]) {\\n                swap(nums[k], nums[right]);\\n            }\\n\\n            if (nums[left] == 0) left++;\\n            if (nums[right] == 2) right--;\\n\\n        }\\n    }\\n};`\\nIf anyone can help how can I improve this code to submit other test cases."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "use bucket sort\\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "question based on quick sort -> partition function \\nsimply simple approch with one extra pointer fixed at end  "
                    },
                    {
                        "username": "tapegun",
                        "content": "I\\'m such a beta I used an ORDERED hashmap lol"
                    },
                    {
                        "username": "ACoder07",
                        "content": "Doing question using simple stack method is a correct approach?"
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "count 0\\'s , 1\\'s , and 2\\'s in array \\nand iterate through array again and chand the index values from start to the count of the respective numbers.\\n"
                    },
                    {
                        "username": "kamdarveer",
                        "content": "Brute force approach with time complexity as O(n)\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n    vector<int> ans;\\n    int n= (int)nums.size();\\n        \\n        int red=0;\\n        int white=0;\\n        int blue=0;\\n\\n        //Counting the number of colors!\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            red++;\\n\\n            else if(nums[i]==1)\\n            white++;\\n\\n            else\\n            blue++;\\n        }\\n\\n        for(int i=0; i<red;i++)\\n        {\\n            nums[i]=0;\\n        }\\n\\n        for(int i=red; i<red+white ; i++)\\n        {\\n            nums[i]=1;\\n        }\\n        \\n        for(int i=red+white; i<n;i++)\\n        {\\n            nums[i]=2;\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "beats 100%  C++"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n     int p1 = 0;\\n     int p2 = 0;\\n\\n     for(int i=0; i<nums.size(); i++)\\n     {\\n         if(nums[i]==0)\\n         {\\n             nums[i] = 2;\\n             nums[p2++] = 1;\\n             nums[p1++] = 0;\\n         }\\n         else if(nums[i]==1)\\n         {\\n                nums[i] = 2;\\n                nums[p2++] =1; \\n         }\\n     }\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1748383,
                "content": [
                    {
                        "username": "shivangisinghhappy",
                        "content": "I am very confused with this problem, this is the code which is passing nearly half the test cases.\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        int left = 0;\\n        int right = nums.size()-1;\\n\\n        for (int k=0; k<nums.size(); k++) {\\n\\n            if (right<k) break;\\n\\n            if (nums[left] > nums[right]) {\\n                swap(nums[left], nums[right]);\\n            }\\n\\n            if (k>left && nums[k] < nums[left]) {\\n                swap(nums[k], nums[left]);\\n            }\\n\\n            if (k<left && nums[k] > nums[left]) {\\n                swap(nums[left], nums[k]);\\n            }\\n\\n            if (nums[k] > nums[right]) {\\n                swap(nums[k], nums[right]);\\n            }\\n\\n            if (nums[left] == 0) left++;\\n            if (nums[right] == 2) right--;\\n\\n        }\\n    }\\n};`\\nIf anyone can help how can I improve this code to submit other test cases."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "use bucket sort\\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "question based on quick sort -> partition function \\nsimply simple approch with one extra pointer fixed at end  "
                    },
                    {
                        "username": "tapegun",
                        "content": "I\\'m such a beta I used an ORDERED hashmap lol"
                    },
                    {
                        "username": "ACoder07",
                        "content": "Doing question using simple stack method is a correct approach?"
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "count 0\\'s , 1\\'s , and 2\\'s in array \\nand iterate through array again and chand the index values from start to the count of the respective numbers.\\n"
                    },
                    {
                        "username": "kamdarveer",
                        "content": "Brute force approach with time complexity as O(n)\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n    vector<int> ans;\\n    int n= (int)nums.size();\\n        \\n        int red=0;\\n        int white=0;\\n        int blue=0;\\n\\n        //Counting the number of colors!\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            red++;\\n\\n            else if(nums[i]==1)\\n            white++;\\n\\n            else\\n            blue++;\\n        }\\n\\n        for(int i=0; i<red;i++)\\n        {\\n            nums[i]=0;\\n        }\\n\\n        for(int i=red; i<red+white ; i++)\\n        {\\n            nums[i]=1;\\n        }\\n        \\n        for(int i=red+white; i<n;i++)\\n        {\\n            nums[i]=2;\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "beats 100%  C++"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n     int p1 = 0;\\n     int p2 = 0;\\n\\n     for(int i=0; i<nums.size(); i++)\\n     {\\n         if(nums[i]==0)\\n         {\\n             nums[i] = 2;\\n             nums[p2++] = 1;\\n             nums[p1++] = 0;\\n         }\\n         else if(nums[i]==1)\\n         {\\n                nums[i] = 2;\\n                nums[p2++] =1; \\n         }\\n     }\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1745693,
                "content": [
                    {
                        "username": "shivangisinghhappy",
                        "content": "I am very confused with this problem, this is the code which is passing nearly half the test cases.\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        int left = 0;\\n        int right = nums.size()-1;\\n\\n        for (int k=0; k<nums.size(); k++) {\\n\\n            if (right<k) break;\\n\\n            if (nums[left] > nums[right]) {\\n                swap(nums[left], nums[right]);\\n            }\\n\\n            if (k>left && nums[k] < nums[left]) {\\n                swap(nums[k], nums[left]);\\n            }\\n\\n            if (k<left && nums[k] > nums[left]) {\\n                swap(nums[left], nums[k]);\\n            }\\n\\n            if (nums[k] > nums[right]) {\\n                swap(nums[k], nums[right]);\\n            }\\n\\n            if (nums[left] == 0) left++;\\n            if (nums[right] == 2) right--;\\n\\n        }\\n    }\\n};`\\nIf anyone can help how can I improve this code to submit other test cases."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "use bucket sort\\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "question based on quick sort -> partition function \\nsimply simple approch with one extra pointer fixed at end  "
                    },
                    {
                        "username": "tapegun",
                        "content": "I\\'m such a beta I used an ORDERED hashmap lol"
                    },
                    {
                        "username": "ACoder07",
                        "content": "Doing question using simple stack method is a correct approach?"
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "count 0\\'s , 1\\'s , and 2\\'s in array \\nand iterate through array again and chand the index values from start to the count of the respective numbers.\\n"
                    },
                    {
                        "username": "kamdarveer",
                        "content": "Brute force approach with time complexity as O(n)\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n    vector<int> ans;\\n    int n= (int)nums.size();\\n        \\n        int red=0;\\n        int white=0;\\n        int blue=0;\\n\\n        //Counting the number of colors!\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            red++;\\n\\n            else if(nums[i]==1)\\n            white++;\\n\\n            else\\n            blue++;\\n        }\\n\\n        for(int i=0; i<red;i++)\\n        {\\n            nums[i]=0;\\n        }\\n\\n        for(int i=red; i<red+white ; i++)\\n        {\\n            nums[i]=1;\\n        }\\n        \\n        for(int i=red+white; i<n;i++)\\n        {\\n            nums[i]=2;\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "beats 100%  C++"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n     int p1 = 0;\\n     int p2 = 0;\\n\\n     for(int i=0; i<nums.size(); i++)\\n     {\\n         if(nums[i]==0)\\n         {\\n             nums[i] = 2;\\n             nums[p2++] = 1;\\n             nums[p1++] = 0;\\n         }\\n         else if(nums[i]==1)\\n         {\\n                nums[i] = 2;\\n                nums[p2++] =1; \\n         }\\n     }\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1741856,
                "content": [
                    {
                        "username": "shivangisinghhappy",
                        "content": "I am very confused with this problem, this is the code which is passing nearly half the test cases.\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        int left = 0;\\n        int right = nums.size()-1;\\n\\n        for (int k=0; k<nums.size(); k++) {\\n\\n            if (right<k) break;\\n\\n            if (nums[left] > nums[right]) {\\n                swap(nums[left], nums[right]);\\n            }\\n\\n            if (k>left && nums[k] < nums[left]) {\\n                swap(nums[k], nums[left]);\\n            }\\n\\n            if (k<left && nums[k] > nums[left]) {\\n                swap(nums[left], nums[k]);\\n            }\\n\\n            if (nums[k] > nums[right]) {\\n                swap(nums[k], nums[right]);\\n            }\\n\\n            if (nums[left] == 0) left++;\\n            if (nums[right] == 2) right--;\\n\\n        }\\n    }\\n};`\\nIf anyone can help how can I improve this code to submit other test cases."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "use bucket sort\\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "question based on quick sort -> partition function \\nsimply simple approch with one extra pointer fixed at end  "
                    },
                    {
                        "username": "tapegun",
                        "content": "I\\'m such a beta I used an ORDERED hashmap lol"
                    },
                    {
                        "username": "ACoder07",
                        "content": "Doing question using simple stack method is a correct approach?"
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "count 0\\'s , 1\\'s , and 2\\'s in array \\nand iterate through array again and chand the index values from start to the count of the respective numbers.\\n"
                    },
                    {
                        "username": "kamdarveer",
                        "content": "Brute force approach with time complexity as O(n)\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n    vector<int> ans;\\n    int n= (int)nums.size();\\n        \\n        int red=0;\\n        int white=0;\\n        int blue=0;\\n\\n        //Counting the number of colors!\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            red++;\\n\\n            else if(nums[i]==1)\\n            white++;\\n\\n            else\\n            blue++;\\n        }\\n\\n        for(int i=0; i<red;i++)\\n        {\\n            nums[i]=0;\\n        }\\n\\n        for(int i=red; i<red+white ; i++)\\n        {\\n            nums[i]=1;\\n        }\\n        \\n        for(int i=red+white; i<n;i++)\\n        {\\n            nums[i]=2;\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "beats 100%  C++"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n     int p1 = 0;\\n     int p2 = 0;\\n\\n     for(int i=0; i<nums.size(); i++)\\n     {\\n         if(nums[i]==0)\\n         {\\n             nums[i] = 2;\\n             nums[p2++] = 1;\\n             nums[p1++] = 0;\\n         }\\n         else if(nums[i]==1)\\n         {\\n                nums[i] = 2;\\n                nums[p2++] =1; \\n         }\\n     }\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1735133,
                "content": [
                    {
                        "username": "shivangisinghhappy",
                        "content": "I am very confused with this problem, this is the code which is passing nearly half the test cases.\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        int left = 0;\\n        int right = nums.size()-1;\\n\\n        for (int k=0; k<nums.size(); k++) {\\n\\n            if (right<k) break;\\n\\n            if (nums[left] > nums[right]) {\\n                swap(nums[left], nums[right]);\\n            }\\n\\n            if (k>left && nums[k] < nums[left]) {\\n                swap(nums[k], nums[left]);\\n            }\\n\\n            if (k<left && nums[k] > nums[left]) {\\n                swap(nums[left], nums[k]);\\n            }\\n\\n            if (nums[k] > nums[right]) {\\n                swap(nums[k], nums[right]);\\n            }\\n\\n            if (nums[left] == 0) left++;\\n            if (nums[right] == 2) right--;\\n\\n        }\\n    }\\n};`\\nIf anyone can help how can I improve this code to submit other test cases."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "use bucket sort\\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "question based on quick sort -> partition function \\nsimply simple approch with one extra pointer fixed at end  "
                    },
                    {
                        "username": "tapegun",
                        "content": "I\\'m such a beta I used an ORDERED hashmap lol"
                    },
                    {
                        "username": "ACoder07",
                        "content": "Doing question using simple stack method is a correct approach?"
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "count 0\\'s , 1\\'s , and 2\\'s in array \\nand iterate through array again and chand the index values from start to the count of the respective numbers.\\n"
                    },
                    {
                        "username": "kamdarveer",
                        "content": "Brute force approach with time complexity as O(n)\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n    vector<int> ans;\\n    int n= (int)nums.size();\\n        \\n        int red=0;\\n        int white=0;\\n        int blue=0;\\n\\n        //Counting the number of colors!\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            red++;\\n\\n            else if(nums[i]==1)\\n            white++;\\n\\n            else\\n            blue++;\\n        }\\n\\n        for(int i=0; i<red;i++)\\n        {\\n            nums[i]=0;\\n        }\\n\\n        for(int i=red; i<red+white ; i++)\\n        {\\n            nums[i]=1;\\n        }\\n        \\n        for(int i=red+white; i<n;i++)\\n        {\\n            nums[i]=2;\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "beats 100%  C++"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n     int p1 = 0;\\n     int p2 = 0;\\n\\n     for(int i=0; i<nums.size(); i++)\\n     {\\n         if(nums[i]==0)\\n         {\\n             nums[i] = 2;\\n             nums[p2++] = 1;\\n             nums[p1++] = 0;\\n         }\\n         else if(nums[i]==1)\\n         {\\n                nums[i] = 2;\\n                nums[p2++] =1; \\n         }\\n     }\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1729439,
                "content": [
                    {
                        "username": "shivangisinghhappy",
                        "content": "I am very confused with this problem, this is the code which is passing nearly half the test cases.\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        int left = 0;\\n        int right = nums.size()-1;\\n\\n        for (int k=0; k<nums.size(); k++) {\\n\\n            if (right<k) break;\\n\\n            if (nums[left] > nums[right]) {\\n                swap(nums[left], nums[right]);\\n            }\\n\\n            if (k>left && nums[k] < nums[left]) {\\n                swap(nums[k], nums[left]);\\n            }\\n\\n            if (k<left && nums[k] > nums[left]) {\\n                swap(nums[left], nums[k]);\\n            }\\n\\n            if (nums[k] > nums[right]) {\\n                swap(nums[k], nums[right]);\\n            }\\n\\n            if (nums[left] == 0) left++;\\n            if (nums[right] == 2) right--;\\n\\n        }\\n    }\\n};`\\nIf anyone can help how can I improve this code to submit other test cases."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "use bucket sort\\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "question based on quick sort -> partition function \\nsimply simple approch with one extra pointer fixed at end  "
                    },
                    {
                        "username": "tapegun",
                        "content": "I\\'m such a beta I used an ORDERED hashmap lol"
                    },
                    {
                        "username": "ACoder07",
                        "content": "Doing question using simple stack method is a correct approach?"
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "count 0\\'s , 1\\'s , and 2\\'s in array \\nand iterate through array again and chand the index values from start to the count of the respective numbers.\\n"
                    },
                    {
                        "username": "kamdarveer",
                        "content": "Brute force approach with time complexity as O(n)\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n    vector<int> ans;\\n    int n= (int)nums.size();\\n        \\n        int red=0;\\n        int white=0;\\n        int blue=0;\\n\\n        //Counting the number of colors!\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            red++;\\n\\n            else if(nums[i]==1)\\n            white++;\\n\\n            else\\n            blue++;\\n        }\\n\\n        for(int i=0; i<red;i++)\\n        {\\n            nums[i]=0;\\n        }\\n\\n        for(int i=red; i<red+white ; i++)\\n        {\\n            nums[i]=1;\\n        }\\n        \\n        for(int i=red+white; i<n;i++)\\n        {\\n            nums[i]=2;\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "beats 100%  C++"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n     int p1 = 0;\\n     int p2 = 0;\\n\\n     for(int i=0; i<nums.size(); i++)\\n     {\\n         if(nums[i]==0)\\n         {\\n             nums[i] = 2;\\n             nums[p2++] = 1;\\n             nums[p1++] = 0;\\n         }\\n         else if(nums[i]==1)\\n         {\\n                nums[i] = 2;\\n                nums[p2++] =1; \\n         }\\n     }\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1726503,
                "content": [
                    {
                        "username": "shivangisinghhappy",
                        "content": "I am very confused with this problem, this is the code which is passing nearly half the test cases.\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        int left = 0;\\n        int right = nums.size()-1;\\n\\n        for (int k=0; k<nums.size(); k++) {\\n\\n            if (right<k) break;\\n\\n            if (nums[left] > nums[right]) {\\n                swap(nums[left], nums[right]);\\n            }\\n\\n            if (k>left && nums[k] < nums[left]) {\\n                swap(nums[k], nums[left]);\\n            }\\n\\n            if (k<left && nums[k] > nums[left]) {\\n                swap(nums[left], nums[k]);\\n            }\\n\\n            if (nums[k] > nums[right]) {\\n                swap(nums[k], nums[right]);\\n            }\\n\\n            if (nums[left] == 0) left++;\\n            if (nums[right] == 2) right--;\\n\\n        }\\n    }\\n};`\\nIf anyone can help how can I improve this code to submit other test cases."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "use bucket sort\\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "question based on quick sort -> partition function \\nsimply simple approch with one extra pointer fixed at end  "
                    },
                    {
                        "username": "tapegun",
                        "content": "I\\'m such a beta I used an ORDERED hashmap lol"
                    },
                    {
                        "username": "ACoder07",
                        "content": "Doing question using simple stack method is a correct approach?"
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "count 0\\'s , 1\\'s , and 2\\'s in array \\nand iterate through array again and chand the index values from start to the count of the respective numbers.\\n"
                    },
                    {
                        "username": "kamdarveer",
                        "content": "Brute force approach with time complexity as O(n)\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n    vector<int> ans;\\n    int n= (int)nums.size();\\n        \\n        int red=0;\\n        int white=0;\\n        int blue=0;\\n\\n        //Counting the number of colors!\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            red++;\\n\\n            else if(nums[i]==1)\\n            white++;\\n\\n            else\\n            blue++;\\n        }\\n\\n        for(int i=0; i<red;i++)\\n        {\\n            nums[i]=0;\\n        }\\n\\n        for(int i=red; i<red+white ; i++)\\n        {\\n            nums[i]=1;\\n        }\\n        \\n        for(int i=red+white; i<n;i++)\\n        {\\n            nums[i]=2;\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "beats 100%  C++"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n     int p1 = 0;\\n     int p2 = 0;\\n\\n     for(int i=0; i<nums.size(); i++)\\n     {\\n         if(nums[i]==0)\\n         {\\n             nums[i] = 2;\\n             nums[p2++] = 1;\\n             nums[p1++] = 0;\\n         }\\n         else if(nums[i]==1)\\n         {\\n                nums[i] = 2;\\n                nums[p2++] =1; \\n         }\\n     }\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1726501,
                "content": [
                    {
                        "username": "shivangisinghhappy",
                        "content": "I am very confused with this problem, this is the code which is passing nearly half the test cases.\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n        int left = 0;\\n        int right = nums.size()-1;\\n\\n        for (int k=0; k<nums.size(); k++) {\\n\\n            if (right<k) break;\\n\\n            if (nums[left] > nums[right]) {\\n                swap(nums[left], nums[right]);\\n            }\\n\\n            if (k>left && nums[k] < nums[left]) {\\n                swap(nums[k], nums[left]);\\n            }\\n\\n            if (k<left && nums[k] > nums[left]) {\\n                swap(nums[left], nums[k]);\\n            }\\n\\n            if (nums[k] > nums[right]) {\\n                swap(nums[k], nums[right]);\\n            }\\n\\n            if (nums[left] == 0) left++;\\n            if (nums[right] == 2) right--;\\n\\n        }\\n    }\\n};`\\nIf anyone can help how can I improve this code to submit other test cases."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "use bucket sort\\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "question based on quick sort -> partition function \\nsimply simple approch with one extra pointer fixed at end  "
                    },
                    {
                        "username": "tapegun",
                        "content": "I\\'m such a beta I used an ORDERED hashmap lol"
                    },
                    {
                        "username": "ACoder07",
                        "content": "Doing question using simple stack method is a correct approach?"
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "count 0\\'s , 1\\'s , and 2\\'s in array \\nand iterate through array again and chand the index values from start to the count of the respective numbers.\\n"
                    },
                    {
                        "username": "kamdarveer",
                        "content": "Brute force approach with time complexity as O(n)\\n\\n `class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n\\n    vector<int> ans;\\n    int n= (int)nums.size();\\n        \\n        int red=0;\\n        int white=0;\\n        int blue=0;\\n\\n        //Counting the number of colors!\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            red++;\\n\\n            else if(nums[i]==1)\\n            white++;\\n\\n            else\\n            blue++;\\n        }\\n\\n        for(int i=0; i<red;i++)\\n        {\\n            nums[i]=0;\\n        }\\n\\n        for(int i=red; i<red+white ; i++)\\n        {\\n            nums[i]=1;\\n        }\\n        \\n        for(int i=red+white; i<n;i++)\\n        {\\n            nums[i]=2;\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "beats 100%  C++"
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n     int p1 = 0;\\n     int p2 = 0;\\n\\n     for(int i=0; i<nums.size(); i++)\\n     {\\n         if(nums[i]==0)\\n         {\\n             nums[i] = 2;\\n             nums[p2++] = 1;\\n             nums[p1++] = 0;\\n         }\\n         else if(nums[i]==1)\\n         {\\n                nums[i] = 2;\\n                nums[p2++] =1; \\n         }\\n     }\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1721261,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/75_sort_colours.cpp"
                    },
                    {
                        "username": "pathak_priya",
                        "content": "This can be solved in single pass and using constant space using dutch flag algorithm."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,b=0,c=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                swap(nums[i],nums[a]);\\n                a++;\\n            }\\n            else if(nums[i]==2)\\n            {\\n                swap(nums[i],nums[c]);\\n                c--,n--,i--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "Most Optimized"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "VISHNUPRATAPSINGH",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] nums) {\\n        int mid =0;\\n        int left =0; \\n        int right = nums.length-1;\\n\\n       while(mid<=right){\\n           if(nums[mid]==0){\\n               int temp = nums[left];\\n               nums[left]=nums[mid];\\n               nums[mid]=temp;\\n               left++;\\n               mid++;\\n           }else if(nums[mid] == 2){\\n               int temp = nums[mid];\\n               nums[mid]=nums[right];\\n               nums[right]=temp;\\n               \\n               right--;\\n           }else if(nums[mid]==1){\\n               mid++;\\n           }\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "madhusweety",
                        "content": "worst it\\'s working in my normal compiler"
                    },
                    {
                        "username": "DorukYelken",
                        "content": "My code is working on Eclipse but it is giving this error in leetcode.\\nMethod sortColors in class Solution cannot be applied to given types; [in __Driver__.java]"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "void sortColors(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n    }"
                    },
                    {
                        "username": "thanmaisai",
                        "content": "Java Solution with commented code and basic logic\\n\\n**Logic:**\\nlow and mid = 0 and high = nums.length \\nmid == 0 \\u21D2 swap low and mid then mid++,low++\\nmid == 1 \\u21D2 mid++ mid == 2 =\\u21D2 swap mid and high then high--\\n\\n**Code**\\n```\\n class  Solution {\\n    public  void  sortColors(int[] nums)\\n    {\\n     //step1: first declare the low,mid,high and temp for swapping later\\n      int  low = 0;\\n     int  mid = 0;\\n     int  high = nums.length-1;\\n     int  temp;\\n     //step2: use loop to iterate nums[] and switch case to see if value is 0 or 1 or 2\\n    while(mid<=high){ // because the loop wont swap if mid>high\\n        switch(nums[mid]){\\n          case  0: // now as mid == 0 swap mid with low and increment mid and low by 1\\n             temp = nums[low];\\n             nums[low] = nums[mid];\\n             nums[mid] = temp;\\n             low++;mid++;break;\\n\\n         case  1:// now as mid == 1 we will just increment mid by 1\\n         mid++; break;\\n\\n          case  2:// as mid == 2 swap mid with high and only decrement high by 1\\n           temp = nums[mid];\\n           nums[mid] = nums[high];\\n           nums[high] = temp;\\n          high--;\\n          break;\\n             } // end of switch\\n         } //end of while\\n     }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1721212,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/75_sort_colours.cpp"
                    },
                    {
                        "username": "pathak_priya",
                        "content": "This can be solved in single pass and using constant space using dutch flag algorithm."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,b=0,c=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                swap(nums[i],nums[a]);\\n                a++;\\n            }\\n            else if(nums[i]==2)\\n            {\\n                swap(nums[i],nums[c]);\\n                c--,n--,i--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "Most Optimized"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "VISHNUPRATAPSINGH",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] nums) {\\n        int mid =0;\\n        int left =0; \\n        int right = nums.length-1;\\n\\n       while(mid<=right){\\n           if(nums[mid]==0){\\n               int temp = nums[left];\\n               nums[left]=nums[mid];\\n               nums[mid]=temp;\\n               left++;\\n               mid++;\\n           }else if(nums[mid] == 2){\\n               int temp = nums[mid];\\n               nums[mid]=nums[right];\\n               nums[right]=temp;\\n               \\n               right--;\\n           }else if(nums[mid]==1){\\n               mid++;\\n           }\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "madhusweety",
                        "content": "worst it\\'s working in my normal compiler"
                    },
                    {
                        "username": "DorukYelken",
                        "content": "My code is working on Eclipse but it is giving this error in leetcode.\\nMethod sortColors in class Solution cannot be applied to given types; [in __Driver__.java]"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "void sortColors(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n    }"
                    },
                    {
                        "username": "thanmaisai",
                        "content": "Java Solution with commented code and basic logic\\n\\n**Logic:**\\nlow and mid = 0 and high = nums.length \\nmid == 0 \\u21D2 swap low and mid then mid++,low++\\nmid == 1 \\u21D2 mid++ mid == 2 =\\u21D2 swap mid and high then high--\\n\\n**Code**\\n```\\n class  Solution {\\n    public  void  sortColors(int[] nums)\\n    {\\n     //step1: first declare the low,mid,high and temp for swapping later\\n      int  low = 0;\\n     int  mid = 0;\\n     int  high = nums.length-1;\\n     int  temp;\\n     //step2: use loop to iterate nums[] and switch case to see if value is 0 or 1 or 2\\n    while(mid<=high){ // because the loop wont swap if mid>high\\n        switch(nums[mid]){\\n          case  0: // now as mid == 0 swap mid with low and increment mid and low by 1\\n             temp = nums[low];\\n             nums[low] = nums[mid];\\n             nums[mid] = temp;\\n             low++;mid++;break;\\n\\n         case  1:// now as mid == 1 we will just increment mid by 1\\n         mid++; break;\\n\\n          case  2:// as mid == 2 swap mid with high and only decrement high by 1\\n           temp = nums[mid];\\n           nums[mid] = nums[high];\\n           nums[high] = temp;\\n          high--;\\n          break;\\n             } // end of switch\\n         } //end of while\\n     }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1715502,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/75_sort_colours.cpp"
                    },
                    {
                        "username": "pathak_priya",
                        "content": "This can be solved in single pass and using constant space using dutch flag algorithm."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,b=0,c=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                swap(nums[i],nums[a]);\\n                a++;\\n            }\\n            else if(nums[i]==2)\\n            {\\n                swap(nums[i],nums[c]);\\n                c--,n--,i--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "Most Optimized"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "VISHNUPRATAPSINGH",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] nums) {\\n        int mid =0;\\n        int left =0; \\n        int right = nums.length-1;\\n\\n       while(mid<=right){\\n           if(nums[mid]==0){\\n               int temp = nums[left];\\n               nums[left]=nums[mid];\\n               nums[mid]=temp;\\n               left++;\\n               mid++;\\n           }else if(nums[mid] == 2){\\n               int temp = nums[mid];\\n               nums[mid]=nums[right];\\n               nums[right]=temp;\\n               \\n               right--;\\n           }else if(nums[mid]==1){\\n               mid++;\\n           }\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "madhusweety",
                        "content": "worst it\\'s working in my normal compiler"
                    },
                    {
                        "username": "DorukYelken",
                        "content": "My code is working on Eclipse but it is giving this error in leetcode.\\nMethod sortColors in class Solution cannot be applied to given types; [in __Driver__.java]"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "void sortColors(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n    }"
                    },
                    {
                        "username": "thanmaisai",
                        "content": "Java Solution with commented code and basic logic\\n\\n**Logic:**\\nlow and mid = 0 and high = nums.length \\nmid == 0 \\u21D2 swap low and mid then mid++,low++\\nmid == 1 \\u21D2 mid++ mid == 2 =\\u21D2 swap mid and high then high--\\n\\n**Code**\\n```\\n class  Solution {\\n    public  void  sortColors(int[] nums)\\n    {\\n     //step1: first declare the low,mid,high and temp for swapping later\\n      int  low = 0;\\n     int  mid = 0;\\n     int  high = nums.length-1;\\n     int  temp;\\n     //step2: use loop to iterate nums[] and switch case to see if value is 0 or 1 or 2\\n    while(mid<=high){ // because the loop wont swap if mid>high\\n        switch(nums[mid]){\\n          case  0: // now as mid == 0 swap mid with low and increment mid and low by 1\\n             temp = nums[low];\\n             nums[low] = nums[mid];\\n             nums[mid] = temp;\\n             low++;mid++;break;\\n\\n         case  1:// now as mid == 1 we will just increment mid by 1\\n         mid++; break;\\n\\n          case  2:// as mid == 2 swap mid with high and only decrement high by 1\\n           temp = nums[mid];\\n           nums[mid] = nums[high];\\n           nums[high] = temp;\\n          high--;\\n          break;\\n             } // end of switch\\n         } //end of while\\n     }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1710926,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/75_sort_colours.cpp"
                    },
                    {
                        "username": "pathak_priya",
                        "content": "This can be solved in single pass and using constant space using dutch flag algorithm."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,b=0,c=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                swap(nums[i],nums[a]);\\n                a++;\\n            }\\n            else if(nums[i]==2)\\n            {\\n                swap(nums[i],nums[c]);\\n                c--,n--,i--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "Most Optimized"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "VISHNUPRATAPSINGH",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] nums) {\\n        int mid =0;\\n        int left =0; \\n        int right = nums.length-1;\\n\\n       while(mid<=right){\\n           if(nums[mid]==0){\\n               int temp = nums[left];\\n               nums[left]=nums[mid];\\n               nums[mid]=temp;\\n               left++;\\n               mid++;\\n           }else if(nums[mid] == 2){\\n               int temp = nums[mid];\\n               nums[mid]=nums[right];\\n               nums[right]=temp;\\n               \\n               right--;\\n           }else if(nums[mid]==1){\\n               mid++;\\n           }\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "madhusweety",
                        "content": "worst it\\'s working in my normal compiler"
                    },
                    {
                        "username": "DorukYelken",
                        "content": "My code is working on Eclipse but it is giving this error in leetcode.\\nMethod sortColors in class Solution cannot be applied to given types; [in __Driver__.java]"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "void sortColors(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n    }"
                    },
                    {
                        "username": "thanmaisai",
                        "content": "Java Solution with commented code and basic logic\\n\\n**Logic:**\\nlow and mid = 0 and high = nums.length \\nmid == 0 \\u21D2 swap low and mid then mid++,low++\\nmid == 1 \\u21D2 mid++ mid == 2 =\\u21D2 swap mid and high then high--\\n\\n**Code**\\n```\\n class  Solution {\\n    public  void  sortColors(int[] nums)\\n    {\\n     //step1: first declare the low,mid,high and temp for swapping later\\n      int  low = 0;\\n     int  mid = 0;\\n     int  high = nums.length-1;\\n     int  temp;\\n     //step2: use loop to iterate nums[] and switch case to see if value is 0 or 1 or 2\\n    while(mid<=high){ // because the loop wont swap if mid>high\\n        switch(nums[mid]){\\n          case  0: // now as mid == 0 swap mid with low and increment mid and low by 1\\n             temp = nums[low];\\n             nums[low] = nums[mid];\\n             nums[mid] = temp;\\n             low++;mid++;break;\\n\\n         case  1:// now as mid == 1 we will just increment mid by 1\\n         mid++; break;\\n\\n          case  2:// as mid == 2 swap mid with high and only decrement high by 1\\n           temp = nums[mid];\\n           nums[mid] = nums[high];\\n           nums[high] = temp;\\n          high--;\\n          break;\\n             } // end of switch\\n         } //end of while\\n     }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1710925,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/75_sort_colours.cpp"
                    },
                    {
                        "username": "pathak_priya",
                        "content": "This can be solved in single pass and using constant space using dutch flag algorithm."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,b=0,c=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                swap(nums[i],nums[a]);\\n                a++;\\n            }\\n            else if(nums[i]==2)\\n            {\\n                swap(nums[i],nums[c]);\\n                c--,n--,i--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "Most Optimized"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "VISHNUPRATAPSINGH",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] nums) {\\n        int mid =0;\\n        int left =0; \\n        int right = nums.length-1;\\n\\n       while(mid<=right){\\n           if(nums[mid]==0){\\n               int temp = nums[left];\\n               nums[left]=nums[mid];\\n               nums[mid]=temp;\\n               left++;\\n               mid++;\\n           }else if(nums[mid] == 2){\\n               int temp = nums[mid];\\n               nums[mid]=nums[right];\\n               nums[right]=temp;\\n               \\n               right--;\\n           }else if(nums[mid]==1){\\n               mid++;\\n           }\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "madhusweety",
                        "content": "worst it\\'s working in my normal compiler"
                    },
                    {
                        "username": "DorukYelken",
                        "content": "My code is working on Eclipse but it is giving this error in leetcode.\\nMethod sortColors in class Solution cannot be applied to given types; [in __Driver__.java]"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "void sortColors(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n    }"
                    },
                    {
                        "username": "thanmaisai",
                        "content": "Java Solution with commented code and basic logic\\n\\n**Logic:**\\nlow and mid = 0 and high = nums.length \\nmid == 0 \\u21D2 swap low and mid then mid++,low++\\nmid == 1 \\u21D2 mid++ mid == 2 =\\u21D2 swap mid and high then high--\\n\\n**Code**\\n```\\n class  Solution {\\n    public  void  sortColors(int[] nums)\\n    {\\n     //step1: first declare the low,mid,high and temp for swapping later\\n      int  low = 0;\\n     int  mid = 0;\\n     int  high = nums.length-1;\\n     int  temp;\\n     //step2: use loop to iterate nums[] and switch case to see if value is 0 or 1 or 2\\n    while(mid<=high){ // because the loop wont swap if mid>high\\n        switch(nums[mid]){\\n          case  0: // now as mid == 0 swap mid with low and increment mid and low by 1\\n             temp = nums[low];\\n             nums[low] = nums[mid];\\n             nums[mid] = temp;\\n             low++;mid++;break;\\n\\n         case  1:// now as mid == 1 we will just increment mid by 1\\n         mid++; break;\\n\\n          case  2:// as mid == 2 swap mid with high and only decrement high by 1\\n           temp = nums[mid];\\n           nums[mid] = nums[high];\\n           nums[high] = temp;\\n          high--;\\n          break;\\n             } // end of switch\\n         } //end of while\\n     }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1707308,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/75_sort_colours.cpp"
                    },
                    {
                        "username": "pathak_priya",
                        "content": "This can be solved in single pass and using constant space using dutch flag algorithm."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,b=0,c=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                swap(nums[i],nums[a]);\\n                a++;\\n            }\\n            else if(nums[i]==2)\\n            {\\n                swap(nums[i],nums[c]);\\n                c--,n--,i--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "Most Optimized"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "VISHNUPRATAPSINGH",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] nums) {\\n        int mid =0;\\n        int left =0; \\n        int right = nums.length-1;\\n\\n       while(mid<=right){\\n           if(nums[mid]==0){\\n               int temp = nums[left];\\n               nums[left]=nums[mid];\\n               nums[mid]=temp;\\n               left++;\\n               mid++;\\n           }else if(nums[mid] == 2){\\n               int temp = nums[mid];\\n               nums[mid]=nums[right];\\n               nums[right]=temp;\\n               \\n               right--;\\n           }else if(nums[mid]==1){\\n               mid++;\\n           }\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "madhusweety",
                        "content": "worst it\\'s working in my normal compiler"
                    },
                    {
                        "username": "DorukYelken",
                        "content": "My code is working on Eclipse but it is giving this error in leetcode.\\nMethod sortColors in class Solution cannot be applied to given types; [in __Driver__.java]"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "void sortColors(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n    }"
                    },
                    {
                        "username": "thanmaisai",
                        "content": "Java Solution with commented code and basic logic\\n\\n**Logic:**\\nlow and mid = 0 and high = nums.length \\nmid == 0 \\u21D2 swap low and mid then mid++,low++\\nmid == 1 \\u21D2 mid++ mid == 2 =\\u21D2 swap mid and high then high--\\n\\n**Code**\\n```\\n class  Solution {\\n    public  void  sortColors(int[] nums)\\n    {\\n     //step1: first declare the low,mid,high and temp for swapping later\\n      int  low = 0;\\n     int  mid = 0;\\n     int  high = nums.length-1;\\n     int  temp;\\n     //step2: use loop to iterate nums[] and switch case to see if value is 0 or 1 or 2\\n    while(mid<=high){ // because the loop wont swap if mid>high\\n        switch(nums[mid]){\\n          case  0: // now as mid == 0 swap mid with low and increment mid and low by 1\\n             temp = nums[low];\\n             nums[low] = nums[mid];\\n             nums[mid] = temp;\\n             low++;mid++;break;\\n\\n         case  1:// now as mid == 1 we will just increment mid by 1\\n         mid++; break;\\n\\n          case  2:// as mid == 2 swap mid with high and only decrement high by 1\\n           temp = nums[mid];\\n           nums[mid] = nums[high];\\n           nums[high] = temp;\\n          high--;\\n          break;\\n             } // end of switch\\n         } //end of while\\n     }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1706547,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/75_sort_colours.cpp"
                    },
                    {
                        "username": "pathak_priya",
                        "content": "This can be solved in single pass and using constant space using dutch flag algorithm."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,b=0,c=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                swap(nums[i],nums[a]);\\n                a++;\\n            }\\n            else if(nums[i]==2)\\n            {\\n                swap(nums[i],nums[c]);\\n                c--,n--,i--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "Most Optimized"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "VISHNUPRATAPSINGH",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] nums) {\\n        int mid =0;\\n        int left =0; \\n        int right = nums.length-1;\\n\\n       while(mid<=right){\\n           if(nums[mid]==0){\\n               int temp = nums[left];\\n               nums[left]=nums[mid];\\n               nums[mid]=temp;\\n               left++;\\n               mid++;\\n           }else if(nums[mid] == 2){\\n               int temp = nums[mid];\\n               nums[mid]=nums[right];\\n               nums[right]=temp;\\n               \\n               right--;\\n           }else if(nums[mid]==1){\\n               mid++;\\n           }\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "madhusweety",
                        "content": "worst it\\'s working in my normal compiler"
                    },
                    {
                        "username": "DorukYelken",
                        "content": "My code is working on Eclipse but it is giving this error in leetcode.\\nMethod sortColors in class Solution cannot be applied to given types; [in __Driver__.java]"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "void sortColors(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n    }"
                    },
                    {
                        "username": "thanmaisai",
                        "content": "Java Solution with commented code and basic logic\\n\\n**Logic:**\\nlow and mid = 0 and high = nums.length \\nmid == 0 \\u21D2 swap low and mid then mid++,low++\\nmid == 1 \\u21D2 mid++ mid == 2 =\\u21D2 swap mid and high then high--\\n\\n**Code**\\n```\\n class  Solution {\\n    public  void  sortColors(int[] nums)\\n    {\\n     //step1: first declare the low,mid,high and temp for swapping later\\n      int  low = 0;\\n     int  mid = 0;\\n     int  high = nums.length-1;\\n     int  temp;\\n     //step2: use loop to iterate nums[] and switch case to see if value is 0 or 1 or 2\\n    while(mid<=high){ // because the loop wont swap if mid>high\\n        switch(nums[mid]){\\n          case  0: // now as mid == 0 swap mid with low and increment mid and low by 1\\n             temp = nums[low];\\n             nums[low] = nums[mid];\\n             nums[mid] = temp;\\n             low++;mid++;break;\\n\\n         case  1:// now as mid == 1 we will just increment mid by 1\\n         mid++; break;\\n\\n          case  2:// as mid == 2 swap mid with high and only decrement high by 1\\n           temp = nums[mid];\\n           nums[mid] = nums[high];\\n           nums[high] = temp;\\n          high--;\\n          break;\\n             } // end of switch\\n         } //end of while\\n     }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1702326,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/75_sort_colours.cpp"
                    },
                    {
                        "username": "pathak_priya",
                        "content": "This can be solved in single pass and using constant space using dutch flag algorithm."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,b=0,c=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                swap(nums[i],nums[a]);\\n                a++;\\n            }\\n            else if(nums[i]==2)\\n            {\\n                swap(nums[i],nums[c]);\\n                c--,n--,i--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "Most Optimized"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "VISHNUPRATAPSINGH",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] nums) {\\n        int mid =0;\\n        int left =0; \\n        int right = nums.length-1;\\n\\n       while(mid<=right){\\n           if(nums[mid]==0){\\n               int temp = nums[left];\\n               nums[left]=nums[mid];\\n               nums[mid]=temp;\\n               left++;\\n               mid++;\\n           }else if(nums[mid] == 2){\\n               int temp = nums[mid];\\n               nums[mid]=nums[right];\\n               nums[right]=temp;\\n               \\n               right--;\\n           }else if(nums[mid]==1){\\n               mid++;\\n           }\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "madhusweety",
                        "content": "worst it\\'s working in my normal compiler"
                    },
                    {
                        "username": "DorukYelken",
                        "content": "My code is working on Eclipse but it is giving this error in leetcode.\\nMethod sortColors in class Solution cannot be applied to given types; [in __Driver__.java]"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "void sortColors(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n    }"
                    },
                    {
                        "username": "thanmaisai",
                        "content": "Java Solution with commented code and basic logic\\n\\n**Logic:**\\nlow and mid = 0 and high = nums.length \\nmid == 0 \\u21D2 swap low and mid then mid++,low++\\nmid == 1 \\u21D2 mid++ mid == 2 =\\u21D2 swap mid and high then high--\\n\\n**Code**\\n```\\n class  Solution {\\n    public  void  sortColors(int[] nums)\\n    {\\n     //step1: first declare the low,mid,high and temp for swapping later\\n      int  low = 0;\\n     int  mid = 0;\\n     int  high = nums.length-1;\\n     int  temp;\\n     //step2: use loop to iterate nums[] and switch case to see if value is 0 or 1 or 2\\n    while(mid<=high){ // because the loop wont swap if mid>high\\n        switch(nums[mid]){\\n          case  0: // now as mid == 0 swap mid with low and increment mid and low by 1\\n             temp = nums[low];\\n             nums[low] = nums[mid];\\n             nums[mid] = temp;\\n             low++;mid++;break;\\n\\n         case  1:// now as mid == 1 we will just increment mid by 1\\n         mid++; break;\\n\\n          case  2:// as mid == 2 swap mid with high and only decrement high by 1\\n           temp = nums[mid];\\n           nums[mid] = nums[high];\\n           nums[high] = temp;\\n          high--;\\n          break;\\n             } // end of switch\\n         } //end of while\\n     }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1702278,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/75_sort_colours.cpp"
                    },
                    {
                        "username": "pathak_priya",
                        "content": "This can be solved in single pass and using constant space using dutch flag algorithm."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,b=0,c=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                swap(nums[i],nums[a]);\\n                a++;\\n            }\\n            else if(nums[i]==2)\\n            {\\n                swap(nums[i],nums[c]);\\n                c--,n--,i--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "Most Optimized"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "VISHNUPRATAPSINGH",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] nums) {\\n        int mid =0;\\n        int left =0; \\n        int right = nums.length-1;\\n\\n       while(mid<=right){\\n           if(nums[mid]==0){\\n               int temp = nums[left];\\n               nums[left]=nums[mid];\\n               nums[mid]=temp;\\n               left++;\\n               mid++;\\n           }else if(nums[mid] == 2){\\n               int temp = nums[mid];\\n               nums[mid]=nums[right];\\n               nums[right]=temp;\\n               \\n               right--;\\n           }else if(nums[mid]==1){\\n               mid++;\\n           }\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "madhusweety",
                        "content": "worst it\\'s working in my normal compiler"
                    },
                    {
                        "username": "DorukYelken",
                        "content": "My code is working on Eclipse but it is giving this error in leetcode.\\nMethod sortColors in class Solution cannot be applied to given types; [in __Driver__.java]"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "void sortColors(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n    }"
                    },
                    {
                        "username": "thanmaisai",
                        "content": "Java Solution with commented code and basic logic\\n\\n**Logic:**\\nlow and mid = 0 and high = nums.length \\nmid == 0 \\u21D2 swap low and mid then mid++,low++\\nmid == 1 \\u21D2 mid++ mid == 2 =\\u21D2 swap mid and high then high--\\n\\n**Code**\\n```\\n class  Solution {\\n    public  void  sortColors(int[] nums)\\n    {\\n     //step1: first declare the low,mid,high and temp for swapping later\\n      int  low = 0;\\n     int  mid = 0;\\n     int  high = nums.length-1;\\n     int  temp;\\n     //step2: use loop to iterate nums[] and switch case to see if value is 0 or 1 or 2\\n    while(mid<=high){ // because the loop wont swap if mid>high\\n        switch(nums[mid]){\\n          case  0: // now as mid == 0 swap mid with low and increment mid and low by 1\\n             temp = nums[low];\\n             nums[low] = nums[mid];\\n             nums[mid] = temp;\\n             low++;mid++;break;\\n\\n         case  1:// now as mid == 1 we will just increment mid by 1\\n         mid++; break;\\n\\n          case  2:// as mid == 2 swap mid with high and only decrement high by 1\\n           temp = nums[mid];\\n           nums[mid] = nums[high];\\n           nums[high] = temp;\\n          high--;\\n          break;\\n             } // end of switch\\n         } //end of while\\n     }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1699978,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/75_sort_colours.cpp"
                    },
                    {
                        "username": "pathak_priya",
                        "content": "This can be solved in single pass and using constant space using dutch flag algorithm."
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0,b=0,c=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                swap(nums[i],nums[a]);\\n                a++;\\n            }\\n            else if(nums[i]==2)\\n            {\\n                swap(nums[i],nums[c]);\\n                c--,n--,i--;\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "gauravsinghbhadauriya06",
                        "content": "Most Optimized"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] a) {\\n\\t\\tint j=0,z=0,t=0,o=0;\\n\\t\\tint res[] = new int[a.length];\\n\\t\\tfor(int i:a) {\\n\\t\\t\\tif(i==0) {\\n\\t\\t\\t\\tz++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==1) {\\n\\t\\t\\t\\to++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(i==2) {\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(z!=0) {\\n\\t\\t\\ta[j++] =0;\\n\\t\\t\\tz--;\\n\\t\\t}\\n\\t\\twhile(o!=0) {\\n\\t\\t\\ta[j++] =1;\\n\\t\\t\\to--;\\n\\t\\t}\\n\\t\\twhile(t!=0) {\\n\\t\\t\\ta[j++] =2;\\n\\t\\t\\tt--;\\n\\t\\t}\\n    }\\n}"
                    },
                    {
                        "username": "VISHNUPRATAPSINGH",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public void sortColors(int[] nums) {\\n        int mid =0;\\n        int left =0; \\n        int right = nums.length-1;\\n\\n       while(mid<=right){\\n           if(nums[mid]==0){\\n               int temp = nums[left];\\n               nums[left]=nums[mid];\\n               nums[mid]=temp;\\n               left++;\\n               mid++;\\n           }else if(nums[mid] == 2){\\n               int temp = nums[mid];\\n               nums[mid]=nums[right];\\n               nums[right]=temp;\\n               \\n               right--;\\n           }else if(nums[mid]==1){\\n               mid++;\\n           }\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "madhusweety",
                        "content": "worst it\\'s working in my normal compiler"
                    },
                    {
                        "username": "DorukYelken",
                        "content": "My code is working on Eclipse but it is giving this error in leetcode.\\nMethod sortColors in class Solution cannot be applied to given types; [in __Driver__.java]"
                    },
                    {
                        "username": "Azmankhan",
                        "content": "void sortColors(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n    }"
                    },
                    {
                        "username": "thanmaisai",
                        "content": "Java Solution with commented code and basic logic\\n\\n**Logic:**\\nlow and mid = 0 and high = nums.length \\nmid == 0 \\u21D2 swap low and mid then mid++,low++\\nmid == 1 \\u21D2 mid++ mid == 2 =\\u21D2 swap mid and high then high--\\n\\n**Code**\\n```\\n class  Solution {\\n    public  void  sortColors(int[] nums)\\n    {\\n     //step1: first declare the low,mid,high and temp for swapping later\\n      int  low = 0;\\n     int  mid = 0;\\n     int  high = nums.length-1;\\n     int  temp;\\n     //step2: use loop to iterate nums[] and switch case to see if value is 0 or 1 or 2\\n    while(mid<=high){ // because the loop wont swap if mid>high\\n        switch(nums[mid]){\\n          case  0: // now as mid == 0 swap mid with low and increment mid and low by 1\\n             temp = nums[low];\\n             nums[low] = nums[mid];\\n             nums[mid] = temp;\\n             low++;mid++;break;\\n\\n         case  1:// now as mid == 1 we will just increment mid by 1\\n         mid++; break;\\n\\n          case  2:// as mid == 2 swap mid with high and only decrement high by 1\\n           temp = nums[mid];\\n           nums[mid] = nums[high];\\n           nums[high] = temp;\\n          high--;\\n          break;\\n             } // end of switch\\n         } //end of while\\n     }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1694078,
                "content": [
                    {
                        "username": "Anonymous_user_79",
                        "content": "Dutch National Flag Algo:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,r=nums.size()-1;\\n        while(j<=r)\\n        {\\n            switch(nums[j])\\n            {\\n                case 0: swap(nums[i++],nums[j++]);\\n                        break;\\n                case 1: j++;\\n                        break;\\n                case 2: swap(nums[j],nums[r--]);\\n                        break;                \\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Counting Sort CPP Solution:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int c1=0,c2=0,c3=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                  c1++;\\n            else if(nums[i]==1)\\n                  c2++;\\n            else \\n                  c3++;            \\n        } \\n        int j=0;\\n        for(;j<c1;j++)\\n        {\\n            nums[j]=0;\\n        }\\n        for(;j<c2+c1;j++)\\n        {\\n            nums[j]=1;\\n        }\\n        for(;j<c1+c2+c3;j++)\\n        {\\n            nums[j]=2;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Harshal-Tupe",
                        "content": "\n// C++ Solution  \nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n             int zero = 0;\n             int one = 0;\n             int two = 0;\n        int s = nums.size();\n        vector<int> ans;\n        for(int i = 0; i<s; i++){\n            if(nums[i] == 0){\n                zero++;\n            }\n            if(nums[i] == 1){\n                one++;\n            }\n            if(nums[i] == 2){\n                two++;\n            }\n        }\n        nums.clear();\n        for(int i = 0; i<zero; i++){\n            nums.push_back(0);\n        }\n         for(int i = zero; i<zero+one; i++){\n            nums.push_back(1);\n        }\n         for(int i = zero+one; i<s; i++){\n            nums.push_back(2);\n        } \n    }\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "bekki3",
                        "content": "Best way is to use QuickSort. "
                    },
                    {
                        "username": "gargie20",
                        "content": "Can we solve this question using Arrays.sort(arr) ??"
                    },
                    {
                        "username": "gargie20",
                        "content": "[@yashodint](/yashodint) okay. Thanks \\n"
                    },
                    {
                        "username": "yashodint",
                        "content": "Yes, you can. but you need to solve the problem in O(n) T.C. Arrays.sort() has O(nlogn) T.C."
                    },
                    {
                        "username": "Mridulcse",
                        "content": "https://www.youtube.com/watch?v=9pdkbqGwUhs\\nsee this video,you will understand it better.\\n\\n `public void sortColors(int[] nums) {\\n        int start = 0;\\n        int mid = 0;\\n        int high = nums.length-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n            {\\n                int temp = nums[mid];\\n                nums[mid] = nums[start];\\n                nums[start] = temp;\\n                start++;\\n                mid++;\\n            }else if(nums[mid] == 1)\\n            {\\n                mid++;\\n            }else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--; \\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  3 DIFFERENT APPROACHES | UBER SDE-1 INTERVIEW\n\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "Pranay_24",
                        "content": "class Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        q = nums.count(\"0\")\\n        r = nums.count(\"1\")\\n        s = nums.count(\"2\")\\n        nums.clear()\\n        for i in range(q):\\n            nums.append(\"0\")\\n        for i in range(r):\\n            nums.append(\"1\")\\n        for i in range(s):\\n            nums.append(\"2\")\\n        return nums\\n\\n\\nwhy isnt it working?"
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Problem should really be rated easy. No difficult algorithmic trick to memorize here, just think about the problem for a moment."
                    }
                ]
            },
            {
                "id": 1694074,
                "content": [
                    {
                        "username": "Anonymous_user_79",
                        "content": "Dutch National Flag Algo:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,r=nums.size()-1;\\n        while(j<=r)\\n        {\\n            switch(nums[j])\\n            {\\n                case 0: swap(nums[i++],nums[j++]);\\n                        break;\\n                case 1: j++;\\n                        break;\\n                case 2: swap(nums[j],nums[r--]);\\n                        break;                \\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Counting Sort CPP Solution:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int c1=0,c2=0,c3=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                  c1++;\\n            else if(nums[i]==1)\\n                  c2++;\\n            else \\n                  c3++;            \\n        } \\n        int j=0;\\n        for(;j<c1;j++)\\n        {\\n            nums[j]=0;\\n        }\\n        for(;j<c2+c1;j++)\\n        {\\n            nums[j]=1;\\n        }\\n        for(;j<c1+c2+c3;j++)\\n        {\\n            nums[j]=2;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Harshal-Tupe",
                        "content": "\n// C++ Solution  \nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n             int zero = 0;\n             int one = 0;\n             int two = 0;\n        int s = nums.size();\n        vector<int> ans;\n        for(int i = 0; i<s; i++){\n            if(nums[i] == 0){\n                zero++;\n            }\n            if(nums[i] == 1){\n                one++;\n            }\n            if(nums[i] == 2){\n                two++;\n            }\n        }\n        nums.clear();\n        for(int i = 0; i<zero; i++){\n            nums.push_back(0);\n        }\n         for(int i = zero; i<zero+one; i++){\n            nums.push_back(1);\n        }\n         for(int i = zero+one; i<s; i++){\n            nums.push_back(2);\n        } \n    }\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "bekki3",
                        "content": "Best way is to use QuickSort. "
                    },
                    {
                        "username": "gargie20",
                        "content": "Can we solve this question using Arrays.sort(arr) ??"
                    },
                    {
                        "username": "gargie20",
                        "content": "[@yashodint](/yashodint) okay. Thanks \\n"
                    },
                    {
                        "username": "yashodint",
                        "content": "Yes, you can. but you need to solve the problem in O(n) T.C. Arrays.sort() has O(nlogn) T.C."
                    },
                    {
                        "username": "Mridulcse",
                        "content": "https://www.youtube.com/watch?v=9pdkbqGwUhs\\nsee this video,you will understand it better.\\n\\n `public void sortColors(int[] nums) {\\n        int start = 0;\\n        int mid = 0;\\n        int high = nums.length-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n            {\\n                int temp = nums[mid];\\n                nums[mid] = nums[start];\\n                nums[start] = temp;\\n                start++;\\n                mid++;\\n            }else if(nums[mid] == 1)\\n            {\\n                mid++;\\n            }else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--; \\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  3 DIFFERENT APPROACHES | UBER SDE-1 INTERVIEW\n\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "Pranay_24",
                        "content": "class Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        q = nums.count(\"0\")\\n        r = nums.count(\"1\")\\n        s = nums.count(\"2\")\\n        nums.clear()\\n        for i in range(q):\\n            nums.append(\"0\")\\n        for i in range(r):\\n            nums.append(\"1\")\\n        for i in range(s):\\n            nums.append(\"2\")\\n        return nums\\n\\n\\nwhy isnt it working?"
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Problem should really be rated easy. No difficult algorithmic trick to memorize here, just think about the problem for a moment."
                    }
                ]
            },
            {
                "id": 1691806,
                "content": [
                    {
                        "username": "Anonymous_user_79",
                        "content": "Dutch National Flag Algo:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,r=nums.size()-1;\\n        while(j<=r)\\n        {\\n            switch(nums[j])\\n            {\\n                case 0: swap(nums[i++],nums[j++]);\\n                        break;\\n                case 1: j++;\\n                        break;\\n                case 2: swap(nums[j],nums[r--]);\\n                        break;                \\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Counting Sort CPP Solution:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int c1=0,c2=0,c3=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                  c1++;\\n            else if(nums[i]==1)\\n                  c2++;\\n            else \\n                  c3++;            \\n        } \\n        int j=0;\\n        for(;j<c1;j++)\\n        {\\n            nums[j]=0;\\n        }\\n        for(;j<c2+c1;j++)\\n        {\\n            nums[j]=1;\\n        }\\n        for(;j<c1+c2+c3;j++)\\n        {\\n            nums[j]=2;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Harshal-Tupe",
                        "content": "\n// C++ Solution  \nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n             int zero = 0;\n             int one = 0;\n             int two = 0;\n        int s = nums.size();\n        vector<int> ans;\n        for(int i = 0; i<s; i++){\n            if(nums[i] == 0){\n                zero++;\n            }\n            if(nums[i] == 1){\n                one++;\n            }\n            if(nums[i] == 2){\n                two++;\n            }\n        }\n        nums.clear();\n        for(int i = 0; i<zero; i++){\n            nums.push_back(0);\n        }\n         for(int i = zero; i<zero+one; i++){\n            nums.push_back(1);\n        }\n         for(int i = zero+one; i<s; i++){\n            nums.push_back(2);\n        } \n    }\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "bekki3",
                        "content": "Best way is to use QuickSort. "
                    },
                    {
                        "username": "gargie20",
                        "content": "Can we solve this question using Arrays.sort(arr) ??"
                    },
                    {
                        "username": "gargie20",
                        "content": "[@yashodint](/yashodint) okay. Thanks \\n"
                    },
                    {
                        "username": "yashodint",
                        "content": "Yes, you can. but you need to solve the problem in O(n) T.C. Arrays.sort() has O(nlogn) T.C."
                    },
                    {
                        "username": "Mridulcse",
                        "content": "https://www.youtube.com/watch?v=9pdkbqGwUhs\\nsee this video,you will understand it better.\\n\\n `public void sortColors(int[] nums) {\\n        int start = 0;\\n        int mid = 0;\\n        int high = nums.length-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n            {\\n                int temp = nums[mid];\\n                nums[mid] = nums[start];\\n                nums[start] = temp;\\n                start++;\\n                mid++;\\n            }else if(nums[mid] == 1)\\n            {\\n                mid++;\\n            }else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--; \\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  3 DIFFERENT APPROACHES | UBER SDE-1 INTERVIEW\n\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "Pranay_24",
                        "content": "class Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        q = nums.count(\"0\")\\n        r = nums.count(\"1\")\\n        s = nums.count(\"2\")\\n        nums.clear()\\n        for i in range(q):\\n            nums.append(\"0\")\\n        for i in range(r):\\n            nums.append(\"1\")\\n        for i in range(s):\\n            nums.append(\"2\")\\n        return nums\\n\\n\\nwhy isnt it working?"
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Problem should really be rated easy. No difficult algorithmic trick to memorize here, just think about the problem for a moment."
                    }
                ]
            },
            {
                "id": 1687277,
                "content": [
                    {
                        "username": "Anonymous_user_79",
                        "content": "Dutch National Flag Algo:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,r=nums.size()-1;\\n        while(j<=r)\\n        {\\n            switch(nums[j])\\n            {\\n                case 0: swap(nums[i++],nums[j++]);\\n                        break;\\n                case 1: j++;\\n                        break;\\n                case 2: swap(nums[j],nums[r--]);\\n                        break;                \\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Counting Sort CPP Solution:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int c1=0,c2=0,c3=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                  c1++;\\n            else if(nums[i]==1)\\n                  c2++;\\n            else \\n                  c3++;            \\n        } \\n        int j=0;\\n        for(;j<c1;j++)\\n        {\\n            nums[j]=0;\\n        }\\n        for(;j<c2+c1;j++)\\n        {\\n            nums[j]=1;\\n        }\\n        for(;j<c1+c2+c3;j++)\\n        {\\n            nums[j]=2;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Harshal-Tupe",
                        "content": "\n// C++ Solution  \nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n             int zero = 0;\n             int one = 0;\n             int two = 0;\n        int s = nums.size();\n        vector<int> ans;\n        for(int i = 0; i<s; i++){\n            if(nums[i] == 0){\n                zero++;\n            }\n            if(nums[i] == 1){\n                one++;\n            }\n            if(nums[i] == 2){\n                two++;\n            }\n        }\n        nums.clear();\n        for(int i = 0; i<zero; i++){\n            nums.push_back(0);\n        }\n         for(int i = zero; i<zero+one; i++){\n            nums.push_back(1);\n        }\n         for(int i = zero+one; i<s; i++){\n            nums.push_back(2);\n        } \n    }\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "bekki3",
                        "content": "Best way is to use QuickSort. "
                    },
                    {
                        "username": "gargie20",
                        "content": "Can we solve this question using Arrays.sort(arr) ??"
                    },
                    {
                        "username": "gargie20",
                        "content": "[@yashodint](/yashodint) okay. Thanks \\n"
                    },
                    {
                        "username": "yashodint",
                        "content": "Yes, you can. but you need to solve the problem in O(n) T.C. Arrays.sort() has O(nlogn) T.C."
                    },
                    {
                        "username": "Mridulcse",
                        "content": "https://www.youtube.com/watch?v=9pdkbqGwUhs\\nsee this video,you will understand it better.\\n\\n `public void sortColors(int[] nums) {\\n        int start = 0;\\n        int mid = 0;\\n        int high = nums.length-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n            {\\n                int temp = nums[mid];\\n                nums[mid] = nums[start];\\n                nums[start] = temp;\\n                start++;\\n                mid++;\\n            }else if(nums[mid] == 1)\\n            {\\n                mid++;\\n            }else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--; \\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  3 DIFFERENT APPROACHES | UBER SDE-1 INTERVIEW\n\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "Pranay_24",
                        "content": "class Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        q = nums.count(\"0\")\\n        r = nums.count(\"1\")\\n        s = nums.count(\"2\")\\n        nums.clear()\\n        for i in range(q):\\n            nums.append(\"0\")\\n        for i in range(r):\\n            nums.append(\"1\")\\n        for i in range(s):\\n            nums.append(\"2\")\\n        return nums\\n\\n\\nwhy isnt it working?"
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Problem should really be rated easy. No difficult algorithmic trick to memorize here, just think about the problem for a moment."
                    }
                ]
            },
            {
                "id": 1682935,
                "content": [
                    {
                        "username": "Anonymous_user_79",
                        "content": "Dutch National Flag Algo:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,r=nums.size()-1;\\n        while(j<=r)\\n        {\\n            switch(nums[j])\\n            {\\n                case 0: swap(nums[i++],nums[j++]);\\n                        break;\\n                case 1: j++;\\n                        break;\\n                case 2: swap(nums[j],nums[r--]);\\n                        break;                \\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Counting Sort CPP Solution:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int c1=0,c2=0,c3=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                  c1++;\\n            else if(nums[i]==1)\\n                  c2++;\\n            else \\n                  c3++;            \\n        } \\n        int j=0;\\n        for(;j<c1;j++)\\n        {\\n            nums[j]=0;\\n        }\\n        for(;j<c2+c1;j++)\\n        {\\n            nums[j]=1;\\n        }\\n        for(;j<c1+c2+c3;j++)\\n        {\\n            nums[j]=2;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Harshal-Tupe",
                        "content": "\n// C++ Solution  \nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n             int zero = 0;\n             int one = 0;\n             int two = 0;\n        int s = nums.size();\n        vector<int> ans;\n        for(int i = 0; i<s; i++){\n            if(nums[i] == 0){\n                zero++;\n            }\n            if(nums[i] == 1){\n                one++;\n            }\n            if(nums[i] == 2){\n                two++;\n            }\n        }\n        nums.clear();\n        for(int i = 0; i<zero; i++){\n            nums.push_back(0);\n        }\n         for(int i = zero; i<zero+one; i++){\n            nums.push_back(1);\n        }\n         for(int i = zero+one; i<s; i++){\n            nums.push_back(2);\n        } \n    }\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "bekki3",
                        "content": "Best way is to use QuickSort. "
                    },
                    {
                        "username": "gargie20",
                        "content": "Can we solve this question using Arrays.sort(arr) ??"
                    },
                    {
                        "username": "gargie20",
                        "content": "[@yashodint](/yashodint) okay. Thanks \\n"
                    },
                    {
                        "username": "yashodint",
                        "content": "Yes, you can. but you need to solve the problem in O(n) T.C. Arrays.sort() has O(nlogn) T.C."
                    },
                    {
                        "username": "Mridulcse",
                        "content": "https://www.youtube.com/watch?v=9pdkbqGwUhs\\nsee this video,you will understand it better.\\n\\n `public void sortColors(int[] nums) {\\n        int start = 0;\\n        int mid = 0;\\n        int high = nums.length-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n            {\\n                int temp = nums[mid];\\n                nums[mid] = nums[start];\\n                nums[start] = temp;\\n                start++;\\n                mid++;\\n            }else if(nums[mid] == 1)\\n            {\\n                mid++;\\n            }else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--; \\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  3 DIFFERENT APPROACHES | UBER SDE-1 INTERVIEW\n\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "Pranay_24",
                        "content": "class Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        q = nums.count(\"0\")\\n        r = nums.count(\"1\")\\n        s = nums.count(\"2\")\\n        nums.clear()\\n        for i in range(q):\\n            nums.append(\"0\")\\n        for i in range(r):\\n            nums.append(\"1\")\\n        for i in range(s):\\n            nums.append(\"2\")\\n        return nums\\n\\n\\nwhy isnt it working?"
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Problem should really be rated easy. No difficult algorithmic trick to memorize here, just think about the problem for a moment."
                    }
                ]
            },
            {
                "id": 1678850,
                "content": [
                    {
                        "username": "Anonymous_user_79",
                        "content": "Dutch National Flag Algo:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,r=nums.size()-1;\\n        while(j<=r)\\n        {\\n            switch(nums[j])\\n            {\\n                case 0: swap(nums[i++],nums[j++]);\\n                        break;\\n                case 1: j++;\\n                        break;\\n                case 2: swap(nums[j],nums[r--]);\\n                        break;                \\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Counting Sort CPP Solution:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int c1=0,c2=0,c3=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                  c1++;\\n            else if(nums[i]==1)\\n                  c2++;\\n            else \\n                  c3++;            \\n        } \\n        int j=0;\\n        for(;j<c1;j++)\\n        {\\n            nums[j]=0;\\n        }\\n        for(;j<c2+c1;j++)\\n        {\\n            nums[j]=1;\\n        }\\n        for(;j<c1+c2+c3;j++)\\n        {\\n            nums[j]=2;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Harshal-Tupe",
                        "content": "\n// C++ Solution  \nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n             int zero = 0;\n             int one = 0;\n             int two = 0;\n        int s = nums.size();\n        vector<int> ans;\n        for(int i = 0; i<s; i++){\n            if(nums[i] == 0){\n                zero++;\n            }\n            if(nums[i] == 1){\n                one++;\n            }\n            if(nums[i] == 2){\n                two++;\n            }\n        }\n        nums.clear();\n        for(int i = 0; i<zero; i++){\n            nums.push_back(0);\n        }\n         for(int i = zero; i<zero+one; i++){\n            nums.push_back(1);\n        }\n         for(int i = zero+one; i<s; i++){\n            nums.push_back(2);\n        } \n    }\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "bekki3",
                        "content": "Best way is to use QuickSort. "
                    },
                    {
                        "username": "gargie20",
                        "content": "Can we solve this question using Arrays.sort(arr) ??"
                    },
                    {
                        "username": "gargie20",
                        "content": "[@yashodint](/yashodint) okay. Thanks \\n"
                    },
                    {
                        "username": "yashodint",
                        "content": "Yes, you can. but you need to solve the problem in O(n) T.C. Arrays.sort() has O(nlogn) T.C."
                    },
                    {
                        "username": "Mridulcse",
                        "content": "https://www.youtube.com/watch?v=9pdkbqGwUhs\\nsee this video,you will understand it better.\\n\\n `public void sortColors(int[] nums) {\\n        int start = 0;\\n        int mid = 0;\\n        int high = nums.length-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n            {\\n                int temp = nums[mid];\\n                nums[mid] = nums[start];\\n                nums[start] = temp;\\n                start++;\\n                mid++;\\n            }else if(nums[mid] == 1)\\n            {\\n                mid++;\\n            }else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--; \\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  3 DIFFERENT APPROACHES | UBER SDE-1 INTERVIEW\n\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "Pranay_24",
                        "content": "class Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        q = nums.count(\"0\")\\n        r = nums.count(\"1\")\\n        s = nums.count(\"2\")\\n        nums.clear()\\n        for i in range(q):\\n            nums.append(\"0\")\\n        for i in range(r):\\n            nums.append(\"1\")\\n        for i in range(s):\\n            nums.append(\"2\")\\n        return nums\\n\\n\\nwhy isnt it working?"
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Problem should really be rated easy. No difficult algorithmic trick to memorize here, just think about the problem for a moment."
                    }
                ]
            },
            {
                "id": 1676308,
                "content": [
                    {
                        "username": "Anonymous_user_79",
                        "content": "Dutch National Flag Algo:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,r=nums.size()-1;\\n        while(j<=r)\\n        {\\n            switch(nums[j])\\n            {\\n                case 0: swap(nums[i++],nums[j++]);\\n                        break;\\n                case 1: j++;\\n                        break;\\n                case 2: swap(nums[j],nums[r--]);\\n                        break;                \\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Counting Sort CPP Solution:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int c1=0,c2=0,c3=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                  c1++;\\n            else if(nums[i]==1)\\n                  c2++;\\n            else \\n                  c3++;            \\n        } \\n        int j=0;\\n        for(;j<c1;j++)\\n        {\\n            nums[j]=0;\\n        }\\n        for(;j<c2+c1;j++)\\n        {\\n            nums[j]=1;\\n        }\\n        for(;j<c1+c2+c3;j++)\\n        {\\n            nums[j]=2;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Harshal-Tupe",
                        "content": "\n// C++ Solution  \nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n             int zero = 0;\n             int one = 0;\n             int two = 0;\n        int s = nums.size();\n        vector<int> ans;\n        for(int i = 0; i<s; i++){\n            if(nums[i] == 0){\n                zero++;\n            }\n            if(nums[i] == 1){\n                one++;\n            }\n            if(nums[i] == 2){\n                two++;\n            }\n        }\n        nums.clear();\n        for(int i = 0; i<zero; i++){\n            nums.push_back(0);\n        }\n         for(int i = zero; i<zero+one; i++){\n            nums.push_back(1);\n        }\n         for(int i = zero+one; i<s; i++){\n            nums.push_back(2);\n        } \n    }\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "bekki3",
                        "content": "Best way is to use QuickSort. "
                    },
                    {
                        "username": "gargie20",
                        "content": "Can we solve this question using Arrays.sort(arr) ??"
                    },
                    {
                        "username": "gargie20",
                        "content": "[@yashodint](/yashodint) okay. Thanks \\n"
                    },
                    {
                        "username": "yashodint",
                        "content": "Yes, you can. but you need to solve the problem in O(n) T.C. Arrays.sort() has O(nlogn) T.C."
                    },
                    {
                        "username": "Mridulcse",
                        "content": "https://www.youtube.com/watch?v=9pdkbqGwUhs\\nsee this video,you will understand it better.\\n\\n `public void sortColors(int[] nums) {\\n        int start = 0;\\n        int mid = 0;\\n        int high = nums.length-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n            {\\n                int temp = nums[mid];\\n                nums[mid] = nums[start];\\n                nums[start] = temp;\\n                start++;\\n                mid++;\\n            }else if(nums[mid] == 1)\\n            {\\n                mid++;\\n            }else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--; \\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  3 DIFFERENT APPROACHES | UBER SDE-1 INTERVIEW\n\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "Pranay_24",
                        "content": "class Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        q = nums.count(\"0\")\\n        r = nums.count(\"1\")\\n        s = nums.count(\"2\")\\n        nums.clear()\\n        for i in range(q):\\n            nums.append(\"0\")\\n        for i in range(r):\\n            nums.append(\"1\")\\n        for i in range(s):\\n            nums.append(\"2\")\\n        return nums\\n\\n\\nwhy isnt it working?"
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Problem should really be rated easy. No difficult algorithmic trick to memorize here, just think about the problem for a moment."
                    }
                ]
            },
            {
                "id": 1671629,
                "content": [
                    {
                        "username": "Anonymous_user_79",
                        "content": "Dutch National Flag Algo:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,r=nums.size()-1;\\n        while(j<=r)\\n        {\\n            switch(nums[j])\\n            {\\n                case 0: swap(nums[i++],nums[j++]);\\n                        break;\\n                case 1: j++;\\n                        break;\\n                case 2: swap(nums[j],nums[r--]);\\n                        break;                \\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Counting Sort CPP Solution:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int c1=0,c2=0,c3=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                  c1++;\\n            else if(nums[i]==1)\\n                  c2++;\\n            else \\n                  c3++;            \\n        } \\n        int j=0;\\n        for(;j<c1;j++)\\n        {\\n            nums[j]=0;\\n        }\\n        for(;j<c2+c1;j++)\\n        {\\n            nums[j]=1;\\n        }\\n        for(;j<c1+c2+c3;j++)\\n        {\\n            nums[j]=2;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Harshal-Tupe",
                        "content": "\n// C++ Solution  \nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n             int zero = 0;\n             int one = 0;\n             int two = 0;\n        int s = nums.size();\n        vector<int> ans;\n        for(int i = 0; i<s; i++){\n            if(nums[i] == 0){\n                zero++;\n            }\n            if(nums[i] == 1){\n                one++;\n            }\n            if(nums[i] == 2){\n                two++;\n            }\n        }\n        nums.clear();\n        for(int i = 0; i<zero; i++){\n            nums.push_back(0);\n        }\n         for(int i = zero; i<zero+one; i++){\n            nums.push_back(1);\n        }\n         for(int i = zero+one; i<s; i++){\n            nums.push_back(2);\n        } \n    }\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "bekki3",
                        "content": "Best way is to use QuickSort. "
                    },
                    {
                        "username": "gargie20",
                        "content": "Can we solve this question using Arrays.sort(arr) ??"
                    },
                    {
                        "username": "gargie20",
                        "content": "[@yashodint](/yashodint) okay. Thanks \\n"
                    },
                    {
                        "username": "yashodint",
                        "content": "Yes, you can. but you need to solve the problem in O(n) T.C. Arrays.sort() has O(nlogn) T.C."
                    },
                    {
                        "username": "Mridulcse",
                        "content": "https://www.youtube.com/watch?v=9pdkbqGwUhs\\nsee this video,you will understand it better.\\n\\n `public void sortColors(int[] nums) {\\n        int start = 0;\\n        int mid = 0;\\n        int high = nums.length-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n            {\\n                int temp = nums[mid];\\n                nums[mid] = nums[start];\\n                nums[start] = temp;\\n                start++;\\n                mid++;\\n            }else if(nums[mid] == 1)\\n            {\\n                mid++;\\n            }else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--; \\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  3 DIFFERENT APPROACHES | UBER SDE-1 INTERVIEW\n\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "Pranay_24",
                        "content": "class Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        q = nums.count(\"0\")\\n        r = nums.count(\"1\")\\n        s = nums.count(\"2\")\\n        nums.clear()\\n        for i in range(q):\\n            nums.append(\"0\")\\n        for i in range(r):\\n            nums.append(\"1\")\\n        for i in range(s):\\n            nums.append(\"2\")\\n        return nums\\n\\n\\nwhy isnt it working?"
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Problem should really be rated easy. No difficult algorithmic trick to memorize here, just think about the problem for a moment."
                    }
                ]
            },
            {
                "id": 1664998,
                "content": [
                    {
                        "username": "Anonymous_user_79",
                        "content": "Dutch National Flag Algo:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,r=nums.size()-1;\\n        while(j<=r)\\n        {\\n            switch(nums[j])\\n            {\\n                case 0: swap(nums[i++],nums[j++]);\\n                        break;\\n                case 1: j++;\\n                        break;\\n                case 2: swap(nums[j],nums[r--]);\\n                        break;                \\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Counting Sort CPP Solution:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int c1=0,c2=0,c3=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                  c1++;\\n            else if(nums[i]==1)\\n                  c2++;\\n            else \\n                  c3++;            \\n        } \\n        int j=0;\\n        for(;j<c1;j++)\\n        {\\n            nums[j]=0;\\n        }\\n        for(;j<c2+c1;j++)\\n        {\\n            nums[j]=1;\\n        }\\n        for(;j<c1+c2+c3;j++)\\n        {\\n            nums[j]=2;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Harshal-Tupe",
                        "content": "\n// C++ Solution  \nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n             int zero = 0;\n             int one = 0;\n             int two = 0;\n        int s = nums.size();\n        vector<int> ans;\n        for(int i = 0; i<s; i++){\n            if(nums[i] == 0){\n                zero++;\n            }\n            if(nums[i] == 1){\n                one++;\n            }\n            if(nums[i] == 2){\n                two++;\n            }\n        }\n        nums.clear();\n        for(int i = 0; i<zero; i++){\n            nums.push_back(0);\n        }\n         for(int i = zero; i<zero+one; i++){\n            nums.push_back(1);\n        }\n         for(int i = zero+one; i<s; i++){\n            nums.push_back(2);\n        } \n    }\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "bekki3",
                        "content": "Best way is to use QuickSort. "
                    },
                    {
                        "username": "gargie20",
                        "content": "Can we solve this question using Arrays.sort(arr) ??"
                    },
                    {
                        "username": "gargie20",
                        "content": "[@yashodint](/yashodint) okay. Thanks \\n"
                    },
                    {
                        "username": "yashodint",
                        "content": "Yes, you can. but you need to solve the problem in O(n) T.C. Arrays.sort() has O(nlogn) T.C."
                    },
                    {
                        "username": "Mridulcse",
                        "content": "https://www.youtube.com/watch?v=9pdkbqGwUhs\\nsee this video,you will understand it better.\\n\\n `public void sortColors(int[] nums) {\\n        int start = 0;\\n        int mid = 0;\\n        int high = nums.length-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n            {\\n                int temp = nums[mid];\\n                nums[mid] = nums[start];\\n                nums[start] = temp;\\n                start++;\\n                mid++;\\n            }else if(nums[mid] == 1)\\n            {\\n                mid++;\\n            }else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--; \\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  3 DIFFERENT APPROACHES | UBER SDE-1 INTERVIEW\n\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "Pranay_24",
                        "content": "class Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        q = nums.count(\"0\")\\n        r = nums.count(\"1\")\\n        s = nums.count(\"2\")\\n        nums.clear()\\n        for i in range(q):\\n            nums.append(\"0\")\\n        for i in range(r):\\n            nums.append(\"1\")\\n        for i in range(s):\\n            nums.append(\"2\")\\n        return nums\\n\\n\\nwhy isnt it working?"
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Problem should really be rated easy. No difficult algorithmic trick to memorize here, just think about the problem for a moment."
                    }
                ]
            },
            {
                "id": 1657802,
                "content": [
                    {
                        "username": "Anonymous_user_79",
                        "content": "Dutch National Flag Algo:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int i=0,j=0,r=nums.size()-1;\\n        while(j<=r)\\n        {\\n            switch(nums[j])\\n            {\\n                case 0: swap(nums[i++],nums[j++]);\\n                        break;\\n                case 1: j++;\\n                        break;\\n                case 2: swap(nums[j],nums[r--]);\\n                        break;                \\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Counting Sort CPP Solution:\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int n = nums.size();\\n        int c1=0,c2=0,c3=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                  c1++;\\n            else if(nums[i]==1)\\n                  c2++;\\n            else \\n                  c3++;            \\n        } \\n        int j=0;\\n        for(;j<c1;j++)\\n        {\\n            nums[j]=0;\\n        }\\n        for(;j<c2+c1;j++)\\n        {\\n            nums[j]=1;\\n        }\\n        for(;j<c1+c2+c3;j++)\\n        {\\n            nums[j]=2;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "Harshal-Tupe",
                        "content": "\n// C++ Solution  \nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n             int zero = 0;\n             int one = 0;\n             int two = 0;\n        int s = nums.size();\n        vector<int> ans;\n        for(int i = 0; i<s; i++){\n            if(nums[i] == 0){\n                zero++;\n            }\n            if(nums[i] == 1){\n                one++;\n            }\n            if(nums[i] == 2){\n                two++;\n            }\n        }\n        nums.clear();\n        for(int i = 0; i<zero; i++){\n            nums.push_back(0);\n        }\n         for(int i = zero; i<zero+one; i++){\n            nums.push_back(1);\n        }\n         for(int i = zero+one; i<s; i++){\n            nums.push_back(2);\n        } \n    }\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 3 DIFFERENT APPROACHES | UBER\\uD83D\\uDE97 SDE-1 INTERVIEW\\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "bekki3",
                        "content": "Best way is to use QuickSort. "
                    },
                    {
                        "username": "gargie20",
                        "content": "Can we solve this question using Arrays.sort(arr) ??"
                    },
                    {
                        "username": "gargie20",
                        "content": "[@yashodint](/yashodint) okay. Thanks \\n"
                    },
                    {
                        "username": "yashodint",
                        "content": "Yes, you can. but you need to solve the problem in O(n) T.C. Arrays.sort() has O(nlogn) T.C."
                    },
                    {
                        "username": "Mridulcse",
                        "content": "https://www.youtube.com/watch?v=9pdkbqGwUhs\\nsee this video,you will understand it better.\\n\\n `public void sortColors(int[] nums) {\\n        int start = 0;\\n        int mid = 0;\\n        int high = nums.length-1;\\n\\n        while(mid<=high)\\n        {\\n            if(nums[mid] == 0)\\n            {\\n                int temp = nums[mid];\\n                nums[mid] = nums[start];\\n                nums[start] = temp;\\n                start++;\\n                mid++;\\n            }else if(nums[mid] == 1)\\n            {\\n                mid++;\\n            }else{\\n                int temp = nums[mid];\\n                nums[mid] = nums[high];\\n                nums[high] = temp;\\n                high--; \\n            }\\n        }\\n    }`"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "#  3 DIFFERENT APPROACHES | UBER SDE-1 INTERVIEW\n\nhttps://leetcode.com/problems/sort-colors/solutions/2358550/3-different-approaches-uber-sde-1-interview/"
                    },
                    {
                        "username": "Pranay_24",
                        "content": "class Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        q = nums.count(\"0\")\\n        r = nums.count(\"1\")\\n        s = nums.count(\"2\")\\n        nums.clear()\\n        for i in range(q):\\n            nums.append(\"0\")\\n        for i in range(r):\\n            nums.append(\"1\")\\n        for i in range(s):\\n            nums.append(\"2\")\\n        return nums\\n\\n\\nwhy isnt it working?"
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Problem should really be rated easy. No difficult algorithmic trick to memorize here, just think about the problem for a moment."
                    }
                ]
            }
        ]
    },
    {
        "title": "Combine Two Tables",
        "question_content": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| personId    | int     |\n| lastName    | varchar |\n| firstName   | varchar |\n+-------------+---------+\npersonId is the primary key (column with unique values) for this table.\nThis table contains information about the ID of some persons and their first and last names.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Address</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| addressId   | int     |\n| personId    | int     |\n| city        | varchar |\n| state       | varchar |\n+-------------+---------+\naddressId is the primary key (column with unique values) for this table.\nEach row of this table contains information about the city and state of one person with ID = PersonId.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the first name, last name, city, and state of each person in the <code>Person</code> table. If the address of a <code>personId</code> is not present in the <code>Address</code> table, report <code>null</code> instead.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----------+----------+-----------+\n| personId | lastName | firstName |\n+----------+----------+-----------+\n| 1        | Wang     | Allen     |\n| 2        | Alice    | Bob       |\n+----------+----------+-----------+\nAddress table:\n+-----------+----------+---------------+------------+\n| addressId | personId | city          | state      |\n+-----------+----------+---------------+------------+\n| 1         | 2        | New York City | New York   |\n| 2         | 3        | Leetcode      | California |\n+-----------+----------+---------------+------------+\n<strong>Output:</strong> \n+-----------+----------+---------------+----------+\n| firstName | lastName | city          | state    |\n+-----------+----------+---------------+----------+\n| Allen     | Wang     | Null          | Null     |\n| Bob       | Alice    | New York City | New York |\n+-----------+----------+---------------+----------+\n<strong>Explanation:</strong> \nThere is no address in the address table for the personId = 1 so we return null in their city and state.\naddressId = 1 contains information about the address of personId = 2.\n</pre>\n",
        "solutions": [
            {
                "id": 2593063,
                "title": "2-ways-to-write-the-same-query-using-left-join-easy-explanation",
                "content": "### **Explanation:**\\nThe questuion asks us to report the first name, last name, city, and state of each person in the Person table. If the address of a personId is not present in the Address table, report null instead.\\n\\nLEFT JOIN works here since it exactly does the same. It returns all the records from the 1st table and the corresponding information from the 2nd table. If there\\'s no matching data in the 2nd table, it returns NULL for those fields.\\n\\nNow the same query can be written in 2 ways. Here they are :\\n\\n#### **1st way (table1 LEFT JOIN table2 ON condition)**\\n```\\nSELECT P.firstName, P.lastName, A.city, A.state\\nFROM Person P LEFT JOIN Address A\\non P.personId = A.personId\\n```\\n\\n#### **2nd way (table1 LEFT JOIN table2 USING column_name)**\\n```\\nSELECT P.firstName, P.lastName, A.city, A.state\\nFROM Person P\\nLEFT JOIN Address A USING (personId)\\n```\\n\\nIf it helped or you learned a new way, kindly upvote. Thanks :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT P.firstName, P.lastName, A.city, A.state\\nFROM Person P LEFT JOIN Address A\\non P.personId = A.personId\\n```\n```\\nSELECT P.firstName, P.lastName, A.city, A.state\\nFROM Person P\\nLEFT JOIN Address A USING (personId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52928,
                "title": "its-a-simple-question-of-left-join-my-solution-attached",
                "content": "    SELECT Person.FirstName, Person.LastName, Address.City, Address.State from Person LEFT JOIN Address on Person.PersonId = Address.PersonId;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    SELECT Person.FirstName, Person.LastName, Address.City, Address.State from Person LEFT JOIN Address on Person.PersonId = Address.PersonId;",
                "codeTag": "Unknown"
            },
            {
                "id": 2498322,
                "title": "two-methods-by-join-and-union",
                "content": "*\\uD83D\\uDE0ADO UPVOTE IF YOU FIND HELPFUL \\uD83D\\uDE0A*\\n\\n**METHOD -> JOIN**\\n```\\nSELECT p.firstName, p.lastName, a.city, a.state \\nFROM Person p left join Address a\\nON p.personId = a.personId;\\n```\\n**METHOD2 -> UNION**\\n```\\nSELECT p.firstName, p.lastName, a.city, a.state from Person p, Address a\\nWHERE p.personId = a.personId\\nUNION\\nSELECT  p.firstName, p.lastName, null, null from Person p\\nWHERE p.personId NOT IN (Select personId from Address);\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\nSELECT p.firstName, p.lastName, a.city, a.state \\nFROM Person p left join Address a\\nON p.personId = a.personId;\\n```\n```\\nSELECT p.firstName, p.lastName, a.city, a.state from Person p, Address a\\nWHERE p.personId = a.personId\\nUNION\\nSELECT  p.firstName, p.lastName, null, null from Person p\\nWHERE p.personId NOT IN (Select personId from Address);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1757541,
                "title": "simple-2-lines-with-explanation-you-ll-love-it-guaranteed",
                "content": "Here we have to use Outer Joins in order to get expected results. because we want every row from Person( which is we are specifying first using SELECT statement.) table so we are using LEFT JOIN on contrary if we wanted every row from address table we would have used RIGHT JOIN. I hope you have understood.\\n\\nHow to remember what is left, what is right?\\n-Simple\\nWhatever you are accessing first = LEFT -----  1 = LEFT\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2 = RIGHT\\n\\n```\\nSELECT p.firstName, p.lastName, a.city, a.state FROM Person p  --accessing first hench LEFT\\nLEFT JOIN Address a USING (personId) -- accessing second hence RIGHT. but we want every row in person so LEFT JOIN.\\n```\\n\\nIf you Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT p.firstName, p.lastName, a.city, a.state FROM Person p  --accessing first hench LEFT\\nLEFT JOIN Address a USING (personId) -- accessing second hence RIGHT. but we want every row in person so LEFT JOIN.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52930,
                "title": "comparative-solution-between-left-join-left-join-using-and-natural-left-join",
                "content": "basic left join: 902ms.\\n\\n    SELECT FirstName, LastName, City, State\\n    FROM Person\\n    LEFT JOIN Address\\n    ON Person.PersonId = Address.PersonId;\\n\\nleft join + using: 907ms\\n\\n    SELECT FirstName, LastName, City, State\\n    FROM Person\\n    LEFT JOIN Address\\n    USING(PersonId);\\n\\nnatural left join: 940ms\\n\\n    SELECT FirstName, LastName, City, State\\n    FROM Person\\n    NATURAL LEFT JOIN Address;\\n\\nleft join is the fastest compare to the two others.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "basic left join: 902ms.\\n\\n    SELECT FirstName, LastName, City, State\\n    FROM Person\\n    LEFT JOIN Address\\n    ON Person.PersonId = Address.PersonId;\\n\\nleft join + using: 907ms\\n\\n    SELECT FirstName, LastName, City, State\\n    FROM Person\\n    LEFT JOIN Address\\n    USING(PersonId);\\n\\nnatural left join: 940ms\\n\\n    SELECT FirstName, LastName, City, State\\n    FROM Person\\n    NATURAL LEFT JOIN Address;\\n\\nleft join is the fastest compare to the two others.",
                "codeTag": "Unknown"
            },
            {
                "id": 52931,
                "title": "why-cannot-using-where",
                "content": "    select p.FirstName, p.LastName, a.City, a. State\\n    from Person p, Address a \\n    where p.PersonId = a.PersonId;\\n\\ndidnt using sql for two years, might be a stupid question",
                "solutionTags": [],
                "code": "    select p.FirstName, p.LastName, a.City, a. State\\n    from Person p, Address a \\n    where p.PersonId = a.PersonId;\\n\\ndidnt using sql for two years, might be a stupid question",
                "codeTag": "Unknown"
            },
            {
                "id": 3823934,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT p.firstName,\\n       p.lastName,\\n       a.city,\\n       a.state \\nfrom Person p left outer join Address a \\non p.personId=a.personId;\\n```\\nIF THIS WILL BE HELPFUL TO YOU PLEASE UPVOTE \\u2705![5kej8w.jpg](https://assets.leetcode.com/users/images/f1e6cb67-cf9a-4ee0-be9d-f1a685709e13_1690464424.995609.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT p.firstName,\\n       p.lastName,\\n       a.city,\\n       a.state \\nfrom Person p left outer join Address a \\non p.personId=a.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542837,
                "title": "easy-approach-left-join-using-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMain focus of posting this solution to make you all aware of **USING()** function is SQL and how you use it make your code easier to understand.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n###### We will follow approaches of inner join in this: \\n\\nAt first we will get the required columns (attributes) from the tables then we will join them by using `LEFT JOIN` i.e.\\n\\n```\\nselect p.firstName , p.lastName, a.city , a.state \\n    from Person p LEFT JOIN Address a ........\\n``` \\n\\nThen the main thing comes what I am going to teach you guys\\n    \\n**Approach 1:**  Using conventional method by making equal both the attributes of the table to join them \\ni.e.     `on p.personId  = a.personId `\\n\\n**Approach 2:** We can see that both the attributes of the table to compare have same name i.e. personId, so instead of writing it multiple time we will use `USING()` function \\ni.e. `USING(personId)`\\n\\n\\n#### I hope this helps you understand it easily :) \\n\\n\\n# Code\\n\\n**Approach 1:**\\n```\\nselect p.firstName , p.lastName, a.city , a.state \\n    from Person p LEFT JOIN Address a on p.personId  = a.personId  \\n\\n```\\n\\n**Approach 2 :** Try learning this and implementing this in your another questions.\\n```\\nselect p.firstName , p.lastName, a.city , a.state \\n    from Person p LEFT JOIN Address a USING(personId) \\n\\n```\\n\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/faf2f121-376c-4aac-943e-341e41d6c8aa_1684525186.4883614.jpeg)\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\nselect p.firstName , p.lastName, a.city , a.state \\n    from Person p LEFT JOIN Address a ........\\n```\n```\\nselect p.firstName , p.lastName, a.city , a.state \\n    from Person p LEFT JOIN Address a on p.personId  = a.personId  \\n\\n```\n```\\nselect p.firstName , p.lastName, a.city , a.state \\n    from Person p LEFT JOIN Address a USING(personId) \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52932,
                "title": "my-solution-and-question-with-union",
                "content": "Just come up with this idea to do it. Does anyone have any advises to make it better?\\nBy the way, besides using join, does anybody have any idea to do it by using CASE? \\n```\\nSELECT per.FirstName, per.LastName, addr.City, addr.State\\nFROM Person per, Address addr\\nWHERE per.PersonId = addr.PersonId\\nUNION\\nSELECT per.FirstName, per.LastName, NULL as City, NULL as State\\nFROM Person per\\nWHERE per.PersonId NOT IN (SELECT PersonId from Address);\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT per.FirstName, per.LastName, addr.City, addr.State\\nFROM Person per, Address addr\\nWHERE per.PersonId = addr.PersonId\\nUNION\\nSELECT per.FirstName, per.LastName, NULL as City, NULL as State\\nFROM Person per\\nWHERE per.PersonId NOT IN (SELECT PersonId from Address);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276217,
                "title": "mysql-outer-join-with-using",
                "content": "Hello,\\nI just want to share the fact that we can use `USING` instead of `ON`:\\n\\n```\\nSELECT FirstName, LastName, City, State\\nFROM Person LEFT JOIN Address USING (PersonId)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT FirstName, LastName, City, State\\nFROM Person LEFT JOIN Address USING (PersonId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3212884,
                "title": "175-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved using a LEFT JOIN to combine the Person and Address tables based on their common column personId. The query would look like this:\\n```\\nSELECT Person.firstName, Person.lastName, Address.city, Address.state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;\\n\\n```\\nHere, we select the firstName and lastName columns from the Person table, and the city and state columns from the Address table. We use a LEFT JOIN to combine the tables based on their personId columns. If a personId in the Person table doesn\\'t have a corresponding entry in the Address table, the city and state columns will be NULL. We then return the resulting table.\\n\\nThis query should produce the desired output:\\n```\\n+-----------+----------+---------------+----------+\\n| firstName | lastName | city          | state    |\\n+-----------+----------+---------------+----------+\\n| Allen     | Wang     | NULL          | NULL     |\\n| Bob       | Alice    | New York City | New York |\\n+-----------+----------+---------------+----------+\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT Person.firstName, Person.lastName, Address.city, Address.state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT Person.firstName, Person.lastName, Address.city, Address.state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;\\n\\n```\n```\\n+-----------+----------+---------------+----------+\\n| firstName | lastName | city          | state    |\\n+-----------+----------+---------------+----------+\\n| Allen     | Wang     | NULL          | NULL     |\\n| Bob       | Alice    | New York City | New York |\\n+-----------+----------+---------------+----------+\\n\\n```\n```\\nSELECT Person.firstName, Person.lastName, Address.city, Address.state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977552,
                "title": "clean-solution",
                "content": "```\\nSELECT p.firstName,\\n       p.lastName, \\n       a.city, \\n       a.state \\n  FROM Person p \\n  LEFT JOIN Address a ON a.personId = p.personId\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nSELECT p.firstName,\\n       p.lastName, \\n       a.city, \\n       a.state \\n  FROM Person p \\n  LEFT JOIN Address a ON a.personId = p.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2685050,
                "title": "combine-two-tables",
                "content": "```\\nSELECT firstName, lastName, city, state FROM Address\\nRIGHT JOIN Person\\nON Person.personId = Address.personId;\\n// upvote if helpful\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT firstName, lastName, city, state FROM Address\\nRIGHT JOIN Person\\nON Person.personId = Address.personId;\\n// upvote if helpful\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1071262,
                "title": "really-cute-solution",
                "content": "```\\nSELECT Person.FirstName, Person.LastName, Address.City, Address.State\\nFROM Person LEFT JOIN Address\\non Person.PersonId = Address.PersonId",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Person.FirstName, Person.LastName, Address.City, Address.State\\nFROM Person LEFT JOIN Address\\non Person.PersonId = Address.PersonId",
                "codeTag": "Unknown"
            },
            {
                "id": 834462,
                "title": "sql-left-join-simple-solution",
                "content": "```\\nSELECT FirstName, LastName, City, State\\nFROM Person left join Address\\non Person.PersonId = Address.PersonId\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT FirstName, LastName, City, State\\nFROM Person left join Address\\non Person.PersonId = Address.PersonId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2996381,
                "title": "mysql-solution",
                "content": "# Code 1\\n```\\n# Write your MySQL query statement below\\nselect firstName, lastName, city, state \\nfrom Person natural left join Address;\\n```\\n\\n# Code 2\\n```\\n# Write your MySQL query statement below\\nselect firstName, lastName, city, state \\nfrom Person left join Address on Person.personId = Address.personId;\\n```\\n\\n# Code 3\\n```\\n# Write your MySQL query statement below\\nselect firstName, lastName, city, state \\nfrom Person left join Address using(personId);\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect firstName, lastName, city, state \\nfrom Person natural left join Address;\\n```\n```\\n# Write your MySQL query statement below\\nselect firstName, lastName, city, state \\nfrom Person left join Address on Person.personId = Address.personId;\\n```\n```\\n# Write your MySQL query statement below\\nselect firstName, lastName, city, state \\nfrom Person left join Address using(personId);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538730,
                "title": "simple-left-join-solution",
                "content": "```\\nselect FirstName, LastName, City, State\\nfrom Person\\nleft join Address\\non Person.PersonId = Address.PersonId\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect FirstName, LastName, City, State\\nfrom Person\\nleft join Address\\non Person.PersonId = Address.PersonId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955959,
                "title": "easy-solution",
                "content": "**SELECT Clause**: You want to select specific columns from both the Person and Address tables. These columns include firstName and lastName from the Person table, and city and state from the Address table.\\n\\n**FROM Clause**: You start by querying the Person table, denoted as p, and you want to perform a left join operation with the Address table, denoted as a.\\n\\n**LEFT JOIN**: The left join operation ensures that you include all rows from the Person table in the result, even if there\\'s no matching entry in the Address table for a specific person.\\n\\n**ON Clause**: The ON clause defines the condition for joining the two tables. In this case, you join the Person table with the Address table using the personId column as the common attribute. This ensures that you\\'re linking the right person with their corresponding address (if available).\\n\\n**Result**: The result will include all persons from the Person table. For each person, if there is a corresponding address entry in the Address table, the query will fetch the city and state. If there\\'s no corresponding address entry (as indicated by the left join), the city and state values will be NULL.\\n\\n\\nThis way, the query gives you a comprehensive overview of each person\\'s details along with their associated city and state information, or ***NULL*** values if an address is not available for that person.\\n\\nThe key to the correct query is to establish the join between the tables based on the personId column, which is the common identifier between the two tables.\\n\\n\\n\\n# Code\\n```\\nSELECT p.firstName, p.lastName, a.city, a.state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\n\\n \\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT p.firstName, p.lastName, a.city, a.state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\n\\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2665791,
                "title": "mysql-easy-beginner-friendly",
                "content": "```\\n\\n```# Write your MySQL query statement below\\n\\n select p.firstName,p.lastName,a.city,a.state\\n from Person as p left join Address as a\\n on p.personId=a.personId ;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647401,
                "title": "two-approach-join-and-union-easy-to-understand",
                "content": "**METHOD -> JOIN**\\n\\nSELECT P.firstName, P.lastName, A.city, A.state \\nFROM Person P left join Address A\\nON P.personId = A.personId;\\n\\n\\n**METHOD2 -> UNION**\\n\\nSelect P.firstName, P.lastName,  A.city, A.state From Person P, Address A\\n    where P.personId=A.PersonId\\nUnion\\nSelect P.firstName, P.lastName, null, null From  Person P \\n    where p.personId not in (Select personId from Address)\\n",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "**METHOD -> JOIN**\\n\\nSELECT P.firstName, P.lastName, A.city, A.state \\nFROM Person P left join Address A\\nON P.personId = A.personId;\\n\\n\\n**METHOD2 -> UNION**\\n\\nSelect P.firstName, P.lastName,  A.city, A.state From Person P, Address A\\n    where P.personId=A.PersonId\\nUnion\\nSelect P.firstName, P.lastName, null, null From  Person P \\n    where p.personId not in (Select personId from Address)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2067725,
                "title": "easy-and-simple-solution-with-explanation",
                "content": "As we want to display first name, last name, city, and state of **each person** in the Person table. So we use **LEFT JOIN** here. \\n ![image](https://assets.leetcode.com/users/images/18579613-91be-4c19-ae24-c15af1400307_1653331994.4420538.jpeg)\\nThis diagram clears the the all doubt, why we are using **LEFT JOIN** as we want **each** person of person table.\\n```\\n# Write your MySQL query statement below\\nSELECT Person.firstName, Person.lastName, Address.city, Address.state\\n    FROM Person LEFT JOIN Address \\n        ON Person.personId = Address.personId;\\n```\\n\\nRuntime: 403 ms, faster than 51.73% of MySQL online submissions for Combine Two Tables.\\nMemory Usage: 0B, less than **100.00%** of MySQL online submissions for Combine Two Tables.\\n\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Person.firstName, Person.lastName, Address.city, Address.state\\n    FROM Person LEFT JOIN Address \\n        ON Person.personId = Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1728755,
                "title": "mysql-easy-left-join-combine-two-tables",
                "content": "```\\nSELECT person.firstname, person.lastname, address.city, address.state \\nFROM person \\nLEFT OUTER JOIN address \\nON person.personid = address.personid;\\n```\\nPlease **UpVote**, if you understood the problem.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT person.firstname, person.lastname, address.city, address.state \\nFROM person \\nLEFT OUTER JOIN address \\nON person.personid = address.personid;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919364,
                "title": "pandas-absolutely-100-beating-easy-solution",
                "content": "# Intuition\\nI love pandas and its simplicity)\\n# Approach\\nWe use the pandas \"merge\" function and combine two tables based on the left (person) by person IDs, if there is no such ID in the second table, then pandas will put \"Null\" value for us.\\n\\n\\n![Leercode 100% beating.png](https://assets.leetcode.com/users/images/679a1f65-cf2e-475c-95a0-1d8dc3f4fd47_1692209542.424886.png)\\n\\nUpvote please, if you like my solution, thanks <3\\n# Code\\n```\\nimport pandas as pd\\n\\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\\n    return pd.merge(left=person, right=address, how=\\'left\\', on=\\'personId\\')[[\\'firstName\\', \\'lastName\\', \\'city\\', \\'state\\']]\\n```",
                "solutionTags": [
                    "Database",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\\n    return pd.merge(left=person, right=address, how=\\'left\\', on=\\'personId\\')[[\\'firstName\\', \\'lastName\\', \\'city\\', \\'state\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3523677,
                "title": "mysql-solution-for-combine-two-tables-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this SQL query is to retrieve the first name, last name, city, and state of all people in the Person table, along with their corresponding address information from the Address table \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use a LEFT JOIN to join the Person table with the Address table on the PersonId column.\\n2. Select the FirstName, LastName, City, and State columns from the resulting joined table.\\n3. The LEFT JOIN ensures that all rows from the Person table are included in the result, even if there is no corresponding row in the Address table.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this query depends on the size of the Person and Address tables and the efficiency of the database engine\\'s query optimizer. In general, the time complexity of a LEFT JOIN operation is O(m * n), where m is the number of rows in the left table (Person in this case) and n is the number of rows in the right table (Address in this case). However, the query optimizer may be able to optimize the query execution plan to reduce the actual time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this query depends on the size of the result set and the size of the columns being selected. In this case, the result set will have at most as many rows as the Person table, and each row will have four columns (FirstName, LastName, City, and State). Therefore, the space complexity is O(m), where m is the number of rows in the Person table.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect FirstName, LastName, City, State from Person as p left join Address as a on p.PersonId = a.PersonId\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect FirstName, LastName, City, State from Person as p left join Address as a on p.PersonId = a.PersonId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607373,
                "title": "175-combine-two-tables",
                "content": "```\\nSELECT person.firstName, person.lastName, address.city, address.state\\nFROM person\\nLEFT JOIN ADDRESS on address.personID = person.personID\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT person.firstName, person.lastName, address.city, address.state\\nFROM person\\nLEFT JOIN ADDRESS on address.personID = person.personID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420659,
                "title": "mysql-easy-understanding-left-join",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n____________________________________________________________________________________________________________________________\\n\\u2705 **MySQL Code :**\\n```\\nSelect firstName,lastName,city,state\\nFROM Person \\nLEFT JOIN Address\\n    on Person.PersonId=Address.PersonId;\\n\\n```\\n____________________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect firstName,lastName,city,state\\nFROM Person \\nLEFT JOIN Address\\n    on Person.PersonId=Address.PersonId;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 266706,
                "title": "simple-solution",
                "content": "select p.FirstName, p.LastName, a.City,a.State\\nfrom person as p\\nleft join Address as a\\non p.PersonId=a.PersonId;",
                "solutionTags": [],
                "code": "select p.FirstName, p.LastName, a.City,a.State\\nfrom person as p\\nleft join Address as a\\non p.PersonId=a.PersonId;",
                "codeTag": "Unknown"
            },
            {
                "id": 3467379,
                "title": "left-join-and-selecting-columns-to-pull",
                "content": "# Intuition\\nI need to merge both tables and pull four columns.\\n\\n# Approach\\nI pulled the four columns and joined the data tables using a LEFT JOIN.\\n\\n# Complexity\\n- Time complexity:\\nn/a\\n\\n- Space complexity:\\nn/a\\n\\n# Code\\n```\\nSelect Person.firstName,Person.lastName,Address.city,Address.state FROM Person\\nLEFT JOIN Address\\nOn Person.personId = Address.personId\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect Person.firstName,Person.lastName,Address.city,Address.state FROM Person\\nLEFT JOIN Address\\nOn Person.personId = Address.personId\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3303921,
                "title": "sql-server-clean-easy",
                "content": "Here\\'s an SQL query that should solve the problem:\\n\\n```\\nSELECT Person.firstName, Person.lastName, Address.city, Address.state\\nFROM Person LEFT JOIN Address\\nON Person.personId = Address.personId\\n```\\n\\nExplanation:\\n\\nWe perform a LEFT JOIN between the Person and Address tables using the personId column as the join condition. This will ensure that we keep all rows from the Person table, even if there is no corresponding row in the Address table.\\nWe select the firstName and lastName columns from the Person table, and the city and state columns from the Address table.\\nIf there is no corresponding row in the Address table, the values for city and state will be NULL.",
                "solutionTags": [],
                "code": "```\\nSELECT Person.firstName, Person.lastName, Address.city, Address.state\\nFROM Person LEFT JOIN Address\\nON Person.personId = Address.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3277421,
                "title": "mysql",
                "content": "# Please upvote guys!\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect firstName,lastName,city,state\\nfrom Person\\nleft join Address\\non person.personID  = Address.personID\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect firstName,lastName,city,state\\nfrom Person\\nleft join Address\\non person.personID  = Address.personID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3254375,
                "title": "easy-sql-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT p.firstname,p.lastname,a.city,a.state from person p LEFT  OUTER JOIN address  a on p.PersonId=a.PersonId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT p.firstname,p.lastname,a.city,a.state from person p LEFT  OUTER JOIN address  a on p.PersonId=a.PersonId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2873490,
                "title": "mysql-using",
                "content": "\\n# Code\\n```\\nSELECT firstName, lastName, city, state\\nFROM Person\\nLEFT JOIN Address\\nUSING (personId);\\n```\\n# Using clause\\nThere are matching column \\'personID\\' between 2 tables, by applying \\'Using\\' clause may help us spare some time.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT firstName, lastName, city, state\\nFROM Person\\nLEFT JOIN Address\\nUSING (personId);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2616098,
                "title": "ms-sql-left-join-on",
                "content": "```\\nSELECT\\n    firstName,\\n    lastName,\\n    city,\\n    state\\nFROM\\n    Person AS P\\nLEFT JOIN\\n    Address AS A\\nON\\n    P.personId = A.personId\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    firstName,\\n    lastName,\\n    city,\\n    state\\nFROM\\n    Person AS P\\nLEFT JOIN\\n    Address AS A\\nON\\n    P.personId = A.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569947,
                "title": "very-easy-solutions",
                "content": "```\\nselect firstName, lastName, city, state\\nfrom Person\\nleft join Address\\non Person.personId = Address.personId;\\n```",
                "solutionTags": [],
                "code": "```\\nselect firstName, lastName, city, state\\nfrom Person\\nleft join Address\\non Person.personId = Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2519789,
                "title": "175-combine-two-tables",
                "content": "```\\nSELECT person.firstName, person.lastName, address.city, address.state\\nFROM person\\nLEFT JOIN ADDRESS on address.personID = person.personID",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT person.firstName, person.lastName, address.city, address.state\\nFROM person\\nLEFT JOIN ADDRESS on address.personID = person.personID",
                "codeTag": "Unknown"
            },
            {
                "id": 2214137,
                "title": "mysql-left-join",
                "content": "```\\nSELECT P.FIRSTNAME, P.LASTNAME, A.CITY, A.STATE\\nFROM PERSON P LEFT JOIN ADDRESS A\\nON P.PERSONID = A.PERSONID\\n\\n```\\nPLEASE **UPVOTE**.",
                "solutionTags": [],
                "code": "```\\nSELECT P.FIRSTNAME, P.LASTNAME, A.CITY, A.STATE\\nFROM PERSON P LEFT JOIN ADDRESS A\\nON P.PERSONID = A.PERSONID\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2102871,
                "title": "sql-easy-sol",
                "content": "```\\n# Write your MySQL query statement below\\n# method 1\\n# note : we are using left join because we have to access all the rows from the person table. vice versa for right. \\nselect person.firstName, person.lastName, Address.city, Address.state\\nfrom person\\nLEFT JOIN Address \\non person.personId=Address.personId;\\n# method 2\\nselect firstName, lastName, city, state\\nfrom person\\nLEFT JOIN Address \\non person.personId=Address.personId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# method 1\\n# note : we are using left join because we have to access all the rows from the person table. vice versa for right. \\nselect person.firstName, person.lastName, Address.city, Address.state\\nfrom person\\nLEFT JOIN Address \\non person.personId=Address.personId;\\n# method 2\\nselect firstName, lastName, city, state\\nfrom person\\nLEFT JOIN Address \\non person.personId=Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2021881,
                "title": "union-solution-sql",
                "content": "```\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Person p, Address a\\nwhere p.personId = a.personId\\nunion\\nselect p.firstName, p.lastName, null, null \\nfrom Person p\\nwhere p.personId not in (select a.personId from Address a)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Person p, Address a\\nwhere p.personId = a.personId\\nunion\\nselect p.firstName, p.lastName, null, null \\nfrom Person p\\nwhere p.personId not in (select a.personId from Address a)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2004146,
                "title": "mysql-using-simple-l-r-join",
                "content": "select  \\nFirstName,\\nLastName, \\nCity, State from Person p \\nleft join Address a on p.PersonId = a.PersonId",
                "solutionTags": [],
                "code": "select  \\nFirstName,\\nLastName, \\nCity, State from Person p \\nleft join Address a on p.PersonId = a.PersonId",
                "codeTag": "Unknown"
            },
            {
                "id": 1930213,
                "title": "simple-and-easy-one-line-left-join-solution-faster",
                "content": "```\\nselect firstName,lastName,city,state from Person left join Address using (personId);\\n```",
                "solutionTags": [],
                "code": "```\\nselect firstName,lastName,city,state from Person left join Address using (personId);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791081,
                "title": "combine-two-tables-solution",
                "content": "SELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonId = Address.PersonId",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonId = Address.PersonId",
                "codeTag": "Unknown"
            },
            {
                "id": 1621703,
                "title": "mysql-solution",
                "content": "```\\nselect firstname, lastname, city, state \\nfrom person left join address\\non person.personid=address.personid;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect firstname, lastname, city, state \\nfrom person left join address\\non person.personid=address.personid;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1579091,
                "title": "simple-left-join",
                "content": "```\\n# Write your MySQL query statement below\\nselect firstName,lastName,city,state\\nfrom\\nperson\\nleft join\\naddress on person.personid=address.personid;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect firstName,lastName,city,state\\nfrom\\nperson\\nleft join\\naddress on person.personid=address.personid;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224274,
                "title": "test-data-is-wrong",
                "content": "Test data is wrong.\\n```\\n{\"headers\": {\"Person\": [\"PersonId\", \"LastName\", \"FirstName\"], \"Address\": [\"AddressId\", \"PersonId\", \"City\", \"State\"]}, \"rows\": {\"Person\": [[1, \"Wang\", \"Allen\"]], \"Address\": [[1, 2, \"New York City\", \"New York\"]]}}\\n```\\nWhen you check the data for Address Table, PersonId is two (2) while the PersonId is one (1) in the Person Table. The join should not happen.\\nHow come people can pass this example?\\n",
                "solutionTags": [],
                "code": "```\\n{\"headers\": {\"Person\": [\"PersonId\", \"LastName\", \"FirstName\"], \"Address\": [\"AddressId\", \"PersonId\", \"City\", \"State\"]}, \"rows\": {\"Person\": [[1, \"Wang\", \"Allen\"]], \"Address\": [[1, 2, \"New York City\", \"New York\"]]}}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52936,
                "title": "so-watch-your-capitalization-carefully-uff01",
                "content": "\\n```\\nSELECT person.firstname,person.lastname,address.city,address.state \\nFROM person \\nLEFT JOIN address \\nON person.personid=address.personid\\nORDER BY person.personid;\\n```\\n\\u200bWRONG!!!\\n#\\u6ce8\\u610f\\u5927\\u5c0f\\u5199\\uff01\\uff01\\uff01\\n\\u200b\\n```\\nSELECT Person.FirstName,Person.LastName,Address.City,Address.State \\nFROM Person \\nLEFT JOIN Address \\nON Person.PersonId=Address.PersonId\\nORDER BY Person.PersonId;\\n```\\nRIGHT!!!",
                "solutionTags": [],
                "code": "```\\nSELECT person.firstname,person.lastname,address.city,address.state \\nFROM person \\nLEFT JOIN address \\nON person.personid=address.personid\\nORDER BY person.personid;\\n```\n```\\nSELECT Person.FirstName,Person.LastName,Address.City,Address.State \\nFROM Person \\nLEFT JOIN Address \\nON Person.PersonId=Address.PersonId\\nORDER BY Person.PersonId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051076,
                "title": "pandas-sql-easy-combine-two-tables",
                "content": "[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1050775699/)\\n```\\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\\n    # Let\\'s merge the two DataFrames using a left outer join on \\'personId\\'\\n    merged_df = pd.merge(person, address, on=\\'personId\\', how=\\'left\\')\\n    \\n    # Then we select the specific columns \\'firstName\\', \\'lastName\\', \\'city\\', and \\'state\\'\\n    selected_columns = merged_df[[\\'firstName\\', \\'lastName\\', \\'city\\', \\'state\\']]\\n    \\n    return selected_columns\\n```\\n\\n**SQL**\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1061396660/)\\n```\\nSELECT firstName, lastName, city, state\\nFROM Person\\nLEFT OUTER JOIN address\\nON person.personId = address.personId;\\n```\\n\\n```\\n-- Selecting columns \"firstName,\" \"lastName,\" \"city,\" and \"state\" from the tables\\nSELECT firstName, lastName, city, state\\n\\n-- Specifying the source table as \"Person\" from which data will be retrieved\\nFROM Person \\n\\n-- Performing a LEFT OUTER JOIN between \"Person\" and \"address\" tables\\n-- This join combines records from both tables based on the condition that \"personId\" in \"Person\" matches \"personId\" in \"address\"\\nLEFT OUTER JOIN address\\nON person.personId = address.personId;\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f94d4271-69e7-4a44-aad2-db00c938b341_1695221837.87254.jpeg)\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\\n    # Let\\'s merge the two DataFrames using a left outer join on \\'personId\\'\\n    merged_df = pd.merge(person, address, on=\\'personId\\', how=\\'left\\')\\n    \\n    # Then we select the specific columns \\'firstName\\', \\'lastName\\', \\'city\\', and \\'state\\'\\n    selected_columns = merged_df[[\\'firstName\\', \\'lastName\\', \\'city\\', \\'state\\']]\\n    \\n    return selected_columns\\n```\n```\\nSELECT firstName, lastName, city, state\\nFROM Person\\nLEFT OUTER JOIN address\\nON person.personId = address.personId;\\n```\n```\\n-- Selecting columns \"firstName,\" \"lastName,\" \"city,\" and \"state\" from the tables\\nSELECT firstName, lastName, city, state\\n\\n-- Specifying the source table as \"Person\" from which data will be retrieved\\nFROM Person \\n\\n-- Performing a LEFT OUTER JOIN between \"Person\" and \"address\" tables\\n-- This join combines records from both tables based on the condition that \"personId\" in \"Person\" matches \"personId\" in \"address\"\\nLEFT OUTER JOIN address\\nON person.personId = address.personId;\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3813470,
                "title": "easy-solution-with-left-join",
                "content": "# Code\\n```\\nSELECT p.firstName, p.lastName, a.city, a.state FROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT p.firstName, p.lastName, a.city, a.state FROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739670,
                "title": "easy-mysql-solution-using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT firstName, lastName, city, state FROM Person p LEFT JOIN Address a ON p.personId = a.personId\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT firstName, lastName, city, state FROM Person p LEFT JOIN Address a ON p.personId = a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659411,
                "title": "ms-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT P.firstName, P.lastName, A.city, A.state\\nFROM Person P LEFT JOIN Address A\\non P.personId = A.personId\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT P.firstName, P.lastName, A.city, A.state\\nFROM Person P LEFT JOIN Address A\\non P.personId = A.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479968,
                "title": "easy-to-understand-mysql-left-join",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT p.firstName,p.lastName,a.city,a.state FROM Person as P LEFT JOIN Address as a on p.personId=a.personId;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT p.firstName,p.lastName,a.city,a.state FROM Person as P LEFT JOIN Address as a on p.personId=a.personId;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3361601,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Person.firstName, Person.lastName, Address.city, Address.state from person left join Address on Person.personId=Address.personId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Person.firstName, Person.lastName, Address.city, Address.state from person left join Address on Person.personId=Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266958,
                "title": "left-outer-join-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT FIRSTNAME,LASTNAME,CITY,STATE FROM PERSON LEFT OUTER JOIN ADDRESS ON (PERSON.PERSONID=ADDRESS.PERSONID);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT FIRSTNAME,LASTNAME,CITY,STATE FROM PERSON LEFT OUTER JOIN ADDRESS ON (PERSON.PERSONID=ADDRESS.PERSONID);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3265200,
                "title": "using-left-join-mysql",
                "content": "**USING LEFT JOIN**\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT Person.FirstName, Person.LastName, Address.City, Address.State \\nFROM Person \\nLEFT JOIN Address \\nON Person.PersonId = Address.PersonId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Person.FirstName, Person.LastName, Address.City, Address.State \\nFROM Person \\nLEFT JOIN Address \\nON Person.PersonId = Address.PersonId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3171094,
                "title": "sql-easy-approach",
                "content": "Here is my MYSQL code for this problem.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect p.firstName, p.lastName, a.city, a.state from Person as p left join Address as a on p.personID=a.personID;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect p.firstName, p.lastName, a.city, a.state from Person as p left join Address as a on p.personID=a.personID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3140049,
                "title": "mysql-simple-and-easy",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT firstName, lastName, city, state FROM Person LEFT JOIN Address ON Person.personId=Address.personId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT firstName, lastName, city, state FROM Person LEFT JOIN Address ON Person.personId=Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3112100,
                "title": "two-simple-solutions-explained-in-detail-for-beginners",
                "content": "We can solve this using two ways mentioned below,\\neach of them use leftjoin, why? because we need each entry from table 1 the entries from second table can be taken as null and that is exactly what left join do.\\nIf we use full join, then it would give us the rows that are present in both the tables, while right join will give us all the values from table 2 no matter whether they are present in table 1 or not, like opposite of left join.\\n\\nMethod 1 using on:-\\n```\\nselect firstname, lastname, city, state\\nfrom person left join address\\non person.personid = address.personid\\n\\n```\\non can also be used when the column name is different in both the tables, like \\nif personid was named as p_id in address table then we use the below statement\\n```\\non person.personid=address.p_id\\n```\\nI hope this is clear.\\n\\nMethod 2:- \\n```\\n\\nselect firstname, lastname, city, state\\nfrom person left join address using (personid);\\n```\\n\\'using\\' can only be used when columns from both the table have same name otherwise it won\\'t work,\\nfor this question this is more better approach because the column name is same.\\n\\nFeel free to ask anything in the comments.\\nIf you found this helpful please upvote.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect firstname, lastname, city, state\\nfrom person left join address\\non person.personid = address.personid\\n\\n```\n```\\non person.personid=address.p_id\\n```\n```\\n\\nselect firstname, lastname, city, state\\nfrom person left join address using (personid);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3092336,
                "title": "mysql-solution-beats-98",
                "content": "# Code\\n```\\nSELECT Person.FirstName, Person.LastName, Address.City, Address.State from Person LEFT JOIN Address on Person.PersonId = Address.PersonId;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT Person.FirstName, Person.LastName, Address.City, Address.State from Person LEFT JOIN Address on Person.PersonId = Address.PersonId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3088916,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT Person.firstName, Person.lastName,Address.city,Address.state\\nFROM Person\\nLeft JOIN Address ON Person.personId=Address.personId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Person.firstName, Person.lastName,Address.city,Address.state\\nFROM Person\\nLeft JOIN Address ON Person.personId=Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900206,
                "title": "mysql-left-join",
                "content": "https://leetcode.com/submissions/detail/857988684/\\n```\\n# Write your MySQL query statement below\\nselect p.firstname, p.lastname, a.city, a.state\\nfrom Person as p left join Address as a\\non p.personId = a.personID\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect p.firstname, p.lastname, a.city, a.state\\nfrom Person as p left join Address as a\\non p.personId = a.personID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809458,
                "title": "99-faster-left-join",
                "content": "![image](https://assets.leetcode.com/users/images/d1585e11-31eb-4913-af83-9dec929c40e4_1668318733.873789.png)\\n\\n```\\nSELECT P.firstName, P.lastName, A.city, A.state\\nFROM Person P \\nLEFT JOIN Address A\\nON P.personId = A.personId\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT P.firstName, P.lastName, A.city, A.state\\nFROM Person P \\nLEFT JOIN Address A\\nON P.personId = A.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756801,
                "title": "sql-joins-easy-explanation-beginners",
                "content": "# JOIN EXPLANATION \\n\\nLeft Join -> inner join + take the value from left join which are not matching with right join\\n\\nExplanation \\n\\n# Table \\n\\nPERSON1  \\n  2\\n  3\\n  1\\n\\nPERSON2\\n  2\\n  2\\n  1      \\n\\n\\n# INNER JOIN \\n\\n 1. Look at the above table PERSON1 ,take the first row value is 2 , it will look for value 2 in PERSON2 table\\n 2. we can find two rows in PERSON2 having value 2 so in the NEWTABLE(this means combained inner join table) insert the value 2 twice\\n\\n\\t                               NEWTABLE\\n                                     2\\n                                     2\\n\\n 3. Again move to next row in PERSON1 take the Value 3 and check weather three is present in PERSON2,finally its not present,so no insertion\\n 4. Then move to the next row in PERSON1 take the value 1 and check for match in PERSON2, yes last row in PERSON2 is matched,so insert the value 1 in NEWTABLE\\n\\n\\t                               NEWTABLE\\n                                     2\\n                                     2\\n                                     1\\n\\n\\n5.our inner Join is ready.\\n\\n# LEFT JOIN\\n\\n1.Here after doing inner join take the new table and here person 1 is left table so add the value which are left in PERSON1 table ie) we left 3 because it is not matching, so insert 3 here\\n\\n                                NEWTABLE\\n                                     2\\n                                     2\\n                                     1\\n                                     3\\n\\n# RIGHT JOIN \\n\\n Vice versa of left join ie) inner join + right table values which are not matching  with left table\\n\\n# COMMENT THE NEWTABLE FOR RIGHT JOIN ! THANK YOU\\n\\n# CODE\\nselect firstName,lastName,city,state from Person t1 left join Address t2 on t1.personId = t2.personId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# JOIN EXPLANATION \\n\\nLeft Join -> inner join + take the value from left join which are not matching with right join\\n\\nExplanation \\n\\n# Table \\n\\nPERSON1  \\n  2\\n  3\\n  1\\n\\nPERSON2\\n  2\\n  2\\n  1      \\n\\n\\n# INNER JOIN \\n\\n 1. Look at the above table PERSON1 ,take the first row value is 2 , it will look for value 2 in PERSON2 table\\n 2. we can find two rows in PERSON2 having value 2 so in the NEWTABLE(this means combained inner join table) insert the value 2 twice\\n\\n\\t                               NEWTABLE\\n                                     2\\n                                     2\\n\\n 3. Again move to next row in PERSON1 take the Value 3 and check weather three is present in PERSON2,finally its not present,so no insertion\\n 4. Then move to the next row in PERSON1 take the value 1 and check for match in PERSON2, yes last row in PERSON2 is matched,so insert the value 1 in NEWTABLE\\n\\n\\t                               NEWTABLE\\n                                     2\\n                                     2\\n                                     1\\n\\n\\n5.our inner Join is ready.\\n\\n# LEFT JOIN\\n\\n1.Here after doing inner join take the new table and here person 1 is left table so add the value which are left in PERSON1 table ie) we left 3 because it is not matching, so insert 3 here\\n\\n                                NEWTABLE\\n                                     2\\n                                     2\\n                                     1\\n                                     3\\n\\n# RIGHT JOIN \\n\\n Vice versa of left join ie) inner join + right table values which are not matching  with left table\\n\\n# COMMENT THE NEWTABLE FOR RIGHT JOIN ! THANK YOU\\n\\n# CODE\\nselect firstName,lastName,city,state from Person t1 left join Address t2 on t1.personId = t2.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2717390,
                "title": "2-way-logic-thinking-solution",
                "content": "```\\n1)\\nselect lastname, firstname, \\n         (select top 1 city\\n             from address \\n          where personid = p.personid\\n             ) as city,\\n            \\n         (select top 1 state\\n             from address\\n          where personid = p.personid\\n             ) as  state\\nfrom person p\\n\\n2)\\nselect p.lastName, p.firstname , a.city,a.state\\nfrom person p left join address a on p.personId = a.personId\\n```",
                "solutionTags": [],
                "code": "```\\n1)\\nselect lastname, firstname, \\n         (select top 1 city\\n             from address \\n          where personid = p.personid\\n             ) as city,\\n            \\n         (select top 1 state\\n             from address\\n          where personid = p.personid\\n             ) as  state\\nfrom person p\\n\\n2)\\nselect p.lastName, p.firstname , a.city,a.state\\nfrom person p left join address a on p.personId = a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629695,
                "title": "sql-join-easy",
                "content": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\n\\n\\tselect p.firstName , p.lastName , a.city , a.state\\n\\tfrom person as p\\n\\tleft join Address as a \\n\\ton p.personId = a.personId\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\n\\n\\tselect p.firstName , p.lastName , a.city , a.state\\n\\tfrom person as p\\n\\tleft join Address as a \\n\\ton p.personId = a.personId\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2536401,
                "title": "left-join-sql",
                "content": "SELECT p.firstName, p.lastName, a.city, a.state \\nFROM Person as p Left join address as a\\non p.personId = a.personId;",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "SELECT p.firstName, p.lastName, a.city, a.state \\nFROM Person as p Left join address as a\\non p.personId = a.personId;",
                "codeTag": "Unknown"
            },
            {
                "id": 2459956,
                "title": "oracle-left-join-faster-than-99",
                "content": "```\\nselect p.firstName,p.lastName,a.city,a.state from Person p left join address a on\\np.personid = a.personid;\\n```\\n![image](https://assets.leetcode.com/users/images/69e97f0d-d48b-4396-bee4-9f46b44a3d1a_1661100186.12899.png)\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect p.firstName,p.lastName,a.city,a.state from Person p left join address a on\\np.personid = a.personid;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431734,
                "title": "mysql-easy-to-understand-left-join",
                "content": "```\\nSELECT firstName, lastName, city, state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId=Address.personId;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT firstName, lastName, city, state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId=Address.personId;",
                "codeTag": "Unknown"
            },
            {
                "id": 2367420,
                "title": "easy-mysql-solution-using-left-join",
                "content": "* SELECT firstname,lastname,Address.city,Address.state FROM person left join Address ON person.personId=address.personId",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "* SELECT firstname,lastname,Address.city,Address.state FROM person left join Address ON person.personId=address.personId",
                "codeTag": "Unknown"
            },
            {
                "id": 2317802,
                "title": "simple-2-approaches-left-join-right-join",
                "content": "**Right Join solution**\\n```\\nSELECT Person.firstname, Person.lastname, Address.city, Address.state\\nFROM Address RIGHT JOIN Person \\nON Person.personId = Address.personId;\\n```\\n\\n\\n\\n**Left Join solution**\\n\\n```\\nSELECT Person.firstname, Person.lastname, Address.city, Address.state\\nFROM Person LEFT JOIN Address \\nON Person.personId = Address.personId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Person.firstname, Person.lastname, Address.city, Address.state\\nFROM Address RIGHT JOIN Person \\nON Person.personId = Address.personId;\\n```\n```\\nSELECT Person.firstname, Person.lastname, Address.city, Address.state\\nFROM Person LEFT JOIN Address \\nON Person.personId = Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2313953,
                "title": "simplest-solution-mysql",
                "content": "SELECT p.firstname, p.lastname, a.state, a.city\\nFROM Person p\\nLEFT JOIN address a ON p.personId = a.personID",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT p.firstname, p.lastname, a.state, a.city\\nFROM Person p\\nLEFT JOIN address a ON p.personId = a.personID",
                "codeTag": "Unknown"
            },
            {
                "id": 2246841,
                "title": "simple-and-easy-solution-mysql-left-join",
                "content": "```\\nselect firstName, lastName, city, state\\nfrom Person p left join Address a\\non p.personId=a.personId\\n```\\n\\n**Please UpVote if it was Helpful :)**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect firstName, lastName, city, state\\nfrom Person p left join Address a\\non p.personId=a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2225545,
                "title": "left-join-mysql-explanation",
                "content": "Here in the question it is given the two tables i,e.\\n\\nPerson : (personId, lastname, firstName)\\nAddress: (addressId, personId,city,state)\\n\\nHere in the both tables one attribute is common which is \"PersonId\" through which the DBMS concept say us that Join occurs only when there is an same attribute in both the tables and if they are same then one must be ```primary key``` and other must be the ```foreign key```. So for this condition we can join both the tables.\\n\\nRemember\\n```\\nPersonId in Person table is primary Key and\\nPersonId in Address table is Foreign Key\\n```\\n\\nThere are many joins which should be used?? \\n>> At mind, the mostly used is [RIGHT,LEFT,FULL]\\n>> **RIGHT**: It starts selecting data from the right table and matching it with the rows from the left table.\\n>> **LEFT**: It returns all the rows from the left table even if there are no matches in right table.\\n>> **FULL**: It returns all the rows from both joined tables whether they have a matching row or not.\\n\\nFrom both the tables we want firstName, lastName, city and state. We don\\'t  need PersonId, AddressId.\\n\\nWe have to join => Person JOIN Address. Selected items should be selected from query. Person table had been on the left and we want the left table extending to the right table through which we can get all the attributes excepting some of them.\\n\\nSolution:\\n```\\nSELECT firstName, lastName, city, state \\nFROM Person LEFT JOIN Address\\nON Person.personID = Address.addressId;\\n```\\n\\n***Explanation of Solution:***\\n```\\nWe are selecting the firstName, lastName, city and state from both the tables where PersonId in both the tables are common attributes.\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```primary key```\n```foreign key```\n```\\nPersonId in Person table is primary Key and\\nPersonId in Address table is Foreign Key\\n```\n```\\nSELECT firstName, lastName, city, state \\nFROM Person LEFT JOIN Address\\nON Person.personID = Address.addressId;\\n```\n```\\nWe are selecting the firstName, lastName, city and state from both the tables where PersonId in both the tables are common attributes.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1999046,
                "title": "mysql-union-solution",
                "content": "```\\n# NON-NULL CASE\\nselect Person.firstName, Person.lastName, Address.city, Address.state from Person, Address where Person.personId = Address.personId\\nunion\\n# NULL CASE\\nselect Person.firstName, Person.lastName, null, null from Person where Person.personId not in (select Address.personId from Address);\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```\\n# NON-NULL CASE\\nselect Person.firstName, Person.lastName, Address.city, Address.state from Person, Address where Person.personId = Address.personId\\nunion\\n# NULL CASE\\nselect Person.firstName, Person.lastName, null, null from Person where Person.personId not in (select Address.personId from Address);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947356,
                "title": "easy-left-join-concept",
                "content": "![image](https://assets.leetcode.com/users/images/95917b07-d2d6-4c59-b308-22fea57e7227_1649959926.220577.png)\\n\\nSELECT \\n    Person.firstName, Person.lastName, Address.city, Address.state\\nFROM\\n    Person\\nLEFT JOIN\\n    Address\\nON\\n    Person.personId = Address.personId\\n;",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/95917b07-d2d6-4c59-b308-22fea57e7227_1649959926.220577.png)\\n\\nSELECT \\n    Person.firstName, Person.lastName, Address.city, Address.state\\nFROM\\n    Person\\nLEFT JOIN\\n    Address\\nON\\n    Person.personId = Address.personId\\n;",
                "codeTag": "Unknown"
            },
            {
                "id": 1935795,
                "title": "easy-code-join-clean-code-mysql",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT \\n    Person.firstName, Person.lastName, Address.city, Address.state\\nFROM\\n    Person\\nLEFT JOIN\\n    Address\\nON\\n    Person.personId = Address.personId\\n;\\n```\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    Person.firstName, Person.lastName, Address.city, Address.state\\nFROM\\n    Person\\nLEFT JOIN\\n    Address\\nON\\n    Person.personId = Address.personId\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916563,
                "title": "simple-faster-easy-mysql",
                "content": "**MYSQL LEFT JOIN**\\n\\n```\\nselect firstName,lastName,city,state from Person p\\nleft join Address a on p.personId=a.personId\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect firstName,lastName,city,state from Person p\\nleft join Address a on p.personId=a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803598,
                "title": "best-easiest-simplest-mysql-solution-175-combine-two-tables",
                "content": "```\\nselect firstName, lastName,city, state\\nfrom Person LEFT JOIN Address ON Person.personId = Address.personId;\\n\\n#pls upvote if you found the solution easy ..!! thanks\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect firstName, lastName,city, state\\nfrom Person LEFT JOIN Address ON Person.personId = Address.personId;\\n\\n#pls upvote if you found the solution easy ..!! thanks\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1701296,
                "title": "simple-mysql-solution",
                "content": "```\\nselect \\np.firstName,\\np.lastName,\\na.city,\\na.state\\nfrom person p\\nleft join address a on a.personId = p.personId #include all values from p, resulting in null values in a\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect \\np.firstName,\\np.lastName,\\na.city,\\na.state\\nfrom person p\\nleft join address a on a.personId = p.personId #include all values from p, resulting in null values in a\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1486103,
                "title": "oracle-sql-easy-with-readable-sql-format",
                "content": "```\\nselect p.FirstName\\n    , p.LastName\\n    , a.City\\n    , a.State\\n    from Person p\\n    left join Address a\\n    on p.PersonId = a.PersonId\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nselect p.FirstName\\n    , p.LastName\\n    , a.City\\n    , a.State\\n    from Person p\\n    left join Address a\\n    on p.PersonId = a.PersonId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1282866,
                "title": "left-join-from-table-person-to-table-address",
                "content": "**Here we need to use left join because they asked all rows need to be printed which need not to be in address table so we need to print all person table rows and even the rows which is intersected with address table so we need to perform left join from person table to address table.**\\n\\n\\n```\\n# Write your MySQL query statement below\\nSELECT Person.FirstName,Person.LastName,Address.City,Address.State \\nfrom Person \\nLEFT OUTER JOIN Address\\nON Person.PersonId = Address.PersonId\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Person.FirstName,Person.LastName,Address.City,Address.State \\nfrom Person \\nLEFT OUTER JOIN Address\\nON Person.PersonId = Address.PersonId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167890,
                "title": "beats-100-memory-left-join-concept",
                "content": "SELECT Person.FirstName, Person.LastName, Address.City, Address.State\\nFROM Person\\nLEFT JOIN Address ON Person.PersonId=Address.PersonId\\nORDER BY Person.FirstName;\\n",
                "solutionTags": [],
                "code": "SELECT Person.FirstName, Person.LastName, Address.City, Address.State\\nFROM Person\\nLEFT JOIN Address ON Person.PersonId=Address.PersonId\\nORDER BY Person.FirstName;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 659282,
                "title": "simple-query-with-left-join",
                "content": "SELECT p.FirstName, p.LastName,a.City,a.State\\nFROM Person p LEFT JOIN Address a \\nON a.PersonId = p.PersonId\\n",
                "solutionTags": [],
                "code": "SELECT p.FirstName, p.LastName,a.City,a.State\\nFROM Person p LEFT JOIN Address a \\nON a.PersonId = p.PersonId\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 372231,
                "title": "mysql-left-join",
                "content": "```\\nSELECT FirstName, LastName, City, State FROM Person LEFT JOIN Address ON Person.PersonId = Address.PersonId\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT FirstName, LastName, City, State FROM Person LEFT JOIN Address ON Person.PersonId = Address.PersonId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3933974,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT FIRSTNAME,LASTNAME,CITY,STATE FROM PERSON LEFT OUTER JOIN ADDRESS ON (PERSON.PERSONID=ADDRESS.PERSONID);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT FIRSTNAME,LASTNAME,CITY,STATE FROM PERSON LEFT OUTER JOIN ADDRESS ON (PERSON.PERSONID=ADDRESS.PERSONID);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929353,
                "title": "2-lines-sql-pandas",
                "content": "# Intuition\\nWe want to combine information from two tables based on a common column (personId), the initial intuition is to use a join operation. \\n\\nSpecifically, a left join will allow us to retain all records from the left table (person) and match them with corresponding records from the right table (address).\\n\\n---\\n\\n# Approach\\nPerform a left join on the personId column between the person and address DataFrames using the merge function in pandas.\\n\\nSelect the desired columns (\\'firstName\\', \\'lastName\\', \\'city\\', \\'state\\') from the merged DataFrame to create the result DataFrame.\\n\\n# Complexity\\n- Time complexity:\\nThe merge operation complexity would be approximately O(n + m), as it involves creating an index and matching rows based on the personId column.\\n\\n- Space complexity:\\nThe space complexity involves the memory required to store the merged DataFrame and the result DataFrame. \\n\\n# Code \\n```SQL []\\n# Write your MySQL query statement below\\n\\nSELECT p.firstName, p.lastName, a.city, a.state FROM Person p\\nLEFT JOIN Address a ON p.personId = a.per\\n```\\n```Pandas []\\nimport pandas as pd\\n\\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\\n    merged_df = person.merge(address, on=\\'personId\\', how=\\'left\\')\\n    result_df = merged_df[[\\'firstName\\', \\'lastName\\', \\'city\\', \\'state\\']]\\n    return result_df\\n```\\n\\n> \\uD83D\\uDCA1",
                "solutionTags": [
                    "MySQL",
                    "Database",
                    "Pandas"
                ],
                "code": "```SQL []\\n# Write your MySQL query statement below\\n\\nSELECT p.firstName, p.lastName, a.city, a.state FROM Person p\\nLEFT JOIN Address a ON p.personId = a.per\\n```\n```Pandas []\\nimport pandas as pd\\n\\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\\n    merged_df = person.merge(address, on=\\'personId\\', how=\\'left\\')\\n    result_df = merged_df[[\\'firstName\\', \\'lastName\\', \\'city\\', \\'state\\']]\\n    return result_df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3919352,
                "title": "pandas-simple-left-join-be-carefull-with-returning-columns-by-their-position",
                "content": "# Intuition\\nSimplest left join. One thing that is actually interesting to notice, you **CAN NOT** return columns by their position:\\n\\n`return person.merge(address, on = \\'personId\\',how = \\'left\\').iloc[:,[2,1,4,5]]`\\n \\nIt works as long as tables are populated, but if tables are empty it messes order or columns => you **HAVE TO** specify their names, as in solution, try both solutions.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\\n    return person.merge(address, on = \\'personId\\',how = \\'left\\')[[\\'firstName\\',\\'lastName\\',\\'city\\',\\'state\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\\n    return person.merge(address, on = \\'personId\\',how = \\'left\\')[[\\'firstName\\',\\'lastName\\',\\'city\\',\\'state\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3918996,
                "title": "mysql-simple-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT firstName,lastName,city,state\\nFROM Person\\nLeft JOIN Address\\nUSING(PersonId)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT firstName,lastName,city,state\\nFROM Person\\nLeft JOIN Address\\nUSING(PersonId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913719,
                "title": "pandas-simple-solution-using-merge",
                "content": "\\n```\\nimport pandas as pd\\n\\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\\n    combined = pd.merge(person, address, how=\\'left\\', on=\\'personId\\')\\n    return combined[[\\'firstName\\', \\'lastName\\', \\'city\\', \\'state\\']]\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\\n    combined = pd.merge(person, address, how=\\'left\\', on=\\'personId\\')\\n    return combined[[\\'firstName\\', \\'lastName\\', \\'city\\', \\'state\\']]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3820343,
                "title": "oracle-easy-solution-memory-beats-100",
                "content": "# Code\\n```\\nSelect firstName,lastName,city,state From Person Left Outer Join Address On (Person.personId=Address.personId)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSelect firstName,lastName,city,state From Person Left Outer Join Address On (Person.personId=Address.personId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3820096,
                "title": "combine-two-tables-mysql-solution-code",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect person.firstname, person.lastName, Address.city, Address.state \\nfrom person \\nleft join Address\\non person.personId  = Address.personId ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect person.firstname, person.lastName, Address.city, Address.state \\nfrom person \\nleft join Address\\non person.personId  = Address.personId ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739673,
                "title": "sql-solution-with-91-68-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT firstName, lastName, city, state FROM Person p LEFT JOIN Address a ON p.personId = a.personId\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT firstName, lastName, city, state FROM Person p LEFT JOIN Address a ON p.personId = a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3642922,
                "title": "simple-sql-solution-left-join",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n  p.firstName,\\n  p.lastName,\\n  a.city,\\n  a.state\\nFROM Person p\\nLEFT JOIN Address a\\nON p.personId = a.personId;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n  p.firstName,\\n  p.lastName,\\n  a.city,\\n  a.state\\nFROM Person p\\nLEFT JOIN Address a\\nON p.personId = a.personId;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3379948,
                "title": "combine-two-table-left-join",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect p1.firstName,p1.lastName,a1.city,a1.state\\nfrom Person as p1\\nleft join \\nAddress as a1\\non p1.personId=a1.personId\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect p1.firstName,p1.lastName,a1.city,a1.state\\nfrom Person as p1\\nleft join \\nAddress as a1\\non p1.personId=a1.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3227811,
                "title": "easy-mysql-solution-left-join-explain",
                "content": "`It is typical demonstration of LEFT JOIN operation`\\n## LEFT JOIN\\n> The LEFT JOIN keyword returns all records from the left table (table A), and the matching records from the right table (table B). The result is 0 records from the right side, if there is no match.\\n\\n##### SYNTAX\\n```\\nSELECT column_name(s)\\nFROM table_A\\nLEFT JOIN table_B\\nON table_A.column_name = table_B.column_name;\\n```\\n![left-join.png](https://assets.leetcode.com/users/images/30c00392-267d-482f-9a25-b152cdf3d7fb_1677309313.8535137.png)\\n\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECt p.firstname, p.lastName, a.city, a.state\\nFROM Person p LEFT JOIN Address a\\nON p.personId = a.personId\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT column_name(s)\\nFROM table_A\\nLEFT JOIN table_B\\nON table_A.column_name = table_B.column_name;\\n```\n```\\n# Write your MySQL query statement below\\nSELECt p.firstname, p.lastName, a.city, a.state\\nFROM Person p LEFT JOIN Address a\\nON p.personId = a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3081319,
                "title": "simple-query-combine-two-tables",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect firstname,lastname,city,state from Person left join Address on Person.personId=Address.personId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect firstname,lastname,city,state from Person left join Address on Person.personId=Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2673353,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```# Write your MySQL query statement below\\n\\n\\nSELECT firstName,lastName,city,state FROM Person LEFT JOIN Address on Person.personId = Address.personId;\\n# Write your MySQL query statement below\\n\\n\\nSELECT firstName,lastName,city,state FROM Person LEFT JOIN Address on Person.personId = Address.personId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```# Write your MySQL query statement below\\n\\n\\nSELECT firstName,lastName,city,state FROM Person LEFT JOIN Address on Person.personId = Address.personId;\\n# Write your MySQL query statement below\\n\\n\\nSELECT firstName,lastName,city,state FROM Person LEFT JOIN Address on Person.personId = Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2638357,
                "title": "mysql",
                "content": "```\\nselect firstName , lastName , city , state from Person left outer join Address on Person.personId = Address.personId\\n```",
                "solutionTags": [],
                "code": "```\\nselect firstName , lastName , city , state from Person left outer join Address on Person.personId = Address.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2632606,
                "title": "simple-solution-using-left-join",
                "content": "select p.firstName,p.lastName,a.city,a.state from Person as p left join Address as a on p.personId=a.personId;",
                "solutionTags": [],
                "code": "select p.firstName,p.lastName,a.city,a.state from Person as p left join Address as a on p.personId=a.personId;",
                "codeTag": "Unknown"
            },
            {
                "id": 2626809,
                "title": "c-solution",
                "content": "***Left Join***\\n```\\nselect firstName, lastName, city, state from Person p left join Address a on p.personId=a.personId;\\n```",
                "solutionTags": [
                    "MySQL",
                    "C"
                ],
                "code": "```\\nselect firstName, lastName, city, state from Person p left join Address a on p.personId=a.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2600679,
                "title": "easy-join",
                "content": "```\\nSELECT p.firstName, p.lastname, a.city, a.state\\nFROM Person p\\nLEFT JOIN Address a\\nON p.personId = a.personId\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT p.firstName, p.lastname, a.city, a.state\\nFROM Person p\\nLEFT JOIN Address a\\nON p.personId = a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563763,
                "title": "mysql-shortest-solution-one-line",
                "content": "***Please UPVOTE \\uD83D\\uDD25***\\n```\\nSELECT firstName,lastName, city , state FROM Person LEFT JOIN Address ON Person.personID = Address.personID \\n\\n```\\n\\n*  **Another  solution**  (*just to see the differenc*e)\\n\\n```\\nSELECT \\n\\tfirstName,\\n    lastName, \\n    (CASE WHEN \\n        (SELECT city FROM Address WHERE Address.personID =  Person.personID)IS NULL \\n\\t\\tTHEN NULL \\n\\t\\tELSE (SELECT city FROM Address WHERE Address.personID = Person.personID) \\n\\t\\tEND)AS city ,\\n    (CASE WHEN \\n        (SELECT state FROM Address WHERE Address.personID = Person.personID)IS NULL \\n\\t\\tTHEN NULL \\n\\t\\tELSE  (SELECT state FROM Address WHERE Address.personID = Person.personID) \\n\\t\\tEND) AS state\\nFROM Person \\n```\\n***Please UPVOTE \\uD83D\\uDD25***",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT firstName,lastName, city , state FROM Person LEFT JOIN Address ON Person.personID = Address.personID \\n\\n```\n```\\nSELECT \\n\\tfirstName,\\n    lastName, \\n    (CASE WHEN \\n        (SELECT city FROM Address WHERE Address.personID =  Person.personID)IS NULL \\n\\t\\tTHEN NULL \\n\\t\\tELSE (SELECT city FROM Address WHERE Address.personID = Person.personID) \\n\\t\\tEND)AS city ,\\n    (CASE WHEN \\n        (SELECT state FROM Address WHERE Address.personID = Person.personID)IS NULL \\n\\t\\tTHEN NULL \\n\\t\\tELSE  (SELECT state FROM Address WHERE Address.personID = Person.personID) \\n\\t\\tEND) AS state\\nFROM Person \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2548535,
                "title": "simple-and-easy",
                "content": "select firstname,lastname,city,state from person left join address on person.personId = address.personid",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select firstname,lastname,city,state from person left join address on person.personId = address.personid",
                "codeTag": "Unknown"
            },
            {
                "id": 2525895,
                "title": "mysql-union-solution",
                "content": "```sql\\nselect firstName, lastName, null as city, null as state\\nfrom person \\nwhere personId not in (select personId from address)\\n\\nunion\\n\\nselect person.firstName, person.lastName, address.city, address.state\\nfrom person inner join address \\nwhere person.personId = address.personId\\n```",
                "solutionTags": [
                    "MySQL",
                    "Union Find"
                ],
                "code": "```sql\\nselect firstName, lastName, null as city, null as state\\nfrom person \\nwhere personId not in (select personId from address)\\n\\nunion\\n\\nselect person.firstName, person.lastName, address.city, address.state\\nfrom person inner join address \\nwhere person.personId = address.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494435,
                "title": "easiest-sql-solution",
                "content": "##### **just join both the tables on the common attribute i.e. personID****\\nSELECT firstname,lastname,city,state FROM (Person LEFT JOIN Address on person.personID=Address.personID);",
                "solutionTags": [],
                "code": "##### **just join both the tables on the common attribute i.e. personID****\\nSELECT firstname,lastname,city,state FROM (Person LEFT JOIN Address on person.personID=Address.personID);",
                "codeTag": "Unknown"
            },
            {
                "id": 2478562,
                "title": "sql-like-pizza",
                "content": "```\\nselect \\np.firstname as firstname,\\np.lastname as lastname,\\na.city as city,\\na.state as state\\nfrom person p\\nleft join address a on p.personId = a.personId \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect \\np.firstname as firstname,\\np.lastname as lastname,\\na.city as city,\\na.state as state\\nfrom person p\\nleft join address a on p.personId = a.personId \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2441191,
                "title": "simple-left-outer-join-mysql",
                "content": "```\\nselect firstName,lastName,city,state\\nfrom Person p left outer join Address a\\non p.personId = a.personId;",
                "solutionTags": [],
                "code": "```\\nselect firstName,lastName,city,state\\nfrom Person p left outer join Address a\\non p.personId = a.personId;",
                "codeTag": "Unknown"
            },
            {
                "id": 2421687,
                "title": "faster-than-99-33-of-submissions",
                "content": "```\\n# Selecting columns using table aliases\\nSELECT p.firstName, p.lastName, a.city, a.state\\n# Start with the Person table\\n    FROM Person as p\\n\\t# Left Join Address table\\n    LEFT JOIN Address as a\\n\\t# Joining on personID, using \"USING\", \\n\\t# since id names are identical in both tables.\\n        USING(personId);\\n```\\n![image](https://assets.leetcode.com/users/images/b24b2a69-3a22-44d9-8599-239ed0d93fd5_1660431721.3093936.png)\\n",
                "solutionTags": [],
                "code": "```\\n# Selecting columns using table aliases\\nSELECT p.firstName, p.lastName, a.city, a.state\\n# Start with the Person table\\n    FROM Person as p\\n\\t# Left Join Address table\\n    LEFT JOIN Address as a\\n\\t# Joining on personID, using \"USING\", \\n\\t# since id names are identical in both tables.\\n        USING(personId);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406562,
                "title": "mysql-solution-using-left-join-and-natural-left-join",
                "content": "# Using Natural Left Join\\n```select Person.firstName, Person.lastName, Address.city, Address.state from Person Natural left join Address;```\\n\\n# using left join\\n```select Person.firstName, Person.lastName, Address.city, Address.state from Person left join Address using(personId);```\\n",
                "solutionTags": [],
                "code": "```select Person.firstName, Person.lastName, Address.city, Address.state from Person Natural left join Address;```\n```select Person.firstName, Person.lastName, Address.city, Address.state from Person left join Address using(personId);```",
                "codeTag": "Unknown"
            },
            {
                "id": 2337440,
                "title": "left-join",
                "content": "```\\n# Write your MySQL query statement below\\n\\nSELECT firstName,lastName,city,state\\nFROM Person LEFT JOIN \\nAddress on Person.personId = Address.personID;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT firstName,lastName,city,state\\nFROM Person LEFT JOIN \\nAddress on Person.personId = Address.personID;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2328341,
                "title": "mysql-easy",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonId = Address.PersonID;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonId = Address.PersonID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2301968,
                "title": "mysql-left-outer-join",
                "content": "```\\nselect firstName,lastName,city,state from Person left outer join Address on Person.personId = Address.personId\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect firstName,lastName,city,state from Person left outer join Address on Person.personId = Address.personId\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2295035,
                "title": "ms-sql-left-join",
                "content": "```\\nSELECT firstName, lastName, city, state\\nFROM Person P\\nLEFT JOIN Address A ON A.personId = P.personId\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT firstName, lastName, city, state\\nFROM Person P\\nLEFT JOIN Address A ON A.personId = P.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281115,
                "title": "oracle",
                "content": "```\\nSELECT firstName, lastName, city, state FROM Person p LEFT JOIN Address a ON p.personId = a.personId;",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT firstName, lastName, city, state FROM Person p LEFT JOIN Address a ON p.personId = a.personId;",
                "codeTag": "Unknown"
            },
            {
                "id": 2268188,
                "title": "using-join",
                "content": "```\\nSELECT FirstName, LastName, City, State FROM Person LEFT JOIN Address ON Person.PersonId = Address.PersonId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT FirstName, LastName, City, State FROM Person LEFT JOIN Address ON Person.PersonId = Address.PersonId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2266172,
                "title": "mysql-simple-mysql-solution-using-left-join",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 400 ms, faster than 64.40% of MySQL online submissions for Combine Two Tables.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Combine Two Tables.\\n\\n\\tselect p1.firstName, p1.lastName, a1.city, a1.state from person as p1\\n\\tleft join address as a1 on p1.personId = a1.personId\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 400 ms, faster than 64.40% of MySQL online submissions for Combine Two Tables.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Combine Two Tables.\\n\\n\\tselect p1.firstName, p1.lastName, a1.city, a1.state from person as p1\\n\\tleft join address as a1 on p1.personId = a1.personId\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 2245759,
                "title": "solution-to-combine-to-two-tables",
                "content": "When you want all the records from table one even there is no related records for them in table b then we use left join.\\n\\nUpvote if you find this is helpful. \\n\\n```\\nselect \\n    a.firstname,\\n    a.lastname, \\n    b.city, \\n    b.state \\nfrom \\n    Person a \\nleft join \\n    Address b\\non \\n    a.personId = b.personId\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    a.firstname,\\n    a.lastname, \\n    b.city, \\n    b.state \\nfrom \\n    Person a \\nleft join \\n    Address b\\non \\n    a.personId = b.personId\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2240486,
                "title": "oracle-with-union",
                "content": "```\\nSELECT firstName, lastName, city, state FROM Person p LEFT JOIN Address a ON p.personId = a.personId;\\nUNION\\nSELECT firstName, lastName, city, state FROM Person p LEFT JOIN Address a ON p.personId = a.personId;",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT firstName, lastName, city, state FROM Person p LEFT JOIN Address a ON p.personId = a.personId;\\nUNION\\nSELECT firstName, lastName, city, state FROM Person p LEFT JOIN Address a ON p.personId = a.personId;",
                "codeTag": "Unknown"
            },
            {
                "id": 2237179,
                "title": "simplest-oracle-solution-using-left-outer-join",
                "content": "select P.firstName,P.lastName,A.city,A.state\\nfrom Person P left outer join Address A\\non P.personId=A.personId",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "select P.firstName,P.lastName,A.city,A.state\\nfrom Person P left outer join Address A\\non P.personId=A.personId",
                "codeTag": "Unknown"
            },
            {
                "id": 2209507,
                "title": "the-easiest-solution-and-easy-to-understand",
                "content": "select FirstName, LastName, City, State from person p\\nleft join address a on p.personID= a.personID\\n",
                "solutionTags": [],
                "code": "select FirstName, LastName, City, State from person p\\nleft join address a on p.personID= a.personID\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2200455,
                "title": "faster-than-98-13-of-ms-sql-server-submissions",
                "content": "SELECT p.firstName, p.lastname, a.city, a.state \\nFROM person p\\nLEFT JOIN Address a\\nON p.personId = a.personId",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "SELECT p.firstName, p.lastname, a.city, a.state \\nFROM person p\\nLEFT JOIN Address a\\nON p.personId = a.personId",
                "codeTag": "Unknown"
            },
            {
                "id": 2184556,
                "title": "mysql-left-join-notes-of-all-join-operation-supported-by-sql",
                "content": "```\\nSelect firstName, lastName, city, state \\nFrom Person Left Join Address\\non Person.personId = Address.personId;\\n```\\n\\nTypes of Joins\\n![image](https://assets.leetcode.com/users/images/624dc14b-4d9d-4f05-b5ea-6f28e49671c7_1656342616.1009154.png)\\n![image](https://assets.leetcode.com/users/images/7e440f2d-0b09-4c1b-aa69-74a4a293acac_1656342660.3972323.png)\\n![image](https://assets.leetcode.com/users/images/f4082167-7057-4398-b210-15b2f9978807_1656342673.8611495.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect firstName, lastName, city, state \\nFrom Person Left Join Address\\non Person.personId = Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2161584,
                "title": "oracle-very-easy-solution",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nselect p.firstName,p.lastName,a.city,a.state from Person p left join Address a on p.personId=a.personId\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect p.firstName,p.lastName,a.city,a.state from Person p left join Address a on p.personId=a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2153302,
                "title": "top-99-11-solution",
                "content": "## Solution possible ony if you upvote :-\\n\\nIf you don\\'t get the desired output in top 99.11% , probably it would be because of \\npremium feature.\\n\\n![image](https://assets.leetcode.com/users/images/58f00414-1ef8-4d8c-bc35-8b0d3cff3e73_1655265813.7566879.gif)\\n\\n\\n```\\nSELECT firstname,lastname ,city,state from person p\\nleft join Address  a on p.personid=a.personid;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT firstname,lastname ,city,state from person p\\nleft join Address  a on p.personid=a.personid;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2117770,
                "title": "sql-easy-solution",
                "content": "Please do upvote if u find this solution useful\\n```\\n# Write your MySQL query statement below\\nSelect Person.firstName, Person.lastname , Address.city, Address.state\\nfrom Person \\nleft join Address \\non Person.personId=Address.personId;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "Please do upvote if u find this solution useful\\n```\\n# Write your MySQL query statement below\\nSelect Person.firstName, Person.lastname , Address.city, Address.state\\nfrom Person \\nleft join Address \\non Person.personId=Address.personId;",
                "codeTag": "Unknown"
            },
            {
                "id": 2015481,
                "title": "combine-two-tables-mysql",
                "content": "*The **LEFT JOIN** keyword returns all records from the left table (table1), and the matching records from the right table (table2). The result is 0 records from the right side, if there is no match.*\\n![image](https://assets.leetcode.com/users/images/ac34c2f1-e7ea-4f0c-bdad-c3f452e2763f_1651902937.555098.gif)\\n\\n\\n```\\n# Write your MySQL query statement below\\nSELECT P.firstName,P.lastName ,a.city,a.state from Person p LEFT join Address a ON p.personId = a.personId\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT P.firstName,P.lastName ,a.city,a.state from Person p LEFT join Address a ON p.personId = a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1958078,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nselect  firstName , lastName , city , state  \\nfrom Person p\\nleft join Address a on p.personId = a.personId\\n```\\n**PersonId** is *FK* to table **Person**  in **Adress**.\\nLeft join give us all from left table and replace **city** and **state** to *null* how we need in description.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect  firstName , lastName , city , state  \\nfrom Person p\\nleft join Address a on p.personId = a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1952650,
                "title": "python-left-join",
                "content": "```\\nselect firstName, lastName, city, state\\nfrom \\nPerson a left join Address b\\non a.personId= b.personId",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nselect firstName, lastName, city, state\\nfrom \\nPerson a left join Address b\\non a.personId= b.personId",
                "codeTag": "Unknown"
            },
            {
                "id": 1952642,
                "title": "mysql-easy-implementation",
                "content": "```\\nSELECT p.firstName, p.lastName, a.city, a.state\\nFROM Person p LEFT JOIN Address a \\nON p.personId = a.personId\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT p.firstName, p.lastName, a.city, a.state\\nFROM Person p LEFT JOIN Address a \\nON p.personId = a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1942861,
                "title": "sql-left-join",
                "content": "```\\n# Write your MySQL query statement below\\n\\nselect  firstName, lastName, city, state\\n\\t FROM Person left join Address\\n     on\\n     (Person.personId=Address.personId);\\n\\n```\\nIf Helpful Please Like and Upvoke",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect  firstName, lastName, city, state\\n\\t FROM Person left join Address\\n     on\\n     (Person.personId=Address.personId);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937306,
                "title": "left-join-89-72-time-100-space",
                "content": "```\\nSELECT Person.firstName, Person.lastName, Address.city, Address.state from PERSON\\nLEFT JOIN Address ON Person.personId = Address.personId;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Person.firstName, Person.lastName, Address.city, Address.state from PERSON\\nLEFT JOIN Address ON Person.personId = Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935141,
                "title": "mysql-easy-solution-using-left-join",
                "content": "```\\n# Write your MySQL query statement below\\nselect p.firstname, p.lastname, a.city, a.state from Person as p left join Address as a on p.personid = a.personid",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect p.firstname, p.lastname, a.city, a.state from Person as p left join Address as a on p.personid = a.personid",
                "codeTag": "Unknown"
            },
            {
                "id": 1904037,
                "title": "mysql-simple-left-join",
                "content": "```\\nSELECT  p.firstName, p.lastName, a.city,a.state\\nFROM Person p LEFT JOIN Address a\\nON p.personID=a.personID\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT  p.firstName, p.lastName, a.city,a.state\\nFROM Person p LEFT JOIN Address a\\nON p.personID=a.personID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1818416,
                "title": "simple-question-of-left-join",
                "content": "```\\nSELECT P.FirstName,\\n\\t   P.LastName,\\n\\t   A.City,\\n\\t   A.State\\nfrom \\n\\t  Person as P \\nLEFT JOIN \\n     Address as A\\non \\n     P.PersonId = A.PersonId;\\n````\\n\\nPlease **Upvote** if you like the solution.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT P.FirstName,\\n\\t   P.LastName,\\n\\t   A.City,\\n\\t   A.State\\nfrom \\n\\t  Person as P \\nLEFT JOIN \\n     Address as A\\non \\n     P.PersonId = A.PersonId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786762,
                "title": "simple-solution-left-outer-join",
                "content": "```\\nselect firstName, lastName, city, state from Person\\nleft outer join Address\\non Address.personId = Person.personId\\n```\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect firstName, lastName, city, state from Person\\nleft outer join Address\\non Address.personId = Person.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775811,
                "title": "easy-solution-join-tables-using-left-join",
                "content": "```\\nselect Person.firstName, Person.LastName, Address.city, Address.state \\nfrom Person\\nLeft Join Address\\nON Person.personId=Address.personId;\\n```",
                "solutionTags": [],
                "code": "```\\nselect Person.firstName, Person.LastName, Address.city, Address.state \\nfrom Person\\nLeft Join Address\\nON Person.personId=Address.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760130,
                "title": "would-this-answer-work-too",
                "content": "Wondering if this answer is acceptable too -- \\n\\nselect \\n    P.firstName\\n    ,P.lastName\\n    ,A.city\\n    ,A.state\\nfrom \\n    Person P\\nleft join \\n    Address A\\non P.personId = A.personId",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "Wondering if this answer is acceptable too -- \\n\\nselect \\n    P.firstName\\n    ,P.lastName\\n    ,A.city\\n    ,A.state\\nfrom \\n    Person P\\nleft join \\n    Address A\\non P.personId = A.personId",
                "codeTag": "Unknown"
            },
            {
                "id": 1722625,
                "title": "simple-mysql-solution",
                "content": "```\\nselect p.firstName, p.lastName,a.city, a.state\\nfrom Person p left join Address a\\non p.personId=a.personId\\n```",
                "solutionTags": [],
                "code": "```\\nselect p.firstName, p.lastName,a.city, a.state\\nfrom Person p left join Address a\\non p.personId=a.personId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1721012,
                "title": "combine-two-tables-simple-and-near",
                "content": "```\\nSELECT p.firstname,\\n       p.lastname,\\n       a.city,\\n       a.state\\nFROM person p\\nLEFT JOIN address a\\nON p.personid = a.personid\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT p.firstname,\\n       p.lastname,\\n       a.city,\\n       a.state\\nFROM person p\\nLEFT JOIN address a\\nON p.personid = a.personid\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1684768,
                "title": "sql-left-join",
                "content": "```\\nSELECT firstName, lastName, city, state\\nFROM Person\\nLEFT JOIN Address ON\\nPerson.PersonId = Address.PersonId\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT firstName, lastName, city, state\\nFROM Person\\nLEFT JOIN Address ON\\nPerson.PersonId = Address.PersonId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1610841,
                "title": "mysql-explanation-with-code",
                "content": "In this question we have to print some columns from the both the table such that the fullname and lastname should not be null but address part could be.\\nthats why we use here left join in place of inner join. \\nAnd we know that to join the tables we have to do it with respect to some key which should be primary key for one of the table and foreign key of the another table.\\nAnd thats it :)\\n```\\nSELECT firstName, lastName, city, state\\n from person \\n  left join address \\n    on person.personId = address.personId;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "In this question we have to print some columns from the both the table such that the fullname and lastname should not be null but address part could be.\\nthats why we use here left join in place of inner join. \\nAnd we know that to join the tables we have to do it with respect to some key which should be primary key for one of the table and foreign key of the another table.\\nAnd thats it :)\\n```\\nSELECT firstName, lastName, city, state\\n from person \\n  left join address \\n    on person.personId = address.personId;",
                "codeTag": "Unknown"
            },
            {
                "id": 1595374,
                "title": "simple-solution",
                "content": "\\n#inner join is not used because it won\\'t work when person id will be missing in other table.\\n\\nSELECT firstName,lastName,city,state\\nFROM Person left join Address \\non Person.personId = Address.personId;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\n#inner join is not used because it won\\'t work when person id will be missing in other table.\\n\\nSELECT firstName,lastName,city,state\\nFROM Person left join Address \\non Person.personId = Address.personId;",
                "codeTag": "Unknown"
            },
            {
                "id": 1568653,
                "title": "using-cases",
                "content": "# Using Mysql cases\\n\\n```\\n   select p.firstName,p.lastName,\\n          case \\n              when (select count(a.personId) from address a where a.personId=p.personId)=0\\n              then null\\n              else (select a.city from address a where  a.personId=p.personId limit 1)\\n           End as city,\\n           case \\n              when (select count(a.personId) from address a where a.personId=p.personId)=0\\n              then null\\n              else (select a.state from address a where  a.personId=p.personId limit 1) \\n           End as state\\n            from person p\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n   select p.firstName,p.lastName,\\n          case \\n              when (select count(a.personId) from address a where a.personId=p.personId)=0\\n              then null\\n              else (select a.city from address a where  a.personId=p.personId limit 1)\\n           End as city,\\n           case \\n              when (select count(a.personId) from address a where a.personId=p.personId)=0\\n              then null\\n              else (select a.state from address a where  a.personId=p.personId limit 1) \\n           End as state\\n            from person p\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1557788,
                "title": "sql",
                "content": "```\\nselect firstName,lastName,city,state \\nfrom Person LEFT JOIN Address\\non person.personId=Address.personId ;\\n```",
                "solutionTags": [],
                "code": "```\\nselect firstName,lastName,city,state \\nfrom Person LEFT JOIN Address\\non person.personId=Address.personId ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1554380,
                "title": "mysql-left-join",
                "content": "```\\n# Write your MySQL query statement below\\nselect firstName,lastname,city,state FROM Person AS p LEFT JOIN Address AS a on p.personId=a.personId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect firstName,lastname,city,state FROM Person AS p LEFT JOIN Address AS a on p.personId=a.personId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539656,
                "title": "left-join-some-explanation",
                "content": "No need to use OUTER LEFT JOIN since LEFT JOIN alreay implicitly means OUTER JOIN. \\nSince no duplicated cols in Person & Address tables, no need to get a alias for each table and give prefix to selected cols. \\n```\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address USING(PersonId)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address USING(PersonId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1512650,
                "title": "ms-sql",
                "content": "#### Question \\n````\\nSQL Schema\\nTable: Person\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| PersonId    | int     |\\n| FirstName   | varchar |\\n| LastName    | varchar |\\n+-------------+---------+\\nPersonId is the primary key column for this table.\\nThis table contains information about the ID of some persons and their first and last names.\\n \\n\\nTable: Address\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| AddressId   | int     |\\n| PersonId    | int     |\\n| City        | varchar |\\n| State       | varchar |\\n+-------------+---------+\\nAddressId is the primary key column for this table.\\nEach row of this table containts information about the city and state of one person with ID = PersonId.\\n \\n\\nWrite an SQL query to report the first name, last name, city, and state of each person in the Person table. If the address of a PersonId is not present in the Address table, report null instead.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nPerson table:\\n+----------+----------+-----------+\\n| PersonId | LastName | FirstName |\\n+----------+----------+-----------+\\n| 1        | Wang     | Allen     |\\n| 2        | Alice    | Bob       |\\n+----------+----------+-----------+\\nAddress table:\\n+-----------+----------+---------------+------------+\\n| AddressId | PersonId | City          | State      |\\n+-----------+----------+---------------+------------+\\n| 1         | 2        | New York City | New York   |\\n| 2         | 3        | Leetcode      | California |\\n+-----------+----------+---------------+------------+\\nOutput: \\n+-----------+----------+---------------+----------+\\n| FirstName | LastName | City          | State    |\\n+-----------+----------+---------------+----------+\\n| Allen     | Wang     | Null          | Null     |\\n| Bob       | Alice    | New York City | New York |\\n+-----------+----------+---------------+----------+\\nExplanation: \\nThere is no address in the address table for the PersonId = 1 so we return null in their city and state.\\nAddressId = 1 contains information about the address of PersonId = 2.\\n````\\n\\n#### answer\\n````/* Write your T-SQL query statement below */\\nselect p.FirstName, p.LastName, a.City, a.State \\nfrom Person as P left join Address a on a.PersonId = p.PersonId\\n\\n\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "````\\nSQL Schema\\nTable: Person\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| PersonId    | int     |\\n| FirstName   | varchar |\\n| LastName    | varchar |\\n+-------------+---------+\\nPersonId is the primary key column for this table.\\nThis table contains information about the ID of some persons and their first and last names.\\n \\n\\nTable: Address\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| AddressId   | int     |\\n| PersonId    | int     |\\n| City        | varchar |\\n| State       | varchar |\\n+-------------+---------+\\nAddressId is the primary key column for this table.\\nEach row of this table containts information about the city and state of one person with ID = PersonId.\\n \\n\\nWrite an SQL query to report the first name, last name, city, and state of each person in the Person table. If the address of a PersonId is not present in the Address table, report null instead.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nPerson table:\\n+----------+----------+-----------+\\n| PersonId | LastName | FirstName |\\n+----------+----------+-----------+\\n| 1        | Wang     | Allen     |\\n| 2        | Alice    | Bob       |\\n+----------+----------+-----------+\\nAddress table:\\n+-----------+----------+---------------+------------+\\n| AddressId | PersonId | City          | State      |\\n+-----------+----------+---------------+------------+\\n| 1         | 2        | New York City | New York   |\\n| 2         | 3        | Leetcode      | California |\\n+-----------+----------+---------------+------------+\\nOutput: \\n+-----------+----------+---------------+----------+\\n| FirstName | LastName | City          | State    |\\n+-----------+----------+---------------+----------+\\n| Allen     | Wang     | Null          | Null     |\\n| Bob       | Alice    | New York City | New York |\\n+-----------+----------+---------------+----------+\\nExplanation: \\nThere is no address in the address table for the PersonId = 1 so we return null in their city and state.\\nAddressId = 1 contains information about the address of PersonId = 2.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1503246,
                "title": "faster-than-65-vs-85-runtime-submissions",
                "content": "--Runtime: faster than 65.17% of MS SQL Server online submissions for Combine Two Tables.\\n\\nselect FirstName,LastName,City,State\\nfrom Person p LEFT OUTER JOIN Address a\\nON p.PersonId = a.PersonId\\n\\n--Runtime: faster than 85.28% of MS SQL Server online submissions for Combine Two Tables.\\n\\nselect p.FirstName,p.LastName,a.City,a.State\\nfrom Person p LEFT OUTER JOIN Address a\\nON p.PersonId = a.PersonId\\n\\nAlthough not required, explicitly mentioning table alias names in select clause reduced runtime further.",
                "solutionTags": [],
                "code": "--Runtime: faster than 65.17% of MS SQL Server online submissions for Combine Two Tables.\\n\\nselect FirstName,LastName,City,State\\nfrom Person p LEFT OUTER JOIN Address a\\nON p.PersonId = a.PersonId\\n\\n--Runtime: faster than 85.28% of MS SQL Server online submissions for Combine Two Tables.\\n\\nselect p.FirstName,p.LastName,a.City,a.State\\nfrom Person p LEFT OUTER JOIN Address a\\nON p.PersonId = a.PersonId\\n\\nAlthough not required, explicitly mentioning table alias names in select clause reduced runtime further.",
                "codeTag": "Unknown"
            },
            {
                "id": 1451581,
                "title": "mysql-solution-using-left-join",
                "content": "```\\n######################################################\\n\\n#   Runtime: 270ms   -   94.71%\\n#   Memory: 0B  -   100.00%\\n\\n######################################################\\n\\nSELECT Firstname, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonId = Address.PersonId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n######################################################\\n\\n#   Runtime: 270ms   -   94.71%\\n#   Memory: 0B  -   100.00%\\n\\n######################################################\\n\\nSELECT Firstname, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonId = Address.PersonId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1443582,
                "title": "mysql-solution-96-faster",
                "content": "```\\nselect p.FirstName, p.LastName, a.City, a.State from Person p left outer join Address a on a.PersonId=p.PersonId\\n```",
                "solutionTags": [],
                "code": "```\\nselect p.FirstName, p.LastName, a.City, a.State from Person p left outer join Address a on a.PersonId=p.PersonId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1418000,
                "title": "mysql-100-faster",
                "content": "```\\n\\nSELECT FirstName,LastName,City,State FROM Person LEFT JOIN Address \\n           ON Person.PersonId=Address.PersonId;\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT FirstName,LastName,City,State FROM Person LEFT JOIN Address \\n           ON Person.PersonId=Address.PersonId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389576,
                "title": "using-using-and-left-join",
                "content": "```\\nSELECT FirstName, LastName, City, State \\nFROM Person LEFT JOIN Address\\nUSING (PersonId)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT FirstName, LastName, City, State \\nFROM Person LEFT JOIN Address\\nUSING (PersonId)",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570224,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1574600,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1572135,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1572960,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1575583,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1576938,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1567418,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1575428,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1575079,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1573093,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1570224,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1574600,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1572135,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1572960,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1575583,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1576938,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1567418,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1575428,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1575079,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1573093,
                "content": [
                    {
                        "username": "leihua",
                        "content": "#The key to this SQL question is to understand the structure of data: we want to keep the full records of one dataset (**Person**) and don\\'t concern too much about the other (**Address**). so, a left JOIN is perfect. \\n\\nSELECT FirstName,LastName,City,State\\nFROM Person \\nLEFT JOIN Address\\nUSING(PersonId)"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "[@user4175bH](/user4175bH) Because you don\\'t need to. LEFT JOIN is an OUTER join and hence will include all the rows no matter whether the ON clause is satisfied or not. Here, in the problem we are required to output NULL for cases where personId does not exist in the Address table. And that is exactly what LEFT JOIN will do by default. In case we were to output something else in city and state columns, we would not have gotten away with a simple LEFT JOIN."
                    },
                    {
                        "username": "user4175bH",
                        "content": "why can\\'t we use a where clause like where a.personid is null after left join ? Any comments will be of great help."
                    },
                    {
                        "username": "ankitkum20",
                        "content": "**why are we using left join here?\\nwhy cannot we use right join , full outer join ...?**\\n**can somebody explain how to identify where to use left join and where to use right join?**\\n**sry for silly question :)**"
                    },
                    {
                        "username": "AayushiTrivedi_13",
                        "content": "it is mentioned in the question that they want each name from person table.\\nSo we can use left join"
                    },
                    {
                        "username": "bbbssqa",
                        "content": "To get all the values for first table and second table will show null for the field which is null then we need to use left outer join."
                    },
                    {
                        "username": "anandadhoni77",
                        "content": "why here we are using left join is the question is to get the output in the null where addressid not matches with person id.\\naddressid is the second table that means it is in the right side, so we are using left join\\nto get the matching rows between two tables and all the leftside table rows"
                    },
                    {
                        "username": "ajinkya_kadhe",
                        "content": "It\\'s to late but here is explanation \\nThe reason for using a LEFT JOIN in this query is because the goal is to display all records from the \"Person\" table, along with the corresponding address information from the \"Address\" table if available. If a matching record is not present in the \"Address\" table, the values for \"city\" and \"state\" should be null.\\n\\nA RIGHT JOIN would return all records from the \"Address\" table and the matching records from the \"Person\" table. If a matching record is not found in the \"Person\" table, the values for \"firstName\" and \"lastName\" would be null. In this case, it is not desired to display the records from the \"Address\" table if there is no corresponding record in the \"Person\" table.\\n\\nA FULL OUTER JOIN would return all records from both the \"Person\" and \"Address\" tables, regardless of whether a matching record exists in both tables or not. This may result in duplicate records or records with null values in both tables, which is not the desired outcome for this particular query.\\n\\nTherefore, a LEFT JOIN is the most appropriate choice for this query to display all records from the \"Person\" table and the matching address information from the \"Address\" table if available."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "Hey, I know it is too late but to answer your question RIGHT JOIN WILL WORK.\nHere is my solution which scored faster than 81% which was faster than my LEFT JOIN solution:\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Address as a\nRIGHT JOIN Person as p\nON a.personId = p.personId\n\nIn this problem, RIGHT and LEFT does not matter if you just swap the tables before the JOIN clause. However, it is intuitive to use LEFT JOIN and that is why most people think that RIGHT JOIN will not work. Here is the same query with LEFT JOIN. You can quickly notice the difference. Swap the places that's all.\n\nselect p.firstName, p.lastName, a.city, a.state\nfrom Person as p\nLEFT JOIN Address as a\nON p.personId = a.personId"
                    },
                    {
                        "username": "sabreenashraf22894",
                        "content": "because in requirement for this problem he need person with no address so we should use left join as our left table is person and this is meaning of left join get all row fro left join and put null if one value has not value from right table"
                    },
                    {
                        "username": "Teja767",
                        "content": "[@Srivastava_Swapnil](/Srivastava_Swapnil) can u please check my both the queries and reply........?"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@Teja767](/Teja767) here right join will not work."
                    },
                    {
                        "username": "Teja767",
                        "content": "we use left join when we need full data from leftside table and only common data from rightside table\\nselect a.firstname ,a.lastname , b.city , b.state from person a left outer join address b on a.personid=b.personid; \\n\\nwe also can use right join when we need full data from rightside table and only common data from leftside table\\nselect a.firstname ,a.lastname , b.city , b.state from address b right outer join person a on a.personid=b.personid; \\n\\n\\nso here are the multiple solutions for the given prob using left and right both joins\\n\\nplease upvote me if it is useful to u\\n\\n\\n"
                    },
                    {
                        "username": "SterlsR",
                        "content": "W3 Schools has a great concise article with the venn diagrams you\\'re describing.\\nhttps://www.w3schools.com/mysql/mysql_join.asp"
                    },
                    {
                        "username": "choisauce",
                        "content": "Almost 2 years late but here\\'s the explanation.\\nSo the table in the FROM clause is the left table, while the table in the Join clause is the right table.\\n\\nImagine the tables overlapping as a vendiagram and the overlapping portion is the part that is joined.\\n\\nLeft join takes the data from the joined portion and the left table even  if there is no corresponding value on the right table. In this question left join would give us Allen Wang with the joined portion even though his personId is not in the Address table.\\n\\nRight join would do the same except with the right table. This would give us the joined portion and Leetcode, California, even thought the personId for the person living there is not included in the Person table.\\n\\nInner join would only give us the data that is joined together, which would exclude everything from either side. So we would ONLY get, Bob Alice New York City, New York\\n\\nOuter join will give us all the selected data from both tables even if the data isn\\'t joined anywhere."
                    },
                    {
                        "username": "XueyingDing",
                        "content": "what\\'s wrong with this:\\nSELECT FirstName, LastName, City, State\\nFROM Person FULL OUTER JOIN Address\\nON Person.PersonId = Address.PersonId;"
                    },
                    {
                        "username": "joeliu0322",
                        "content": "[@unnotedme](/unnotedme) just run your code and you will find whats wrong with it."
                    },
                    {
                        "username": "unnotedme",
                        "content": "you are supposed to left join instead of full outer join. in your case, all the informations would be joined and we don\\'t want that."
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi, \\nHere\\'s the Mandarin Chinese version to explain this problem by MySQL.\\n\\n[LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790 (01): #175 Combine Two Tables](https://medium.com/@s9811219/leetcode-database-my-sql-175-combine-two-tables-ef9d18627c5)\\n\\nWelcome to discuss together!\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1566964082.png)\\n"
                    },
                    {
                        "username": "Gautam_24",
                        "content": "\\nselect FirstName,LastName,City,State from Person P left join Address A on P.PersonID=A.PersonID"
                    },
                    {
                        "username": "user0794ip",
                        "content": "\\nselect firstName, lastName, (case when city is Null then Null else city end) as city,\\n(case when state is Null then Null else state end) as state\\nfrom person as p\\nleft join address as a on p.personId=a.personId\\n"
                    },
                    {
                        "username": "haoyu6427",
                        "content": "{\\'mysql\\': \\'# Write your MySQL query statement below\\\\n\\', \\'mssql\\': \\'/* Write your T-SQL query statement below */\\\\n\\', \\'oraclesql\\': \\'/* Write your PL/SQL query statement below */\\\\n\\'}\\n\\nI type my SQL query and run it. Nothing show up in output and expected"
                    },
                    {
                        "username": "rdetsch",
                        "content": "Visualize Joins via website \\nhttps://joins.spathon.com/"
                    },
                    {
                        "username": "user4244w",
                        "content": "Why does the following code doesn\\'t work?\\n\\nSELECT p.FirstName, p.LastName, a.City, a.State\\nFROM Person p\\nINNER JOIN Address a ON p.PersonId = a.PersonId;\\n\\nI am doing inner join on PersonId then it should only take PersonId as the matching criteria.\\n\\nCan someone help me with this?"
                    },
                    {
                        "username": "GiggyJung",
                        "content": "You need to use \\n\"LEFT JOIN\" instead \"INNER JOIN\""
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "[@choisauce](/choisauce) yes innerjoin will return only records matching in both tables but we need to return null if the record is not matching too"
                    },
                    {
                        "username": "choisauce",
                        "content": "Over a year but thought I\\'d help answer this.\\ninner join only returns the portion of data that is joined together and excludes anything that doesn\\'t match anything from the other table.\\n\\nIn this case we want to query the name Allen Wang even though his Id isn\\'t joined with the Address table. We do this by using a left join if the person table is in the from clause, or a right join if the person table is in the join clause.\\n\\nWe wouldn\\'t use outer join since we don\\'t want to include Leetcode, California."
                    },
                    {
                        "username": "user8951FL",
                        "content": "How do you decide to use left joint? I think we could also use right..."
                    },
                    {
                        "username": "anuradhanda4498",
                        "content": "Here we choosing:\\nPerson: Table_1 \\nAddress: Table_2\\nWe want every value from the Table_1 and every value related to it in Table_2.\\nAs for Allen Wang we don\\'t have any value in address table, but we still want that to show it.\\nThis we can do with the help of Left_Table\\n\\n#upvote If you find it helping \\n"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "1. if we will use right join it will select values from 2nd table i.e it will show null,null,leetcode,california .\\n\\n2.if we will use left join then it will focus on 1st table and will show wang,allen,null,null.\\n\\n MySQL query statement below\\nSELECT firstName,lastName,(case when city is Null then null else city end)as city,(case when state is Null then null else state end) as state from Person \\nleft join Address on Person.personId=Address.personId order by firstName;"
                    }
                ]
            },
            {
                "id": 1572390,
                "content": [
                    {
                        "username": "rongy2018",
                        "content": "this is an example of poorly dedesigned relational model. \\nlet personId in the Address table causes data redundency.  in addition\\uFF0C the person table  and address table have  a many to many relationship, therefore a junction table shall be introduced."
                    },
                    {
                        "username": "ya4",
                        "content": "below is my code, if I change inner join instead of left join, it's output is null? why? \\n\\n\\nselect Person.Firstname, Person.lastname,Address.city, Address. state\\n from Person\\nleft join Address\\non Person.PersonId = Address.PersonId"
                    },
                    {
                        "username": "greg6837",
                        "content": "My solution pass the runcode fine, but when I submit it keep saying it\\'s wrong.\\nNeed another pair of eyes to take a look.\\n\\nThank!\\n\\'\\'\\'\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonID = Address.PersonID\\n;\\n\\'\\'\\'"
                    },
                    {
                        "username": "aryandec25",
                        "content": "##### key note here, which type of join to use.\\nSelect A.FirstName,\\nA.LastName, \\nB.City,\\nB.State \\nfrom Person A left JOIN Address B on\\nA.PersonId=B.PersonId"
                    },
                    {
                        "username": "Shadowpii",
                        "content": " `SELECT p.firstName,p.lastName,a.city,a.state\\nFROM Person as p\\nLEFT JOIN Address as a ON p.personId = a.presonId`\\n\\nwhat\\'s wrong with this code"
                    },
                    {
                        "username": "alextsevilla",
                        "content": "As a tip, if you are using CASE, don\\'t write null as a string!! "
                    },
                    {
                        "username": "bhuvanasetty97",
                        "content": "huii"
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": "SELECT [TB_Person].[firstName]\\n      ,[TB_Person].[lastName]\\n      ,[TB_Address].[city]\\n      ,[TB_Address].[state]\\nFROM Person AS [TB_Person]\\nLEFT JOIN [Address] [TB_Address] ON [TB_Address].[personId] = [TB_Person].[personId]"
                    },
                    {
                        "username": "nourlx",
                        "content": "We just need to insert a NULL function.\\nHere is my solution :\\n\\nSELECT\\n    firstName,\\n    lastName,\\n    ISNULL(city, NULL) AS city,\\n    ISNULL(state, NULL) AS state\\nFROM Person \\nLEFT JOIN Address \\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "siddhantvh11",
                        "content": "Seriously why we use left join only??\\nwhy we are not using left join??"
                    }
                ]
            },
            {
                "id": 1571384,
                "content": [
                    {
                        "username": "rongy2018",
                        "content": "this is an example of poorly dedesigned relational model. \\nlet personId in the Address table causes data redundency.  in addition\\uFF0C the person table  and address table have  a many to many relationship, therefore a junction table shall be introduced."
                    },
                    {
                        "username": "ya4",
                        "content": "below is my code, if I change inner join instead of left join, it's output is null? why? \\n\\n\\nselect Person.Firstname, Person.lastname,Address.city, Address. state\\n from Person\\nleft join Address\\non Person.PersonId = Address.PersonId"
                    },
                    {
                        "username": "greg6837",
                        "content": "My solution pass the runcode fine, but when I submit it keep saying it\\'s wrong.\\nNeed another pair of eyes to take a look.\\n\\nThank!\\n\\'\\'\\'\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonID = Address.PersonID\\n;\\n\\'\\'\\'"
                    },
                    {
                        "username": "aryandec25",
                        "content": "##### key note here, which type of join to use.\\nSelect A.FirstName,\\nA.LastName, \\nB.City,\\nB.State \\nfrom Person A left JOIN Address B on\\nA.PersonId=B.PersonId"
                    },
                    {
                        "username": "Shadowpii",
                        "content": " `SELECT p.firstName,p.lastName,a.city,a.state\\nFROM Person as p\\nLEFT JOIN Address as a ON p.personId = a.presonId`\\n\\nwhat\\'s wrong with this code"
                    },
                    {
                        "username": "alextsevilla",
                        "content": "As a tip, if you are using CASE, don\\'t write null as a string!! "
                    },
                    {
                        "username": "bhuvanasetty97",
                        "content": "huii"
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": "SELECT [TB_Person].[firstName]\\n      ,[TB_Person].[lastName]\\n      ,[TB_Address].[city]\\n      ,[TB_Address].[state]\\nFROM Person AS [TB_Person]\\nLEFT JOIN [Address] [TB_Address] ON [TB_Address].[personId] = [TB_Person].[personId]"
                    },
                    {
                        "username": "nourlx",
                        "content": "We just need to insert a NULL function.\\nHere is my solution :\\n\\nSELECT\\n    firstName,\\n    lastName,\\n    ISNULL(city, NULL) AS city,\\n    ISNULL(state, NULL) AS state\\nFROM Person \\nLEFT JOIN Address \\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "siddhantvh11",
                        "content": "Seriously why we use left join only??\\nwhy we are not using left join??"
                    }
                ]
            },
            {
                "id": 1565958,
                "content": [
                    {
                        "username": "rongy2018",
                        "content": "this is an example of poorly dedesigned relational model. \\nlet personId in the Address table causes data redundency.  in addition\\uFF0C the person table  and address table have  a many to many relationship, therefore a junction table shall be introduced."
                    },
                    {
                        "username": "ya4",
                        "content": "below is my code, if I change inner join instead of left join, it's output is null? why? \\n\\n\\nselect Person.Firstname, Person.lastname,Address.city, Address. state\\n from Person\\nleft join Address\\non Person.PersonId = Address.PersonId"
                    },
                    {
                        "username": "greg6837",
                        "content": "My solution pass the runcode fine, but when I submit it keep saying it\\'s wrong.\\nNeed another pair of eyes to take a look.\\n\\nThank!\\n\\'\\'\\'\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonID = Address.PersonID\\n;\\n\\'\\'\\'"
                    },
                    {
                        "username": "aryandec25",
                        "content": "##### key note here, which type of join to use.\\nSelect A.FirstName,\\nA.LastName, \\nB.City,\\nB.State \\nfrom Person A left JOIN Address B on\\nA.PersonId=B.PersonId"
                    },
                    {
                        "username": "Shadowpii",
                        "content": " `SELECT p.firstName,p.lastName,a.city,a.state\\nFROM Person as p\\nLEFT JOIN Address as a ON p.personId = a.presonId`\\n\\nwhat\\'s wrong with this code"
                    },
                    {
                        "username": "alextsevilla",
                        "content": "As a tip, if you are using CASE, don\\'t write null as a string!! "
                    },
                    {
                        "username": "bhuvanasetty97",
                        "content": "huii"
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": "SELECT [TB_Person].[firstName]\\n      ,[TB_Person].[lastName]\\n      ,[TB_Address].[city]\\n      ,[TB_Address].[state]\\nFROM Person AS [TB_Person]\\nLEFT JOIN [Address] [TB_Address] ON [TB_Address].[personId] = [TB_Person].[personId]"
                    },
                    {
                        "username": "nourlx",
                        "content": "We just need to insert a NULL function.\\nHere is my solution :\\n\\nSELECT\\n    firstName,\\n    lastName,\\n    ISNULL(city, NULL) AS city,\\n    ISNULL(state, NULL) AS state\\nFROM Person \\nLEFT JOIN Address \\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "siddhantvh11",
                        "content": "Seriously why we use left join only??\\nwhy we are not using left join??"
                    }
                ]
            },
            {
                "id": 1570804,
                "content": [
                    {
                        "username": "rongy2018",
                        "content": "this is an example of poorly dedesigned relational model. \\nlet personId in the Address table causes data redundency.  in addition\\uFF0C the person table  and address table have  a many to many relationship, therefore a junction table shall be introduced."
                    },
                    {
                        "username": "ya4",
                        "content": "below is my code, if I change inner join instead of left join, it's output is null? why? \\n\\n\\nselect Person.Firstname, Person.lastname,Address.city, Address. state\\n from Person\\nleft join Address\\non Person.PersonId = Address.PersonId"
                    },
                    {
                        "username": "greg6837",
                        "content": "My solution pass the runcode fine, but when I submit it keep saying it\\'s wrong.\\nNeed another pair of eyes to take a look.\\n\\nThank!\\n\\'\\'\\'\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonID = Address.PersonID\\n;\\n\\'\\'\\'"
                    },
                    {
                        "username": "aryandec25",
                        "content": "##### key note here, which type of join to use.\\nSelect A.FirstName,\\nA.LastName, \\nB.City,\\nB.State \\nfrom Person A left JOIN Address B on\\nA.PersonId=B.PersonId"
                    },
                    {
                        "username": "Shadowpii",
                        "content": " `SELECT p.firstName,p.lastName,a.city,a.state\\nFROM Person as p\\nLEFT JOIN Address as a ON p.personId = a.presonId`\\n\\nwhat\\'s wrong with this code"
                    },
                    {
                        "username": "alextsevilla",
                        "content": "As a tip, if you are using CASE, don\\'t write null as a string!! "
                    },
                    {
                        "username": "bhuvanasetty97",
                        "content": "huii"
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": "SELECT [TB_Person].[firstName]\\n      ,[TB_Person].[lastName]\\n      ,[TB_Address].[city]\\n      ,[TB_Address].[state]\\nFROM Person AS [TB_Person]\\nLEFT JOIN [Address] [TB_Address] ON [TB_Address].[personId] = [TB_Person].[personId]"
                    },
                    {
                        "username": "nourlx",
                        "content": "We just need to insert a NULL function.\\nHere is my solution :\\n\\nSELECT\\n    firstName,\\n    lastName,\\n    ISNULL(city, NULL) AS city,\\n    ISNULL(state, NULL) AS state\\nFROM Person \\nLEFT JOIN Address \\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "siddhantvh11",
                        "content": "Seriously why we use left join only??\\nwhy we are not using left join??"
                    }
                ]
            },
            {
                "id": 2073089,
                "content": [
                    {
                        "username": "rongy2018",
                        "content": "this is an example of poorly dedesigned relational model. \\nlet personId in the Address table causes data redundency.  in addition\\uFF0C the person table  and address table have  a many to many relationship, therefore a junction table shall be introduced."
                    },
                    {
                        "username": "ya4",
                        "content": "below is my code, if I change inner join instead of left join, it's output is null? why? \\n\\n\\nselect Person.Firstname, Person.lastname,Address.city, Address. state\\n from Person\\nleft join Address\\non Person.PersonId = Address.PersonId"
                    },
                    {
                        "username": "greg6837",
                        "content": "My solution pass the runcode fine, but when I submit it keep saying it\\'s wrong.\\nNeed another pair of eyes to take a look.\\n\\nThank!\\n\\'\\'\\'\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonID = Address.PersonID\\n;\\n\\'\\'\\'"
                    },
                    {
                        "username": "aryandec25",
                        "content": "##### key note here, which type of join to use.\\nSelect A.FirstName,\\nA.LastName, \\nB.City,\\nB.State \\nfrom Person A left JOIN Address B on\\nA.PersonId=B.PersonId"
                    },
                    {
                        "username": "Shadowpii",
                        "content": " `SELECT p.firstName,p.lastName,a.city,a.state\\nFROM Person as p\\nLEFT JOIN Address as a ON p.personId = a.presonId`\\n\\nwhat\\'s wrong with this code"
                    },
                    {
                        "username": "alextsevilla",
                        "content": "As a tip, if you are using CASE, don\\'t write null as a string!! "
                    },
                    {
                        "username": "bhuvanasetty97",
                        "content": "huii"
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": "SELECT [TB_Person].[firstName]\\n      ,[TB_Person].[lastName]\\n      ,[TB_Address].[city]\\n      ,[TB_Address].[state]\\nFROM Person AS [TB_Person]\\nLEFT JOIN [Address] [TB_Address] ON [TB_Address].[personId] = [TB_Person].[personId]"
                    },
                    {
                        "username": "nourlx",
                        "content": "We just need to insert a NULL function.\\nHere is my solution :\\n\\nSELECT\\n    firstName,\\n    lastName,\\n    ISNULL(city, NULL) AS city,\\n    ISNULL(state, NULL) AS state\\nFROM Person \\nLEFT JOIN Address \\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "siddhantvh11",
                        "content": "Seriously why we use left join only??\\nwhy we are not using left join??"
                    }
                ]
            },
            {
                "id": 2046336,
                "content": [
                    {
                        "username": "rongy2018",
                        "content": "this is an example of poorly dedesigned relational model. \\nlet personId in the Address table causes data redundency.  in addition\\uFF0C the person table  and address table have  a many to many relationship, therefore a junction table shall be introduced."
                    },
                    {
                        "username": "ya4",
                        "content": "below is my code, if I change inner join instead of left join, it's output is null? why? \\n\\n\\nselect Person.Firstname, Person.lastname,Address.city, Address. state\\n from Person\\nleft join Address\\non Person.PersonId = Address.PersonId"
                    },
                    {
                        "username": "greg6837",
                        "content": "My solution pass the runcode fine, but when I submit it keep saying it\\'s wrong.\\nNeed another pair of eyes to take a look.\\n\\nThank!\\n\\'\\'\\'\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonID = Address.PersonID\\n;\\n\\'\\'\\'"
                    },
                    {
                        "username": "aryandec25",
                        "content": "##### key note here, which type of join to use.\\nSelect A.FirstName,\\nA.LastName, \\nB.City,\\nB.State \\nfrom Person A left JOIN Address B on\\nA.PersonId=B.PersonId"
                    },
                    {
                        "username": "Shadowpii",
                        "content": " `SELECT p.firstName,p.lastName,a.city,a.state\\nFROM Person as p\\nLEFT JOIN Address as a ON p.personId = a.presonId`\\n\\nwhat\\'s wrong with this code"
                    },
                    {
                        "username": "alextsevilla",
                        "content": "As a tip, if you are using CASE, don\\'t write null as a string!! "
                    },
                    {
                        "username": "bhuvanasetty97",
                        "content": "huii"
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": "SELECT [TB_Person].[firstName]\\n      ,[TB_Person].[lastName]\\n      ,[TB_Address].[city]\\n      ,[TB_Address].[state]\\nFROM Person AS [TB_Person]\\nLEFT JOIN [Address] [TB_Address] ON [TB_Address].[personId] = [TB_Person].[personId]"
                    },
                    {
                        "username": "nourlx",
                        "content": "We just need to insert a NULL function.\\nHere is my solution :\\n\\nSELECT\\n    firstName,\\n    lastName,\\n    ISNULL(city, NULL) AS city,\\n    ISNULL(state, NULL) AS state\\nFROM Person \\nLEFT JOIN Address \\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "siddhantvh11",
                        "content": "Seriously why we use left join only??\\nwhy we are not using left join??"
                    }
                ]
            },
            {
                "id": 2037918,
                "content": [
                    {
                        "username": "rongy2018",
                        "content": "this is an example of poorly dedesigned relational model. \\nlet personId in the Address table causes data redundency.  in addition\\uFF0C the person table  and address table have  a many to many relationship, therefore a junction table shall be introduced."
                    },
                    {
                        "username": "ya4",
                        "content": "below is my code, if I change inner join instead of left join, it's output is null? why? \\n\\n\\nselect Person.Firstname, Person.lastname,Address.city, Address. state\\n from Person\\nleft join Address\\non Person.PersonId = Address.PersonId"
                    },
                    {
                        "username": "greg6837",
                        "content": "My solution pass the runcode fine, but when I submit it keep saying it\\'s wrong.\\nNeed another pair of eyes to take a look.\\n\\nThank!\\n\\'\\'\\'\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonID = Address.PersonID\\n;\\n\\'\\'\\'"
                    },
                    {
                        "username": "aryandec25",
                        "content": "##### key note here, which type of join to use.\\nSelect A.FirstName,\\nA.LastName, \\nB.City,\\nB.State \\nfrom Person A left JOIN Address B on\\nA.PersonId=B.PersonId"
                    },
                    {
                        "username": "Shadowpii",
                        "content": " `SELECT p.firstName,p.lastName,a.city,a.state\\nFROM Person as p\\nLEFT JOIN Address as a ON p.personId = a.presonId`\\n\\nwhat\\'s wrong with this code"
                    },
                    {
                        "username": "alextsevilla",
                        "content": "As a tip, if you are using CASE, don\\'t write null as a string!! "
                    },
                    {
                        "username": "bhuvanasetty97",
                        "content": "huii"
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": "SELECT [TB_Person].[firstName]\\n      ,[TB_Person].[lastName]\\n      ,[TB_Address].[city]\\n      ,[TB_Address].[state]\\nFROM Person AS [TB_Person]\\nLEFT JOIN [Address] [TB_Address] ON [TB_Address].[personId] = [TB_Person].[personId]"
                    },
                    {
                        "username": "nourlx",
                        "content": "We just need to insert a NULL function.\\nHere is my solution :\\n\\nSELECT\\n    firstName,\\n    lastName,\\n    ISNULL(city, NULL) AS city,\\n    ISNULL(state, NULL) AS state\\nFROM Person \\nLEFT JOIN Address \\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "siddhantvh11",
                        "content": "Seriously why we use left join only??\\nwhy we are not using left join??"
                    }
                ]
            },
            {
                "id": 2015209,
                "content": [
                    {
                        "username": "rongy2018",
                        "content": "this is an example of poorly dedesigned relational model. \\nlet personId in the Address table causes data redundency.  in addition\\uFF0C the person table  and address table have  a many to many relationship, therefore a junction table shall be introduced."
                    },
                    {
                        "username": "ya4",
                        "content": "below is my code, if I change inner join instead of left join, it's output is null? why? \\n\\n\\nselect Person.Firstname, Person.lastname,Address.city, Address. state\\n from Person\\nleft join Address\\non Person.PersonId = Address.PersonId"
                    },
                    {
                        "username": "greg6837",
                        "content": "My solution pass the runcode fine, but when I submit it keep saying it\\'s wrong.\\nNeed another pair of eyes to take a look.\\n\\nThank!\\n\\'\\'\\'\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonID = Address.PersonID\\n;\\n\\'\\'\\'"
                    },
                    {
                        "username": "aryandec25",
                        "content": "##### key note here, which type of join to use.\\nSelect A.FirstName,\\nA.LastName, \\nB.City,\\nB.State \\nfrom Person A left JOIN Address B on\\nA.PersonId=B.PersonId"
                    },
                    {
                        "username": "Shadowpii",
                        "content": " `SELECT p.firstName,p.lastName,a.city,a.state\\nFROM Person as p\\nLEFT JOIN Address as a ON p.personId = a.presonId`\\n\\nwhat\\'s wrong with this code"
                    },
                    {
                        "username": "alextsevilla",
                        "content": "As a tip, if you are using CASE, don\\'t write null as a string!! "
                    },
                    {
                        "username": "bhuvanasetty97",
                        "content": "huii"
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": "SELECT [TB_Person].[firstName]\\n      ,[TB_Person].[lastName]\\n      ,[TB_Address].[city]\\n      ,[TB_Address].[state]\\nFROM Person AS [TB_Person]\\nLEFT JOIN [Address] [TB_Address] ON [TB_Address].[personId] = [TB_Person].[personId]"
                    },
                    {
                        "username": "nourlx",
                        "content": "We just need to insert a NULL function.\\nHere is my solution :\\n\\nSELECT\\n    firstName,\\n    lastName,\\n    ISNULL(city, NULL) AS city,\\n    ISNULL(state, NULL) AS state\\nFROM Person \\nLEFT JOIN Address \\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "siddhantvh11",
                        "content": "Seriously why we use left join only??\\nwhy we are not using left join??"
                    }
                ]
            },
            {
                "id": 2006296,
                "content": [
                    {
                        "username": "rongy2018",
                        "content": "this is an example of poorly dedesigned relational model. \\nlet personId in the Address table causes data redundency.  in addition\\uFF0C the person table  and address table have  a many to many relationship, therefore a junction table shall be introduced."
                    },
                    {
                        "username": "ya4",
                        "content": "below is my code, if I change inner join instead of left join, it's output is null? why? \\n\\n\\nselect Person.Firstname, Person.lastname,Address.city, Address. state\\n from Person\\nleft join Address\\non Person.PersonId = Address.PersonId"
                    },
                    {
                        "username": "greg6837",
                        "content": "My solution pass the runcode fine, but when I submit it keep saying it\\'s wrong.\\nNeed another pair of eyes to take a look.\\n\\nThank!\\n\\'\\'\\'\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonID = Address.PersonID\\n;\\n\\'\\'\\'"
                    },
                    {
                        "username": "aryandec25",
                        "content": "##### key note here, which type of join to use.\\nSelect A.FirstName,\\nA.LastName, \\nB.City,\\nB.State \\nfrom Person A left JOIN Address B on\\nA.PersonId=B.PersonId"
                    },
                    {
                        "username": "Shadowpii",
                        "content": " `SELECT p.firstName,p.lastName,a.city,a.state\\nFROM Person as p\\nLEFT JOIN Address as a ON p.personId = a.presonId`\\n\\nwhat\\'s wrong with this code"
                    },
                    {
                        "username": "alextsevilla",
                        "content": "As a tip, if you are using CASE, don\\'t write null as a string!! "
                    },
                    {
                        "username": "bhuvanasetty97",
                        "content": "huii"
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": "SELECT [TB_Person].[firstName]\\n      ,[TB_Person].[lastName]\\n      ,[TB_Address].[city]\\n      ,[TB_Address].[state]\\nFROM Person AS [TB_Person]\\nLEFT JOIN [Address] [TB_Address] ON [TB_Address].[personId] = [TB_Person].[personId]"
                    },
                    {
                        "username": "nourlx",
                        "content": "We just need to insert a NULL function.\\nHere is my solution :\\n\\nSELECT\\n    firstName,\\n    lastName,\\n    ISNULL(city, NULL) AS city,\\n    ISNULL(state, NULL) AS state\\nFROM Person \\nLEFT JOIN Address \\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "siddhantvh11",
                        "content": "Seriously why we use left join only??\\nwhy we are not using left join??"
                    }
                ]
            },
            {
                "id": 2000411,
                "content": [
                    {
                        "username": "rongy2018",
                        "content": "this is an example of poorly dedesigned relational model. \\nlet personId in the Address table causes data redundency.  in addition\\uFF0C the person table  and address table have  a many to many relationship, therefore a junction table shall be introduced."
                    },
                    {
                        "username": "ya4",
                        "content": "below is my code, if I change inner join instead of left join, it's output is null? why? \\n\\n\\nselect Person.Firstname, Person.lastname,Address.city, Address. state\\n from Person\\nleft join Address\\non Person.PersonId = Address.PersonId"
                    },
                    {
                        "username": "greg6837",
                        "content": "My solution pass the runcode fine, but when I submit it keep saying it\\'s wrong.\\nNeed another pair of eyes to take a look.\\n\\nThank!\\n\\'\\'\\'\\nSELECT FirstName, LastName, City, State\\nFROM Person\\nLEFT JOIN Address\\nON Person.PersonID = Address.PersonID\\n;\\n\\'\\'\\'"
                    },
                    {
                        "username": "aryandec25",
                        "content": "##### key note here, which type of join to use.\\nSelect A.FirstName,\\nA.LastName, \\nB.City,\\nB.State \\nfrom Person A left JOIN Address B on\\nA.PersonId=B.PersonId"
                    },
                    {
                        "username": "Shadowpii",
                        "content": " `SELECT p.firstName,p.lastName,a.city,a.state\\nFROM Person as p\\nLEFT JOIN Address as a ON p.personId = a.presonId`\\n\\nwhat\\'s wrong with this code"
                    },
                    {
                        "username": "alextsevilla",
                        "content": "As a tip, if you are using CASE, don\\'t write null as a string!! "
                    },
                    {
                        "username": "bhuvanasetty97",
                        "content": "huii"
                    },
                    {
                        "username": "guilhermelinosp",
                        "content": "SELECT [TB_Person].[firstName]\\n      ,[TB_Person].[lastName]\\n      ,[TB_Address].[city]\\n      ,[TB_Address].[state]\\nFROM Person AS [TB_Person]\\nLEFT JOIN [Address] [TB_Address] ON [TB_Address].[personId] = [TB_Person].[personId]"
                    },
                    {
                        "username": "nourlx",
                        "content": "We just need to insert a NULL function.\\nHere is my solution :\\n\\nSELECT\\n    firstName,\\n    lastName,\\n    ISNULL(city, NULL) AS city,\\n    ISNULL(state, NULL) AS state\\nFROM Person \\nLEFT JOIN Address \\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "siddhantvh11",
                        "content": "Seriously why we use left join only??\\nwhy we are not using left join??"
                    }
                ]
            },
            {
                "id": 1966884,
                "content": [
                    {
                        "username": "Sanjeevbk123",
                        "content": "SELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personIdSELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personId"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste\\n"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "KuoDarren",
                        "content": "SELECT\\nfirstName,\\nlastName,\\nIFNULL(city,null) as city,\\nIFNULL(state,null) as state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "Savithri_Hariharan7",
                        "content": "select p.firstName,p.lastName,a.city,a.state from Person p, Address a where p.personId=a.personId"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "First query returns the same output as expected, yet it is not getting accepted. The Second on gets accepted. Could somebody tell me why the first one is not acceptable?\\n\\n# Doesn\\'t get accepted\\n`SELECT p.firstName, p.lastName, IFNULL(a.city, \\'null\\') as city, IFNULL(a.state, \\'null\\') as state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`\\n# Accepted\\n`SELECT p.firstName, p.lastName, a.city, a.state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`"
                    },
                    {
                        "username": "shadab1",
                        "content": "can you guys help me here and tell me , where am I wrong in this query  : \\n\\nSelect\\nperson.firstname as \\'First name\\',\\nperson.lastname as \\'Last name\\',\\naddress.city as \\'City\\',\\naddress.state as \\'State\\'\\nfrom\\nperson \\nleft join\\naddress\\non\\nperson.personId = address.personId\\norder by\\nfirstname \\n\\n"
                    },
                    {
                        "username": "Linco011",
                        "content": "SELECT firstName,lastName,city,state FROM person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;"
                    },
                    {
                        "username": "user5290DC",
                        "content": "Hello guys, i\\'m recieving this error message and i don\\'t know what to do:\\n\\n\"SELECT command denied to user \\'student\\'@\\'localhost\\' for table \\'p\\'\""
                    }
                ]
            },
            {
                "id": 1950889,
                "content": [
                    {
                        "username": "Sanjeevbk123",
                        "content": "SELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personIdSELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personId"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste\\n"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "KuoDarren",
                        "content": "SELECT\\nfirstName,\\nlastName,\\nIFNULL(city,null) as city,\\nIFNULL(state,null) as state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "Savithri_Hariharan7",
                        "content": "select p.firstName,p.lastName,a.city,a.state from Person p, Address a where p.personId=a.personId"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "First query returns the same output as expected, yet it is not getting accepted. The Second on gets accepted. Could somebody tell me why the first one is not acceptable?\\n\\n# Doesn\\'t get accepted\\n`SELECT p.firstName, p.lastName, IFNULL(a.city, \\'null\\') as city, IFNULL(a.state, \\'null\\') as state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`\\n# Accepted\\n`SELECT p.firstName, p.lastName, a.city, a.state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`"
                    },
                    {
                        "username": "shadab1",
                        "content": "can you guys help me here and tell me , where am I wrong in this query  : \\n\\nSelect\\nperson.firstname as \\'First name\\',\\nperson.lastname as \\'Last name\\',\\naddress.city as \\'City\\',\\naddress.state as \\'State\\'\\nfrom\\nperson \\nleft join\\naddress\\non\\nperson.personId = address.personId\\norder by\\nfirstname \\n\\n"
                    },
                    {
                        "username": "Linco011",
                        "content": "SELECT firstName,lastName,city,state FROM person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;"
                    },
                    {
                        "username": "user5290DC",
                        "content": "Hello guys, i\\'m recieving this error message and i don\\'t know what to do:\\n\\n\"SELECT command denied to user \\'student\\'@\\'localhost\\' for table \\'p\\'\""
                    }
                ]
            },
            {
                "id": 1949143,
                "content": [
                    {
                        "username": "Sanjeevbk123",
                        "content": "SELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personIdSELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personId"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste\\n"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "KuoDarren",
                        "content": "SELECT\\nfirstName,\\nlastName,\\nIFNULL(city,null) as city,\\nIFNULL(state,null) as state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "Savithri_Hariharan7",
                        "content": "select p.firstName,p.lastName,a.city,a.state from Person p, Address a where p.personId=a.personId"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "First query returns the same output as expected, yet it is not getting accepted. The Second on gets accepted. Could somebody tell me why the first one is not acceptable?\\n\\n# Doesn\\'t get accepted\\n`SELECT p.firstName, p.lastName, IFNULL(a.city, \\'null\\') as city, IFNULL(a.state, \\'null\\') as state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`\\n# Accepted\\n`SELECT p.firstName, p.lastName, a.city, a.state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`"
                    },
                    {
                        "username": "shadab1",
                        "content": "can you guys help me here and tell me , where am I wrong in this query  : \\n\\nSelect\\nperson.firstname as \\'First name\\',\\nperson.lastname as \\'Last name\\',\\naddress.city as \\'City\\',\\naddress.state as \\'State\\'\\nfrom\\nperson \\nleft join\\naddress\\non\\nperson.personId = address.personId\\norder by\\nfirstname \\n\\n"
                    },
                    {
                        "username": "Linco011",
                        "content": "SELECT firstName,lastName,city,state FROM person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;"
                    },
                    {
                        "username": "user5290DC",
                        "content": "Hello guys, i\\'m recieving this error message and i don\\'t know what to do:\\n\\n\"SELECT command denied to user \\'student\\'@\\'localhost\\' for table \\'p\\'\""
                    }
                ]
            },
            {
                "id": 1948266,
                "content": [
                    {
                        "username": "Sanjeevbk123",
                        "content": "SELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personIdSELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personId"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste\\n"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "KuoDarren",
                        "content": "SELECT\\nfirstName,\\nlastName,\\nIFNULL(city,null) as city,\\nIFNULL(state,null) as state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "Savithri_Hariharan7",
                        "content": "select p.firstName,p.lastName,a.city,a.state from Person p, Address a where p.personId=a.personId"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "First query returns the same output as expected, yet it is not getting accepted. The Second on gets accepted. Could somebody tell me why the first one is not acceptable?\\n\\n# Doesn\\'t get accepted\\n`SELECT p.firstName, p.lastName, IFNULL(a.city, \\'null\\') as city, IFNULL(a.state, \\'null\\') as state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`\\n# Accepted\\n`SELECT p.firstName, p.lastName, a.city, a.state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`"
                    },
                    {
                        "username": "shadab1",
                        "content": "can you guys help me here and tell me , where am I wrong in this query  : \\n\\nSelect\\nperson.firstname as \\'First name\\',\\nperson.lastname as \\'Last name\\',\\naddress.city as \\'City\\',\\naddress.state as \\'State\\'\\nfrom\\nperson \\nleft join\\naddress\\non\\nperson.personId = address.personId\\norder by\\nfirstname \\n\\n"
                    },
                    {
                        "username": "Linco011",
                        "content": "SELECT firstName,lastName,city,state FROM person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;"
                    },
                    {
                        "username": "user5290DC",
                        "content": "Hello guys, i\\'m recieving this error message and i don\\'t know what to do:\\n\\n\"SELECT command denied to user \\'student\\'@\\'localhost\\' for table \\'p\\'\""
                    }
                ]
            },
            {
                "id": 1917603,
                "content": [
                    {
                        "username": "Sanjeevbk123",
                        "content": "SELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personIdSELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personId"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste\\n"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "KuoDarren",
                        "content": "SELECT\\nfirstName,\\nlastName,\\nIFNULL(city,null) as city,\\nIFNULL(state,null) as state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "Savithri_Hariharan7",
                        "content": "select p.firstName,p.lastName,a.city,a.state from Person p, Address a where p.personId=a.personId"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "First query returns the same output as expected, yet it is not getting accepted. The Second on gets accepted. Could somebody tell me why the first one is not acceptable?\\n\\n# Doesn\\'t get accepted\\n`SELECT p.firstName, p.lastName, IFNULL(a.city, \\'null\\') as city, IFNULL(a.state, \\'null\\') as state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`\\n# Accepted\\n`SELECT p.firstName, p.lastName, a.city, a.state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`"
                    },
                    {
                        "username": "shadab1",
                        "content": "can you guys help me here and tell me , where am I wrong in this query  : \\n\\nSelect\\nperson.firstname as \\'First name\\',\\nperson.lastname as \\'Last name\\',\\naddress.city as \\'City\\',\\naddress.state as \\'State\\'\\nfrom\\nperson \\nleft join\\naddress\\non\\nperson.personId = address.personId\\norder by\\nfirstname \\n\\n"
                    },
                    {
                        "username": "Linco011",
                        "content": "SELECT firstName,lastName,city,state FROM person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;"
                    },
                    {
                        "username": "user5290DC",
                        "content": "Hello guys, i\\'m recieving this error message and i don\\'t know what to do:\\n\\n\"SELECT command denied to user \\'student\\'@\\'localhost\\' for table \\'p\\'\""
                    }
                ]
            },
            {
                "id": 1915047,
                "content": [
                    {
                        "username": "Sanjeevbk123",
                        "content": "SELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personIdSELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personId"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste\\n"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "KuoDarren",
                        "content": "SELECT\\nfirstName,\\nlastName,\\nIFNULL(city,null) as city,\\nIFNULL(state,null) as state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "Savithri_Hariharan7",
                        "content": "select p.firstName,p.lastName,a.city,a.state from Person p, Address a where p.personId=a.personId"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "First query returns the same output as expected, yet it is not getting accepted. The Second on gets accepted. Could somebody tell me why the first one is not acceptable?\\n\\n# Doesn\\'t get accepted\\n`SELECT p.firstName, p.lastName, IFNULL(a.city, \\'null\\') as city, IFNULL(a.state, \\'null\\') as state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`\\n# Accepted\\n`SELECT p.firstName, p.lastName, a.city, a.state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`"
                    },
                    {
                        "username": "shadab1",
                        "content": "can you guys help me here and tell me , where am I wrong in this query  : \\n\\nSelect\\nperson.firstname as \\'First name\\',\\nperson.lastname as \\'Last name\\',\\naddress.city as \\'City\\',\\naddress.state as \\'State\\'\\nfrom\\nperson \\nleft join\\naddress\\non\\nperson.personId = address.personId\\norder by\\nfirstname \\n\\n"
                    },
                    {
                        "username": "Linco011",
                        "content": "SELECT firstName,lastName,city,state FROM person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;"
                    },
                    {
                        "username": "user5290DC",
                        "content": "Hello guys, i\\'m recieving this error message and i don\\'t know what to do:\\n\\n\"SELECT command denied to user \\'student\\'@\\'localhost\\' for table \\'p\\'\""
                    }
                ]
            },
            {
                "id": 1896290,
                "content": [
                    {
                        "username": "Sanjeevbk123",
                        "content": "SELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personIdSELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personId"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste\\n"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "KuoDarren",
                        "content": "SELECT\\nfirstName,\\nlastName,\\nIFNULL(city,null) as city,\\nIFNULL(state,null) as state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "Savithri_Hariharan7",
                        "content": "select p.firstName,p.lastName,a.city,a.state from Person p, Address a where p.personId=a.personId"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "First query returns the same output as expected, yet it is not getting accepted. The Second on gets accepted. Could somebody tell me why the first one is not acceptable?\\n\\n# Doesn\\'t get accepted\\n`SELECT p.firstName, p.lastName, IFNULL(a.city, \\'null\\') as city, IFNULL(a.state, \\'null\\') as state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`\\n# Accepted\\n`SELECT p.firstName, p.lastName, a.city, a.state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`"
                    },
                    {
                        "username": "shadab1",
                        "content": "can you guys help me here and tell me , where am I wrong in this query  : \\n\\nSelect\\nperson.firstname as \\'First name\\',\\nperson.lastname as \\'Last name\\',\\naddress.city as \\'City\\',\\naddress.state as \\'State\\'\\nfrom\\nperson \\nleft join\\naddress\\non\\nperson.personId = address.personId\\norder by\\nfirstname \\n\\n"
                    },
                    {
                        "username": "Linco011",
                        "content": "SELECT firstName,lastName,city,state FROM person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;"
                    },
                    {
                        "username": "user5290DC",
                        "content": "Hello guys, i\\'m recieving this error message and i don\\'t know what to do:\\n\\n\"SELECT command denied to user \\'student\\'@\\'localhost\\' for table \\'p\\'\""
                    }
                ]
            },
            {
                "id": 1883402,
                "content": [
                    {
                        "username": "Sanjeevbk123",
                        "content": "SELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personIdSELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personId"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste\\n"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "KuoDarren",
                        "content": "SELECT\\nfirstName,\\nlastName,\\nIFNULL(city,null) as city,\\nIFNULL(state,null) as state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "Savithri_Hariharan7",
                        "content": "select p.firstName,p.lastName,a.city,a.state from Person p, Address a where p.personId=a.personId"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "First query returns the same output as expected, yet it is not getting accepted. The Second on gets accepted. Could somebody tell me why the first one is not acceptable?\\n\\n# Doesn\\'t get accepted\\n`SELECT p.firstName, p.lastName, IFNULL(a.city, \\'null\\') as city, IFNULL(a.state, \\'null\\') as state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`\\n# Accepted\\n`SELECT p.firstName, p.lastName, a.city, a.state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`"
                    },
                    {
                        "username": "shadab1",
                        "content": "can you guys help me here and tell me , where am I wrong in this query  : \\n\\nSelect\\nperson.firstname as \\'First name\\',\\nperson.lastname as \\'Last name\\',\\naddress.city as \\'City\\',\\naddress.state as \\'State\\'\\nfrom\\nperson \\nleft join\\naddress\\non\\nperson.personId = address.personId\\norder by\\nfirstname \\n\\n"
                    },
                    {
                        "username": "Linco011",
                        "content": "SELECT firstName,lastName,city,state FROM person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;"
                    },
                    {
                        "username": "user5290DC",
                        "content": "Hello guys, i\\'m recieving this error message and i don\\'t know what to do:\\n\\n\"SELECT command denied to user \\'student\\'@\\'localhost\\' for table \\'p\\'\""
                    }
                ]
            },
            {
                "id": 1870399,
                "content": [
                    {
                        "username": "Sanjeevbk123",
                        "content": "SELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personIdSELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personId"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste\\n"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "KuoDarren",
                        "content": "SELECT\\nfirstName,\\nlastName,\\nIFNULL(city,null) as city,\\nIFNULL(state,null) as state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "Savithri_Hariharan7",
                        "content": "select p.firstName,p.lastName,a.city,a.state from Person p, Address a where p.personId=a.personId"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "First query returns the same output as expected, yet it is not getting accepted. The Second on gets accepted. Could somebody tell me why the first one is not acceptable?\\n\\n# Doesn\\'t get accepted\\n`SELECT p.firstName, p.lastName, IFNULL(a.city, \\'null\\') as city, IFNULL(a.state, \\'null\\') as state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`\\n# Accepted\\n`SELECT p.firstName, p.lastName, a.city, a.state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`"
                    },
                    {
                        "username": "shadab1",
                        "content": "can you guys help me here and tell me , where am I wrong in this query  : \\n\\nSelect\\nperson.firstname as \\'First name\\',\\nperson.lastname as \\'Last name\\',\\naddress.city as \\'City\\',\\naddress.state as \\'State\\'\\nfrom\\nperson \\nleft join\\naddress\\non\\nperson.personId = address.personId\\norder by\\nfirstname \\n\\n"
                    },
                    {
                        "username": "Linco011",
                        "content": "SELECT firstName,lastName,city,state FROM person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;"
                    },
                    {
                        "username": "user5290DC",
                        "content": "Hello guys, i\\'m recieving this error message and i don\\'t know what to do:\\n\\n\"SELECT command denied to user \\'student\\'@\\'localhost\\' for table \\'p\\'\""
                    }
                ]
            },
            {
                "id": 1867628,
                "content": [
                    {
                        "username": "Sanjeevbk123",
                        "content": "SELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personIdSELECT a.firstName, a.lastName, b.city, b.state\\nfrom Person a\\nleft join Address b\\non a.personId=b.personId"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste\\n"
                    },
                    {
                        "username": "yancerqueira",
                        "content": "teste"
                    },
                    {
                        "username": "KuoDarren",
                        "content": "SELECT\\nfirstName,\\nlastName,\\nIFNULL(city,null) as city,\\nIFNULL(state,null) as state\\nFROM Person\\nLEFT JOIN Address\\nON Person.personId = Address.personId"
                    },
                    {
                        "username": "Savithri_Hariharan7",
                        "content": "select p.firstName,p.lastName,a.city,a.state from Person p, Address a where p.personId=a.personId"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "First query returns the same output as expected, yet it is not getting accepted. The Second on gets accepted. Could somebody tell me why the first one is not acceptable?\\n\\n# Doesn\\'t get accepted\\n`SELECT p.firstName, p.lastName, IFNULL(a.city, \\'null\\') as city, IFNULL(a.state, \\'null\\') as state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`\\n# Accepted\\n`SELECT p.firstName, p.lastName, a.city, a.state from Person p LEFT JOIN Address a ON p.personId = a.personId;\\n`"
                    },
                    {
                        "username": "shadab1",
                        "content": "can you guys help me here and tell me , where am I wrong in this query  : \\n\\nSelect\\nperson.firstname as \\'First name\\',\\nperson.lastname as \\'Last name\\',\\naddress.city as \\'City\\',\\naddress.state as \\'State\\'\\nfrom\\nperson \\nleft join\\naddress\\non\\nperson.personId = address.personId\\norder by\\nfirstname \\n\\n"
                    },
                    {
                        "username": "Linco011",
                        "content": "SELECT firstName,lastName,city,state FROM person\\nLEFT JOIN Address\\nON Person.personId = Address.personId;"
                    },
                    {
                        "username": "user5290DC",
                        "content": "Hello guys, i\\'m recieving this error message and i don\\'t know what to do:\\n\\n\"SELECT command denied to user \\'student\\'@\\'localhost\\' for table \\'p\\'\""
                    }
                ]
            },
            {
                "id": 1859865,
                "content": [
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the solution that I wrote,\\nselect P.FirstName,P.LastName,A.City,A.State from Person as P left outer join Address as A ON P.PersonId=A.PersonId"
                    },
                    {
                        "username": "HasanFarazi1234",
                        "content": " `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "gokulpilot007",
                        "content": "why we are not using foreign key ??using foreign key also we get the same output but i dont know how to make it"
                    },
                    {
                        "username": "Babul955719",
                        "content": "select  firstName, lastName , city , state\\nfrom  Person \\nleft join Address\\non Person.personId = Address.personId - finally got it after trying 4 times , i am begineer in SQL"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "SELECT p.lastName, p.firstName, a.city,a.state \\nFROM Person p \\nLEFT JOIN Address a \\nON p.personId=a.personId;"
                    },
                    {
                        "username": "8500423404",
                        "content": "select p.firstName,p.lastName,a.state,a.city \\nfrom Person p\\nleft join Address a \\non p.personId = a.personId"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "SELECT firstName, \\nlastName, \\nIF(city IS NOT NULL, city, \\'null\\') AS city, \\nIF(state IS NOT NULL, state, \\'null\\') AS state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\nI get expected output, test isn\\'t validated :O! Maybe I\\'ve stared at a screen too long for today.."
                    },
                    {
                        "username": "rkdapp",
                        "content": "\\nThis would be the best way\\n\\nselect p.firstName,p.lastName,a.city,a.state\\nfrom person p\\nleft JOIN Address a ON p.PersonId = a.PersonId"
                    },
                    {
                        "username": "Doctorma999",
                        "content": "Select p.firstName, p.lastName, a.city, a.state from Person p\\nLeft join Address a on p.personId=a.addressId\\n\\nRan this and got the wrong output, the city column shows as \\'Leetcode\\' instead of null. How do I report a null value if the column text isn\\'t correct?"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select firstName, lastName, city, state from person as p LEFT JOIN  Address as a\\non p.personId = a.personId"
                    }
                ]
            },
            {
                "id": 1857333,
                "content": [
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the solution that I wrote,\\nselect P.FirstName,P.LastName,A.City,A.State from Person as P left outer join Address as A ON P.PersonId=A.PersonId"
                    },
                    {
                        "username": "HasanFarazi1234",
                        "content": " `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "gokulpilot007",
                        "content": "why we are not using foreign key ??using foreign key also we get the same output but i dont know how to make it"
                    },
                    {
                        "username": "Babul955719",
                        "content": "select  firstName, lastName , city , state\\nfrom  Person \\nleft join Address\\non Person.personId = Address.personId - finally got it after trying 4 times , i am begineer in SQL"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "SELECT p.lastName, p.firstName, a.city,a.state \\nFROM Person p \\nLEFT JOIN Address a \\nON p.personId=a.personId;"
                    },
                    {
                        "username": "8500423404",
                        "content": "select p.firstName,p.lastName,a.state,a.city \\nfrom Person p\\nleft join Address a \\non p.personId = a.personId"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "SELECT firstName, \\nlastName, \\nIF(city IS NOT NULL, city, \\'null\\') AS city, \\nIF(state IS NOT NULL, state, \\'null\\') AS state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\nI get expected output, test isn\\'t validated :O! Maybe I\\'ve stared at a screen too long for today.."
                    },
                    {
                        "username": "rkdapp",
                        "content": "\\nThis would be the best way\\n\\nselect p.firstName,p.lastName,a.city,a.state\\nfrom person p\\nleft JOIN Address a ON p.PersonId = a.PersonId"
                    },
                    {
                        "username": "Doctorma999",
                        "content": "Select p.firstName, p.lastName, a.city, a.state from Person p\\nLeft join Address a on p.personId=a.addressId\\n\\nRan this and got the wrong output, the city column shows as \\'Leetcode\\' instead of null. How do I report a null value if the column text isn\\'t correct?"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select firstName, lastName, city, state from person as p LEFT JOIN  Address as a\\non p.personId = a.personId"
                    }
                ]
            },
            {
                "id": 1853216,
                "content": [
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the solution that I wrote,\\nselect P.FirstName,P.LastName,A.City,A.State from Person as P left outer join Address as A ON P.PersonId=A.PersonId"
                    },
                    {
                        "username": "HasanFarazi1234",
                        "content": " `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "gokulpilot007",
                        "content": "why we are not using foreign key ??using foreign key also we get the same output but i dont know how to make it"
                    },
                    {
                        "username": "Babul955719",
                        "content": "select  firstName, lastName , city , state\\nfrom  Person \\nleft join Address\\non Person.personId = Address.personId - finally got it after trying 4 times , i am begineer in SQL"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "SELECT p.lastName, p.firstName, a.city,a.state \\nFROM Person p \\nLEFT JOIN Address a \\nON p.personId=a.personId;"
                    },
                    {
                        "username": "8500423404",
                        "content": "select p.firstName,p.lastName,a.state,a.city \\nfrom Person p\\nleft join Address a \\non p.personId = a.personId"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "SELECT firstName, \\nlastName, \\nIF(city IS NOT NULL, city, \\'null\\') AS city, \\nIF(state IS NOT NULL, state, \\'null\\') AS state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\nI get expected output, test isn\\'t validated :O! Maybe I\\'ve stared at a screen too long for today.."
                    },
                    {
                        "username": "rkdapp",
                        "content": "\\nThis would be the best way\\n\\nselect p.firstName,p.lastName,a.city,a.state\\nfrom person p\\nleft JOIN Address a ON p.PersonId = a.PersonId"
                    },
                    {
                        "username": "Doctorma999",
                        "content": "Select p.firstName, p.lastName, a.city, a.state from Person p\\nLeft join Address a on p.personId=a.addressId\\n\\nRan this and got the wrong output, the city column shows as \\'Leetcode\\' instead of null. How do I report a null value if the column text isn\\'t correct?"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select firstName, lastName, city, state from person as p LEFT JOIN  Address as a\\non p.personId = a.personId"
                    }
                ]
            },
            {
                "id": 1848687,
                "content": [
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the solution that I wrote,\\nselect P.FirstName,P.LastName,A.City,A.State from Person as P left outer join Address as A ON P.PersonId=A.PersonId"
                    },
                    {
                        "username": "HasanFarazi1234",
                        "content": " `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "gokulpilot007",
                        "content": "why we are not using foreign key ??using foreign key also we get the same output but i dont know how to make it"
                    },
                    {
                        "username": "Babul955719",
                        "content": "select  firstName, lastName , city , state\\nfrom  Person \\nleft join Address\\non Person.personId = Address.personId - finally got it after trying 4 times , i am begineer in SQL"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "SELECT p.lastName, p.firstName, a.city,a.state \\nFROM Person p \\nLEFT JOIN Address a \\nON p.personId=a.personId;"
                    },
                    {
                        "username": "8500423404",
                        "content": "select p.firstName,p.lastName,a.state,a.city \\nfrom Person p\\nleft join Address a \\non p.personId = a.personId"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "SELECT firstName, \\nlastName, \\nIF(city IS NOT NULL, city, \\'null\\') AS city, \\nIF(state IS NOT NULL, state, \\'null\\') AS state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\nI get expected output, test isn\\'t validated :O! Maybe I\\'ve stared at a screen too long for today.."
                    },
                    {
                        "username": "rkdapp",
                        "content": "\\nThis would be the best way\\n\\nselect p.firstName,p.lastName,a.city,a.state\\nfrom person p\\nleft JOIN Address a ON p.PersonId = a.PersonId"
                    },
                    {
                        "username": "Doctorma999",
                        "content": "Select p.firstName, p.lastName, a.city, a.state from Person p\\nLeft join Address a on p.personId=a.addressId\\n\\nRan this and got the wrong output, the city column shows as \\'Leetcode\\' instead of null. How do I report a null value if the column text isn\\'t correct?"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select firstName, lastName, city, state from person as p LEFT JOIN  Address as a\\non p.personId = a.personId"
                    }
                ]
            },
            {
                "id": 1844180,
                "content": [
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the solution that I wrote,\\nselect P.FirstName,P.LastName,A.City,A.State from Person as P left outer join Address as A ON P.PersonId=A.PersonId"
                    },
                    {
                        "username": "HasanFarazi1234",
                        "content": " `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "gokulpilot007",
                        "content": "why we are not using foreign key ??using foreign key also we get the same output but i dont know how to make it"
                    },
                    {
                        "username": "Babul955719",
                        "content": "select  firstName, lastName , city , state\\nfrom  Person \\nleft join Address\\non Person.personId = Address.personId - finally got it after trying 4 times , i am begineer in SQL"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "SELECT p.lastName, p.firstName, a.city,a.state \\nFROM Person p \\nLEFT JOIN Address a \\nON p.personId=a.personId;"
                    },
                    {
                        "username": "8500423404",
                        "content": "select p.firstName,p.lastName,a.state,a.city \\nfrom Person p\\nleft join Address a \\non p.personId = a.personId"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "SELECT firstName, \\nlastName, \\nIF(city IS NOT NULL, city, \\'null\\') AS city, \\nIF(state IS NOT NULL, state, \\'null\\') AS state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\nI get expected output, test isn\\'t validated :O! Maybe I\\'ve stared at a screen too long for today.."
                    },
                    {
                        "username": "rkdapp",
                        "content": "\\nThis would be the best way\\n\\nselect p.firstName,p.lastName,a.city,a.state\\nfrom person p\\nleft JOIN Address a ON p.PersonId = a.PersonId"
                    },
                    {
                        "username": "Doctorma999",
                        "content": "Select p.firstName, p.lastName, a.city, a.state from Person p\\nLeft join Address a on p.personId=a.addressId\\n\\nRan this and got the wrong output, the city column shows as \\'Leetcode\\' instead of null. How do I report a null value if the column text isn\\'t correct?"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select firstName, lastName, city, state from person as p LEFT JOIN  Address as a\\non p.personId = a.personId"
                    }
                ]
            },
            {
                "id": 1834992,
                "content": [
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the solution that I wrote,\\nselect P.FirstName,P.LastName,A.City,A.State from Person as P left outer join Address as A ON P.PersonId=A.PersonId"
                    },
                    {
                        "username": "HasanFarazi1234",
                        "content": " `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "gokulpilot007",
                        "content": "why we are not using foreign key ??using foreign key also we get the same output but i dont know how to make it"
                    },
                    {
                        "username": "Babul955719",
                        "content": "select  firstName, lastName , city , state\\nfrom  Person \\nleft join Address\\non Person.personId = Address.personId - finally got it after trying 4 times , i am begineer in SQL"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "SELECT p.lastName, p.firstName, a.city,a.state \\nFROM Person p \\nLEFT JOIN Address a \\nON p.personId=a.personId;"
                    },
                    {
                        "username": "8500423404",
                        "content": "select p.firstName,p.lastName,a.state,a.city \\nfrom Person p\\nleft join Address a \\non p.personId = a.personId"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "SELECT firstName, \\nlastName, \\nIF(city IS NOT NULL, city, \\'null\\') AS city, \\nIF(state IS NOT NULL, state, \\'null\\') AS state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\nI get expected output, test isn\\'t validated :O! Maybe I\\'ve stared at a screen too long for today.."
                    },
                    {
                        "username": "rkdapp",
                        "content": "\\nThis would be the best way\\n\\nselect p.firstName,p.lastName,a.city,a.state\\nfrom person p\\nleft JOIN Address a ON p.PersonId = a.PersonId"
                    },
                    {
                        "username": "Doctorma999",
                        "content": "Select p.firstName, p.lastName, a.city, a.state from Person p\\nLeft join Address a on p.personId=a.addressId\\n\\nRan this and got the wrong output, the city column shows as \\'Leetcode\\' instead of null. How do I report a null value if the column text isn\\'t correct?"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select firstName, lastName, city, state from person as p LEFT JOIN  Address as a\\non p.personId = a.personId"
                    }
                ]
            },
            {
                "id": 1820656,
                "content": [
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the solution that I wrote,\\nselect P.FirstName,P.LastName,A.City,A.State from Person as P left outer join Address as A ON P.PersonId=A.PersonId"
                    },
                    {
                        "username": "HasanFarazi1234",
                        "content": " `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "gokulpilot007",
                        "content": "why we are not using foreign key ??using foreign key also we get the same output but i dont know how to make it"
                    },
                    {
                        "username": "Babul955719",
                        "content": "select  firstName, lastName , city , state\\nfrom  Person \\nleft join Address\\non Person.personId = Address.personId - finally got it after trying 4 times , i am begineer in SQL"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "SELECT p.lastName, p.firstName, a.city,a.state \\nFROM Person p \\nLEFT JOIN Address a \\nON p.personId=a.personId;"
                    },
                    {
                        "username": "8500423404",
                        "content": "select p.firstName,p.lastName,a.state,a.city \\nfrom Person p\\nleft join Address a \\non p.personId = a.personId"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "SELECT firstName, \\nlastName, \\nIF(city IS NOT NULL, city, \\'null\\') AS city, \\nIF(state IS NOT NULL, state, \\'null\\') AS state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\nI get expected output, test isn\\'t validated :O! Maybe I\\'ve stared at a screen too long for today.."
                    },
                    {
                        "username": "rkdapp",
                        "content": "\\nThis would be the best way\\n\\nselect p.firstName,p.lastName,a.city,a.state\\nfrom person p\\nleft JOIN Address a ON p.PersonId = a.PersonId"
                    },
                    {
                        "username": "Doctorma999",
                        "content": "Select p.firstName, p.lastName, a.city, a.state from Person p\\nLeft join Address a on p.personId=a.addressId\\n\\nRan this and got the wrong output, the city column shows as \\'Leetcode\\' instead of null. How do I report a null value if the column text isn\\'t correct?"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select firstName, lastName, city, state from person as p LEFT JOIN  Address as a\\non p.personId = a.personId"
                    }
                ]
            },
            {
                "id": 1812550,
                "content": [
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the solution that I wrote,\\nselect P.FirstName,P.LastName,A.City,A.State from Person as P left outer join Address as A ON P.PersonId=A.PersonId"
                    },
                    {
                        "username": "HasanFarazi1234",
                        "content": " `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "gokulpilot007",
                        "content": "why we are not using foreign key ??using foreign key also we get the same output but i dont know how to make it"
                    },
                    {
                        "username": "Babul955719",
                        "content": "select  firstName, lastName , city , state\\nfrom  Person \\nleft join Address\\non Person.personId = Address.personId - finally got it after trying 4 times , i am begineer in SQL"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "SELECT p.lastName, p.firstName, a.city,a.state \\nFROM Person p \\nLEFT JOIN Address a \\nON p.personId=a.personId;"
                    },
                    {
                        "username": "8500423404",
                        "content": "select p.firstName,p.lastName,a.state,a.city \\nfrom Person p\\nleft join Address a \\non p.personId = a.personId"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "SELECT firstName, \\nlastName, \\nIF(city IS NOT NULL, city, \\'null\\') AS city, \\nIF(state IS NOT NULL, state, \\'null\\') AS state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\nI get expected output, test isn\\'t validated :O! Maybe I\\'ve stared at a screen too long for today.."
                    },
                    {
                        "username": "rkdapp",
                        "content": "\\nThis would be the best way\\n\\nselect p.firstName,p.lastName,a.city,a.state\\nfrom person p\\nleft JOIN Address a ON p.PersonId = a.PersonId"
                    },
                    {
                        "username": "Doctorma999",
                        "content": "Select p.firstName, p.lastName, a.city, a.state from Person p\\nLeft join Address a on p.personId=a.addressId\\n\\nRan this and got the wrong output, the city column shows as \\'Leetcode\\' instead of null. How do I report a null value if the column text isn\\'t correct?"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select firstName, lastName, city, state from person as p LEFT JOIN  Address as a\\non p.personId = a.personId"
                    }
                ]
            },
            {
                "id": 1804789,
                "content": [
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the solution that I wrote,\\nselect P.FirstName,P.LastName,A.City,A.State from Person as P left outer join Address as A ON P.PersonId=A.PersonId"
                    },
                    {
                        "username": "HasanFarazi1234",
                        "content": " `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "gokulpilot007",
                        "content": "why we are not using foreign key ??using foreign key also we get the same output but i dont know how to make it"
                    },
                    {
                        "username": "Babul955719",
                        "content": "select  firstName, lastName , city , state\\nfrom  Person \\nleft join Address\\non Person.personId = Address.personId - finally got it after trying 4 times , i am begineer in SQL"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "SELECT p.lastName, p.firstName, a.city,a.state \\nFROM Person p \\nLEFT JOIN Address a \\nON p.personId=a.personId;"
                    },
                    {
                        "username": "8500423404",
                        "content": "select p.firstName,p.lastName,a.state,a.city \\nfrom Person p\\nleft join Address a \\non p.personId = a.personId"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "SELECT firstName, \\nlastName, \\nIF(city IS NOT NULL, city, \\'null\\') AS city, \\nIF(state IS NOT NULL, state, \\'null\\') AS state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\nI get expected output, test isn\\'t validated :O! Maybe I\\'ve stared at a screen too long for today.."
                    },
                    {
                        "username": "rkdapp",
                        "content": "\\nThis would be the best way\\n\\nselect p.firstName,p.lastName,a.city,a.state\\nfrom person p\\nleft JOIN Address a ON p.PersonId = a.PersonId"
                    },
                    {
                        "username": "Doctorma999",
                        "content": "Select p.firstName, p.lastName, a.city, a.state from Person p\\nLeft join Address a on p.personId=a.addressId\\n\\nRan this and got the wrong output, the city column shows as \\'Leetcode\\' instead of null. How do I report a null value if the column text isn\\'t correct?"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select firstName, lastName, city, state from person as p LEFT JOIN  Address as a\\non p.personId = a.personId"
                    }
                ]
            },
            {
                "id": 1791095,
                "content": [
                    {
                        "username": "Amit_Jha",
                        "content": "Below is the solution that I wrote,\\nselect P.FirstName,P.LastName,A.City,A.State from Person as P left outer join Address as A ON P.PersonId=A.PersonId"
                    },
                    {
                        "username": "HasanFarazi1234",
                        "content": " `your inline code...your inline code...`[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "gokulpilot007",
                        "content": "why we are not using foreign key ??using foreign key also we get the same output but i dont know how to make it"
                    },
                    {
                        "username": "Babul955719",
                        "content": "select  firstName, lastName , city , state\\nfrom  Person \\nleft join Address\\non Person.personId = Address.personId - finally got it after trying 4 times , i am begineer in SQL"
                    },
                    {
                        "username": "jasurbekabdunazarov111",
                        "content": "SELECT p.lastName, p.firstName, a.city,a.state \\nFROM Person p \\nLEFT JOIN Address a \\nON p.personId=a.personId;"
                    },
                    {
                        "username": "8500423404",
                        "content": "select p.firstName,p.lastName,a.state,a.city \\nfrom Person p\\nleft join Address a \\non p.personId = a.personId"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "SELECT firstName, \\nlastName, \\nIF(city IS NOT NULL, city, \\'null\\') AS city, \\nIF(state IS NOT NULL, state, \\'null\\') AS state\\nFROM Person p\\nLEFT JOIN Address a ON p.personId = a.personId;\\n\\nI get expected output, test isn\\'t validated :O! Maybe I\\'ve stared at a screen too long for today.."
                    },
                    {
                        "username": "rkdapp",
                        "content": "\\nThis would be the best way\\n\\nselect p.firstName,p.lastName,a.city,a.state\\nfrom person p\\nleft JOIN Address a ON p.PersonId = a.PersonId"
                    },
                    {
                        "username": "Doctorma999",
                        "content": "Select p.firstName, p.lastName, a.city, a.state from Person p\\nLeft join Address a on p.personId=a.addressId\\n\\nRan this and got the wrong output, the city column shows as \\'Leetcode\\' instead of null. How do I report a null value if the column text isn\\'t correct?"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select firstName, lastName, city, state from person as p LEFT JOIN  Address as a\\non p.personId = a.personId"
                    }
                ]
            },
            {
                "id": 1783622,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": " `SELECT lastName , firstName ,city , state FROM Person LEFT JOIN Address ON\\nPerson.personId = Address.personId`\\nAbove SQL query to report the last name, first name, city, and state of each person in the \"Person\" table, along with the null value for missing address information. The query uses a LEFT JOIN clause to join the \"Person\" and \"Address\" tables on the \"personId\" column. This allows the query to return all records from the \"Person\" table, even if the matching record is not present in the \"Address\" table. If a record is not found, the values for \"city\" and \"state\" will be null."
                    },
                    {
                        "username": "arkapravabhunia4",
                        "content": "how to solve the error \\nTable \\'test.persion\\' doesn\\'t exist\\n"
                    },
                    {
                        "username": "Almas02",
                        "content": "SELECT FirstName,LastName,City,State from Person  left join Address  on Person.PersonID=Address.PersonID"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "SELECT P.firstName,P.lastName,A.city,A.state\\nFROM Person AS P\\nLEFT JOIN Address AS A ON P.personId=A.personId;"
                    },
                    {
                        "username": "paljugnu50",
                        "content": "elect Person.firstName,Person.lastName,Address.city,Address.state from Person  LEFT JOIN Address on Person.personId = Address.personId  ;"
                    },
                    {
                        "username": "somnathdutta2001",
                        "content": "when I try it with outer join it give syntax error.\\nwhy? anybody  can help? with the same code I just use left join it works. \\n\\nouter join will not right answer , it\\'s ok but why syntax error?"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "The thing is outer join is a concept not an actual SYNTAX (at least in MySQL). Outer joins  include LEFT, RIGHT, and FULL OUTER JOIN. And that is the reason LEFT JOIN worked for you. Check the infograph on this page:https://mode.com/sql-tutorial/sql-outer-joins/\\n\\nHere is a bonus for you:\\n\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Address as a\\nRIGHT JOIN Person as p\\nON p.personId = a.personId \\n\\nYes! It is a RIGHT JOIN solution. Try it for yourself!!"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Solution :\\n`select firstname,lastname, city, state from person left join address on address.personid=person.personid;`"
                    },
                    {
                        "username": "Jhanvi_chaudhary",
                        "content": "SELECT firstName, lastName, city, state \\nFROM Person LEFT OUTER JOIN Address \\nON Person.personId=Address.personId;"
                    },
                    {
                        "username": "user4175bH",
                        "content": "select p.firstName ,p.lastName ,a.city ,a.state   FROM Person p left join Address a on      p.personId = a.personId \\n\\nI have a doubt,when I kept a where condition saying where  a.personid is null ,it showed an error."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "I can\\'t say why it showed an error unless I can see the whole code but I can tell you why WHERE a.personId IS NULL won\\'t work here. \\n\\na.personId IS NULL checks where there is no data in the Address table for a particular person. However, if you read the problem carefully, you can see that it is not what is asked of you. It is easy to think along these lines and even I did when I first attempted the problem. The thing that is asked of us is to check if a given personId exists in both Address table and Person table. When you do the LEFT JOIN ON a.perosnId = p.PersonId, it is exactly what is being checked.  Hope it clears your doubt. Let me know if you need any further clarifications. "
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Read about left join, and difference between joins"
                    }
                ]
            },
            {
                "id": 1779399,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": " `SELECT lastName , firstName ,city , state FROM Person LEFT JOIN Address ON\\nPerson.personId = Address.personId`\\nAbove SQL query to report the last name, first name, city, and state of each person in the \"Person\" table, along with the null value for missing address information. The query uses a LEFT JOIN clause to join the \"Person\" and \"Address\" tables on the \"personId\" column. This allows the query to return all records from the \"Person\" table, even if the matching record is not present in the \"Address\" table. If a record is not found, the values for \"city\" and \"state\" will be null."
                    },
                    {
                        "username": "arkapravabhunia4",
                        "content": "how to solve the error \\nTable \\'test.persion\\' doesn\\'t exist\\n"
                    },
                    {
                        "username": "Almas02",
                        "content": "SELECT FirstName,LastName,City,State from Person  left join Address  on Person.PersonID=Address.PersonID"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "SELECT P.firstName,P.lastName,A.city,A.state\\nFROM Person AS P\\nLEFT JOIN Address AS A ON P.personId=A.personId;"
                    },
                    {
                        "username": "paljugnu50",
                        "content": "elect Person.firstName,Person.lastName,Address.city,Address.state from Person  LEFT JOIN Address on Person.personId = Address.personId  ;"
                    },
                    {
                        "username": "somnathdutta2001",
                        "content": "when I try it with outer join it give syntax error.\\nwhy? anybody  can help? with the same code I just use left join it works. \\n\\nouter join will not right answer , it\\'s ok but why syntax error?"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "The thing is outer join is a concept not an actual SYNTAX (at least in MySQL). Outer joins  include LEFT, RIGHT, and FULL OUTER JOIN. And that is the reason LEFT JOIN worked for you. Check the infograph on this page:https://mode.com/sql-tutorial/sql-outer-joins/\\n\\nHere is a bonus for you:\\n\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Address as a\\nRIGHT JOIN Person as p\\nON p.personId = a.personId \\n\\nYes! It is a RIGHT JOIN solution. Try it for yourself!!"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Solution :\\n`select firstname,lastname, city, state from person left join address on address.personid=person.personid;`"
                    },
                    {
                        "username": "Jhanvi_chaudhary",
                        "content": "SELECT firstName, lastName, city, state \\nFROM Person LEFT OUTER JOIN Address \\nON Person.personId=Address.personId;"
                    },
                    {
                        "username": "user4175bH",
                        "content": "select p.firstName ,p.lastName ,a.city ,a.state   FROM Person p left join Address a on      p.personId = a.personId \\n\\nI have a doubt,when I kept a where condition saying where  a.personid is null ,it showed an error."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "I can\\'t say why it showed an error unless I can see the whole code but I can tell you why WHERE a.personId IS NULL won\\'t work here. \\n\\na.personId IS NULL checks where there is no data in the Address table for a particular person. However, if you read the problem carefully, you can see that it is not what is asked of you. It is easy to think along these lines and even I did when I first attempted the problem. The thing that is asked of us is to check if a given personId exists in both Address table and Person table. When you do the LEFT JOIN ON a.perosnId = p.PersonId, it is exactly what is being checked.  Hope it clears your doubt. Let me know if you need any further clarifications. "
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Read about left join, and difference between joins"
                    }
                ]
            },
            {
                "id": 1772183,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": " `SELECT lastName , firstName ,city , state FROM Person LEFT JOIN Address ON\\nPerson.personId = Address.personId`\\nAbove SQL query to report the last name, first name, city, and state of each person in the \"Person\" table, along with the null value for missing address information. The query uses a LEFT JOIN clause to join the \"Person\" and \"Address\" tables on the \"personId\" column. This allows the query to return all records from the \"Person\" table, even if the matching record is not present in the \"Address\" table. If a record is not found, the values for \"city\" and \"state\" will be null."
                    },
                    {
                        "username": "arkapravabhunia4",
                        "content": "how to solve the error \\nTable \\'test.persion\\' doesn\\'t exist\\n"
                    },
                    {
                        "username": "Almas02",
                        "content": "SELECT FirstName,LastName,City,State from Person  left join Address  on Person.PersonID=Address.PersonID"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "SELECT P.firstName,P.lastName,A.city,A.state\\nFROM Person AS P\\nLEFT JOIN Address AS A ON P.personId=A.personId;"
                    },
                    {
                        "username": "paljugnu50",
                        "content": "elect Person.firstName,Person.lastName,Address.city,Address.state from Person  LEFT JOIN Address on Person.personId = Address.personId  ;"
                    },
                    {
                        "username": "somnathdutta2001",
                        "content": "when I try it with outer join it give syntax error.\\nwhy? anybody  can help? with the same code I just use left join it works. \\n\\nouter join will not right answer , it\\'s ok but why syntax error?"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "The thing is outer join is a concept not an actual SYNTAX (at least in MySQL). Outer joins  include LEFT, RIGHT, and FULL OUTER JOIN. And that is the reason LEFT JOIN worked for you. Check the infograph on this page:https://mode.com/sql-tutorial/sql-outer-joins/\\n\\nHere is a bonus for you:\\n\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Address as a\\nRIGHT JOIN Person as p\\nON p.personId = a.personId \\n\\nYes! It is a RIGHT JOIN solution. Try it for yourself!!"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Solution :\\n`select firstname,lastname, city, state from person left join address on address.personid=person.personid;`"
                    },
                    {
                        "username": "Jhanvi_chaudhary",
                        "content": "SELECT firstName, lastName, city, state \\nFROM Person LEFT OUTER JOIN Address \\nON Person.personId=Address.personId;"
                    },
                    {
                        "username": "user4175bH",
                        "content": "select p.firstName ,p.lastName ,a.city ,a.state   FROM Person p left join Address a on      p.personId = a.personId \\n\\nI have a doubt,when I kept a where condition saying where  a.personid is null ,it showed an error."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "I can\\'t say why it showed an error unless I can see the whole code but I can tell you why WHERE a.personId IS NULL won\\'t work here. \\n\\na.personId IS NULL checks where there is no data in the Address table for a particular person. However, if you read the problem carefully, you can see that it is not what is asked of you. It is easy to think along these lines and even I did when I first attempted the problem. The thing that is asked of us is to check if a given personId exists in both Address table and Person table. When you do the LEFT JOIN ON a.perosnId = p.PersonId, it is exactly what is being checked.  Hope it clears your doubt. Let me know if you need any further clarifications. "
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Read about left join, and difference between joins"
                    }
                ]
            },
            {
                "id": 1763381,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": " `SELECT lastName , firstName ,city , state FROM Person LEFT JOIN Address ON\\nPerson.personId = Address.personId`\\nAbove SQL query to report the last name, first name, city, and state of each person in the \"Person\" table, along with the null value for missing address information. The query uses a LEFT JOIN clause to join the \"Person\" and \"Address\" tables on the \"personId\" column. This allows the query to return all records from the \"Person\" table, even if the matching record is not present in the \"Address\" table. If a record is not found, the values for \"city\" and \"state\" will be null."
                    },
                    {
                        "username": "arkapravabhunia4",
                        "content": "how to solve the error \\nTable \\'test.persion\\' doesn\\'t exist\\n"
                    },
                    {
                        "username": "Almas02",
                        "content": "SELECT FirstName,LastName,City,State from Person  left join Address  on Person.PersonID=Address.PersonID"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "SELECT P.firstName,P.lastName,A.city,A.state\\nFROM Person AS P\\nLEFT JOIN Address AS A ON P.personId=A.personId;"
                    },
                    {
                        "username": "paljugnu50",
                        "content": "elect Person.firstName,Person.lastName,Address.city,Address.state from Person  LEFT JOIN Address on Person.personId = Address.personId  ;"
                    },
                    {
                        "username": "somnathdutta2001",
                        "content": "when I try it with outer join it give syntax error.\\nwhy? anybody  can help? with the same code I just use left join it works. \\n\\nouter join will not right answer , it\\'s ok but why syntax error?"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "The thing is outer join is a concept not an actual SYNTAX (at least in MySQL). Outer joins  include LEFT, RIGHT, and FULL OUTER JOIN. And that is the reason LEFT JOIN worked for you. Check the infograph on this page:https://mode.com/sql-tutorial/sql-outer-joins/\\n\\nHere is a bonus for you:\\n\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Address as a\\nRIGHT JOIN Person as p\\nON p.personId = a.personId \\n\\nYes! It is a RIGHT JOIN solution. Try it for yourself!!"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Solution :\\n`select firstname,lastname, city, state from person left join address on address.personid=person.personid;`"
                    },
                    {
                        "username": "Jhanvi_chaudhary",
                        "content": "SELECT firstName, lastName, city, state \\nFROM Person LEFT OUTER JOIN Address \\nON Person.personId=Address.personId;"
                    },
                    {
                        "username": "user4175bH",
                        "content": "select p.firstName ,p.lastName ,a.city ,a.state   FROM Person p left join Address a on      p.personId = a.personId \\n\\nI have a doubt,when I kept a where condition saying where  a.personid is null ,it showed an error."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "I can\\'t say why it showed an error unless I can see the whole code but I can tell you why WHERE a.personId IS NULL won\\'t work here. \\n\\na.personId IS NULL checks where there is no data in the Address table for a particular person. However, if you read the problem carefully, you can see that it is not what is asked of you. It is easy to think along these lines and even I did when I first attempted the problem. The thing that is asked of us is to check if a given personId exists in both Address table and Person table. When you do the LEFT JOIN ON a.perosnId = p.PersonId, it is exactly what is being checked.  Hope it clears your doubt. Let me know if you need any further clarifications. "
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Read about left join, and difference between joins"
                    }
                ]
            },
            {
                "id": 1755336,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": " `SELECT lastName , firstName ,city , state FROM Person LEFT JOIN Address ON\\nPerson.personId = Address.personId`\\nAbove SQL query to report the last name, first name, city, and state of each person in the \"Person\" table, along with the null value for missing address information. The query uses a LEFT JOIN clause to join the \"Person\" and \"Address\" tables on the \"personId\" column. This allows the query to return all records from the \"Person\" table, even if the matching record is not present in the \"Address\" table. If a record is not found, the values for \"city\" and \"state\" will be null."
                    },
                    {
                        "username": "arkapravabhunia4",
                        "content": "how to solve the error \\nTable \\'test.persion\\' doesn\\'t exist\\n"
                    },
                    {
                        "username": "Almas02",
                        "content": "SELECT FirstName,LastName,City,State from Person  left join Address  on Person.PersonID=Address.PersonID"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "SELECT P.firstName,P.lastName,A.city,A.state\\nFROM Person AS P\\nLEFT JOIN Address AS A ON P.personId=A.personId;"
                    },
                    {
                        "username": "paljugnu50",
                        "content": "elect Person.firstName,Person.lastName,Address.city,Address.state from Person  LEFT JOIN Address on Person.personId = Address.personId  ;"
                    },
                    {
                        "username": "somnathdutta2001",
                        "content": "when I try it with outer join it give syntax error.\\nwhy? anybody  can help? with the same code I just use left join it works. \\n\\nouter join will not right answer , it\\'s ok but why syntax error?"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "The thing is outer join is a concept not an actual SYNTAX (at least in MySQL). Outer joins  include LEFT, RIGHT, and FULL OUTER JOIN. And that is the reason LEFT JOIN worked for you. Check the infograph on this page:https://mode.com/sql-tutorial/sql-outer-joins/\\n\\nHere is a bonus for you:\\n\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Address as a\\nRIGHT JOIN Person as p\\nON p.personId = a.personId \\n\\nYes! It is a RIGHT JOIN solution. Try it for yourself!!"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Solution :\\n`select firstname,lastname, city, state from person left join address on address.personid=person.personid;`"
                    },
                    {
                        "username": "Jhanvi_chaudhary",
                        "content": "SELECT firstName, lastName, city, state \\nFROM Person LEFT OUTER JOIN Address \\nON Person.personId=Address.personId;"
                    },
                    {
                        "username": "user4175bH",
                        "content": "select p.firstName ,p.lastName ,a.city ,a.state   FROM Person p left join Address a on      p.personId = a.personId \\n\\nI have a doubt,when I kept a where condition saying where  a.personid is null ,it showed an error."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "I can\\'t say why it showed an error unless I can see the whole code but I can tell you why WHERE a.personId IS NULL won\\'t work here. \\n\\na.personId IS NULL checks where there is no data in the Address table for a particular person. However, if you read the problem carefully, you can see that it is not what is asked of you. It is easy to think along these lines and even I did when I first attempted the problem. The thing that is asked of us is to check if a given personId exists in both Address table and Person table. When you do the LEFT JOIN ON a.perosnId = p.PersonId, it is exactly what is being checked.  Hope it clears your doubt. Let me know if you need any further clarifications. "
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Read about left join, and difference between joins"
                    }
                ]
            },
            {
                "id": 1750111,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": " `SELECT lastName , firstName ,city , state FROM Person LEFT JOIN Address ON\\nPerson.personId = Address.personId`\\nAbove SQL query to report the last name, first name, city, and state of each person in the \"Person\" table, along with the null value for missing address information. The query uses a LEFT JOIN clause to join the \"Person\" and \"Address\" tables on the \"personId\" column. This allows the query to return all records from the \"Person\" table, even if the matching record is not present in the \"Address\" table. If a record is not found, the values for \"city\" and \"state\" will be null."
                    },
                    {
                        "username": "arkapravabhunia4",
                        "content": "how to solve the error \\nTable \\'test.persion\\' doesn\\'t exist\\n"
                    },
                    {
                        "username": "Almas02",
                        "content": "SELECT FirstName,LastName,City,State from Person  left join Address  on Person.PersonID=Address.PersonID"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "SELECT P.firstName,P.lastName,A.city,A.state\\nFROM Person AS P\\nLEFT JOIN Address AS A ON P.personId=A.personId;"
                    },
                    {
                        "username": "paljugnu50",
                        "content": "elect Person.firstName,Person.lastName,Address.city,Address.state from Person  LEFT JOIN Address on Person.personId = Address.personId  ;"
                    },
                    {
                        "username": "somnathdutta2001",
                        "content": "when I try it with outer join it give syntax error.\\nwhy? anybody  can help? with the same code I just use left join it works. \\n\\nouter join will not right answer , it\\'s ok but why syntax error?"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "The thing is outer join is a concept not an actual SYNTAX (at least in MySQL). Outer joins  include LEFT, RIGHT, and FULL OUTER JOIN. And that is the reason LEFT JOIN worked for you. Check the infograph on this page:https://mode.com/sql-tutorial/sql-outer-joins/\\n\\nHere is a bonus for you:\\n\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Address as a\\nRIGHT JOIN Person as p\\nON p.personId = a.personId \\n\\nYes! It is a RIGHT JOIN solution. Try it for yourself!!"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Solution :\\n`select firstname,lastname, city, state from person left join address on address.personid=person.personid;`"
                    },
                    {
                        "username": "Jhanvi_chaudhary",
                        "content": "SELECT firstName, lastName, city, state \\nFROM Person LEFT OUTER JOIN Address \\nON Person.personId=Address.personId;"
                    },
                    {
                        "username": "user4175bH",
                        "content": "select p.firstName ,p.lastName ,a.city ,a.state   FROM Person p left join Address a on      p.personId = a.personId \\n\\nI have a doubt,when I kept a where condition saying where  a.personid is null ,it showed an error."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "I can\\'t say why it showed an error unless I can see the whole code but I can tell you why WHERE a.personId IS NULL won\\'t work here. \\n\\na.personId IS NULL checks where there is no data in the Address table for a particular person. However, if you read the problem carefully, you can see that it is not what is asked of you. It is easy to think along these lines and even I did when I first attempted the problem. The thing that is asked of us is to check if a given personId exists in both Address table and Person table. When you do the LEFT JOIN ON a.perosnId = p.PersonId, it is exactly what is being checked.  Hope it clears your doubt. Let me know if you need any further clarifications. "
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Read about left join, and difference between joins"
                    }
                ]
            },
            {
                "id": 1749289,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": " `SELECT lastName , firstName ,city , state FROM Person LEFT JOIN Address ON\\nPerson.personId = Address.personId`\\nAbove SQL query to report the last name, first name, city, and state of each person in the \"Person\" table, along with the null value for missing address information. The query uses a LEFT JOIN clause to join the \"Person\" and \"Address\" tables on the \"personId\" column. This allows the query to return all records from the \"Person\" table, even if the matching record is not present in the \"Address\" table. If a record is not found, the values for \"city\" and \"state\" will be null."
                    },
                    {
                        "username": "arkapravabhunia4",
                        "content": "how to solve the error \\nTable \\'test.persion\\' doesn\\'t exist\\n"
                    },
                    {
                        "username": "Almas02",
                        "content": "SELECT FirstName,LastName,City,State from Person  left join Address  on Person.PersonID=Address.PersonID"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "SELECT P.firstName,P.lastName,A.city,A.state\\nFROM Person AS P\\nLEFT JOIN Address AS A ON P.personId=A.personId;"
                    },
                    {
                        "username": "paljugnu50",
                        "content": "elect Person.firstName,Person.lastName,Address.city,Address.state from Person  LEFT JOIN Address on Person.personId = Address.personId  ;"
                    },
                    {
                        "username": "somnathdutta2001",
                        "content": "when I try it with outer join it give syntax error.\\nwhy? anybody  can help? with the same code I just use left join it works. \\n\\nouter join will not right answer , it\\'s ok but why syntax error?"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "The thing is outer join is a concept not an actual SYNTAX (at least in MySQL). Outer joins  include LEFT, RIGHT, and FULL OUTER JOIN. And that is the reason LEFT JOIN worked for you. Check the infograph on this page:https://mode.com/sql-tutorial/sql-outer-joins/\\n\\nHere is a bonus for you:\\n\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Address as a\\nRIGHT JOIN Person as p\\nON p.personId = a.personId \\n\\nYes! It is a RIGHT JOIN solution. Try it for yourself!!"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Solution :\\n`select firstname,lastname, city, state from person left join address on address.personid=person.personid;`"
                    },
                    {
                        "username": "Jhanvi_chaudhary",
                        "content": "SELECT firstName, lastName, city, state \\nFROM Person LEFT OUTER JOIN Address \\nON Person.personId=Address.personId;"
                    },
                    {
                        "username": "user4175bH",
                        "content": "select p.firstName ,p.lastName ,a.city ,a.state   FROM Person p left join Address a on      p.personId = a.personId \\n\\nI have a doubt,when I kept a where condition saying where  a.personid is null ,it showed an error."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "I can\\'t say why it showed an error unless I can see the whole code but I can tell you why WHERE a.personId IS NULL won\\'t work here. \\n\\na.personId IS NULL checks where there is no data in the Address table for a particular person. However, if you read the problem carefully, you can see that it is not what is asked of you. It is easy to think along these lines and even I did when I first attempted the problem. The thing that is asked of us is to check if a given personId exists in both Address table and Person table. When you do the LEFT JOIN ON a.perosnId = p.PersonId, it is exactly what is being checked.  Hope it clears your doubt. Let me know if you need any further clarifications. "
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Read about left join, and difference between joins"
                    }
                ]
            },
            {
                "id": 1744227,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": " `SELECT lastName , firstName ,city , state FROM Person LEFT JOIN Address ON\\nPerson.personId = Address.personId`\\nAbove SQL query to report the last name, first name, city, and state of each person in the \"Person\" table, along with the null value for missing address information. The query uses a LEFT JOIN clause to join the \"Person\" and \"Address\" tables on the \"personId\" column. This allows the query to return all records from the \"Person\" table, even if the matching record is not present in the \"Address\" table. If a record is not found, the values for \"city\" and \"state\" will be null."
                    },
                    {
                        "username": "arkapravabhunia4",
                        "content": "how to solve the error \\nTable \\'test.persion\\' doesn\\'t exist\\n"
                    },
                    {
                        "username": "Almas02",
                        "content": "SELECT FirstName,LastName,City,State from Person  left join Address  on Person.PersonID=Address.PersonID"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "SELECT P.firstName,P.lastName,A.city,A.state\\nFROM Person AS P\\nLEFT JOIN Address AS A ON P.personId=A.personId;"
                    },
                    {
                        "username": "paljugnu50",
                        "content": "elect Person.firstName,Person.lastName,Address.city,Address.state from Person  LEFT JOIN Address on Person.personId = Address.personId  ;"
                    },
                    {
                        "username": "somnathdutta2001",
                        "content": "when I try it with outer join it give syntax error.\\nwhy? anybody  can help? with the same code I just use left join it works. \\n\\nouter join will not right answer , it\\'s ok but why syntax error?"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "The thing is outer join is a concept not an actual SYNTAX (at least in MySQL). Outer joins  include LEFT, RIGHT, and FULL OUTER JOIN. And that is the reason LEFT JOIN worked for you. Check the infograph on this page:https://mode.com/sql-tutorial/sql-outer-joins/\\n\\nHere is a bonus for you:\\n\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Address as a\\nRIGHT JOIN Person as p\\nON p.personId = a.personId \\n\\nYes! It is a RIGHT JOIN solution. Try it for yourself!!"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Solution :\\n`select firstname,lastname, city, state from person left join address on address.personid=person.personid;`"
                    },
                    {
                        "username": "Jhanvi_chaudhary",
                        "content": "SELECT firstName, lastName, city, state \\nFROM Person LEFT OUTER JOIN Address \\nON Person.personId=Address.personId;"
                    },
                    {
                        "username": "user4175bH",
                        "content": "select p.firstName ,p.lastName ,a.city ,a.state   FROM Person p left join Address a on      p.personId = a.personId \\n\\nI have a doubt,when I kept a where condition saying where  a.personid is null ,it showed an error."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "I can\\'t say why it showed an error unless I can see the whole code but I can tell you why WHERE a.personId IS NULL won\\'t work here. \\n\\na.personId IS NULL checks where there is no data in the Address table for a particular person. However, if you read the problem carefully, you can see that it is not what is asked of you. It is easy to think along these lines and even I did when I first attempted the problem. The thing that is asked of us is to check if a given personId exists in both Address table and Person table. When you do the LEFT JOIN ON a.perosnId = p.PersonId, it is exactly what is being checked.  Hope it clears your doubt. Let me know if you need any further clarifications. "
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Read about left join, and difference between joins"
                    }
                ]
            },
            {
                "id": 1743144,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": " `SELECT lastName , firstName ,city , state FROM Person LEFT JOIN Address ON\\nPerson.personId = Address.personId`\\nAbove SQL query to report the last name, first name, city, and state of each person in the \"Person\" table, along with the null value for missing address information. The query uses a LEFT JOIN clause to join the \"Person\" and \"Address\" tables on the \"personId\" column. This allows the query to return all records from the \"Person\" table, even if the matching record is not present in the \"Address\" table. If a record is not found, the values for \"city\" and \"state\" will be null."
                    },
                    {
                        "username": "arkapravabhunia4",
                        "content": "how to solve the error \\nTable \\'test.persion\\' doesn\\'t exist\\n"
                    },
                    {
                        "username": "Almas02",
                        "content": "SELECT FirstName,LastName,City,State from Person  left join Address  on Person.PersonID=Address.PersonID"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "SELECT P.firstName,P.lastName,A.city,A.state\\nFROM Person AS P\\nLEFT JOIN Address AS A ON P.personId=A.personId;"
                    },
                    {
                        "username": "paljugnu50",
                        "content": "elect Person.firstName,Person.lastName,Address.city,Address.state from Person  LEFT JOIN Address on Person.personId = Address.personId  ;"
                    },
                    {
                        "username": "somnathdutta2001",
                        "content": "when I try it with outer join it give syntax error.\\nwhy? anybody  can help? with the same code I just use left join it works. \\n\\nouter join will not right answer , it\\'s ok but why syntax error?"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "The thing is outer join is a concept not an actual SYNTAX (at least in MySQL). Outer joins  include LEFT, RIGHT, and FULL OUTER JOIN. And that is the reason LEFT JOIN worked for you. Check the infograph on this page:https://mode.com/sql-tutorial/sql-outer-joins/\\n\\nHere is a bonus for you:\\n\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Address as a\\nRIGHT JOIN Person as p\\nON p.personId = a.personId \\n\\nYes! It is a RIGHT JOIN solution. Try it for yourself!!"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Solution :\\n`select firstname,lastname, city, state from person left join address on address.personid=person.personid;`"
                    },
                    {
                        "username": "Jhanvi_chaudhary",
                        "content": "SELECT firstName, lastName, city, state \\nFROM Person LEFT OUTER JOIN Address \\nON Person.personId=Address.personId;"
                    },
                    {
                        "username": "user4175bH",
                        "content": "select p.firstName ,p.lastName ,a.city ,a.state   FROM Person p left join Address a on      p.personId = a.personId \\n\\nI have a doubt,when I kept a where condition saying where  a.personid is null ,it showed an error."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "I can\\'t say why it showed an error unless I can see the whole code but I can tell you why WHERE a.personId IS NULL won\\'t work here. \\n\\na.personId IS NULL checks where there is no data in the Address table for a particular person. However, if you read the problem carefully, you can see that it is not what is asked of you. It is easy to think along these lines and even I did when I first attempted the problem. The thing that is asked of us is to check if a given personId exists in both Address table and Person table. When you do the LEFT JOIN ON a.perosnId = p.PersonId, it is exactly what is being checked.  Hope it clears your doubt. Let me know if you need any further clarifications. "
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Read about left join, and difference between joins"
                    }
                ]
            },
            {
                "id": 1734285,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": " `SELECT lastName , firstName ,city , state FROM Person LEFT JOIN Address ON\\nPerson.personId = Address.personId`\\nAbove SQL query to report the last name, first name, city, and state of each person in the \"Person\" table, along with the null value for missing address information. The query uses a LEFT JOIN clause to join the \"Person\" and \"Address\" tables on the \"personId\" column. This allows the query to return all records from the \"Person\" table, even if the matching record is not present in the \"Address\" table. If a record is not found, the values for \"city\" and \"state\" will be null."
                    },
                    {
                        "username": "arkapravabhunia4",
                        "content": "how to solve the error \\nTable \\'test.persion\\' doesn\\'t exist\\n"
                    },
                    {
                        "username": "Almas02",
                        "content": "SELECT FirstName,LastName,City,State from Person  left join Address  on Person.PersonID=Address.PersonID"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "SELECT P.firstName,P.lastName,A.city,A.state\\nFROM Person AS P\\nLEFT JOIN Address AS A ON P.personId=A.personId;"
                    },
                    {
                        "username": "paljugnu50",
                        "content": "elect Person.firstName,Person.lastName,Address.city,Address.state from Person  LEFT JOIN Address on Person.personId = Address.personId  ;"
                    },
                    {
                        "username": "somnathdutta2001",
                        "content": "when I try it with outer join it give syntax error.\\nwhy? anybody  can help? with the same code I just use left join it works. \\n\\nouter join will not right answer , it\\'s ok but why syntax error?"
                    },
                    {
                        "username": "nirbhayr",
                        "content": "The thing is outer join is a concept not an actual SYNTAX (at least in MySQL). Outer joins  include LEFT, RIGHT, and FULL OUTER JOIN. And that is the reason LEFT JOIN worked for you. Check the infograph on this page:https://mode.com/sql-tutorial/sql-outer-joins/\\n\\nHere is a bonus for you:\\n\\nselect p.firstName, p.lastName, a.city, a.state\\nfrom Address as a\\nRIGHT JOIN Person as p\\nON p.personId = a.personId \\n\\nYes! It is a RIGHT JOIN solution. Try it for yourself!!"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Solution :\\n`select firstname,lastname, city, state from person left join address on address.personid=person.personid;`"
                    },
                    {
                        "username": "Jhanvi_chaudhary",
                        "content": "SELECT firstName, lastName, city, state \\nFROM Person LEFT OUTER JOIN Address \\nON Person.personId=Address.personId;"
                    },
                    {
                        "username": "user4175bH",
                        "content": "select p.firstName ,p.lastName ,a.city ,a.state   FROM Person p left join Address a on      p.personId = a.personId \\n\\nI have a doubt,when I kept a where condition saying where  a.personid is null ,it showed an error."
                    },
                    {
                        "username": "nirbhayr",
                        "content": "I can\\'t say why it showed an error unless I can see the whole code but I can tell you why WHERE a.personId IS NULL won\\'t work here. \\n\\na.personId IS NULL checks where there is no data in the Address table for a particular person. However, if you read the problem carefully, you can see that it is not what is asked of you. It is easy to think along these lines and even I did when I first attempted the problem. The thing that is asked of us is to check if a given personId exists in both Address table and Person table. When you do the LEFT JOIN ON a.perosnId = p.PersonId, it is exactly what is being checked.  Hope it clears your doubt. Let me know if you need any further clarifications. "
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Read about left join, and difference between joins"
                    }
                ]
            }
        ]
    },
    {
        "title": "H-Index II",
        "question_content": "<p>Given an array of integers <code>citations</code> where <code>citations[i]</code> is the number of citations a researcher received for their <code>i<sup>th</sup></code> paper and <code>citations</code> is sorted in <strong>ascending order</strong>, return <em>the researcher&#39;s h-index</em>.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/H-index\" target=\"_blank\">definition of h-index on Wikipedia</a>: The h-index is defined as the maximum value of <code>h</code> such that the given researcher has published at least <code>h</code> papers that have each been cited at least <code>h</code> times.</p>\n\n<p>You must write an algorithm that runs in logarithmic time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [0,1,3,5,6]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [1,2,100]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n\t<li><code>citations</code> is sorted in <strong>ascending order</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 71063,
                "title": "standard-binary-search",
                "content": "Just binary search, each time check citations[mid]\\ncase 1: citations[mid] == len-mid, then it means there are citations[mid] papers that have at least citations[mid] citations.\\ncase 2: citations[mid] > len-mid, then it means there are citations[mid] papers that have moret than citations[mid] citations, so we should continue searching in the left half\\ncase 3:  citations[mid] < len-mid, we should continue searching in the right side\\nAfter iteration, it is guaranteed that right+1 is the one we need to find (i.e. len-(right+1) papars have at least len-(righ+1) citations)\\n\\n\\n    class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            int left=0, len = citations.size(), right= len-1,  mid;\\n            while(left<=right)\\n            {\\n                mid=(left+right)>>1;\\n                if(citations[mid]== (len-mid)) return citations[mid];\\n                else if(citations[mid] > (len-mid)) right = mid - 1;\\n                else left = mid + 1;\\n            }\\n            return len - (right+1);\\n        }\\n    };\\n\\nor simplified version\\n\\n    class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            int left=0, len = citations.size(), right= len-1,  mid;\\n            while(left<=right)\\n            {\\n                mid=left+ (right-left)/2;\\n                if(citations[mid] >= (len-mid)) right = mid - 1;\\n                else left = mid + 1;\\n            }\\n            return len - left;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            int left=0, len = citations.size(), right= len-1,  mid;\\n            while(left<=right)\\n            {\\n                mid=(left+right)>>1;\\n                if(citations[mid]== (len-mid)) return citations[mid];\\n                else if(citations[mid] > (len-mid)) right = mid - 1;\\n                else left = mid + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71124,
                "title": "java-binary-search-simple-and-clean",
                "content": "The idea is to search for the first index from the sorted array so that :\\n<br> <i>citations[index] >= length(citations) - index.</I> <br>\\nAnd return (length - index) as the result.\\nHere is the code:\\n\\n    public int hIndex(int[] citations) {\\n\\t\\tint len = citations.length;\\n\\t\\tint lo = 0, hi = len - 1;\\n\\t\\twhile (lo <= hi) {\\n\\t\\t\\tint med = (hi + lo) / 2;\\n\\t\\t\\tif (citations[med] == len - med) {\\n\\t\\t\\t\\treturn len - med;\\n\\t\\t\\t} else if (citations[med] < len - med) {\\n\\t\\t\\t\\tlo = med + 1;\\n\\t\\t\\t} else { \\n\\t\\t\\t\\t//(citations[med] > len-med), med qualified as a hIndex,\\n\\t\\t\\t    // but we have to continue to search for a higher one.\\n\\t\\t\\t\\thi = med - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn len - lo;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "The idea is to search for the first index from the sorted array so that :\\n<br> <i>citations[index] >= length(citations) - index.</I> <br>\\nAnd return (length - index) as the result.\\nHere is the code:\\n\\n    public int hIndex(int[] citations) {\\n\\t\\tint len = citations.length;\\n\\t\\tint lo = 0, hi = len - 1;\\n\\t\\twhile (lo <= hi) {\\n\\t\\t\\tint med = (hi + lo) / 2;\\n\\t\\t\\tif (citations[med] == len - med) {\\n\\t\\t\\t\\treturn len - med;\\n\\t\\t\\t} else if (citations[med] < len - med) {\\n\\t\\t\\t\\tlo = med + 1;\\n\\t\\t\\t} else { \\n\\t\\t\\t\\t//(citations[med] > len-med), med qualified as a hIndex,\\n\\t\\t\\t    // but we have to continue to search for a higher one.\\n\\t\\t\\t\\thi = med - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn len - lo;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 693427,
                "title": "c-both-o-logn-and-o-n-solution-with-explanation",
                "content": "First we will look at O(N) solution to understand the problem then we will optimise it with binary search.\\n\\n**The Idea behind the problem**\\nLet us consider the following example:\\n```\\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\\nHere the ans is 6.\\n\\nWhy not 5 or 7?\\n\\nnumber of papers with citation alteast 7 is only 5.\\nWheras for 6 it is 6 i.e. among 12 papers 6 papers have citation atleast 6.\\n\\nAnd though number of paper with citation atleast 5 is more than that of 6, 6 is higher value compared to 5 and also the quantity 6 is a better tradeoff.\\n\\n------------------(Credits: @greeneggsandsam)---------------------------------------------------------------------------\\n\"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\n5 of the papers have at least 5 citations, but among the other 7 papers, one (value 6) has more than 5 citations.\\n------------------------------------------------------------------------------------------------------------------------------\\nThe key concept here is to understand that the problem requires a value that has a proper weight with significant quantity.\\n\\nOne more observation we can make here is that more consecutive integers the value at the middle is good as the quantity and weight is bettered compared to other elements.\\n```\\nThe O(N) approach: \\n\\nThis approach is straight forward traverse the array and when you find the first element such that the value of that element is greater than or equal to the amount of elements remaining that is our ans so we return the length of array after that point. If no such element exisits return 0;\\n\\nCODE: \\n\\n```\\nint hIndex(vector<int>& c) {\\n        int n = c.size();\\n        if(!n) return 0;\\n        for(int i=0;i<n;i++){\\n             if(c[i] >= n-i) return n-i;   // The first element whose value is more than the length of remaining array. \\n\\t\\t\\t //So we return the remaining length which is the answer.\\n\\t\\t\\t // eg [0,1,3,4,6]  c[2] = 3 >2(length of remaing array) so n-i = length of remaining array + that element\\n        }\\n        return 0;\\n    }\\n```\\n\\nThe O(logn) approach | Binary Search\\n\\nIt is clear now that we need to find such an element as discussed in O(n) solution but faster so we need binary search. We will store our answer in ans variable.  Once our condition is hit we store the length of remaing array on ans and continue with our binary search as we want the first element that satisfies this condition.\\n\\nCODE: \\n```\\nint hIndex(vector<int>& c) {\\n        int n = c.size();\\n        if(!n) return 0;\\n        int low =0,high=n-1;\\n        int ans = 0;\\n        while(low<=high){\\n            int mid  = low + (high-low)/2;\\n            if(c[mid] >= n-mid){\\n                ans = n-mid;\\n                high = mid - 1;\\n            }else{\\n                low  = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n\\t}\\n```\\nHope this helps! :)\\nForgive me for any ambiguous sentences.\\n",
                "solutionTags": [],
                "code": "```\\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\\nHere the ans is 6.\\n\\nWhy not 5 or 7?\\n\\nnumber of papers with citation alteast 7 is only 5.\\nWheras for 6 it is 6 i.e. among 12 papers 6 papers have citation atleast 6.\\n\\nAnd though number of paper with citation atleast 5 is more than that of 6, 6 is higher value compared to 5 and also the quantity 6 is a better tradeoff.\\n\\n------------------(Credits: @greeneggsandsam)---------------------------------------------------------------------------\\n\"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"\\n\\n5 of the papers have at least 5 citations, but among the other 7 papers, one (value 6) has more than 5 citations.\\n------------------------------------------------------------------------------------------------------------------------------\\nThe key concept here is to understand that the problem requires a value that has a proper weight with significant quantity.\\n\\nOne more observation we can make here is that more consecutive integers the value at the middle is good as the quantity and weight is bettered compared to other elements.\\n```\n```\\nint hIndex(vector<int>& c) {\\n        int n = c.size();\\n        if(!n) return 0;\\n        for(int i=0;i<n;i++){\\n             if(c[i] >= n-i) return n-i;   // The first element whose value is more than the length of remaining array. \\n\\t\\t\\t //So we return the remaining length which is the answer.\\n\\t\\t\\t // eg [0,1,3,4,6]  c[2] = 3 >2(length of remaing array) so n-i = length of remaining array + that element\\n        }\\n        return 0;\\n    }\\n```\n```\\nint hIndex(vector<int>& c) {\\n        int n = c.size();\\n        if(!n) return 0;\\n        int low =0,high=n-1;\\n        int ans = 0;\\n        while(low<=high){\\n            int mid  = low + (high-low)/2;\\n            if(c[mid] >= n-mid){\\n                ans = n-mid;\\n                high = mid - 1;\\n            }else{\\n                low  = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693380,
                "title": "python-2-solutions-binary-search-o-log-n-and-oneliner-o-n-explained",
                "content": "### Binary search\\nIn this problem data is already sorted for you, so we should take advantage of it. What you think what you need to search in sorted data? The answer is **binary search**. Of course you can not apply it like this, you need to adapt it to our problem. Let us start with example `[1,3,3,3,4,4,7]` and then consider general case. \\n\\n`......X`\\n`......X`\\n`......X`\\n`....XXX`\\n`.XXXXXX`\\n`.XXXXXX`\\n`XXXXXXX`\\n\\nWhat is the answer fo this data? It is `3`, because there is `3` publications with at least `3` citations:\\n\\n`......X`\\n`......X`\\n`......X`\\n`....XXX`\\n`.XXXOOO`\\n`.XXXOOO`\\n`XXXXOOO`\\n\\nI denoted found elements as `O`. We can see, that what we actually need to find, is the size of biggest **square** which is inside our sorted data. Mathematically speaking, we look for smallest index `i`, such that `i + citations[i] >= n` and then we return `n-i`. In our example `n=7`, `i = 4` and answer is `7 - 4 = 3`. How we find this smallest index `i`? Using **binary search** of course, because sequence `i + citations[i]` is non-decreasing.\\n\\nWe can not use `bisect` library here, because for this we need to calculate `i + citations[i]` for every `i`, which can be done only in `O(n)`, so we need to apply vanila binary search by hands.\\n\\n**Complexity**: time complexity is `O(log n)` and additional space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def hIndex(self, citations):\\n        if not citations: return 0\\n        n = len(citations)\\n        beg, end = 0, n - 1\\n        while beg <= end:\\n            mid = (beg + end)//2\\n            if mid + citations[mid] >= n:\\n                end = mid - 1\\n            else:\\n                beg = mid + 1                \\n        return n - beg\\n```\\n\\n### Oneliner \\n\\nIf we do not use binary search, we can solve problem in one line, using linear search. We need to add `[0]` in the end to handle some border cases.\\n\\n```\\nclass Solution:\\n    def hIndex(self, c):\\n        return ([i+j>=len(c) for i,j in enumerate(c)][::-1]+[0]).index(0)\\n```\\n\\nSee also my solution of **254** problem **H-Index**:\\nhttps://leetcode.com/problems/h-index/discuss/656820/Python-O(n)-timeandspace-with-explanation\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations):\\n        if not citations: return 0\\n        n = len(citations)\\n        beg, end = 0, n - 1\\n        while beg <= end:\\n            mid = (beg + end)//2\\n            if mid + citations[mid] >= n:\\n                end = mid - 1\\n            else:\\n                beg = mid + 1                \\n        return n - beg\\n```\n```\\nclass Solution:\\n    def hIndex(self, c):\\n        return ([i+j>=len(c) for i,j in enumerate(c)][::-1]+[0]).index(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71071,
                "title": "o-logn-time-o-1-space-easy-solution-with-detailed-explanations-c-java-python",
                "content": "The basic idea of this solution is to use **binary search** to find the minimum `index` such that\\n\\n    citations[index] >= length(citations) - index\\n\\nAfter finding this `index`, the answer is `length(citations) - index`.\\n\\nThis logic is very similar to the C++ function `lower_bound` or `upper_bound`.\\n\\n----------\\n\\nComplexities:\\n\\n- Time: O(log *n*)\\n- Space: O(1)\\n\\n----------\\n\\n\\n**C++:**\\n\\n    class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            int size = citations.size();\\n\\n            int first = 0;\\n            int mid;\\n            int count = size;\\n            int step;\\n            \\n            while (count > 0) {\\n                step = count / 2;\\n                mid = first + step;\\n                if (citations[mid] < size - mid) {\\n                    first = mid + 1;\\n                    count -= (step + 1);\\n                }\\n                else {\\n                    count = step;\\n                }\\n            }\\n            \\n            return size - first;\\n        }\\n    };\\n\\n\\n\\n\\n**Java:**\\n\\n    public class Solution {\\n        public int hIndex(int[] citations) {\\n            int len = citations.length;\\n\\n            int first = 0;\\n            int mid;\\n            int count = len;\\n            int step;\\n            \\n            while (count > 0) {\\n                step = count / 2;\\n                mid = first + step;\\n                if (citations[mid] < len - mid) {\\n                    first = mid + 1;\\n                    count -= (step + 1);\\n                }\\n                else {\\n                    count = step;\\n                }\\n            }\\n            \\n            return len - first;\\n        }\\n    }\\n\\n**Python:**\\n\\n    class Solution(object):\\n        def hIndex(self, citations):\\n            \"\"\"\\n            :type citations: List[int]\\n            :rtype: int\\n            \"\"\"\\n            \\n            length = len(citations)\\n            \\n            first = 0\\n            count = length\\n            \\n            while count > 0:\\n                step = count / 2\\n                mid = first + step\\n                if citations[mid] < length - mid:\\n                    first = mid + 1\\n                    count -= (step + 1)\\n                else:\\n                    count = step\\n            \\n            return length - first\\n            \\n------------------\\n\\n**@daviantan1890  @ruichang** Thank you for your comments and discussions.\\n\\nI am very sure that two-branch binary search is more efficient than three branch binary search.\\nand (low + high) is not good idea since it may rely on the overflow behavior.\\nIn fact, using `count` `step` `first` `mid` is the standard implement way of C++, so I do not think there are better ways to implement the binary search.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            int size = citations.size();\\n\\n            int first = 0;\\n            int mid;\\n            int count = size;\\n            int step;\\n            \\n            while (count > 0) {\\n                step = count / 2;\\n                mid = first + step;\\n                if (citations[mid] < size - mid) {\\n                    first = mid + 1;\\n                    count -= (step + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 71093,
                "title": "short-python-o-log-n-solution",
                "content": "The idea is to do binary search to find the min index such that `citations[i] >= len(citations) - i`, then the answer is `len(citations)-i`\\n\\n    def hIndex(self, citations):\\n        n = len(citations)\\n        l, r = 0, n-1\\n        while l <= r:\\n            mid = (l+r)/2\\n            if citations[mid] >= n-mid:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return n-l",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "The idea is to do binary search to find the min index such that `citations[i] >= len(citations) - i`, then the answer is `len(citations)-i`\\n\\n    def hIndex(self, citations):\\n        n = len(citations)\\n        l, r = 0, n-1\\n        while l <= r:\\n            mid = (l+r)/2\\n            if citations[mid] >= n-mid:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return n-l",
                "codeTag": "Python3"
            },
            {
                "id": 71115,
                "title": "very-standard-binary-search-using-start-1-end",
                "content": "    public class Solution {\\n        public int hIndex(int[] citations) {\\n            int length = citations.length;\\n            if (length == 0) return 0;\\n            int start = 0, end = length-1;\\n            while (start + 1 < end) {\\n                int mid = start + (end-start)/2;\\n                if (citations[mid] == length-mid) {\\n                    return length-mid;\\n                } else if (citations[mid] > length-mid) {\\n                    end = mid;\\n                } else {\\n                    start = mid;\\n                }\\n            }\\n            // once jump out, always check start & end\\n            if (citations[start] >= length-start) return length-start;\\n            if (citations[end] >= length-end) return length-end;\\n            return 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            int length = citations.length;\\n            if (length == 0) return 0;\\n            int start = 0, end = length-1;\\n            while (start + 1 < end) {\\n                int mid = start + (end-start)/2;\\n                if (citations[mid] == length-mid) {\\n                    return length-mid;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 71090,
                "title": "most-clear-explanation-binary-search-java-solution",
                "content": "We use two pinter to solve this problem: pointer l (low) and pointer h (high).\\n\\nSay n = citations.length. \\nBecause the range of H-index is [0,n], at the beginning we must point high pointer after the last element of the array: h = n. In this way we can generate all possible value without worrying about annoying corner case.\\n\\nThe rest is standard binary search, we find middle point m and compare **citations[m]** with **n-m** (n-m means number of papers has at least citations[m] citations.)\\n1. citations[m] == n-m : we find the answer\\n2. citations[m] < n-m : more papers has at least this number of citations we should raise the bar of citations so we go to the right part: l = m+1.\\n3. citations[m] > n-m : we should lower the bar so we go to the left part: h = m.\\n\\nIn the end **l == r** and the H-index is n-l.\\n\\n```\\npublic class Solution {\\n    public int hIndex(int[] citations) {\\n        int n=citations.length;\\n        int l=0, h=citations.length;\\n        while(l<h){\\n            int m=l+h>>>1;\\n            if(citations[m]==n-m)\\n                return n-m;\\n            else if(citations[m]<n-m){\\n                l=m+1;\\n            }else{\\n                h=m;\\n            }\\n        }\\n        return n-l;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int hIndex(int[] citations) {\\n        int n=citations.length;\\n        int l=0, h=citations.length;\\n        while(l<h){\\n            int m=l+h>>>1;\\n            if(citations[m]==n-m)\\n                return n-m;\\n            else if(citations[m]<n-m){\\n                l=m+1;\\n            }else{\\n                h=m;\\n            }\\n        }\\n        return n-l;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71117,
                "title": "share-my-c-o-logn-solution-with-explanation",
                "content": "The basic idea comes from the description **h of his/her N papers have at least h citations each**.\\nTherefore, we know `if \"mid + 1\" is a valid h index, it means value of position \"citationsSize - mid - 1\" must exceed \"mid\"`. After we find a valid h index, we go on searching on the right part to see if we can find a larger h index.\\nIf it's not a valid h index, the h index can be found in the left part and we simply follow the standard binary search to solve this problem. \\n    \\n    int hIndex(int* citations, int citationsSize) {\\n        int lo = 0, hi = citationsSize, mid, index = 0;\\n        while (lo <= hi) {\\n            mid = lo + ((hi - lo) >> 1);\\n            if (citations[citationsSize - mid - 1] > mid) {\\n                lo = mid + 1;\\n                index = lo;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return index;\\n    }",
                "solutionTags": [],
                "code": "The basic idea comes from the description **h of his/her N papers have at least h citations each**.\\nTherefore, we know `if \"mid + 1\" is a valid h index, it means value of position \"citationsSize - mid - 1\" must exceed \"mid\"`. After we find a valid h index, we go on searching on the right part to see if we can find a larger h index.\\nIf it's not a valid h index, the h index can be found in the left part and we simply follow the standard binary search to solve this problem. \\n    \\n    int hIndex(int* citations, int citationsSize) {\\n        int lo = 0, hi = citationsSize, mid, index = 0;\\n        while (lo <= hi) {\\n            mid = lo + ((hi - lo) >> 1);\\n            if (citations[citationsSize - mid - 1] > mid) {\\n                lo = mid + 1;\\n                index = lo;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return index;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71097,
                "title": "c-binary-search",
                "content": "    class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            if (citations.empty()) return 0;\\n            int start = 0, len = citations.size(), end = len - 1;\\n            while (start <= end) {\\n                int mid = (start + end)/2;\\n                if (citations[mid] < len - mid)\\n                    start = mid + 1;\\n                else if (citations[mid] > len - mid)\\n                    end = mid - 1;\\n                else return len - mid;\\n            }\\n            return len - start;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int hIndex(vector<int>& citations) {\\n            if (citations.empty()) return 0;\\n            int start = 0, len = citations.size(), end = len - 1;\\n            while (start <= end) {\\n                int mid = (start + end)/2;\\n                if (citations[mid] < len - mid)\\n                    start = mid + 1;\\n                else if (citations[mid] > len - mid)\\n                    end = mid - 1;\\n                else return len - mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71148,
                "title": "binary-search-in-python",
                "content": "Binary Search With Runtime Complexity of O(log n):\\n\\n    class Solution(object):\\n        def hIndex(self, citations):\\n            \"\"\"\\n            :type citations: List[int]\\n            :rtype: int\\n            \"\"\"\\n            N = len(citations)\\n            low, high = 0, N - 1\\n            while low <= high:\\n                mid = (low + high) / 2\\n                if N - mid > citations[mid]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return N - low\\n\\nRef: [http://bookshadow.com/weblog/2015/09/04/leetcode-h-index-ii/][1]\\n\\n\\n  [1]: http://bookshadow.com/weblog/2015/09/04/leetcode-h-index-ii/",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "Binary Search With Runtime Complexity of O(log n):\\n\\n    class Solution(object):\\n        def hIndex(self, citations):\\n            \"\"\"\\n            :type citations: List[int]\\n            :rtype: int\\n            \"\"\"\\n            N = len(citations)\\n            low, high = 0, N - 1\\n            while low <= high:\\n                mid = (low + high) / 2\\n                if N - mid > citations[mid]:\\n                    low = mid + 1\\n                else:\\n                    high = mid - 1\\n            return N - low\\n\\nRef: [http://bookshadow.com/weblog/2015/09/04/leetcode-h-index-ii/][1]\\n\\n\\n  [1]: http://bookshadow.com/weblog/2015/09/04/leetcode-h-index-ii/",
                "codeTag": "Java"
            },
            {
                "id": 404677,
                "title": "here-s-a-very-concise-7-line-c-solution-why-is-everyone-writing-messy-binary-search",
                "content": "Some solutions with high votes really sting my eyes. \\nHowever, it does take some experience to write a good binary search sometimes.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size(), l = 0, r = n;\\n        while(l < r){\\n            int mid = l + (r - l) / 2;\\n            if(citations[mid] >= n - mid) r = mid;\\n            else l = mid + 1;\\n        }\\n        return n - r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size(), l = 0, r = n;\\n        while(l < r){\\n            int mid = l + (r - l) / 2;\\n            if(citations[mid] >= n - mid) r = mid;\\n            else l = mid + 1;\\n        }\\n        return n - r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71119,
                "title": "c-binary-search-h-index-ii",
                "content": "    int hIndex(vector<int>& citations) {\\n        const int size_c = citations.size();\\n        int left = 0, right = size_c - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (citations[mid] < size_c - mid) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return size_c - left;\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "    int hIndex(vector<int>& citations) {\\n        const int size_c = citations.size();\\n        int left = 0, right = size_c - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (citations[mid] < size_c - mid) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return size_c - left;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3420753,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) \\n    {\\n        int n = citations.size();\\n        int min = 0, max = n - 1;\\n        int mid;\\n        while (min <= max)\\n         {\\n            mid = (min + max) / 2;\\n            if (citations[mid] < n - mid) \\n            {\\n                min = mid + 1;\\n            } \\n            else \\n            {\\n                max = mid - 1;\\n            }\\n        }\\n        return n - min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) \\n    {\\n        int n = citations.size();\\n        int min = 0, max = n - 1;\\n        int mid;\\n        while (min <= max)\\n         {\\n            mid = (min + max) / 2;\\n            if (citations[mid] < n - mid) \\n            {\\n                min = mid + 1;\\n            } \\n            else \\n            {\\n                max = mid - 1;\\n            }\\n        }\\n        return n - min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235216,
                "title": "275-time-98-1-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem is a follow-up to the H-Index problem with the added constraint that the input array is sorted in ascending order. As a result, we can take advantage of this property to optimize the solution.\\n\\nThe basic idea is to use binary search to find the h-index. Since the array is sorted in ascending order, we can use the index to represent the citation count. For example, citations[3] means the number of papers that have at least 4 citations.\\n\\nLet\\'s take the example [0, 1, 3, 5, 6] and the length of the array n = 5. We start by initializing the left and right pointers to 0 and n - 1, respectively. The mid index is (left + right) // 2 = 2. The corresponding citation count is citations[2] = 3. Since there are 3 papers with at least 3 citations, and the remaining two papers have no more than 3 citations, the h-index is 3.\\n\\nIf citations[2] is less than n - 2, then we need to move the left pointer to mid + 1, and if citations[2] is greater than or equal to n - 2, then we need to move the right pointer to mid - 1. We repeat the process until left > right.\\n\\nThe time complexity of the algorithm is O(log n), and the space complexity is O(1).\\n\\n# Complexity\\n- Time complexity:\\n98.1%\\n\\n- Space complexity:\\n75.12%\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        left, right = 0, n - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if citations[mid] == n - mid:\\n                return n - mid\\n            elif citations[mid] < n - mid:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return n - left\\n\\n```\\n\\nNote that we return n - left instead of n - mid because left may not be at the exact position of the h-index. However, we know that left is the smallest index that satisfies citations[left] >= n - left, so n - left is the correct answer.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        left, right = 0, n - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if citations[mid] == n - mid:\\n                return n - mid\\n            elif citations[mid] < n - mid:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return n - left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71144,
                "title": "two-solutions-o-log-n-o-n",
                "content": "1. O(lg n)\\n\\n        int hIndex(vector<int>& citations) {\\n\\t\\t   int left = 0;\\n\\t       int right = citations.size() - 1;\\n  \\t\\t   int n = citations.size();\\n\\t\\t   int last = 0;\\n\\n\\t\\t   while (left <= right) {\\n\\t\\t  \\t  int mid = left + (right - left) / 2;\\n\\t\\t\\t  if (citations[mid] == n - mid)\\n\\t\\t\\t  \\treturn n - mid;\\n\\n\\t\\t\\t  if (n - mid < citations[mid]) {\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t\\tlast = n - mid;\\n\\t\\t\\t  }\\n\\t\\t\\t  else\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t   }\\n\\n\\t\\t   return last;\\n\\t    }\\n\\n\\n\\n\\n2. O(n)\\n\\n        int hIndex(vector<int>& citations) {\\n           int n = citations.size();\\n           for(int i = 0; i<citations.size(); i++) {\\n              if(n - i <= citations[i])\\n                   return n - i;\\n           }\\n        \\n           return 0;\\n        }",
                "solutionTags": [],
                "code": "1. O(lg n)\\n\\n        int hIndex(vector<int>& citations) {\\n\\t\\t   int left = 0;\\n\\t       int right = citations.size() - 1;\\n  \\t\\t   int n = citations.size();\\n\\t\\t   int last = 0;\\n\\n\\t\\t   while (left <= right) {\\n\\t\\t  \\t  int mid = left + (right - left) / 2;\\n\\t\\t\\t  if (citations[mid] == n - mid)\\n\\t\\t\\t  \\treturn n - mid;\\n\\n\\t\\t\\t  if (n - mid < citations[mid]) {\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t\\tlast = n - mid;\\n\\t\\t\\t  }\\n\\t\\t\\t  else\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t   }\\n\\n\\t\\t   return last;\\n\\t    }\\n\\n\\n\\n\\n2. O(n)\\n\\n        int hIndex(vector<int>& citations) {\\n           int n = citations.size();\\n           for(int i = 0; i<citations.size(); i++) {\\n              if(n - i <= citations[i])\\n                   return n - i;\\n           }\\n        \\n           return 0;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3296545,
                "title": "java-clear-explanation-binary-search",
                "content": "We use the concept of Binary Search where low=0 and high=n-1(last element).\\n\\nSay n = citations.length.\\nBecause the range of H-index is [0,n], at the beginning we must point high pointer at the last element of the array: h = n-1. In this way whenever we compute and find the answer we can store the answer in  another variable ANS.\\n\\nThe rest is standard binary search, we find middle point m and compare citations[m] with n-m (n-m means number of papers has at least citations[m] citations.)\\n\\ncitations[m] == n-m : we find the answer where the n-m means number of papers has at least citations[m] citations.\\ncitations[m] < n-m : Here the citations in (n-m) is more so to reduce it we must Increase m so move right i.e l=m+1.\\ncitations[m] > n-m : Here the citations in (n-m) is less so to Increase it we must reeduce m so move left i.e h=m-1.\\n\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        \\n        int n=citations.length;\\n        int low=0;\\n        int high=n-1;\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            if(citations[mid]==n-mid){\\n                ans=n-mid;\\n                return ans;\\n                \\n            }\\n            else if(citations[mid]<n-mid){\\n                low=mid+1;\\n            }else if(citations[mid]>n-mid){\\n                high=mid-1;\\n            }\\n            \\n            \\n            \\n        }\\n        return n-low;\\n    }\\n}\\n```\\n\\n\\n\\nThanks.\\nIf any doubt post in comment section.",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        \\n        int n=citations.length;\\n        int low=0;\\n        int high=n-1;\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            \\n            if(citations[mid]==n-mid){\\n                ans=n-mid;\\n                return ans;\\n                \\n            }\\n            else if(citations[mid]<n-mid){\\n                low=mid+1;\\n            }else if(citations[mid]>n-mid){\\n                high=mid-1;\\n            }\\n            \\n            \\n            \\n        }\\n        return n-low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093362,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations=citations[::-1]\\n        for i in range(len(citations)):\\n            if citations[i]<=i:\\n                return i\\n        return len(citations)     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        citations=citations[::-1]\\n        for i in range(len(citations)):\\n            if citations[i]<=i:\\n                return i\\n        return len(citations)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 693522,
                "title": "python-o-log-n-with-explanation",
                "content": "Explanation:\\nI will break this down in to two cases.\\n\\nCase 1\\uFF1AIf n-mid==citations[mid]: \\nWe cannot increase the h-index anymore. (If we increase it by 1, the citation before will be excluded, and the number of citations>=h-index will definitely be less than h-index)\\n\\nCase 2: We exit the binary search without hitting the n-mid==citations[mid] condition\\uFF1A\\nWe know that the binary search will stop at the index where citations[low-1]<h-index< citations[low], the maximum h-index possible will be the length of citations[low:]. \\n\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n=len(citations)\\n        if n==0:return 0\\n        low=0;high=n\\n        while high>low:\\n            mid=(low+high)//2\\n            if n-mid==citations[mid]:\\n                return n-mid\\n            if n-mid>citations[mid]:\\n                low=mid+1\\n            else:\\n                high=mid\\n        return n-low\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n=len(citations)\\n        if n==0:return 0\\n        low=0;high=n\\n        while high>low:\\n            mid=(low+high)//2\\n            if n-mid==citations[mid]:\\n                return n-mid\\n            if n-mid>citations[mid]:\\n                low=mid+1\\n            else:\\n                high=mid\\n        return n-low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71146,
                "title": "easy-o-logn-c-8ms-solution",
                "content": "    int hIndex(vector<int>& citations) {\\n        int size = citations.size();\\n        if (size == 0) {\\n            return 0;\\n        }\\n        int l = 0, r = size - 1; \\n        while (l < r) {\\n            int m = (l + r) / 2;\\n            if (citations[m] < size - m) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        if (!citations[r]) {\\n            return 0;\\n        } else {\\n            return size - r;\\n        }\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "    int hIndex(vector<int>& citations) {\\n        int size = citations.size();\\n        if (size == 0) {\\n            return 0;\\n        }\\n        int l = 0, r = size - 1; \\n        while (l < r) {\\n            int m = (l + r) / 2;\\n            if (citations[m] < size - m) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        if (!citations[r]) {\\n            return 0;\\n        } else {\\n            return size - r;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3825641,
                "title": "100-faster-sufficient-intuition-binary-search",
                "content": "# Intuition\\n  100 % faster solution:\\uD83C\\uDFC6\\uD83C\\uDFC6\\n   \\n![Screenshot 2023-07-28 001104.png](https://assets.leetcode.com/users/images/2875fa6f-32b7-48ec-9647-7ca1645e7751_1690486356.7312574.png)\\n\\n****we require atleast m numbers of papers, which having greater or equal to m citations.****\\n\\neg. [ 3 , 2 , 5 , 1 , 7 , 4] in this array [5,7,4] these are the elements that we can select (**because these 3 papers citations are >= 3).**\\n\\n****if we select [3,5,7,4] from input array then there should be atleast 4 elements(in this problem called research paper) which have to greater than or equal to 4 . but in above selected array 3 element is not greater than 4 . which is not valid for citation criteria****\\n\\nSo,we can\\'t include 3. hence ans will be 3 which is [5 , 7, 4]\\uD83D\\uDE80\\n\\n# Complexity\\n- Time complexity:\\n   O(log N)\\n\\n- Space complexity:\\n  O(1)\\n\\n **if you find helpful Kindly Upvote**\\uD83D\\uDE80\\uD83D\\uDE80\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        int l = 0 , h = n-1;\\n        int ans = 0 ;\\n        while( l <= h ){\\n            int mid = l + (h-l)/2;\\n            int idx = n - mid ;\\n            if(citations[mid] >= idx){\\n                ans = idx ;\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        int l = 0 , h = n-1;\\n        int ans = 0 ;\\n        while( l <= h ){\\n            int mid = l + (h-l)/2;\\n            int idx = n - mid ;\\n            if(citations[mid] >= idx){\\n                ans = idx ;\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914648,
                "title": "c-solution-binary-search-clean-concise-code",
                "content": "\\n# Complexity\\n- Time complexity: O(log N . Range)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        ios::sync_with_stdio(0);\\n        cin.tie(NULL);\\n        \\n        int n = c.size();\\n        int low = 0, high = n - 1, mid;\\n        while(low <= high) {\\n            //To Avoid overflow Condition\\n            int mid = low + (high - low) / 2;\\n            if(c[mid] == (n - mid))\\n                return c[mid];\\n            \\n            else if(c[mid] > (n - mid))\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n        return n - low;\\n    }\\n};\\n```\\n\\n\\nPlease **Upvote** this simple solution!!\\nHappy Coding:)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        ios::sync_with_stdio(0);\\n        cin.tie(NULL);\\n        \\n        int n = c.size();\\n        int low = 0, high = n - 1, mid;\\n        while(low <= high) {\\n            //To Avoid overflow Condition\\n            int mid = low + (high - low) / 2;\\n            if(c[mid] == (n - mid))\\n                return c[mid];\\n            \\n            else if(c[mid] > (n - mid))\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n        return n - low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729382,
                "title": "python3-solution-binary-search-o-logn",
                "content": "`Time Complexity` : `O(logn)`\\n`Space Complexity` : `O(1)`\\n```\\nclass Solution:\\n    def hIndex(self, A):\\n        n = len(A)\\n        l, r = 0, n - 1\\n        while l < r:\\n            m = (l + r + 1) // 2\\n            if A[m] > n - m: r = m - 1\\n            else: l = m\\n        return n - l - (A[l] < n - l)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, A):\\n        n = len(A)\\n        l, r = 0, n - 1\\n        while l < r:\\n            m = (l + r + 1) // 2\\n            if A[m] > n - m: r = m - 1\\n            else: l = m\\n        return n - l - (A[l] < n - l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004229,
                "title": "c-2-solutions-with-without-priority-queue-same-code-for-274-h-index",
                "content": "//same solution for [274. H-Index ](https://leetcode.com/problems/h-index/)\\n**WITH PRIORITY QUEUE**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint hIndex(vector<int>& citations) {\\n\\t\\t\\t\\tint index;\\n\\t\\t\\t\\tpriority_queue<int> pq(begin(citations), end(citations));\\n\\n\\t\\t\\t\\tfor (index = 0; !pq.empty() && index < pq.top();index++)\\n\\t\\t\\t\\t\\tpq.pop();  \\n\\n\\t\\t\\t\\treturn index;\\n\\t\\t\\t}\\n\\t\\t};\\n**WITHOUT PRIORITY QUEUE**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint hIndex(vector<int>& citations) {\\n\\t\\t\\tint index;\\n\\t\\t\\tsort(citations.begin(),citations.end(),greater<int>());\\n\\t\\t\\tint n=citations.size();\\n\\t\\t\\tfor (index = 0;index<n;index++){\\n\\t\\t\\t\\tif(index>=citations[index])break;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn index;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint hIndex(vector<int>& citations) {\\n\\t\\t\\t\\tint index;\\n\\t\\t\\t\\tpriority_queue<int> pq(begin(citations), end(citations));\\n\\n\\t\\t\\t\\tfor (index = 0; !pq.empty() && index < pq.top();index++)\\n\\t\\t\\t\\t\\tpq.pop();  \\n\\n\\t\\t\\t\\treturn index;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1939699,
                "title": "c-easy-binary-100",
                "content": "The array is sorted and we need to find the h-index in O(logN), only one thing clicks in mind and that is binary search. See the code for implementation.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool check(int x, vector<int>& a){\\n        \\n        // length of array from mid to end\\n        int len = a.size() - x;\\n        \\n        if(x > 0){\\n            // Checking for the definition of h-index mentioned in question\\n            if(a[x-1] <= len && a[x] >= len)\\n                return true;\\n            else\\n                return false;\\n        }\\n        else{\\n            if(a[x] >= len)\\n                return true;\\n            else\\n                return false;\\n        }\\n    }\\n    \\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        \\n        // For binary search we are taking low & high as value index of elements of array\\n        int low = 0, high = n-1;\\n        int ans = 0;\\n\\n        while(low <= high){\\n            // mid = index of element of minimum number of citations which is >= h\\n            // Here h = (n - mid) = length of array from mid to end\\n            int mid = low + (high - low)/2;\\n            \\n            // Checking if this value satisfies as h-index\\n            if(check(mid, citations)){\\n                // If yes then we are changing high because we now want to check for higher\\n                // values and as we increase h-index we need to increase the length of array\\n                // from mid to end, therefore high decreased (not low increased)\\n                ans = n - mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                // Here length of array from mid is greater than citations number but we need\\n                // to have comparable values in both so we need to increase citation value and\\n                // decrease length from mid to end therefore low is increased\\n                if(n - mid > citations[mid])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\nUpvote if you found my solution helpful :-)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool check(int x, vector<int>& a){\\n        \\n        // length of array from mid to end\\n        int len = a.size() - x;\\n        \\n        if(x > 0){\\n            // Checking for the definition of h-index mentioned in question\\n            if(a[x-1] <= len && a[x] >= len)\\n                return true;\\n            else\\n                return false;\\n        }\\n        else{\\n            if(a[x] >= len)\\n                return true;\\n            else\\n                return false;\\n        }\\n    }\\n    \\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        \\n        // For binary search we are taking low & high as value index of elements of array\\n        int low = 0, high = n-1;\\n        int ans = 0;\\n\\n        while(low <= high){\\n            // mid = index of element of minimum number of citations which is >= h\\n            // Here h = (n - mid) = length of array from mid to end\\n            int mid = low + (high - low)/2;\\n            \\n            // Checking if this value satisfies as h-index\\n            if(check(mid, citations)){\\n                // If yes then we are changing high because we now want to check for higher\\n                // values and as we increase h-index we need to increase the length of array\\n                // from mid to end, therefore high decreased (not low increased)\\n                ans = n - mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                // Here length of array from mid is greater than citations number but we need\\n                // to have comparable values in both so we need to increase citation value and\\n                // decrease length from mid to end therefore low is increased\\n                if(n - mid > citations[mid])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694394,
                "title": "c-solution-and-explanation",
                "content": "Intuition: Since the vector is sorted in ascending order, this problem is to find the first element i which satisfy: citation[i] >= n-i, where n=citations.size. (Notice that citation[i] is the smallest among the elements from i to the last one). For the following element j larger than i, since citation[j] will become larger while n-j will become smaller, the reqirement will always be meet for the elements on the right. Therefor the problem is implicitly sorted, we can use binery search.\\n\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n=citations.size();\\n        int l=0, r=citations.size();\\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            if(citations[m]>=n-m) r=m;\\n            else l=m+1;\\n        }\\n        \\n        return n-l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n=citations.size();\\n        int l=0, r=citations.size();\\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            if(citations[m]>=n-m) r=m;\\n            else l=m+1;\\n        }\\n        \\n        return n-l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693553,
                "title": "javascript-binary-search",
                "content": "To better understand, please visit to link:\\nhttps://youtu.be/tQ15fhm2d6s?t=2\\n```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    let start = 0, end = citations.length-1\\n    while(start <= end){\\n        let mid = Math.floor((start+end)/2)\\n        if(mid+1 <= citations[citations.length-mid-1]){\\n            start = mid + 1\\n            continue\\n        }\\n        end=mid-1\\n    }\\n    return start\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    let start = 0, end = citations.length-1\\n    while(start <= end){\\n        let mid = Math.floor((start+end)/2)\\n        if(mid+1 <= citations[citations.length-mid-1]){\\n            start = mid + 1\\n            continue\\n        }\\n        end=mid-1\\n    }\\n    return start\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71109,
                "title": "clean-python-code",
                "content": "    class Solution(object):\\n        def hIndex(self, citations):\\n            n = len(citations)\\n    \\n            low, high = 0, n - 1\\n            while low <= high:\\n                mid = low + high >> 1\\n                if citations[mid] < n - mid:\\n                    low = mid + 1\\n                else:\\n                    if mid == 0 or citations[mid - 1] < n - mid + 1:\\n                        return n - mid\\n                    high = mid - 1\\n            return 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def hIndex(self, citations):\\n            n = len(citations)\\n    \\n            low, high = 0, n - 1\\n            while low <= high:\\n                mid = low + high >> 1\\n                if citations[mid] < n - mid:\\n                    low = mid + 1\\n                else:\\n                    if mid == 0 or citations[mid - 1] < n - mid + 1:\\n                        return n - mid\\n                    high = mid - 1\\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 4012453,
                "title": "h-index-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        if(!n) return 0;\\n        int low =0,high=n-1;\\n        int ans = 0;\\n        while(low<=high){\\n            int mid  = low + (high-low)/2;\\n            if(c[mid] >= n-mid){\\n                ans = n-mid;\\n                high = mid - 1;\\n            }else{\\n                low  = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        if(!n) return 0;\\n        int low =0,high=n-1;\\n        int ans = 0;\\n        while(low<=high){\\n            int mid  = low + (high-low)/2;\\n            if(c[mid] >= n-mid){\\n                ans = n-mid;\\n                high = mid - 1;\\n            }else{\\n                low  = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775351,
                "title": "both-o-n-using-linear-and-o-logn-using-binary-search",
                "content": "# Complexity\\n- Time complexity: $$O(logn)$$ \\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        // O(n) Time Complexity\\n        // int n = citations.length;\\n        // int index = 0;\\n        // while(index < n && n - index > citations[index]){\\n        //     index++;\\n        // }\\n        // return n - index;\\n\\n        // O(logn) Time Complexity // Binary Search:- Since Sorted Array\\n        int left = 0, right = citations.length - 1;\\n        int n = citations.length;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(citations[mid] == n - mid) return n - mid;\\n            else if(citations[mid] < n - mid) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return n - left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        // O(n) Time Complexity\\n        // int n = citations.length;\\n        // int index = 0;\\n        // while(index < n && n - index > citations[index]){\\n        //     index++;\\n        // }\\n        // return n - index;\\n\\n        // O(logn) Time Complexity // Binary Search:- Since Sorted Array\\n        int left = 0, right = citations.length - 1;\\n        int n = citations.length;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(citations[mid] == n - mid) return n - mid;\\n            else if(citations[mid] < n - mid) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return n - left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733755,
                "title": "binary-search-explained-c-neat-and-short-code-o-log-n-time-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the word montonic is given we can easily think of searching through binary search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, now this one is example of binary search on answer so we make analyze the search space as the min can be 1 and max can be n so range becomes[1,citations.size()] and we simply apply binary searching on this search space and alayze the condition by making a chk function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool chk(int mid, vector<int> &citations){\\n        int cnt=citations.size();\\n        for(auto&x:citations){\\n            if(x<mid)cnt--;\\n        }\\n        return (cnt>=mid);\\n    }\\n    int hIndex(vector<int>& citations) {\\n        int lo=1, hi=citations.size();\\n        int ans=0;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(chk(mid,citations)){\\n                ans=max(ans,mid);\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool chk(int mid, vector<int> &citations){\\n        int cnt=citations.size();\\n        for(auto&x:citations){\\n            if(x<mid)cnt--;\\n        }\\n        return (cnt>=mid);\\n    }\\n    int hIndex(vector<int>& citations) {\\n        int lo=1, hi=citations.size();\\n        int ans=0;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(chk(mid,citations)){\\n                ans=max(ans,mid);\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758962,
                "title": "c-binary-search-only-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int hIndex(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        int st = 0;\\n        int end = n-1;\\n        \\n        while(st <= end){\\n            int mid = st + (end-st)/2;\\n            \\n            if(arr[mid] == n-mid){\\n                return arr[mid];\\n            }\\n            \\n            else if(arr[mid] > n-mid){\\n                end = mid-1;\\n            }\\n            else st = mid+1;\\n            \\n        }\\n        return n-st;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int hIndex(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\n        int st = 0;\\n        int end = n-1;\\n        \\n        while(st <= end){\\n            int mid = st + (end-st)/2;\\n            \\n            if(arr[mid] == n-mid){\\n                return arr[mid];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2668023,
                "title": "c-nive-solution-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int hIndex(vector<int>& citations) {\\n        int i = 0, j = citations.size() - 1;\\n        while(j >= 0 && citations[j] > i) i++, j--;\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int hIndex(vector<int>& citations) {\\n        int i = 0, j = citations.size() - 1;\\n        while(j >= 0 && citations[j] > i) i++, j--;\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570904,
                "title": "fastest-java-solution",
                "content": "class Solution {\\n    public int hIndex(int[] citations) {\\n        int li=0;\\n        int hi=citations.length-1;\\n        \\n        int n = citations.length;\\n        \\n        while(li<=hi){\\n            int mi=li+(hi-li)/2;\\n            if(citations[mi]==(n-mi)){\\n                return citations[mi];\\n            }\\n            else if(citations[mi]>(n-mi)){\\n                hi=mi-1;\\n            }\\n            else{\\n                li=mi+1;\\n            }\\n        }\\n        return n-li;\\n    }\\n}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        int li=0;\\n        int hi=citations.length-1;\\n        \\n        int n = citations.length;\\n        \\n        while(li<=hi){\\n            int mi=li+(hi-li)/2;\\n            if(citations[mi]==(n-mi)){\\n                return citations[mi];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2106897,
                "title": "c-binary-search-on-answer-o-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, int k){\\n        int n=nums.size();\\n        if(k!=0 and nums[n-k]>=k and nums[n-k-1]<=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int hIndex(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        if(nums[0]>=n){\\n            return n;\\n        }\\n        \\n        \\n        int l=1,r=n;\\n        int res=0;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(isPossible(nums,mid)){\\n                res=mid;\\n                l=mid+1;\\n            }else{\\n                if(nums[n-mid]>=mid and nums[n-mid-1]>mid){\\n                    l=mid+1;\\n                }else{\\n                    r=mid-1;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, int k){\\n        int n=nums.size();\\n        if(k!=0 and nums[n-k]>=k and nums[n-k-1]<=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int hIndex(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        if(nums[0]>=n){\\n            return n;\\n        }\\n        \\n        \\n        int l=1,r=n;\\n        int res=0;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(isPossible(nums,mid)){\\n                res=mid;\\n                l=mid+1;\\n            }else{\\n                if(nums[n-mid]>=mid and nums[n-mid-1]>mid){\\n                    l=mid+1;\\n                }else{\\n                    r=mid-1;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101967,
                "title": "c-binary-search-o-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        int low = 0;\\n        int high = citations.size()-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n            if(citations[mid] == ((n - mid))){\\n                return citations[mid];\\n            }\\n            else if(citations[mid]  < (n - mid)){\\n                low = mid +  1;\\n            }\\n            else if(citations[mid] > (n-mid)){\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return n - low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        int low = 0;\\n        int high = citations.size()-1;\\n\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n            if(citations[mid] == ((n - mid))){\\n                return citations[mid];\\n            }\\n            else if(citations[mid]  < (n - mid)){\\n                low = mid +  1;\\n            }\\n            else if(citations[mid] > (n-mid)){\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return n - low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975890,
                "title": "python3-binary-search-simple-clean",
                "content": "```\\ndef hIndex(self, citations: List[int]) -> int:\\n        l, r = 0, citations[-1]\\n        while l < r:\\n            m = (l + r + 1) >> 1\\n            cnt = sum([c >= m for c in citations])\\n            if cnt < m:\\n                r = m - 1\\n            else:\\n                l = m\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef hIndex(self, citations: List[int]) -> int:\\n        l, r = 0, citations[-1]\\n        while l < r:\\n            m = (l + r + 1) >> 1\\n            cnt = sum([c >= m for c in citations])\\n            if cnt < m:\\n                r = m - 1\\n            else:\\n                l = m\\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1968913,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n    class Solution {\\n\\t\\n    public int hIndex(int[] citations) \\n    {\\n        int maximalIndex = 0;\\n        int hIndex = 1;\\n        \\n        \\n        // Handle the singleton case\\n        if(citations.length == 1)\\n        {\\n            if(citations[0] != 0) return 1;\\n            else return 0;\\n        }\\n        \\n        Arrays.sort(citations);\\n\\n        // Parition : (n-h):(h) papers - h/n have at least h citations\\n        int low = 0;\\n        int high = citations.length - 1;\\n        while(low <= high)\\n        {\\n            int mid = ( low + high ) / 2; // low + ((high-low)/2);\\n            hIndex = citations.length - mid;\\n            if(citations[mid] >= hIndex)\\n            {\\n                if(mid == 0) // can not grow hIndex any more here\\n                {\\n                    maximalIndex = hIndex;\\n                    break;\\n                }\\n                if(mid != 0 && citations[mid-1] <= hIndex) // the other (n-h) have no more values\\n                {\\n                    maximalIndex = hIndex;\\n                    high = mid - 1; // check above now\\n                }\\n                else\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n            else\\n            {\\n                low = mid + 1; // any ( array indices <= mid ) fail already ; no greater h-index works\\n            }\\n            \\n        }\\n        return maximalIndex;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\n    public int hIndex(int[] citations) \\n    {\\n        int maximalIndex = 0;\\n        int hIndex = 1;\\n        \\n        \\n        // Handle the singleton case\\n        if(citations.length == 1)\\n        {\\n            if(citations[0] != 0) return 1;\\n            else return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1960955,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] c) {\\n        int l=0,h=c.length-1,k=c.length;\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            if(c[m]==(k-m))\\n                return k-m;\\n            else if(c[m]>(k-m))\\n                h=m-1;\\n            else\\n                l=m+1;\\n        }\\n        return k-l;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int hIndex(int[] c) {\\n        int l=0,h=c.length-1,k=c.length;\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            if(c[m]==(k-m))\\n                return k-m;\\n            else if(c[m]>(k-m))\\n                h=m-1;\\n            else\\n                l=m+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1846915,
                "title": "c-simple-o-logn-solution-simple-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //t.c. logn\\n    int hIndex(vector<int>& c) {\\n        int n=c.size();\\n        int l=0;\\n        int h=n-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(c[mid]==n-mid){\\n                return c[mid];//our optimal ans for all time when c[mid]==n-mid\\n            }\\n            else if(c[mid]>n-mid){\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return n-l;//if we did not find c[mid]==n-mid we return all elemnt righthand side\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //t.c. logn\\n    int hIndex(vector<int>& c) {\\n        int n=c.size();\\n        int l=0;\\n        int h=n-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(c[mid]==n-mid){\\n                return c[mid];//our optimal ans for all time when c[mid]==n-mid\\n            }\\n            else if(c[mid]>n-mid){\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return n-l;//if we did not find c[mid]==n-mid we return all elemnt righthand side\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325353,
                "title": "java-binary-search-solution-o-logn-time-o-1-space",
                "content": "```\\n/*\\nTHOUGHT PROCESS : \\nthis is the binary search equivalent to the \"H-index\" problem [ 274 ] \\nURL ( for H-index ) = https://leetcode.com/problems/h-index/\\nURL ( for H-Index-II ) = https://leetcode.com/problems/h-index-ii/\\n\\nCan copy-paste highly similar code\\n\\nMajor gotchas\\n(a) Linearly probe the element right behind you in some cases \\n(b) Must account for hIndex =  ( citations.len - mid )  => think in the opposite direction now\\n\\nTrick : use (n-h:h) partitioning and sorted property to induct on a sorted sequence ( in ascending/descending order ) and guarantee proper convergence to some solution here\\n\\nThe cool part of binary search : is just like a linear search, but not auxillary space needed\\n\\n*/\\n\\nclass Solution \\n{\\n    public int hIndex(int[] citations) \\n    {\\n        int maximalIndex = 0;\\n        int hIndex = 1;\\n        \\n        \\n        // Handle the singleton case\\n        if(citations.length == 1)\\n        {\\n            if(citations[0] != 0) return 1;\\n            else return 0;\\n        }\\n        \\n        Arrays.sort(citations);\\n\\n        // Parition : (n-h):(h) papers - h/n have at least h citations\\n        int low = 0;\\n        int high = citations.length - 1;\\n        while(low <= high)\\n        {\\n            int mid = ( low + high ) / 2; // low + ((high-low)/2);\\n            hIndex = citations.length - mid;\\n            if(citations[mid] >= hIndex)\\n            {\\n                if(mid == 0) // can not grow hIndex any more here\\n                {\\n                    maximalIndex = hIndex;\\n                    break;\\n                }\\n                if(mid != 0 && citations[mid-1] <= hIndex) // the other (n-h) have no more values\\n                {\\n                    maximalIndex = hIndex;\\n                    high = mid - 1; // check above now\\n                }\\n                else\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n            else\\n            {\\n                low = mid + 1; // any ( array indices <= mid ) fail already ; no greater h-index works\\n            }\\n            \\n        }\\n        return maximalIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\nTHOUGHT PROCESS : \\nthis is the binary search equivalent to the \"H-index\" problem [ 274 ] \\nURL ( for H-index ) = https://leetcode.com/problems/h-index/\\nURL ( for H-Index-II ) = https://leetcode.com/problems/h-index-ii/\\n\\nCan copy-paste highly similar code\\n\\nMajor gotchas\\n(a) Linearly probe the element right behind you in some cases \\n(b) Must account for hIndex =  ( citations.len - mid )  => think in the opposite direction now\\n\\nTrick : use (n-h:h) partitioning and sorted property to induct on a sorted sequence ( in ascending/descending order ) and guarantee proper convergence to some solution here\\n\\nThe cool part of binary search : is just like a linear search, but not auxillary space needed\\n\\n*/\\n\\nclass Solution \\n{\\n    public int hIndex(int[] citations) \\n    {\\n        int maximalIndex = 0;\\n        int hIndex = 1;\\n        \\n        \\n        // Handle the singleton case\\n        if(citations.length == 1)\\n        {\\n            if(citations[0] != 0) return 1;\\n            else return 0;\\n        }\\n        \\n        Arrays.sort(citations);\\n\\n        // Parition : (n-h):(h) papers - h/n have at least h citations\\n        int low = 0;\\n        int high = citations.length - 1;\\n        while(low <= high)\\n        {\\n            int mid = ( low + high ) / 2; // low + ((high-low)/2);\\n            hIndex = citations.length - mid;\\n            if(citations[mid] >= hIndex)\\n            {\\n                if(mid == 0) // can not grow hIndex any more here\\n                {\\n                    maximalIndex = hIndex;\\n                    break;\\n                }\\n                if(mid != 0 && citations[mid-1] <= hIndex) // the other (n-h) have no more values\\n                {\\n                    maximalIndex = hIndex;\\n                    high = mid - 1; // check above now\\n                }\\n                else\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n            else\\n            {\\n                low = mid + 1; // any ( array indices <= mid ) fail already ; no greater h-index works\\n            }\\n            \\n        }\\n        return maximalIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285317,
                "title": "c-binary-search-logn",
                "content": "C++ | Binary Search | logn\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& a) {\\n        \\n        int n = a.size();\\n        \\n        // using predicate p(x): a[mid] >= n - mid.\\n        // this will result in FFFFTTTT.\\n        // I am looking for first T.\\n        \\n        int lo = 0, hi = n - 1;\\n        \\n        while(lo < hi){\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if(a[mid] >= n - mid ){\\n                hi = mid;\\n            } else{\\n                lo = mid + 1;\\n            }\\n        }\\n        // sanity check.\\n        if(a[lo] >= n - lo)\\n            return n - lo;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& a) {\\n        \\n        int n = a.size();\\n        \\n        // using predicate p(x): a[mid] >= n - mid.\\n        // this will result in FFFFTTTT.\\n        // I am looking for first T.\\n        \\n        int lo = 0, hi = n - 1;\\n        \\n        while(lo < hi){\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if(a[mid] >= n - mid ){\\n                hi = mid;\\n            } else{\\n                lo = mid + 1;\\n            }\\n        }\\n        // sanity check.\\n        if(a[lo] >= n - lo)\\n            return n - lo;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196609,
                "title": "old-school-binary-search",
                "content": "```\\nimport static java.lang.Math.ceil;\\nimport static java.lang.Math.max;\\nclass Solution {\\n    //already in ascending order\\n    public int hIndex(int[] citations) {\\n       return bisectArray(citations, 1, citations.length); \\n    }\\n    \\n    public int bisectArray(int[] citations, int start, int end) {\\n        // terminal case of recursion\\n        if(start > end) {\\n           return 0;\\n        }\\n        int mid = (int)(start+end)/2;\\n        int result = 0;\\n        \\n        if(citations[citations.length-mid] >= mid) {\\n            result = max(mid, bisectArray(citations, mid +1, end));\\n       \\n        } else {\\n            result = bisectArray(citations, start, mid-1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport static java.lang.Math.ceil;\\nimport static java.lang.Math.max;\\nclass Solution {\\n    //already in ascending order\\n    public int hIndex(int[] citations) {\\n       return bisectArray(citations, 1, citations.length); \\n    }\\n    \\n    public int bisectArray(int[] citations, int start, int end) {\\n        // terminal case of recursion\\n        if(start > end) {\\n           return 0;\\n        }\\n        int mid = (int)(start+end)/2;\\n        int result = 0;\\n        \\n        if(citations[citations.length-mid] >= mid) {\\n            result = max(mid, bisectArray(citations, mid +1, end));\\n       \\n        } else {\\n            result = bisectArray(citations, start, mid-1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130345,
                "title": "java-binary-search-solution",
                "content": "```\\nclass Solution{\\n   public int hIndex(int[] citations) {\\n     int len = citations.length;\\n     int left = 0;\\n     int right = len-1;\\n     \\n     while (left <= right){\\n      int mid = left + (right - left) / 2;\\n      if (citations[mid] < len - mid)\\n        left = mid + 1;\\n      else if(citations[mid] >= len - mid)\\n        right = mid - 1;\\n     }\\n     return len - left; \\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution{\\n   public int hIndex(int[] citations) {\\n     int len = citations.length;\\n     int left = 0;\\n     int right = len-1;\\n     \\n     while (left <= right){\\n      int mid = left + (right - left) / 2;\\n      if (citations[mid] < len - mid)\\n        left = mid + 1;\\n      else if(citations[mid] >= len - mid)\\n        right = mid - 1;\\n     }\\n     return len - left; \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008611,
                "title": "clean-python-solution-binary-search",
                "content": "```Python\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        left, right = 0, n\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if citations[mid] >= n - mid:\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return n - left",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```Python\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        left, right = 0, n\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if citations[mid] >= n - mid:\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return n - left",
                "codeTag": "Java"
            },
            {
                "id": 694894,
                "title": "python-by-binary-search-w-comment",
                "content": "Python by binary search. \\n\\n---\\n\\n**Implementation** by binary search:\\n\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        \\n        left, right = 0, len(citations)-1\\n        \\n        size = len(citations)\\n        \\n        while left <= right:\\n            \\n            mid = left + (right - left)//2\\n            \\n            the_number_of_larger_equal_to_current = size - mid\\n            h_index = citations[mid]\\n            \\n            \\n            if h_index < the_number_of_larger_equal_to_current:\\n                # current h index is too small, make it larger\\n                left = mid + 1\\n                    \\n            elif h_index > the_number_of_larger_equal_to_current:\\n                # current h index is to large, make it smaller\\n                right = mid - 1\\n            \\n            else:\\n                # meet the definition of h-index\\n                return h_index\\n            \\n        return size - left \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        \\n        left, right = 0, len(citations)-1\\n        \\n        size = len(citations)\\n        \\n        while left <= right:\\n            \\n            mid = left + (right - left)//2\\n            \\n            the_number_of_larger_equal_to_current = size - mid\\n            h_index = citations[mid]\\n            \\n            \\n            if h_index < the_number_of_larger_equal_to_current:\\n                # current h index is too small, make it larger\\n                left = mid + 1\\n                    \\n            elif h_index > the_number_of_larger_equal_to_current:\\n                # current h index is to large, make it smaller\\n                right = mid - 1\\n            \\n            else:\\n                # meet the definition of h-index\\n                return h_index\\n            \\n        return size - left \\n```",
                "codeTag": "Java"
            },
            {
                "id": 694810,
                "title": "it-seems-to-be-only-one-possible-h-index",
                "content": "Since the array is sorted, if we find an answer ```h```, then we can partition the array to two parts.\\n```arr[0,i) <=h && arr[i, n) >=h, h = n - i```.\\nIf we want to valid that if ```h+1``` can be a possible answer, we may found it impossible.\\nBecause, if ```h+1``` can be a candidate, that means we should have a value in ```arr[0, i)<=h``` i.e. ```arr[i-1]``` to be no less than ```h+1```.\\nSo I think it is impossible.\\nIf I\\'m wrong, please correct me.",
                "solutionTags": [],
                "code": "```h```\n```arr[0,i) <=h && arr[i, n) >=h, h = n - i```\n```h+1```\n```h+1```\n```arr[0, i)<=h```\n```arr[i-1]```\n```h+1```",
                "codeTag": "Unknown"
            },
            {
                "id": 693731,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int size = citations.size();\\n        int low = 0, high = size;\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (size - mid <= citations[mid])\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        return size - high;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int size = citations.size();\\n        int low = 0, high = size;\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (size - mid <= citations[mid])\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        return size - high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693646,
                "title": "c-simplest-solution-o-log-n-binary-search",
                "content": "**Basic idea:**\\nIf we read the question carefully, we find some key points,\\n1. The array is sorted (must be utilized for our solution)\\n2. h index value is the number where `arr[hindex] == arr.size() - hindex` (as exactly N - h values are there with value less than h)\\n3. It is possible to not have an exact number which is our h index but a number in between 2 values.\\n\\n**Solution:**\\nAs we can see, the question gives us an idea of iterating on the whole array, but an array is sorted we can use a **binary search**.\\nUsing a binary search will lower the time complexity to `log n` rather than `n` from linear search.\\ncase 1: If value exist in array, we find the value where `arr[hindex] == arr.size() - hindex` condition satisfies and return its value.\\ncase 2: if the value doesn\\'t exist we find the lower bound`(lb)` of the hindex present in the array and return `N - lb`\\n```\\nint hIndex(vector<int>& arr) {\\n\\tif (arr.size() == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint si = 0, size = arr.size(), ei = size - 1;\\n\\twhile(si <= ei) {\\n\\t\\tint mid = (si + ei) >> 1;\\n\\t\\tif (arr[mid] == size - mid) {\\n\\t\\t\\treturn arr[mid];\\n\\t\\t} else if(arr[mid] > size - mid) {\\n\\t\\t\\tei = mid - 1;\\n\\t\\t} else {\\n\\t\\t\\tsi = mid + 1;\\n\\t\\t}\\n\\t}\\n\\treturn size - si;\\n}\\n```\\nplease suggest improvements if you find any, I\\'ll appreciate your suggestions :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint hIndex(vector<int>& arr) {\\n\\tif (arr.size() == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint si = 0, size = arr.size(), ei = size - 1;\\n\\twhile(si <= ei) {\\n\\t\\tint mid = (si + ei) >> 1;\\n\\t\\tif (arr[mid] == size - mid) {\\n\\t\\t\\treturn arr[mid];\\n\\t\\t} else if(arr[mid] > size - mid) {\\n\\t\\t\\tei = mid - 1;\\n\\t\\t} else {\\n\\t\\t\\tsi = mid + 1;\\n\\t\\t}\\n\\t}\\n\\treturn size - si;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693644,
                "title": "c-simple-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int low = 0;\\n        int size = citations.size();\\n        int high = size-1;\\n        int cnt = 0;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(citations[mid] >= (size-mid)){\\n                cnt=size-mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nHere, we just have to see if the numbers of element is less than `citations[mid]` or not. If yes, then we will to left side to capture more elements. In this way, we are fulfilling the condition given in question.\\n`Happy Coding !! :) `",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int low = 0;\\n        int size = citations.size();\\n        int high = size-1;\\n        int cnt = 0;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(citations[mid] >= (size-mid)){\\n                cnt=size-mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693507,
                "title": "python-3-binary-search-iterative-solution",
                "content": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n , left , right = len(citations) , 0 , len(citations)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            numGreater = n - mid\\n            if numGreater <= citations[mid]:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return n - left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n , left , right = len(citations) , 0 , len(citations)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            numGreater = n - mid\\n            if numGreater <= citations[mid]:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return n - left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693430,
                "title": "simple-java-solution-with-explaination-0ms-100-faster-linear-and-binary-search-both",
                "content": "Naive approach is to use linear search and go from 0 to length and check if element at current index >= length-currentIndex. If condition true return length-currentIndex.\\nIf loop finishes return 0.\\nBetter approach is to use binary search as we know data is sorted.\\nApply classic binary search \\nif arr[mid]==arr[length-mid] return length-mid. \\nelse if arr[mid]>arr[length-mid] set end=mid-1\\nelse set start=mid+1;\\nonce loop terminates we know start will be at correct position and since we wanted to return count. Answer will be length-start.\\n\\nliner search - \\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        for(int i=0;i<citations.length;i++){\\n            if(citations[i]>=citations.length-i){\\n                return citations.length-i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\nbinary search - \\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int start = 0;\\n        int end = citations.length-1;\\n        while(start<=end) {\\n            int mid = end + (end-start)/2;\\n            if(citations[mid]==citations.length-mid) {\\n                return citations.length-mid;\\n            } else if(citations[mid]>citations.length-mid) {\\n                end=mid-1;\\n            } else {\\n                start=mid+1;\\n            }\\n        }\\n        return citations.length-start;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        for(int i=0;i<citations.length;i++){\\n            if(citations[i]>=citations.length-i){\\n                return citations.length-i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int start = 0;\\n        int end = citations.length-1;\\n        while(start<=end) {\\n            int mid = end + (end-start)/2;\\n            if(citations[mid]==citations.length-mid) {\\n                return citations.length-mid;\\n            } else if(citations[mid]>citations.length-mid) {\\n                end=mid-1;\\n            } else {\\n                start=mid+1;\\n            }\\n        }\\n        return citations.length-start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693374,
                "title": "javascript-binary-search",
                "content": "```\\nvar hIndex = function(citations) {\\n        \\n    let start = 0, end = citations.length-1;\\n    \\n    while (start <= end) {\\n        \\n        let mid = Math.floor((start+end)/2);\\n        \\n        if (citations.length - mid - 1 < citations[mid]) {\\n            \\n            end = mid - 1;\\n        } else {\\n            \\n            start = mid + 1;\\n        }\\n    }\\n    \\n    return citations.length - start;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar hIndex = function(citations) {\\n        \\n    let start = 0, end = citations.length-1;\\n    \\n    while (start <= end) {\\n        \\n        let mid = Math.floor((start+end)/2);\\n        \\n        if (citations.length - mid - 1 < citations[mid]) {\\n            \\n            end = mid - 1;\\n        } else {\\n            \\n            start = mid + 1;\\n        }\\n    }\\n    \\n    return citations.length - start;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 682947,
                "title": "runtime-0-ms-faster-than-100-online-submission",
                "content": "class Solution {\\n    public int hIndex(int[] citations) {\\n        int n=citations.length;\\n        if(n==0)\\n            return 0;\\n        if(n==1 && citations[0]==0)\\n            return 0;\\n        //range=1-n\\n        int lo=0,hi=n,mid=0;\\n        \\n        while(lo<=hi)\\n        {\\n            mid=lo+(int)((hi-lo+1)/2);\\n                \\n            if(valuesmax(citations,mid)>=mid && valuesmin(citations,mid)>=n-mid)\\n                return mid;\\n            else if(valuesmax(citations,mid)>=mid)\\n                lo=mid;\\n            else\\n                hi=mid-1;       \\n        }\\n        return 0;\\n    }\\n    \\n    public int valuesmax(int[] arr,int a)\\n    {\\n      int low=0,high=arr.length-1,mid=0;\\n        while(low<high)\\n        {\\n           mid=low + (int)((high-low)/2);\\n               \\n           if(arr[mid]<a)\\n               low=mid+1;\\n            else\\n               high=mid;\\n        }\\n        if(arr[low]>=a)\\n        return arr.length-low;\\n        else\\n        return 0;\\n    }\\n    \\n    public int valuesmin(int[] arr,int a)\\n    {\\n         int lo=0,hi=arr.length-1,mid=0;\\n        while(lo<hi)\\n        {\\n           mid=lo+(int)((hi-lo+1)/2);\\n            \\n          if(arr[mid]<=a)\\n              lo=mid;\\n          else\\n              hi=mid-1;\\n        }\\n        if(arr[lo]<=a)\\n        return lo+1;\\n        else\\n        return 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        int n=citations.length;\\n        if(n==0)\\n            return 0;\\n        if(n==1 && citations[0]==0)\\n            return 0;\\n        //range=1-n\\n        int lo=0,hi=n,mid=0;\\n        \\n        while(lo<=hi)\\n        {\\n            mid=lo+(int)((hi-lo+1)/2);\\n                \\n            if(valuesmax(citations,mid)>=mid && valuesmin(citations,mid)>=n-mid)\\n                return mid;\\n            else if(valuesmax(citations,mid)>=mid)\\n                lo=mid;\\n            else\\n                hi=mid-1;       \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 622343,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        \\n        int n = citations.size();\\n        int l = 0;\\n        int r = n-1;\\n        \\n        while (l <= r) {\\n            int m = l + (r-l)/2;\\n            \\n            if (citations[m] == n-m)\\n                return n-m;\\n            else if (citations[m] > n-m)\\n                r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return n-l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        \\n        int n = citations.size();\\n        int l = 0;\\n        int r = n-1;\\n        \\n        while (l <= r) {\\n            int m = l + (r-l)/2;\\n            \\n            if (citations[m] == n-m)\\n                return n-m;\\n            else if (citations[m] > n-m)\\n                r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return n-l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485524,
                "title": "python-bisect-search",
                "content": "```\\ndef hIndex(self, citations: List[int]) -> int:\\n        length = len(citations)\\n        class Range():\\n            def __getitem__(self, key):\\n                return length - key <= citations[key]\\n        index = bisect.bisect_left(Range(), True, 0, length)\\n        return length - index if index < length else 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef hIndex(self, citations: List[int]) -> int:\\n        length = len(citations)\\n        class Range():\\n            def __getitem__(self, key):\\n                return length - key <= citations[key]\\n        index = bisect.bisect_left(Range(), True, 0, length)\\n        return length - index if index < length else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404956,
                "title": "easy-c-binary-search-solution-12ms-beats-99",
                "content": "Runtime: 12 ms, faster than 99.26% of C++ online submissions for H-Index II.\\nMemory Usage: 12.5 MB, less than 60.00% of C++ online submissions for H-Index II.\\n\\n```\\nint n = citations.size();\\n        int low = 0;\\n        int high = n;\\n        \\n        while(low < high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(n - mid <= citations[mid])\\n                high = mid;\\n            else \\n                low = mid+1;\\n        }\\n        \\n        return n-high;\\n    }",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "Runtime: 12 ms, faster than 99.26% of C++ online submissions for H-Index II.\\nMemory Usage: 12.5 MB, less than 60.00% of C++ online submissions for H-Index II.\\n\\n```\\nint n = citations.size();\\n        int low = 0;\\n        int high = n;\\n        \\n        while(low < high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(n - mid <= citations[mid])\\n                high = mid;\\n            else \\n                low = mid+1;\\n        }\\n        \\n        return n-high;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71098,
                "title": "clear-and-easy-c-solution",
                "content": "\\tint hIndex(vector<int>& citations) {\\n\\t\\tint n = citations.size(), res = 0;\\n\\t\\tint start = 0, end = n - 1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = start + (end - start) / 2;\\n\\t\\t\\tif (citations[mid] >= n - mid) {\\n\\t\\t\\t\\tres = n - mid;\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [],
                "code": "\\tint hIndex(vector<int>& citations) {\\n\\t\\tint n = citations.size(), res = 0;\\n\\t\\tint start = 0, end = n - 1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = start + (end - start) / 2;\\n\\t\\t\\tif (citations[mid] >= n - mid) {\\n\\t\\t\\t\\tres = n - mid;\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 71095,
                "title": "simple-13ms-java-solution",
                "content": "    public class Solution {\\n        public int hIndex(int[] citations) {\\n            int start = 0;\\n            int end = citations.length-1;\\n            int len = citations.length;\\n            int result = 0;\\n            int mid;\\n            while(start <= end){\\n                mid = start + (end-start)/2;\\n                if(citations[mid] >= (len - mid)){\\n                    result = (len-mid);\\n                    end = mid-1;\\n                }\\n                else{\\n                    start = mid + 1;\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int hIndex(int[] citations) {\\n            int start = 0;\\n            int end = citations.length-1;\\n            int len = citations.length;\\n            int result = 0;\\n            int mid;\\n            while(start <= end){\\n                mid = start + (end-start)/2;\\n                if(citations[mid] >= (len - mid)){\\n                    result = (len-mid);\\n                    end = mid-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 71139,
                "title": "1-liner-in-ruby",
                "content": "**Solution**\\n\\n    def h_index(citations)\\n      (0...citations.size).bsearch { |i| citations[~i] <= i } || citations.size\\n    end\\n\\nOr a bit shorter, by adding a virtual dummy paper with zero citations:\\n\\n    def h_index(citations)\\n      (0..citations.size).bsearch { |i| (citations[~i] || 0) <= i }\\n    end\\n\\n---\\n\\n**Explanation**\\n\\nThink/access in reversed order, for example input [0,1,3,5,6] is:\\n\\n                          i:  0 1 2 3 4\\n    citations of i-th paper:  6 5 3 1 0        (implemented as citations[~i])\\n\\nThe index of the first paper having too few citations (`citations[~i] <= i`) is the number of papers with enough citations.",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "**Solution**\\n\\n    def h_index(citations)\\n      (0...citations.size).bsearch { |i| citations[~i] <= i } || citations.size\\n    end\\n\\nOr a bit shorter, by adding a virtual dummy paper with zero citations:\\n\\n    def h_index(citations)\\n      (0..citations.size).bsearch { |i| (citations[~i] || 0) <= i }\\n    end\\n\\n---\\n\\n**Explanation**\\n\\nThink/access in reversed order, for example input [0,1,3,5,6] is:\\n\\n                          i:  0 1 2 3 4\\n    citations of i-th paper:  6 5 3 1 0        (implemented as citations[~i])\\n\\nThe index of the first paper having too few citations (`citations[~i] <= i`) is the number of papers with enough citations.",
                "codeTag": "Python3"
            },
            {
                "id": 71147,
                "title": "binary-search-to-solve-it-uff0c-python-38ms",
                "content": "    def hIndex(self, citations):\\n        \"\"\"\\n        :type citations: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(citations) == 0 or not citations:\\n            return 0\\n        low, high, length = 0, len(citations)-1, len(citations)\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if citations[mid] < length - mid:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return length - high - 1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    def hIndex(self, citations):\\n        \"\"\"\\n        :type citations: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(citations) == 0 or not citations:\\n            return 0\\n        low, high, length = 0, len(citations)-1, len(citations)\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if citations[mid] < length - mid:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return length - high - 1",
                "codeTag": "Python3"
            },
            {
                "id": 3811437,
                "title": "go-o-log-n-one-liner",
                "content": "```\\nfunc hIndex(citations []int) int {\\n    return sort.Search(len(citations), func(i int) bool { return citations[len(citations) - 1 - i] <= i })\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hIndex(citations []int) int {\\n    return sort.Search(len(citations), func(i int) bool { return citations[len(citations) - 1 - i] <= i })\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784263,
                "title": "concise-for-loop-approach-binary-search-made-easy",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] c) {\\n        int x=0;\\n        for(int i=0, n=c.length, j=n-1, m=0; i<=j;x=i, m=(i+j)/2){\\n            if(c[m]==n-m) return n-m;\\n            if(c[m]<n-m) i=m+1;\\n            else j=m-1;\\n        }\\n        return c.length-x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] c) {\\n        int x=0;\\n        for(int i=0, n=c.length, j=n-1, m=0; i<=j;x=i, m=(i+j)/2){\\n            if(c[m]==n-m) return n-m;\\n            if(c[m]<n-m) i=m+1;\\n            else j=m-1;\\n        }\\n        return c.length-x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629719,
                "title": "simple-fast-go-solution-with-approach",
                "content": "# Approach\\n\\n- In first step of checking we check exceptionts like last elemnt is no 0 (if last one is 0, then all elements are 0 because we have sorted array) and array len is > 1 (if array len is 1 and one elemet is not 0 => h index = 1, i dont know, im just checking)\\n- In second step of checking we start for and we go through each element from array end, if the condition is satisfied by the new maximum h index\\n\\n# Code\\n```\\n\\nfunc hIndex(citations []int) int {\\n\\tcitationsSize := len(citations)\\n\\n\\tif citations[citationsSize-1] == 0 {\\n\\t\\treturn 0\\n\\t} else if citationsSize == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\th_index := 0\\n\\n\\tfor h:=1; h<=citationsSize; h++  {\\n\\t\\tif citations[citationsSize-h] >= h {\\n\\t\\t\\th_index = h\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn h_index\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array"
                ],
                "code": "```\\n\\nfunc hIndex(citations []int) int {\\n\\tcitationsSize := len(citations)\\n\\n\\tif citations[citationsSize-1] == 0 {\\n\\t\\treturn 0\\n\\t} else if citationsSize == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\th_index := 0\\n\\n\\tfor h:=1; h<=citationsSize; h++  {\\n\\t\\tif citations[citationsSize-h] >= h {\\n\\t\\t\\th_index = h\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn h_index\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3549293,
                "title": "c-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int s = 0;\\n        int e = n-1;\\n        int n = citations.size();\\n        \\n        int ans =0;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n           if(citations[mid]<n-mid){\\n               s=mid+1;\\n              \\n               \\n           }\\n           else{\\n               e=mid-1;\\n           }\\n           \\n        }\\n        return n-s;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int s = 0;\\n        int e = n-1;\\n        int n = citations.size();\\n        \\n        int ans =0;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n           if(citations[mid]<n-mid){\\n               s=mid+1;\\n              \\n               \\n           }\\n           else{\\n               e=mid-1;\\n           }\\n           \\n        }\\n        return n-s;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508572,
                "title": "just-3-lines-of-code-beats-100-java-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        for (int i=0; i < n; i++)\\n            if(citations[i]>=n-i) return n-i;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        for (int i=0; i < n; i++)\\n            if(citations[i]>=n-i) return n-i;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504416,
                "title": "easy-way-to-kotlin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun hIndex(citations: IntArray): Int {\\n        var hIndex = citations.size\\n        \\n        citations.forEachIndexed { index, i -> \\n            if(i >= hIndex - index){\\n                return hIndex - index\\n            }\\n        }\\n        return 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun hIndex(citations: IntArray): Int {\\n        var hIndex = citations.size\\n        \\n        citations.forEachIndexed { index, i -> \\n            if(i >= hIndex - index){\\n                return hIndex - index\\n            }\\n        }\\n        return 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496883,
                "title": "binary-search-simple-solution-cpp-97-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int low=0, high =citations.size()-1;\\n        int ans=0;\\n        int n = citations.size();\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(citations[mid]==0){\\n                low=mid+1;\\n            }\\n            else{\\n                if(citations[mid] <= n - mid){\\n                    ans=max(ans,citations[mid]);\\n                    low = mid + 1;\\n                }\\n                else{\\n                    ans=max(ans, n -mid);\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int low=0, high =citations.size()-1;\\n        int ans=0;\\n        int n = citations.size();\\n        while(low<=high){\\n            int mid = low + (high - low)/2;\\n            if(citations[mid]==0){\\n                low=mid+1;\\n            }\\n            else{\\n                if(citations[mid] <= n - mid){\\n                    ans=max(ans,citations[mid]);\\n                    low = mid + 1;\\n                }\\n                else{\\n                    ans=max(ans, n -mid);\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452591,
                "title": "c-binary-search-solution-20-lines-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the given array`citations`is sorted in ascending order, we think of Binary Search. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`mid=(low+high)/2`.\\n- If number of elements ahead of`citations[mid]`i.e.`n-mid`elements are less than`citations[mid]`, then`h`can be`n-mid` and as we are asked to maximize the value of`h`, we move behind to check if we can get a larger value of`n-mid`.\\n- If above condition fails, it means that we need to go ahead and so,`low=mid+1`.\\n\\n# Complexity\\n- Time complexity:`O(log(n))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n=citations.size();\\n        int low=0, high=n-1;\\n        int ans=0;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(citations[mid]>=n-mid){\\n                ans=max(ans, n-mid);\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n=citations.size();\\n        int low=0, high=n-1;\\n        int ans=0;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(citations[mid]>=n-mid){\\n                ans=max(ans, n-mid);\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232245,
                "title": "java-solution-100-faster-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int l=0,r=citations.length-1,h=0;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            if(citations.length-mid<=citations[mid]){\\n                h=citations.length-mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int l=0,r=citations.length-1,h=0;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            if(citations.length-mid<=citations[mid]){\\n                h=citations.length-mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227168,
                "title": "c",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        int min = 0, max = n - 1;\\n        int mid;\\n\\n        while (min <= max) {\\n            mid = (min + max) / 2;\\n            if (citations[mid] < n - mid) {\\n                min = mid + 1;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n\\n        return n - min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        int min = 0, max = n - 1;\\n        int mid;\\n\\n        while (min <= max) {\\n            mid = (min + max) / 2;\\n            if (citations[mid] < n - mid) {\\n                min = mid + 1;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n\\n        return n - min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227107,
                "title": "c-binary-search",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int min = 0, max = citations.size();\\n        int mid;\\n\\n        while (min < max) {\\n            mid = (min + max + 1) / 2;\\n            if (isH(mid, citations)) {\\n                min = mid;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n        return min;\\n    }\\n\\n    bool isH(int h, vector<int>& citations) {\\n        int count = citations.size();\\n        for (auto citation: citations) {\\n            if (citation < h) count -= 1;\\n            if (count < h) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int min = 0, max = citations.size();\\n        int mid;\\n\\n        while (min < max) {\\n            mid = (min + max + 1) / 2;\\n            if (isH(mid, citations)) {\\n                min = mid;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n        return min;\\n    }\\n\\n    bool isH(int h, vector<int>& citations) {\\n        int count = citations.size();\\n        for (auto citation: citations) {\\n            if (citation < h) count -= 1;\\n            if (count < h) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128711,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int lower = 0;\\n        int upper = 5000;\\n        int index = -1;\\n        \\n        while(lower < upper) {\\n            int mid = lower + (upper - lower+1)/2;\\n            if(graterThanOrEqual(citations,mid,0,citations.length-1) >= mid) {\\n                lower = mid;\\n            } else {\\n                upper = mid-1; \\n            }\\n        }\\n        \\n        return lower;\\n    }\\n\\n    int graterThanOrEqual(int [] arr , int num , int start , int end) {\\n        while(start < end) {\\n            int mid = start + (end - start)/2;\\n\\n            if(arr[mid] >= num) {\\n                end = mid;\\n            } else start = mid+1;\\n        }\\n\\n        if(arr[start] < num)\\n            return 0;\\n\\n        return arr.length - start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int lower = 0;\\n        int upper = 5000;\\n        int index = -1;\\n        \\n        while(lower < upper) {\\n            int mid = lower + (upper - lower+1)/2;\\n            if(graterThanOrEqual(citations,mid,0,citations.length-1) >= mid) {\\n                lower = mid;\\n            } else {\\n                upper = mid-1; \\n            }\\n        }\\n        \\n        return lower;\\n    }\\n\\n    int graterThanOrEqual(int [] arr , int num , int start , int end) {\\n        while(start < end) {\\n            int mid = start + (end - start)/2;\\n\\n            if(arr[mid] >= num) {\\n                end = mid;\\n            } else start = mid+1;\\n        }\\n\\n        if(arr[start] < num)\\n            return 0;\\n\\n        return arr.length - start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046241,
                "title": "simple-js-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMake use of ascending order and the property that if it is in decending then for every ith paper. all the preview values are greater than current paper. Eg 10, 9, 8, 5, 4 ans is 4 as till 4th paper all values are gte than the value which is 5. But here we have ascending data so start from end and keep it as paper 1st and move left \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nconst hIndex = (citations) => {\\n  let hIndex = 0;\\n  let ind = citations.length -1;\\n  for (let i = 1; i <= citations.length; i++) {\\n    if (citations[ind] >= i) {\\n      hIndex = i;\\n    } else {\\n        break;\\n    }\\n    ind--;\\n  }\\n  return hIndex;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nconst hIndex = (citations) => {\\n  let hIndex = 0;\\n  let ind = citations.length -1;\\n  for (let i = 1; i <= citations.length; i++) {\\n    if (citations[ind] >= i) {\\n      hIndex = i;\\n    } else {\\n        break;\\n    }\\n    ind--;\\n  }\\n  return hIndex;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946478,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(), citations.end());\\n        int i=0, j=1e9, n=citations.size(), ans=0;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            int cnt=lower_bound(citations.begin(), citations.end(), mid)-citations.begin();\\n            if(n-cnt>=mid){\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        sort(citations.begin(), citations.end());\\n        int i=0, j=1e9, n=citations.size(), ans=0;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            int cnt=lower_bound(citations.begin(), citations.end(), mid)-citations.begin();\\n            if(n-cnt>=mid){\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792616,
                "title": "simple-java-solution-easy-to-understand-binary-search-trick",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        \\n        int start = 0;\\n        int end = citations.length - 1;\\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end - start) / 2;\\n            \\n            if(citations[mid] == citations.length - mid){\\n                return citations[mid];\\n            }\\n            else if(citations[mid] > citations.length - mid){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        \\n        return citations.length - start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        \\n        int start = 0;\\n        int end = citations.length - 1;\\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end - start) / 2;\\n            \\n            if(citations[mid] == citations.length - mid){\\n                return citations[mid];\\n            }\\n            else if(citations[mid] > citations.length - mid){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        \\n        \\n        return citations.length - start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753211,
                "title": "c-3-lines-lower-bound",
                "content": "This is mainly to demonstrate how we can use element index in a custom comparator inside ```lower_bound``` in C++:\\n```\\nint hIndex(vector<int>& v) {\\n\\tauto it=lower_bound(v.begin(), v.end(), v.size(), [&v](int& elt, const int &n)\\n\\t{ int idx=&elt-&v[0];  return elt+idx<n; });\\n\\treturn distance(it, v.end());\\n}\\n```",
                "solutionTags": [],
                "code": "```lower_bound```\n```\\nint hIndex(vector<int>& v) {\\n\\tauto it=lower_bound(v.begin(), v.end(), v.size(), [&v](int& elt, const int &n)\\n\\t{ int idx=&elt-&v[0];  return elt+idx<n; });\\n\\treturn distance(it, v.end());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2521349,
                "title": "runtime-0-ms-faster-than-100-00-java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int start=0;\\n        int end=citations.length-1;\\n        int n = end+1;\\n        while(start<=end)\\n        {\\n            int mid = (start+end)/2;\\n            if(citations[mid]<n-mid){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return n-start;   \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        int start=0;\\n        int end=citations.length-1;\\n        int n = end+1;\\n        while(start<=end)\\n        {\\n            int mid = (start+end)/2;\\n            if(citations[mid]<n-mid){\\n                start=mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2445506,
                "title": "java-solution-binary-search-o-logn-time-o-1-space",
                "content": "```java\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int start=0;\\n        int end=citations.length-1;\\n        int n = end+1;\\n        while(start<=end)\\n        {\\n            int mid = (start+end)/2;\\n            if(citations[mid]<n-mid){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return n-start;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int start=0;\\n        int end=citations.length-1;\\n        int n = end+1;\\n        while(start<=end)\\n        {\\n            int mid = (start+end)/2;\\n            if(citations[mid]<n-mid){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return n-start;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071333,
                "title": "java-solution-has-explaination-faster-than-100",
                "content": "We realize that h-index will be in range (0, n) inclusive. So we will binary with left=0 and right=n. Let mid = (left+right)/2. if mid is our h-index, it has to satisfy conditions: citations[n-mid]>=mid (exactly mid paper has at least mid citations) and citations[n-mid-1]<=mid (other n-mid paper has no more than mid citations each). Let res be the result.If citations[n-mid]<mid, then res < mid. If citations[n-mid-1]>mid, then res > mid. \\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n=citations.length;\\n        int l=0;\\n        int r=n;\\n        int res=0;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(m!=0 && citations[n-m]<m){\\n                r=m-1;\\n            }\\n            else if(n!=m && citations[n-m-1]>m){\\n                l=m+1;\\n            }\\n            else {\\n                res=m;\\n                l=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n=citations.length;\\n        int l=0;\\n        int r=n;\\n        int res=0;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(m!=0 && citations[n-m]<m){\\n                r=m-1;\\n            }\\n            else if(n!=m && citations[n-m-1]>m){\\n                l=m+1;\\n            }\\n            else {\\n                res=m;\\n                l=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048914,
                "title": "2-ways-to-solve-python",
                "content": "First approach: binary search on the answer search space O(log n):\\n\\n```\\nlo, hi = 0, len(citations)\\n\\nwhile lo < hi:\\n\\tmid = hi - (hi - lo) // 2         # ceil(mid)\\n\\tif citations[-mid] >= mid:        # are there enough papers with at-least \"mid\" no. of citations ? \\n\\t\\tlo = mid                      # yes, mid is possible answer, keep searching for better\\n\\telse:\\n\\t\\thi = mid - 1                  # no, search for lower h-index\\n\\nreturn lo\\n```\\n\\nSecond approach: Greedy linear search with early stopping O(n):\\n```\\nh = len(citations)  # H-index cannot be more than the number of papers\\n\\nfor c in citations:     \\n\\tif c >= h:      # all papers to the right have at-least as many citations as h\\n\\t\\treturn h\\n\\th -= 1          # else: nope, so H-index cannot be so high, reduce and keep checking\\n\\nreturn h            # at this point, H-index is 0\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nlo, hi = 0, len(citations)\\n\\nwhile lo < hi:\\n\\tmid = hi - (hi - lo) // 2         # ceil(mid)\\n\\tif citations[-mid] >= mid:        # are there enough papers with at-least \"mid\" no. of citations ? \\n\\t\\tlo = mid                      # yes, mid is possible answer, keep searching for better\\n\\telse:\\n\\t\\thi = mid - 1                  # no, search for lower h-index\\n\\nreturn lo\\n```\n```\\nh = len(citations)  # H-index cannot be more than the number of papers\\n\\nfor c in citations:     \\n\\tif c >= h:      # all papers to the right have at-least as many citations as h\\n\\t\\treturn h\\n\\th -= 1          # else: nope, so H-index cannot be so high, reduce and keep checking\\n\\nreturn h            # at this point, H-index is 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2035750,
                "title": "using-binary-search-in-java",
                "content": "```\\nclass Solution {\\n    public int f(int[] c,int m)\\n    {\\n        int count=0;\\n        for(int e:c) if(e>=m) count++;\\n        return count;\\n    }\\n    public int hIndex(int[] c) {\\n        int l=1;\\n        int m,ans=0;\\n        int h=Integer.MIN_VALUE;\\n        for(int e:c) if(e>h) h=e;\\n        while(l<=h)\\n        {\\n            m=((h-l)/2)+l;\\n            int x=f(c,m);\\n            if(x>=m)\\n            {\\n                 ans=m;\\n                l=m+1;\\n            }\\n            else h=m-1;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int f(int[] c,int m)\\n    {\\n        int count=0;\\n        for(int e:c) if(e>=m) count++;\\n        return count;\\n    }\\n    public int hIndex(int[] c) {\\n        int l=1;\\n        int m,ans=0;\\n        int h=Integer.MIN_VALUE;\\n        for(int e:c) if(e>h) h=e;\\n        while(l<=h)\\n        {\\n            m=((h-l)/2)+l;\\n            int x=f(c,m);\\n            if(x>=m)\\n            {\\n                 ans=m;\\n                l=m+1;\\n            }\\n            else h=m-1;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017242,
                "title": "python-c-c-simple-binary-search",
                "content": "**Code : C++**\\n```\\nint hIndex(vector<int>& citations) {\\n\\tint start = 0, end = citations.size()-1, ans = 0;\\n\\twhile(start<=end){\\n\\t\\tint mid = start + (end - start)/2;\\n\\t\\tif(citations[mid] >= citations.size() - mid) {\\n\\t\\t\\tans = max(ans,(int)citations.size() - mid); end = mid - 1;\\n\\t\\t}\\n\\t\\telse start = mid + 1;\\n\\t}\\n\\treturn ans;\\n}\\n```\\n**Code : C**\\n```\\nint hIndex(int* citations, int citationsSize){\\n\\tint start = 0, end = citationsSize-1, ans = 0;\\n\\twhile(start<=end){\\n\\t\\tint mid = start + (end - start)/2;\\n\\t\\tif(citations[mid] >= citationsSize - mid) {\\n\\t\\t\\tans = fmax(ans,(int)citationsSize - mid); end = mid - 1;\\n\\t\\t}\\n\\t\\telse start = mid + 1;\\n\\t}\\n\\treturn ans;\\n}\\n```\\n**Code : Python/Python3**\\n```\\ndef hIndex(self, citations):\\n\\tstart = 0\\n\\tend = len(citations)-1\\n\\tans = 0\\n\\twhile start <= end:\\n\\t\\tmid = start + (end - start)//2\\n\\t\\tif citations[mid] >= len(citations) - mid:\\n\\t\\t\\tans = max(ans,len(citations)-mid)\\n\\t\\t\\tend = mid - 1\\n\\t\\telse: start = mid + 1\\n\\treturn ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint hIndex(vector<int>& citations) {\\n\\tint start = 0, end = citations.size()-1, ans = 0;\\n\\twhile(start<=end){\\n\\t\\tint mid = start + (end - start)/2;\\n\\t\\tif(citations[mid] >= citations.size() - mid) {\\n\\t\\t\\tans = max(ans,(int)citations.size() - mid); end = mid - 1;\\n\\t\\t}\\n\\t\\telse start = mid + 1;\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nint hIndex(int* citations, int citationsSize){\\n\\tint start = 0, end = citationsSize-1, ans = 0;\\n\\twhile(start<=end){\\n\\t\\tint mid = start + (end - start)/2;\\n\\t\\tif(citations[mid] >= citationsSize - mid) {\\n\\t\\t\\tans = fmax(ans,(int)citationsSize - mid); end = mid - 1;\\n\\t\\t}\\n\\t\\telse start = mid + 1;\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\ndef hIndex(self, citations):\\n\\tstart = 0\\n\\tend = len(citations)-1\\n\\tans = 0\\n\\twhile start <= end:\\n\\t\\tmid = start + (end - start)//2\\n\\t\\tif citations[mid] >= len(citations) - mid:\\n\\t\\t\\tans = max(ans,len(citations)-mid)\\n\\t\\t\\tend = mid - 1\\n\\t\\telse: start = mid + 1\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1964767,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func hIndex(_ c: [Int]) -> Int {\\n        var lhs = 0, rhs = c.count\\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs + 1) >> 1\\n            c[c.count - mid] >= mid ? (lhs = mid) : (rhs = mid - 1)\\n        }\\n        return lhs\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.009 (0.011) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    // [0,1,3,5,6] means the researcher has 5 papers in total and each\\n    // of them had received 0, 1, 3, 5, 6 citations respectively.\\n    // Since the researcher has 3 papers with at least 3 citations each and\\n    // the remaining two with no more than 3 citations each, their h-index is 3.\\n    func test0() {\\n        let value = solution.hIndex([0,1,3,5,6])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.hIndex([1,2,100])\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func hIndex(_ c: [Int]) -> Int {\\n        var lhs = 0, rhs = c.count\\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs + 1) >> 1\\n            c[c.count - mid] >= mid ? (lhs = mid) : (rhs = mid - 1)\\n        }\\n        return lhs\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    // [0,1,3,5,6] means the researcher has 5 papers in total and each\\n    // of them had received 0, 1, 3, 5, 6 citations respectively.\\n    // Since the researcher has 3 papers with at least 3 citations each and\\n    // the remaining two with no more than 3 citations each, their h-index is 3.\\n    func test0() {\\n        let value = solution.hIndex([0,1,3,5,6])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.hIndex([1,2,100])\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928316,
                "title": "simple-solution-0ms",
                "content": "```\\npublic int hIndex(int[] citations) {\\n\\tint count = 0, index = citations.length - 1;\\n\\twhile( index >= 0 && citations[index] > count ) {\\n\\t\\tcount++;\\n\\t\\tindex--;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int hIndex(int[] citations) {\\n\\tint count = 0, index = citations.length - 1;\\n\\twhile( index >= 0 && citations[index] > count ) {\\n\\t\\tcount++;\\n\\t\\tindex--;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1898954,
                "title": "simple-easy-to-understand-c-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& arr) {\\n        int s=0,e=arr.size()-1;\\n        int mid;\\n        //Binary Search\\n        while(s<=e){\\n            mid=s+(e-s)/2;\\n            if(arr[mid]>=arr.size()-mid){\\n                e=mid-1;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return arr.size()-s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& arr) {\\n        int s=0,e=arr.size()-1;\\n        int mid;\\n        //Binary Search\\n        while(s<=e){\\n            mid=s+(e-s)/2;\\n            if(arr[mid]>=arr.size()-mid){\\n                e=mid-1;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return arr.size()-s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858202,
                "title": "python-275-h-index-ii-recursive-solution",
                "content": "``` class Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        \\n        \\n        max_citations  = 0\\n        def binary_search(low, high):\\n            nonlocal max_citations\\n            \\n            if low > high:\\n                return\\n            \\n            mid = low + (high - low)//2\\n            number_papers = len(citations) - mid\\n            \\n            if citations[mid] >= number_papers:\\n                max_citations = max(max_citations, number_papers)\\n                binary_search(low, mid-1)\\n            else:\\n                binary_search(mid + 1, high)\\n                \\n        binary_search(0, len(citations)-1)\\n        return max_citations ```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "``` class Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        \\n        \\n        max_citations  = 0\\n        def binary_search(low, high):\\n            nonlocal max_citations\\n            \\n            if low > high:\\n                return\\n            \\n            mid = low + (high - low)//2\\n            number_papers = len(citations) - mid\\n            \\n            if citations[mid] >= number_papers:\\n                max_citations = max(max_citations, number_papers)\\n                binary_search(low, mid-1)\\n            else:\\n                binary_search(mid + 1, high)\\n                \\n        binary_search(0, len(citations)-1)\\n        return max_citations ```",
                "codeTag": "Java"
            },
            {
                "id": 1778376,
                "title": "java-easy-solution-binary-search-o-logn-tc-o-1-sc",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n=citations.length;\\n        int ans=0;\\n        int low=0;\\n        int high=n-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(citations[mid]>=n-mid){\\n                ans=n-mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n       return ans; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n=citations.length;\\n        int ans=0;\\n        int low=0;\\n        int high=n-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(citations[mid]>=n-mid){\\n                ans=n-mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n       return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775712,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n         int ans = 0;\\n         int lo = 0, hi = citations.size() - 1;\\n         int n = citations.size();\\n        \\n         while(lo <= hi){\\n             int mid = lo + (hi - lo) / 2;\\n             if(citations[mid] >= (n - mid)){\\n                 ans = n - mid;\\n                 hi = mid - 1;\\n             }\\n             else lo = mid + 1;\\n         }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n         int ans = 0;\\n         int lo = 0, hi = citations.size() - 1;\\n         int n = citations.size();\\n        \\n         while(lo <= hi){\\n             int mid = lo + (hi - lo) / 2;\\n             if(citations[mid] >= (n - mid)){\\n                 ans = n - mid;\\n                 hi = mid - 1;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1738553,
                "title": "understand-the-solution",
                "content": "Let\\'s analyze the problem. \\n\\tThe given array is named citations and the comparion array(which is used in code as n-mid) is named hindex\\n\\t\\n\\t(1) normal cases where we can find an exact match:\\n\\t\\n\\tcitations: [0, 1, 3, 5, 6]\\n    hIndex(n-mid): [5, 4, 3, 2, 1] (from right to left, if c[i]>h[i], then at least h[i] paper that higher than h[i]), notice that c is ascending and h is descending.\\n\\t\\n\\tthree conditions will appear:\\n       1.  if (h[i] == c[i]) : the cross point, return h[i];\\n       \\n       2.  if (h[i] < c[i]) : at least h[i] paper has equal or more h[i] index. the answer is found, but we are looking for better answer(bigger h index), so we continue left.\\n       \\n       3.  if (h[i] > c[i]) : meaningless. we need a correct answer so we continue right(smaller h index)\\n       \\n\\t(2)  if cross point is not found, we can consider two cases:\\n        1. all the number are small: \\n        citations: [0, 0, 0, 0, 0]\\n    hIndex(n-mid): [5, 4, 3, 2, 1]\\n        in this case, c[i] is always smaller than h[i], which will continue moves pointer rightwards. thus lo will become really big and n-lo will be 0;\\n\\t\\t\\n        2. all teh numbers are big:\\n        citations: [6, 6, 6, 6, 6]\\n    hIndex(n-mid): [5, 4, 3, 2, 1]\\n        in this case, c[i] is alwasys larger than h[i], which will continue moves pointer leftwards. thus lo will become really small and n-lo will be 5, which is the correct answer.\\n\\t\\t\\n        so we will return n - lo when we can\\'t find an exact match.\\n\\t\\tcode is below:\\n\\t\\t\\n```\\t\\t\\n    public int hIndex(int[] citations) {\\n        int lo = 0, hi = citations.length - 1, n = citations.length;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo)/2;\\n            if (citations[mid] == n-mid) {\\n                return citations[mid];\\n            } else if (citations[mid] < n-mid) {\\n                lo = mid+1;\\n            } else hi = mid-1;\\n        }\\n        return n - lo;\\n    }\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\t\\t\\n    public int hIndex(int[] citations) {\\n        int lo = 0, hi = citations.length - 1, n = citations.length;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo)/2;\\n            if (citations[mid] == n-mid) {\\n                return citations[mid];\\n            } else if (citations[mid] < n-mid) {\\n                lo = mid+1;\\n            } else hi = mid-1;\\n        }\\n        return n - lo;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1650450,
                "title": "c-8ms-99-65-binary-search",
                "content": "Runtime: 8 ms, faster than 99.65% of C++ online submissions for H-Index II.\\nMemory Usage: 18.7 MB, less than 47.03% of C++ online submissions for H-Index II.\\n```\\nclass Solution {\\npublic:\\n  int hIndex(vector<int>& citations) {\\n    int l = 0, r = citations.size() - 1, n = citations.size();\\n    \\n    for(int m = (l + r)>>1; l <= r; m = (l + r)>>1)\\n      citations[m] >= n - m ? r = m - 1 : l = m + 1;\\n    \\n    return l == n ? citations.back() > n ? n : citations.back() : min(citations[l], n - l);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int hIndex(vector<int>& citations) {\\n    int l = 0, r = citations.size() - 1, n = citations.size();\\n    \\n    for(int m = (l + r)>>1; l <= r; m = (l + r)>>1)\\n      citations[m] >= n - m ? r = m - 1 : l = m + 1;\\n    \\n    return l == n ? citations.back() > n ? n : citations.back() : min(citations[l], n - l);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367355,
                "title": "100-python-solution-explained-logn-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\nTime: O(LogN)\\nSpace: O(1)\\n\\nSince citations is sorted,\\ni = N-1, if 1<=citations[i], it means that at least 1 of the citations is larger than 1. h-index is 1.\\ni = N-2, if 2<=citations[i], it means that at least 2 of the citations is larger than 2. h-index is 2.\\n...\\ni = 0, if N<=citations[i], it means that at least N of the citations is larger than N. h-index is N.\\n\\nWe can iterate from N-1 to 0. See what h-index ends up. Using O(N) of time.\\n\\nWe can also binary search the i, see which i match the condition.\\n\"\"\"\\nclass Solution(object):\\n    def hIndex(self, citations):\\n        N = len(citations)\\n        \\n        l = 0\\n        r = N-1\\n        \\n        while l<r:\\n            i = (l+r)/2\\n            h = N-i\\n\\n            if citations[i]>=h:\\n                #h may be the h-index, check larger h.\\n                r = i\\n            else:\\n                #h is not h-index, check smaller h.\\n                l = i+1\\n        \\n        #now, l is equal to r\\n\\n        return N-l if citations[l]!=0 else 0  #take care of edge case [0], [0, 0] or [0, 0, 0]\\n\\n\"\"\"\\nRelated Problems:\\nSearch Insert Position\\nMedian of Two Sorted Arrays\\nFind Minimum in Rotated Sorted Array: I, II\\nFind First and Last Position of Element in Sorted Array\\nGuess Number Higher or Lower\\nFirst Bad Version\\nSearch in Rotated Array:I, II\\nLongest Increasing Subsequence, Count of Smaller Numbers After Self\\nRussian Doll Envelopes\\nH-Index, H-Index II\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(LogN)\\nSpace: O(1)\\n\\nSince citations is sorted,\\ni = N-1, if 1<=citations[i], it means that at least 1 of the citations is larger than 1. h-index is 1.\\ni = N-2, if 2<=citations[i], it means that at least 2 of the citations is larger than 2. h-index is 2.\\n...\\ni = 0, if N<=citations[i], it means that at least N of the citations is larger than N. h-index is N.\\n\\nWe can iterate from N-1 to 0. See what h-index ends up. Using O(N) of time.\\n\\nWe can also binary search the i, see which i match the condition.\\n\"\"\"\\nclass Solution(object):\\n    def hIndex(self, citations):\\n        N = len(citations)\\n        \\n        l = 0\\n        r = N-1\\n        \\n        while l<r:\\n            i = (l+r)/2\\n            h = N-i\\n\\n            if citations[i]>=h:\\n                #h may be the h-index, check larger h.\\n                r = i\\n            else:\\n                #h is not h-index, check smaller h.\\n                l = i+1\\n        \\n        #now, l is equal to r\\n\\n        return N-l if citations[l]!=0 else 0  #take care of edge case [0], [0, 0] or [0, 0, 0]\\n\\n\"\"\"\\nRelated Problems:\\nSearch Insert Position\\nMedian of Two Sorted Arrays\\nFind Minimum in Rotated Sorted Array: I, II\\nFind First and Last Position of Element in Sorted Array\\nGuess Number Higher or Lower\\nFirst Bad Version\\nSearch in Rotated Array:I, II\\nLongest Increasing Subsequence, Count of Smaller Numbers After Self\\nRussian Doll Envelopes\\nH-Index, H-Index II\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003276,
                "title": "java-0-ms-binary-search",
                "content": "```\\nclass Solution {\\n    public int hIndex(int[] nums) {\\n        int n = nums.length;\\n        int left = 0, right = n-1;\\n        \\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] == n-mid){\\n                return nums[mid];\\n            } else if(nums[mid] > n-mid){\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n        \\n        return n-left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] nums) {\\n        int n = nums.length;\\n        int left = 0, right = n-1;\\n        \\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] == n-mid){\\n                return nums[mid];\\n            } else if(nums[mid] > n-mid){\\n                right = mid-1;\\n            } else {\\n                left = mid+1;\\n            }\\n        }\\n        \\n        return n-left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788971,
                "title": "python-solution-with-explanation-o-log-n-faster-than-96-97",
                "content": "For H-Index, we require the array to be in reverse sorted order. Since the input is in sorted order,  we need to return the `length - index(left)`\\nPerform a normal binary search to get the index.\\n\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        if not citations:\\n            return 0\\n        \\n        n = len(citations)\\n        l, r = 0, n\\n        while l < r:\\n            \\n            m = (l+r) // 2\\n            if citations[m] >= n - m:\\n                r = m \\n            else:\\n                l = m + 1\\n        \\n        return n - l \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        if not citations:\\n            return 0\\n        \\n        n = len(citations)\\n        l, r = 0, n\\n        while l < r:\\n            \\n            m = (l+r) // 2\\n            if citations[m] >= n - m:\\n                r = m \\n            else:\\n                l = m + 1\\n        \\n        return n - l \\n```",
                "codeTag": "Java"
            },
            {
                "id": 769579,
                "title": "python-two-approaches-explained-beats-99-19",
                "content": "So the follow-up in the description hints that this problem should be solved via a binary search since it asks us to achieve logarithmic time complexity.  The binary search solution is shown at the end.  \\n\\nTo better understand the binary-search solution, let\\'s first look at the linear time complexity solution (slow).  \\n\\n```python\\ndef hIndex(self, citations: List[int]) -> int:\\n\\tfor h in range(1, len(citations)+1):\\n\\t\\tif citations[-h] < h:\\n\\t\\t\\treturn h - 1\\n\\treturn len(citations)\\n```\\n\\nWhat we are doing here is looking for the first paper that is cited (```citations[-h]```) fewer times than it\\'s rank (```h```).  Here is a step by step walkthrough, starting by comparing the most cited paper (```6```) to a rank of ```h = 1```.  \\n\\nFor the given example: ```[0,1,3,5,6]```\\n\\nWe start at ```h = 1``` and ```citations[-1] = 6``` since ```6 >= 1``` we proceed\\nNext, ```h = 2``` and ```citations[-2] = 5``` since ```5 >= 2``` we proceed\\nNext, ```h = 3``` and ```citations[-3] = 3``` since ```3 >= 3``` we proceed\\nLast, ```h = 4``` and ```citations[-4] = 1``` since ```1 >= 4``` is False, we return the last true value which is ```h = 3```\\n\\nSince we are searching in a sorted list, we can speed up the process through binary search, shown below.  The goal is the same - to locate the least cited paper that has at least as many citations as it\\'s rank.  \\n\\n```python\\ndef hIndex(self, citations: List[int]) -> int:\\n\\tif not citations: return 0\\n\\tif len(citations) == 1: return int(bool(citations.pop()))\\n\\n\\ti = 0\\n\\tj = len(citations) - 1\\n\\twhile i < j:\\n\\t\\tg = (i + j) >> 1\\n\\t\\tif len(citations) - g > citations[g]:\\n\\t\\t\\ti = g + 1\\n\\t\\telse:\\n\\t\\t\\tj = g\\n\\treturn 0 if len(citations) - j > citations[j] else len(citations) - j \\n```\\n<img src=\"https://assets.leetcode.com/users/images/c1d85174-cbb6-4c9e-a1d9-e54341d3f9a7_1596396606.740443.png\" width=\"450px\">\\n",
                "solutionTags": [],
                "code": "```python\\ndef hIndex(self, citations: List[int]) -> int:\\n\\tfor h in range(1, len(citations)+1):\\n\\t\\tif citations[-h] < h:\\n\\t\\t\\treturn h - 1\\n\\treturn len(citations)\\n```\n```citations[-h]```\n```h```\n```6```\n```h = 1```\n```[0,1,3,5,6]```\n```h = 1```\n```citations[-1] = 6```\n```6 >= 1```\n```h = 2```\n```citations[-2] = 5```\n```5 >= 2```\n```h = 3```\n```citations[-3] = 3```\n```3 >= 3```\n```h = 4```\n```citations[-4] = 1```\n```1 >= 4```\n```h = 3```\n```python\\ndef hIndex(self, citations: List[int]) -> int:\\n\\tif not citations: return 0\\n\\tif len(citations) == 1: return int(bool(citations.pop()))\\n\\n\\ti = 0\\n\\tj = len(citations) - 1\\n\\twhile i < j:\\n\\t\\tg = (i + j) >> 1\\n\\t\\tif len(citations) - g > citations[g]:\\n\\t\\t\\ti = g + 1\\n\\t\\telse:\\n\\t\\t\\tj = g\\n\\treturn 0 if len(citations) - j > citations[j] else len(citations) - j \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 764586,
                "title": "c-easy-iterative-b-search-explained-in-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int low = 0 , high = citations.size() - 1, hindex = 0, cunt = 0;\\n         \\n        while(low <= high)\\n        {\\n            int mid = (low + high)/2;\\n\\t\\t\\t\\n\\t\\t\\t// If no.elements in the right subarray is less than the min element(citations[mid])\\n\\t\\t\\t// then length of this subarray can be possible h-index\\n\\t\\t\\t// then recurse to left subarray to find bigger hfactor\\n            if(citations[mid] >= int(citations.size() - mid) ) {\\n                hindex = max(hindex,int(citations.size() - mid));\\n                high = mid - 1;\\n            }\\n            else {\\n\\t\\t\\t// If it cant be hfactor, then go to right subarray\\n                low = mid + 1;\\n            }\\n        }\\n    return hindex;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int low = 0 , high = citations.size() - 1, hindex = 0, cunt = 0;\\n         \\n        while(low <= high)\\n        {\\n            int mid = (low + high)/2;\\n\\t\\t\\t\\n\\t\\t\\t// If no.elements in the right subarray is less than the min element(citations[mid])\\n\\t\\t\\t// then length of this subarray can be possible h-index\\n\\t\\t\\t// then recurse to left subarray to find bigger hfactor\\n            if(citations[mid] >= int(citations.size() - mid) ) {\\n                hindex = max(hindex,int(citations.size() - mid));\\n                high = mid - 1;\\n            }\\n            else {\\n\\t\\t\\t// If it cant be hfactor, then go to right subarray\\n                low = mid + 1;\\n            }\\n        }\\n    return hindex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744943,
                "title": "easy-python-binary-search",
                "content": "**Easy Python | Binary Search**\\n\\n```\\nclass Solution:\\n    def hIndex(self, A):\\n        L     = len(A)\\n        valid = lambda i: A[i]>=(L-i)\\n        i,j   = 0, L-1 \\n        best  = L\\n        #\\n        while i<=j:\\n            mid = (i+j)//2\\n            if valid(mid):\\n                best = mid # After a match, \" (j = mid - 1) < mid \", so the latest match is always the minimum\\n                j = mid - 1 # try even lower\\n            else:\\n                i = mid + 1 # index must be higher\\n        return L-best\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, A):\\n        L     = len(A)\\n        valid = lambda i: A[i]>=(L-i)\\n        i,j   = 0, L-1 \\n        best  = L\\n        #\\n        while i<=j:\\n            mid = (i+j)//2\\n            if valid(mid):\\n                best = mid # After a match, \" (j = mid - 1) < mid \", so the latest match is always the minimum\\n                j = mid - 1 # try even lower\\n            else:\\n                i = mid + 1 # index must be higher\\n        return L-best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696166,
                "title": "c-solution",
                "content": "```\\n/*\\n    Time: O(n)\\n    Space: O(1)\\n*/\\n\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        \\n        // at index i, paper i is cited citations[i] times\\n        // the number of papers who have at least citations[i] is (n - i)\\n        // h-index is the max (n - i) value, so we need to find the smallest i that meet the criteria\\n        \\n        int n = citations.Length; \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // (n-i) papers have at least citation[i]\\n            if(citations[i] >= n - i)\\n                return n - i;\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Time: O(n)\\n    Space: O(1)\\n*/\\n\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        \\n        // at index i, paper i is cited citations[i] times\\n        // the number of papers who have at least citations[i] is (n - i)\\n        // h-index is the max (n - i) value, so we need to find the smallest i that meet the criteria\\n        \\n        int n = citations.Length; \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // (n-i) papers have at least citation[i]\\n            if(citations[i] >= n - i)\\n                return n - i;\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694850,
                "title": "binary-search-apporch",
                "content": "\\n        n=len(c)\\n        l,r=0,n-1\\n        \\n        while l<=r:\\n            mid=(l+r)//2\\n            \\n            if c[mid]<n-mid:\\n                l=mid+1\\n            else:\\n                r=mid-1\\n        return n-l",
                "solutionTags": [],
                "code": "\\n        n=len(c)\\n        l,r=0,n-1\\n        \\n        while l<=r:\\n            mid=(l+r)//2\\n            \\n            if c[mid]<n-mid:\\n                l=mid+1\\n            else:\\n                r=mid-1\\n        return n-l",
                "codeTag": "Unknown"
            },
            {
                "id": 694760,
                "title": "java-0ms-binary-search-o-logn-simple-solution",
                "content": "Please upvote if you like the solution.\\n\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int hIndex=0;\\n        int start=0;\\n        int end=citations.length-1;    \\n        int len=citations.length;\\n        \\n        while(start<=end) {\\n            int mid = start + (end-start)/2;\\n            if(citations[mid]<=len-mid) {\\n                hIndex=hIndex<citations[mid]?citations[mid]:hIndex;\\n                start=mid+1;\\n            } else {\\n                hIndex=hIndex<len-mid?len-mid:hIndex;\\n                end=mid-1;\\n            }\\n        }\\n        return hIndex;\\n    }\\n}\\n```\\n\\n**Runtime**: beats 100.00 % of java submissions\\n**Memory usage**: beats 90.31 % of java submissions",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int hIndex=0;\\n        int start=0;\\n        int end=citations.length-1;    \\n        int len=citations.length;\\n        \\n        while(start<=end) {\\n            int mid = start + (end-start)/2;\\n            if(citations[mid]<=len-mid) {\\n                hIndex=hIndex<citations[mid]?citations[mid]:hIndex;\\n                start=mid+1;\\n            } else {\\n                hIndex=hIndex<len-mid?len-mid:hIndex;\\n                end=mid-1;\\n            }\\n        }\\n        return hIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694718,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& cit) {\\n        int index=0;\\n        for(int j=cit.size()-1; j>=0; j--){\\n            if(cit[j]>index) index++;\\n            else break;\\n        }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& cit) {\\n        int index=0;\\n        for(int j=cit.size()-1; j>=0; j--){\\n            if(cit[j]>index) index++;\\n            else break;\\n        }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694273,
                "title": "python3-bisect-right-and-bisect-left-h-index-ii",
                "content": "There are two ways to do this:  bisect_right and bisect_left.\\n\\nIf you want to bisect the answer directly, you can only use bisect_right because a smaller number (number in the left part of the array) of papers with least citation larger than the number of papers can be the answer (e.g. `[1,2]`) but not vice versa and bisect_right finds the smallest number that\\'s not the answer so the answer should be `lo - 1`. For this reason, `hi` initially should be `n+1` instead of `n`.\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        if not citations:\\n            return 0\\n        n = len(citations)\\n        lo, hi = 0, n+1\\n        while lo < hi:\\n            mid = (lo + hi)//2\\n            if citations[-mid] < mid:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return max(lo-1, 0)\\n```\\n\\nIf you don\\'t bisect the answer directly but the diff between the answer and `n`, you can use bisect_left, which looks nicer.\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        lo, hi = 0, n\\n        while lo < hi:\\n            mid = (lo + hi)//2\\n            if citations[mid] < n - mid:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return n - lo\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        if not citations:\\n            return 0\\n        n = len(citations)\\n        lo, hi = 0, n+1\\n        while lo < hi:\\n            mid = (lo + hi)//2\\n            if citations[-mid] < mid:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return max(lo-1, 0)\\n```\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        n = len(citations)\\n        lo, hi = 0, n\\n        while lo < hi:\\n            mid = (lo + hi)//2\\n            if citations[mid] < n - mid:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return n - lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694031,
                "title": "100-faster-binary-search-recursion-self-explanatory",
                "content": "```\\npublic int hIndex(int[] citations) {\\n        int n=citations.length;\\n        if(n==0)return 0;\\n        return util(citations,0,n-1,n);\\n    }\\n    \\n    int max=0;\\n    public int util(int arr[],int start,int end,int n){\\n        int mid=(start+end)/2;\\n    \\n        if(start>end) return max;\\n        \\n        if(arr[mid]>=n-mid)\\n        {\\n            max=Math.max(max,n-mid);\\n            util(arr,start,mid-1,n);   \\n        }\\n        else{\\n            util(arr,mid+1,end,n);\\n        }\\n        \\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int hIndex(int[] citations) {\\n        int n=citations.length;\\n        if(n==0)return 0;\\n        return util(citations,0,n-1,n);\\n    }\\n    \\n    int max=0;\\n    public int util(int arr[],int start,int end,int n){\\n        int mid=(start+end)/2;\\n    \\n        if(start>end) return max;\\n        \\n        if(arr[mid]>=n-mid)\\n        {\\n            max=Math.max(max,n-mid);\\n            util(arr,start,mid-1,n);   \\n        }\\n        else{\\n            util(arr,mid+1,end,n);\\n        }\\n        \\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693903,
                "title": "c",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        \\n        int H = 0;\\n        \\n        if (citations.size() == 0)\\n            return 0;\\n        \\n        if (citations.size() == 1 && citations[0] == 0)\\n            return 0;\\n        \\n        if (citations.size() == 1 && citations[0] != 0)\\n            return 1;\\n        \\n        sort(citations.begin(), citations.end(), greater<int>());\\n        \\n        for (int i = 0; i < citations.size(); i++)\\n        {\\n            if ( citations[i] <= i )\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                H++;\\n            }\\n        }\\n        \\n        return H;\\n    }\\n};\\n```\\n\\n[\\u53C2\\u8003](https://leetcode.com/problems/h-index-ii/discuss/693427/C%2B%2B-or-BOTH-O(logn)-and-O(n)-solution-with-explanation)\\n\\n```C++\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        \\n        if (citations.size() == 0)\\n            return 0;\\n        \\n        if (citations.size() == 1 && citations[0] == 0)\\n            return 0;\\n        \\n        if (citations.size() == 1 && citations[0] != 0)\\n            return 1;\\n        \\n        int low = 0, high = citations.size()-1;\\n        \\n        int mid = 0, H = 0;\\n        \\n        while (low <= high)\\n        {\\n            mid = (low + high) / 2;\\n            \\n            if ( citations[mid] >= citations.size() - mid)\\n            {\\n                H = citations.size() - mid;\\n            \\n                high = mid - 1;\\n            }\\n                \\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return H;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        \\n        int H = 0;\\n        \\n        if (citations.size() == 0)\\n            return 0;\\n        \\n        if (citations.size() == 1 && citations[0] == 0)\\n            return 0;\\n        \\n        if (citations.size() == 1 && citations[0] != 0)\\n            return 1;\\n        \\n        sort(citations.begin(), citations.end(), greater<int>());\\n        \\n        for (int i = 0; i < citations.size(); i++)\\n        {\\n            if ( citations[i] <= i )\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                H++;\\n            }\\n        }\\n        \\n        return H;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        \\n        if (citations.size() == 0)\\n            return 0;\\n        \\n        if (citations.size() == 1 && citations[0] == 0)\\n            return 0;\\n        \\n        if (citations.size() == 1 && citations[0] != 0)\\n            return 1;\\n        \\n        int low = 0, high = citations.size()-1;\\n        \\n        int mid = 0, H = 0;\\n        \\n        while (low <= high)\\n        {\\n            mid = (low + high) / 2;\\n            \\n            if ( citations[mid] >= citations.size() - mid)\\n            {\\n                H = citations.size() - mid;\\n            \\n                high = mid - 1;\\n            }\\n                \\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return H;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693635,
                "title": "are-there-arrays-which-haven-t-got-solutions",
                "content": "Lets make a function *f* (works with non-negative rational numbers), which assigns to every rational number x the number of numbers in the array that at least x.\\nAnd another one *g* which is just *f(x)=x*.\\n\\nIf f(x)=g(x), x is a valid solution.\\nLet\\'s plot the function graphs!\\n\\n![image](https://assets.leetcode.com/users/meljandavid/image_1592475854.png)\\n\\nAfter this, we can construct our own arrays, which haven\\'t got any solutions.\\nFor example **citations=[0, 1, 3]** have no correct H-Index.\\n![image](https://assets.leetcode.com/users/meljandavid/image_1592475844.png)\\n\\nI had acceptance with this Python solution, but it\\'s just throws a bad answer for the mentioned array.\\n```\\ndef hIndex(self, citations: List[int])->int:\\n\\tN = len(citations)\\n\\thead=0\\n\\ttail=N\\n\\twhile head<tail:\\n\\t\\tmid=(head+tail)//2\\n\\t\\tbigger=N-mid\\n\\n\\t\\tif bigger<=citations[mid]:\\n\\t\\t\\ttail=mid\\n\\t\\telse:\\n\\t\\t\\thead=mid+1\\n\\n\\treturn N-head\\n```\\n\\nEdit: we can see, we can maximum 1 correct H-Index (because g strictly monotonically grows, f decreases)",
                "solutionTags": [],
                "code": "```\\ndef hIndex(self, citations: List[int])->int:\\n\\tN = len(citations)\\n\\thead=0\\n\\ttail=N\\n\\twhile head<tail:\\n\\t\\tmid=(head+tail)//2\\n\\t\\tbigger=N-mid\\n\\n\\t\\tif bigger<=citations[mid]:\\n\\t\\t\\ttail=mid\\n\\t\\telse:\\n\\t\\t\\thead=mid+1\\n\\n\\treturn N-head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 693408,
                "title": "python-easy-and-self-explanatory-solution",
                "content": "Please comment for any doubt\\n\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        l=len(citations)\\n        res=0\\n        for i in range(l):\\n            if citations[l-i-1]>=(res+1):res+=1\\n            else:return res\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        l=len(citations)\\n        res=0\\n        for i in range(l):\\n            if citations[l-i-1]>=(res+1):res+=1\\n            else:return res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693348,
                "title": "c-i-have-done-my-best",
                "content": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) \\n    {\\n        int n = citations.size();\\n        int l = 0,r = n-1;\\n        while (l <= r) \\n        {\\n            int mid = l + (r-l)/2;\\n            if (citations[mid] == n-mid)\\n            return n-mid;\\n            else if(citations[mid] > n-mid)\\n            r = mid-1;\\n            else\\n            l = mid+1;\\n        }\\n        return n-l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) \\n    {\\n        int n = citations.size();\\n        int l = 0,r = n-1;\\n        while (l <= r) \\n        {\\n            int mid = l + (r-l)/2;\\n            if (citations[mid] == n-mid)\\n            return n-mid;\\n            else if(citations[mid] > n-mid)\\n            r = mid-1;\\n            else\\n            l = mid+1;\\n        }\\n        return n-l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513958,
                "title": "python-3-runtime-144-standard-binary-search",
                "content": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        low,hight, n = 0, len(citations)-1, len(citations)\\n        while low<=hight:\\n            middle = low+(hight-low)//2\\n            if (n - middle) == citations[middle]:\\n                return citations[middle]\\n            if (n - middle) < citations[middle]:\\n                hight = middle -1\\n            if (n - middle) > citations[middle]:\\n                low = middle +1 \\n        return n-low\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        low,hight, n = 0, len(citations)-1, len(citations)\\n        while low<=hight:\\n            middle = low+(hight-low)//2\\n            if (n - middle) == citations[middle]:\\n                return citations[middle]\\n            if (n - middle) < citations[middle]:\\n                hight = middle -1\\n            if (n - middle) > citations[middle]:\\n                low = middle +1 \\n        return n-low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447298,
                "title": "python-solution-with-binary-search",
                "content": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        lo, hi = 0, len(citations)\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if citations[~mid] > mid:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        lo, hi = 0, len(citations)\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if citations[~mid] > mid:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401532,
                "title": "java-loop-invariant-explanation",
                "content": "Loop Invariant Explaination:\\nhttp://www.cs.cornell.edu/courses/cs2112/2015fa/lectures/lec_loopinv/index.html\\n\\nFor this question:\\n1. Establishment: The final answer must present in index [0, length - 1].\\n2. Preservation: \\n\\t- mid point situation: val < num. mid + 1 point situation: bigger val, smaller num, at least same H. We can ensure answer will present in [mid + 1, right]\\n\\t- mid point situation: val > num. mid - 1 point situation: smaller val, bigger num, at least same H. We can ensure answer will present in [left, mid - 1].\\n\\t- Thus: Loop invariance is preserved.\\n\\n3. Post-condition: The only situation we can exit the loop is left > right. The only situation we have left > right is when left == mid and val > num. We know we have the loop invariance, answer is in [left, right] in every loop. Thus, after right = mid - 1 = left - 1, left is the only point that is still valid as an answer. Then, return size - left. \\n\\n```\\npublic int hIndex(int[] citations) {\\n\\n        // corner case\\n        if (citations == null || citations.length == 0) return 0;\\n        \\n        int size = citations.length;\\n\\t\\t\\n\\t\\t// establishment\\n        int left = 0, right = size - 1;\\n        \\n        while (left <= right) {\\n            \\n            int mid = (right - left) / 2 + left;\\n            int val = citations[mid];\\n            int num = size - mid;\\n            \\n\\t\\t\\t// preservation\\n            if (val < num) {\\n                left = mid + 1;\\n            } else if (val > num) {\\n                right = mid - 1;\\n            } else {\\n                return num;\\n            }\\n        }\\n        \\n\\t\\t// postcondition\\n        return size - left;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int hIndex(int[] citations) {\\n\\n        // corner case\\n        if (citations == null || citations.length == 0) return 0;\\n        \\n        int size = citations.length;\\n\\t\\t\\n\\t\\t// establishment\\n        int left = 0, right = size - 1;\\n        \\n        while (left <= right) {\\n            \\n            int mid = (right - left) / 2 + left;\\n            int val = citations[mid];\\n            int num = size - mid;\\n            \\n\\t\\t\\t// preservation\\n            if (val < num) {\\n                left = mid + 1;\\n            } else if (val > num) {\\n                right = mid - 1;\\n            } else {\\n                return num;\\n            }\\n        }\\n        \\n\\t\\t// postcondition\\n        return size - left;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 335332,
                "title": "c-native-binary-search",
                "content": "The possible HIndex for every element is  **hIndex = array_size - element_index**, use binary search to find the first element with \\n**citation[element_index] >=hIndex**, if none meets this requirement, return 0;\\n\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        if (citations.empty()) return 0;\\n        \\n        int i = 0;\\n        int size = citations.size();\\n        int j = size - 1;\\n        \\n        while (i < j)\\n        {\\n            int mid = i + (j - i) / 2;\\n            int value = citations[mid];\\n            int hIndex = size - mid;\\n            if (value == hIndex) return value;\\n            else if (value > hIndex) j = mid;\\n            else i = mid + 1;\\n        }\\n        \\n        if (j < 0 || (citations[j] < (size - j))) return 0;\\n        return size - i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        if (citations.empty()) return 0;\\n        \\n        int i = 0;\\n        int size = citations.size();\\n        int j = size - 1;\\n        \\n        while (i < j)\\n        {\\n            int mid = i + (j - i) / 2;\\n            int value = citations[mid];\\n            int hIndex = size - mid;\\n            if (value == hIndex) return value;\\n            else if (value > hIndex) j = mid;\\n            else i = mid + 1;\\n        }\\n        \\n        if (j < 0 || (citations[j] < (size - j))) return 0;\\n        return size - i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295483,
                "title": "super-simple-o-n-solution",
                "content": "Explanations:\\ncitations.length -i is the number of papers that has been citated more than citations[i] times. \\nBesides, the array is already sorted so it must be non-decreasing, thus we know that the previous 0 to i-1 th papers must have been citated less than citations[i] times.\\n\\ncorner case:\\nwhen none of the papers been citated, we return 0;\\n\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        for(int i = 0; i<citations.length; i++){\\n            if(citations[i]>= citations.length -i){\\n                return citations.length -i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        for(int i = 0; i<citations.length; i++){\\n            if(citations[i]>= citations.length -i){\\n                return citations.length -i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272594,
                "title": "simple-java-solution-with-explanation-using-binary-search-beat-100",
                "content": "Main idea: the h-index should be in range of (1, citation.length). So we use binary search to find the biggest n in range of (1, citation.length) where the citation of the last n papers are all bigger than n. The ONLY Change we should do by using the classical binary search is to find the first elment of the last n papers and compare it value to n. \\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if (citations == null || citations.length == 0) return 0;\\n        int start = 1;\\n        int end   = citations.length;\\n        while (start <= end) {\\n            int mid = start + (end - start)/2;       \\n            int index = citations.length - mid;      \\n            if (citations[index] >= mid) start = mid + 1;    \\n            else end = mid - 1;                      \\n        }\\n        return end;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int hIndex(int[] citations) {\\n        if (citations == null || citations.length == 0) return 0;\\n        int start = 1;\\n        int end   = citations.length;\\n        while (start <= end) {\\n            int mid = start + (end - start)/2;       \\n            int index = citations.length - mid;      \\n            if (citations[index] >= mid) start = mid + 1;    \\n            else end = mid - 1;                      \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 174752,
                "title": "python-solution",
                "content": "Binary search:\\n```\\nclass Solution(object):\\n    def hIndex(self, citations):\\n        \"\"\"\\n        :type citations: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(citations)\\n        if n == 0:\\n            return 0\\n        i = 0\\n        j = n-1\\n        while i < j:\\n            mid = (i+j) / 2\\n            if citations[mid] == n-mid:\\n                return n-mid\\n            elif citations[mid] < n-mid:\\n                i = mid+1\\n            else:\\n                j = mid\\n        return min(citations[i],n-i)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hIndex(self, citations):\\n        \"\"\"\\n        :type citations: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(citations)\\n        if n == 0:\\n            return 0\\n        i = 0\\n        j = n-1\\n        while i < j:\\n            mid = (i+j) / 2\\n            if citations[mid] == n-mid:\\n                return n-mid\\n            elif citations[mid] < n-mid:\\n                i = mid+1\\n            else:\\n                j = mid\\n        return min(citations[i],n-i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155445,
                "title": "beats-100-java-easiest-simplest",
                "content": "```\\n public int hIndex(int[] citations) {\\n        int i=0,j=citations.length-1;\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;                 \\n            if(citations[mid]>=(citations.length-mid))\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return citations.length-i;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int hIndex(int[] citations) {\\n        int i=0,j=citations.length-1;\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;                 \\n            if(citations[mid]>=(citations.length-mid))\\n                j=mid-1;\\n            else\\n                i=mid+1;\\n        }\\n        return citations.length-i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71069,
                "title": "clear-java-code-using-binary-search-easy-to-understand",
                "content": "```\\npublic int hIndex(int[] citations) {\\n    int n=citations.length;\\n    int lo=0,hi=n;\\n    while(lo<hi){\\n        int mid=(lo+hi+1)/2;//mid represents current h value, not the current position \\n        if(citations[n-mid]<mid){\\n            hi=mid-1;\\n        }else{\\n            lo=mid;\\n        }\\n    }\\n    return lo;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int hIndex(int[] citations) {\\n    int n=citations.length;\\n    int lo=0,hi=n;\\n    while(lo<hi){\\n        int mid=(lo+hi+1)/2;//mid represents current h value, not the current position \\n        if(citations[n-mid]<mid){\\n            hi=mid-1;\\n        }else{\\n            lo=mid;\\n        }\\n    }\\n    return lo;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71084,
                "title": "o-log-n-c-binary-search",
                "content": "* I spent lots of time on understanding what H is. In fact just image the vector like a bar and the value of each citations[i] is the height of each factor. \\n\\n* **Definition: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \\u2212 h papers have no more than h citations each.\"**\\n\\n* Now you use the H from 0 to n (included) to test all of the factors in the vector. You should find one number of H which makes that that some certain citations[k], the n - k ==  citations[k], where the k is the value of our expected H.\\n\\n* So binary search is applied for Time O(lg n).\\n\\n\\n    class Solution {\\n    public:\\n    int hIndex(vector<int>& citations) {\\n        if(citations.empty()) return 0;\\n        int n = citations.size();\\n        int a = 0, b = n;// because the index range is [0,n].\\n        while(a < b){\\n            int i = a + (b - a)/2;\\n            if(citations[i] > n - i){\\n                b = i;\\n            }\\n            else if(citations[i] < n - i){\\n                a = i + 1;\\n            }\\n            else if(citations[i] == n - i){\\n                return n - i;\\n            }\\n        }\\n        return n - a;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int hIndex(vector<int>& citations) {\\n        if(citations.empty()) return 0;\\n        int n = citations.size();\\n        int a = 0, b = n;// because the index range is [0,n].\\n        while(a < b){\\n            int i = a + (b - a)/2;\\n            if(citations[i] > n - i){\\n                b = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71088,
                "title": "c-o-log-n-solution-by-binary-search-with-explanation",
                "content": "Simply find the maximum k that satisfies ```citations[n-1-k] > k``` by binary search.\\nReturn ```k+1``` as the answer.\\n```\\nclass Solution {\\npublic:\\n    bool valid(vector<int>& citations, int n, int k) {\\n        if (k < n)\\n            return (citations[n-1-k] > k);\\n        else\\n            return false;\\n    }\\n    \\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        if (!n) return 0;\\n        int st = 0;\\n        int ed = n - 1;\\n        if (!valid(citations, n, st)) return 0;\\n        if (valid(citations, n, ed)) return n;\\n        while (ed - st > 1) {\\n            int mid = (st+ed)/2;\\n            if (valid(citations, n, mid))\\n                st = mid;\\n            else\\n                ed = mid;\\n        }\\n        return st+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```citations[n-1-k] > k```\n```k+1```\n```\\nclass Solution {\\npublic:\\n    bool valid(vector<int>& citations, int n, int k) {\\n        if (k < n)\\n            return (citations[n-1-k] > k);\\n        else\\n            return false;\\n    }\\n    \\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        if (!n) return 0;\\n        int st = 0;\\n        int ed = n - 1;\\n        if (!valid(citations, n, st)) return 0;\\n        if (valid(citations, n, ed)) return n;\\n        while (ed - st > 1) {\\n            int mid = (st+ed)/2;\\n            if (valid(citations, n, mid))\\n                st = mid;\\n            else\\n                ed = mid;\\n        }\\n        return st+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71089,
                "title": "efficient-solution-in-c-well-explained",
                "content": "### Solution\\nThere is only one possible result and the demonstration logic is as follows:\\nSuppose, we have two different H-index in n citations and `a<b`.\\n\\n- First, as for b, there are `b` citations that are bigger or equal to `b`.\\n- Second, as for a, there are `a` citations that are bigger or equal to `a` and the rest `n-a` citations are equal to or less than `a`;\\n- But, since `b>a` then there are at least `b` citations that are bigger than `a` (according to the First) and then at most there will be `n-b` that are less than or equal to `a` which is a contradiction against the fact that there will be `n-a` that is equal to or less than `a` (according to the Second). \\n\\nSo once it's sorted, the index can be used to partition the array and do binary searching.\\n\\n- First, the splitting element should be `citations[m]` and `citations.size()-m` and once they are equal, we should directly return otherwise continue the binary searching.\\n- Second, due to the special condition in the First, then we should  use `l=m+1` or `r=m-1` to select the next range and as a result the termination condition should be `l<=r`.\\n\\n>**Note** Corner cases: [1], [0].\\n\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) \\n    {\\n        if(citations.empty()) return 0;\\n        int l = 0, r = citations.size()-1;\\n        while(l <= r)\\n        {\\n            int m = l+((r-l)>>1);\\n            if(citations.size()-m == citations[m]) return citations[m];\\n            else if(citations.size()-m > citations[m]) l = m+1;\\n            else if(citations.size()-m < citations[m]) r = m-1;\\n        }\\n        return citations.size()-l;\\n    }\\n};\\n```\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) \\n    {\\n        if(citations.empty()) return 0;\\n        int l = 0, r = citations.size()-1;\\n        while(l <= r)\\n        {\\n            int m = l+((r-l)>>1);\\n            if(citations.size()-m == citations[m]) return citations[m];\\n            else if(citations.size()-m > citations[m]) l = m+1;\\n            else if(citations.size()-m < citations[m]) r = m-1;\\n        }\\n        return citations.size()-l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71091,
                "title": "a-little-more-than-just-binary-search",
                "content": "Binary search the correct index (from which are the papers counted to H-index) came first in my head:\\n```\\nclass Solution(object):\\n    def hIndex(self, citations):\\n        # Binary Search using number of papers\\n        n = len(citations)\\n        l = 0; r = n\\n        while l < r:\\n            m = (l+r)/2\\n            if citations[m] == n-m: return n-m\\n            elif citations[m] < n-m: l = m+1\\n            else: r = m\\n        return n-l\\n```\\nThat one takes 124ms. \\nThen I thought, wait, we can also binary guess the correct H-index by doing this:\\n```\\nclass Solution(object):\\n    def hIndex(self, citations):\\n        # Binary Search on paper's highest citation: binary guess the h-index\\n        n = len(citations)\\n        if n == 0: return 0\\n        l = 0; r = min(citations[-1], n)\\n        while l < r:\\n            m = l + r - (l+r)/2\\n            if citations[n-m] == m: return m\\n            elif citations[n-m] < m: r = m-1\\n            else: l = m\\n        return l\\n```\\nThe second one took 120ms.\\nNow, do you see how we can optimize the solution a little bit more? For example, when there are many papers with low-index (The second solution does this better than the first one)? Or, when there are very few papers but with high H-index (The first solution handles this better than the second one)?\\n\\nYes, you're right: combining them! Here is the final solution (which is a little faster than the 2 first ones with 112ms and beats 95% submissions, but when you add more variations to the dataset, it will make a lot of difference): \\n```\\nclass Solution(object):\\n    def hIndex(self, citations):\\n        n = len(citations)\\n        if n == 0: return 0\\n        \\n        if citations[-1] > n:\\n            # Binary Search on number of papers: binary search the index\\n            l = 0; r = n\\n            while l < r:\\n                m = (l+r)/2\\n                if citations[m] == n-m: return n-m\\n                elif citations[m] < n-m: l = m+1\\n                else: r = m\\n            return n-l\\n        \\n        else:\\n            # Binary Search on paper's highest citation: binary guess the h-index\\n            l = 0; r = citations[-1]\\n            while l < r:\\n                m = l + r - (l+r)/2\\n                if citations[n-m] == m: return m\\n                elif citations[n-m] < m: r = m-1\\n                else: l = m\\n            return l\\n```\\n![0_1469395339958_Screen Shot 2016-07-24 at 2.11.39 PM.png](/uploads/files/1469395339743-screen-shot-2016-07-24-at-2.11.39-pm.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hIndex(self, citations):\\n        # Binary Search using number of papers\\n        n = len(citations)\\n        l = 0; r = n\\n        while l < r:\\n            m = (l+r)/2\\n            if citations[m] == n-m: return n-m\\n            elif citations[m] < n-m: l = m+1\\n            else: r = m\\n        return n-l\\n```\n```\\nclass Solution(object):\\n    def hIndex(self, citations):\\n        # Binary Search on paper's highest citation: binary guess the h-index\\n        n = len(citations)\\n        if n == 0: return 0\\n        l = 0; r = min(citations[-1], n)\\n        while l < r:\\n            m = l + r - (l+r)/2\\n            if citations[n-m] == m: return m\\n            elif citations[n-m] < m: r = m-1\\n            else: l = m\\n        return l\\n```\n```\\nclass Solution(object):\\n    def hIndex(self, citations):\\n        n = len(citations)\\n        if n == 0: return 0\\n        \\n        if citations[-1] > n:\\n            # Binary Search on number of papers: binary search the index\\n            l = 0; r = n\\n            while l < r:\\n                m = (l+r)/2\\n                if citations[m] == n-m: return n-m\\n                elif citations[m] < n-m: l = m+1\\n                else: r = m\\n            return n-l\\n        \\n        else:\\n            # Binary Search on paper's highest citation: binary guess the h-index\\n            l = 0; r = citations[-1]\\n            while l < r:\\n                m = l + r - (l+r)/2\\n                if citations[n-m] == m: return m\\n                elif citations[n-m] < m: r = m-1\\n                else: l = m\\n            return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71099,
                "title": "share-my-bs-solution-with-explanation",
                "content": "Based on the algorithm described in [this wikipedia article][1], when the citations are sorted in descending order, the h-index is the position of the last publication that has citation larger than or equal to its position. Note that the position here starts from 1. Based on the question's information, the input is sorted in ascending order. Then what we need to find is the last element in the array from end to start that satisfies the requirement. Suppose its index is i, and the total number of publications is n, then we need to find the last i from end to start that citations[i] >= n - i. Based on these, we can come up with a natural binary search approach.\\n\\n    public int hIndex(int[] citations) {\\n        if (citations == null || citations.length == 0) return 0;\\n        int n = citations.length;\\n        int l = 0, r = n - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (citations[m] >= n - m) r = m;\\n            else l = m + 1;\\n        }\\n        return citations[l] >= n - l ? n - l : 0;\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/H-index",
                "solutionTags": [
                    "Java"
                ],
                "code": "Based on the algorithm described in [this wikipedia article][1], when the citations are sorted in descending order, the h-index is the position of the last publication that has citation larger than or equal to its position. Note that the position here starts from 1. Based on the question's information, the input is sorted in ascending order. Then what we need to find is the last element in the array from end to start that satisfies the requirement. Suppose its index is i, and the total number of publications is n, then we need to find the last i from end to start that citations[i] >= n - i. Based on these, we can come up with a natural binary search approach.\\n\\n    public int hIndex(int[] citations) {\\n        if (citations == null || citations.length == 0) return 0;\\n        int n = citations.length;\\n        int l = 0, r = n - 1;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (citations[m] >= n - m) r = m;\\n            else l = m + 1;\\n        }\\n        return citations[l] >= n - l ? n - l : 0;\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/H-index",
                "codeTag": "Unknown"
            },
            {
                "id": 71100,
                "title": "two-different-binary-search-solutions-in-c-accepted-as-best",
                "content": "    //AC - 4ms;\\n    int hIndex1(int* nums, int size)\\n    {\\n        int l=0, r=size-1;\\n        while(l <= r)\\n        {\\n            int m = l+(r-l)/2;\\n            if(size-m < nums[m]) r = m-1;\\n            else if(size-m > nums[m]) l = m+1;\\n            else r--; //ensure the loop will terminate properly;\\n        }\\n        return size-l;\\n    }\\n\\n\\n----------\\n \\nActually we can just return if **size-m == nums[m]** since the array is ordered the left side will always be equal to or smaller than nums[m]. \\n\\n    \\n    //AC - 4ms;\\n    int hIndex(int* nums, int size)\\n    {\\n        int l=0, r=size-1;\\n        while(l <= r)\\n        {\\n            int m = l+(r-l)/2;\\n            if(size-m == nums[m]) return nums[m]; //exactly fit in, just return;\\n            if(size-m < nums[m]) r = m-1;\\n            else l = m+1;\\n        }\\n        return size-l;\\n    }",
                "solutionTags": [],
                "code": "    //AC - 4ms;\\n    int hIndex1(int* nums, int size)\\n    {\\n        int l=0, r=size-1;\\n        while(l <= r)\\n        {\\n            int m = l+(r-l)/2;\\n            if(size-m < nums[m]) r = m-1;\\n            else if(size-m > nums[m]) l = m+1;\\n            else r--; //ensure the loop will terminate properly;\\n        }\\n        return size-l;\\n    }\\n\\n\\n----------\\n \\nActually we can just return if **size-m == nums[m]** since the array is ordered the left side will always be equal to or smaller than nums[m]. \\n\\n    \\n    //AC - 4ms;\\n    int hIndex(int* nums, int size)\\n    {\\n        int l=0, r=size-1;\\n        while(l <= r)\\n        {\\n            int m = l+(r-l)/2;\\n            if(size-m == nums[m]) return nums[m]; //exactly fit in, just return;\\n            if(size-m < nums[m]) r = m-1;\\n            else l = m+1;\\n        }\\n        return size-l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71101,
                "title": "straightforward-standard-very-clean-binary-search",
                "content": "The idea is simple, if you want to have x as h-index, your citation[N-x] must have at least x citations. This is simplified like finding the largest number that satisfy citation[N-x]>=x. So like Find the First Bad Version, code is simple BS:\\n\\n    public int hIndex(int[] c) {\\n\\t\\t\\tint N = c.length;\\n\\t\\t\\tint lo = 0, hi = N;\\n\\t\\t\\twhile (lo < hi) {\\n                // only different, +1 to avoid infinity loop when mid == lo \\n\\t\\t\\t\\tint mid = (hi + lo + 1) / 2;\\n\\t\\t\\t\\tif (c[N - mid] >= mid) {\\n\\t\\t\\t\\t\\tlo = mid;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn lo;\\n\\t}",
                "solutionTags": [],
                "code": "The idea is simple, if you want to have x as h-index, your citation[N-x] must have at least x citations. This is simplified like finding the largest number that satisfy citation[N-x]>=x. So like Find the First Bad Version, code is simple BS:\\n\\n    public int hIndex(int[] c) {\\n\\t\\t\\tint N = c.length;\\n\\t\\t\\tint lo = 0, hi = N;\\n\\t\\t\\twhile (lo < hi) {\\n                // only different, +1 to avoid infinity loop when mid == lo \\n\\t\\t\\t\\tint mid = (hi + lo + 1) / 2;\\n\\t\\t\\t\\tif (c[N - mid] >= mid) {\\n\\t\\t\\t\\t\\tlo = mid;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn lo;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 71111,
                "title": "short-binary-search-c-code",
                "content": "\\n    int hIndex(vector<int>& citations) {\\n        int left = 0, right = citations.size(), idx = right;\\n        while( left < right ) {\\n            idx = (left+right)/2;\\n            if( citations[idx] < citations.size() - idx ) left = idx+1;\\n            else right = idx;\\n        }\\n        return citations.size() - right;\\n    }",
                "solutionTags": [],
                "code": "\\n    int hIndex(vector<int>& citations) {\\n        int left = 0, right = citations.size(), idx = right;\\n        while( left < right ) {\\n            idx = (left+right)/2;\\n            if( citations[idx] < citations.size() - idx ) left = idx+1;\\n            else right = idx;\\n        }\\n        return citations.size() - right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71121,
                "title": "binary-search-solution",
                "content": "    int hIndex(vector<int>& citations) {\\n        if (citations.size() <= 0) return 0;\\n        \\n        int n = citations.size() - 1;\\n        int m = 0, l = 0, r= n;\\n        while (l < r) {\\n            m = l + (r - l) / 2;\\n            if (citations[m] >= n - m + 1)\\n                r = m;\\n            else \\n                l = m + 1;\\n        }\\n        \\n        // finally l is the index satisfy the h-index\\n        return min(citations[l], n - l + 1);\\n    }",
                "solutionTags": [],
                "code": "    int hIndex(vector<int>& citations) {\\n        if (citations.size() <= 0) return 0;\\n        \\n        int n = citations.size() - 1;\\n        int m = 0, l = 0, r= n;\\n        while (l < r) {\\n            m = l + (r - l) / 2;\\n            if (citations[m] >= n - m + 1)\\n                r = m;\\n            else \\n                l = m + 1;\\n        }\\n        \\n        // finally l is the index satisfy the h-index\\n        return min(citations[l], n - l + 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71127,
                "title": "ac-python-48-ms-solution-o-log-n",
                "content": "    def hIndex(self, citations):\\n        r = n = len(citations)\\n        l = 0\\n        while l != r:\\n            m = (l + r) >> 1\\n            if citations[m] == n - m:\\n                return n - m\\n            if citations[m] > n - m:\\n                r = m\\n            else:\\n                l = m + 1\\n        return n - l\\n\\n    # 82 / 82 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 48 ms\\n\\n\\nJust simple binary search.",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    def hIndex(self, citations):\\n        r = n = len(citations)\\n        l = 0\\n        while l != r:\\n            m = (l + r) >> 1\\n            if citations[m] == n - m:\\n                return n - m\\n            if citations[m] > n - m:\\n                r = m\\n            else:\\n                l = m + 1\\n        return n - l\\n\\n    # 82 / 82 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 48 ms\\n\\n\\nJust simple binary search.",
                "codeTag": "Python3"
            },
            {
                "id": 71131,
                "title": "my-binary-search-solution",
                "content": "\\n\\n    public int hIndex(int[] citations) {\\n        if(citations.length==0||citations[citations.length-1]<=0) return 0;\\n        int l=0,r=citations.length-1;\\n        while(l<r){\\n            int mid=(r+l)/2;\\n            if(citations[mid]>citations.length-mid) r=mid;\\n            else if(citations[mid]<citations.length-mid) l=mid+1;\\n            else return citations.length-mid;\\n        }\\n        return citations.length-l;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "\\n\\n    public int hIndex(int[] citations) {\\n        if(citations.length==0||citations[citations.length-1]<=0) return 0;\\n        int l=0,r=citations.length-1;\\n        while(l<r){\\n            int mid=(r+l)/2;\\n            if(citations[mid]>citations.length-mid) r=mid;\\n            else if(citations[mid]<citations.length-mid) l=mid+1;\\n            else return citations.length-mid;\\n        }\\n        return citations.length-l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71140,
                "title": "easy-and-concise-standard-binary-search-solution-in-java-with-detailed-explanation",
                "content": "    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        \\n        int l = 0;\\n        int r = citations.length - 1;\\n        \\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (citations[m] >= n - m) { // It checks if it's a valid H-Index\\n                r = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        \\n        return n - l;\\n    }\\n\\nThe basic idea is that the sorted citations can be treated as two part: the left half of array are not H-index and the right half of array are H-index, our goal is to get the leftmost index of the right half so that the right half part will have maximum number of elements (what question asked). In this case, we can use standard binary search to search for this leftmost element. If m is in the right half, we make `r = m - 1` , else `l = m + 1`.\\n\\nNote: I use `while (l <= r)` for two reasons:\\n\\n 1. If all the elements in array are 0s, pointer `l` will end up with index n (length of array), then `return n - l` will return 0.\\n 2. Since `r = m - 1` will cause pointer `r` end up with being the rightmost element in left half, `l <= r` can make sure pointer `l` stops at index to the right of `r` which is the leftmost element of right half.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        \\n        int l = 0;\\n        int r = citations.length - 1;\\n        \\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (citations[m] >= n - m) { // It checks if it's a valid H-Index\\n                r = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        \\n        return n - l;\\n    }\\n\\nThe basic idea is that the sorted citations can be treated as two part: the left half of array are not H-index and the right half of array are H-index, our goal is to get the leftmost index of the right half so that the right half part will have maximum number of elements (what question asked). In this case, we can use standard binary search to search for this leftmost element. If m is in the right half, we make `r = m - 1` , else `l = m + 1`.\\n\\nNote: I use `while (l <= r)` for two reasons:\\n\\n 1. If all the elements in array are 0s, pointer `l` will end up with index n (length of array), then `return n - l` will return 0.\\n 2. Since `r = m - 1` will cause pointer `r` end up with being the rightmost element in left half, `l <= r` can make sure pointer `l` stops at index to the right of `r` which is the leftmost element of right half.",
                "codeTag": "Unknown"
            },
            {
                "id": 4103866,
                "title": "easy-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n=citations.length;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(citations[mid]==n-mid){\\n                return n-mid;\\n            }\\n            else if(citations[mid]<n-mid){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid-1;\\n            }\\n        }\\n        return n-left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n=citations.length;\\n        int left=0;\\n        int right=n-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(citations[mid]==n-mid){\\n                return n-mid;\\n            }\\n            else if(citations[mid]<n-mid){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid-1;\\n            }\\n        }\\n        return n-left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101214,
                "title": "simple-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Binary Search \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int start=0;\\n        int end=citations.length-1;\\n        int cou=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int k=citations.length-mid;\\n            if(citations[mid]>=k){\\n                end=mid-1;\\n                cou=k;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return cou;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int start=0;\\n        int end=citations.length-1;\\n        int cou=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int k=citations.length-mid;\\n            if(citations[mid]>=k){\\n                end=mid-1;\\n                cou=k;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return cou;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090413,
                "title": "binary-search-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int low = 0;\\n        int high = n - 1;\\n        while(low <= high) {\\n            int mid = low + (high - low)/2;\\n            if(citations[mid] == (n - mid))\\n                return citations[mid];\\n            else if(citations[mid] > (n - mid)) \\n                high = mid - 1;\\n            else \\n                low = mid + 1;\\n        }\\n        return n - low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        int low = 0;\\n        int high = n - 1;\\n        while(low <= high) {\\n            int mid = low + (high - low)/2;\\n            if(citations[mid] == (n - mid))\\n                return citations[mid];\\n            else if(citations[mid] > (n - mid)) \\n                high = mid - 1;\\n            else \\n                low = mid + 1;\\n        }\\n        return n - low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080017,
                "title": "simple-binary-search-c-code-beats-83-05-with-explanation",
                "content": "# Intuition\\nThe problem requires us to find the H-Index, which is a metric used to measure the impact and productivity of a researcher\\'s work. The H-Index represents the number of papers with at least `h` citations, where `h` is the largest possible value. We need to find this `h` value.\\n\\n# Approach\\n1. We begin with an efficient binary search approach to find the H-Index.\\n\\n2. We initialize `start` to 0 and `end` to the last index of the `citations` array. `ans` is initialized to 0, and `mid` and `cmt` are used to keep track of the middle index and the number of papers with at least `h` citations, respectively.\\n\\n3. We enter a binary search loop while `start` is less than or equal to `end`.\\n\\n4. In each iteration of the loop, we calculate the `mid` index as the average of `start` and `end`. We also calculate `cmt`, which represents the number of papers with at least `h` citations if `mid` is the H-Index.\\n\\n5. We check if the number of citations at index `mid` is greater than or equal to `cmt`. If it is, it means that `mid` could be a valid H-Index. We update `ans` to `citations.size() - mid`, indicating that we have found a candidate H-Index.\\n\\n6. If `citations[mid] >= cmt`, we adjust the `end` pointer to `mid - 1` to explore lower values of `mid` for a potentially higher H-Index.\\n\\n7. If `citations[mid]` is less than `cmt`, we adjust the `start` pointer to `mid + 1` to explore higher values of `mid`.\\n\\n8. We continue this binary search until `start` is greater than `end`, at which point we have found the largest possible H-Index, and `ans` contains the answer.\\n\\n9. We return `ans` as the H-Index.\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$, where n is the number of citations. The binary search reduces the search space efficiently.\\n- Space complexity: $$O(1)$$, as we only use a few variables for tracking and calculations.\\n# Example\\nSuppose `citations` is [0, 1, 3, 5, 6]. Here\\'s how the code works:\\n\\n- Initially, `start` is 0 and `end` is 4.\\n- In the first iteration, `mid` is calculated as 2, and `cmt` is 3. Since `citations[2]` (3) is greater than or equal to `cmt` (3), we update `ans` to 3 and set `end` to 1.\\n- In the second iteration, `mid` is calculated as 0, and `cmt` is 5. Since `citations[0]` (0) is less than `cmt` (5), we set `start` to 1.\\n- In the third iteration, `start` is now greater than `end`, so we exit the loop. The H-Index is 3, and `ans` contains the answer.\\n\\nThe final result is `ans = 3`, which represents the H-Index.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int start = 0;\\n        int end = citations.size() - 1;\\n        int ans = 0,mid = 0,cmt = 0;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            cmt = citations.size() - mid;\\n            if (citations[mid]>= cmt) {\\n                ans = citations.size() - mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int start = 0;\\n        int end = citations.size() - 1;\\n        int ans = 0,mid = 0,cmt = 0;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            cmt = citations.size() - mid;\\n            if (citations[mid]>= cmt) {\\n                ans = citations.size() - mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058228,
                "title": "optiminize-solution-using-binary-search-100-beats-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int left = 0;\\n        int right = citations.length-1;\\n\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(citations[mid] < citations.length-mid){\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return citations.length-left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int left = 0;\\n        int right = citations.length-1;\\n\\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n            if(citations[mid] < citations.length-mid){\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return citations.length-left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053452,
                "title": "binarysearch-solution-95-for-time-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        left, right = 0, len(citations) - 1\\n        ans = 0\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if citations[mid] >= len(citations) - mid:\\n                ans = max(ans, len(citations) - mid)\\n                right = mid - 1\\n            else: left = mid + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hIndex(self, citations: List[int]) -> int:\\n        left, right = 0, len(citations) - 1\\n        ans = 0\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if citations[mid] >= len(citations) - mid:\\n                ans = max(ans, len(citations) - mid)\\n                right = mid - 1\\n            else: left = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034766,
                "title": "binary-search-log-n-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations.length == 1){\\n            return citations[0]==0?0:1;\\n        }\\n        int lo = 0;\\n        int hi = citations.length-1;\\n        if(citations[hi]==0){\\n            return 0;\\n        }\\n        while(lo<hi){\\n            int mid = (lo+hi)/2;\\n            int val = citations[mid];\\n            int n = citations.length-mid;\\n            if(val>=n){\\n                hi = mid;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return citations.length-hi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        if(citations.length == 1){\\n            return citations[0]==0?0:1;\\n        }\\n        int lo = 0;\\n        int hi = citations.length-1;\\n        if(citations[hi]==0){\\n            return 0;\\n        }\\n        while(lo<hi){\\n            int mid = (lo+hi)/2;\\n            int val = citations[mid];\\n            int n = citations.length-mid;\\n            if(val>=n){\\n                hi = mid;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return citations.length-hi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032339,
                "title": "h-index-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n    final int n = citations.length;\\n    int l = 0;\\n    int r = n;\\n\\n    while (l < r) {\\n      final int m = (l + r) / 2;\\n      if (citations[m] >= n - m)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return n - l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n    final int n = citations.length;\\n    int l = 0;\\n    int r = n;\\n\\n    while (l < r) {\\n      final int m = (l + r) / 2;\\n      if (citations[m] >= n - m)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return n - l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031748,
                "title": "my-o-n-time-and-o-1-space-complexity-4-line-solution-c",
                "content": "# Intuition\\nIterate from the end. Check if $c[i]>=no\\\\_of\\\\_papers_before$ (i.e check if the no. of papers with c[i] or more ciatations is h or not if yes then h index becomes h, then continue). \\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int hIndex(vector<int>& c) \\n    {\\n        int ans=0;\\n        for(int i=c.size()-1;i>=0;i--)\\n        {\\n            int h=c.size()-i;\\n\\n            if(c[i]>=h)\\n            ans=h;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int hIndex(vector<int>& c) \\n    {\\n        int ans=0;\\n        for(int i=c.size()-1;i>=0;i--)\\n        {\\n            int h=c.size()-i;\\n\\n            if(c[i]>=h)\\n            ans=h;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026750,
                "title": "beats-most-of-the-solutions-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        long long end = citations.size()-1;\\n        long long start =0;\\n        long long mid =(end + start)/2;\\n        int num = 0;\\n        while(start <= end){\\n            if(citations[mid] < citations.size()-mid)\\n            {\\n                start = mid +1;\\n            }\\n            else if(citations[mid] > citations.size()-mid){\\n                end = mid -1;\\n            }\\n            else{\\n                if(citations[mid]>num){\\n                    num = citations[mid];\\n                }\\n                start = mid +1;\\n            }\\n            mid = (end + start)/2;\\n        }\\n\\n        return num > (citations.size()-end-1)?num:(citations.size()-end-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        long long end = citations.size()-1;\\n        long long start =0;\\n        long long mid =(end + start)/2;\\n        int num = 0;\\n        while(start <= end){\\n            if(citations[mid] < citations.size()-mid)\\n            {\\n                start = mid +1;\\n            }\\n            else if(citations[mid] > citations.size()-mid){\\n                end = mid -1;\\n            }\\n            else{\\n                if(citations[mid]>num){\\n                    num = citations[mid];\\n                }\\n                start = mid +1;\\n            }\\n            mid = (end + start)/2;\\n        }\\n\\n        return num > (citations.size()-end-1)?num:(citations.size()-end-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022438,
                "title": "best-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s how the algorithm works:\\n\\nInitialize left to 0 and right to the last index of the array.\\nRun a binary search to find the h-index.\\nIn each iteration, calculate mid.\\nCheck if citations[mid] is greater than or equal to n - mid. If it is, it means there are at least n - mid papers with at least n - mid citations.\\nIf the condition is met, move right to mid - 1 to search for a smaller h-index.\\nIf the condition is not met, move left to mid + 1 to search for a larger h-index.\\nRepeat the binary search until left is greater than right.\\nThe h-index is equal to n - left after the binary search.\\n# Complexity\\n- Time complexity:     logarithmic\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:   O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int hIndex(int[] citations) {\\n        int left = 0;\\n        int right = citations.length - 1;\\n        int n = citations.length;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (citations[mid] >= n - mid) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return n - left;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int hIndex(int[] citations) {\\n        int left = 0;\\n        int right = citations.length - 1;\\n        int n = citations.length;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (citations[mid] >= n - mid) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return n - left;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017844,
                "title": "binary-search-c-o-n-log-n",
                "content": "# Intuition\\nBinary search on the possible value of $h$ indices. If $h$ is a possible answer then so is $h-1$. So it forms a monotone space. We can take our low as $low=0$ and $max=n$ and binary search on the possible value. If we get a possible value, move forward. \\n\\n\\n# Complexity\\n- Time complexity:\\n$O(n*log(n))$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //check if h index of x is possible or not\\n    //i.e check if there exist atleast x paper with atleast x ciatations\\n    bool check(vector<int>&a, int x)\\n    {\\n        int count=0;\\n        auto it=lower_bound(a.begin(),a.end(),x);\\n        count=a.size()-(it-a.begin());//number of papers with atleast x ciatations\\n\\n        return count>=x;//check if the no. of papers with atleast x ciatations is greater than x or not\\n    }\\n    int hIndex(vector<int>& c) \\n    {\\n        int mi=INT_MAX,mx=INT_MIN;\\n\\n        for(int i=0;i<c.size();i++)\\n        {\\n            mi=min(c[i],mi);\\n            mx=max(c[i],mx);\\n        }\\n\\n        //possible value of h index is a monotone space, here our ans will be max h index, if h is possible so id h-1\\n        int l=0,h=c.size(),mid,ans=0;\\n\\n        while(l<=h)\\n        {\\n            mid=(l+h)/2;\\n\\n            if(check(c,mid))\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else \\n            {\\n                h=mid-1;\\n            }\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //check if h index of x is possible or not\\n    //i.e check if there exist atleast x paper with atleast x ciatations\\n    bool check(vector<int>&a, int x)\\n    {\\n        int count=0;\\n        auto it=lower_bound(a.begin(),a.end(),x);\\n        count=a.size()-(it-a.begin());//number of papers with atleast x ciatations\\n\\n        return count>=x;//check if the no. of papers with atleast x ciatations is greater than x or not\\n    }\\n    int hIndex(vector<int>& c) \\n    {\\n        int mi=INT_MAX,mx=INT_MIN;\\n\\n        for(int i=0;i<c.size();i++)\\n        {\\n            mi=min(c[i],mi);\\n            mx=max(c[i],mx);\\n        }\\n\\n        //possible value of h index is a monotone space, here our ans will be max h index, if h is possible so id h-1\\n        int l=0,h=c.size(),mid,ans=0;\\n\\n        while(l<=h)\\n        {\\n            mid=(l+h)/2;\\n\\n            if(check(c,mid))\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else \\n            {\\n                h=mid-1;\\n            }\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011441,
                "title": "java-beats-100-binary-search",
                "content": "# Intuition\\nFrom the definition of H-index, it is clear that we need to find the index such that it\\'s value is greater than or equal to it\\'s position in the array. As the array is sorted in ascending order, we will use binary search and compare the value at the index with the length of the remaining part of the array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$ \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        long l=0, r=citations.length-1, len=citations.length, ans=0;\\n        while(l<=r){\\n            long mid = (l+r)/2;\\n            if(len-mid <= citations[(int)mid]){\\n                ans = (int)(len-mid);\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        long l=0, r=citations.length-1, len=citations.length, ans=0;\\n        while(l<=r){\\n            long mid = (l+r)/2;\\n            if(len-mid <= citations[(int)mid]){\\n                ans = (int)(len-mid);\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002315,
                "title": "without-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        for (int i=0; i < citations.length; i++){\\n            if(n-i <= citations[i]){\\n                return n-i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int n = citations.length;\\n        for (int i=0; i < citations.length; i++){\\n            if(n-i <= citations[i]){\\n                return n-i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984550,
                "title": "time-100-space-98-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Binary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> No clue\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int left = 0; int right = citations.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (citations[mid] < citations.length - mid) {\\n                left = mid + 1;\\n            } else if (citations[mid] > citations.length - mid) { // Corrected condition\\n                right = mid - 1;\\n            } else {\\n                return citations[mid];\\n            }\\n        }\\n        return citations.length - left;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        int left = 0; int right = citations.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (citations[mid] < citations.length - mid) {\\n                left = mid + 1;\\n            } else if (citations[mid] > citations.length - mid) { // Corrected condition\\n                right = mid - 1;\\n            } else {\\n                return citations[mid];\\n            }\\n        }\\n        return citations.length - left;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981903,
                "title": "easy-to-code-c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUtilize binary search to find the smallest h that satisfies the h-index condition in a sorted citations list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplement a binary search algorithm to locate the minimum h satisfying the h-index criteria.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        int left = 0;\\n        int right = n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (citations[mid] >= n - mid) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return n - left;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& citations) {\\n        int n = citations.size();\\n        int left = 0;\\n        int right = n - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (citations[mid] >= n - mid) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return n - left;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972487,
                "title": "h-index-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        int left = 0;\\n        int right = citations.Length - 1;\\n\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(citations[mid] >= (citations.Length - mid)){\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return  citations.Length - left;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int HIndex(int[] citations) {\\n        int left = 0;\\n        int right = citations.Length - 1;\\n\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(citations[mid] >= (citations.Length - mid)){\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return  citations.Length - left;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968346,
                "title": "simple-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    boolean count(int[] arr,int i){\\n\\n        int c=0;\\n        for(int x:arr){\\n            if(x>=i){\\n                c++;\\n            }\\n        }\\n\\n        if(c>=i){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    public int hIndex(int[] arr) {\\n        \\n        if(arr.length==1){\\n\\n            return arr[0]>0?1:0;\\n\\n        }\\n\\n        int l=0;\\n        int h=arr[arr.length-1];\\n        int maxx=0;\\n\\n        while(l<=h){\\n\\n            int m=l+(h-l)/2;\\n\\n            if(count(arr,m)){\\n                maxx=Math.max(maxx,m);\\n                l=m+1;\\n            }\\n            else{\\n                h=m-1;\\n            }\\n\\n        }\\n\\n        return maxx;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    boolean count(int[] arr,int i){\\n\\n        int c=0;\\n        for(int x:arr){\\n            if(x>=i){\\n                c++;\\n            }\\n        }\\n\\n        if(c>=i){\\n            return true;\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    public int hIndex(int[] arr) {\\n        \\n        if(arr.length==1){\\n\\n            return arr[0]>0?1:0;\\n\\n        }\\n\\n        int l=0;\\n        int h=arr[arr.length-1];\\n        int maxx=0;\\n\\n        while(l<=h){\\n\\n            int m=l+(h-l)/2;\\n\\n            if(count(arr,m)){\\n                maxx=Math.max(maxx,m);\\n                l=m+1;\\n            }\\n            else{\\n                h=m-1;\\n            }\\n\\n        }\\n\\n        return maxx;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957215,
                "title": "90-faster-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        if(!n) return 0;\\n        int low =0,high=n-1;\\n        int ans = 0;\\n        while(low<=high){\\n            int mid  = low + (high-low)/2;\\n            if(c[mid] >= n-mid){\\n                ans = n-mid;\\n                high = mid - 1;\\n            }else{\\n                low  = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hIndex(vector<int>& c) {\\n        int n = c.size();\\n        if(!n) return 0;\\n        int low =0,high=n-1;\\n        int ans = 0;\\n        while(low<=high){\\n            int mid  = low + (high-low)/2;\\n            if(c[mid] >= n-mid){\\n                ans = n-mid;\\n                high = mid - 1;\\n            }else{\\n                low  = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956684,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    let hIndex = 0;\\n    let ind = citations.length -1;\\n    for (let i = 1; i <= citations.length; i++) {\\n        if (citations[ind] >= i) {\\n        hIndex = i;\\n        } else {\\n            break;\\n        }\\n        ind--;\\n    }\\n    return hIndex;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} citations\\n * @return {number}\\n */\\nvar hIndex = function(citations) {\\n    let hIndex = 0;\\n    let ind = citations.length -1;\\n    for (let i = 1; i <= citations.length; i++) {\\n        if (citations[ind] >= i) {\\n        hIndex = i;\\n        } else {\\n            break;\\n        }\\n        ind--;\\n    }\\n    return hIndex;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954497,
                "title": "best-java-solution-binary-search-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // coppied\\n    public int hIndex(int[] arr) {\\n        int n = arr.length;\\n\\n    \\n        int i=0;\\n        int j = n-1;\\n\\n        int ans = 0;\\n        while(i<=j){\\n            int mid = i+(j-i)/2;\\n\\n            if(n-mid<=arr[mid]){\\n                ans = n-mid;\\n                j=mid-1; \\n            }else i=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // coppied\\n    public int hIndex(int[] arr) {\\n        int n = arr.length;\\n\\n    \\n        int i=0;\\n        int j = n-1;\\n\\n        int ans = 0;\\n        while(i<=j){\\n            int mid = i+(j-i)/2;\\n\\n            if(n-mid<=arr[mid]){\\n                ans = n-mid;\\n                j=mid-1; \\n            }else i=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951339,
                "title": "code-undertsand-line-by-line-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nmain oal of question is that it is asking to apply binary search on answer\\n//start from 1 to max vlue of array to apply binary search on this\\n//then by binary search find out mid and ye jo mid hoga na to compare kya ye mid jo hai atleast mid no of paper hai array me jinka citations mid times hai\\n//.e main goal is to find max value m such that atleast m no of paper with atleast n ctatons\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- time complexcity is although twice of binary search i.e o(logn*logmax(array)) as logn time lga hame frst occurence khone me and log max(array) as ham 1 to max element k bich dekh rhe the kon sa aisa no hai jispe ye condition meet hoga h index ka as yhi hme khojna tha\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*If you have a list of citations [0, 1, 3, 5, 6], where each number represents the number of citations for a specific publication, you would calculate the h-index as follows:\\n\\nSort the list in descending order: [6, 5, 3, 1, 0]\\nFind the highest number \\'h\\' such that there are at least \\'h\\' elements in the list that have a value greater than or equal to \\'h\\'.\\nIn this case, there are three elements (6, 5, and 3) that are greater than or equal to 3. So, the h-index is 3, indicating that there are three publications that each have at least 3 citations.\\n\\nI apologize for any confusion earlier. Thank you for providing the example, and I hope this explanation clarifies the calculation of the h-index in this context.\\n\\n\\nThe algorithm focuses on finding the point in the sorted array where the citation value becomes greater than or equal to the number of papers with at least that many citations. It employs binary search to quickly narrow down the search space and efficiently find the h-index.\\n*/\\n\\n//READ IN ANOTHER EXPECT KI JITNA ARRAY KA SIZE HAI MEAN UTNA TO NO OF BOOK PUBLISHED HO CHUKA HAI\\n//LET OTH INDEX PE HAI TO OTH INDEX PE VALUE 0 HAI N [0,1,3,5,6] TO H INDEX VO HOTA HAI JO iTH CITATIONS K LIYE ATLEAST Ith ITNA PAPER PUBLISHH KR DENA CHAIYE TO 0TH CITATIONS K LIYE OTH PAPER TLEAST HONNA CHIYE TO JAHA MID HAI USSKO SIZE SEE MINUS KR DO TO VO DE DEGA KI KITNA BOOK US INDEX SE PUBLISH HO CHUKA HAI AGE USKO INCLUDE KRKE\\nint howsmall( vector<int>citations,int num)\\n{\\n    int lo=0;\\n    int hi=citations.size()-1;\\n    int ans=0;\\n    while(lo<=hi)\\n    {\\n      int mid=lo+(hi-lo)/2;\\n      if(citations[mid]>=num) //ham sabse lower bound khoj rhe hai isliye ans me store krek hm left ja rhe hai\\n      //agr citations==mid pe return kr jata to sbse frst jo just 3 hi hai ya 3 se jst bada hai let vo nhi mil pta  [7 7 7 7 7 7 7] isme hamko fst occurence hi dhndhna pdega na isly  ans=mid m store krke hi=mid-1 trf chl diye ki kya pata iske left me aur ho jo ki frst appearcnce ho is mid ka\\n      {\\n           ans=mid;\\n          hi=mid-1;//as hame upper bound hona hai na agr right me gya to sare bade hi milenge na isliye h=mid-1 kr diya\\n        \\n      }\\n      else\\n      {\\n          lo=mid+1;\\n      }\\n    }\\n    return ans;\\n}\\n    int hIndex(vector<int>& citations) {\\n      int lo=1;\\n      int hi=citations[citations.size()-1];//hmlog answer pe binary search lgainge\\n      int n=citations.size();\\n      int ans=0;\\n      while(lo<=hi)  \\n      {\\n          int mid=lo+(hi-lo)/2;\\n          int k=howsmall(citations,mid);\\n          if(n-k>=mid)\\n          {\\n              ans=mid;\\n              lo=mid+1;\\n          }\\n          else\\n          {\\n              hi=mid-1;\\n          }\\n          \\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*If you have a list of citations [0, 1, 3, 5, 6], where each number represents the number of citations for a specific publication, you would calculate the h-index as follows:\\n\\nSort the list in descending order: [6, 5, 3, 1, 0]\\nFind the highest number \\'h\\' such that there are at least \\'h\\' elements in the list that have a value greater than or equal to \\'h\\'.\\nIn this case, there are three elements (6, 5, and 3) that are greater than or equal to 3. So, the h-index is 3, indicating that there are three publications that each have at least 3 citations.\\n\\nI apologize for any confusion earlier. Thank you for providing the example, and I hope this explanation clarifies the calculation of the h-index in this context.\\n\\n\\nThe algorithm focuses on finding the point in the sorted array where the citation value becomes greater than or equal to the number of papers with at least that many citations. It employs binary search to quickly narrow down the search space and efficiently find the h-index.\\n*/\\n\\n//READ IN ANOTHER EXPECT KI JITNA ARRAY KA SIZE HAI MEAN UTNA TO NO OF BOOK PUBLISHED HO CHUKA HAI\\n//LET OTH INDEX PE HAI TO OTH INDEX PE VALUE 0 HAI N [0,1,3,5,6] TO H INDEX VO HOTA HAI JO iTH CITATIONS K LIYE ATLEAST Ith ITNA PAPER PUBLISHH KR DENA CHAIYE TO 0TH CITATIONS K LIYE OTH PAPER TLEAST HONNA CHIYE TO JAHA MID HAI USSKO SIZE SEE MINUS KR DO TO VO DE DEGA KI KITNA BOOK US INDEX SE PUBLISH HO CHUKA HAI AGE USKO INCLUDE KRKE\\nint howsmall( vector<int>citations,int num)\\n{\\n    int lo=0;\\n    int hi=citations.size()-1;\\n    int ans=0;\\n    while(lo<=hi)\\n    {\\n      int mid=lo+(hi-lo)/2;\\n      if(citations[mid]>=num) //ham sabse lower bound khoj rhe hai isliye ans me store krek hm left ja rhe hai\\n      //agr citations==mid pe return kr jata to sbse frst jo just 3 hi hai ya 3 se jst bada hai let vo nhi mil pta  [7 7 7 7 7 7 7] isme hamko fst occurence hi dhndhna pdega na isly  ans=mid m store krke hi=mid-1 trf chl diye ki kya pata iske left me aur ho jo ki frst appearcnce ho is mid ka\\n      {\\n           ans=mid;\\n          hi=mid-1;//as hame upper bound hona hai na agr right me gya to sare bade hi milenge na isliye h=mid-1 kr diya\\n        \\n      }\\n      else\\n      {\\n          lo=mid+1;\\n      }\\n    }\\n    return ans;\\n}\\n    int hIndex(vector<int>& citations) {\\n      int lo=1;\\n      int hi=citations[citations.size()-1];//hmlog answer pe binary search lgainge\\n      int n=citations.size();\\n      int ans=0;\\n      while(lo<=hi)  \\n      {\\n          int mid=lo+(hi-lo)/2;\\n          int k=howsmall(citations,mid);\\n          if(n-k>=mid)\\n          {\\n              ans=mid;\\n              lo=mid+1;\\n          }\\n          else\\n          {\\n              hi=mid-1;\\n          }\\n          \\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564845,
                "content": [
                    {
                        "username": "qjhdtc001",
                        "content": "apeuiofadfhfaoefwapfiejfoijfopdjfjopj"
                    },
                    {
                        "username": "teqarine",
                        "content": "yeah exactly! you got it right!\\n"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) yes"
                    },
                    {
                        "username": "jerryy147",
                        "content": "best comment i've seen on leetcode"
                    },
                    {
                        "username": "gary16",
                        "content": "*\"A scientist has index h if h of his/her N papers **have at least h citations** each, and ... ...\"*\\n\\ntest case: `citation = [1,2,3,5,8,9]` \\nresult: `h= 3`\\n\\nso by answer 3 of 6 papers have at least 3 citaitons each, but clearly by definition 4 of 6 papers have at least 3 citations each. \\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Bro, H papers must have atleast H citations. So if U chose H to be 4 than 4 papers must have more than 4 citations.\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "This question is very logical and good application of __discrete binary search__. Why is this downvoted by so many??"
                    },
                    {
                        "username": "tanish34",
                        "content": "[@interpreter](/interpreter)  ig the reason its expecting 1 is because there is 1 research paper with atleast 1 citation(which can be 1 or more than 1)"
                    },
                    {
                        "username": "interpreter",
                        "content": "Because test case is wrong when people are submitting correct code its not expecting.\\n\\nInput as [100] should expect answer 0 because it doesn\\'t have 100 experiments with at least citation value 100. But it\\'s expecting 1.\\n\\nBecause of such test cases only 827 likes and 1.2k dislikes. I have already given feedback with details waiting for correction.\\n\\nThanks\\n"
                    },
                    {
                        "username": "mjmanoj",
                        "content": "exactly"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Too Confusing Got to Do it again.\\nConsumed Whole Day."
                    },
                    {
                        "username": "IRafael",
                        "content": "The funny thing is, if the first part is solved optimally, then to solve this one, you just need to remove the sorting of the initial array)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "hanzichi",
                        "content": "as title, nothing else to say..."
                    }
                ]
            },
            {
                "id": 1569763,
                "content": [
                    {
                        "username": "qjhdtc001",
                        "content": "apeuiofadfhfaoefwapfiejfoijfopdjfjopj"
                    },
                    {
                        "username": "teqarine",
                        "content": "yeah exactly! you got it right!\\n"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) yes"
                    },
                    {
                        "username": "jerryy147",
                        "content": "best comment i've seen on leetcode"
                    },
                    {
                        "username": "gary16",
                        "content": "*\"A scientist has index h if h of his/her N papers **have at least h citations** each, and ... ...\"*\\n\\ntest case: `citation = [1,2,3,5,8,9]` \\nresult: `h= 3`\\n\\nso by answer 3 of 6 papers have at least 3 citaitons each, but clearly by definition 4 of 6 papers have at least 3 citations each. \\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Bro, H papers must have atleast H citations. So if U chose H to be 4 than 4 papers must have more than 4 citations.\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "This question is very logical and good application of __discrete binary search__. Why is this downvoted by so many??"
                    },
                    {
                        "username": "tanish34",
                        "content": "[@interpreter](/interpreter)  ig the reason its expecting 1 is because there is 1 research paper with atleast 1 citation(which can be 1 or more than 1)"
                    },
                    {
                        "username": "interpreter",
                        "content": "Because test case is wrong when people are submitting correct code its not expecting.\\n\\nInput as [100] should expect answer 0 because it doesn\\'t have 100 experiments with at least citation value 100. But it\\'s expecting 1.\\n\\nBecause of such test cases only 827 likes and 1.2k dislikes. I have already given feedback with details waiting for correction.\\n\\nThanks\\n"
                    },
                    {
                        "username": "mjmanoj",
                        "content": "exactly"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Too Confusing Got to Do it again.\\nConsumed Whole Day."
                    },
                    {
                        "username": "IRafael",
                        "content": "The funny thing is, if the first part is solved optimally, then to solve this one, you just need to remove the sorting of the initial array)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "hanzichi",
                        "content": "as title, nothing else to say..."
                    }
                ]
            },
            {
                "id": 1573338,
                "content": [
                    {
                        "username": "qjhdtc001",
                        "content": "apeuiofadfhfaoefwapfiejfoijfopdjfjopj"
                    },
                    {
                        "username": "teqarine",
                        "content": "yeah exactly! you got it right!\\n"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) yes"
                    },
                    {
                        "username": "jerryy147",
                        "content": "best comment i've seen on leetcode"
                    },
                    {
                        "username": "gary16",
                        "content": "*\"A scientist has index h if h of his/her N papers **have at least h citations** each, and ... ...\"*\\n\\ntest case: `citation = [1,2,3,5,8,9]` \\nresult: `h= 3`\\n\\nso by answer 3 of 6 papers have at least 3 citaitons each, but clearly by definition 4 of 6 papers have at least 3 citations each. \\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Bro, H papers must have atleast H citations. So if U chose H to be 4 than 4 papers must have more than 4 citations.\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "This question is very logical and good application of __discrete binary search__. Why is this downvoted by so many??"
                    },
                    {
                        "username": "tanish34",
                        "content": "[@interpreter](/interpreter)  ig the reason its expecting 1 is because there is 1 research paper with atleast 1 citation(which can be 1 or more than 1)"
                    },
                    {
                        "username": "interpreter",
                        "content": "Because test case is wrong when people are submitting correct code its not expecting.\\n\\nInput as [100] should expect answer 0 because it doesn\\'t have 100 experiments with at least citation value 100. But it\\'s expecting 1.\\n\\nBecause of such test cases only 827 likes and 1.2k dislikes. I have already given feedback with details waiting for correction.\\n\\nThanks\\n"
                    },
                    {
                        "username": "mjmanoj",
                        "content": "exactly"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Too Confusing Got to Do it again.\\nConsumed Whole Day."
                    },
                    {
                        "username": "IRafael",
                        "content": "The funny thing is, if the first part is solved optimally, then to solve this one, you just need to remove the sorting of the initial array)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "hanzichi",
                        "content": "as title, nothing else to say..."
                    }
                ]
            },
            {
                "id": 1819578,
                "content": [
                    {
                        "username": "qjhdtc001",
                        "content": "apeuiofadfhfaoefwapfiejfoijfopdjfjopj"
                    },
                    {
                        "username": "teqarine",
                        "content": "yeah exactly! you got it right!\\n"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) yes"
                    },
                    {
                        "username": "jerryy147",
                        "content": "best comment i've seen on leetcode"
                    },
                    {
                        "username": "gary16",
                        "content": "*\"A scientist has index h if h of his/her N papers **have at least h citations** each, and ... ...\"*\\n\\ntest case: `citation = [1,2,3,5,8,9]` \\nresult: `h= 3`\\n\\nso by answer 3 of 6 papers have at least 3 citaitons each, but clearly by definition 4 of 6 papers have at least 3 citations each. \\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Bro, H papers must have atleast H citations. So if U chose H to be 4 than 4 papers must have more than 4 citations.\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "This question is very logical and good application of __discrete binary search__. Why is this downvoted by so many??"
                    },
                    {
                        "username": "tanish34",
                        "content": "[@interpreter](/interpreter)  ig the reason its expecting 1 is because there is 1 research paper with atleast 1 citation(which can be 1 or more than 1)"
                    },
                    {
                        "username": "interpreter",
                        "content": "Because test case is wrong when people are submitting correct code its not expecting.\\n\\nInput as [100] should expect answer 0 because it doesn\\'t have 100 experiments with at least citation value 100. But it\\'s expecting 1.\\n\\nBecause of such test cases only 827 likes and 1.2k dislikes. I have already given feedback with details waiting for correction.\\n\\nThanks\\n"
                    },
                    {
                        "username": "mjmanoj",
                        "content": "exactly"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Too Confusing Got to Do it again.\\nConsumed Whole Day."
                    },
                    {
                        "username": "IRafael",
                        "content": "The funny thing is, if the first part is solved optimally, then to solve this one, you just need to remove the sorting of the initial array)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "hanzichi",
                        "content": "as title, nothing else to say..."
                    }
                ]
            },
            {
                "id": 1910918,
                "content": [
                    {
                        "username": "qjhdtc001",
                        "content": "apeuiofadfhfaoefwapfiejfoijfopdjfjopj"
                    },
                    {
                        "username": "teqarine",
                        "content": "yeah exactly! you got it right!\\n"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) yes"
                    },
                    {
                        "username": "jerryy147",
                        "content": "best comment i've seen on leetcode"
                    },
                    {
                        "username": "gary16",
                        "content": "*\"A scientist has index h if h of his/her N papers **have at least h citations** each, and ... ...\"*\\n\\ntest case: `citation = [1,2,3,5,8,9]` \\nresult: `h= 3`\\n\\nso by answer 3 of 6 papers have at least 3 citaitons each, but clearly by definition 4 of 6 papers have at least 3 citations each. \\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Bro, H papers must have atleast H citations. So if U chose H to be 4 than 4 papers must have more than 4 citations.\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "This question is very logical and good application of __discrete binary search__. Why is this downvoted by so many??"
                    },
                    {
                        "username": "tanish34",
                        "content": "[@interpreter](/interpreter)  ig the reason its expecting 1 is because there is 1 research paper with atleast 1 citation(which can be 1 or more than 1)"
                    },
                    {
                        "username": "interpreter",
                        "content": "Because test case is wrong when people are submitting correct code its not expecting.\\n\\nInput as [100] should expect answer 0 because it doesn\\'t have 100 experiments with at least citation value 100. But it\\'s expecting 1.\\n\\nBecause of such test cases only 827 likes and 1.2k dislikes. I have already given feedback with details waiting for correction.\\n\\nThanks\\n"
                    },
                    {
                        "username": "mjmanoj",
                        "content": "exactly"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Too Confusing Got to Do it again.\\nConsumed Whole Day."
                    },
                    {
                        "username": "IRafael",
                        "content": "The funny thing is, if the first part is solved optimally, then to solve this one, you just need to remove the sorting of the initial array)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "hanzichi",
                        "content": "as title, nothing else to say..."
                    }
                ]
            },
            {
                "id": 1757558,
                "content": [
                    {
                        "username": "qjhdtc001",
                        "content": "apeuiofadfhfaoefwapfiejfoijfopdjfjopj"
                    },
                    {
                        "username": "teqarine",
                        "content": "yeah exactly! you got it right!\\n"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) yes"
                    },
                    {
                        "username": "jerryy147",
                        "content": "best comment i've seen on leetcode"
                    },
                    {
                        "username": "gary16",
                        "content": "*\"A scientist has index h if h of his/her N papers **have at least h citations** each, and ... ...\"*\\n\\ntest case: `citation = [1,2,3,5,8,9]` \\nresult: `h= 3`\\n\\nso by answer 3 of 6 papers have at least 3 citaitons each, but clearly by definition 4 of 6 papers have at least 3 citations each. \\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Bro, H papers must have atleast H citations. So if U chose H to be 4 than 4 papers must have more than 4 citations.\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "This question is very logical and good application of __discrete binary search__. Why is this downvoted by so many??"
                    },
                    {
                        "username": "tanish34",
                        "content": "[@interpreter](/interpreter)  ig the reason its expecting 1 is because there is 1 research paper with atleast 1 citation(which can be 1 or more than 1)"
                    },
                    {
                        "username": "interpreter",
                        "content": "Because test case is wrong when people are submitting correct code its not expecting.\\n\\nInput as [100] should expect answer 0 because it doesn\\'t have 100 experiments with at least citation value 100. But it\\'s expecting 1.\\n\\nBecause of such test cases only 827 likes and 1.2k dislikes. I have already given feedback with details waiting for correction.\\n\\nThanks\\n"
                    },
                    {
                        "username": "mjmanoj",
                        "content": "exactly"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Too Confusing Got to Do it again.\\nConsumed Whole Day."
                    },
                    {
                        "username": "IRafael",
                        "content": "The funny thing is, if the first part is solved optimally, then to solve this one, you just need to remove the sorting of the initial array)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "hanzichi",
                        "content": "as title, nothing else to say..."
                    }
                ]
            },
            {
                "id": 1571515,
                "content": [
                    {
                        "username": "qjhdtc001",
                        "content": "apeuiofadfhfaoefwapfiejfoijfopdjfjopj"
                    },
                    {
                        "username": "teqarine",
                        "content": "yeah exactly! you got it right!\\n"
                    },
                    {
                        "username": "yusufm09",
                        "content": "[@jerryy147](/jerryy147) yes"
                    },
                    {
                        "username": "jerryy147",
                        "content": "best comment i've seen on leetcode"
                    },
                    {
                        "username": "gary16",
                        "content": "*\"A scientist has index h if h of his/her N papers **have at least h citations** each, and ... ...\"*\\n\\ntest case: `citation = [1,2,3,5,8,9]` \\nresult: `h= 3`\\n\\nso by answer 3 of 6 papers have at least 3 citaitons each, but clearly by definition 4 of 6 papers have at least 3 citations each. \\n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "Bro, H papers must have atleast H citations. So if U chose H to be 4 than 4 papers must have more than 4 citations.\\n"
                    },
                    {
                        "username": "hardfault",
                        "content": "This question is very logical and good application of __discrete binary search__. Why is this downvoted by so many??"
                    },
                    {
                        "username": "tanish34",
                        "content": "[@interpreter](/interpreter)  ig the reason its expecting 1 is because there is 1 research paper with atleast 1 citation(which can be 1 or more than 1)"
                    },
                    {
                        "username": "interpreter",
                        "content": "Because test case is wrong when people are submitting correct code its not expecting.\\n\\nInput as [100] should expect answer 0 because it doesn\\'t have 100 experiments with at least citation value 100. But it\\'s expecting 1.\\n\\nBecause of such test cases only 827 likes and 1.2k dislikes. I have already given feedback with details waiting for correction.\\n\\nThanks\\n"
                    },
                    {
                        "username": "mjmanoj",
                        "content": "exactly"
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Too Confusing Got to Do it again.\\nConsumed Whole Day."
                    },
                    {
                        "username": "IRafael",
                        "content": "The funny thing is, if the first part is solved optimally, then to solve this one, you just need to remove the sorting of the initial array)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "hanzichi",
                        "content": "as title, nothing else to say..."
                    }
                ]
            }
        ]
    },
    {
        "title": "Guess Number Higher or Lower II",
        "question_content": "<p>We are playing the Guessing Game. The game will work as follows:</p>\n\n<ol>\n\t<li>I pick a number between&nbsp;<code>1</code>&nbsp;and&nbsp;<code>n</code>.</li>\n\t<li>You guess a number.</li>\n\t<li>If you guess the right number, <strong>you win the game</strong>.</li>\n\t<li>If you guess the wrong number, then I will tell you whether the number I picked is <strong>higher or lower</strong>, and you will continue guessing.</li>\n\t<li>Every time you guess a wrong number&nbsp;<code>x</code>, you will pay&nbsp;<code>x</code>&nbsp;dollars. If you run out of money, <strong>you lose the game</strong>.</li>\n</ol>\n\n<p>Given a particular&nbsp;<code>n</code>, return&nbsp;<em>the minimum amount of money you need to&nbsp;<strong>guarantee a win regardless of what number I pick</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/10/graph.png\" style=\"width: 505px; height: 388px;\" />\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 16\n<strong>Explanation:</strong> The winning strategy is as follows:\n- The range is [1,10]. Guess 7.\n&nbsp;   - If this is my number, your total is $0. Otherwise, you pay $7.\n&nbsp;   - If my number is higher, the range is [8,10]. Guess 9.\n&nbsp;       - If this is my number, your total is $7. Otherwise, you pay $9.\n&nbsp;       - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n&nbsp;       - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n&nbsp;   - If my number is lower, the range is [1,6]. Guess 3.\n&nbsp;       - If this is my number, your total is $7. Otherwise, you pay $3.\n&nbsp;       - If my number is higher, the range is [4,6]. Guess 5.\n&nbsp;           - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n&nbsp;           - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n&nbsp;           - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n&nbsp;       - If my number is lower, the range is [1,2]. Guess 1.\n&nbsp;           - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n&nbsp;           - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>&nbsp;There is only one possible number, so you can guess 1 and not have to pay anything.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>&nbsp;There are two possible numbers, 1 and 2.\n- Guess 1.\n&nbsp;   - If this is my number, your total is $0. Otherwise, you pay $1.\n&nbsp;   - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 84764,
                "title": "simple-dp-solution-with-explanation",
                "content": "For each number x in range[i~j]\\nwe do:  result_when_pick_x = x + **max**{DP([i~x-1]),  DP([x+1, j])}    \\n                 --> *// the max means whenever you choose a number, the feedback is always bad and therefore leads you to a worse branch.*\\nthen we get  DP([i~j]) = **min**{xi, ... ,xj}    \\n                 --> *// this min makes sure that you are minimizing your cost.*\\n\\n```\\npublic class Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] table = new int[n+1][n+1];\\n        return DP(table, 1, n);\\n    }\\n    \\n    int DP(int[][] t, int s, int e){\\n        if(s >= e) return 0;\\n        if(t[s][e] != 0) return t[s][e];\\n        int res = Integer.MAX_VALUE;\\n        for(int x=s; x<=e; x++){\\n            int tmp = x + Math.max(DP(t, s, x-1), DP(t, x+1, e));\\n            res = Math.min(res, tmp);\\n        }\\n        t[s][e] = res;\\n        return res;\\n    }\\n}\\n```\\n\\nHere is a bottom up solution.\\n\\n```\\npublic class Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] table = new int[n+1][n+1];\\n        for(int j=2; j<=n; j++){\\n            for(int i=j-1; i>0; i--){\\n                int globalMin = Integer.MAX_VALUE;\\n                for(int k=i+1; k<j; k++){\\n                    int localMax = k + Math.max(table[i][k-1], table[k+1][j]);\\n                    globalMin = Math.min(globalMin, localMax);\\n                }\\n                table[i][j] = i+1==j?i:globalMin;\\n            }\\n        }\\n        return table[1][n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] table = new int[n+1][n+1];\\n        return DP(table, 1, n);\\n    }\\n    \\n    int DP(int[][] t, int s, int e){\\n        if(s >= e) return 0;\\n        if(t[s][e] != 0) return t[s][e];\\n        int res = Integer.MAX_VALUE;\\n        for(int x=s; x<=e; x++){\\n            int tmp = x + Math.max(DP(t, s, x-1), DP(t, x+1, e));\\n            res = Math.min(res, tmp);\\n        }\\n        t[s][e] = res;\\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] table = new int[n+1][n+1];\\n        for(int j=2; j<=n; j++){\\n            for(int i=j-1; i>0; i--){\\n                int globalMin = Integer.MAX_VALUE;\\n                for(int k=i+1; k<j; k++){\\n                    int localMax = k + Math.max(table[i][k-1], table[k+1][j]);\\n                    globalMin = Math.min(globalMin, localMax);\\n                }\\n                table[i][j] = i+1==j?i:globalMin;\\n            }\\n        }\\n        return table[1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84766,
                "title": "clarification-on-the-problem-description-problem-description-need-to-be-updated",
                "content": "It is actually confusing that the example shown in the problem description is not the best stragety to guess the final target number, and the problem itself is asking for the lowest cost achieved by best guessing strategy.\\nThe example description should be updated.\\n\\n\\n```---POSSIBLY, it can also add some example about the BEST Strategy---```\\nThe example description should be:\\n\\nfirst introducebest strategyto guess:\\n\\n1. ```for one number```, like 1, best strategy is 0$\\n2. ```for two number```, like 3,4, best strategy is 3$, which can be understood in this way: you have two way to guess: a) start by guess 4 is the target, (the worst case is) if wrong, you get charged $4, then immediately you know 3 is the target number, get get charged $0 by guessing that, and finally you get charged $4. b) similarly, if you start by 3, (the worst case is) if wrong, you get charged $3, then you immediately know that 4 is the target number, and get charged $0 for guessing this, and finally you get charged $3. In summary:\\nrange ---------> best strategy cost\\n3, 4 ---------> $3\\n5, 6 ---------> $5\\n...\\n3. ```for three number```, the best strategy is guess the middle number first, and (worst case is) if wrong, you get charged that middle number money, and then you immediately know what target number is by using \"lower\" or \"higher\" response, so in summary:\\nrange ---------> best strategy cost\\n3, 4, 5 ---------> $4\\n7, 8, 9 ---------> $8\\n...\\n4. ```for more numbers```, it can simply be reduced them into smaller ranges, and here is why DP solution make more sense in solving this.\\nsuppose the range is [start, end]\\nthe strategy here is to iterate through all number possible and select it as the starting point, say for any k between start and end, the worst cost for this is: k+DP( start, k-1 ) + DP(k+1, end ), and the goal is minimize the cost, so you need the minimum one among all those k between start and end",
                "solutionTags": [],
                "code": "```---POSSIBLY, it can also add some example about the BEST Strategy---```\n```for one number```\n```for two number```\n```for three number```\n```for more numbers```",
                "codeTag": "Unknown"
            },
            {
                "id": 748271,
                "title": "c-dp-solution-w-detailed-explanation",
                "content": "The problem tells us \"Every time you guess wrong, I\\'ll tell you whether the number I picked is higher or lower.\" This means our target number is within `[1,n]` and guessing incorrectly number `x` will tell us that our target is either between `[1,x)` OR `(x,n]`. In turn our answer to guaranteeing a win between `[1,n]`  is equal to our solution to guaranteeing a win between `[1,x)` OR `(x,n]` plus the cost of guessing `x` incorrectly. Through this we should see that the each incorrect guess breaks down into our original problem just with different bounds. Since the problem also asks us to \"find out how much money you need to have to guarantee a win\" we need to assume the worst case scenario, if guaranteeing a win between `[1,x)` cost more than that of `(x,n]` then we assume the former. If you have an idea on how to approach the problem you should stop reading and try it out for yourself. \\n\\n1. This problem is a classic [merging intervals](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#Merging-Intervalshttp://) problem. To do this we initialize a 2D vector/array where the rows represent the beginning of a range (inclusive) and the columns represent its end (exclusive). For example, dp[0][3] represents the indices `[0,2]`  and for our problem the numbers `[1,3]`. Since the range is exlusive at the end we initialize the vector to be of size `n` by `n+1`.\\n\\n```\\nvector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n```\\n\\n2.  We take a bottom-up approach to this problem as before answering dp[0][3] we answer dp[0][2] \\n```\\nfor(int len=2; len<=n; ++len){\\n\\tfor(int begin=0; begin<=n-len; ++begin){\\n\\t\\tint end = begin + len;\\n\\t\\t//...\\n        }\\n     }\\n```\\n\\n3. To find the minimum money necessary between a given range we use our earlier idea from the intro. We iterate through all possible guesses between our given range and choose the guess that is expected to cost us the least while expecting the worst possible outcome. Combine this with `2)` and we have our solution. \\n```\\nfor(int i=begin; i<end; ++i){\\n\\tint numPicked = i+1;\\n\\tif(i == begin){\\n\\t\\tdp[begin][end] = numPicked + dp[begin+1][end];\\n\\t} else {\\n\\t\\tdp[begin][end] = min(dp[begin][end], max(dp[begin][i], dp[i+1][end]) + numPicked);\\n\\t}\\n```\\n4. **To illustrate the process**\\n\\nlen = 2\\n* dp[0][2] = 1 `(Given the range was between 1 and 2 (inclusive) the worst case scenario, while minimizing costs, is to guess 1 incorrectly and then choose 2 without penalty)` or `1 + dp[2][2] ` \\n* dp[1][3] = 2\\n* ...\\n* dp[n-2][n] =n-1\\n\\nlen  = 3\\n* dp[0][3] = 2` (Given the range was between 1 and 3 we could guess 2 and then our next guess is guarenteed to be correct)`  \\n* dp[1][4] = 3\\n* ...\\n\\nlen = 4\\n* dp[0][4] = 4 `Given the range was between 1 and 4 we guess 1 and then guess 3 then our next guess will guarentee our answer.` \\n Here I would like to illustrate that the solution doesn\\'t rely on binary search to minimize the cost. Using binary,  our guess would begin at `2` followed by `3` (assuming the worst case scenario `target = 4`). A binary search was what I initially thought of, but this clearly disproves the approach.\\n \\n5) **Full Solution** (please don\\'t copy pasta the solution without reading the post!)\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        for(int len=2; len<=n; ++len){\\n            for(int begin=0; begin<=n-len; ++begin){\\n                \\n                int end = begin + len;\\n                for(int i=begin; i<end; ++i){\\n                    int numPicked = i+1;\\n                    if(i == begin){\\n                        dp[begin][end] = numPicked + dp[begin+1][end];\\n                    } else {\\n                        dp[begin][end] = min(dp[begin][end], max(dp[begin][i], dp[i+1][end]) + numPicked);\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return dp[0][n];\\n    }\\n};\\n```\\n6) Useful [post](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns) for those starting out with DP\\n7) Don\\'t forget to upvote if this post helped you :)\\n\\t...if it didn\\'t please don\\'t downvote... I\\'m sorry I\\'ll do anything!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n```\n```\\nfor(int len=2; len<=n; ++len){\\n\\tfor(int begin=0; begin<=n-len; ++begin){\\n\\t\\tint end = begin + len;\\n\\t\\t//...\\n        }\\n     }\\n```\n```\\nfor(int i=begin; i<end; ++i){\\n\\tint numPicked = i+1;\\n\\tif(i == begin){\\n\\t\\tdp[begin][end] = numPicked + dp[begin+1][end];\\n\\t} else {\\n\\t\\tdp[begin][end] = min(dp[begin][end], max(dp[begin][i], dp[i+1][end]) + numPicked);\\n\\t}\\n```\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        for(int len=2; len<=n; ++len){\\n            for(int begin=0; begin<=n-len; ++begin){\\n                \\n                int end = begin + len;\\n                for(int i=begin; i<end; ++i){\\n                    int numPicked = i+1;\\n                    if(i == begin){\\n                        dp[begin][end] = numPicked + dp[begin+1][end];\\n                    } else {\\n                        dp[begin][end] = min(dp[begin][end], max(dp[begin][i], dp[i+1][end]) + numPicked);\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return dp[0][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84787,
                "title": "java-dp-solution",
                "content": "Definition of ```dp[i][j]```: minimum number of money to guarantee win for subproblem ```[i, j]```.\\n\\nTarget: ```dp[1][n]```\\n\\nCorner case: ```dp[i][i] = 0``` (because the only element must be correct)\\n\\nEquation: we can choose ```k (i<=k<=j)``` as our guess, and pay price ```k```. After our guess, the problem is divided into two subproblems. Notice we do not need to pay the money for both subproblems. We only need to pay the worst case (because the system will tell us which side we should go) to guarantee win. So ```dp[i][j] = min (i<=k<=j) { k + max(dp[i][k-1], dp[k+1][j]) }```\\n\\n```\\npublic class Solution {\\n    public int getMoneyAmount(int n) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int jminusi = 1; jminusi < n; jminusi++) {\\n            for (int i = 0; i + jminusi <= n; i++) {\\n                int j = i + jminusi;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = i; k <= j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j],\\n                                        k + Math.max(k - 1 >= i ? dp[i][k - 1] : 0,\\n                                                     j >= k + 1 ? dp[k + 1][j] : 0));\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```dp[i][j]```\n```[i, j]```\n```dp[1][n]```\n```dp[i][i] = 0```\n```k (i<=k<=j)```\n```k```\n```dp[i][j] = min (i<=k<=j) { k + max(dp[i][k-1], dp[k+1][j]) }```\n```\\npublic class Solution {\\n    public int getMoneyAmount(int n) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int jminusi = 1; jminusi < n; jminusi++) {\\n            for (int i = 0; i + jminusi <= n; i++) {\\n                int j = i + jminusi;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = i; k <= j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j],\\n                                        k + Math.max(k - 1 >= i ? dp[i][k - 1] : 0,\\n                                                     j >= k + 1 ? dp[k + 1][j] : 0));\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84778,
                "title": "recursion-memization",
                "content": "Let's take an instance, for n = 3, we have 3 choices either to choose 1 or 2 or 3.\\nLet's say we choose 1. There are 2 possible chances,\\n* [Case X]: 1 is the actual number so you pay 0$ or,\\n* [Case Y]: 1 is not the actual number so you pay 1$ (now you know that the actual number is > 1 because for every guess we will know if its less than or greater than, in our case it can only be greater than) and have the subproblem (2, 3). To choose from (2, 3) again recursively applying the same method, you can choose either 2 or 3. If you pick 2, you have 2 possible outcomes again. 2 is the actual number and you pay 0$ for this choice or 2 is not the actual number and you pay 2$ for this choice and you know 3 is the answer since that's the only one left. On the other hand, if you had picked 3, then either 3 is correct or you pay 3$ and know 2 is the actual answer since it's the only one left. So to sum up this, you pay 2$ in the worst case if you choose 2 or pay 3$ in the worst case if you pick 3$. So we will pick the min of the worst cases which is 2$ and hence 2 is the answer for (2, 3) subproblem. (Notice the minimax? ;) ) So, the total cost paid in this is 1$ + 2$ = 3$.\\n\\nLet's say you picked 2 initially. You have 2 possible outcomes.\\n* 2 is the actual number and you pay 0$ or,\\n* 2 is not the actual number and you pay 2$. At this point, you get to know if the actual number is less than or greater than the actual number. So, you will know the answer right away without another guess. So you end up paying 2$.\\nSo, if you choose 2 initially, you risk paying 2$ at most.\\nSimilarly, if you had chosen 3 initially, you risk paying 4$ at most. Hence picking 2 initially is the best option and you risk at most 2$.\\n\\nThis leads to a natural recursion, which you can find in the code below. I have memoized it in a matrix.\\n\\n```\\npublic class Solution {\\n    int[][] dp;\\n    public int solve(int l, int r){\\n        if(l >= r) return 0;\\n        if(dp[l][r] != Integer.MAX_VALUE) return dp[l][r];\\n        for(int i = l; i <= r; i++){\\n            dp[l][r] = Math.min(dp[l][r], Math.max(i + solve(l, i-1), i + solve(i+1, r)));\\n        }\\n        return dp[l][r];\\n    }\\n    public int getMoneyAmount(int n) {\\n        dp = new int[n+1][n+1];\\n        for(int[] row: dp){\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        return solve(1, n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\npublic class Solution {\\n    int[][] dp;\\n    public int solve(int l, int r){\\n        if(l >= r) return 0;\\n        if(dp[l][r] != Integer.MAX_VALUE) return dp[l][r];\\n        for(int i = l; i <= r; i++){\\n            dp[l][r] = Math.min(dp[l][r], Math.max(i + solve(l, i-1), i + solve(i+1, r)));\\n        }\\n        return dp[l][r];\\n    }\\n    public int getMoneyAmount(int n) {\\n        dp = new int[n+1][n+1];\\n        for(int[] row: dp){\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        return solve(1, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84826,
                "title": "an-o-n-2-dp-solution-quite-hard",
                "content": "Algorithm description: http://artofproblemsolving.com/community/c296841h1273742\\n\\n\\n```\\n#include <vector>\\n#include <deque>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> u(n + 2, vector<int>(n + 2));\\n        for (int b = 2; b <= n; ++b) {\\n            int k0 = b - 1;\\n            deque<pair<int, int>> v;\\n            for (int a = b - 1; a; --a) {\\n                while (u[a][k0 - 1] > u[k0 + 1][b]) {\\n                    if (!v.empty() && v.front().second == k0) v.pop_front();\\n                    --k0;\\n                }\\n                int vn = a + u[a + 1][b];\\n                while (!v.empty() && vn < v.back().first) v.pop_back();\\n                v.emplace_back(vn, a);\\n                int u1 = u[a][k0] + k0 + 1;\\n                int u2 = v.front().first;\\n                u[a][b] = u1 < u2 ? u1 : u2;\\n            }\\n        }\\n        return u[1][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <deque>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> u(n + 2, vector<int>(n + 2));\\n        for (int b = 2; b <= n; ++b) {\\n            int k0 = b - 1;\\n            deque<pair<int, int>> v;\\n            for (int a = b - 1; a; --a) {\\n                while (u[a][k0 - 1] > u[k0 + 1][b]) {\\n                    if (!v.empty() && v.front().second == k0) v.pop_front();\\n                    --k0;\\n                }\\n                int vn = a + u[a + 1][b];\\n                while (!v.empty() && vn < v.back().first) v.pop_back();\\n                v.emplace_back(vn, a);\\n                int u1 = u[a][k0] + k0 + 1;\\n                int u2 = v.front().first;\\n                u[a][b] = u1 < u2 ? u1 : u2;\\n            }\\n        }\\n        return u[1][n];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 84769,
                "title": "two-python-solutions",
                "content": "To find out how much money I need to win the range lo..hi (the game starts with the range 1..n), I try each possible x in the range (except hi, which is pointless because hi-1 costs less and provides more information), calculate how much I need when using that x, and take the minimum of those amounts.\\n\\nBottom-up dynamic programming:\\n\\n    def getMoneyAmount(self, n):\\n        need = [[0] * (n+1) for _ in range(n+1)]\\n        for lo in range(n, 0, -1):\\n            for hi in range(lo+1, n+1):\\n                need[lo][hi] = min(x + max(need[lo][x-1], need[x+1][hi])\\n                                   for x in range(lo, hi))\\n        return need[1][n]\\n\\nTop-down with memoization, subclassing `dict` for convenience. Simpler than bottom-up because I don't need to specify ranges/loops for `lo` and `hi` and don't need to think about their orders and how big my DP matrix needs to be. On the other hand, it's slower.\\n\\n    def getMoneyAmount(self, n):\\n        class Need(dict):\\n            def __missing__(self, (lo, hi)):\\n                if lo >= hi:\\n                    return 0\\n                ret = self[lo, hi] = min(x + max(self[lo, x-1], self[x+1, hi])\\n                                         for x in range(lo, hi))\\n                return ret\\n        return Need()[1, n]\\n\\nGot the motivation to use tuples as indexes from @agave. I had used that myself sometimes in the past, but thought it would be very slow. Turns out it's not that slow. I should do some timings to get a better feeling for it...",
                "solutionTags": [
                    "Python"
                ],
                "code": "To find out how much money I need to win the range lo..hi (the game starts with the range 1..n), I try each possible x in the range (except hi, which is pointless because hi-1 costs less and provides more information), calculate how much I need when using that x, and take the minimum of those amounts.\\n\\nBottom-up dynamic programming:\\n\\n    def getMoneyAmount(self, n):\\n        need = [[0] * (n+1) for _ in range(n+1)]\\n        for lo in range(n, 0, -1):\\n            for hi in range(lo+1, n+1):\\n                need[lo][hi] = min(x + max(need[lo][x-1], need[x+1][hi])\\n                                   for x in range(lo, hi))\\n        return need[1][n]\\n\\nTop-down with memoization, subclassing `dict` for convenience. Simpler than bottom-up because I don't need to specify ranges/loops for `lo` and `hi` and don't need to think about their orders and how big my DP matrix needs to be. On the other hand, it's slower.\\n\\n    def getMoneyAmount(self, n):\\n        class Need(dict):\\n            def __missing__(self, (lo, hi)):\\n                if lo >= hi:\\n                    return 0\\n                ret = self[lo, hi] = min(x + max(self[lo, x-1], self[x+1, hi])\\n                                         for x in range(lo, hi))\\n                return ret\\n        return Need()[1, n]\\n\\nGot the motivation to use tuples as indexes from @agave. I had used that myself sometimes in the past, but thought it would be very slow. Turns out it's not that slow. I should do some timings to get a better feeling for it...",
                "codeTag": "Java"
            },
            {
                "id": 1356393,
                "title": "python-top-down-dp-bottom-up-dp-clean-concise-code-explained",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP**\\n```python\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dp(left, right):\\n            if left >= right:\\n                return 0\\n            ans = math.inf\\n            for pick in range(left, right + 1):\\n                leftCost = dp(left, pick - 1) + pick  # Cost on the left side, if pivot is not a secret number\\n                rightCost = dp(pick + 1, right) + pick  # Cost on the right side, if pivot is not a secret number\\n                cost = max(leftCost, rightCost)  # The cost is the maximum between the left side and the right side\\n                ans = min(ans, cost)  # Choose pivot which will cause minimum cost\\n            return ans\\n\\n        return dp(1, n)\\n```\\nComplexity:\\n- Time: `O(N^3)`\\n- Space: `O(N^2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bottom up DP**\\n```python\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\\n        for l in range(n, 0, -1):\\n            for r in range(l + 1, n + 1):\\n                dp[l][r] = math.inf\\n                for pick in range(l, r + 1):\\n                    leftCost = dp[l][pick - 1] + pick  # Cost on the left side, if pivot is not a secret number\\n                    rightCost = dp[pick + 1][r] + pick  # Cost on the right side, if pivot is not a secret number\\n                    cost = max(leftCost, rightCost)  # The cost is the maximum between the left side and the right side\\n                    dp[l][r] = min(dp[l][r], cost)  # Choose pivot which will cause minimum cost\\n\\n        return dp[1][n]\\n```\\nComplexity:\\n- Time: `O(N^3)`\\n- Space: `O(N^2)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dp(left, right):\\n            if left >= right:\\n                return 0\\n            ans = math.inf\\n            for pick in range(left, right + 1):\\n                leftCost = dp(left, pick - 1) + pick  # Cost on the left side, if pivot is not a secret number\\n                rightCost = dp(pick + 1, right) + pick  # Cost on the right side, if pivot is not a secret number\\n                cost = max(leftCost, rightCost)  # The cost is the maximum between the left side and the right side\\n                ans = min(ans, cost)  # Choose pivot which will cause minimum cost\\n            return ans\\n\\n        return dp(1, n)\\n```\n```python\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\\n        for l in range(n, 0, -1):\\n            for r in range(l + 1, n + 1):\\n                dp[l][r] = math.inf\\n                for pick in range(l, r + 1):\\n                    leftCost = dp[l][pick - 1] + pick  # Cost on the left side, if pivot is not a secret number\\n                    rightCost = dp[pick + 1][r] + pick  # Cost on the right side, if pivot is not a secret number\\n                    cost = max(leftCost, rightCost)  # The cost is the maximum between the left side and the right side\\n                    dp[l][r] = min(dp[l][r], cost)  # Choose pivot which will cause minimum cost\\n\\n        return dp[1][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84807,
                "title": "java-commented-dp-solution",
                "content": "***Big Idea: Given any n, we make a guess k. Then we break the interval [1,n] into [1,k - 1] and [k + 1,n]. The min of worst case cost can be calculated recursively as***\\n\\n***cost[1,n] = k + max{cost[1,k - 1] + cost[k+1,n]}***\\nAlso, it takes a while for me to wrap my head around \"min of max cost\". My understand is that: you strategy is the best, but your luck is the worst. You only guess right when there is no possibilities to guess wrong.\\n```Java\\npublic class Solution {\\n    public int getMoneyAmount(int n) {\\n        // all intervals are inclusive\\n        // uninitialized cells are assured to be zero\\n        // the zero column and row will be uninitialized\\n        // the illegal cells will also be uninitialized\\n        // add 1 to the length just to make the index the same as numbers used\\n        int[][] dp = new int[n + 1][n + 1]; // dp[i][j] means the min cost in the worst case for numbers (i...j)\\n\\n        // iterate the lengths of the intervals since the calculations of longer intervals rely on shorter ones\\n        for (int l = 2; l <= n; l++) {\\n            // iterate all the intervals with length l, the start of which is i. Hence the interval will be [i, i + (l - 1)]\\n            for (int i = 1; i <= n - (l - 1); i++) {\\n                dp[i][i + (l - 1)] = Integer.MAX_VALUE;\\n                // iterate all the first guesses g\\n                for (int g = i; g <= i + (l - 1); g++) {\\n                    int costForThisGuess;\\n                    // since if g is the last integer, g + 1 does not exist, we have to separate this case\\n                    // cost for [i, i + (l - 1)]: g (first guess) + max{the cost of left part [i, g - 1], the cost of right part [g + 1, i + (l - 1)]}\\n                    if (g == n) {\\n                        costForThisGuess = dp[i][g - 1] + g;\\n                    } else {\\n                        costForThisGuess = g + Math.max(dp[i][g - 1], dp[g + 1][i + (l - 1)]);\\n                    }\\n                    dp[i][i + (l - 1)] = Math.min(dp[i][i + (l - 1)], costForThisGuess); // keep track of the min cost among all first guesses\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```\\nAny questions, suggestions & criticism welcomed!",
                "solutionTags": [],
                "code": "```Java\\npublic class Solution {\\n    public int getMoneyAmount(int n) {\\n        // all intervals are inclusive\\n        // uninitialized cells are assured to be zero\\n        // the zero column and row will be uninitialized\\n        // the illegal cells will also be uninitialized\\n        // add 1 to the length just to make the index the same as numbers used\\n        int[][] dp = new int[n + 1][n + 1]; // dp[i][j] means the min cost in the worst case for numbers (i...j)\\n\\n        // iterate the lengths of the intervals since the calculations of longer intervals rely on shorter ones\\n        for (int l = 2; l <= n; l++) {\\n            // iterate all the intervals with length l, the start of which is i. Hence the interval will be [i, i + (l - 1)]\\n            for (int i = 1; i <= n - (l - 1); i++) {\\n                dp[i][i + (l - 1)] = Integer.MAX_VALUE;\\n                // iterate all the first guesses g\\n                for (int g = i; g <= i + (l - 1); g++) {\\n                    int costForThisGuess;\\n                    // since if g is the last integer, g + 1 does not exist, we have to separate this case\\n                    // cost for [i, i + (l - 1)]: g (first guess) + max{the cost of left part [i, g - 1], the cost of right part [g + 1, i + (l - 1)]}\\n                    if (g == n) {\\n                        costForThisGuess = dp[i][g - 1] + g;\\n                    } else {\\n                        costForThisGuess = g + Math.max(dp[i][g - 1], dp[g + 1][i + (l - 1)]);\\n                    }\\n                    dp[i][i + (l - 1)] = Math.min(dp[i][i + (l - 1)], costForThisGuess); // keep track of the min cost among all first guesses\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510747,
                "title": "python-dp-beat-97-52-in-time-99-in-memory-with-explanation",
                "content": "**Appreciate if you could upvote this solution**\\n\\nCase 1: `n is odd`\\nSelected nums = [2, 4, 6, ..., n-1]\\n\\nCase 2: `n is even`\\nSelected nums = [1, 3, 5, ..., n-1]\\n\\nThe basic idea is that if we want to guess the right number, the maximum number of guessing time should be k = floor(n/2) which means we can find out the right number just using the k nums.\\n\\nFor example, \\nWhen n = 5,  k = floor(5/2) = 2\\nwe can find out the right number by guessing 2 and 4 as 2 can classify [1, 2, 3] and 4 and classify [3, 4, 5]\\n```\\n1  2  3  4  5\\n   2     4\\n```\\nWhen n = 6,  k = floor(6/2) = 3\\nwe can find out the right number by guessing 1,  3 and 5 as they can classify [1, 2], [2, 3, 4] and [4, 5, 6] respectively \\n```\\n1  2  3  4  5  6\\n1     3     5\\n```\\n\\nThus, we can use the selected nums to find out the minimum amount of money and the execution time will be reduced by half.\\nIn the dp matrix, the row means the starting index and the col means the ending index.\\nAt the beginning, the dp[i][i] is assignmed as selected_nums[i] because selected_nums[i] is the smallest cost to classify the nums in [selected_nums[i] - 1, selected_nums[i], selected_nums[i] + 1].\\nAfter the initialization, the problem will become an easy dp question, just finding the optimal solution from length 2 to length k.\\n\\n```python\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        starting_index = 1 if n % 2 == 0 else 2\\n        selected_nums = [i for i in range(starting_index, n, 2)]\\n        selected_nums_length = len(selected_nums)\\n        dp = [[0] * selected_nums_length for _ in range(selected_nums_length)]\\n\\n        for i in range(selected_nums_length):\\n            dp[i][i] = selected_nums[i]\\n\\n        for length in range(2, selected_nums_length + 1):\\n            for i in range(selected_nums_length - length + 1):\\n                j = i + length - 1\\n                dp[i][j] = float(\"inf\")\\n                for k in range(i, j + 1):\\n                    dp_left = dp[i][k - 1] if k != 0 else 0\\n                    dp_right = dp[k + 1][j] if k != j else 0\\n                    dp[i][j] = min(dp[i][j], selected_nums[k] + max(dp_left, dp_right))\\n\\n        return dp[0][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n1  2  3  4  5\\n   2     4\\n```\n```\\n1  2  3  4  5  6\\n1     3     5\\n```\n```python\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        starting_index = 1 if n % 2 == 0 else 2\\n        selected_nums = [i for i in range(starting_index, n, 2)]\\n        selected_nums_length = len(selected_nums)\\n        dp = [[0] * selected_nums_length for _ in range(selected_nums_length)]\\n\\n        for i in range(selected_nums_length):\\n            dp[i][i] = selected_nums[i]\\n\\n        for length in range(2, selected_nums_length + 1):\\n            for i in range(selected_nums_length - length + 1):\\n                j = i + length - 1\\n                dp[i][j] = float(\"inf\")\\n                for k in range(i, j + 1):\\n                    dp_left = dp[i][k - 1] if k != 0 else 0\\n                    dp_right = dp[k + 1][j] if k != j else 0\\n                    dp[i][j] = min(dp[i][j], selected_nums[k] + max(dp_left, dp_right))\\n\\n        return dp[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278098,
                "title": "java-solution-minimax-explained",
                "content": "**Idea**\\nFirstly, we should note that choosing `mid` is not always the best strategy. Becuase of the \"penalty\" on each guess. For exmple `[1,2,3,4,5]`, with `mid` strategy we pay $3+$4 = $7 in the worst case (i.e target=5). But we can do it in `$2+$4=$6` for all possible targets.\\n\\nHad all guesses carry the same cost, choosing `mid` at every subproblem will always yield the minimum number of guesses required.\\n\\nSo our goal is try all possible guesses at every stage and choose the minimum. But remember every time we guess, we are diving the search space, `[i..j]`, into two parts, the target could be anywhere (obvioulsy except our current guess). So we solve each part with the assumption that target could be anywhere and see the cost at each possible `k` in `[i..j]`. We take the max cost out of two parts because `target` could be anywhere and we need to cover the cost for that. (i.e. If we take minimum say that is from left part, what if the target is in right part).\\n\\n```\\npublic int getMoneyAmount(int n) {\\n        Integer[][] dp = new Integer[n+1][n+1];\\n        return miniMax(1, n, dp);\\n    }\\n    private int miniMax(int i, int j, Integer[][] dp){\\n        if(i >= j)\\n            return 0;\\n        if(dp[i][j] != null)\\n            return dp[i][j];\\n        dp[i][j] = Integer.MAX_VALUE;\\n        for(int k=i; k <= j; k++)\\n            dp[i][j] = Math.min(dp[i][j], Math.max(miniMax(i, k-1, dp), miniMax(k+1, j, dp))+k);\\n        return dp[i][j];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMoneyAmount(int n) {\\n        Integer[][] dp = new Integer[n+1][n+1];\\n        return miniMax(1, n, dp);\\n    }\\n    private int miniMax(int i, int j, Integer[][] dp){\\n        if(i >= j)\\n            return 0;\\n        if(dp[i][j] != null)\\n            return dp[i][j];\\n        dp[i][j] = Integer.MAX_VALUE;\\n        for(int k=i; k <= j; k++)\\n            dp[i][j] = Math.min(dp[i][j], Math.max(miniMax(i, k-1, dp), miniMax(k+1, j, dp))+k);\\n        return dp[i][j];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 84788,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Guess Number Higher or Lower II** https://leetcode.com/problems/guess-number-higher-or-lower-ii/\\n\\n* The key idea in this problem is that given any n, we make a guess for k. Then we break the interval [1,n] into [1,k-1] and [k+1,n]. The minimum of the worst case cost can be calculated recursively as: cost[1,n] = k + max{cost[1,k - 1] + cost[k+1,n]}.\\n```\\n        for k in range(lo, hi+1):\\n            cache[lo][hi] = min(cache[lo][hi], max(self.cost(lo, k-1, cache), self.cost(k+1, hi, cache))+k)\\n```\\n* Using the above key idea, we realize that this problem can be parameterized by lo and hi. When lo = hi, the cost is 0 since we can make just a single guess which will be correct. The case hi < lo will be an invalid case and hence we return zero for that as well.\\n* https://discuss.leetcode.com/topic/51494/java-commented-dp-solution\\n\\n```\\nclass Solution(object):\\n    def cost(self, lo, hi, cache):\\n        if hi <= lo:\\n            return 0\\n        if cache[lo][hi] != float('inf'):\\n            return cache[lo][hi]\\n        for k in range(lo, hi+1):\\n            cache[lo][hi] = min(cache[lo][hi], max(self.cost(lo, k-1, cache), self.cost(k+1, hi, cache))+k)\\n        return cache[lo][hi]\\n    \\n    def getMoneyAmount(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        cache = [[float('inf')]*(n+1) for _ in range(n+1)]\\n        return self.cost(1, n, cache)\\n```\\n\\n**Expected Loss**\\n* p: Probability that k is the right choice = 1/(hi-lo+1)\\n* 1-p: Probability that k is not the right choice = (hi-lo)/(hi-lo+1)\\n\\n* cost[lo, hi] = min(p*cost_success(k) + (1-p)*cost_failure(k)) where k is between [lo, hi]\\n* Now cost_success(k) = 0. When we have a failure, the answer can lie between [lo, k-1] with probability p_1ower or [k+1, hi] with probability p_higher. p_1ower = (k-lo)/(hi-lo+1) and p_higher = (hi-k)/(hi-lo+1).\\n* cost_failure(k) = (cost[lo,k - 1] + k)*p_1ower + (cost[k+1,hi] + k)*p_higher\\n\\n* cost[lo, hi] = min((1-p)*((cost[lo,k - 1] + k)*((k-lo)/(hi-lo+1)) + (cost[k+1,hi] + k)*((hi-k)/(hi-lo+1)))) where k is between [lo, hi]",
                "solutionTags": [],
                "code": "```\\n        for k in range(lo, hi+1):\\n            cache[lo][hi] = min(cache[lo][hi], max(self.cost(lo, k-1, cache), self.cost(k+1, hi, cache))+k)\\n```\n```\\nclass Solution(object):\\n    def cost(self, lo, hi, cache):\\n        if hi <= lo:\\n            return 0\\n        if cache[lo][hi] != float('inf'):\\n            return cache[lo][hi]\\n        for k in range(lo, hi+1):\\n            cache[lo][hi] = min(cache[lo][hi], max(self.cost(lo, k-1, cache), self.cost(k+1, hi, cache))+k)\\n        return cache[lo][hi]\\n    \\n    def getMoneyAmount(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        cache = [[float('inf')]*(n+1) for _ in range(n+1)]\\n        return self.cost(1, n, cache)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284589,
                "title": "a-template-i-use-for-all-the-minmax-problem",
                "content": "After solving all the minmax problems in leetcode, I found this template is very usefule to solve most of [them](https://leetcode.com/problemset/all/?topicSlugs=minimax).\\n\\nI got the template from this [video](https://www.youtube.com/watch?v=l-hh51ncgDI).\\n\\nIn order to understand the template, there are several things you should know:\\n1. The solution is trying to find all the possible result that could happen, and return only the desired result, which usually is the best result the first player can get.\\n2. The solution mainly aims at solving two player game. So it involves the perspective of both players. As the first player, if I want to win, I need to take the actions which gain me most advantage/ minimum cost(the min part in min-max). But as the second player, I want to take action which damage the first player the most, which equally means maximum cost to the first player(the max part in min-max).\\n\\nSo here is the template:\\n```\\nfunction minMax(Any currentState, boolean isFirstPlayer) {\\n\\tif the game end or run out move\\n\\t\\treturn static evaluation;\\n\\t\\n\\tif(isFirstPlayer) {\\n\\t\\tmax = -infinity;\\n\\t\\tfor any possible move {\\n\\t\\t\\tmax = Math.max(max, minMax(nextState, false) // now is the second player\\'s turn\\n\\t\\t}\\n\\t\\treturn max;\\n\\t} else  {  // second layer\\n\\t\\tmin = +infinity;\\n\\t\\tfor any possible move {\\n\\t\\t\\tmin = Math.min(min, minMax(nextState, true);// now is the first player\\'s turn;\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n}\\n```\\n\\nSo there is the code to solve the problem with above template:\\n```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        return minMax(1, n, -1, true);\\n    }\\n    \\n\\t// picked is only for player two\\n    private int minMax(int start, int end, int picked, boolean isAlex) {\\n        if(start == end) {\\n            return 0;\\n        }\\n        \\n        if(isAlex) {\\n\\t\\t\\t// for player one , the action he needs to take is picked a number, so we go through all the possible one, and find the one cost him the least.\\n            int minCost = Integer.MAX_VALUE;\\n            for(int i = start; i <= end; i ++) {\\n                int cost = i + minMax(start, end, i, false);\\n                minCost = Math.min(minCost, cost);\\n            }\\n            return minCost;\\n        } else {\\n\\t\\t\\t// for player two, the action he needs to take is either say higer or lower, so we go though those two option to find the max money he can get.\\n            int maxCost = Integer.MIN_VALUE;\\n            if(picked > start) {\\n                maxCost = Math.max(maxCost, minMax(start, picked - 1, -1, true));\\n            }\\n            if(picked < end) {\\n                maxCost = Math.max(maxCost, minMax(picked + 1, end, -1, true));\\n            }\\n            return maxCost;\\n        }\\n    }\\n}\\n```\\n**This solution is NOT the optimal one, and it is NOT even an AC solution**. It is just an exmaple to demostrate the point. You can always use extra memory to avoid calculating the duplicate state so it can speed up. To avoid the recursive call, you can further improve it by using bottom-up dp approach. In some cases, you might event want to use heuristic function to increase the performance. \\n\\nHope it helps and have fun with it.\\n\\n",
                "solutionTags": [],
                "code": "```\\nfunction minMax(Any currentState, boolean isFirstPlayer) {\\n\\tif the game end or run out move\\n\\t\\treturn static evaluation;\\n\\t\\n\\tif(isFirstPlayer) {\\n\\t\\tmax = -infinity;\\n\\t\\tfor any possible move {\\n\\t\\t\\tmax = Math.max(max, minMax(nextState, false) // now is the second player\\'s turn\\n\\t\\t}\\n\\t\\treturn max;\\n\\t} else  {  // second layer\\n\\t\\tmin = +infinity;\\n\\t\\tfor any possible move {\\n\\t\\t\\tmin = Math.min(min, minMax(nextState, true);// now is the first player\\'s turn;\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        return minMax(1, n, -1, true);\\n    }\\n    \\n\\t// picked is only for player two\\n    private int minMax(int start, int end, int picked, boolean isAlex) {\\n        if(start == end) {\\n            return 0;\\n        }\\n        \\n        if(isAlex) {\\n\\t\\t\\t// for player one , the action he needs to take is picked a number, so we go through all the possible one, and find the one cost him the least.\\n            int minCost = Integer.MAX_VALUE;\\n            for(int i = start; i <= end; i ++) {\\n                int cost = i + minMax(start, end, i, false);\\n                minCost = Math.min(minCost, cost);\\n            }\\n            return minCost;\\n        } else {\\n\\t\\t\\t// for player two, the action he needs to take is either say higer or lower, so we go though those two option to find the max money he can get.\\n            int maxCost = Integer.MIN_VALUE;\\n            if(picked > start) {\\n                maxCost = Math.max(maxCost, minMax(start, picked - 1, -1, true));\\n            }\\n            if(picked < end) {\\n                maxCost = Math.max(maxCost, minMax(picked + 1, end, -1, true));\\n            }\\n            return maxCost;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84775,
                "title": "3ms-java-dp-solution",
                "content": "Similar to other DP solutions, but with two improvements.\\n1. One more corner case: if the range is less or equal to 3 (start >= end - 2), the cost will be the upper boundary minus 1 (end - 1).\\n2. When selecting the first guess, the loop starts from one index left to the middle ((start + end) / 2 - 1), and the loop break when the cost of left part is higher than the cost of right part.\\n\\nI think this problem is more similar to Burst Balloons #312.\\n\\n```\\npublic class Solution {\\n    int[][] dp;\\n    public int getMoneyAmount(int n) {\\n        dp = new int[n + 1][n + 1];\\n        return helper(1, n);\\n    }\\n    \\n    private int helper(int start, int end) {\\n        if (dp[start][end] != 0) {\\n            return dp[start][end];\\n        }\\n        if (start >= end) {\\n            return 0;\\n        }\\n        if (start >= end - 2) {\\n            return dp[start][end] = end - 1;\\n        }\\n        int mid = (start + end) / 2 - 1, min = Integer.MAX_VALUE;\\n        while (mid < end) {\\n            int left = helper(start, mid - 1);\\n            int right = helper(mid + 1, end);\\n            min = Math.min(min, mid + Math.max(left, right));\\n            if (right <= left) break;\\n            mid++;\\n        }\\n        return dp[start][end] = min;\\n    }\\n    //runtime 3ms\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int[][] dp;\\n    public int getMoneyAmount(int n) {\\n        dp = new int[n + 1][n + 1];\\n        return helper(1, n);\\n    }\\n    \\n    private int helper(int start, int end) {\\n        if (dp[start][end] != 0) {\\n            return dp[start][end];\\n        }\\n        if (start >= end) {\\n            return 0;\\n        }\\n        if (start >= end - 2) {\\n            return dp[start][end] = end - 1;\\n        }\\n        int mid = (start + end) / 2 - 1, min = Integer.MAX_VALUE;\\n        while (mid < end) {\\n            int left = helper(start, mid - 1);\\n            int right = helper(mid + 1, end);\\n            min = Math.min(min, mid + Math.max(left, right));\\n            if (right <= left) break;\\n            mid++;\\n        }\\n        return dp[start][end] = min;\\n    }\\n    //runtime 3ms\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84794,
                "title": "dp-java-o-n-3-solution-with-explanation-15ms-17-lines",
                "content": "Think about this question for three days, read the hint, still had no thought, but minimax did help, finally got this O(n^3) DP solution.  Thanks @yygy for correcting me.\\n\\nJust use an example here for explaining how to find this approach.\\nSuppose n is 5, draw a tree to find the minimum cost in worst cases.\\n![0_1469332171930_IMG_3175.JPG](/uploads/files/1469332173789-img_3175.jpg) \\n\\n\\nThrough the tree, find the transition function:\\n- f(i,j) stands for the minimum lost between guessing i and j.\\n- f(i,0) = 0, f(i,i) = 0\\n- f(i, i) = 0\\n- f(i,i+1) = i\\n- f(i,j) = min[( k from i to j) max(k+f(i,k-1), k+f(k+1,j)]\\n- the answer for this problem is f(1,n)\\n\\nThen find a way to calculate the final answer. Draw a square matrix, the value will be filled in like this:\\n![0_1469332203192_FullSizeRender.jpg](/uploads/files/1469332203662-fullsizerender.jpg) \\nHere is the code:\\n```\\n    public int getMoneyAmount(int n) {\\n        int[][] f = new int[n+2][n+2];\\n        for(int i = 1; i <  n; i++) f[i][i+1] = i;\\n        for(int k = 1; k <= n-2; k++){\\n            for(int left = n-k-1, right = n; right >= k+2; left--,right--)\\n            {        \\n                int min = Integer.MAX_VALUE;\\n            \\tfor(int i = left; i <= right; i++){\\n            \\t\\tint max = Math.max(i+f[left][i-1], i+f[i+1][right]);\\n            \\t\\tif(max < min) min = max;\\n            \\t}\\n            \\tf[left][right] = min;\\n            }\\n        }\\n        return f[1][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getMoneyAmount(int n) {\\n        int[][] f = new int[n+2][n+2];\\n        for(int i = 1; i <  n; i++) f[i][i+1] = i;\\n        for(int k = 1; k <= n-2; k++){\\n            for(int left = n-k-1, right = n; right >= k+2; left--,right--)\\n            {        \\n                int min = Integer.MAX_VALUE;\\n            \\tfor(int i = left; i <= right; i++){\\n            \\t\\tint max = Math.max(i+f[left][i-1], i+f[i+1][right]);\\n            \\t\\tif(max < min) min = max;\\n            \\t}\\n            \\tf[left][right] = min;\\n            }\\n        }\\n        return f[1][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 84823,
                "title": "java-o-n-2-dp-solution-with-clear-explanation",
                "content": "This is to share my understanding about the amazing O(n^2) dp solution, which originates (I guess) from http://artofproblemsolving.com/community/c296841h1273742, and was introduced by https://discuss.leetcode.com/topic/51487/an-o-n-2-dp-solution-quite-hard/2 earlier. \\n\\nThe main idea of the algorithm is to optimize the computations for the trivial O(n^3) dp solution. My understanding for the algorithm is as follows. Notice that my code is a little different from the original code given by the two references.\\n\\nFirst, define **f[a][b] = the min worst-cast cost to guess a number a<=m<=b**, thus, f[1][n] is the result, and **f[a][b] = min{max{f[a][k-1], f[k+1][b]}+k} for a<=k<=b**.\\n\\nSecond, define **k0[a][b] = max{k : a<=k<=b && f[a][k-1]<=f[k+1][b]}**. then\\n**max{f[a][k-1], f[k+1][b]} = f[k+1][b]** if a<=k<=k0[a][b], and **=f[a][k-1]** if k0[a][b]<k<=b. \\n\\nTherefore, **f[a][b]=min( f1[a][b], f2[a][b] )**, where **f1[a][b] = min{ f[k+1][b]+k } for a<=k<=k0[a][b]**, and **f2[a][b] =** min{ f[a][k-1]+k, k0[a][b]<k<=b} = **f[a][k0[a][b]]+k0[a][b]+1**.\\n\\nNow the key is: given a, b, how to find k0[a][b] and f1[a][b], in O(1) time. And I think that is also the most tricky or difficult part.\\n\\nWe shall run the algorithm in double-looping structure, which is **for(b=1, b<=n, b++){ for(a=b-1; a>0; a--) proceed_to_find_f[a][b]; }**. Therefore, f[i][j] for abs(i-j)<b-a are already obtained, and k0[a+1][b] was just found.\\n\\nClearly, a<=k0[a][b]<=k0[a+1][b]<=b. Thus, along the inner loop of (a=b-1; a>0; a--), **k0[all a's][b] would be found by definition in O(b) time**. In other words, it is O(1) time to get k0[a][b] for fixed a, b.\\n\\nNow consider the index sequence: a, a+1,..., k0[a][b] ,..., k0[a+1][b], ..., b.\\n\\nSuppose currently a deque is used to store the values of **{ f[k+1][b]+k, a+1<=k<=k0[a+1][b] } sorted** in ascending order (from the last step).\\n\\nTo find f1[a][b] = min{ f[k+1][b]+k } for a<=k<=k0[a][b], we have to **throw away the values** in the deque whose corresponding index j satisfies **k0[a][b]<j**<= k0[a+1][b], and **add the value f[a+1][b]+a** into deque, then **extract the minimum**. Since the deque is sorted, we can do the process by:\\n\\n**while(peekFirst().index > k0[a][b]) pollFirst();**\\n**while(f[a+1][b]+a < peekLast().value) pollLast();** // The elements polled are useless in the later loops (when a is smaller)\\n**offerLast(new Item(index=a, value=f[a+1][b]+a));**\\n**f1[a][b] = peekFirst().value;**\\n\\nSimilar to the insertion sort, the above process still yields a sorted deque. Notice that given a, b, the deque is offered only once. Thus, for fixed b, deque.size()<= b. Hence along the inner loop of (a=b-1;a>0; a--), **deque is offered for b times, and so is polled at most for b times**. In other words, it is O(1) time to get f1[a][b] for fixed a, b.\\n\\nSince we have a double-looping with variables a,b, **the overall time complexity is O(n^2)**. In fact, k0[ ][ ], f1[ ][ ], f2[ ][ ] needn't be stored. My java code is as follows:\\n```\\npublic int xxxgetMoneyAmount(int n) {\\n\\tint[][] f = new int[n + 1][n + 1];\\n\\tDeque<Integer[]> q; // item[]{index, value}\\n\\n\\tint a, b, k0, v, f1, f2;\\n\\n\\tfor (b = 2; b <= n; b++) {\\n\\t\\tk0 = b - 1;\\n\\t\\tq = new LinkedList<Integer[]>();\\n\\n\\t\\tfor (a = b - 1; a > 0; a--) {\\n\\t\\t\\t// find k0[a][b] by definition in O(1) time.\\n\\t\\t\\twhile (f[a][k0 - 1] > f[k0 + 1][b])\\n\\t\\t\\t\\tk0--;\\n\\n\\t\\t\\t// find f1[a][b] in O(1) time.\\n\\t\\t\\twhile (!q.isEmpty() && q.peekFirst()[0] > k0)\\n\\t\\t\\t\\tq.pollFirst();\\n\\n\\t\\t\\tv = f[a + 1][b] + a;\\n\\n\\t\\t\\twhile (!q.isEmpty() && v < q.peekLast()[1])\\n\\t\\t\\t\\tq.pollLast();\\n\\n\\t\\t\\tq.offerLast(new Integer[] { a, v });\\n\\n\\t\\t\\tf1 = q.peekFirst()[1];\\n\\t\\t\\tf2 = f[a][k0] + k0 + 1;\\n\\t\\t\\tf[a][b] = Math.min(f1, f2);\\n\\t\\t}\\n\\t}\\n\\n\\treturn f[1][n];\\n}\\n```\\nNotice that the operations of deques are not quite efficient. However, from the analysis above, we know that deque.size()<= b, therefore, **we can just use arrays of size O(n) to fulfill the operations of the deque**. The code is as follows, which runs about 4 times faster than the one above.\\n```\\npublic int getMoneyAmount(int n) {\\n\\tint[][] f = new int[n + 1][n + 1];\\n\\n\\t// replace deque by idx and val arrays:\\n\\t// q.pollFirst()={index[beginIdx], value[beginIdx]},\\n\\t// q.pollLast()={index[endIdx], value[endIdx]}, ...\\n\\tint beginIdx, endIdx;\\n\\tint[] index = new int[n + 1];\\n\\tint[] value = new int[n + 1];\\n\\n\\tint a, b, k0, v, f1, f2;\\n\\n\\tfor (b = 2; b <= n; b++) {\\n\\t\\tk0 = b - 1;\\n\\n\\t\\tbeginIdx = 0;\\n\\t\\tendIdx = -1; // q.isEmpty()==(beginIdx>endIdx)\\n\\n\\t\\tfor (a = b - 1; a > 0; a--) {\\n\\t\\t\\t// find k0[a][b] by definition in O(1) time.\\n\\t\\t\\twhile (f[a][k0 - 1] > f[k0 + 1][b])\\n\\t\\t\\t\\tk0--;\\n\\n\\t\\t\\t// find f1[a][b] in O(1) time.\\n\\t\\t\\twhile (beginIdx <= endIdx && index[beginIdx] > k0)\\n\\t\\t\\t\\tbeginIdx++; // q.pollFirst();\\n\\n\\t\\t\\tv = f[a + 1][b] + a;\\n\\n\\t\\t\\twhile (beginIdx <= endIdx && v < value[endIdx])\\n\\t\\t\\t\\tendIdx--; // q.pollLast();\\n\\n                        // q.offerLast(new Integer[] { a, v });\\n\\t\\t\\tendIdx++;\\n\\t\\t\\tindex[endIdx] = a;\\n\\t\\t\\tvalue[endIdx] = v; \\n\\n\\t\\t\\tf1 = value[beginIdx];\\n\\t\\t\\tf2 = f[a][k0] + k0 + 1;\\n\\t\\t\\tf[a][b] = Math.min(f1, f2);\\n\\t\\t}\\n\\t}\\n\\n\\treturn f[1][n];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int xxxgetMoneyAmount(int n) {\\n\\tint[][] f = new int[n + 1][n + 1];\\n\\tDeque<Integer[]> q; // item[]{index, value}\\n\\n\\tint a, b, k0, v, f1, f2;\\n\\n\\tfor (b = 2; b <= n; b++) {\\n\\t\\tk0 = b - 1;\\n\\t\\tq = new LinkedList<Integer[]>();\\n\\n\\t\\tfor (a = b - 1; a > 0; a--) {\\n\\t\\t\\t// find k0[a][b] by definition in O(1) time.\\n\\t\\t\\twhile (f[a][k0 - 1] > f[k0 + 1][b])\\n\\t\\t\\t\\tk0--;\\n\\n\\t\\t\\t// find f1[a][b] in O(1) time.\\n\\t\\t\\twhile (!q.isEmpty() && q.peekFirst()[0] > k0)\\n\\t\\t\\t\\tq.pollFirst();\\n\\n\\t\\t\\tv = f[a + 1][b] + a;\\n\\n\\t\\t\\twhile (!q.isEmpty() && v < q.peekLast()[1])\\n\\t\\t\\t\\tq.pollLast();\\n\\n\\t\\t\\tq.offerLast(new Integer[] { a, v });\\n\\n\\t\\t\\tf1 = q.peekFirst()[1];\\n\\t\\t\\tf2 = f[a][k0] + k0 + 1;\\n\\t\\t\\tf[a][b] = Math.min(f1, f2);\\n\\t\\t}\\n\\t}\\n\\n\\treturn f[1][n];\\n}\\n```\n```\\npublic int getMoneyAmount(int n) {\\n\\tint[][] f = new int[n + 1][n + 1];\\n\\n\\t// replace deque by idx and val arrays:\\n\\t// q.pollFirst()={index[beginIdx], value[beginIdx]},\\n\\t// q.pollLast()={index[endIdx], value[endIdx]}, ...\\n\\tint beginIdx, endIdx;\\n\\tint[] index = new int[n + 1];\\n\\tint[] value = new int[n + 1];\\n\\n\\tint a, b, k0, v, f1, f2;\\n\\n\\tfor (b = 2; b <= n; b++) {\\n\\t\\tk0 = b - 1;\\n\\n\\t\\tbeginIdx = 0;\\n\\t\\tendIdx = -1; // q.isEmpty()==(beginIdx>endIdx)\\n\\n\\t\\tfor (a = b - 1; a > 0; a--) {\\n\\t\\t\\t// find k0[a][b] by definition in O(1) time.\\n\\t\\t\\twhile (f[a][k0 - 1] > f[k0 + 1][b])\\n\\t\\t\\t\\tk0--;\\n\\n\\t\\t\\t// find f1[a][b] in O(1) time.\\n\\t\\t\\twhile (beginIdx <= endIdx && index[beginIdx] > k0)\\n\\t\\t\\t\\tbeginIdx++; // q.pollFirst();\\n\\n\\t\\t\\tv = f[a + 1][b] + a;\\n\\n\\t\\t\\twhile (beginIdx <= endIdx && v < value[endIdx])\\n\\t\\t\\t\\tendIdx--; // q.pollLast();\\n\\n                        // q.offerLast(new Integer[] { a, v });\\n\\t\\t\\tendIdx++;\\n\\t\\t\\tindex[endIdx] = a;\\n\\t\\t\\tvalue[endIdx] = v; \\n\\n\\t\\t\\tf1 = value[beginIdx];\\n\\t\\t\\tf2 = f[a][k0] + k0 + 1;\\n\\t\\t\\tf[a][b] = Math.min(f1, f2);\\n\\t\\t}\\n\\t}\\n\\n\\treturn f[1][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491523,
                "title": "java-with-2d-dp-intuitive-with-explanation",
                "content": "The problem requires the minimum amount of money to guarantee to win. Those are two different conditions.\\n1- Min amount (minimize over available total solutions) (this simulates us selecting a good starting point)\\n2- guarantee win (maximize over possible solutions at each step) (this simulates us getting unlucky and getting pushed into paths with high cost)\\nAnd it is a game so we should start thinking MiniMax Algorithm.\\nThe approach:\\n- We consider the input as a range from start to end (initially start = 1 and end = n)\\n- We try selecting a guess and calculate cost for previous and next ranges and pick max. (satisfies cond. 2)\\n- We try another start (eventually we try all possible guesses in the range) and we choose the min result to be our answer (satisfies cond. 1)\\nEx: \\nn = 4\\n[1, 2, 3, 4]\\n- we try the guess 2 which results in 2 possible directions\\n\\t- upper: [3, 4] and it costs : 3 then total cost = 3 + guess = 3 + 2 = 5\\n\\t- lower: [1] with cost 0 and total cost = 0 + 2 = 2\\n\\t- The result for starting from guess 2 is max(5, 2) = 5\\n- we can also try guessing 3 at the beginning \\n\\t- upper [4] cost = 0 and total cost = 3 + 0 = 3\\n\\t- lower [1, 2] cost = 1 and total cost = 3 + 1 = 4\\n\\t- the result for guess 3 is max(3, 4) = 4\\n- we can also try starting the guess with 1 or 4 but I will not here since they clearly will not get the correct answer. but their costs will be 4, 6\\n- The final result with be min(all starting guess costs) = min(5, 4, 4, 6) = 4\\nThe result is that I need 4 coins to be able guarantee winning while making smart decisions.\\n\\n- DP: notice our function takes two inputs start and end. We can put those into a DP 2D array to avoid repeating our work multiple times and enhance the performance.\\n```\\nclass Solution {\\n    private int[][] dp;\\n    public int getMoneyAmount(int n) {\\n        dp = new int[n+1][n+1];\\n        return getMinMoney(1, n);\\n    }\\n    \\n    private int getMinMoney(int start, int end) {\\n        if(start >= end) return 0;\\n        if(dp[start][end] != 0) return dp[start][end];\\n        int minValue = Integer.MAX_VALUE;\\n        for(int i = start; i <= end; i++) {\\n            int maxValue = i + getMinMoney(start, i - 1);\\n            maxValue = Math.max(maxValue, i + getMinMoney(i + 1, end));\\n            \\n            minValue = Math.min(minValue, maxValue);\\n        }\\n        dp[start][end] = minValue;\\n        return minValue;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] dp;\\n    public int getMoneyAmount(int n) {\\n        dp = new int[n+1][n+1];\\n        return getMinMoney(1, n);\\n    }\\n    \\n    private int getMinMoney(int start, int end) {\\n        if(start >= end) return 0;\\n        if(dp[start][end] != 0) return dp[start][end];\\n        int minValue = Integer.MAX_VALUE;\\n        for(int i = start; i <= end; i++) {\\n            int maxValue = i + getMinMoney(start, i - 1);\\n            maxValue = Math.max(maxValue, i + getMinMoney(i + 1, end));\\n            \\n            minValue = Math.min(minValue, maxValue);\\n        }\\n        dp[start][end] = minValue;\\n        return minValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811523,
                "title": "c-iterative-dp-solution-with-explanation",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        \\n        //dp[i][j] - the amount of money needed for guaranteed win,\\n        // when range is [i, j] (note: both are inclusive)\\n        for(int l = 1; l <= n; l++)\\n        {\\n            for(int i = 0; i+l-1 <= n; i++)\\n            {\\n                \\n                if(l==1)\\n                {\\n                    // if length = 1, then the only number guessed is correct, no penalty\\n                    dp[i][i+l-1] = 0; \\n                }\\n                else if(l==2)\\n                {\\n                    // if length = 2, guess the lower number, \\n                    // if it\\'s not correct then the other number will be the correct one\\n                    // so max amount to guarantee win is the lower of two numbers\\n                    dp[i][i+l-1] = i; \\n                }\\n                else\\n                {\\n                    int ans = INT_MAX;\\n                    // if you guess a number j between i, i+l-1\\n                    // then cost will be j + max of the money required to guarantee win on the either side\\n                    for(int j = i+1; j < i+l-1; j++)\\n                    {\\n                         ans = min(ans, j + max(dp[i][j-1], dp[j+1][i+l-1]));\\n                    }\\n                    \\n                    dp[i][i+l-1] = ans;\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n};\\n```\\n\\n**Approach-**\\nLet\\'s try to calculate what will be the maximum amount of money required when our window for guess starts with `i` and is of length `l`\\nIf `l = 1`, then the number guessed will always be correct. So penalty will be 0.\\nIf `l = 2`, let\\'s take `i = 3`, so the range is `[3, 4]`, the maximum amount will be required when our initial guess is wrong.\\n1. \\tIf the ans is 4, and we guessed 3 penalty is 3\\n1. \\tIf the ans is 3 and we guessed 4 penalty is 4\\nSo to minimize penalty we should always guess the lower of two numbers.\\n\\nFor any other `l`, we can choose a number `j` in the range `(i, i+l-1)` and the cost will be - \\n\\t`j` + maximum of money required for guaranteed win in two subranges - `(i, j-1)` , `(j+1, i+l-1)` \\nTo minimize the maximum money, we need to find the optimal `j`.\\n\\n**Note:** The number will be in either one of the two subranges, so we need to get only the maximum, not the summation of money in the two subranges.\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        \\n        //dp[i][j] - the amount of money needed for guaranteed win,\\n        // when range is [i, j] (note: both are inclusive)\\n        for(int l = 1; l <= n; l++)\\n        {\\n            for(int i = 0; i+l-1 <= n; i++)\\n            {\\n                \\n                if(l==1)\\n                {\\n                    // if length = 1, then the only number guessed is correct, no penalty\\n                    dp[i][i+l-1] = 0; \\n                }\\n                else if(l==2)\\n                {\\n                    // if length = 2, guess the lower number, \\n                    // if it\\'s not correct then the other number will be the correct one\\n                    // so max amount to guarantee win is the lower of two numbers\\n                    dp[i][i+l-1] = i; \\n                }\\n                else\\n                {\\n                    int ans = INT_MAX;\\n                    // if you guess a number j between i, i+l-1\\n                    // then cost will be j + max of the money required to guarantee win on the either side\\n                    for(int j = i+1; j < i+l-1; j++)\\n                    {\\n                         ans = min(ans, j + max(dp[i][j-1], dp[j+1][i+l-1]));\\n                    }\\n                    \\n                    dp[i][i+l-1] = ans;\\n                }\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84798,
                "title": "c-dp-recursive-with-brief-explanation",
                "content": "We use dp[i][j] to indicate the cost if we find our target in range [i,j]. So for each integer k in this range, we have 3 different situation:\\n1. k == target, this cost = 0;\\n2. k > target, we need to search in [i,k-1]; and cost is k + dp[i][k-1]\\n3. k < target, we need to search in [k+1,j]; and cost is k + dp[i][k-1];\\n\\nFrom all of these 3 cases, because we want to cover our cost, so we should consider k != target, and choose the k + max(dp[i][k-1],dp[i][k-1] ). Now what is our k value? Because we have the right to choose k, we definitely want to find a k which could minimize our largest cost, so we will choose the k which could min( k + max(dp[i][k-1],dp[i][k-1] ) ). The code is following:\\n\\n    class Solution {\\n    public:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        return DP(1,n,dp);\\n    }\\n    int DP(int start, int end, vector<vector<int>>& dp){\\n        if(start >= end) return 0;\\n        if(dp[start][end] != 0) return dp[start][end];// this range has been searched!\\n        int res = INT_MAX;\\n        for(int k = start; k < end; ++k){\\n            int max_sub = k + max(DP(start,k - 1,dp), DP(k + 1, end, dp));\\n            res = min(res, max_sub);\\n        }\\n        dp[start][end] = res;\\n        return dp[start][end];\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        return DP(1,n,dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 84822,
                "title": "let-me-try-to-explain-the-dp-solution",
                "content": "In fact , I have no idea why we should do like this . After looking some topic , I find only DP formula was given . So I am trying to explain it totally . It may be not right , but I'll try .\\n\\nFirst , for Chinese , just look this [Chinese Thinking Progress](https://github.com/PersonalExcercise/leetcodeExercise/blob/master/src/prob375guessnumberhigherorlowerII.md). following is the English , and more concise.\\n\\n###  1. MinMax for Game\\n\\nyou should think you are playing game : I and you . **For one turn**, I'll go first , and after I did action , you'll make a response , and give me hurt . Imaging I have N possible choices , if I choose the k-th choice , **you know , I respected you, so I think you'll give me the biggest hurt as posisblility** . Assuming you have T responses for my current action, I'll use `max( T-Responses-Hurt-Value) ` as the harm of taking current action. After thinking this, if I am not stupid , and I am not radical, I'll choice the action which your `max(T-Responses-Hurt-Value)` is `minimum`, that is **min_{k} { max{T-Response-hurt-value} }** \\n\\nSo , this the why `Min Max`.     \\n\\n### 2. How to Suit with this Problem\\n\\nwe ues `R[i][j]` to represents the minMax cost when guessing number in range `[ i , j]` .\\n\\n#### - Dynamic progress\\n\\nfor range [i, j] , we have `j-i+1`   possible choices , for choice `k` ( `i <= k <= j` , and `j > i` ), \\n\\n1. Firstly we'll get your 3 possible responses , which is \\n\\n   1. guess smaller , cost is `R[k+1][j]`\\n\\n    2. guess bigger, cost is `R[i][k-1]`\\n\\n    3. guess right , cost is `0`\\n\\n    you will give the biggest harm , that means , the final cost for choice `k` is \\n\\n    `max(R[k+1][j], R[i][k-1], 0) ` =>  `max(R[k+1][j], R[i][k-1]) ` , because as smart as you , you can't let me guess right.\\n\\n2. So we get cost `k` ( as question saying ) for guessing error.\\n\\n\\nIn conclusion, `R[i][j] = min_{k} { max(R[k+1][j], R[i][k-1])   }, where i<= k <= j`\\n\\nAforementioned formula is what you may see in some solution . \\n\\n#### - And the Edge Condition\\n\\n for `R[x][x]` , no matter how you smart , **only one number is available, so cost is 0**. \\n\\nThat;s all , hope this helps .",
                "solutionTags": [],
                "code": "In fact , I have no idea why we should do like this . After looking some topic , I find only DP formula was given . So I am trying to explain it totally . It may be not right , but I'll try .\\n\\nFirst , for Chinese , just look this [Chinese Thinking Progress](https://github.com/PersonalExcercise/leetcodeExercise/blob/master/src/prob375guessnumberhigherorlowerII.md). following is the English , and more concise.\\n\\n###  1. MinMax for Game\\n\\nyou should think you are playing game : I and you . **For one turn**, I'll go first , and after I did action , you'll make a response , and give me hurt . Imaging I have N possible choices , if I choose the k-th choice , **you know , I respected you, so I think you'll give me the biggest hurt as posisblility** . Assuming you have T responses for my current action, I'll use `max( T-Responses-Hurt-Value) ` as the harm of taking current action. After thinking this, if I am not stupid , and I am not radical, I'll choice the action which your `max(T-Responses-Hurt-Value)` is `minimum`, that is **min_{k} { max{T-Response-hurt-value} }** \\n\\nSo , this the why `Min Max`.     \\n\\n### 2. How to Suit with this Problem\\n\\nwe ues `R[i][j]` to represents the minMax cost when guessing number in range `[ i , j]` .\\n\\n#### - Dynamic progress\\n\\nfor range [i, j] , we have `j-i+1`   possible choices , for choice `k` ( `i <= k <= j` , and `j > i` ), \\n\\n1. Firstly we'll get your 3 possible responses , which is \\n\\n   1. guess smaller , cost is `R[k+1][j]`\\n\\n    2. guess bigger, cost is `R[i][k-1]`\\n\\n    3. guess right , cost is `0`\\n\\n    you will give the biggest harm , that means , the final cost for choice `k` is \\n\\n    `max(R[k+1][j], R[i][k-1], 0) ` =>  `max(R[k+1][j], R[i][k-1]) ` , because as smart as you , you can't let me guess right.\\n\\n2. So we get cost `k` ( as question saying ) for guessing error.\\n\\n\\nIn conclusion, `R[i][j] = min_{k} { max(R[k+1][j], R[i][k-1])   }, where i<= k <= j`\\n\\nAforementioned formula is what you may see in some solution . \\n\\n#### - And the Edge Condition\\n\\n for `R[x][x]` , no matter how you smart , **only one number is available, so cost is 0**. \\n\\nThat;s all , hope this helps .",
                "codeTag": "Unknown"
            },
            {
                "id": 699749,
                "title": "python-very-detailed-explanation-with-examples",
                "content": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        ## RC ##\\n        ## APPROACH : DP - MERGE INTERVALS PATTERN ##\\n        ## LOGIC - BOTTOM UP ##\\n        ## consider numbers 1,2,3,4 (here i = 1, j = 4) ## \\n        ## 1. we start by picking 2 or 3 ==> lets say we started by 2, player B says right side we pick 3 ==> so total = 5. or if player B says left side ? result will be 2 + 0 => 2. worst case scenarios is maximum of leftside and rightside. i.e for k=2 => max(5,2)\\n        ## 2. next if we start with 3 i.e k=3 ==> we can go left side or right side. for leftside ==> total = 3 + 1, for rightside total = 3 + 0. worst case is max(4,3) = 4\\n        ## In short, for start point k =2 in 1234, we need leftside [1,1] rightside[3,4] and pick worst\\n        ## for startpoint k = 3 in 1234, we need leftside [1,2] and rightside[4,4] and pick worst\\n        ## This is the reason why we need to have 2D DP matrix, to store left and right subproblems\\n        ## We need to return best of all worst cases, so res = minimum( worstcase( number + leftside sub problem, number + rightside subproblem ) ) \\n        ## ```dp[i][j] = min( dp[i][j], max( dp[i][k-1] + k, dp[k+1][j] + k ) )``` for all startpoints of k ( k lies between i and j)\\n        \\n\\t\\t## TIME COMPLEXITY : O(N^2) ##\\n\\t\\t## SPACE COMPLEXITY : O(N^2) ##\\n\\n        ## EXAMPLE : 1 2 3 4 5 6 7 ##\\n        # [\\n        #     [\\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\'], \\n        #     [\\'X\\', 0, 1, 2, 4, 6, 8, 10], \\n        #     [\\'X\\', \\'X\\', 0, 2, 3, 6, 8, 10], \\n        #     [\\'X\\', \\'X\\', \\'X\\', 0, 3, 4, 8, 10], \\n        #     [\\'X\\', \\'X\\', \\'X\\', \\'X\\', 0, 4, 5, 10], \\n        #     [\\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', 0, 5, 6], \\n        #     [\\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', 0, 6], \\n        #     [\\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', 0]\\n        # ]\\n\\n        dp = [[ float(\\'inf\\') ] * (n+1) for _ in range(n+1)]\\n        for i in range(n, 0, -1):\\n            for j in range(i,n+1):\\n                if i == j :\\n                    dp[i][j] = 0\\n                if j - i == 1:\\n                    dp[i][j] = i\\n                for k in range(i+1, j):\\n                    dp[i][j] = min( dp[i][j], max( dp[i][k-1] + k, dp[k+1][j] + k ) )\\n        # print(dp)\\n        return dp[1][-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        ## RC ##\\n        ## APPROACH : DP - MERGE INTERVALS PATTERN ##\\n        ## LOGIC - BOTTOM UP ##\\n        ## consider numbers 1,2,3,4 (here i = 1, j = 4) ## \\n        ## 1. we start by picking 2 or 3 ==> lets say we started by 2, player B says right side we pick 3 ==> so total = 5. or if player B says left side ? result will be 2 + 0 => 2. worst case scenarios is maximum of leftside and rightside. i.e for k=2 => max(5,2)\\n        ## 2. next if we start with 3 i.e k=3 ==> we can go left side or right side. for leftside ==> total = 3 + 1, for rightside total = 3 + 0. worst case is max(4,3) = 4\\n        ## In short, for start point k =2 in 1234, we need leftside [1,1] rightside[3,4] and pick worst\\n        ## for startpoint k = 3 in 1234, we need leftside [1,2] and rightside[4,4] and pick worst\\n        ## This is the reason why we need to have 2D DP matrix, to store left and right subproblems\\n        ## We need to return best of all worst cases, so res = minimum( worstcase( number + leftside sub problem, number + rightside subproblem ) ) \\n        ## ```\n``` for all startpoints of k ( k lies between i and j)\\n        \\n\\t\\t## TIME COMPLEXITY : O(N^2) ##\\n\\t\\t## SPACE COMPLEXITY : O(N^2) ##\\n\\n        ## EXAMPLE : 1 2 3 4 5 6 7 ##\\n        # [\\n        #     [\\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\'], \\n        #     [\\'X\\', 0, 1, 2, 4, 6, 8, 10], \\n        #     [\\'X\\', \\'X\\', 0, 2, 3, 6, 8, 10], \\n        #     [\\'X\\', \\'X\\', \\'X\\', 0, 3, 4, 8, 10], \\n        #     [\\'X\\', \\'X\\', \\'X\\', \\'X\\', 0, 4, 5, 10], \\n        #     [\\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', 0, 5, 6], \\n        #     [\\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', 0, 6], \\n        #     [\\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', \\'X\\', 0]\\n        # ]\\n\\n        dp = [[ float(\\'inf\\') ] * (n+1) for _ in range(n+1)]\\n        for i in range(n, 0, -1):\\n            for j in range(i,n+1):\\n                if i == j :\\n                    dp[i][j] = 0\\n                if j - i == 1:\\n                    dp[i][j] = i\\n                for k in range(i+1, j):\\n                    dp[i][j] = min( dp[i][j], max( dp[i][k-1] + k, dp[k+1][j] + k ) )\\n        # print(dp)\\n        return dp[1][-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538500,
                "title": "clear-and-concise-problem-description-solution",
                "content": "The description is misleading when they say \"Find out how much money you need to have to guarantee a win\". It should be rephrased to the below statement and example.\\n\\nFind the minimum amount of money needed when the player guesses incorrectly every time except the last. Assume the player doesn\\'t use binary search to find the optimal solution.\\n\\n**Example:** \\n\\tn = 3\\n\\tI pick 1: You guess 2, I say it\\'s lower. You guess 1. Total paid: $2.\\n\\tI pick 1: You guess 3, I say it\\'s lower. You guess 2, I say it\\'s lower. You guess 1. Total paid: $5.\\n\\tI pick 2: You guess 3, I say it\\'s lower. You guess 1, I say it\\'s higher. You guess 2. Total paid: $4.\\n\\tI pick 2: You guess 1, I say it\\'s higher. You guess 3, I say it\\'s lower. You guess 2. Total paid: $4.\\n\\tI pick 3: You guess 2, I say it\\'s higher. You guess 3, Total paid: $2.\\n\\tI pick 3: You guess 1, I say it\\'s higher. You guess 2, I say it\\'s higher. You guess 3. Total paid: $3.\\n\\tThe minimum amount of money needed when the player guesses incorrectly every time except the last is $2.\\n   \\n   ```\\nclass Solution {\\n\\n    public int getMoneyAmount(int n) {\\n        return amountPaid(1, n, new Integer[n+1][n+1]);\\n    }\\n    \\n    private int amountPaid(int lower, int upper, Integer[][] memo) {\\n        // Base case: No more guesses are left. The guess is correct. No payment is needed.\\n        if(lower >= upper) return 0;\\n        \\n        if(memo[lower][upper] != null) return memo[lower][upper];\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int guess = lower; guess <= upper; guess++){\\n            // Maximum paid if player incorrectly guesses.\\n            int maximumPaid = guess + Math.max(amountPaid(guess+1, upper, memo), amountPaid(lower, guess-1, memo));\\n            \\n            // Minimum paid out of all guesses between lower and upper bounds.\\n            min = Math.min(min, maximumPaid);\\n        }\\n        \\n        return memo[lower][upper] = min;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int getMoneyAmount(int n) {\\n        return amountPaid(1, n, new Integer[n+1][n+1]);\\n    }\\n    \\n    private int amountPaid(int lower, int upper, Integer[][] memo) {\\n        // Base case: No more guesses are left. The guess is correct. No payment is needed.\\n        if(lower >= upper) return 0;\\n        \\n        if(memo[lower][upper] != null) return memo[lower][upper];\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int guess = lower; guess <= upper; guess++){\\n            // Maximum paid if player incorrectly guesses.\\n            int maximumPaid = guess + Math.max(amountPaid(guess+1, upper, memo), amountPaid(lower, guess-1, memo));\\n            \\n            // Minimum paid out of all guesses between lower and upper bounds.\\n            min = Math.min(min, maximumPaid);\\n        }\\n        \\n        return memo[lower][upper] = min;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373238,
                "title": "topdown-dp-in-java",
                "content": "It is a classical type of problem, which I name it **given worst case but I do best**. That\\'s kind of similar to **Minimax** problem except that our competitor is the reality here ;).\\n\\nI do best to minimize the cost, while the worst case will maximize the cost.\\n\\nAssuming we guess `i`, the target number can be in `i`\\'s left or right, that\\'s we cannot decide.\\nSo the worst case will choose the bigger cost between left and right.\\nWhat we can decide is which `i` we guess, so we choose the `i` gives minimum cost.\\n\\n****\\n```\\n    private int[][] memo;\\n    \\n    public int getMoneyAmount(int n) {\\n        memo = new int[n + 1][n + 1];\\n        return minCost(1, n);\\n    }\\n    \\n    private int minCost(int lo, int hi) {\\n        if (lo >= hi) {\\n            return 0;\\n        }\\n        \\n        if (memo[lo][hi] != 0) {\\n            return memo[lo][hi];\\n        }\\n        \\n        int minTotal = Integer.MAX_VALUE;\\n        for (int i = lo; i <= hi; i++) {\\n            minTotal = Math.min(minTotal, i + Math.max(minCost(lo, i - 1), minCost(i + 1, hi)));\\n        }\\n        \\n        memo[lo][hi] = minTotal;\\n        return minTotal;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int[][] memo;\\n    \\n    public int getMoneyAmount(int n) {\\n        memo = new int[n + 1][n + 1];\\n        return minCost(1, n);\\n    }\\n    \\n    private int minCost(int lo, int hi) {\\n        if (lo >= hi) {\\n            return 0;\\n        }\\n        \\n        if (memo[lo][hi] != 0) {\\n            return memo[lo][hi];\\n        }\\n        \\n        int minTotal = Integer.MAX_VALUE;\\n        for (int i = lo; i <= hi; i++) {\\n            minTotal = Math.min(minTotal, i + Math.max(minCost(lo, i - 1), minCost(i + 1, hi)));\\n        }\\n        \\n        memo[lo][hi] = minTotal;\\n        return minTotal;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156018,
                "title": "python-solution-with-explanation",
                "content": "I feel like this is one of the classical kind of DP problem, so here I decided wrote down the thinking process for this problem for futuer record. \\n\\nFirst we have following observation: \\n\\n```python\\ndp[i][j]: min money we need to guarantee a win for numbers from i ->j includisve\\n```\\n\\nFollowing definition we can complete other typical DP components:\\n\\n```python\\ninit: dp = [[0 for _ in  range(n+1)] for _  in range(n + 1)], dp[i][i] = 0 for i from 0->n\\ntransition: dp[i][j] = k + max(dp[i][k-1], dp[k+1][j]), for k = i -> j inclusive\\nreturn: dp[1][n]\\n```\\n\\nOne thing I always felt tricky is the way to iterative over dp matrix becuase for this kind of problem we need to iterative over the diag. I personally like following template:\\n\\n```python\\nfor start in range(1, n+1):\\n    for j in range(start, n+1):\\n\\t\\ti = j - start\\n\\t\\tupdate dp[i][j]\\n```\\n\\nSo basically we iterative over column j, and compute i from j. With above components it is trivial to write following code:\\n\\n```python\\ndef getMoneyAmount(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\\n        for start in range(1, n+1):\\n            for j in range(start, n+1):\\n                i = j - start\\n                dp[i][j] = min(i + dp[i+1][j], j + dp[i][j-1])\\n                for k in range(i+1, j):\\n                    dp[i][j] = min(dp[i][j], k + max(dp[i][k-1], dp[k+1][j]))\\n        return dp[1][n]\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ndp[i][j]: min money we need to guarantee a win for numbers from i ->j includisve\\n```\n```python\\ninit: dp = [[0 for _ in  range(n+1)] for _  in range(n + 1)], dp[i][i] = 0 for i from 0->n\\ntransition: dp[i][j] = k + max(dp[i][k-1], dp[k+1][j]), for k = i -> j inclusive\\nreturn: dp[1][n]\\n```\n```python\\nfor start in range(1, n+1):\\n    for j in range(start, n+1):\\n\\t\\ti = j - start\\n\\t\\tupdate dp[i][j]\\n```\n```python\\ndef getMoneyAmount(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\\n        for start in range(1, n+1):\\n            for j in range(start, n+1):\\n                i = j - start\\n                dp[i][j] = min(i + dp[i+1][j], j + dp[i][j-1])\\n                for k in range(i+1, j):\\n                    dp[i][j] = min(dp[i][j], k + max(dp[i][k-1], dp[k+1][j]))\\n        return dp[1][n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1501824,
                "title": "java-dp-solution-inspired-from-egg-drop-problem",
                "content": "```\\nclass Solution {\\n    int[][] best;\\n    public int getMoneyAmount(int n) {\\n        best = new int[n + 1][n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            Arrays.fill(best[i], -1);\\n        }\\n        return dp(1, n);\\n    }\\n    \\n    private int dp(int lo, int hi) {\\n        if (lo >= hi) {\\n            return 0;\\n        } else {\\n            if (best[lo][hi] != -1) {\\n                return best[lo][hi];\\n            }\\n            //the idea is to  compute the maximum amount of money I need to pay with my guesses ranging from lo to hi.\\n            //Since I want to minimize my payoff, I\\'ll choose the starting point [lo,hi] that has the minimum payoff.\\n            //But for each starting point, I\\'ll choose the maximum amount of money I pay, since I need the worst case scenario.\\n            int res = Integer.MAX_VALUE;\\n            for (int i = lo; i <= hi; i++) {\\n                int op1 = 0; //guess = i, i was correct, no cost incurred\\n                int op2 = i + dp(lo, i - 1);//guess = i = wrong, go lo\\n                int op3 = i + dp(i + 1, hi);//guess = i = wrong, go hi\\n                int out = Math.max(op1, Math.max(op2, op3));\\n                res = Math.min(out, res);\\n            }\\n            best[lo][hi] = res;\\n            return res;\\n        }\\n    }       \\n}\\n```\\n\\nTime Complexity = O(n^2), Space Complexity = O(n^2)\\nLink from where I learned -> https://labuladong.gitbook.io/algo-en/i.-dynamic-programming/throwingeggsinhighbuildings",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] best;\\n    public int getMoneyAmount(int n) {\\n        best = new int[n + 1][n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            Arrays.fill(best[i], -1);\\n        }\\n        return dp(1, n);\\n    }\\n    \\n    private int dp(int lo, int hi) {\\n        if (lo >= hi) {\\n            return 0;\\n        } else {\\n            if (best[lo][hi] != -1) {\\n                return best[lo][hi];\\n            }\\n            //the idea is to  compute the maximum amount of money I need to pay with my guesses ranging from lo to hi.\\n            //Since I want to minimize my payoff, I\\'ll choose the starting point [lo,hi] that has the minimum payoff.\\n            //But for each starting point, I\\'ll choose the maximum amount of money I pay, since I need the worst case scenario.\\n            int res = Integer.MAX_VALUE;\\n            for (int i = lo; i <= hi; i++) {\\n                int op1 = 0; //guess = i, i was correct, no cost incurred\\n                int op2 = i + dp(lo, i - 1);//guess = i = wrong, go lo\\n                int op3 = i + dp(i + 1, hi);//guess = i = wrong, go hi\\n                int out = Math.max(op1, Math.max(op2, op3));\\n                res = Math.min(out, res);\\n            }\\n            best[lo][hi] = res;\\n            return res;\\n        }\\n    }       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84806,
                "title": "top-down-and-bottom-up-solution",
                "content": "Top down solution using memorize search.\\n```\\nclass Solution(object):\\n    def dfs(self, start, end):\\n        if start >= end:\\n            return 0\\n\\n        if start + 1 == end:\\n            return start\\n\\n        if self.record[start][end] is None:\\n            self.record[start][end] = min(\\n                i + max(self.dfs(start, i - 1), self.dfs(i + 1, end))\\n                for i in xrange(start, end + 1)\\n            )\\n\\n        return self.record[start][end]\\n\\n    def getMoneyAmount(self, n):\\n        self.record = [[None] * (n + 1) for _ in xrange(n + 1)]\\n        return self.dfs(1, n)\\n````\\n\\nBottom up solution using DP.\\n\\n```\\nclass Solution(object):\\n    def getMoneyAmount(self, n):\\n        record = [[0] * (n + 2) for _ in xrange(n + 2)]\\n\\n        for r in xrange(2, n + 1):\\n            for start in xrange(1, n - r + 2):\\n                end = start + r - 1\\n\\n                record[start][end] = min(\\n                    i + max(record[start][i - 1], record[i + 1][end])\\n                    for i in xrange(start, end + 1)\\n                )\\n\\n        return record[1][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def dfs(self, start, end):\\n        if start >= end:\\n            return 0\\n\\n        if start + 1 == end:\\n            return start\\n\\n        if self.record[start][end] is None:\\n            self.record[start][end] = min(\\n                i + max(self.dfs(start, i - 1), self.dfs(i + 1, end))\\n                for i in xrange(start, end + 1)\\n            )\\n\\n        return self.record[start][end]\\n\\n    def getMoneyAmount(self, n):\\n        self.record = [[None] * (n + 1) for _ in xrange(n + 1)]\\n        return self.dfs(1, n)\\n```\n```\\nclass Solution(object):\\n    def getMoneyAmount(self, n):\\n        record = [[0] * (n + 2) for _ in xrange(n + 2)]\\n\\n        for r in xrange(2, n + 1):\\n            for start in xrange(1, n - r + 2):\\n                end = start + r - 1\\n\\n                record[start][end] = min(\\n                    i + max(record[start][i - 1], record[i + 1][end])\\n                    for i in xrange(start, end + 1)\\n                )\\n\\n        return record[1][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173704,
                "title": "python-dp-with-explaination",
                "content": "```\\n\\tdef getMoneyAmountDP(self, n):\\n\\t\\t\\'\\'\\'\\n\\t\\tFor n = 4, we have dp array like below, only focus on assigning upper triangle\\n\\t\\tWe fill upper triangle from bottom to top, starting from (3, 4), then (2,3), (2,4), (1,2), (1,3), (1,4)\\n\\t\\t\\n\\t\\t\\t 0   1  2  3  4\\n\\t\\t0\\t[- , -, -, -, -]\\n\\t\\t1\\t[- , 0, 0, 0, 0]\\n\\t\\t2\\t[- , 0, 0, 0, 0]\\n\\t\\t3\\t[- , 0, 0, 0, 0]\\n\\t\\t4\\t[- , 0, 0, 0, 0]\\n\\n\\t\\t:param n:\\n\\t\\t:return:\\n\\t\\t\\'\\'\\'\\n\\t\\tcache = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\\n\\t\\tfor lo in range(n - 1, 0, -1):\\n\\t\\t\\tfor hi in range(lo + 1, n + 1):\\n\\t\\t\\t\\tcache[lo][hi] = float(\\'inf\\')\\n\\t\\t\\t\\tfor pivot in range(lo, hi):\\n\\t\\t\\t\\t\\tcache[lo][hi] = min(cache[lo][hi], pivot + max(cache[lo][pivot - 1], cache[pivot + 1][hi]))\\n\\t\\treturn cache[1][n]\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef getMoneyAmountDP(self, n):\\n\\t\\t\\'\\'\\'\\n\\t\\tFor n = 4, we have dp array like below, only focus on assigning upper triangle\\n\\t\\tWe fill upper triangle from bottom to top, starting from (3, 4), then (2,3), (2,4), (1,2), (1,3), (1,4)\\n\\t\\t\\n\\t\\t\\t 0   1  2  3  4\\n\\t\\t0\\t[- , -, -, -, -]\\n\\t\\t1\\t[- , 0, 0, 0, 0]\\n\\t\\t2\\t[- , 0, 0, 0, 0]\\n\\t\\t3\\t[- , 0, 0, 0, 0]\\n\\t\\t4\\t[- , 0, 0, 0, 0]\\n\\n\\t\\t:param n:\\n\\t\\t:return:\\n\\t\\t\\'\\'\\'\\n\\t\\tcache = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\\n\\t\\tfor lo in range(n - 1, 0, -1):\\n\\t\\t\\tfor hi in range(lo + 1, n + 1):\\n\\t\\t\\t\\tcache[lo][hi] = float(\\'inf\\')\\n\\t\\t\\t\\tfor pivot in range(lo, hi):\\n\\t\\t\\t\\t\\tcache[lo][hi] = min(cache[lo][hi], pivot + max(cache[lo][pivot - 1], cache[pivot + 1][hi]))\\n\\t\\treturn cache[1][n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 84802,
                "title": "c-more-simple-dp-solution",
                "content": "```\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\\n        for (int i = 1; i <= n; ++i){\\n            for (int j = i - 1; j >= 1; --j){\\n                int min_value = INT_MAX;\\n                for (int k = j; k <= i; ++k){\\n                    int tmp = k + max(dp[j][k - 1], dp[k + 1][i]);\\n                    min_value = min(min_value, tmp);\\n                }\\n                dp[j][i] = min_value;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\\n        for (int i = 1; i <= n; ++i){\\n            for (int j = i - 1; j >= 1; --j){\\n                int min_value = INT_MAX;\\n                for (int k = j; k <= i; ++k){\\n                    int tmp = k + max(dp[j][k - 1], dp[k + 1][i]);\\n                    min_value = min(min_value, tmp);\\n                }\\n                dp[j][i] = min_value;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3795938,
                "title": "easy-top-down-and-bottom-up-solution",
                "content": "\\n# PLS UPVOTE IF U LIKE MY SOLUTION\\n# Approach\\nThe main function getMoneyAmount(n) takes an integer n as input and returns the minimum amount of money required to guarantee a win in the \"Guess the Number\" game.\\n\\nThe helper function solve(start, end, dp) takes two integers start and end, representing the current range of numbers to consider for guessing, and a 2D vector dp for memoization.\\n\\nIn the helper function solve, it first checks for the base cases:\\n\\nIf start is greater than or equal to end, the range has only one element (or none), so no guessing is needed, and the function returns 0.\\nIf dp[start][end] is not equal to -1, it means that the minimum cost to guarantee a win for the current range start to end has already been calculated and stored in the memoization table. In this case, the function directly returns the value stored in dp[start][end], avoiding redundant computations.\\nIf the code reaches this point, it means that start is less than end, and we need to calculate the minimum amount of money required to guarantee a win.\\n\\nInitialize maxi to INT_MAX, which will be used to store the minimum cost for the current range start to end.\\n\\nIterate from i = start up to i = end, considering each number i as a potential guess. Calculate the cost for guessing i and find the maximum cost between the left and right subranges.\\n\\nCalculate the cost for guessing i as i + max(solve(start, i - 1, dp), solve(i + 1, end, dp)).\\nThe cost of guessing i is the sum of the cost of guessing the left subrange (from start to i-1) and the cost of guessing the right subrange (from i+1 to end).\\nKeep track of the minimum cost by updating maxi with the minimum value between its current value and the cost calculated in step 6.\\n\\nAfter calculating the minimum cost for the current range start to end, store the result maxi in the dp vector at index [start][end] for memoization to avoid redundant calculations in the future.\\n\\nAfter calculating the minimum amount of money required to guarantee a win for the range start to end, the function returns the result maxi.\\n\\nIn the getMoneyAmount(n) function, it initializes a 2D vector dp of size (n+1) x (n+1) with all elements set to -1 for memoization.\\n\\nIt calls the helper function solve(1, n, dp) with the given range 1 to n and the memoization table dp and returns the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int start,int end ,vector<vector<int>>&dp)\\n{\\n    if(start>=end)\\n    return 0;\\n    if(dp[start][end]!=-1)\\n    return dp[start][end];\\n\\n    int maxi=INT_MAX;\\n    for(int i=start;i<=end;i++)\\n    {\\n        maxi=min(maxi,i+max(solve(start,i-1,dp), solve(i+1,end,dp )));\\n    }\\n    return dp[start][end] =maxi;\\n}\\n    int getMoneyAmount(int n)\\n    {\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return solve(1,n,dp);\\n    }\\n};\\n```\\n\\n\\n# Approach\\nThe main function getMoneyAmount(n) takes an integer n as input and returns the minimum amount of money required to guarantee a win in the \"Guess the Number\" game for numbers from 1 to n.\\n\\nThe helper function solvetab(n) takes an integer n (representing the range of numbers from 1 to n) and returns the minimum amount of money required to guarantee a win in the \"Guess the Number\" game for numbers from 1 to n using tabulation.\\n\\nThe function initializes a 2D vector dp of size (n+2) x (n+2) with all elements set to 0. The vector dp will be used to store the minimum amount of money required to guarantee a win for ranges start to end.\\n\\nThe outer loop iterates from start = n down to start = 1. This ensures that we calculate the results for smaller ranges first before using them to compute larger ranges.\\n\\nThe inner loop iterates from end = start up to end = n. Since we are calculating the minimum amount of money required to guarantee a win for each range, we need to cover all possible subrange combinations.\\n\\nIf start == end, it means the range has only one element (or none), so no guessing is needed, and we continue to the next iteration.\\n\\nFor other cases where start != end, we calculate the minimum amount of money required to guarantee a win for the current range start to end.\\n\\nInitialize maxi to INT_MAX, which will be used to store the minimum amount of money required for the current range start to end.\\n\\nIterate from i = start up to i = end, considering each number i as a potential guess. Calculate the cost for guessing i and find the maximum cost between the left and right subranges.\\n\\nCalculate the cost for guessing i as i + max(dp[start][i - 1], dp[i + 1][end]).\\nThe cost of guessing i is the sum of the cost of guessing the left subrange (from start to i-1) and the cost of guessing the right subrange (from i+1 to end).\\nKeep track of the minimum cost by updating maxi with the minimum value between its current value and the cost calculated in step 9.\\n\\nAfter calculating the minimum amount of money required for the current range start to end, store the result maxi in the dp vector at index [start][end] for memoization.\\n\\nAfter calculating the minimum amount of money required for all ranges, return the result stored in dp[1][n], which represents the minimum amount of money required to guarantee a win for numbers from 1 to n.\\n\\nThe dynamic programming approach with tabulation efficiently computes the minimum amount of money required to guarantee a win for each range without redundant \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solvetab(int n )\\n{\\n    vector<vector<int>>dp(n+2,vector<int>(n+2,0));\\n    for(int start=n;start>=1;start--)\\n    {\\n        for(int end=start;end<=n;end++)\\n        {\\n            if(start==end)\\n            continue;\\n        else\\n        {\\n            int maxi=INT_MAX;\\n            for(int i=start;i<=end;i++)\\n            {\\n                maxi=min(maxi,i+max(dp[start][i-1],dp[i+1][end]));\\n            }\\n            dp[start][end]=maxi;\\n        }\\n        }\\n    }\\n    return dp[1][n];\\n}\\n    int getMoneyAmount(int n)\\n    {\\n        return solvetab(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int start,int end ,vector<vector<int>>&dp)\\n{\\n    if(start>=end)\\n    return 0;\\n    if(dp[start][end]!=-1)\\n    return dp[start][end];\\n\\n    int maxi=INT_MAX;\\n    for(int i=start;i<=end;i++)\\n    {\\n        maxi=min(maxi,i+max(solve(start,i-1,dp), solve(i+1,end,dp )));\\n    }\\n    return dp[start][end] =maxi;\\n}\\n    int getMoneyAmount(int n)\\n    {\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return solve(1,n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint solvetab(int n )\\n{\\n    vector<vector<int>>dp(n+2,vector<int>(n+2,0));\\n    for(int start=n;start>=1;start--)\\n    {\\n        for(int end=start;end<=n;end++)\\n        {\\n            if(start==end)\\n            continue;\\n        else\\n        {\\n            int maxi=INT_MAX;\\n            for(int i=start;i<=end;i++)\\n            {\\n                maxi=min(maxi,i+max(dp[start][i-1],dp[i+1][end]));\\n            }\\n            dp[start][end]=maxi;\\n        }\\n        }\\n    }\\n    return dp[1][n];\\n}\\n    int getMoneyAmount(int n)\\n    {\\n        return solvetab(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004954,
                "title": "python3-dp-binsearch-w-explanation-t-m-96-47",
                "content": "For an interval `[l,r]`, we choose a num, which if incorrect still allows us to know whether the secret is in either `[l,num-1]` or `[num+1,r]`. So, the worst-case (w-c) cost is num + max(w-c cost in`[l,num-1]`, w-c cost in `[num+1,r])`. We do this by recursion and binary search, starting with`[1,n]`.\\n```\\nclass Solution:\\n    def getMoneyAmount(self, n):\\n\\n        @lru_cache(None)              # <-- we cache function results to avoid recomputing them\\n        def dp(l = 1, r = n)-> int:\\n            if r-l < 1: return 0      # <-- base case for the recursion; one number in [l,r]       \\n            ans = 1000                # <-- the answer for n = 200 is 952\\n            \\n            for choice in range((l+r)//2,r):\\n                ans = min(ans,choice+max(dp(l,choice-1),dp(choice+1,r)))\\n\\n            return ans\\n\\n        return dp()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n):\\n\\n        @lru_cache(None)              # <-- we cache function results to avoid recomputing them\\n        def dp(l = 1, r = n)-> int:\\n            if r-l < 1: return 0      # <-- base case for the recursion; one number in [l,r]       \\n            ans = 1000                # <-- the answer for n = 200 is 952\\n            \\n            for choice in range((l+r)//2,r):\\n                ans = min(ans,choice+max(dp(l,choice-1),dp(choice+1,r)))\\n\\n            return ans\\n\\n        return dp()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629546,
                "title": "c-o-n-3-o-n-2lgn-o-n-2-detailed-explanation",
                "content": "\\n## Step 1: trivial O(n^3) DP\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 1));\\n        for (int r = 2; r <= n; r++) {\\n            for (int l = r - 1; l; l--) {\\n                dp[l][r] = INT_MAX;\\n                for (int m = l; m <= r; m++) {\\n                    dp[l][r] = min(dp[l][r], m + max(dp[l][m - 1], dp[m + 1][r]));\\n                }\\n            }\\n        }\\n        return dp[1].back();\\n    }\\n};\\n```\\n\\n1. we can find the largest `m` s.t. `dp[l][m - 1] <= dp[m + 1][r]`\\n- for any `k >= 1, dp[l][m + k] > dp[m + k][r]`\\n- and `dp[l][m + a - 1] + m + a < dp[l][m + b] + m + b, for b > a >= 1`\\n\\nso we only need to use `m + 1 + dp[i][m]` for left hand side\\nwe can have the following implementation (still O(n^3)) but we avoid the unnecessary `max` calls.\\n\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 1));\\n        for (int r = 2; r <= n; r++) {\\n            int m = r - 1;\\n            for (int l = r - 1; l; l--) {\\n                for (; dp[l][m - 1] > dp[m + 1][r]; m--);\\n                dp[l][r] = dp[l][m] + m + 1;\\n                for (int k = m; k >= l; k--) {\\n                    dp[l][r] = min(dp[l][r], k + dp[k + 1][r]);\\n                }\\n            }\\n        }\\n        return dp[1].back();\\n    }\\n};\\n```\\n\\n## Step 2: deal with right hand side\\n\\nAs you can see, we have lots of repeated computation in the following loop\\n```cpp\\nfor (int k = m; k >= l; k--) {\\n    dp[l][r] = min(dp[l][r], k + dp[k + 1][r]);\\n}\\n```\\n\\nwe can do better, just place values `k + dp[k + 1][r], k in [l, m]` in priority queue to keep track of the minimum one.\\n\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 1));\\n        for (int r = 2; r <= n; r++) {\\n            priority_queue<array<int, 2>> pq;\\n            int m = r - 1;\\n            for (int l = r - 1; l; l--) {\\n                for (; dp[l][m - 1] > dp[m + 1][r]; m--);\\n                for (; !pq.empty() && pq.top()[1] > m;) {\\n                    // because left part is greater than right part if we choose `pq.top()[1]` as middle point\\n                    pq.pop();\\n                }\\n                pq.push({-(dp[l + 1][r] + l), l});\\n                dp[l][r] = min(dp[l][m] + m + 1, -pq.top()[0]);\\n            }\\n        }\\n        return dp[1].back();\\n    }\\n};\\n```\\n\\n## Step 3: sliding window\\n\\nbecause we are tracking the values `k + dp[k + 1][r], k in [l, m]`, and with `l` decreasing `m` may als decrease, so we can find out the window can only move left.\\n\\nIn this scenario, we can use `deque` to maintain our window:)\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 1));\\n        for (int r = 2; r <= n; r++) {\\n            deque<array<int, 2>> window;\\n            int m = r - 1;\\n            for (int l = r - 1; l; l--) {\\n                for (; dp[l][m - 1] > dp[m + 1][r]; m--);\\n                for (; !window.empty() && window.back()[1] > m;) {\\n                    // because left part is greater than right part if we choose `window.back()[1]` as middle point\\n                    window.pop_back();\\n                }\\n                for (; dp[l + 1][r] + l <= window.front()[0];)\\n\\t\\t\\t\\t\\t// because dp[l + 1][r] + l will live longer than others, so we can simply keep the deque decreasing  \\n                    window.pop_front();\\n                window.push_front({dp[l + 1][r] + l, l});\\n                dp[l][r] = min(dp[l][m] + m + 1, window.back()[0]);\\n            }\\n        }\\n        return dp[1].back();\\n    }\\n};\\n```\\n\\nreference: https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/84826/An-O(n2)-DP-Solution-Quite-Hard.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 1));\\n        for (int r = 2; r <= n; r++) {\\n            for (int l = r - 1; l; l--) {\\n                dp[l][r] = INT_MAX;\\n                for (int m = l; m <= r; m++) {\\n                    dp[l][r] = min(dp[l][r], m + max(dp[l][m - 1], dp[m + 1][r]));\\n                }\\n            }\\n        }\\n        return dp[1].back();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 1));\\n        for (int r = 2; r <= n; r++) {\\n            int m = r - 1;\\n            for (int l = r - 1; l; l--) {\\n                for (; dp[l][m - 1] > dp[m + 1][r]; m--);\\n                dp[l][r] = dp[l][m] + m + 1;\\n                for (int k = m; k >= l; k--) {\\n                    dp[l][r] = min(dp[l][r], k + dp[k + 1][r]);\\n                }\\n            }\\n        }\\n        return dp[1].back();\\n    }\\n};\\n```\n```cpp\\nfor (int k = m; k >= l; k--) {\\n    dp[l][r] = min(dp[l][r], k + dp[k + 1][r]);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 1));\\n        for (int r = 2; r <= n; r++) {\\n            priority_queue<array<int, 2>> pq;\\n            int m = r - 1;\\n            for (int l = r - 1; l; l--) {\\n                for (; dp[l][m - 1] > dp[m + 1][r]; m--);\\n                for (; !pq.empty() && pq.top()[1] > m;) {\\n                    // because left part is greater than right part if we choose `pq.top()[1]` as middle point\\n                    pq.pop();\\n                }\\n                pq.push({-(dp[l + 1][r] + l), l});\\n                dp[l][r] = min(dp[l][m] + m + 1, -pq.top()[0]);\\n            }\\n        }\\n        return dp[1].back();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 1));\\n        for (int r = 2; r <= n; r++) {\\n            deque<array<int, 2>> window;\\n            int m = r - 1;\\n            for (int l = r - 1; l; l--) {\\n                for (; dp[l][m - 1] > dp[m + 1][r]; m--);\\n                for (; !window.empty() && window.back()[1] > m;) {\\n                    // because left part is greater than right part if we choose `window.back()[1]` as middle point\\n                    window.pop_back();\\n                }\\n                for (; dp[l + 1][r] + l <= window.front()[0];)\\n\\t\\t\\t\\t\\t// because dp[l + 1][r] + l will live longer than others, so we can simply keep the deque decreasing  \\n                    window.pop_front();\\n                window.push_front({dp[l + 1][r] + l, l});\\n                dp[l][r] = min(dp[l][m] + m + 1, window.back()[0]);\\n            }\\n        }\\n        return dp[1].back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885650,
                "title": "c-recursive-dp-minimax-solution",
                "content": "Runtime: 188 ms, faster than 25.60% of C++ online submissions for Guess Number Higher or Lower II.\\nMemory Usage: 6.3 MB, less than 90.38% of C++ online submissions for Guess Number Higher or Lower II.\\n\\nThis is a minimax game problem. To get the minimum money amount to win the game regardless of any\\nnumber is picked (worst case), we can minimize the maximum loss means we have to get max loss while we\\nplay optimally. Also it means to find the max loss that we will have when we play with optimal strategy.\\n\\nGiven N, we guess number from 1 to N and get the minimum of maximum loss. \\nIf we guess number x in range L and H and it is wrong then there are \\ntwo possible loss result from ranges (L, x-1) (pick is lower) and (x+1, H) (pick is higher), \\nalso value x is added with the max result between those two range results. \\nFinally we take the minimum among all those guesses (1 to N) max loss values. Thus the recurrence relation becomes,\\n\\n```\\nloss(l,h):\\n\\tfor i = l:h\\n\\t\\tres = min(res, i + max(loss(l,i-1),loss(i+1,h)))\\n```\\n\\nTerminating condition, if L >= H then there is no way to guess wrong and thus the loss is 0.\\n\\nAs same result is calculated multiple times we use DP collection to return the result which is already calculated. \\nDP[L][H] means the minimum of maximum guess loss in range L to H inclusive.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // dp vector contains minimum of maximum guess losses in range L and H\\n    int dp[201][201];\\n    \\n    // returns minimum of maximum guess losses in range L and H\\n    int getMinimum(int l, int h)\\n    {\\n        // base case: L>=H then there is no way to guess wrong and so loss is 0\\n        if(h<=l) return 0;\\n        \\n        // return precalculated values\\n        if(dp[l][h]!=-1) return dp[l][h];\\n        \\n        // min of max guess loss \\n        int res = INT_MAX;\\n        \\n        // guess value from L to H\\n        for(int i=l;i<=h;i++)\\n        {\\n            // guess number i and it is wrong, so the possible losses are\\n            // i+getMinimum(l,i-1) and i+getMinimum(i+1,h) and we take the max loss\\n            // get minimum loss between res and max guess loss\\n            res = min(res, i + max(getMinimum(l,i-1),getMinimum(i+1,h)));\\n        }\\n        \\n        return dp[l][h] = res;\\n    }\\n    \\n    int getMoneyAmount(int n){\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return getMinimum(1,n);\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nloss(l,h):\\n\\tfor i = l:h\\n\\t\\tres = min(res, i + max(loss(l,i-1),loss(i+1,h)))\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // dp vector contains minimum of maximum guess losses in range L and H\\n    int dp[201][201];\\n    \\n    // returns minimum of maximum guess losses in range L and H\\n    int getMinimum(int l, int h)\\n    {\\n        // base case: L>=H then there is no way to guess wrong and so loss is 0\\n        if(h<=l) return 0;\\n        \\n        // return precalculated values\\n        if(dp[l][h]!=-1) return dp[l][h];\\n        \\n        // min of max guess loss \\n        int res = INT_MAX;\\n        \\n        // guess value from L to H\\n        for(int i=l;i<=h;i++)\\n        {\\n            // guess number i and it is wrong, so the possible losses are\\n            // i+getMinimum(l,i-1) and i+getMinimum(i+1,h) and we take the max loss\\n            // get minimum loss between res and max guess loss\\n            res = min(res, i + max(getMinimum(l,i-1),getMinimum(i+1,h)));\\n        }\\n        \\n        return dp[l][h] = res;\\n    }\\n    \\n    int getMoneyAmount(int n){\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return getMinimum(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375740,
                "title": "python-recursion-with-detailed-explanation",
                "content": "The questions itself is easy to understand but to solve it actually is much harder than it seems. My intuition is to trying to find some pattern or formula to calculate the result directly since the question itself seems to fits some logarithmic divide and conquer type.  \\n\\nWhen n < 4 it\\'s trivial. Starting from n = 4, [1,2,3,4]. If you start from the median, i.e. 2, you will get 5 because if the target is 4, your sequence of guesses would be [2,3]. However, if you start with 3, if the target is 4, you are done. If the target is 2, use 1 to get it done, so the total cost would be 4.\\n\\nIf you think the search should start at the median and only need to consider the right part of the array since the cost of searching larger numbers (right) outweighs the cost of the lower part (left), you are in a wrong path.  This is only true when starting from the middle and the search pattern is the same for both left and right.\\n\\nHowever, the starting point have nothing to do with the median. In fact, from n = 4 to n = 11, the correct answer is sum of the second last and the fourth last of the array 1 to n. i.e. (n-1) + (n-3)\\n\\nStarting from n = 12, things begin to change because the cost of search 1 to 8 is larger than searching from 10 to 12. It\\'s correct that we only need to worry half of the array, but we don\\'t have a clue which half. Things change again when n = 20, the right half outweighs the left one and the correct starting point is 13.\\n\\nOut goal is to find the correct starting point, or pivot point. The cost of the search from point i is `p[i] + max(cost(p[:i]), cost(p[i+1:])]` and the candidates for the search is every other number starting from n-1 because we can always use a smaller number to find the larger one.\\n\\n```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(maxsize=None) \\n        def cost(arr):\\n            l = len(arr)\\n            if not l: return 0\\n            if l == 1: return 0\\n            if l == 2: return arr[0]\\n            if l == 3: return arr[1]\\n            minimum = float(\\'inf\\')\\n            for i in range(len(arr)-2, -1, -2):\\n                left, right = cost(arr[:i]), cost(arr[i+1:])\\n                minimum = min(minimum, max(left + arr[i], arr[i] + right))\\n            return minimum\\n        return cost(tuple(range(1, n+1)))\\n```\\n\\nI use lrc_cache as the memoization cache, for dp without recursion, you can refer to [here](https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/371367/Python-DP).\\n",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(maxsize=None) \\n        def cost(arr):\\n            l = len(arr)\\n            if not l: return 0\\n            if l == 1: return 0\\n            if l == 2: return arr[0]\\n            if l == 3: return arr[1]\\n            minimum = float(\\'inf\\')\\n            for i in range(len(arr)-2, -1, -2):\\n                left, right = cost(arr[:i]), cost(arr[i+1:])\\n                minimum = min(minimum, max(left + arr[i], arr[i] + right))\\n            return minimum\\n        return cost(tuple(range(1, n+1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84799,
                "title": "java-minmax-solution-beats-97",
                "content": "public class Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n+1][n+1];\\n        \\n        return helper(dp, 1, n);\\n    }\\n    \\n    public int helper(int[][] dp, int left, int right) {\\n        if(dp[left][right] != 0) {\\n            return dp[left][right];\\n        }\\n        \\n        if(left >= right) {\\n            return 0;\\n        } else if(left >= right - 2) {\\n            return right - 1;\\n        }\\n        \\n        int mid = left + (right-left) / 2, min = Integer.MAX_VALUE, i;\\n        \\n        for(i=mid;i<right;i++) {\\n            min = Math.min(min, i + Math.max(helper(dp, i + 1, right) , helper(dp,left,i-1)));\\n        }\\n        \\n        dp[left][right] = min;\\n        \\n        return min;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n+1][n+1];\\n        \\n        return helper(dp, 1, n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 84828,
                "title": "c-dp-solution-with-easy-understanding-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(n+2,0));\\n        for(int len = 2; len <= n; len++){  //len of range [i,i+1,...,i+len-1]\\n            for(int i = 1; i + len - 1 <= n; i++){ // the start number of the range\\n            dp[i][i+len-1] = INT_MAX;\\n                for(int j = i ; j <= i + len - 1; j++){ // guess which number first\\n                    dp[i][i+len-1] = min(dp[i][i+len-1], j + max(dp[i][j-1], dp[j+1][i+len-1]));\\n                }\\n            }\\n            \\n        }\\n        return dp[1][n];\\n    }\\n};\\n\\n````\\ndp[i][j] indicates how much money we need to guarantee a win when we guess between i and j.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(n+2,0));\\n        for(int len = 2; len <= n; len++){  //len of range [i,i+1,...,i+len-1]\\n            for(int i = 1; i + len - 1 <= n; i++){ // the start number of the range\\n            dp[i][i+len-1] = INT_MAX;\\n                for(int j = i ; j <= i + len - 1; j++){ // guess which number first\\n                    dp[i][i+len-1] = min(dp[i][i+len-1], j + max(dp[i][j-1], dp[j+1][i+len-1]));\\n                }\\n            }\\n            \\n        }\\n        return dp[1][n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282263,
                "title": "python-dp-approach",
                "content": "# Intuition\\nLet `dp` is the minimum cost for make sure we win in range `[l, r]` (inclusive).\\nIf we choose `i` and wrong, the correct answer should be in `[l, i - 1]` or `[i + 1, r]`. So if we choose `i` and wrong, we need to get maximum cost between this 2 cases + `i` for make sure we always win even the correct answer in `[l, i - 1]` or `[i + 1, r]`.\\nSo minimum cost for make sure we win if we choose `i` and wrong is `i` + `max(dp(l, i - 1), dp(i + 1, r))`.\\nTry all possible `i` in range `[l, r]` and find the minimum to get the minimum cost for make sure we win in range `[l, r]`.\\n# Code\\n```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dp(l, r):\\n            if l >= r:\\n                return 0       \\n            ans = float(\\'inf\\')     \\n            for i in range(l, r):\\n                ans = min(ans, max(dp(l, i - 1), dp(i + 1, r)) + i)\\n            return ans\\n        return dp(1, n)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dp(l, r):\\n            if l >= r:\\n                return 0       \\n            ans = float(\\'inf\\')     \\n            for i in range(l, r):\\n                ans = min(ans, max(dp(l, i - 1), dp(i + 1, r)) + i)\\n            return ans\\n        return dp(1, n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720394,
                "title": "python-5-liner",
                "content": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(maxsize=None)\\n        def helper(a, b):\\n            if a >= b: return 0\\n            return min(x + max(helper(a, x-1), helper(x+1, b)) for x in range(a, b+1))\\n        return helper(1, n)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(maxsize=None)\\n        def helper(a, b):\\n            if a >= b: return 0\\n            return min(x + max(helper(a, x-1), helper(x+1, b)) for x in range(a, b+1))\\n        return helper(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197981,
                "title": "dp-and-memo-solution-explanation",
                "content": "Question: Guess from 1->n nums, Tells you your guess is > or <, What is the best way to choose that in worst case (guessed wrong until you are certain the ans) you still have the minimum loss.\\n**In other words: Mini cost among max losses**\\nCase 1: 1 num; n=1, cost is 0; We always choose correct if only 1 choice.\\nCase 2: 2 nums; {3,4} cost is smallest num, 3 in this case. B/c they till you > or < than the target. Choose 3, knowing 4 is next, pay $3; Choose 4 will pay $4; So 3 < 4;\\nCase 3: 3 nums; {3,4,5} cost is the mid num; since they told you > or <. Guess the mid, knowing we can choose the next one Correctly. 4 in this case.\\n*Notice we can choose start 3 or 4 or 5; 3[4,5] cost 7; [3]4[5] cost 4; [3,4]5 cost 8; So 4 is the minimum cost to guarantee a win.*\\nCase 4: More than 3 nums; {2,3,4,5} Same as 3 choices, we can start with any of the 4 nums. \\nchoose 2 first: 2[3,4,5] = 2 + 4 = 6; \\nchoose 3 first: [2] 3 [4,5], this is tricky, [2]=0 or [4,5]=4 which side do you pick from? We want the worst case, which is guessing wrong and opponent will choose larger cost num. So in this case 4 > 0; so 3 + 4 = 7;\\nchoose 4 first: [2,3]4 [5], [2,3]=2 or [5]=0; opponent will choose the larger, so 2, 4+2=6;\\nchoose 5 first: [2,3,4] 5, 5+3=8;\\nSo we have 6,7,6,8; We find the mini cost 6;\\n\\nSolution: Memorize recursive, top-down\\nHow to arrive:\\n* From the analysis above, we need a range to choose from, starting with 1->n;\\n* We can choose any 1->n nums first, so a loop. Call it x.\\n* Now we can choose from **either left of x** or **right side of x**;\\n* We want the larger one between left and right. Then add it to cur x, since choosed x first.\\n* We get x + Max(func(start, i-1), func(i+1, end));\\n* The result is 1 possible mini cost. We need to find all possibilities, start with another x.\\n* **Base case** is when there is only 1 num left, we know the cost is 0;\\n* Otherwise we recurse down to smaller problem for left and right. And memorize the results.\\n* Time: O(n^3);\\n\\t* B/c we loop 1->n; for each num we recurse down i+1 and loop from 1->n again; \\n\\t* And then for each of those 1->n nums we recurse down to another 1->n; Until n times. So for not memorized it\\'s O(n^n);\\n\\t* What happen is choose start num from 1->n, for each choice we need to split and loop left and right which is n total. That is n^2; now n^2 will do the same for each, n-1; n^3; And on and on until down to 1 left;\\n\\t* We memorized, so no repeated recurse. We just traverse each different combos once. Meaning we generate all continuous subarrs, and we choose every # in that subarr. So, O(n^2) to get all continuous subarrs, O(n) to choose every possibility. \\n* Space: O(n^2);\\n\\nSolution: DP, bottom-up\\nHow to arrive:\\n* Like memo solution, we need a 2d DP to store start and end miniCosts, dp[start][end]; So an dp[n+1][n+1]; \\n* Now we need to **know the shorter range in order to get to the longest range 1->n**;\\n* Ex: {1,2,3,4} 1[2,3,4]; find the [2,3,4] first.\\n* So we need to find from the shortest range and progress to longest 1->n;\\n* We know the 1 num is 0, that is already the vals in dp. So we start with 2 num.\\n* So, for (int end = 2; end <= n; end++); Smallest range to larger.\\n* And, for (int start = end - 1; start > 0; start--); Smallest range from start->end to larger.\\n* Now we have the range, we need to choose every num in that range, get the worse case for choosing each num as 1st choice.\\n* for (int split = start + 1; split < end; split++); And, curMax = split + Math.max(dp[start][split - 1], dp[split + 1][end]);\\n* We go left and right to find the worse/largest cost between them. And add the cur choice cost to it.\\n* Now, find the miniCost among all the starting choices\\' worse costs.\\n* miniCost = Math.min(miniCost, curMax);\\n* Notice: we are spliting dp[start][split - 1] and dp[split + 1][end]. To prevent case of loop out of bounce, end+1 or start-1; the loop is for atleast 3 nums.\\n* We can check for 2 nums cases after the loop, dp[start][end] = (start + 1 == end) ? start : miniCost;\\n* Time: O(n^3); for every range (continuous subarrs) n^2, we traverse starting choices n;\\n* Space: O(n^2);",
                "solutionTags": [],
                "code": "Question: Guess from 1->n nums, Tells you your guess is > or <, What is the best way to choose that in worst case (guessed wrong until you are certain the ans) you still have the minimum loss.\\n**In other words: Mini cost among max losses**\\nCase 1: 1 num; n=1, cost is 0; We always choose correct if only 1 choice.\\nCase 2: 2 nums; {3,4} cost is smallest num, 3 in this case. B/c they till you > or < than the target. Choose 3, knowing 4 is next, pay $3; Choose 4 will pay $4; So 3 < 4;\\nCase 3: 3 nums; {3,4,5} cost is the mid num; since they told you > or <. Guess the mid, knowing we can choose the next one Correctly. 4 in this case.\\n*Notice we can choose start 3 or 4 or 5; 3[4,5] cost 7; [3]4[5] cost 4; [3,4]5 cost 8; So 4 is the minimum cost to guarantee a win.*\\nCase 4: More than 3 nums; {2,3,4,5} Same as 3 choices, we can start with any of the 4 nums. \\nchoose 2 first: 2[3,4,5] = 2 + 4 = 6; \\nchoose 3 first: [2] 3 [4,5], this is tricky, [2]=0 or [4,5]=4 which side do you pick from? We want the worst case, which is guessing wrong and opponent will choose larger cost num. So in this case 4 > 0; so 3 + 4 = 7;\\nchoose 4 first: [2,3]4 [5], [2,3]=2 or [5]=0; opponent will choose the larger, so 2, 4+2=6;\\nchoose 5 first: [2,3,4] 5, 5+3=8;\\nSo we have 6,7,6,8; We find the mini cost 6;\\n\\nSolution: Memorize recursive, top-down\\nHow to arrive:\\n* From the analysis above, we need a range to choose from, starting with 1->n;\\n* We can choose any 1->n nums first, so a loop. Call it x.\\n* Now we can choose from **either left of x** or **right side of x**;\\n* We want the larger one between left and right. Then add it to cur x, since choosed x first.\\n* We get x + Max(func(start, i-1), func(i+1, end));\\n* The result is 1 possible mini cost. We need to find all possibilities, start with another x.\\n* **Base case** is when there is only 1 num left, we know the cost is 0;\\n* Otherwise we recurse down to smaller problem for left and right. And memorize the results.\\n* Time: O(n^3);\\n\\t* B/c we loop 1->n; for each num we recurse down i+1 and loop from 1->n again; \\n\\t* And then for each of those 1->n nums we recurse down to another 1->n; Until n times. So for not memorized it\\'s O(n^n);\\n\\t* What happen is choose start num from 1->n, for each choice we need to split and loop left and right which is n total. That is n^2; now n^2 will do the same for each, n-1; n^3; And on and on until down to 1 left;\\n\\t* We memorized, so no repeated recurse. We just traverse each different combos once. Meaning we generate all continuous subarrs, and we choose every # in that subarr. So, O(n^2) to get all continuous subarrs, O(n) to choose every possibility. \\n* Space: O(n^2);\\n\\nSolution: DP, bottom-up\\nHow to arrive:\\n* Like memo solution, we need a 2d DP to store start and end miniCosts, dp[start][end]; So an dp[n+1][n+1]; \\n* Now we need to **know the shorter range in order to get to the longest range 1->n**;\\n* Ex: {1,2,3,4} 1[2,3,4]; find the [2,3,4] first.\\n* So we need to find from the shortest range and progress to longest 1->n;\\n* We know the 1 num is 0, that is already the vals in dp. So we start with 2 num.\\n* So, for (int end = 2; end <= n; end++); Smallest range to larger.\\n* And, for (int start = end - 1; start > 0; start--); Smallest range from start->end to larger.\\n* Now we have the range, we need to choose every num in that range, get the worse case for choosing each num as 1st choice.\\n* for (int split = start + 1; split < end; split++); And, curMax = split + Math.max(dp[start][split - 1], dp[split + 1][end]);\\n* We go left and right to find the worse/largest cost between them. And add the cur choice cost to it.\\n* Now, find the miniCost among all the starting choices\\' worse costs.\\n* miniCost = Math.min(miniCost, curMax);\\n* Notice: we are spliting dp[start][split - 1] and dp[split + 1][end]. To prevent case of loop out of bounce, end+1 or start-1; the loop is for atleast 3 nums.\\n* We can check for 2 nums cases after the loop, dp[start][end] = (start + 1 == end) ? start : miniCost;\\n* Time: O(n^3); for every range (continuous subarrs) n^2, we traverse starting choices n;\\n* Space: O(n^2);",
                "codeTag": "Unknown"
            },
            {
                "id": 84835,
                "title": "bottom-up-solution-for-both-worst-case-and-expected-case",
                "content": "**Original problem:** \\n\\n* Try all possible guess **i** for a given n, we want to find out which **i** gives the minimum cost.\\n* For each guess, you actually divide the original problem of size **n** into 2 smaller problem of size **x** and size **(n - x)**. Smaller size problem needs to be solved first, larger size problem needs to look up the result of smaller size problem. Base case is size of 1, cost is 0, because you always guess correctly in the first try.\\n* Use dynamic programming to solve (either bottom up or top down), be careful with edge cases when you guess is the first or the last element of the subproblem.\\n* For strategy 1 (maximum loss you could possibly face): while you guess, ALWAYS assume:\\n1. You guess the wrong number unless there is only one element left.\\n2. The target number is hiding in one of the two subproblems that has a higher cost.\\n\\nCode:\\n```\\n// solution for minimize the maximum (worst case) loss\\npublic static int solutionMax(int n) {\\n    // index 0 is not used for convenience\\n    int[][] dp = new int[n + 1][n + 1];\\n    int left = 0;\\n    int right = 0;\\n    int best = Integer.MAX_VALUE;\\n    int[][] moves = new int[n + 1][n + 1];\\n\\n    for (int step = 1; step <= n - 1; step++) {\\n        for (int i = 1; i + step <= n; i++) {\\n            best = Integer.MAX_VALUE;\\n            for (int j = i; j <= i + step; j++) {\\n                left = (j == i) ? 0 : dp[i][j - 1];\\n                right = (j == i + step) ? 0 : dp[j + 1][i + step];\\n                int bestofTwo = Math.max(left, right);\\n                if (j + bestofTwo < best) {\\n                    best = bestofTwo + j;\\n                    moves[i][i + step] = j;\\n                }\\n            }\\n            dp[i][i + step] = best;\\n        }\\n    }\\n\\n    // for the purpose of printing moves only\\n    int curL = 1;\\n    int curR = n;\\n    System.out.println(\"worst case moves: \");\\n    while (dp[curL][curR] != 0) {\\n        int curM = moves[curL][curR];\\n        System.out.print(curM + \" \");\\n        int curML = (curM == curL) ? curM : curM - 1;\\n        int curMR = (curM == curR) ? curM : curM + 1;\\n        if (dp[curL][curML] > dp[curMR][curR]) {\\n            curR = curML;\\n        } else {\\n            curL = curMR;\\n        }\\n    }\\n    System.out.println();\\n    // end of printing\\n\\n    return dp[1][n];\\n}\\n```\\n\\n**Follow-up Problem:**\\nEverything is the same except the definition of loss function. In this case,  change the assumption to:\\nWhile you are guessing number **i** over problem size n:\\n1. Consider all cases, including the case that you guess the correct number, which leads to zero cost.\\n2. When guess is wrong, calculate the weighted loss for both subproblems, instead of taking the max, take the sum of the two weighted loss value.\\n\\nCode:\\n```\\n// solution for minimize the maximum (worst case) loss\\npublic static double solutionExp(int n) {\\n    // index 0 is not used for convenience\\n    double[][] dp = new double[n + 1][n + 1];\\n    double weightedLeft = 0;\\n    double weightedRight = 0;\\n    double best = Double.MAX_VALUE;\\n    int[][] moves = new int[n + 1][n + 1];\\n\\n    for (int step = 1; step <= n - 1; step++) {\\n        for (int i = 1; i + step <= n; i++) {\\n            best = Double.MAX_VALUE;\\n            for (int j = i; j <= i + step; j++) {\\n                weightedLeft = 1.0 * ((j == i) ? 0 : dp[i][j - 1] + j)\\n                        * (j - i) / (step + 1);\\n                weightedRight = 1.0\\n                        * ((j == i + step) ? 0 : dp[j + 1][i + step] + j)\\n                        * (i + step - j) / (step + 1);\\n                double expectedCost = weightedLeft + weightedRight;\\n                if (expectedCost < best) {\\n                    best = expectedCost;\\n                    moves[i][i + step] = j;\\n                }\\n            }\\n            dp[i][i + step] = best;\\n        }\\n    }\\n\\n    // for the purpose of printing moves only\\n    int curL = 1;\\n    int curR = n;\\n    System.out.println(\"worst case moves: \");\\n    while (dp[curL][curR] != 0) {\\n        int curM = moves[curL][curR];\\n        System.out.print(curM + \" \");\\n        int curML = (curM == curL) ? curM : curM - 1;\\n        int curMR = (curM == curR) ? curM : curM + 1;\\n        if (dp[curL][curML] > dp[curMR][curR]) {\\n            curR = curML;\\n        } else {\\n            curL = curMR;\\n        }\\n    }\\n    System.out.println();\\n    // end of printing\\n\\n    return dp[1][n];\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// solution for minimize the maximum (worst case) loss\\npublic static int solutionMax(int n) {\\n    // index 0 is not used for convenience\\n    int[][] dp = new int[n + 1][n + 1];\\n    int left = 0;\\n    int right = 0;\\n    int best = Integer.MAX_VALUE;\\n    int[][] moves = new int[n + 1][n + 1];\\n\\n    for (int step = 1; step <= n - 1; step++) {\\n        for (int i = 1; i + step <= n; i++) {\\n            best = Integer.MAX_VALUE;\\n            for (int j = i; j <= i + step; j++) {\\n                left = (j == i) ? 0 : dp[i][j - 1];\\n                right = (j == i + step) ? 0 : dp[j + 1][i + step];\\n                int bestofTwo = Math.max(left, right);\\n                if (j + bestofTwo < best) {\\n                    best = bestofTwo + j;\\n                    moves[i][i + step] = j;\\n                }\\n            }\\n            dp[i][i + step] = best;\\n        }\\n    }\\n\\n    // for the purpose of printing moves only\\n    int curL = 1;\\n    int curR = n;\\n    System.out.println(\"worst case moves: \");\\n    while (dp[curL][curR] != 0) {\\n        int curM = moves[curL][curR];\\n        System.out.print(curM + \" \");\\n        int curML = (curM == curL) ? curM : curM - 1;\\n        int curMR = (curM == curR) ? curM : curM + 1;\\n        if (dp[curL][curML] > dp[curMR][curR]) {\\n            curR = curML;\\n        } else {\\n            curL = curMR;\\n        }\\n    }\\n    System.out.println();\\n    // end of printing\\n\\n    return dp[1][n];\\n}\\n```\n```\\n// solution for minimize the maximum (worst case) loss\\npublic static double solutionExp(int n) {\\n    // index 0 is not used for convenience\\n    double[][] dp = new double[n + 1][n + 1];\\n    double weightedLeft = 0;\\n    double weightedRight = 0;\\n    double best = Double.MAX_VALUE;\\n    int[][] moves = new int[n + 1][n + 1];\\n\\n    for (int step = 1; step <= n - 1; step++) {\\n        for (int i = 1; i + step <= n; i++) {\\n            best = Double.MAX_VALUE;\\n            for (int j = i; j <= i + step; j++) {\\n                weightedLeft = 1.0 * ((j == i) ? 0 : dp[i][j - 1] + j)\\n                        * (j - i) / (step + 1);\\n                weightedRight = 1.0\\n                        * ((j == i + step) ? 0 : dp[j + 1][i + step] + j)\\n                        * (i + step - j) / (step + 1);\\n                double expectedCost = weightedLeft + weightedRight;\\n                if (expectedCost < best) {\\n                    best = expectedCost;\\n                    moves[i][i + step] = j;\\n                }\\n            }\\n            dp[i][i + step] = best;\\n        }\\n    }\\n\\n    // for the purpose of printing moves only\\n    int curL = 1;\\n    int curR = n;\\n    System.out.println(\"worst case moves: \");\\n    while (dp[curL][curR] != 0) {\\n        int curM = moves[curL][curR];\\n        System.out.print(curM + \" \");\\n        int curML = (curM == curL) ? curM : curM - 1;\\n        int curMR = (curM == curR) ? curM : curM + 1;\\n        if (dp[curL][curML] > dp[curMR][curR]) {\\n            curR = curML;\\n        } else {\\n            curL = curMR;\\n        }\\n    }\\n    System.out.println();\\n    // end of printing\\n\\n    return dp[1][n];\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3585013,
                "title": "intuitive-memoization-approach-c-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat we are supposed to do is find the minimum coins that you have to spend. And this minimum coin is the maximum coin that you will have to spend in case you make series of bad guesses even with the best strategy you can make.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nfor(int i=l; i<=r; i++){\\n    ans = min(ans, i + max(solve(dp, l, i-1), solve(dp, i+1, r)));\\n}\\n```\\nThis line in my code does exactly what the last line of the previous paragraph says.\\nI am finding the best strategy. In each strategy I am acoounting for the worst case scenario.\\nIn a tree(as binary search is the strategy), we will go either left or right from the current node. So the cost will come from either left or right subtree. Hence we take max among those two.\\n\\nTo make this efficient, we will memoize this. Notice how only two parameters are variable in the recursion! (l and r). So we will use a dp array of `(n+1) * (n+1)` dimension.\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& dp, int l, int r) {\\n        if(l >= r){return 0;}\\n        if(dp[l][r] != -1){return dp[l][r];}\\n        int ans = INT_MAX;\\n        for(int i=l; i<=r; i++){\\n            ans = min(ans, i + max(solve(dp, l, i-1), solve(dp, i+1, r)));\\n        }\\n        return dp[l][r] = ans;\\n    }\\n\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        int ans = solve(dp, 1, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nfor(int i=l; i<=r; i++){\\n    ans = min(ans, i + max(solve(dp, l, i-1), solve(dp, i+1, r)));\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& dp, int l, int r) {\\n        if(l >= r){return 0;}\\n        if(dp[l][r] != -1){return dp[l][r];}\\n        int ans = INT_MAX;\\n        for(int i=l; i<=r; i++){\\n            ans = min(ans, i + max(solve(dp, l, i-1), solve(dp, i+1, r)));\\n        }\\n        return dp[l][r] = ans;\\n    }\\n\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        int ans = solve(dp, 1, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252824,
                "title": "375-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses dynamic programming to solve the problem.\\n\\nFirst, we define a 2D array dp of size (n+2) x (n+2), where dp[i][j] represents the minimum amount of money needed to guarantee a win when guessing a number between i and j inclusive.\\n\\nThen, we iterate over all possible subranges of the range [1, n], which have lengths from 1 to n, using the outer loop with variable d and the inner loop with variable i. For each subrange [i, j], we need to find the minimum cost of guessing a number.\\n\\nTo find this minimum cost, we iterate over all possible guesses k between i and j, and compute the maximum cost between guessing k and the worst-case scenario for each of the two subranges [i, k-1] and [k+1, j]. The total cost of guessing k is the sum of k and the maximum cost of the two subranges.\\n\\nWe take the minimum cost over all possible guesses k and assign this value to dp[i][j].\\n\\nFinally, the minimum cost of guessing a number between 1 and n is stored in dp[1][n] and returned.\\n\\n# Complexity\\n- Time complexity:\\n63.66%\\n\\n- Space complexity:\\n78.31%\\n\\n# Code\\n```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        # dp[i][j] := min money you need to guarantee a win of picking i..j\\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\\n\\n        # iterate over all possible subranges of [1, n]\\n        for d in range(1, n + 1):\\n            for i in range(1, n - d + 1):\\n                j = i + d\\n                # initialize dp[i][j] to infinity\\n                dp[i][j] = math.inf\\n                # iterate over all possible guesses k between i and j\\n                for k in range(i, j + 1):\\n                    # compute the maximum cost of guessing k and the worst-case scenario for each of the two subranges\\n                    cost = max(dp[i][k-1], dp[k+1][j]) + k\\n                    # take the minimum cost over all possible guesses k\\n                    dp[i][j] = min(dp[i][j], cost)\\n\\n        # the minimum cost of guessing a number between 1 and n is stored in dp[1][n]\\n        return dp[1][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        # dp[i][j] := min money you need to guarantee a win of picking i..j\\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\\n\\n        # iterate over all possible subranges of [1, n]\\n        for d in range(1, n + 1):\\n            for i in range(1, n - d + 1):\\n                j = i + d\\n                # initialize dp[i][j] to infinity\\n                dp[i][j] = math.inf\\n                # iterate over all possible guesses k between i and j\\n                for k in range(i, j + 1):\\n                    # compute the maximum cost of guessing k and the worst-case scenario for each of the two subranges\\n                    cost = max(dp[i][k-1], dp[k+1][j]) + k\\n                    # take the minimum cost over all possible guesses k\\n                    dp[i][j] = min(dp[i][j], cost)\\n\\n        # the minimum cost of guessing a number between 1 and n is stored in dp[1][n]\\n        return dp[1][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158665,
                "title": "java-dp-clean-code",
                "content": "```\\npublic int getMoneyAmount(int n) {\\n\\n\\tint dpRows = n+2;\\n\\tint dpCols = n+2;\\n\\tint[][] dp = new int[dpRows][dpCols];\\n\\n\\tfor(int lenSubArray = 1; lenSubArray<n; lenSubArray++) {\\n\\t\\tfor(int start = 1; start+lenSubArray<=n; start++) {\\n\\t\\t\\tint end = start + lenSubArray;\\n\\n\\t\\t\\tdp[start][end] = Integer.MAX_VALUE;\\n\\t\\t\\tfor(int guess = start; guess<=end; guess++) {\\n\\n\\t\\t\\t\\t// taking worst case\\n\\t\\t\\t\\tint costOfGuess = guess + Math.max(dp[start][guess-1], dp[guess+1][end]);\\n\\t\\t\\t\\tdp[start][end] = Math.min(dp[start][end], costOfGuess);\\n\\t\\t\\t}\\n\\t\\t}  \\n\\t}\\n\\treturn dp[1][n];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int getMoneyAmount(int n) {\\n\\n\\tint dpRows = n+2;\\n\\tint dpCols = n+2;\\n\\tint[][] dp = new int[dpRows][dpCols];\\n\\n\\tfor(int lenSubArray = 1; lenSubArray<n; lenSubArray++) {\\n\\t\\tfor(int start = 1; start+lenSubArray<=n; start++) {\\n\\t\\t\\tint end = start + lenSubArray;\\n\\n\\t\\t\\tdp[start][end] = Integer.MAX_VALUE;\\n\\t\\t\\tfor(int guess = start; guess<=end; guess++) {\\n\\n\\t\\t\\t\\t// taking worst case\\n\\t\\t\\t\\tint costOfGuess = guess + Math.max(dp[start][guess-1], dp[guess+1][end]);\\n\\t\\t\\t\\tdp[start][end] = Math.min(dp[start][end], costOfGuess);\\n\\t\\t\\t}\\n\\t\\t}  \\n\\t}\\n\\treturn dp[1][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848026,
                "title": "intuitive-top-down-recursion-understanding-binary-search",
                "content": "The problem was hard for me to understand originally, so I\\'ll break it down in a way I think would\\'ve helped me the most.\\n\\nThe first obvious thing about this problem is that it has something to do a binary search. A binary search is a series of guesses (a \"path\") that leads to the only possible answer. The problem says that each guess has a cost, and thus a series of guesses incurs some total cost. This is apparently what we want to minimize. However, if you are like me, it is not obvious what exactly we are comparing here.\\n\\nWhen we normally think of binary search, we almost always pick the middle element and using that to partition the search interval. We do this because it balances the left and right partition; if our guess is wrong, then we are left with either the left or right partition, which are roughly equal in size. Thus, in a standard binary search, there is only one possible path to any element.\\n\\nWhat makes this problem different is that choosing the middle element is not necessarily the best choice. Elements on one end cost more than elements on the other, so the ideal choice is somewhere closer to the heavier side and balances the cost of the left and right partitions. Unfortunately, there doesn\\'t appear to be any direct way to compute which element to guess. We are left with one option, which is to try each possible choice.\\n\\nIn more precise terms, we have a search interval that runs from L to R (inclusive).\\n\\nLet T(L, R) be the minimum cost to find *any* number in [L, R].\\n\\nIf L >= R, then there is either one or no elements remaining. No guess is required, so the cost is 0.\\n\\nOtherwise, we will need to make a guess M for some L <= M <= R.\\nIf we guess M, we would be left with two partitions: [L, M - 1] and [M + 1, R]. We can make a recursive call on these intervals to find the minimum cost to find any number in them.\\nThe cost of making guess M is:\\n\\nmax{ M, M + T(L, M - 1), M + T(M + 1, R) }\\n\\nor equivalently:\\n\\nM + max{ T(L, M - 1), T(M + 1, R) }\\n\\nWhy? The target number can be M or somewhere in the left or right partitions. You need an amount that can cover the cost in all of these cases. For example, even if it cost less to search the left partition, the target may be in the right partition, so you\\'d need at least enough money to pay for searching the right partition.\\n\\nNow that we know how to compute the cost of guessing M. We need to try all choices of M and see which choice of M *minimizes* the cost across all guesses of M.\\n\\nOur equation is thus:\\n\\nT(L, R) = min { M + max{ T(L, M - 1), T(M + 1, R) } } across all M where L <= M <= R\\n\\nWe can employ memoization to optimize the calculation. The problem depends on L and R, so we need a 2D matrix to cache the result.\\n\\nHere is an implementation:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int getMoneyAmount(int n) {\\n        dp = vector<vector<int>> (n + 1, vector<int> (n + 1, -1));\\n        return helper(1, n);\\n    }\\n    int helper(int lower, int upper) {\\n        // no or one choice, cost nothing\\n        if (lower >= upper) {\\n            return 0;\\n        }\\n        // cached result\\n        if (dp[lower][upper] != -1) {\\n            return dp[lower][upper];\\n        }\\n        // calculate minimum cost of all possible choices\\n        int min_cost = INT_MAX;\\n        for (int i = lower; i <= upper; ++i) {\\n            // calculate maximum cost of specific choice\\n            int cost = i;\\n            cost += max(helper(lower, i - 1), helper(i + 1, upper));\\n            min_cost = min(min_cost, cost);\\n        }\\n        // cache result\\n        return dp[lower][upper] = min_cost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int getMoneyAmount(int n) {\\n        dp = vector<vector<int>> (n + 1, vector<int> (n + 1, -1));\\n        return helper(1, n);\\n    }\\n    int helper(int lower, int upper) {\\n        // no or one choice, cost nothing\\n        if (lower >= upper) {\\n            return 0;\\n        }\\n        // cached result\\n        if (dp[lower][upper] != -1) {\\n            return dp[lower][upper];\\n        }\\n        // calculate minimum cost of all possible choices\\n        int min_cost = INT_MAX;\\n        for (int i = lower; i <= upper; ++i) {\\n            // calculate maximum cost of specific choice\\n            int cost = i;\\n            cost += max(helper(lower, i - 1), helper(i + 1, upper));\\n            min_cost = min(min_cost, cost);\\n        }\\n        // cache result\\n        return dp[lower][upper] = min_cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544968,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(None)\\n        def help(l, r):\\n            res = inf\\n            if l >= r: return 0\\n            for i in range((l + r) // 2, r):\\n                res = min(res, max(help(l, i - 1), help(i + 1, r)) + i)\\n                \\n            return res\\n\\n        return help(1, n)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(None)\\n        def help(l, r):\\n            res = inf\\n            if l >= r: return 0\\n            for i in range((l + r) // 2, r):\\n                res = min(res, max(help(l, i - 1), help(i + 1, r)) + i)\\n                \\n            return res\\n\\n        return help(1, n)",
                "codeTag": "Java"
            },
            {
                "id": 1489903,
                "title": "c-top-down-recursive-approach-with-memoization",
                "content": "For finding in range (l to r), choose any feasible x, and then the max cost will be = (x + the bigger of the solution to the two sub problems). \\nBase cases - single number in range -> always guess correct, 0 penalty. \\n```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int helper(int l, int r){\\n        if(l>=r)    \\n            return 0;\\n        if(dp[l][r]!=0)\\n            return dp[l][r];\\n        int ans = INT_MAX;\\n        for(int x=l; x<=r; x++){\\n            ans = min(ans, x + max(helper(l, x-1), helper(x+1, r)) );\\n        }\\n        dp[l][r] = ans;\\n        return ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        memset(dp, 0, 201*201*sizeof(int));\\n        return helper(1, n);        \\n    }\\n};\\n```\\nEdit - changed vector to array, and did memset to 0. Now time better than 89%.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int helper(int l, int r){\\n        if(l>=r)    \\n            return 0;\\n        if(dp[l][r]!=0)\\n            return dp[l][r];\\n        int ans = INT_MAX;\\n        for(int x=l; x<=r; x++){\\n            ans = min(ans, x + max(helper(l, x-1), helper(x+1, r)) );\\n        }\\n        dp[l][r] = ans;\\n        return ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        memset(dp, 0, 201*201*sizeof(int));\\n        return helper(1, n);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414845,
                "title": "c-recursion-dp-o-n3",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201]={};\\n    int fun(int l,int r)\\n    {\\n        if(l>=r) return 0;\\n        if(dp[l][r]) return dp[l][r];\\n        int ans=INT_MAX;\\n        \\n        for(int i=l;i<=r;i++)\\n            ans=min(ans,max(fun(l,i-1),fun(i+1,r))+i);\\n        return dp[l][r]=ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        return fun(1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201]={};\\n    int fun(int l,int r)\\n    {\\n        if(l>=r) return 0;\\n        if(dp[l][r]) return dp[l][r];\\n        int ans=INT_MAX;\\n        \\n        for(int i=l;i<=r;i++)\\n            ans=min(ans,max(fun(l,i-1),fun(i+1,r))+i);\\n        return dp[l][r]=ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        return fun(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210892,
                "title": "2-dp-solutions-c-with-comments-memoization-bottom-up",
                "content": "```\\nclass Solution {\\npublic:\\n    //dp[left][right] represents the min amount required to guess between left and right(inclusive)\\n    int helper(int left, int right, vector<vector<int>> &dp) {\\n        if(left >= right)\\n            return 0;\\n        if(dp[left][right] != INT_MAX)\\n            return dp[left][right];\\n        for(int i = left; i <= right; i++) { //iterate over all elements in between l and r, to find the best split\\n            int a = i + helper(left, i - 1, dp); //element to be guessed present in left subtree\\n            int b = i + helper(i + 1, right, dp); //element to be guessed present in right subtree\\n            dp[left][right] = min(dp[left][right], max(a, b)); //take max of above two choices\\n        }\\n        return dp[left][right];\\n    }\\n    \\n    int bottomUp2(int n) {\\n        if(n == 1)\\n            return 0;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, INT_MAX));\\n        for(int i = 0; i <= n; i++) {\\n            dp[i][0] = 0; //0 length array\\n            dp[i][i] = 0; //only 1 element available so takes 0 guesses so 0 rs.\\n        }\\n        for(int len = 1; len <= n; len++) { //iterate over lengths\\n            for(int left = 1; left + len- 1 <= n; left++) { //left boundary starting from 1, right = left + len - 1\\n                for(int k = left; k <= left + len - 1; k++) {\\n                    dp[left][left + len - 1] = min(\\n                                                dp[left][left + len - 1], k + //previous splits best ans stored in dp[left][right] \\n                                                max(\\n                                                    (k - 1) >= left ? dp[left][k - 1] : 0, //present in left subtree of split of split at k\\n                                                    (k + 1) <= left + len - 1 ? dp[k + 1][left + len - 1] : 0 //present in right subtree of the split at k\\n                                                )  \\n                                              );\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //dp[left][right] represents the min amount required to guess between left and right(inclusive)\\n    int helper(int left, int right, vector<vector<int>> &dp) {\\n        if(left >= right)\\n            return 0;\\n        if(dp[left][right] != INT_MAX)\\n            return dp[left][right];\\n        for(int i = left; i <= right; i++) { //iterate over all elements in between l and r, to find the best split\\n            int a = i + helper(left, i - 1, dp); //element to be guessed present in left subtree\\n            int b = i + helper(i + 1, right, dp); //element to be guessed present in right subtree\\n            dp[left][right] = min(dp[left][right], max(a, b)); //take max of above two choices\\n        }\\n        return dp[left][right];\\n    }\\n    \\n    int bottomUp2(int n) {\\n        if(n == 1)\\n            return 0;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, INT_MAX));\\n        for(int i = 0; i <= n; i++) {\\n            dp[i][0] = 0; //0 length array\\n            dp[i][i] = 0; //only 1 element available so takes 0 guesses so 0 rs.\\n        }\\n        for(int len = 1; len <= n; len++) { //iterate over lengths\\n            for(int left = 1; left + len- 1 <= n; left++) { //left boundary starting from 1, right = left + len - 1\\n                for(int k = left; k <= left + len - 1; k++) {\\n                    dp[left][left + len - 1] = min(\\n                                                dp[left][left + len - 1], k + //previous splits best ans stored in dp[left][right] \\n                                                max(\\n                                                    (k - 1) >= left ? dp[left][k - 1] : 0, //present in left subtree of split of split at k\\n                                                    (k + 1) <= left + len - 1 ? dp[k + 1][left + len - 1] : 0 //present in right subtree of the split at k\\n                                                )  \\n                                              );\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991411,
                "title": "python-recursive-dp-solution-with-inline-comments",
                "content": "```\\nfrom functools import lru_cache as cache\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        \\n        # This is a minimax problem. Find the minimum worst case for guessing in between 1 and n.\\n        \\n        # Time:\\n        # O(n^3) because there are O(n^2) possible inputs for pay_to_guess, and for each one we make O(n) guesses.\\n        \\n        # Space:\\n        # O(n^2) because we cache O(n^2) possible inputs for pay_to_guess. \\n        \\n        # Cache answers to save time.\\n        @cache(None)\\n        def pay_to_guess(lo, hi):\\n            \\n            # In this case, optimal strategy is to guess the lower number.\\n            # You are either correct and pay nothing, or wrong and pay the minimum of the two (then you guess correctly).\\n            # The latter is our worst case, so return that.\\n            if hi - lo == 1:\\n                return lo\\n            \\n            # If your guessing range is of length 1, you are at the correct number, so pay nothing.\\n            if lo == hi:\\n                return 0\\n            \\n            # Let\\'s look at every possible guess, and see what our minimum worst case is.\\n            min_ = float(\\'inf\\')\\n            for i in range(lo+1, hi):\\n                \\n                # i is our current guess.\\n                \\n                # The number is lower than i, so pay i and guess in the lower range.\\n                lower = i + pay_to_guess(lo, i-1)\\n                \\n                # The number is higher than i, so pay i and guess in the higher range.\\n                higher = i + pay_to_guess(i+1, hi)\\n                \\n                # We ignore the correct case (where we pay 0) since that cannot be our worst case.\\n                \\n                # Our worst case cost is the max of higher and lower. Update minimum worst case.\\n                min_ = min(min_, max(lower, higher))\\n            \\n            return min_\\n        \\n        return pay_to_guess(1, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfrom functools import lru_cache as cache\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        \\n        # This is a minimax problem. Find the minimum worst case for guessing in between 1 and n.\\n        \\n        # Time:\\n        # O(n^3) because there are O(n^2) possible inputs for pay_to_guess, and for each one we make O(n) guesses.\\n        \\n        # Space:\\n        # O(n^2) because we cache O(n^2) possible inputs for pay_to_guess. \\n        \\n        # Cache answers to save time.\\n        @cache(None)\\n        def pay_to_guess(lo, hi):\\n            \\n            # In this case, optimal strategy is to guess the lower number.\\n            # You are either correct and pay nothing, or wrong and pay the minimum of the two (then you guess correctly).\\n            # The latter is our worst case, so return that.\\n            if hi - lo == 1:\\n                return lo\\n            \\n            # If your guessing range is of length 1, you are at the correct number, so pay nothing.\\n            if lo == hi:\\n                return 0\\n            \\n            # Let\\'s look at every possible guess, and see what our minimum worst case is.\\n            min_ = float(\\'inf\\')\\n            for i in range(lo+1, hi):\\n                \\n                # i is our current guess.\\n                \\n                # The number is lower than i, so pay i and guess in the lower range.\\n                lower = i + pay_to_guess(lo, i-1)\\n                \\n                # The number is higher than i, so pay i and guess in the higher range.\\n                higher = i + pay_to_guess(i+1, hi)\\n                \\n                # We ignore the correct case (where we pay 0) since that cannot be our worst case.\\n                \\n                # Our worst case cost is the max of higher and lower. Update minimum worst case.\\n                min_ = min(min_, max(lower, higher))\\n            \\n            return min_\\n        \\n        return pay_to_guess(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815208,
                "title": "python3-bottom-up-with-detailed-explanation",
                "content": "Dynamic programming\\nthis should be a hard problem\\n```\\nimport sys\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        \"\"\"\\n        n = 1 -> min = 0 as there only 1 number to choose\\n        n = 1 2 -> min = 1 as you guess 1. If it is wrong then it has to be 2\\n        \\n        n = 1 2 3. You pick 2, min is 2 as it is lower than it is 1, higher than it is 3\\n        n = 1 2 3 4. if you pick 3 then min is 4 which is better than 5 if you pick 2 then 3. IMPORTANT: when you pick 3, either it gonna be higher or lower, if higher then it is 4. if lower then it either 1 or 2 which comes back to n = 1 2. Therefore, min is 1 + 3 = 4\\n        \"\"\"\\n        # O(N^2 * N) time as we traverse each pivot for every cell in the matrix | O(N^2) space\\n        matrix = [[0 for _ in range(n+1)] for i in range (n+1)]\\n        for Len in range (2,n+1):\\n            start = 1\\n            while (start + Len - 1 <= n):\\n                end = start + (Len - 1) # row:1, col: 3 --> [1,2,3] . Row:2, col 4 --> [2,3,4]\\n                # finding the minimum cost out of all pivots\\'cost\\n                cellMinValue = sys.maxsize\\n                for pivot in range(start,end + 1): # O(N)\\n                    cost = pivot\\n                    left = matrix[start][pivot - 1]\\n                    right = matrix[pivot+1][end] if pivot+1 <= end else 0\\n                    cost += max(left,right)\\n                    # example: [1,2,3,4], we going to take each number as pivot. Here we take 2 as pivot\\n                    #   cost = 2; minCost of [1] is 0 and minCost of [3,4] is 3. \\n                    #   We have to choose 2 + 3 for the worst case\\n                    cellMinValue = min(cellMinValue,cost) # minimum cost of all pivots\\'cost\\n                    \\n                matrix[start][end] = cellMinValue\\n                start += 1\\n        \\n        return matrix[1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nimport sys\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        \"\"\"\\n        n = 1 -> min = 0 as there only 1 number to choose\\n        n = 1 2 -> min = 1 as you guess 1. If it is wrong then it has to be 2\\n        \\n        n = 1 2 3. You pick 2, min is 2 as it is lower than it is 1, higher than it is 3\\n        n = 1 2 3 4. if you pick 3 then min is 4 which is better than 5 if you pick 2 then 3. IMPORTANT: when you pick 3, either it gonna be higher or lower, if higher then it is 4. if lower then it either 1 or 2 which comes back to n = 1 2. Therefore, min is 1 + 3 = 4\\n        \"\"\"\\n        # O(N^2 * N) time as we traverse each pivot for every cell in the matrix | O(N^2) space\\n        matrix = [[0 for _ in range(n+1)] for i in range (n+1)]\\n        for Len in range (2,n+1):\\n            start = 1\\n            while (start + Len - 1 <= n):\\n                end = start + (Len - 1) # row:1, col: 3 --> [1,2,3] . Row:2, col 4 --> [2,3,4]\\n                # finding the minimum cost out of all pivots\\'cost\\n                cellMinValue = sys.maxsize\\n                for pivot in range(start,end + 1): # O(N)\\n                    cost = pivot\\n                    left = matrix[start][pivot - 1]\\n                    right = matrix[pivot+1][end] if pivot+1 <= end else 0\\n                    cost += max(left,right)\\n                    # example: [1,2,3,4], we going to take each number as pivot. Here we take 2 as pivot\\n                    #   cost = 2; minCost of [1] is 0 and minCost of [3,4] is 3. \\n                    #   We have to choose 2 + 3 for the worst case\\n                    cellMinValue = min(cellMinValue,cost) # minimum cost of all pivots\\'cost\\n                    \\n                matrix[start][end] = cellMinValue\\n                start += 1\\n        \\n        return matrix[1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790344,
                "title": "detailed-explain-with-walk-through",
                "content": "#  This is called Minimax\\n ## The ideal is to find out the best strategy under the the worst case\\n1.  For example, if you have only [1], you pay 0, because you know the answer is 1\\n\\t\\t **One number, we pay Zero**\\n2.  For example, if you have [1,2]. The worst case is the number you choose is not the correct answer. Then, the best suitnation in the worst case is you pay $1, while the true number is 2\\n        **Two number, choose the smaller one**\\n3.  For example, if you have [1,2,3], \\n  A. 1 +  Subproblem(2,3) = 1 + 2 = 3\\n  B. 2 + Max(Subproblem(2), Subproblem(3)) = 2 +0 =2\\n  C. 3 + Subproblem(1,2) = 3+1 = 4 \\n            **Three Numbers, we pay the one in the middle**\\n\\n---\\n# Now, with these three base cases, you should be able to solve any minimax problems: \\n \\n Let\\'s have a practice with [1,2,3,4]\\n \\n        # Now, for [1,2,3,4]\\n        # 1 + Subproblem [2,3,4] = 1 + 3=4\\n        # 2 + Max(Subproblem[1], Subproblem[3,4]) = 2 + 3 = 5\\n        # 3 + Max(Subproblem[1,2]), Subproblem[4])=3+1 = 4\\n        # 4 + Max(Subproblem[2,3,4]) = 4 + 3 = 7\\n        # The answer will be 4\\n\\n# The brust force solution would be: This is very slow and exceed the time limit\\n\\n```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        start = 1 \\n        end = n+1\\n        def pay(start, end):\\n            if end-start == 1 or end-start ==0:return 0\\n            if end-start ==2: return start\\n            return min([i+max(pay(start,i), pay(i+1,end)) for i in range(start,end)])\\n        \\n        return pay(start,end)\\n```\\n\\n# On the second try, I used a 2D Matrix to save the subproblems that I had already solved. The runtime is 1300ms:\\n\\n```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        start,end = 1,n\\n        result = [[None]*n for _ in range(n)] # generate a 2D matrix to save the results\\n        \\n        def pay(start,end):\\n            if start > end:return 0\\n            if result[start][end]!= None:\\n                return result[start][end] # if value exist, return it\\n            else:\\n                if start==end:\\n                    result[start][end]=0 # set the diagonal to be Zero \\n                    return 0\\n                if end-start ==1:\\n                    result[start][end]=start+1 # set the first band of the matrix to be n\\n                    return start+1\\n                else:\\n                    result[start][end] = \\\\\\n                    min([i+1+max(pay(start,i-1),pay(i+1,end)) for i in range(start,end+1)])\\n                    return result[start][end]\\n                \\n        return pay(start-1,end-1) # -1 to start from result[0][0]\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        start = 1 \\n        end = n+1\\n        def pay(start, end):\\n            if end-start == 1 or end-start ==0:return 0\\n            if end-start ==2: return start\\n            return min([i+max(pay(start,i), pay(i+1,end)) for i in range(start,end)])\\n        \\n        return pay(start,end)\\n```\n```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        start,end = 1,n\\n        result = [[None]*n for _ in range(n)] # generate a 2D matrix to save the results\\n        \\n        def pay(start,end):\\n            if start > end:return 0\\n            if result[start][end]!= None:\\n                return result[start][end] # if value exist, return it\\n            else:\\n                if start==end:\\n                    result[start][end]=0 # set the diagonal to be Zero \\n                    return 0\\n                if end-start ==1:\\n                    result[start][end]=start+1 # set the first band of the matrix to be n\\n                    return start+1\\n                else:\\n                    result[start][end] = \\\\\\n                    min([i+1+max(pay(start,i-1),pay(i+1,end)) for i in range(start,end+1)])\\n                    return result[start][end]\\n                \\n        return pay(start-1,end-1) # -1 to start from result[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656489,
                "title": "need-more-explanation",
                "content": "Hi,\\n\\n    For n=10, I got 16 as output.  Can someone explain this.",
                "solutionTags": [],
                "code": "Hi,\\n\\n    For n=10, I got 16 as output.  Can someone explain this.",
                "codeTag": "Unknown"
            },
            {
                "id": 474244,
                "title": "concise-js-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar getMoneyAmount = function (n) {\\n\\n  const dp = Array(n + 1).fill(null).map(() => Array(n + 1).fill(Infinity))\\n\\n  const minimax = (l, r) => {\\n    if (l >= r) return 0\\n    if (dp[l][r] !== Infinity) return dp[l][r]\\n\\n    for (let i = l; i <= r; i++) {\\n      dp[l][r] = Math.min(dp[l][r], i + Math.max(minimax(i + 1, r), minimax(l, i - 1)))\\n    }\\n    return dp[l][r]\\n  }\\n\\n  return minimax(1, n)\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar getMoneyAmount = function (n) {\\n\\n  const dp = Array(n + 1).fill(null).map(() => Array(n + 1).fill(Infinity))\\n\\n  const minimax = (l, r) => {\\n    if (l >= r) return 0\\n    if (dp[l][r] !== Infinity) return dp[l][r]\\n\\n    for (let i = l; i <= r; i++) {\\n      dp[l][r] = Math.min(dp[l][r], i + Math.max(minimax(i + 1, r), minimax(l, i - 1)))\\n    }\\n    return dp[l][r]\\n  }\\n\\n  return minimax(1, n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176507,
                "title": "despite-confusing-description-this-is-an-awesome-problem",
                "content": "Most people (like me), got confused by the example, will immediately go to binary search, which is wrong.\\nThis is a so called \"biased\" binary search problem, meaning pivot point is not necessarily in the middle. But, there should be a pivot that will lead to optimal result. We can come up with this formula:\\noptimal cost[i, j] = min among max(dp[i][k - 1], dp[k + 1][j]) + k\\nwe want max(dp[i][k - 1], dp[k + 1][j]) because we should guarantee a win, so pick the max sub cost.\\n\\n```\\npublic int getMoneyAmount(int n) {\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 1; i <= n - len; i++) {\\n                int j = i + len;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                if (j - i == 1) {\\n                    dp[i][j] = i;\\n                } else {\\n                    for (int k = i + 1; k < j; k++) {\\n                        dp[i][j] = Math.min(dp[i][j], Math.max(dp[i][k - 1], dp[k + 1][j]) + k);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMoneyAmount(int n) {\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 1; i <= n - len; i++) {\\n                int j = i + len;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                if (j - i == 1) {\\n                    dp[i][j] = i;\\n                } else {\\n                    for (int k = i + 1; k < j; k++) {\\n                        dp[i][j] = Math.min(dp[i][j], Math.max(dp[i][k - 1], dp[k + 1][j]) + k);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666363,
                "title": "easiest-explanation-thought-process-explained",
                "content": "**Return the minimum amount of money you need to guarantee a win regardless of what number I pick.**  This is the most interesting part of the problem.\\n\\n**APPROACH:**\\n**So what exactly this statement is trying to say ?** \\n\\uD83D\\uDC49At every step we have a range of number **[start, end]** among which we can pick any number (Say X). Say the required cost of this sub-problem is **F(start, end)** .\\n\\uD83D\\uDC49After choosing X, there are 2 possibilities:\\n* Either we can go left (correctNum < X). So, our new sub-problem become F(start, X-1). (say \\'a\\', which represent the cost required if range is [start, X-1]).\\n* OR we can go right (correctNum > X). So, our new sub-problem become F(X+1, end). (say \\'b\\', which represent the cost required if range is [X+1, end]).\\n \\n\\uD83D\\uDC49 Between \\'a\\' and \\'b\\' we will consider the worst case scenario (as we need a guaranted win no matter what number I choose), that means we will choose the one incurring more cost. We will also add X to cost as we pick the wrong number. So, ```cost= max(a, b) + X```\\n\\uD83D\\uDC49 This gives **Money that I need to guarantee a win if I choose \\'X\\' at first**\\n\\nWe need to find minimum of them. That is:\\n```\\nint ans= INT_MAX;\\nfor(int X=start; X<=end; X++){\\n\\tint a= F(start, X-1); int b= F(X+1, end);\\n\\tans= min(ans, max(a, b) + X );\\n}\\n```\\n\\uD83D\\uDC49 Finally we will memoize the recursive solution.\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    int helper(int start, int end, vector<vector<int>>& dp){\\n        if(start>end){  return INT_MIN;  }\\n        if(start==end){  return 0;  }\\n        if(dp[start][end]!=-1){ return dp[start][end]; }\\n        \\n        int ans=INT_MAX;\\n        for(int i=start; i<=end; i++){\\n            int a= helper(start, i-1, dp) ; \\n            int b= helper(i+1, end, dp) ; \\n            int maxi= max(a, b) + i ;\\n            ans= min(ans, maxi);\\n        }\\n        return dp[start][end]=ans;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        return helper(1, n, dp);\\n    }\\n};\\n```\\nTime Complexity : O(N^3) || Space Complexity: O(N)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Game Theory"
                ],
                "code": "```cost= max(a, b) + X```\n```\\nint ans= INT_MAX;\\nfor(int X=start; X<=end; X++){\\n\\tint a= F(start, X-1); int b= F(X+1, end);\\n\\tans= min(ans, max(a, b) + X );\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int start, int end, vector<vector<int>>& dp){\\n        if(start>end){  return INT_MIN;  }\\n        if(start==end){  return 0;  }\\n        if(dp[start][end]!=-1){ return dp[start][end]; }\\n        \\n        int ans=INT_MAX;\\n        for(int i=start; i<=end; i++){\\n            int a= helper(start, i-1, dp) ; \\n            int b= helper(i+1, end, dp) ; \\n            int maxi= max(a, b) + i ;\\n            ans= min(ans, maxi);\\n        }\\n        return dp[start][end]=ans;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        return helper(1, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542037,
                "title": "100-binary-search-dp-optimized-js-sol-explained-with-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n-     We can utilize a technique called Binary Search with \\n      Dynamic Programming.\\n\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- The approach used in the provided code is a dynamic programming approach with memoization. Here\\'s a breakdown of the approach :-\\n\\n1. The code initializes a 2D array dp with dimensions **(n+1) x (n+1)**. \\n2. This array will be used for memoization to store the minimum cost for each sub-range of numbers.\\n3. The **calculateCost** function is a recursive helper function that computes the minimum amount needed to guarantee a win for a given range [start, end]. \\n4. It takes the start and end indices of the range as parameters.\\n5. The base case is when the start index is greater than or equal to the end index. \\n6. In this case, there are no numbers left in the range, so the cost is 0.\\n7. The code checks if the minimum cost for the current range is already calculated and stored in the dp array. \\n8. If it is, the stored value is returned to avoid redundant calculations.\\n9. If the minimum cost is not stored, the code initializes **minCost** to **Infinity**.\\n10. The code then iterates through the range of guesses, starting from the middle of the range **(Math.floor((start + end) / 2))** up to the end index.\\n11. For each guess, the code recursively calculates the cost of guessing that number and the maximum cost of the two sub-ranges (start to guess-1 and guess+1 to end) using the **calculateCost** function. \\n12. The total cost is the sum of **guess** and the **maximum of the costs for the sub-ranges**.\\n13. The code updates minCost with the minimum of the current minimum cost and the calculated cost for the current guess.\\n14. Finally, the minimum cost is stored in the dp array for the current range, and it is returned as the result.\\n15. ***The calculateCost function is initially called with the range [1, n] to find the minimum cost needed to guarantee a win for the entire range.***\\n\\n -     The approach uses memoization to avoid redundant calculations\\n       and optimizes the search process by starting the guesses from \\n       the middle of the range. This dynamic programming approach \\n       efficiently computes the minimum amount needed to guarantee a \\n       win for any given range of numbers.\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here **n** is the given number. \\n2. This is because the code utilizes dynamic programming with memoization to avoid redundant calculations.\\n3. The function **calculateCost** is called for each sub-range of numbers, and within each call, there is a loop that runs from the middle of the range to the end. \\n4. This results in a nested loop structure, with the outer loop iterating n times and the inner loop iterating approximately n/2 times on average. \\n5. Hence, the overall time complexity is O(n * n/2) or simply $$O(n^2)$$.\\n\\n\\n\\n\\n\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because the code uses a 2D array dp with dimensions **(n+1) x (n+1)** to store the memoization table. \\n2. The size of this array is proportional to the square of the given number n, resulting in a space complexity of $$O(n^2)$$.\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar getMoneyAmount = function(n) {\\n  \\n  let dp = Array(n + 1).fill(0).map(() => Array(n + 1).fill(0));\\n  \\n  function calculateCost(start, end) {\\n    \\n    if (start >= end) {\\n      return 0;\\n    }\\n\\n    if (dp[start][end] !== 0) {\\n      return dp[start][end];\\n    }\\n    \\n    let minCost = Infinity;\\n    \\n    for (let guess = Math.floor((start + end) / 2); guess <= end; guess++) {\\n      \\n      let cost = guess + Math.max(calculateCost(start, guess - 1), calculateCost(guess + 1, end));\\n      \\n      minCost = Math.min(minCost, cost);\\n    }\\n\\n    dp[start][end] = minCost;\\n    return minCost;\\n  }\\n  \\n  return calculateCost(1, n);  \\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/42322498-d5b6-4671-820d-8ddb70c6346d_1684504858.1307254.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Dynamic Programming",
                    "Game Theory"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar getMoneyAmount = function(n) {\\n  \\n  let dp = Array(n + 1).fill(0).map(() => Array(n + 1).fill(0));\\n  \\n  function calculateCost(start, end) {\\n    \\n    if (start >= end) {\\n      return 0;\\n    }\\n\\n    if (dp[start][end] !== 0) {\\n      return dp[start][end];\\n    }\\n    \\n    let minCost = Infinity;\\n    \\n    for (let guess = Math.floor((start + end) / 2); guess <= end; guess++) {\\n      \\n      let cost = guess + Math.max(calculateCost(start, guess - 1), calculateCost(guess + 1, end));\\n      \\n      minCost = Math.min(minCost, cost);\\n    }\\n\\n    dp[start][end] = minCost;\\n    return minCost;\\n  }\\n  \\n  return calculateCost(1, n);  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2653849,
                "title": "minmax-problem-just-like-egg-droping-problem",
                "content": "Minimax (sometimes MinMax, MM[1] or saddle point[2]) is a decision rule used in artificial intelligence, decision theory, game theory, statistics, and philosophy for minimizing the possible loss for a worst case (maximum loss) scenario\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][201]= {};\\n    \\n    long dfs(int start,int end){\\n        \\n        if(start >= end) return 0;\\n        if(dp[start][end]) return dp[start][end] - 1;\\n        \\n        long res = INT_MAX;\\n        \\n        for(int i = start ; i <= end;i++){\\n            res = min(res, max(dfs(start,i - 1),dfs(i + 1 ,end)) + i);\\n        }\\n        dp[start][end] = res + 1;\\n        return res;\\n    }\\n    \\n    int getMoneyAmount(int n){\\n        \\n        return dfs(1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][201]= {};\\n    \\n    long dfs(int start,int end){\\n        \\n        if(start >= end) return 0;\\n        if(dp[start][end]) return dp[start][end] - 1;\\n        \\n        long res = INT_MAX;\\n        \\n        for(int i = start ; i <= end;i++){\\n            res = min(res, max(dfs(start,i - 1),dfs(i + 1 ,end)) + i);\\n        }\\n        dp[start][end] = res + 1;\\n        return res;\\n    }\\n    \\n    int getMoneyAmount(int n){\\n        \\n        return dfs(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567633,
                "title": "c-mcm-partitioning-approach-dp-memoization",
                "content": "TC: O( N * N * N)\\nSC: O(N * N) + Auxiliary Stack Space O( N)\\n```\\nclass Solution {\\npublic:\\n    int solve(int i ,int j ,vector<vector<int>>&dp){\\n        //base case\\n        if(i>=j)\\n            return 0;\\n        \\n        //check the cache\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int mini=INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            int left = solve(i,k-1,dp);\\n            int right= solve(k+1,j,dp);\\n            int curr= k + max(left,right);\\n            mini=min(mini,curr);\\n        }\\n         return dp[i][j] =  mini;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return solve(1,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i ,int j ,vector<vector<int>>&dp){\\n        //base case\\n        if(i>=j)\\n            return 0;\\n        \\n        //check the cache\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int mini=INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            int left = solve(i,k-1,dp);\\n            int right= solve(k+1,j,dp);\\n            int curr= k + max(left,right);\\n            mini=min(mini,curr);\\n        }\\n         return dp[i][j] =  mini;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return solve(1,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510244,
                "title": "c-easy-dp-solution-similar-like-egg-dropping",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[201][201];\\n\\tint f(int s, int e) {\\n\\t\\tif (s >= e) return 0;\\n        \\n        if(dp[s][e] != -1) return dp[s][e];\\n\\t\\tint res = INT_MAX;\\n\\t\\tfor (int i = s; i <= e; ++i) {\\n\\t\\t\\tint ans = i + max(f(s, i - 1), f(i + 1, e));\\n\\t\\t\\tres = min(res, ans);\\n\\t\\t}\\n\\t\\treturn dp[s][e] = res;\\n\\t}\\npublic:\\n\\tint getMoneyAmount(int n) {\\n        memset(dp, -1, sizeof(dp));\\n\\t\\treturn f(1, n);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[201][201];\\n\\tint f(int s, int e) {\\n\\t\\tif (s >= e) return 0;\\n        \\n        if(dp[s][e] != -1) return dp[s][e];\\n\\t\\tint res = INT_MAX;\\n\\t\\tfor (int i = s; i <= e; ++i) {\\n\\t\\t\\tint ans = i + max(f(s, i - 1), f(i + 1, e));\\n\\t\\t\\tres = min(res, ans);\\n\\t\\t}\\n\\t\\treturn dp[s][e] = res;\\n\\t}\\npublic:\\n\\tint getMoneyAmount(int n) {\\n        memset(dp, -1, sizeof(dp));\\n\\t\\treturn f(1, n);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508377,
                "title": "simple-dp-step-by-step-solution-recursion-memoisation-tabulation",
                "content": "STEP 1: first find the maximum value of worst guess cost of 1 to n(using loop)\\nSTEP 2: then find minimum of all the value\\n```\\nclass Solution {\\npublic:\\n    //Recursion\\n   /* int solve(int start,int end ){\\n        if(start>=end) return 0;\\n        int mini=INT_MAX;\\n        for(int i=start;i<=end;i++){\\n            mini=min(mini,i+max(solve(start,i-1),solve(i+1,end)));\\n        }\\n        return mini;\\n        \\n    }*/\\n    //Recursion+Memoisation\\n  /*  int solveMem(int start,int end,vector<vector<int>>& dp){\\n        if(start>=end) return 0;\\n        if(dp[start][end]!=-1) return dp[start][end];\\n        int mini=INT_MAX;\\n        for(int i=start;i<=end;i++){\\n            mini=min(mini,i+max(solveMem(start,i-1,dp),solveMem(i+1,end,dp)));\\n        }\\n        return dp[start][end]= mini;\\n    }*/\\n    int solveTab(int n){\\n        vector<vector<int>> dp(n+2,vector<int>(n+2,0));\\n        for(int start=n;start>=1;start--){\\n            for(int end=start+1;end<=n;end++){\\n                 int mini=INT_MAX;\\n                 for(int i=start;i<=end;i++){\\n                  mini=min(mini,i+max(dp[start][i-1],dp[i+1][end]));\\n        }\\n            dp[start][end]= mini;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n    int getMoneyAmount(int n) {\\n         \\n        //Recursion\\n       // return solve(start,end);\\n        //Recursion+Memoisation\\n        // vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        // return solveMem(start,end,dp);\\n        return solveTab(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Recursion\\n   /* int solve(int start,int end ){\\n        if(start>=end) return 0;\\n        int mini=INT_MAX;\\n        for(int i=start;i<=end;i++){\\n            mini=min(mini,i+max(solve(start,i-1),solve(i+1,end)));\\n        }\\n        return mini;\\n        \\n    }*/\\n    //Recursion+Memoisation\\n  /*  int solveMem(int start,int end,vector<vector<int>>& dp){\\n        if(start>=end) return 0;\\n        if(dp[start][end]!=-1) return dp[start][end];\\n        int mini=INT_MAX;\\n        for(int i=start;i<=end;i++){\\n            mini=min(mini,i+max(solveMem(start,i-1,dp),solveMem(i+1,end,dp)));\\n        }\\n        return dp[start][end]= mini;\\n    }*/\\n    int solveTab(int n){\\n        vector<vector<int>> dp(n+2,vector<int>(n+2,0));\\n        for(int start=n;start>=1;start--){\\n            for(int end=start+1;end<=n;end++){\\n                 int mini=INT_MAX;\\n                 for(int i=start;i<=end;i++){\\n                  mini=min(mini,i+max(dp[start][i-1],dp[i+1][end]));\\n        }\\n            dp[start][end]= mini;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n    int getMoneyAmount(int n) {\\n         \\n        //Recursion\\n       // return solve(start,end);\\n        //Recursion+Memoisation\\n        // vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        // return solveMem(start,end,dp);\\n        return solveTab(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706294,
                "title": "very-simple-c-dp-solution-with-pen-paper-visual-explanation-very-easy-to-understand",
                "content": "In this question we have to find the minimum amount of money required to win the game given some constraints. So this problem can easily be broken into subproblems. For each of the number between 1-n we will consider the case where this number is choosen by the player first and we will always consider this as a wrong choice. For example when n = 10 and the player guess the 1 as the first number then cost is 1 and again he have to choose from the range of 2-10. So to generalize this\\n\\n1....... i........ n. Suppose i is any number between 1 to n. Then if player choose i as first number (which we will consider as wrong choice because we want to consider the worst case to find our answer), then we will be left with two choice either our answer is in range (1..... i-1) or (i+1 ..... n). So we have to consider max amoung these two cases. If this sounds confusing then see the explanation below for n= 3\\n\\n![image](https://assets.leetcode.com/users/images/ee0c92e7-88a6-4446-a9cc-3158547ae0d5_1642746023.1117773.jpeg)\\n\\nSee my code for more understanding\\n\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(n+2));\\n        for(int len = 2;len <= n; ++len){\\n            int l = 1, r = len;\\n            while(r <= n) {\\n                int ans = INT_MAX;\\n                for(int i=l; i<=r; i++){\\n                    ans = min(ans, i + max(dp[l][i-1], dp[i+1][r]));\\n                }\\n                dp[l][r] = ans;\\n                l++, r++;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+2, vector<int>(n+2));\\n        for(int len = 2;len <= n; ++len){\\n            int l = 1, r = len;\\n            while(r <= n) {\\n                int ans = INT_MAX;\\n                for(int i=l; i<=r; i++){\\n                    ans = min(ans, i + max(dp[l][i-1], dp[i+1][r]));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1597697,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n+1][n+1];\\n        getMoneyAmount(1,n,dp);\\n        return dp[1][n];\\n    }\\n    \\n    private int getMoneyAmount(int start,int end,int[][] dp) {\\n        if(start>=end)\\n            return 0;\\n        if(dp[start][end]!=0)\\n            return dp[start][end];\\n        int minCost = Integer.MAX_VALUE;\\n        for(int i=start;i<=end;i++) {\\n            int cost=i+Math.max(getMoneyAmount(start,i-1,dp), getMoneyAmount(i+1,end,dp));\\n            minCost=Math.min(minCost,cost);\\n        }\\n        dp[start][end]=minCost;\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n+1][n+1];\\n        getMoneyAmount(1,n,dp);\\n        return dp[1][n];\\n    }\\n    \\n    private int getMoneyAmount(int start,int end,int[][] dp) {\\n        if(start>=end)\\n            return 0;\\n        if(dp[start][end]!=0)\\n            return dp[start][end];\\n        int minCost = Integer.MAX_VALUE;\\n        for(int i=start;i<=end;i++) {\\n            int cost=i+Math.max(getMoneyAmount(start,i-1,dp), getMoneyAmount(i+1,end,dp));\\n            minCost=Math.min(minCost,cost);\\n        }\\n        dp[start][end]=minCost;\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417811,
                "title": "java-top-down-dp",
                "content": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n + 1][n + 1];\\n        helper(0, n, dp);\\n        return dp[1][n];\\n    }\\n    \\n    int helper(int start, int end, int[][] dp) {\\n        if (start >= end)\\n            return 0;\\n        \\n        if (dp[start][end] != 0)\\n            return dp[start][end];\\n        \\n        int amount = Integer.MAX_VALUE;\\n        \\n        for (int k = start; k <= end; k++) {\\n            int maxAmountNeededOnEitherSideOfPivot = Math.max(helper(start, k - 1, dp), helper(k + 1, end, dp));\\n            amount = Math.min(amount, maxAmountNeededOnEitherSideOfPivot + k);\\n        }\\n        \\n        return dp[start][end] = amount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n + 1][n + 1];\\n        helper(0, n, dp);\\n        return dp[1][n];\\n    }\\n    \\n    int helper(int start, int end, int[][] dp) {\\n        if (start >= end)\\n            return 0;\\n        \\n        if (dp[start][end] != 0)\\n            return dp[start][end];\\n        \\n        int amount = Integer.MAX_VALUE;\\n        \\n        for (int k = start; k <= end; k++) {\\n            int maxAmountNeededOnEitherSideOfPivot = Math.max(helper(start, k - 1, dp), helper(k + 1, end, dp));\\n            amount = Math.min(amount, maxAmountNeededOnEitherSideOfPivot + k);\\n        }\\n        \\n        return dp[start][end] = amount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407609,
                "title": "c-dp-solution-with-explanation",
                "content": "For such decision based problems, intuition might tell us to divide our problem into two equal subproblems, as doing so would maintain balance in our structure. However, in this problem, we are not concerned with the size of the subproblems but rather their cost.\\nConsider a simple example:\\n\\nSuppose *n*  = 5.\\n1.Going with the equal subproblems strategy, we will first guess the number 3, and then guess number 4. If the correct answer was 5, the cost would be --> 3 + 4 = 7.\\n2. Assume we have an algorithm that tells us to guess 2 first, and then guess 4. In this case, the final cost would be --> 2 + 4 = 6.\\n\\nSo it\\'s pretty obvious that choosing the middle won\\'t give us the optimal cost here.\\n(Notice how we only chose the right hand side in the above  example. This is because we only want to consider the worst case scenario as that would lead to the maximum required cost, and our goal is to minimise this maximum required cost.)\\n\\n**Approach:** The idea is to choose only the best pivot for a given range. To do so, we could iterate over all possible pivots from starting number to ending number, and calculate their cost in the worst case scenario. Finally, we will choose the pivot which gives minimum cost . This is a typical *MinMax* problem.\\n\\n* One way to implement this is by recursively calling our function for every range we encounter. However, we\\'ll have to use memoization to meet the time limits.\\n* Or, we could implement a dynamic programming approach with a 2-D DP matrix. Dp(i,j) would store the answer for range [i,j].\\n\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int i=1;i<n;i++)\\n            dp[i][i+1] = i;\\n        \\n        for(int gap=2;gap<n;gap++) {  //Fill dp vector diagonally.\\n            for(int start = 1;start+gap<=n;start++) {\\n                int end = start + gap; \\n                //dp[i][j] = minimum amount of money to guarantee win if i---j range is given.\\n                // i) In range start----end, one by one take every element as pivot.\\n                // ii) For a particular pivot, consider only the worst case.\\n                // iii) From worst case costs of all pivots, return the minimum cost.\\n                // That will be the minimum cost to guarantee a win in start-----end range.\\n                \\n                int minMaxCost = INT_MAX; //Minimum cost required to guarantee win in range.\\n                for(int pivot = start;pivot<=end;pivot++) {\\n                    int leftCost = dp[start][pivot-1]; //If number was to the left of pivot.\\n                    int rightCost = pivot < end ? dp[pivot+1][end] : 0; //To right of pivot.\\n                    int cost = max(leftCost,rightCost) + pivot; //Consider worst case for pivot.\\n                    \\n                    minMaxCost = min(minMaxCost,cost); //Update ans for given range.\\n                }\\n                dp[start][end] = minMaxCost;\\n            }\\n        }\\n        \\n        //Final answer is at dp[1][n], i.e. when start = 1 and end = n.\\n        return dp[1][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int i=1;i<n;i++)\\n            dp[i][i+1] = i;\\n        \\n        for(int gap=2;gap<n;gap++) {  //Fill dp vector diagonally.\\n            for(int start = 1;start+gap<=n;start++) {\\n                int end = start + gap; \\n                //dp[i][j] = minimum amount of money to guarantee win if i---j range is given.\\n                // i) In range start----end, one by one take every element as pivot.\\n                // ii) For a particular pivot, consider only the worst case.\\n                // iii) From worst case costs of all pivots, return the minimum cost.\\n                // That will be the minimum cost to guarantee a win in start-----end range.\\n                \\n                int minMaxCost = INT_MAX; //Minimum cost required to guarantee win in range.\\n                for(int pivot = start;pivot<=end;pivot++) {\\n                    int leftCost = dp[start][pivot-1]; //If number was to the left of pivot.\\n                    int rightCost = pivot < end ? dp[pivot+1][end] : 0; //To right of pivot.\\n                    int cost = max(leftCost,rightCost) + pivot; //Consider worst case for pivot.\\n                    \\n                    minMaxCost = min(minMaxCost,cost); //Update ans for given range.\\n                }\\n                dp[start][end] = minMaxCost;\\n            }\\n        }\\n        \\n        //Final answer is at dp[1][n], i.e. when start = 1 and end = n.\\n        return dp[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320819,
                "title": "clear-and-simple-python-solution",
                "content": "This is a Dynamic Programming solution directly\\ntranslating the recurssive function into code.\\nWe use the ```@cache``` decorator for memoization.\\n\\nComplexity:\\n*O(n<sup>3</sup>)*\\n\\n```\\ndef getMoneyAmount(self, n):\\n\\t@functools.cache\\n\\tdef cost(i, j):\\n\\t\\tif i >= j:\\n\\t\\t\\treturn 0\\n\\t\\treturn min(max(cost(i, p - 1), cost(p + 1, j)) + p\\n\\t\\t\\t\\t   for p in range(i, j + 1))\\n\\treturn cost(1, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```@cache```\n```\\ndef getMoneyAmount(self, n):\\n\\t@functools.cache\\n\\tdef cost(i, j):\\n\\t\\tif i >= j:\\n\\t\\t\\treturn 0\\n\\t\\treturn min(max(cost(i, p - 1), cost(p + 1, j)) + p\\n\\t\\t\\t\\t   for p in range(i, j + 1))\\n\\treturn cost(1, n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1076705,
                "title": "java-simple-top-down-dp-recursion",
                "content": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        \\n        int[][] dp = new int[n+1][n+1];\\n\\t\\t\\n        return getMoney(1, n, dp);\\n    }\\n\\n    private int getMoney(int l, int r, int[][] dp){\\n        \\n        if(l==r)\\n            return 0;\\n        if(l+1 == r)\\n            return l;\\n        \\n        if(dp[l][r] > 0) return dp[l][r];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        \\n        for(int k=l+1; k < r; k++){\\n             ans = Math.min(ans, k + Math.max( getMoney(l,k-1,dp), getMoney(k+1, r,dp)) );\\n        }\\n        \\n        dp[l][r] = ans;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        \\n        int[][] dp = new int[n+1][n+1];\\n\\t\\t\\n        return getMoney(1, n, dp);\\n    }\\n\\n    private int getMoney(int l, int r, int[][] dp){\\n        \\n        if(l==r)\\n            return 0;\\n        if(l+1 == r)\\n            return l;\\n        \\n        if(dp[l][r] > 0) return dp[l][r];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        \\n        for(int k=l+1; k < r; k++){\\n             ans = Math.min(ans, k + Math.max( getMoney(l,k-1,dp), getMoney(k+1, r,dp)) );\\n        }\\n        \\n        dp[l][r] = ans;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062431,
                "title": "why-this-dp-approach-gives-wrong-result-starting-from-some-step",
                "content": "The idea is to store both the result value, which is the \"minimum amount of money you need to guarantee a win regardless of what number I pick\" if the optimal strategy is chosen, and the maximum number of steps needed for that particular money to guess any number.\\n\\nWhat I\\'m claiming is the strategy for `[i+1, ... n]` is the same as for `[1 ... n-i]`, therefore if one knows the result for `[1 ... n-i]` with the maximum steps number, one can deduce the result for `[i+1 ... n]` as `res(i+1, n) = res(1, n-i) + k * i`.\\n\\nWe still use min-max idea and bottom-up dynamic programming, but what\\'s wrong with this solution? It fails starting from `n = 62`.\\n```\\n   int getMoneyAmount(int n) {\\n        if (n < 3) return n-1;\\n\\n        vector<pair<int, int>> dp(n+1);\\n        dp[1] = {0, 0};\\n        dp[2] = {1, 1};\\n        \\n        for (int j = 3; j <= n; ++j) {\\n            int res = INT_MAX, k = INT_MAX;\\n            for (int i = 2; i < j; ++i) {\\n                auto [v1, k1] = dp[i-1];\\n                auto [v2, k2] = dp[j-i];\\n                v2 += k2 * i;\\n                \\n                int r = max(v1, v2) + i, q = 1 + max(k1, k2);\\n                if (r == res)\\n                    k = min(k, q);\\n                else if (r < res)\\n                    res = r, k = q;\\n            }\\n            dp[j] = {res, k};\\n        }\\n        \\n        return dp[n].first;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int getMoneyAmount(int n) {\\n        if (n < 3) return n-1;\\n\\n        vector<pair<int, int>> dp(n+1);\\n        dp[1] = {0, 0};\\n        dp[2] = {1, 1};\\n        \\n        for (int j = 3; j <= n; ++j) {\\n            int res = INT_MAX, k = INT_MAX;\\n            for (int i = 2; i < j; ++i) {\\n                auto [v1, k1] = dp[i-1];\\n                auto [v2, k2] = dp[j-i];\\n                v2 += k2 * i;\\n                \\n                int r = max(v1, v2) + i, q = 1 + max(k1, k2);\\n                if (r == res)\\n                    k = min(k, q);\\n                else if (r < res)\\n                    res = r, k = q;\\n            }\\n            dp[j] = {res, k};\\n        }\\n        \\n        return dp[n].first;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1027946,
                "title": "easy-memoized-approach-93",
                "content": "Lets first define a state [l, r] -- which means min sufficient amount to do guess work for nos in range [l, r]\\nBase Cases:\\n\\t\\tdp[i][i] = 0\\n\\t\\tdp[i][i+1] = i\\n\\t\\nLets say solver(i, j) returns the solution for nos in segment [i, i+1, i+2,.....,j] so when we are given segment [l, r] we can choose any element i which is in range [l, r] which divides the problem into [l, i-1] and [i+1, r] and we only need to consider the maximum out of thes branches to solve our complete problem.\\n\\n```\\nclass Solution{\\n    int dp[210][210];\\npublic:\\n    int solver(int l, int r){\\n        if(dp[l][r]!=INT_MAX)\\n            return dp[l][r]; // already solved\\n        \\n        for(int i=l+1;i<r;i++)\\n            dp[l][r] = min(dp[l][r], i + max(solver(i+1, r), solver(l, i-1))); // take i as guess break into 2 parts and choose maximum of the 2 broken segments\\n        \\n        return dp[l][r];\\n    }\\n    \\n    int getMoneyAmount(int n){\\n        int i, j;\\n        if(n==1)\\n            return 0; // Base Case\\n        \\n        if(n<4)\\n            return n-1; // Base Case\\n        \\n        for(i=0;i<210;i++)\\n            for(j=0;j<210;j++)\\n                dp[i][j] = INT_MAX;\\n        \\n        for(i=0;i<209;i++){\\n            dp[i][i] = 0;\\n            dp[i][i+1] = i; // Solution for Smaller Subproblems initialized\\n        }\\n        \\n        return solver(1, n); // initial segment [1, n]\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution{\\n    int dp[210][210];\\npublic:\\n    int solver(int l, int r){\\n        if(dp[l][r]!=INT_MAX)\\n            return dp[l][r]; // already solved\\n        \\n        for(int i=l+1;i<r;i++)\\n            dp[l][r] = min(dp[l][r], i + max(solver(i+1, r), solver(l, i-1))); // take i as guess break into 2 parts and choose maximum of the 2 broken segments\\n        \\n        return dp[l][r];\\n    }\\n    \\n    int getMoneyAmount(int n){\\n        int i, j;\\n        if(n==1)\\n            return 0; // Base Case\\n        \\n        if(n<4)\\n            return n-1; // Base Case\\n        \\n        for(i=0;i<210;i++)\\n            for(j=0;j<210;j++)\\n                dp[i][j] = INT_MAX;\\n        \\n        for(i=0;i<209;i++){\\n            dp[i][i] = 0;\\n            dp[i][i+1] = i; // Solution for Smaller Subproblems initialized\\n        }\\n        \\n        return solver(1, n); // initial segment [1, n]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935747,
                "title": "elegant-python-dp-improved-solution-with-3-groups-99",
                "content": "For instance, let\\'s consider the list of potential guesses for n = 12:\\n1 2 3 4 5 6 7 8 9 10 11 12\\nAny guessing path set must include 11, because it\\'s the optimal way to test 12. Guessing 11 also give a clue about 10. So we can group numbers by 3 in every guessing path set, starting form the end.\\n(1 2 3 4) 5 (6 7 8) 9 (10 11 12)\\nSo now the question is only should we start by 5 or by 9 ?\\n\\nThe \"@lru_cache\" decorator allows memoization of intermediate results.  \\nP.S. All solutions for n < 5 are special cases handled separatly \\n\\n````\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(maxsize=None)\\n        def rec(a, b):\\n            if b < 5:\\n                return [0, 0, 1, 2, 4][b]\\n            elif b == a+2:\\n                return a+1\\n            else:\\n                return min(i + max(rec(a,i-1),rec(i+1,b)) for i in range(b-3, a, -4))\\n        return rec(1, n)\\n\\t",
                "solutionTags": [],
                "code": "For instance, let\\'s consider the list of potential guesses for n = 12:\\n1 2 3 4 5 6 7 8 9 10 11 12\\nAny guessing path set must include 11, because it\\'s the optimal way to test 12. Guessing 11 also give a clue about 10. So we can group numbers by 3 in every guessing path set, starting form the end.\\n(1 2 3 4) 5 (6 7 8) 9 (10 11 12)\\nSo now the question is only should we start by 5 or by 9 ?\\n\\nThe \"@lru_cache\" decorator allows memoization of intermediate results.  \\nP.S. All solutions for n < 5 are special cases handled separatly \\n\\n````\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        @lru_cache(maxsize=None)\\n        def rec(a, b):\\n            if b < 5:\\n                return [0, 0, 1, 2, 4][b]\\n            elif b == a+2:\\n                return a+1\\n            else:\\n                return min(i + max(rec(a,i-1),rec(i+1,b)) for i in range(b-3, a, -4))\\n        return rec(1, n)\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 864332,
                "title": "minimax-with-dp-in-python-with-recursion-tree-plotted",
                "content": "Runtime : O(n^3)\\n```\\nclass Solution:\\n    \\n    def minAmt(self, l, h, dp):    \\n\\n        if (l, h) in dp:\\n            return dp[(l, h)]\\n\\n        elif l >= h:\\n            return 0\\n\\n        _min = float(\"+inf\")\\n        for i in range(l, h+1):\\n            _min = min(_min, i + max(self.minAmt(l, i-1, dp), self.minAmt(i+1, h, dp)))\\n        dp[(l, h)] =_min    \\n        return _min\\n\\n            \\n    \\n    def getMoneyAmount(self, n: int) -> int:        \\n        return self.minAmt(1, n, dict())\\n```\\n\\nRecursion Tree for n=3:\\n![image](https://assets.leetcode.com/users/images/81d3183f-f04e-41bb-924d-7bf70afebcd1_1601065353.7143068.png)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def minAmt(self, l, h, dp):    \\n\\n        if (l, h) in dp:\\n            return dp[(l, h)]\\n\\n        elif l >= h:\\n            return 0\\n\\n        _min = float(\"+inf\")\\n        for i in range(l, h+1):\\n            _min = min(_min, i + max(self.minAmt(l, i-1, dp), self.minAmt(i+1, h, dp)))\\n        dp[(l, h)] =_min    \\n        return _min\\n\\n            \\n    \\n    def getMoneyAmount(self, n: int) -> int:        \\n        return self.minAmt(1, n, dict())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779132,
                "title": "dp-solution-c-with-one-line-desciption-of-question",
                "content": "One Line Description - \\nYou have to find the minimum amount of money for which you can guess a number in worst case.\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j,vector<vector<int>>& dp){\\n        if(i>=j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int res = INT_MAX;\\n        for(int k=i; k<=j; k++){\\n            int tmp = k + max(solve(i,k-1,dp), solve(k+1,j,dp));\\n            if(res>tmp)\\n                res = tmp;\\n        }\\n        return dp[i][j] = res;\\n        \\n    }\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(1,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j,vector<vector<int>>& dp){\\n        if(i>=j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int res = INT_MAX;\\n        for(int k=i; k<=j; k++){\\n            int tmp = k + max(solve(i,k-1,dp), solve(k+1,j,dp));\\n            if(res>tmp)\\n                res = tmp;\\n        }\\n        return dp[i][j] = res;\\n        \\n    }\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(1,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650139,
                "title": "java-dp-with-comments",
                "content": "```\\n/* \\tCredits: https://harunscorner.wordpress.com/2016/09/04/leetcode-guess-number-higher-or-lower-ii-solution/\\n * \\tLet\\u2019s take an instance, for n = 3, we have 3 choices either to choose 1 or 2 or 3.\\n\\tLet\\u2019s say we choose 1. There are 2 possible chances,\\n\\n\\t[Case X]: 1 is the actual number so you pay 0$ or,\\n\\t[Case Y]: 1 is not the actual number so you pay 1$ (now you know that the actual number is > 1 because for every guess we will know if its less than or greater than, in our case it can only be greater than) and have the subproblem (2, 3). To choose from (2, 3) again recursively applying the same method, you can choose either 2 or 3. If you pick 2, you have 2 possible outcomes again. 2 is the actual number and you pay 0$ for this choice or 2 is not the actual number and you pay 2$ for this choice and you know 3 is the answer since that\\u2019s the only one left. On the other hand, if you had picked 3, then either 3 is correct or you pay 3$ and know 2 is the actual answer since it\\u2019s the only one left. So to sum up this, you pay 2$ in the worst case if you choose 2 or pay 3$ in the worst case if you pick 3$. So we will pick the min of the worst cases which is 2$ and hence 2 is the answer for (2, 3) subproblem. (Notice the minimax? \\uD83D\\uDE09 ) So, the total cost paid in this is 1$ + 2$ = 3$.\\n\\tLet\\u2019s say you picked 2 initially. You have 2 possible outcomes.\\n\\n\\t2 is the actual number and you pay 0$ or,\\n\\t2 is not the actual number and you pay 2$. \\n\\tAt this point, you get to know if the actual number is less than or greater than the actual number. \\n\\tSo, you will know the answer right away without another guess. So you end up paying 2$.\\n\\tSo, if you choose 2 initially, you risk paying 2$ at most.\\n\\tSimilarly, if you had chosen 3 initially, you risk paying 4$ at most. \\n\\tHence picking 2 initially is the best option and you risk at most 2$.\\n\\n\\n\\tLet\\u2019s say you picked 2 initially. You have 2 possible outcomes.\\n\\n\\t2 is the actual number and you pay 0$ or,\\n\\t2 is not the actual number and you pay 2$. \\n\\tAt this point, you get to know if the actual number is less than or greater than the actual number. \\n\\tSo, you will know the answer right away without another guess. So you end up paying 2$.\\n\\tSo, if you choose 2 initially, you risk paying 2$ at most.\\n\\tSimilarly, if you had chosen 3 initially, you risk paying 4$ at most. \\n\\tHence picking 2 initially is the best option and you risk at most 2$.\\n\\n\\t * 1 2 3 4 5\\n\\t * 1: 1+ [2,3,4,5]\\n\\t * 2: 2+ max([1], [3,4,5])\\n\\t * 3: 3+ max([1,2], [4,5])\\n\\t * 4: 4+ max([1,2,3], [5])\\n\\t * 5: 5+ [1,2,3,4]\\n */\\npublic int getMoneyAmount(int n) {\\n\\tint[][] table = new int[n + 1][n + 1];\\n\\treturn helper(table, 1, n);\\n}\\n\\npublic int helper(int[][] table, int start, int end) {\\n\\tif (start >= end)\\n\\t\\treturn 0;\\n\\n\\tif (table[start][end] > 0)\\n\\t\\treturn table[start][end];\\n\\n\\tint ans = Integer.MAX_VALUE;\\n\\n\\tfor (int x = start + (end - start) / 2; x <= end; x++) {\\n\\t\\ttable[start][end] = x + Math.max(helper(table, start, x - 1), helper(table, x + 1, end));\\n\\t\\tans = Math.min(ans, table[start][end]);\\n\\t}\\n\\n\\ttable[start][end] = ans;\\n\\treturn table[start][end];\\n}",
                "solutionTags": [],
                "code": "```\\n/* \\tCredits: https://harunscorner.wordpress.com/2016/09/04/leetcode-guess-number-higher-or-lower-ii-solution/\\n * \\tLet\\u2019s take an instance, for n = 3, we have 3 choices either to choose 1 or 2 or 3.\\n\\tLet\\u2019s say we choose 1. There are 2 possible chances,\\n\\n\\t[Case X]: 1 is the actual number so you pay 0$ or,\\n\\t[Case Y]: 1 is not the actual number so you pay 1$ (now you know that the actual number is > 1 because for every guess we will know if its less than or greater than, in our case it can only be greater than) and have the subproblem (2, 3). To choose from (2, 3) again recursively applying the same method, you can choose either 2 or 3. If you pick 2, you have 2 possible outcomes again. 2 is the actual number and you pay 0$ for this choice or 2 is not the actual number and you pay 2$ for this choice and you know 3 is the answer since that\\u2019s the only one left. On the other hand, if you had picked 3, then either 3 is correct or you pay 3$ and know 2 is the actual answer since it\\u2019s the only one left. So to sum up this, you pay 2$ in the worst case if you choose 2 or pay 3$ in the worst case if you pick 3$. So we will pick the min of the worst cases which is 2$ and hence 2 is the answer for (2, 3) subproblem. (Notice the minimax? \\uD83D\\uDE09 ) So, the total cost paid in this is 1$ + 2$ = 3$.\\n\\tLet\\u2019s say you picked 2 initially. You have 2 possible outcomes.\\n\\n\\t2 is the actual number and you pay 0$ or,\\n\\t2 is not the actual number and you pay 2$. \\n\\tAt this point, you get to know if the actual number is less than or greater than the actual number. \\n\\tSo, you will know the answer right away without another guess. So you end up paying 2$.\\n\\tSo, if you choose 2 initially, you risk paying 2$ at most.\\n\\tSimilarly, if you had chosen 3 initially, you risk paying 4$ at most. \\n\\tHence picking 2 initially is the best option and you risk at most 2$.\\n\\n\\n\\tLet\\u2019s say you picked 2 initially. You have 2 possible outcomes.\\n\\n\\t2 is the actual number and you pay 0$ or,\\n\\t2 is not the actual number and you pay 2$. \\n\\tAt this point, you get to know if the actual number is less than or greater than the actual number. \\n\\tSo, you will know the answer right away without another guess. So you end up paying 2$.\\n\\tSo, if you choose 2 initially, you risk paying 2$ at most.\\n\\tSimilarly, if you had chosen 3 initially, you risk paying 4$ at most. \\n\\tHence picking 2 initially is the best option and you risk at most 2$.\\n\\n\\t * 1 2 3 4 5\\n\\t * 1: 1+ [2,3,4,5]\\n\\t * 2: 2+ max([1], [3,4,5])\\n\\t * 3: 3+ max([1,2], [4,5])\\n\\t * 4: 4+ max([1,2,3], [5])\\n\\t * 5: 5+ [1,2,3,4]\\n */\\npublic int getMoneyAmount(int n) {\\n\\tint[][] table = new int[n + 1][n + 1];\\n\\treturn helper(table, 1, n);\\n}\\n\\npublic int helper(int[][] table, int start, int end) {\\n\\tif (start >= end)\\n\\t\\treturn 0;\\n\\n\\tif (table[start][end] > 0)\\n\\t\\treturn table[start][end];\\n\\n\\tint ans = Integer.MAX_VALUE;\\n\\n\\tfor (int x = start + (end - start) / 2; x <= end; x++) {\\n\\t\\ttable[start][end] = x + Math.max(helper(table, start, x - 1), helper(table, x + 1, end));\\n\\t\\tans = Math.min(ans, table[start][end]);\\n\\t}\\n\\n\\ttable[start][end] = ans;\\n\\treturn table[start][end];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 389172,
                "title": "concise-dp-python-code-with-clear-explanation",
                "content": "The recursive statement is as follows:\\nWe have ```func(i, j)```, which defines the minimum amount you need to have if you have to guess values that are in between ```i``` and ```j```.\\n```\\nIf i >= j: return 0 \\n\\'\\'\\'\\nExplanation:\\ni is the start of range.\\nj is the end of range.\\nIf start == end, pay 0, because you definitely will have a correct guess with just one value \\nwithin your guess range. \\nIf start > end, it just simply doesn\\'t make sense, so it\\'s also 0.\\n\\'\\'\\'\\n\\nElse: return min(k + max(func(i, k-1), func(k+1, j))), for i<=k<j.\\n\\'\\'\\'\\nExplanation:\\nYou choose a value k within the range. \\n2 scenarios are likely to happen: k is too high OR k is too low\\nTo find the worse case scenario, find the max return value between these 2 scenarios\\nThen, find the best case scenario out of all your choices of k, and hence the min.\\n\\'\\'\\'\\n```\\n\\nThen comes the issue on how to fill up the dp_arr.\\nConsider ```n``` of a decent size, say ```n=6```\\nAnd consider at dp_arr[1][6], which is the value we want to return at the end, we\\'d need the following coordinates ```(start, end)``` at each value of ```k```.\\n```\\nAt k = 1:    1,0    2,6\\nAt k = 2:    1,1    3,6\\nAt k = 3:    1,2    4,6\\nAt k = 4:    1,3    5,6\\nAt k = 5:    1,4    6,6\\n```\\n\\nThen observe, we would need to fill out the dp-arr in the following manner, so as to avoid the \"index out of range\" error, but also for correctness :)\\nThe order is to be read from left to right.\\n```\\n1,2     2,3     3,4     4,5     5,6\\n1,3     2,4     3,5     4,6\\n1,4     2,5     3,6\\n1,5     2,6\\n1,6\\n```\\nHence, the 2 for-loops (with ```i``` and ```j```)  in the code below will fill up the dp_arr as follows.\\nTry drawing out the array and it\\'d make much more sense!\\n\\n```\\nclass Solution(object):\\n    def getMoneyAmount(self, n):\\n        dp_arr = []\\n\\t\\t\\n\\t\\t# initialising 2-d DP-arr\\n        for i in range(n + 1):\\n            col = [0] * (n + 1)\\n            dp_arr.append(col)\\n        \\n\\t\\t# diagonally filling up DP-arr\\n        for i in range(1, n + 1):\\n            for j in range(1, n - i + 1):\\n                res = float(\\'inf\\')\\n                start = j\\n                end = j + i\\n                for k in range(start, end):\\n                    res = min(res, k + max(dp_arr[start][k-1], \\\\\\n                                             dp_arr[k+1][end]))\\n                dp_arr[start][end] = res\\n        return dp_arr[1][n]\\n```",
                "solutionTags": [],
                "code": "```func(i, j)```\n```i```\n```j```\n```\\nIf i >= j: return 0 \\n\\'\\'\\'\\nExplanation:\\ni is the start of range.\\nj is the end of range.\\nIf start == end, pay 0, because you definitely will have a correct guess with just one value \\nwithin your guess range. \\nIf start > end, it just simply doesn\\'t make sense, so it\\'s also 0.\\n\\'\\'\\'\\n\\nElse: return min(k + max(func(i, k-1), func(k+1, j))), for i<=k<j.\\n\\'\\'\\'\\nExplanation:\\nYou choose a value k within the range. \\n2 scenarios are likely to happen: k is too high OR k is too low\\nTo find the worse case scenario, find the max return value between these 2 scenarios\\nThen, find the best case scenario out of all your choices of k, and hence the min.\\n\\'\\'\\'\\n```\n```n```\n```n=6```\n```(start, end)```\n```k```\n```\\nAt k = 1:    1,0    2,6\\nAt k = 2:    1,1    3,6\\nAt k = 3:    1,2    4,6\\nAt k = 4:    1,3    5,6\\nAt k = 5:    1,4    6,6\\n```\n```\\n1,2     2,3     3,4     4,5     5,6\\n1,3     2,4     3,5     4,6\\n1,4     2,5     3,6\\n1,5     2,6\\n1,6\\n```\n```i```\n```j```\n```\\nclass Solution(object):\\n    def getMoneyAmount(self, n):\\n        dp_arr = []\\n\\t\\t\\n\\t\\t# initialising 2-d DP-arr\\n        for i in range(n + 1):\\n            col = [0] * (n + 1)\\n            dp_arr.append(col)\\n        \\n\\t\\t# diagonally filling up DP-arr\\n        for i in range(1, n + 1):\\n            for j in range(1, n - i + 1):\\n                res = float(\\'inf\\')\\n                start = j\\n                end = j + i\\n                for k in range(start, end):\\n                    res = min(res, k + max(dp_arr[start][k-1], \\\\\\n                                             dp_arr[k+1][end]))\\n                dp_arr[start][end] = res\\n        return dp_arr[1][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279348,
                "title": "java-dfs-with-memorization",
                "content": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        return dfs(new Integer[n + 1][n + 1], 1, n);\\n    }\\n    \\n    int dfs(Integer[][] memo, int left, int right) {\\n        if (left >= right) return 0;\\n        if (memo[left][right] != null) return memo[left][right];\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int i = left; i <= right; ++i) {\\n            res = Math.min(res, i + Math.max(dfs(memo, left, i - 1), dfs(memo, i + 1, right)));\\n        }\\n        memo[left][right] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        return dfs(new Integer[n + 1][n + 1], 1, n);\\n    }\\n    \\n    int dfs(Integer[][] memo, int left, int right) {\\n        if (left >= right) return 0;\\n        if (memo[left][right] != null) return memo[left][right];\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int i = left; i <= right; ++i) {\\n            res = Math.min(res, i + Math.max(dfs(memo, left, i - 1), dfs(memo, i + 1, right)));\\n        }\\n        memo[left][right] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262965,
                "title": "java-1ms-backtrack",
                "content": "Minimax cost for each potential pivot positions. Setting pivot k = i + (j - i) / 2 does make a big difference.\\nRuntime - O(N^3) since there is O(N^2) search space and each one takes O(N)\\nSpace - O(N^2) for memo table\\n\\n```java\\nclass Solution {\\n    // Let F(i, j) be the min cost to win starting with range i ... j\\n    // F(i, j) = min(k + max(F(i, k-1) + F(k+1, j))), for each k from i to j\\n    // Base case F(i, j) = 0 if i >= j\\n    \\n    Integer[][] memo;\\n    public int getMoneyAmount(int n) {\\n        memo = new Integer[n + 1][n + 1];\\n        return backtrack(1, n);\\n    }\\n    \\n    // Returns the min cost to win starting with i and ending with j\\n    public int backtrack(int i, int j) {\\n        if (i >= j) {\\n            return 0;\\n        }\\n        \\n        if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        for (int k = i + (j - i) / 2; k <= j; k++) {\\n            int max = Math.max(backtrack(i, k - 1), backtrack(k + 1, j)) + k;\\n            min = Math.min(min, max);\\n        }\\n        \\n        memo[i][j] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    // Let F(i, j) be the min cost to win starting with range i ... j\\n    // F(i, j) = min(k + max(F(i, k-1) + F(k+1, j))), for each k from i to j\\n    // Base case F(i, j) = 0 if i >= j\\n    \\n    Integer[][] memo;\\n    public int getMoneyAmount(int n) {\\n        memo = new Integer[n + 1][n + 1];\\n        return backtrack(1, n);\\n    }\\n    \\n    // Returns the min cost to win starting with i and ending with j\\n    public int backtrack(int i, int j) {\\n        if (i >= j) {\\n            return 0;\\n        }\\n        \\n        if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        for (int k = i + (j - i) / 2; k <= j; k++) {\\n            int max = Math.max(backtrack(i, k - 1), backtrack(k + 1, j)) + k;\\n            min = Math.min(min, max);\\n        }\\n        \\n        memo[i][j] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189182,
                "title": "recursion-memo-simple-java-solution",
                "content": "```\\nclass Solution {\\n    private Integer[][] memo;\\n    public int getMoneyAmount(int n) {\\n        memo = new Integer[n + 1][n + 1];\\n        return money(1,n);\\n    }\\n    private int money(int s, int e){\\n        if(s >= e) return 0;\\n        if(memo[s][e] !=null) return memo[s][e];\\n        int min = Integer.MAX_VALUE;\\n        for(int i = s; i <= e; i++){\\n            int prev = i + Math.max(money(s, i - 1), money(i + 1, e));\\n            min = Math.min(min, prev);\\n        }\\n        memo[s][e] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Integer[][] memo;\\n    public int getMoneyAmount(int n) {\\n        memo = new Integer[n + 1][n + 1];\\n        return money(1,n);\\n    }\\n    private int money(int s, int e){\\n        if(s >= e) return 0;\\n        if(memo[s][e] !=null) return memo[s][e];\\n        int min = Integer.MAX_VALUE;\\n        for(int i = s; i <= e; i++){\\n            int prev = i + Math.max(money(s, i - 1), money(i + 1, e));\\n            min = Math.min(min, prev);\\n        }\\n        memo[s][e] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84817,
                "title": "minimizing-the-expected-loss-instead-of-worst-case-loss",
                "content": "I've solved the problem using dynamic programming by minimizing the worst-case loss. Here is my code:\\n\\n```\\nclass Solution {\\n    int getMoneyAmountDp(int left, int right, vector<vector<int>>& dp) {\\n        if(left >= right) {\\n            return 0;\\n        }\\n        int& ret = dp[left][right];\\n        if(ret != -1) return ret;\\n        ret = INT_MAX;\\n        for(int x = left; x <= right; ++x) {\\n            ret = min(ret, x + max(getMoneyAmountDp(left, x - 1, dp), getMoneyAmountDp(x + 1, right, dp)));\\n        }\\n        \\n        return ret;\\n    }\\n    \\npublic:\\n    int getMoneyAmount(int n) {\\n        // bottom-up\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, INT_MAX));\\n        for(int i = 0; i <= n; ++i) {\\n            dp[i][i] = 0;\\n        }\\n        for(int len = 2; len <= n; ++len) {\\n            for(int left = 1; left + len - 1 <= n; ++left) {\\n                int right = left + len - 1;\\n                for(int x = left; x <= right; ++x) {\\n                    int lhs = 0, rhs = 0;\\n                    if(x > left) {\\n                        lhs = dp[left][x - 1];\\n                    }\\n                    if(x < right) {\\n                        rhs = dp[x + 1][right];\\n                    }\\n                    dp[left][right] = min(dp[left][right], x + max(lhs, rhs));\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n        \\n        // top-down\\n        // vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        // return getMoneyAmountDp(1, n, dp);\\n    }\\n};\\n```\\nNow, I want to answer the follow-up question - solving the problem by minimizing the expected loss instead of worst-case loss. Can anyone help me with the idea? I am out of touch of expectation theory.\\n\\nThanks in advance!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int getMoneyAmountDp(int left, int right, vector<vector<int>>& dp) {\\n        if(left >= right) {\\n            return 0;\\n        }\\n        int& ret = dp[left][right];\\n        if(ret != -1) return ret;\\n        ret = INT_MAX;\\n        for(int x = left; x <= right; ++x) {\\n            ret = min(ret, x + max(getMoneyAmountDp(left, x - 1, dp), getMoneyAmountDp(x + 1, right, dp)));\\n        }\\n        \\n        return ret;\\n    }\\n    \\npublic:\\n    int getMoneyAmount(int n) {\\n        // bottom-up\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, INT_MAX));\\n        for(int i = 0; i <= n; ++i) {\\n            dp[i][i] = 0;\\n        }\\n        for(int len = 2; len <= n; ++len) {\\n            for(int left = 1; left + len - 1 <= n; ++left) {\\n                int right = left + len - 1;\\n                for(int x = left; x <= right; ++x) {\\n                    int lhs = 0, rhs = 0;\\n                    if(x > left) {\\n                        lhs = dp[left][x - 1];\\n                    }\\n                    if(x < right) {\\n                        rhs = dp[x + 1][right];\\n                    }\\n                    dp[left][right] = min(dp[left][right], x + max(lhs, rhs));\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n        \\n        // top-down\\n        // vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        // return getMoneyAmountDp(1, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84837,
                "title": "ruby-solution",
                "content": "Just recursion with memoization. To calculate how much money I need to solve a range lo..hi (initially 1..n) with two or more numbers, I try all x in the range and take the best.\\n```\\ndef get_money_amount(n)\\n  memo = (1..n).map { [] }\\n  need = -> lo, hi {\\n    lo >= hi ? 0 : memo[lo][hi] ||= (lo..hi).map { |x| x + [need[lo, x-1], need[x+1, hi]].max }.min\\n  }\\n  need[1, n]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef get_money_amount(n)\\n  memo = (1..n).map { [] }\\n  need = -> lo, hi {\\n    lo >= hi ? 0 : memo[lo][hi] ||= (lo..hi).map { |x| x + [need[lo, x-1], need[x+1, hi]].max }.min\\n  }\\n  need[1, n]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4091539,
                "title": "python-split-into-groups-of-3",
                "content": "The most economic way of guessing a number at the tail is to pick the middle one, e.g., `... 23 24 25` (choose `24`). But this means that a split should be done at `n-4` (i.e., `22` in the previous example). The same logic applies to every possible segment, thus, the split points are `n-3, n-7, n-11, ...`. \\n\\nThe minimum penalty for the interval `[l,r]` would be the minimum value among all split points for the sum of:\\n1. The value at the split `m` itself, and\\n2. The maximum of penalties for the left and right subintervals, `[l,m-1]` and `[m+1,l]`.\\n\\nAnswers for short subintervals are hardcoded.\\n\\n```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n               \\n        @cache\\n        def dfs(l,r):\\n            if r-l == 4 : return 2*l + 4\\n            if r-l == 3 : return 2*l + 2\\n            if r-l == 2 : return l + 1\\n            if r-l == 1 : return l\\n            \\n            return min((m + max(dfs(l,m-1), dfs(m+1,r)) for m in range(r-3,l,-4)), default=0)\\n\\n        if n <= 2 : return n-1\\n        if n == 3 : return 2\\n        \\n        return dfs(1,n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n               \\n        @cache\\n        def dfs(l,r):\\n            if r-l == 4 : return 2*l + 4\\n            if r-l == 3 : return 2*l + 2\\n            if r-l == 2 : return l + 1\\n            if r-l == 1 : return l\\n            \\n            return min((m + max(dfs(l,m-1), dfs(m+1,r)) for m in range(r-3,l,-4)), default=0)\\n\\n        if n <= 2 : return n-1\\n        if n == 3 : return 2\\n        \\n        return dfs(1,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832577,
                "title": "explained-with-clear-and-concise-code-with-comments",
                "content": "# Complexity\\n- Time complexity : $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+2,vector<int> (n+2,-1));\\n        return f(1,n,dp);\\n    }\\n\\n    int f(int i, int j, vector<vector<int>> &dp) {\\n        // base cases\\n        if(i == j) return 0; // if there is only one number for eg - 1, best strategy is to pick 0\\n        if(i+1 == j) return i; // if there are two numbers for eg - 1,2, best strategy is to pick the smaller one\\n        if(i+2 == j) return i+1; // if there are three numbers for eg - 1,2, best strategy is to pick the middle one\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = 1e9;\\n        for(int k=i ; k<=j ; k++) {\\n            int ansIsOnLeft = k + f(i,k-1,dp);\\n            int ansIsOnRight = k + f(k+1,j,dp);\\n\\n            ans = min(ans,max(ansIsOnLeft,ansIsOnRight)); // since we need to guarantee a win regardless of what no. we pick, we take max of ansIsOnLeft and ansIsOnRight\\n        }\\n        return dp[i][j] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+2,vector<int> (n+2,-1));\\n        return f(1,n,dp);\\n    }\\n\\n    int f(int i, int j, vector<vector<int>> &dp) {\\n        // base cases\\n        if(i == j) return 0; // if there is only one number for eg - 1, best strategy is to pick 0\\n        if(i+1 == j) return i; // if there are two numbers for eg - 1,2, best strategy is to pick the smaller one\\n        if(i+2 == j) return i+1; // if there are three numbers for eg - 1,2, best strategy is to pick the middle one\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = 1e9;\\n        for(int k=i ; k<=j ; k++) {\\n            int ansIsOnLeft = k + f(i,k-1,dp);\\n            int ansIsOnRight = k + f(k+1,j,dp);\\n\\n            ans = min(ans,max(ansIsOnLeft,ansIsOnRight)); // since we need to guarantee a win regardless of what no. we pick, we take max of ansIsOnLeft and ansIsOnRight\\n        }\\n        return dp[i][j] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802792,
                "title": "easy-c-solution-bottom-up-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int bottomUp(int n){\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int start=n-1;start>=1;start--){\\n            for(int end=1;end<=n;end++){\\n                if(start>=end)\\n                    continue;\\n                else{\\n                  int ans=INT_MAX;\\n            for(int i=start;i<end;i++){\\n            ans=min(ans,i+max(dp[start][i-1],dp[i+1][end]));\\n            }\\n            dp[start][end]=ans;\\n            }\\n        }\\n    }\\n        return dp[1][n];\\n}\\n    int getMoneyAmount(int n) {\\n        \\n        return bottomUp(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int bottomUp(int n){\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int start=n-1;start>=1;start--){\\n            for(int end=1;end<=n;end++){\\n                if(start>=end)\\n                    continue;\\n                else{\\n                  int ans=INT_MAX;\\n            for(int i=start;i<end;i++){\\n            ans=min(ans,i+max(dp[start][i-1],dp[i+1][end]));\\n            }\\n            dp[start][end]=ans;\\n            }\\n        }\\n    }\\n        return dp[1][n];\\n}\\n    int getMoneyAmount(int n) {\\n        \\n        return bottomUp(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802693,
                "title": "easy-c-solution-top-down-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       int topDown(int start,int end,vector<vector<int>> &dp){\\n        if(start>=end)\\n            return 0;\\n        if(dp[start][end]!=-1)\\n            return dp[start][end];\\n            int ans=INT_MAX;\\n        for(int i=start;i<end;i++){\\n            ans=min(ans,i+max(topDown(start,i-1,dp),topDown(i+1,end,dp)));\\n        }\\n        dp[start][end]=ans;\\n        return dp[start][end];\\n    }\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return topDown(1,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int topDown(int start,int end,vector<vector<int>> &dp){\\n        if(start>=end)\\n            return 0;\\n        if(dp[start][end]!=-1)\\n            return dp[start][end];\\n            int ans=INT_MAX;\\n        for(int i=start;i<end;i++){\\n            ans=min(ans,i+max(topDown(start,i-1,dp),topDown(i+1,end,dp)));\\n        }\\n        dp[start][end]=ans;\\n        return dp[start][end];\\n    }\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return topDown(1,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760402,
                "title": "recursion-solution-dp-c",
                "content": "for ```n = 10```, the range is from 1 to 10\\nwe guessed a number from the range, let it be 7\\nif 7 is an incorrect guess, then there will be two possibilities\\neither the correct number is greater than 7 or lower than 7.\\n![image](https://assets.leetcode.com/users/images/2d22de3c-4d40-4152-969a-b5f23a6e6e3c_1689268560.7078216.jpeg)\\n\\nRecursive approach:\\n```\\nclass Solution {\\n    int solve(int start, int end){\\n        if(start >= end){\\n            return 0;\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int i = start; i <= end; i++){\\n            // get the range if the number is lower\\n            int leftRange = solve(start, i-1);\\n            // get the range if the number is higher\\n            int rightRange = solve(i+1, end);\\n            int cost = i + max(leftRange, rightRange);\\n            \\n            mini = min(mini, cost);\\n        }\\n        \\n        return mini;\\n    }\\npublic:\\n    int getMoneyAmount(int n) {\\n        return solve(1, n);\\n    }\\n};\\n```\\n\\n\\n\\nOptimized solution using Dynamic Programming:\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int> (n + 2, 0));\\n        \\n        for(int start = n; start >= 1; start--){\\n            for(int end = start+1; end <= n; end++){\\n                \\n                int mini = INT_MAX;\\n                for(int i = start; i <= end; i++){\\n                    int leftRange = dp[start][i-1];\\n                    int rightRange = dp[i+1][end];\\n                        \\n                    int cost = i + max(leftRange, rightRange);\\n                    mini = min(mini, cost);\\n                }\\n                dp[start][end] = mini;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```n = 10```\n```\\nclass Solution {\\n    int solve(int start, int end){\\n        if(start >= end){\\n            return 0;\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int i = start; i <= end; i++){\\n            // get the range if the number is lower\\n            int leftRange = solve(start, i-1);\\n            // get the range if the number is higher\\n            int rightRange = solve(i+1, end);\\n            int cost = i + max(leftRange, rightRange);\\n            \\n            mini = min(mini, cost);\\n        }\\n        \\n        return mini;\\n    }\\npublic:\\n    int getMoneyAmount(int n) {\\n        return solve(1, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 2, vector<int> (n + 2, 0));\\n        \\n        for(int start = n; start >= 1; start--){\\n            for(int end = start+1; end <= n; end++){\\n                \\n                int mini = INT_MAX;\\n                for(int i = start; i <= end; i++){\\n                    int leftRange = dp[start][i-1];\\n                    int rightRange = dp[i+1][end];\\n                        \\n                    int cost = i + max(leftRange, rightRange);\\n                    mini = min(mini, cost);\\n                }\\n                dp[start][end] = mini;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575745,
                "title": "easy-dp-solution-tabulation-bottom-up-approach-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        // Initialized dp vector\\n        vector<vector<int>> dp(n+1,vector<int>(n+1, 0));\\n        // Iterate over dp vector using low and high pointers\\n        for(int low = n;low>=1;low--){\\n            for(int high = low; high<=n;high++){\\n                // If low and high are equal skip them\\n                if(low == high) continue;\\n                else{\\n                    // We have to think about worst case so suppose our all guesses\\n                    // are wrong so + wrong guess no and we have two option left\\n                    // either the no lie inside range [low,i-1]\\n                    // or range[i+1,high]\\n                    // Ai = i + max(dp[low][i-1],dp[i+1][high])\\n                    // finalAns = min(finalAns,Ai)\\n                    int ans = INT_MAX;\\n                    for(int i = low;i<high;i++){\\n                        ans = min(ans, i + max(dp[low][i-1],dp[i+1][high]));\\n                    }\\n                    dp[low][high] = ans;\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        // Initialized dp vector\\n        vector<vector<int>> dp(n+1,vector<int>(n+1, 0));\\n        // Iterate over dp vector using low and high pointers\\n        for(int low = n;low>=1;low--){\\n            for(int high = low; high<=n;high++){\\n                // If low and high are equal skip them\\n                if(low == high) continue;\\n                else{\\n                    // We have to think about worst case so suppose our all guesses\\n                    // are wrong so + wrong guess no and we have two option left\\n                    // either the no lie inside range [low,i-1]\\n                    // or range[i+1,high]\\n                    // Ai = i + max(dp[low][i-1],dp[i+1][high])\\n                    // finalAns = min(finalAns,Ai)\\n                    int ans = INT_MAX;\\n                    for(int i = low;i<high;i++){\\n                        ans = min(ans, i + max(dp[low][i-1],dp[i+1][high]));\\n                    }\\n                    dp[low][high] = ans;\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308945,
                "title": "easy-explanation-c-solution-important-maxmin-concept",
                "content": "# Intuition\\nThis problem is exactly same as egg dropping problem....\\nIn simple terms we have been asked to minimize the maximized losses....\\nOr you can say of all the bad outcomes which is least bad outcome that is what we have to return\\n....................................................................\\nTo solve this problem  we must be aware of one very important concept which is called maxmin concept\\nWhat it means is we must choose the  best out of worst.\\n....................................................................\\nFor better understanding of this concept please refer to the video on egg dropping problem by pepcoding..........\\nUnderstand the concept first and refer to solution later.....\\nhttps://youtu.be/UvksR0hR9nA\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[201][201];\\nint maxmin(int s,int e)\\n{\\n    \\n    if(s>=e)\\n    return 0;\\n    \\n    if(dp[s][e]!=-1)\\n    return dp[s][e];\\n    int ans=1e8;\\n    for(int i=s;i<=e;i++)\\n    {\\n        int temp = max(maxmin(i+1,e),maxmin(s,i-1));\\n        ans=  min(ans,temp+i);\\n\\n    }\\n    return dp[s][e]=ans;\\n}\\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return maxmin(1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[201][201];\\nint maxmin(int s,int e)\\n{\\n    \\n    if(s>=e)\\n    return 0;\\n    \\n    if(dp[s][e]!=-1)\\n    return dp[s][e];\\n    int ans=1e8;\\n    for(int i=s;i<=e;i++)\\n    {\\n        int temp = max(maxmin(i+1,e),maxmin(s,i-1));\\n        ans=  min(ans,temp+i);\\n\\n    }\\n    return dp[s][e]=ans;\\n}\\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return maxmin(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224076,
                "title": "minmax-with-memo-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMinMax, similar to egg drop\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nchoose a guess that takes less cost; for each guess, should consider worset case. Thus, come up with lesat cost of worst case.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(int low, int high,  vector<vector<int>>& dp){\\n        if(low>=high){\\n            return 0;\\n        }\\n        if(dp[low][high]!=-1){\\n            return dp[low][high];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=low; i<=high; i++){\\n            ans = min(ans, i+max(search(low, i-1, dp),search(i+1, high, dp)));\\n        }\\n        dp[low][high]=ans;\\n        return ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return search(1,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(int low, int high,  vector<vector<int>>& dp){\\n        if(low>=high){\\n            return 0;\\n        }\\n        if(dp[low][high]!=-1){\\n            return dp[low][high];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=low; i<=high; i++){\\n            ans = min(ans, i+max(search(low, i-1, dp),search(i+1, high, dp)));\\n        }\\n        dp[low][high]=ans;\\n        return ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return search(1,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992975,
                "title": "javascript-solution-beats-100",
                "content": "# Code\\n```\\nvar getMoneyAmount = function(n) {\\n    var dp = [];\\n    for (var i = 0; i <= n; i++) {\\n        dp[i] = [];\\n        for (var j = 0; j <= n; j++) {\\n            dp[i][j] = 0;\\n        }\\n    }\\n    for (var len = 2; len <= n; len++) {\\n        for (var i = 1; i <= n - len + 1; i++) {\\n            var j = i + len - 1;\\n            dp[i][j] = Number.MAX_VALUE;\\n            for (var k = i; k <= j; k++) {\\n                dp[i][j] = Math.min(dp[i][j], k + Math.max(k - 1 >= i ? dp[i][k - 1] : 0, j >= k + 1 ? dp[k + 1][j] : 0));\\n            }\\n        }\\n    }\\n    return dp[1][n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMoneyAmount = function(n) {\\n    var dp = [];\\n    for (var i = 0; i <= n; i++) {\\n        dp[i] = [];\\n        for (var j = 0; j <= n; j++) {\\n            dp[i][j] = 0;\\n        }\\n    }\\n    for (var len = 2; len <= n; len++) {\\n        for (var i = 1; i <= n - len + 1; i++) {\\n            var j = i + len - 1;\\n            dp[i][j] = Number.MAX_VALUE;\\n            for (var k = i; k <= j; k++) {\\n                dp[i][j] = Math.min(dp[i][j], k + Math.max(k - 1 >= i ? dp[i][k - 1] : 0, j >= k + 1 ? dp[k + 1][j] : 0));\\n            }\\n        }\\n    }\\n    return dp[1][n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798446,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        for(int len=2; len<=n; ++len){\\n            for(int begin=0; begin<=n-len; ++begin){\\n                \\n                int end = begin + len;\\n                for(int i=begin; i<end; ++i){\\n                    int numPicked = i+1;\\n                    if(i == begin){\\n                        dp[begin][end] = numPicked + dp[begin+1][end];\\n                    } else {\\n                        dp[begin][end] = min(dp[begin][end], max(dp[begin][i], dp[i+1][end]) + numPicked);\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return dp[0][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        for(int len=2; len<=n; ++len){\\n            for(int begin=0; begin<=n-len; ++begin){\\n                \\n                int end = begin + len;\\n                for(int i=begin; i<end; ++i){\\n                    int numPicked = i+1;\\n                    if(i == begin){\\n                        dp[begin][end] = numPicked + dp[begin+1][end];\\n                    } else {\\n                        dp[begin][end] = min(dp[begin][end], max(dp[begin][i], dp[i+1][end]) + numPicked);\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return dp[0][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637474,
                "title": "line-by-line-detailed-explanation-c-memoisation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[210][210];\\n    \\n    // this helper function calculate the amount of money needed if the guessed number lies between \"l\" and \"r\". \\n    int helper(long l, long r, long n){\\n        if(l == r)return 0; // the guessed number lies between \"l\" and \"r\" and, if \"l\" and \"r\" are equal then \"l\"(or \"r\") is the required number\\n        if(dp[l][r])return dp[l][r];\\n        long ans = INT_MAX;\\n        \\n        // take guesses from \"l\" to \"r\", as the required number can be any number between \"l\" and \"r\"\\n        for(long i = l;i <= r;i++){\\n            // Let\\'s say, I guessed \\'i\\'\\n            long t1 = 0, t2 = 0, t3 = 0;\\n            t1 = i;// if my guess is correct, then I only have to pay \"i\" amount\\n            if(i > 1)\\n                t2 = i + helper(l, i - 1, n);// if my guess is incorrect and required number is less than i, then I pay \"i\" amount and then search for the number in range \"l\" to \"i - 1\"\\n            if(i < n)\\n                t3 = i + helper(i + 1, r, n);// if my guess is incorrect and required number is greater than i, then I pay \"i\" amount and then search for the number in range \"i + 1\" to \"r\"\\n            \\n            //take the worst case possible out of above 3 cases\\n            ans = min(ans, max({t1, t2, t3}));\\n        }\\n        return dp[l][r] = ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        return helper(1, n, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[210][210];\\n    \\n    // this helper function calculate the amount of money needed if the guessed number lies between \"l\" and \"r\". \\n    int helper(long l, long r, long n){\\n        if(l == r)return 0; // the guessed number lies between \"l\" and \"r\" and, if \"l\" and \"r\" are equal then \"l\"(or \"r\") is the required number\\n        if(dp[l][r])return dp[l][r];\\n        long ans = INT_MAX;\\n        \\n        // take guesses from \"l\" to \"r\", as the required number can be any number between \"l\" and \"r\"\\n        for(long i = l;i <= r;i++){\\n            // Let\\'s say, I guessed \\'i\\'\\n            long t1 = 0, t2 = 0, t3 = 0;\\n            t1 = i;// if my guess is correct, then I only have to pay \"i\" amount\\n            if(i > 1)\\n                t2 = i + helper(l, i - 1, n);// if my guess is incorrect and required number is less than i, then I pay \"i\" amount and then search for the number in range \"l\" to \"i - 1\"\\n            if(i < n)\\n                t3 = i + helper(i + 1, r, n);// if my guess is incorrect and required number is greater than i, then I pay \"i\" amount and then search for the number in range \"i + 1\" to \"r\"\\n            \\n            //take the worst case possible out of above 3 cases\\n            ans = min(ans, max({t1, t2, t3}));\\n        }\\n        return dp[l][r] = ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        return helper(1, n, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618132,
                "title": "python-dp-easily-understand",
                "content": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        dp, length = [[0] * (n + 2) for _ in range(n + 2)], 2\\n        for i in range(1, n): dp[i][i + 1] = i\\n            \\n        while length < n:\\n            for i in range(1, n + 1 - length):\\n                dp[i][i + length] = min(\\n                    l + max(dp[i][l - 1], dp[l + 1][i + length]) for l in range(i, i + length + 1)\\n                )\\n                \\n            length += 1\\n            \\n        return dp[1][n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        dp, length = [[0] * (n + 2) for _ in range(n + 2)], 2\\n        for i in range(1, n): dp[i][i + 1] = i\\n            \\n        while length < n:\\n            for i in range(1, n + 1 - length):\\n                dp[i][i + length] = min(\\n                    l + max(dp[i][l - 1], dp[l + 1][i + length]) for l in range(i, i + length + 1)\\n                )\\n                \\n            length += 1\\n            \\n        return dp[1][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534906,
                "title": "recursive-top-down-bottom-up",
                "content": "```\\nclass Solution {\\nprivate:\\n    int recursive(int low, int high){\\n        if(low >= high) return 0;\\n        int ans = INT_MAX;\\n        for(int num = low ; num <= high ; num++){\\n            ans = min(max(num + recursive(low, num - 1), num + recursive(num + 1, high)), ans);\\n        }\\n        return ans;\\n    }\\n    int topDown(int low, int high, vector<vector<int>> &dp){\\n        if(low >= high) return 0;\\n        int ans = INT_MAX;\\n        if(dp[low][high] != -1) return dp[low][high];\\n        for(int num = low ; num <= high ; num++){\\n            ans = min(num + max(topDown(low, num - 1, dp), topDown(num + 1, high, dp)), ans);\\n        }\\n        return dp[low][high] = ans;\\n    }\\n    int bottomUp(int n){\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 1, 0));\\n        for(int low = n ; low >= 1 ; low--){\\n            for(int high = low + 1 ; high <= n ; high++){\\n                int ans = INT_MAX;\\n                for(int num = low ; num <= high ; num++){\\n                    ans = min(num + max(dp[low][num - 1], dp[num + 1][high]), ans);\\n                }\\n                dp[low][high] = ans;  \\n            }\\n        }\\n        return dp[1][n];\\n    }\\npublic:\\n    int getMoneyAmount(int n) {\\n        // return recursive(1, n);\\n        // vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        // return topDown(1, n, dp);\\n        return bottomUp(n);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int recursive(int low, int high){\\n        if(low >= high) return 0;\\n        int ans = INT_MAX;\\n        for(int num = low ; num <= high ; num++){\\n            ans = min(max(num + recursive(low, num - 1), num + recursive(num + 1, high)), ans);\\n        }\\n        return ans;\\n    }\\n    int topDown(int low, int high, vector<vector<int>> &dp){\\n        if(low >= high) return 0;\\n        int ans = INT_MAX;\\n        if(dp[low][high] != -1) return dp[low][high];\\n        for(int num = low ; num <= high ; num++){\\n            ans = min(num + max(topDown(low, num - 1, dp), topDown(num + 1, high, dp)), ans);\\n        }\\n        return dp[low][high] = ans;\\n    }\\n    int bottomUp(int n){\\n        vector<vector<int>> dp(n + 2, vector<int>(n + 1, 0));\\n        for(int low = n ; low >= 1 ; low--){\\n            for(int high = low + 1 ; high <= n ; high++){\\n                int ans = INT_MAX;\\n                for(int num = low ; num <= high ; num++){\\n                    ans = min(num + max(dp[low][num - 1], dp[num + 1][high]), ans);\\n                }\\n                dp[low][high] = ans;  \\n            }\\n        }\\n        return dp[1][n];\\n    }\\npublic:\\n    int getMoneyAmount(int n) {\\n        // return recursive(1, n);\\n        // vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        // return topDown(1, n, dp);\\n        return bottomUp(n);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533393,
                "title": "cpp-mcm-egg-dropping-problem-variation-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[201][201];\\n    int mcm(int i,int j){\\n        if(i>=j) return 0;\\n        if(memo[i][j]!=-1) return memo[i][j];\\n        int temp = 100000;\\n        for(int k=i;k<=j;k++){\\n            temp = min(temp,k+max(mcm(i,k-1),mcm(k+1,j)));\\n        }\\n        return memo[i][j] = temp;\\n    }\\n    int getMoneyAmount(int n) {\\n        memset(memo,-1,sizeof(memo));\\n        return mcm(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[201][201];\\n    int mcm(int i,int j){\\n        if(i>=j) return 0;\\n        if(memo[i][j]!=-1) return memo[i][j];\\n        int temp = 100000;\\n        for(int k=i;k<=j;k++){\\n            temp = min(temp,k+max(mcm(i,k-1),mcm(k+1,j)));\\n        }\\n        return memo[i][j] = temp;\\n    }\\n    int getMoneyAmount(int n) {\\n        memset(memo,-1,sizeof(memo));\\n        return mcm(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478059,
                "title": "java-solution-easy-to-understand-this-question-approach",
                "content": "```\\n/*\\nFirstly this is very similar to standard problem -- > egg dropping problem.\\nLet\\'s understand with example -\\ntake n = 3\\n   now ,\\n   3 -- end\\n   2\\n   1 -- start\\n   i have option from where to begin either from 1 or from 3. Suppose I begin with 3 now i have 2 options whether to go up or go down - if i go up --> it would be  end  + (end+1) . Means i am taking this money and going upwards.\\n   \\n   If i go down end + (end-1).\\n   Core logic is i take money and check both up and down . \\n   Now for max and min thing.\\n   We are taking max of (down , up) -- > we taking worst case , how much we can spend \\n   then min beacuse from all worst cases we will take minimum from them.\\n   \\n   Take like this , person -- > A  Go for shopping in  10 shopes , now take maximum amount spend from 10 shopes.\\n   Then he goes 10 times in a day , max of every time he go and then minimum from 10 maximum values;\\n   \\n   Now go through solution then -- i will explain again.\\n   */\\n   \\n   class Solution {\\n    public int getMoneyAmount(int n) {\\n        if(n==1){\\n            return 0;\\n        }\\n        Integer[][] dp = new Integer[n+1][n+1];\\n        return answer(1,n,dp);\\n    }\\n    private int answer(int start,int end,Integer[][] dp){\\n        if(start > end){\\n            return Integer.MIN_VALUE;\\n        }\\n        if(start == end){\\n            return 0;\\n        }\\n        if(dp[start][end] != null){\\n            return dp[start][end];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=start;i<=end-1;i++){\\n            int max = i + Math.max(answer(start,i-1,dp),answer(i+1,end,dp));\\n            min = Math.min(min,max);\\n        }\\n        return dp[start][end] = min;\\n    }\\n}\\n/*\\nLooping for checking every particular worst case and (money we can take) + Max(down,up)\\nthen min from all worst cases.\\nBy loop we are making cut between up and down + money(possibly we take).\\nFor better understanding go through EGG DROPING PROBLEM  + use pen paper for this problem , use small case (n==4)  then you will understand.\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/*\\nFirstly this is very similar to standard problem -- > egg dropping problem.\\nLet\\'s understand with example -\\ntake n = 3\\n   now ,\\n   3 -- end\\n   2\\n   1 -- start\\n   i have option from where to begin either from 1 or from 3. Suppose I begin with 3 now i have 2 options whether to go up or go down - if i go up --> it would be  end  + (end+1) . Means i am taking this money and going upwards.\\n   \\n   If i go down end + (end-1).\\n   Core logic is i take money and check both up and down . \\n   Now for max and min thing.\\n   We are taking max of (down , up) -- > we taking worst case , how much we can spend \\n   then min beacuse from all worst cases we will take minimum from them.\\n   \\n   Take like this , person -- > A  Go for shopping in  10 shopes , now take maximum amount spend from 10 shopes.\\n   Then he goes 10 times in a day , max of every time he go and then minimum from 10 maximum values;\\n   \\n   Now go through solution then -- i will explain again.\\n   */\\n   \\n   class Solution {\\n    public int getMoneyAmount(int n) {\\n        if(n==1){\\n            return 0;\\n        }\\n        Integer[][] dp = new Integer[n+1][n+1];\\n        return answer(1,n,dp);\\n    }\\n    private int answer(int start,int end,Integer[][] dp){\\n        if(start > end){\\n            return Integer.MIN_VALUE;\\n        }\\n        if(start == end){\\n            return 0;\\n        }\\n        if(dp[start][end] != null){\\n            return dp[start][end];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=start;i<=end-1;i++){\\n            int max = i + Math.max(answer(start,i-1,dp),answer(i+1,end,dp));\\n            min = Math.min(min,max);\\n        }\\n        return dp[start][end] = min;\\n    }\\n}\\n/*\\nLooping for checking every particular worst case and (money we can take) + Max(down,up)\\nthen min from all worst cases.\\nBy loop we are making cut between up and down + money(possibly we take).\\nFor better understanding go through EGG DROPING PROBLEM  + use pen paper for this problem , use small case (n==4)  then you will understand.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468842,
                "title": "simplest-c-solution-dp",
                "content": "For better explanation watch this : https://youtu.be/73qd6DtEQq4\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int getMoneyAmount(int n) {\\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        int start=1;\\n        int end=n;\\n        return fun(start,end);\\n    }\\n    int fun(int start,int end)\\n    {\\n        if(start>=end)\\n        {\\n            return 0;\\n        }\\n        if(dp[start][end]!=-1)\\n        {\\n            return dp[start][end];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=start;i<=end;i++)\\n        {\\n            ans=min(ans,i+max(fun(start,i-1),fun(i+1,end)));\\n        }\\n        return dp[start][end]=ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int getMoneyAmount(int n) {\\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        int start=1;\\n        int end=n;\\n        return fun(start,end);\\n    }\\n    int fun(int start,int end)\\n    {\\n        if(start>=end)\\n        {\\n            return 0;\\n        }\\n        if(dp[start][end]!=-1)\\n        {\\n            return dp[start][end];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=start;i<=end;i++)\\n        {\\n            ans=min(ans,i+max(fun(start,i-1),fun(i+1,end)));\\n        }\\n        return dp[start][end]=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454708,
                "title": "simplest-c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int getMoneyAmount(int n) {\\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        \\n        int start=1;\\n        int end=n;\\n        return fun(start,end);  \\n    }\\n   int fun(int start,int end)\\n   {\\n        if(start>end)\\n        return INT_MIN;\\n\\n        if(start==end)    //only possible ans of that subtree\\n        return 0;\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n       \\n        int ans=INT_MAX;\\n\\n        for(int i=start;i<=end;i++)\\n        {\\n          ans=min(ans,i+max(fun(start,i-1),fun(i+1,end)));\\t\\n        }\\n\\t    return dp[start][end] =ans;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int getMoneyAmount(int n) {\\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        \\n        int start=1;\\n        int end=n;\\n        return fun(start,end);  \\n    }\\n   int fun(int start,int end)\\n   {\\n        if(start>end)\\n        return INT_MIN;\\n\\n        if(start==end)    //only possible ans of that subtree\\n        return 0;\\n        \\n        if(dp[start][end]!=-1) return dp[start][end];\\n       \\n        int ans=INT_MAX;\\n\\n        for(int i=start;i<=end;i++)\\n        {\\n          ans=min(ans,i+max(fun(start,i-1),fun(i+1,end)));\\t\\n        }\\n\\t    return dp[start][end] =ans;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441137,
                "title": "c-simple-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        return binary(1, n, dp);\\n    }\\n    \\n    int binary(int left, int right, vector<vector<int>>& dp){\\n        if(left >= right) return 0;\\n     \\n        if(dp[left][right] != -1) return dp[left][right];\\n        \\n        int min_amount = INT_MAX;\\n        \\n        for(int i = left;i <= right;i++){\\n            int mid = i;\\n            min_amount = min(min_amount, mid + max(binary(left, mid - 1, dp), binary(mid + 1, right, dp)));\\n        }\\n        \\n        return dp[left][right] = min_amount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n        return binary(1, n, dp);\\n    }\\n    \\n    int binary(int left, int right, vector<vector<int>>& dp){\\n        if(left >= right) return 0;\\n     \\n        if(dp[left][right] != -1) return dp[left][right];\\n        \\n        int min_amount = INT_MAX;\\n        \\n        for(int i = left;i <= right;i++){\\n            int mid = i;\\n            min_amount = min(min_amount, mid + max(binary(left, mid - 1, dp), binary(mid + 1, right, dp)));\\n        }\\n        \\n        return dp[left][right] = min_amount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440138,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    \\n    int solve(int low, int high){\\n        if(low>=high) return 0;\\n        if(dp[low][high] != -1) return dp[low][high];\\n        \\n        int ans = INT_MAX;\\n        for(int i=low; i<=high; ++i){\\n            ans = min(ans, i + max(solve(low,i-1), solve(i+1,high)));\\n        }\\n        return dp[low][high] = ans;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,n);\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    \\n    int solve(int low, int high){\\n        if(low>=high) return 0;\\n        if(dp[low][high] != -1) return dp[low][high];\\n        \\n        int ans = INT_MAX;\\n        for(int i=low; i<=high; ++i){\\n            ans = min(ans, i + max(solve(low,i-1), solve(i+1,high)));\\n        }\\n        return dp[low][high] = ans;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330715,
                "title": "c-memoization-dp-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    int solve(int start, int end)\\n    {\\n        if(start>= end)\\n            return 0;\\n        \\n        if(dp[start][end] != -1)\\n            return dp[start][end];\\n        \\n        int ans = 0;\\n        int result = INT_MAX;\\n        for(int i=start; i<=end; i++)\\n        {\\n            int left = solve(start,i-1);\\n            int right = solve(i+1,end);\\n            ans = max(left,right) + i;      // this line gurantee to include the money that is needed to win higher values\\n            result = min(ans,result);\\n        }\\n        \\n        return dp[start][end] = result;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        int ans = 0;\\n        dp = vector<vector<int>>(n+1,vector<int>(n+1,-1));\\n        return solve(1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    int solve(int start, int end)\\n    {\\n        if(start>= end)\\n            return 0;\\n        \\n        if(dp[start][end] != -1)\\n            return dp[start][end];\\n        \\n        int ans = 0;\\n        int result = INT_MAX;\\n        for(int i=start; i<=end; i++)\\n        {\\n            int left = solve(start,i-1);\\n            int right = solve(i+1,end);\\n            ans = max(left,right) + i;      // this line gurantee to include the money that is needed to win higher values\\n            result = min(ans,result);\\n        }\\n        \\n        return dp[start][end] = result;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        int ans = 0;\\n        dp = vector<vector<int>>(n+1,vector<int>(n+1,-1));\\n        return solve(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323815,
                "title": "faster-than-98-memoization-google-interview-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    unsigned int solve(int i,int j){\\n        if(i > j)\\n            return 0;\\n        \\n        if(j == i+1)\\n            return i;\\n        \\n        if(i == j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        unsigned int mn = INT_MAX;\\n        for(int k=i+1;k<j;k++){\\n            unsigned int ans = max(solve(i,k-1),solve(k+1,j)) + k; //   my choice (I always expect to take the worst choice)\\n            if(ans < mn)\\n                mn = ans; // out of all my worst choices this stores best \\n        }\\n        return dp[i][j] = mn;\\n    }\\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,n);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[201][201];\\n    unsigned int solve(int i,int j){\\n        if(i > j)\\n            return 0;\\n        \\n        if(j == i+1)\\n            return i;\\n        \\n        if(i == j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        unsigned int mn = INT_MAX;\\n        for(int k=i+1;k<j;k++){\\n            unsigned int ans = max(solve(i,k-1),solve(k+1,j)) + k; //   my choice (I always expect to take the worst choice)\\n            if(ans < mn)\\n                mn = ans; // out of all my worst choices this stores best \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2320307,
                "title": "c-simple-to-understand-matrix-chain-mul-dp",
                "content": "```\\nint dp[201][201];\\n    \\n    int getMoneyHelper(int low,int high){\\n        if(low>high)return INT_MIN;\\n        if(low==high)return 0;\\n        if(dp[low][high]!=-1)return dp[low][high];\\n        \\n        int minMoney = INT_MAX;\\n        int right = 0;\\n        int left=0;\\n        \\n        for(int i=low;i<=high;i++){\\n            right = getMoneyHelper(low,i-1);\\n            left = getMoneyHelper(i+1,high);\\n            \\n            int maxval = max(left,right);\\n            minMoney = min(maxval+i,minMoney);\\n            \\n        }\\n        return dp[low][high] = minMoney;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return getMoneyHelper(1,n);\\n    }\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nint dp[201][201];\\n    \\n    int getMoneyHelper(int low,int high){\\n        if(low>high)return INT_MIN;\\n        if(low==high)return 0;\\n        if(dp[low][high]!=-1)return dp[low][high];\\n        \\n        int minMoney = INT_MAX;\\n        int right = 0;\\n        int left=0;\\n        \\n        for(int i=low;i<=high;i++){\\n            right = getMoneyHelper(low,i-1);\\n            left = getMoneyHelper(i+1,high);\\n            \\n            int maxval = max(left,right);\\n            minMoney = min(maxval+i,minMoney);\\n            \\n        }\\n        return dp[low][high] = minMoney;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return getMoneyHelper(1,n);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2288532,
                "title": "range-dp-c",
                "content": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        range dp\\n        \\n        ------o--------\\n        i     k       j\\n        \\n        f[i, j] = min of all max(f[i, k - 1], f[k + 1, j]) + k, worst case: k is not the picked-up number\\n        \\n        why mean: since we want to find a best guess path\\n    */\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> f(n + 2, vector<int>(n + 2));\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 1; i + len - 1 <= n; i++) {\\n                int j = i + len - 1;\\n                f[i][j] = INT_MAX;\\n                for (int k = i; k <= j; k++) {\\n                    f[i][j] = min(f[i][j], max(f[i][k - 1], f[k + 1][j]) + k);\\n                }\\n            }\\n        }\\n    \\n        return f[1][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        range dp\\n        \\n        ------o--------\\n        i     k       j\\n        \\n        f[i, j] = min of all max(f[i, k - 1], f[k + 1, j]) + k, worst case: k is not the picked-up number\\n        \\n        why mean: since we want to find a best guess path\\n    */\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> f(n + 2, vector<int>(n + 2));\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 1; i + len - 1 <= n; i++) {\\n                int j = i + len - 1;\\n                f[i][j] = INT_MAX;\\n                for (int k = i; k <= j; k++) {\\n                    f[i][j] = min(f[i][j], max(f[i][k - 1], f[k + 1][j]) + k);\\n                }\\n            }\\n        }\\n    \\n        return f[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192744,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(int start,int end,vector<vector<int>> &dp)\\n    {\\n        if(start>=end)\\n        return 0;\\n        if(dp[start][end]!=-1)\\n        return dp[start][end];\\n        int ans=INT_MAX;\\n        for(int i=start;i<=end;i++)\\n        {\\n            ans=min(ans,i+max(fun(start,i-1,dp),fun(i+1,end,dp)));\\n        }\\n        return dp[start][end]=ans;\\n    }\\n    int getMoneyAmount(int n) {\\n      vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n      return fun(1,n,dp);  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int start,int end,vector<vector<int>> &dp)\\n    {\\n        if(start>=end)\\n        return 0;\\n        if(dp[start][end]!=-1)\\n        return dp[start][end];\\n        int ans=INT_MAX;\\n        for(int i=start;i<=end;i++)\\n        {\\n            ans=min(ans,i+max(fun(start,i-1,dp),fun(i+1,end,dp)));\\n        }\\n        return dp[start][end]=ans;\\n    }\\n    int getMoneyAmount(int n) {\\n      vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n      return fun(1,n,dp);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159370,
                "title": "c-memoization-explained",
                "content": "```\\nclass Solution {\\n    int dp[205][205];\\n    int fun(int i , int j)\\n    {\\n        if(i >= j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = i ; k <= j ; k++)\\n        {\\n            int val = k + max(fun(i,k-1) , fun(k+1,j));\\n            ans = min(ans , val);\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int getMoneyAmount(int n) {\\n        for(int i = 0 ; i  < 205  ;i++)\\n            for(int j = 0; j <205; j++)\\n                dp[i][j] = -1;\\n        \\n        int s = 1;\\n        int e = n;\\n        return fun(s,e);\\n    }\\n};\\n```\\n\\n\\nYour Range will be from [1,n] . \\n\\niterate over all numbers within curent range to choose which can become your choice.\\n\\nFor eah choice (k) in current range [i,j] , you have 2 ways (if current choice is not the correct guess) \\n\\t\\ta) **goto range [i,k-1]**\\n\\t\\tb) **goto range [k+1,j]**\\n\\t\\t\\nyou just need to select **max of this (worst case scenario).**\\n\\nSo total cost for this current choice(k) = **ans(k) = k + max(cost[i,k-1] , cost[k+1,j])**  *//Recursive calls*\\n\\nTo get final answer , You need to minimize this answer ans(k) over all k\\'s    i.e. ** Final_ans = min(ans(k))**\\n\\n**Pure Recursion Will give TLE , memoize in terms of i and j (range)**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[205][205];\\n    int fun(int i , int j)\\n    {\\n        if(i >= j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = i ; k <= j ; k++)\\n        {\\n            int val = k + max(fun(i,k-1) , fun(k+1,j));\\n            ans = min(ans , val);\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int getMoneyAmount(int n) {\\n        for(int i = 0 ; i  < 205  ;i++)\\n            for(int j = 0; j <205; j++)\\n                dp[i][j] = -1;\\n        \\n        int s = 1;\\n        int e = n;\\n        return fun(s,e);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053913,
                "title": "python-easy-to-read-and-understand-recusion-memoization",
                "content": "```\\nclass Solution:\\n    def solve(self, start, end):\\n        if start >= end:\\n            return 0\\n        if (start, end) in self.d:\\n            return self.d[(start, end)]\\n        self.d[(start, end)] = float(\"inf\")\\n        for i in range(start, end+1):\\n            cost1 = self.solve(start, i-1) + i\\n            cost2 = self.solve(i+1, end) + i\\n            cost = max(cost1, cost2)\\n            self.d[(start, end)] = min(self.d[(start, end)], cost)\\n        return self.d[(start, end)]\\n    \\n    def getMoneyAmount(self, n: int) -> int:\\n        self.d = {}\\n        return self.solve(1, n)\\n    \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def solve(self, start, end):\\n        if start >= end:\\n            return 0\\n        if (start, end) in self.d:\\n            return self.d[(start, end)]\\n        self.d[(start, end)] = float(\"inf\")\\n        for i in range(start, end+1):\\n            cost1 = self.solve(start, i-1) + i\\n            cost2 = self.solve(i+1, end) + i\\n            cost = max(cost1, cost2)\\n            self.d[(start, end)] = min(self.d[(start, end)], cost)\\n        return self.d[(start, end)]\\n    \\n    def getMoneyAmount(self, n: int) -> int:\\n        self.d = {}",
                "codeTag": "Java"
            },
            {
                "id": 2052665,
                "title": "javascript-easy-explanation-100-100",
                "content": "This problem is about searching for a pivot *(p)* which will divide the numbers to two sections (1 to *p*-1 and *p*+1 to n), where the **maximum search cost between 1 to *p*-1 and *p*+1 to n plus *p*** itself is a possible answer. \\n\\nLet\\'s call the function to get the minimum money between 1 to, say, 10 is findMin(1, 10).\\nThen findMin(1, 10) wil calculate the cost by testing a pivot *p* starting from 10 - 1 (max - 1), there\\'s no point of using the max as the pivot. \\n\\nSo, 1st p = 9. Then the amount of money = 9 + Math.max(findMin(1, 8) , findMin(10, 10))\\nthen we compare with p = 8. The money = 8 + Math.max(findMin(1, 7), findMin(8, 10)). We store the minimum of these two values. \\nand we test with p = 7, and so on, until p = 1.\\n\\n**Optimization: We know that for every pivot *p* the cost for pivot *p-1* would be higher because we will have to pick *p* itself in addition to the same right subsection. Therefore we can skip every other *p* by decreasing p-=2 instead of p--**\\n\\nSince this is a divide and conquer problem with a recursive logic, we will be sure to encounter the same subset multiple times. Therefore a memoization is required. I used a Map instead of a 2D array to save on memory space.\\n\\n**One other important optimization: the value of cost will be higher as the pivot *p* gets closer to the edges (1 or n). As we iterate from higher p to lower p, we can safely assume that if we find a cost that is higher than the minimum, it will only get higher from that point on. So, we can cut the search there.**\\n```\\n\\nlet tab = new Map();    // this tab is for memoization\\n\\nfunction findMin(min, max) {\\n\\n    let count = max - min + 1;\\n    if (count <= 1) return 0;\\n    if (count == 2) return min;\\n    if (count == 3) return min + 1;\\n\\n    // check if we have found the value for findMin(min, max) before\\n    if (tab.has(min)) {\\n        if (tab.get(min).has(max)) return tab.get(min).get(max);\\n    }\\n    let money, minMoney = Infinity;\\n    for (let i = max - 1; i >= min; i-=2) {\\n        money = i + Math.max(findMin(i+1, max) , findMin(min, i-1));\\n        if(minMoney > money) {\\n            minMoney = money;\\n        } else if (minMoney < money) {\\n            // this is just optimization, we assume that the next iteration will only result in a higher cost as the right hand side will have more numbers to guess\\n            break;\\n        }\\n    }\\n\\t\\n\\t// memoize the result first before returning the value\\n    if (!tab.has(min)) tab.set(min, new Map());\\n    tab.get(min).set(max, minMoney);\\n\\t\\n    return minMoney;\\n}\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar getMoneyAmount = function(n) {\\n    return findMin(1, n);\\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nlet tab = new Map();    // this tab is for memoization\\n\\nfunction findMin(min, max) {\\n\\n    let count = max - min + 1;\\n    if (count <= 1) return 0;\\n    if (count == 2) return min;\\n    if (count == 3) return min + 1;\\n\\n    // check if we have found the value for findMin(min, max) before\\n    if (tab.has(min)) {\\n        if (tab.get(min).has(max)) return tab.get(min).get(max);\\n    }\\n    let money, minMoney = Infinity;\\n    for (let i = max - 1; i >= min; i-=2) {\\n        money = i + Math.max(findMin(i+1, max) , findMin(min, i-1));\\n        if(minMoney > money) {\\n            minMoney = money;\\n        } else if (minMoney < money) {\\n            // this is just optimization, we assume that the next iteration will only result in a higher cost as the right hand side will have more numbers to guess\\n            break;\\n        }\\n    }\\n\\t\\n\\t// memoize the result first before returning the value\\n    if (!tab.has(min)) tab.set(min, new Map());\\n    tab.get(min).set(max, minMoney);\\n\\t\\n    return minMoney;\\n}\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar getMoneyAmount = function(n) {\\n    return findMin(1, n);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2044387,
                "title": "easiesst-code-with-explanation",
                "content": "int solve(vector<vector<int>> &dp,int i,int j)\\n    {\\n        if(i>=j)\\n            return 0;\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int mino=INT_MAX;\\n        \\n        //minimum of the (maximum coins among guessing 1-->k-1 and k+1-->n)\\n        for(int k=i;k<=j;k++)\\n            mino=min(mino,k+max(solve(dp,i,k-1),solve(dp,k+1,j)));\\n                   \\n        return dp[i][j]=mino;\\n    }\\n    int getMoneyAmount(int n) {\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(dp,1,n);\\n    }",
                "solutionTags": [],
                "code": "int solve(vector<vector<int>> &dp,int i,int j)\\n    {\\n        if(i>=j)\\n            return 0;\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int mino=INT_MAX;\\n        \\n        //minimum of the (maximum coins among guessing 1-->k-1 and k+1-->n)\\n        for(int k=i;k<=j;k++)\\n            mino=min(mino,k+max(solve(dp,i,k-1),solve(dp,k+1,j)));\\n                   \\n        return dp[i][j]=mino;\\n    }\\n    int getMoneyAmount(int n) {\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(dp,1,n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2037055,
                "title": "simple-conceptual-and-implementational-explanation-for-o-n-2-time-solution",
                "content": "Please checkout [rikimberley\\'s](https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/84823/Java-O(n2)-DP-solution-with-clear-explanation) explanation on which this is based.\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        // notice the difference b/w strategy and choice\\n        // strategy is how we guess the next number\\n        // choice is we have to go higher or lower\\n        // we have to find a solution with best strategy considering worst choices \\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0)); // dp[l][r] stores the ans for [l, r]\\n        // thus, for transitions we have\\n        // dp[l][r] = min(k + max(dp[l][k-1], dp[k+1][r]))\\n        // the innner max denotes that our guess will always be wrong [worst choice]\\n        // and the outer min denotes the overall strategy we will adopt to minimise our loss\\n        // now, lets analyze the above function\\n        // dp[l][k-1] will increase monotonically with k\\n        // dp[k + 1][r] will decrease monotonically with k\\n        // let k0 = max{k : dp[l][k-1] <= dp[k+1][r]}\\n        // if we are able to find such k0 then our ans simply becomes\\n        // dp[l][r] = min(k0 + dp[k0+1][r], k0 + 1 + dp[l][k0 + 1 - 1])\\n        // k0 + dp[k0+1][r] is the right side cost, when we guessed k0\\n        // note because of the selection of k0, max{k : dp[l][k-1] <= dp[k+1][r]}\\n        // at k0 we select the right cost because that is greater than the left CHOICE hence we will loose more money by going right\\n        // k0 + 1 + dp[l][k0 + 1 - 1] is the left side cost, when we guessed k0 + 1\\n        // note because of the selection of k0, max{k : dp[l][k-1] <= dp[k+1][r]}\\n        // at k0 + 1 we select the left cost because that is greater than the right CHOICE hence we will loose more money by going left\\n\\n        int l, r, k0, v;\\n\\n        for (r = 2; r <= n; r++) {\\n\\n            k0 = r - 1; // iterating from the last value\\n            deque<pair<int, int>> dq; // {k, right side cost of guessing k}\\n\\n            for (l = r - 1; l; l--) {\\n\\n                // finding k0\\n                while (dp[l][k0 - 1] > dp[k0 + 1][r]) k0--;\\n\\n                // as we are only pushing the right side values in the deque\\n                // we pop all the right side values which have a greater k than k0\\n                // because they now represent the optimal CHOICE where we can go after taking a guess\\n                // thus, these should not be considered\\n                // popping from front because the largest k values are at the front of the deque\\n                while (!dq.empty() && dq.front().first > k0) dq.pop_front();\\n\\n                // the right side value considering l as k0 for future and present iterations\\n                v = dp[l + 1][r] + l;\\n\\n                // popping all the values which are greater than v\\n                while (!dq.empty() && v < dq.back().second) dq.pop_back();\\n\\n                // only pushing right side values in the deque\\n                dq.push_back({l, v}); // considering l as k0 for future and present iterations\\n\\n                int can_r = dq.front().second; // the appropriate right side value from the deque\\n                int can_l = dp[l][k0] + k0 + 1; // the left side value when we guess k0 + 1\\n\\n                dp[l][r] = min(can_l, can_r);\\n            }\\n        }\\n        return dp[1][n];   \\n    }\\n};\\n```\\nPlease drop a like, it motivates me to provide more of these.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        // notice the difference b/w strategy and choice\\n        // strategy is how we guess the next number\\n        // choice is we have to go higher or lower\\n        // we have to find a solution with best strategy considering worst choices \\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0)); // dp[l][r] stores the ans for [l, r]\\n        // thus, for transitions we have\\n        // dp[l][r] = min(k + max(dp[l][k-1], dp[k+1][r]))\\n        // the innner max denotes that our guess will always be wrong [worst choice]\\n        // and the outer min denotes the overall strategy we will adopt to minimise our loss\\n        // now, lets analyze the above function\\n        // dp[l][k-1] will increase monotonically with k\\n        // dp[k + 1][r] will decrease monotonically with k\\n        // let k0 = max{k : dp[l][k-1] <= dp[k+1][r]}\\n        // if we are able to find such k0 then our ans simply becomes\\n        // dp[l][r] = min(k0 + dp[k0+1][r], k0 + 1 + dp[l][k0 + 1 - 1])\\n        // k0 + dp[k0+1][r] is the right side cost, when we guessed k0\\n        // note because of the selection of k0, max{k : dp[l][k-1] <= dp[k+1][r]}\\n        // at k0 we select the right cost because that is greater than the left CHOICE hence we will loose more money by going right\\n        // k0 + 1 + dp[l][k0 + 1 - 1] is the left side cost, when we guessed k0 + 1\\n        // note because of the selection of k0, max{k : dp[l][k-1] <= dp[k+1][r]}\\n        // at k0 + 1 we select the left cost because that is greater than the right CHOICE hence we will loose more money by going left\\n\\n        int l, r, k0, v;\\n\\n        for (r = 2; r <= n; r++) {\\n\\n            k0 = r - 1; // iterating from the last value\\n            deque<pair<int, int>> dq; // {k, right side cost of guessing k}\\n\\n            for (l = r - 1; l; l--) {\\n\\n                // finding k0\\n                while (dp[l][k0 - 1] > dp[k0 + 1][r]) k0--;\\n\\n                // as we are only pushing the right side values in the deque\\n                // we pop all the right side values which have a greater k than k0\\n                // because they now represent the optimal CHOICE where we can go after taking a guess\\n                // thus, these should not be considered\\n                // popping from front because the largest k values are at the front of the deque\\n                while (!dq.empty() && dq.front().first > k0) dq.pop_front();\\n\\n                // the right side value considering l as k0 for future and present iterations\\n                v = dp[l + 1][r] + l;\\n\\n                // popping all the values which are greater than v\\n                while (!dq.empty() && v < dq.back().second) dq.pop_back();\\n\\n                // only pushing right side values in the deque\\n                dq.push_back({l, v}); // considering l as k0 for future and present iterations\\n\\n                int can_r = dq.front().second; // the appropriate right side value from the deque\\n                int can_l = dp[l][k0] + k0 + 1; // the left side value when we guess k0 + 1\\n\\n                dp[l][r] = min(can_l, can_r);\\n            }\\n        }\\n        return dp[1][n];   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958829,
                "title": "simple-c-dp-3ms-99-74-short",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    \\n    int dp(int l, int r){\\n        if(l >= r) return 0;\\n        if(memo[l][r] != -1) return memo[l][r];\\n        int res = INT32_MAX;\\n        for(int i = r; i >= (l + r) / 2; --i){\\n            int curr = i + max(dp(l, i-1), dp(i+1, r));\\n            if(curr > res) break;\\n            res = curr;\\n        }\\n        return memo[l][r] = res;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        memo.assign(n + 1, vector<int>(n + 1, -1));\\n        return dp(1, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    \\n    int dp(int l, int r){\\n        if(l >= r) return 0;\\n        if(memo[l][r] != -1) return memo[l][r];\\n        int res = INT32_MAX;\\n        for(int i = r; i >= (l + r) / 2; --i){\\n            int curr = i + max(dp(l, i-1), dp(i+1, r));\\n            if(curr > res) break;\\n            res = curr;\\n        }\\n        return memo[l][r] = res;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        memo.assign(n + 1, vector<int>(n + 1, -1));\\n        return dp(1, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900454,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>mem;\\n    int findAns(int s,int e){\\n        if(e==s){\\n            return 0;\\n        } else if(e-s==1){\\n            return s;\\n        } else if(mem[s][e]!=-1){\\n            return mem[s][e];\\n        } else {\\n            int ans=-1;\\n            for(int i=s;i<=e;i++){\\n                if(i-1>=s and i+1<=e){\\n                    int lower=findAns(s,i-1);\\n                    int higher=findAns(i+1,e);\\n                    int currPick=i+max(lower,higher);\\n                    if(ans==-1){\\n                        ans=currPick;\\n                    } else {\\n                        ans=min(ans,currPick);\\n                    }\\n                }\\n            }\\n            return mem[s][e]=ans;\\n        }\\n    }\\npublic:\\n    int getMoneyAmount(int n) {\\n        mem=vector<vector<int>>(n+1,vector<int>(n+1,-1));\\n        return findAns(1,n);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<vector<int>>mem;\\n    int findAns(int s,int e){\\n        if(e==s){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1850265,
                "title": "java-dp-solution",
                "content": "class Solution {\\n    public int getMoneyAmount(int n) {\\n        int [][] dp = new int[n+1][n+1];\\n        for(int [] row: dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return getMoneyAmount(1,n,dp);    \\n    }\\n    \\n    public int getMoneyAmount(int min, int max, int [][] dp){\\n        if(min >=max)return 0;\\n        if(dp[min][max]!=-1)return dp[min][max];\\n        int res = Integer.MAX_VALUE;\\n        for(int i = min; i <=max;i++){\\n            int higher = i+getMoneyAmount(i+1, max,dp);\\n            int lower = i+getMoneyAmount(min,i-1,dp);\\n            res = Math.min(res,Math.max(higher,lower));\\n        }\\n        dp[min][max]= res;\\n        return res;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getMoneyAmount(int n) {\\n        int [][] dp = new int[n+1][n+1];\\n        for(int [] row: dp){\\n            Arrays.fill(row,-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1838661,
                "title": "intuitive-c-approach-using-recursion-with-tree-diagram",
                "content": "**So lets first understand whats the question is actually saying. I found the question little ambiguous**\\nBasically you are given a value n. you can guess any number from 1 to n. It\\'s a garuantee you will be winning because the user would be giving us an range wether the number you have guessed is ***higher or lower*** . And whenever you guess a wrong number then basically you have to give certain amount of money **[which is equal to your guessing number]**. \\n*You have to find a guessing combination so that amount you gonna pay should be as low as possible.*\\n\\n**Please note: we wont be using Binary Search reason being it doesn\\'t gives us a combination such that amount to be paid is always minimum. As taking middle element everytime as an guess doesn\\'t gives us an optimal solution**\\n\\nFor an example: n = 3\\n```\\nFor simplicity let\\'s assume we are given an array of [1,2,3]\\narr = [1,2,3]\\nsubtree is -->        [1, 2, 3]\\n                  /       |      \\\\\\n        guess     1       2       3\\n                   \\\\     / \\\\      /\\n    new Subtree     \\\\  [1] [3]  [1,2]\\n                     \\\\            /\\\\\\n                   [2,3]         /  \\\\\\n                     /\\\\         /    \\\\\\n                    /  \\\\       /      \\\\\\n                   2    3     1        2     <-- guess\\n                   |    |     |        |\\n                  [3]  [2]   [2]      [1]  < -- new subtree\\n\\t\\t\\t\\t  The new subtree which we are getting is of size 1. So, whatever is our next guessing will always be correct as there will be 1 element in the array and we dont have to pay anything to them.\\n```\\n\\nAt first we are given an array [1,2,3].\\n1. If we guess 1 then subtree becomes [2,3]. We have to guess again from the subtree [2,3], We can guess any number *2 or 3*. Whatever we chose our new subtree becomes [3] or [2]. **Please look at the tree for visualisation.**\\n2. If we guess 2 then there are two subtree [1] and [3]\\n3. If we guess 3 then subtree becomes [1,2]. We have to guess again from the subtree [1,2]\\n\\nFrom the tree we have to pay only **$2**  (minimum of all other guess) if we chose the number **2** because the new subtree becomes [1] or [3] and our next guess will always be a correct one.\\n\\n```\\nclass Solution {\\npublic:\\n    int recursion(int start, int end){\\n        \\n        if(start>=end) return 0;\\n        \\n        int minAmount = INT_MAX;\\n        for(int i=start;i<=end;i++){\\n            \\n           int leftSubtree  = min(minAmount,i+recursion(start,i-1));\\n           int rightSubtree = min(minAmount,i+recursion(i+1,end));\\n           minAmount = max(leftSubtree,rightSubtree);  /*we are taking maximum of left and right subtree because we want to calculate in worst case scenarion. i.e. what if we guess every time wrong then what will be the maximum value*/\\n        }\\n        return minAmount;\\n    }\\n    int getMoneyAmount(int n) {\\n        return recursion(1,n);\\n    }\\n};\\n```\\n\\nRecursive + Memo Solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int recursion(int start, int end, vector<vector<int>> & memo){\\n        \\n        if(start>=end) return 0;\\n        \\n        if(memo[start][end]!=-1) return memo[start][end];\\n        \\n        int minAmount = INT_MAX;\\n        for(int i=start;i<=end;i++){\\n            \\n           int leftSubtree  = min(minAmount,i+recursion(start,i-1,memo));\\n           int rightSubtree = min(minAmount,i+recursion(i+1,end,memo));\\n           minAmount = max(leftSubtree,rightSubtree);\\n        }\\n        memo[start][end]=minAmount;\\n        return minAmount;\\n    }\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> memo(n+1,vector<int>(n+1,-1));\\n        return recursion(1,n,memo);\\n    }\\n};\\n\\n```\\n\\nPlease do upvote if you like the explanation.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nFor simplicity let\\'s assume we are given an array of [1,2,3]\\narr = [1,2,3]\\nsubtree is -->        [1, 2, 3]\\n                  /       |      \\\\\\n        guess     1       2       3\\n                   \\\\     / \\\\      /\\n    new Subtree     \\\\  [1] [3]  [1,2]\\n                     \\\\            /\\\\\\n                   [2,3]         /  \\\\\\n                     /\\\\         /    \\\\\\n                    /  \\\\       /      \\\\\\n                   2    3     1        2     <-- guess\\n                   |    |     |        |\\n                  [3]  [2]   [2]      [1]  < -- new subtree\\n\\t\\t\\t\\t  The new subtree which we are getting is of size 1. So, whatever is our next guessing will always be correct as there will be 1 element in the array and we dont have to pay anything to them.\\n```\n```\\nclass Solution {\\npublic:\\n    int recursion(int start, int end){\\n        \\n        if(start>=end) return 0;\\n        \\n        int minAmount = INT_MAX;\\n        for(int i=start;i<=end;i++){\\n            \\n           int leftSubtree  = min(minAmount,i+recursion(start,i-1));\\n           int rightSubtree = min(minAmount,i+recursion(i+1,end));\\n           minAmount = max(leftSubtree,rightSubtree);  /*we are taking maximum of left and right subtree because we want to calculate in worst case scenarion. i.e. what if we guess every time wrong then what will be the maximum value*/\\n        }\\n        return minAmount;\\n    }\\n    int getMoneyAmount(int n) {\\n        return recursion(1,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int recursion(int start, int end, vector<vector<int>> & memo){\\n        \\n        if(start>=end) return 0;\\n        \\n        if(memo[start][end]!=-1) return memo[start][end];\\n        \\n        int minAmount = INT_MAX;\\n        for(int i=start;i<=end;i++){\\n            \\n           int leftSubtree  = min(minAmount,i+recursion(start,i-1,memo));\\n           int rightSubtree = min(minAmount,i+recursion(i+1,end,memo));\\n           minAmount = max(leftSubtree,rightSubtree);\\n        }\\n        memo[start][end]=minAmount;\\n        return minAmount;\\n    }\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> memo(n+1,vector<int>(n+1,-1));\\n        return recursion(1,n,memo);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830371,
                "title": "python-recursion-with-memorization",
                "content": "```\\nclass Solution(object):\\n    def getMoneyAmount(self, n):\\n        if n==1:\\n            return 0\\n        def guess(i,j):\\n            if(i==j):\\n                return 0\\n            if (i==j-1):\\n                return i\\n            if str(i)+\":\"+str(j) in memo:\\n                return memo[str(i)+\":\"+str(j)]\\n            m=(i+j)//2\\n            ans=999999999999999999\\n            for item in range(m,j):\\n                left=guess(i,item-1)\\n                right=guess(item+1,j)\\n                a=max(left,right)+item\\n                ans=min(a,ans)\\n            memo[str(i)+\":\"+str(j)]=ans\\n            return ans\\n        memo={}\\n        return guess(0,n)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution(object):\\n    def getMoneyAmount(self, n):\\n        if n==1:\\n            return 0\\n        def guess(i,j):\\n            if(i==j):\\n                return 0\\n            if (i==j-1):\\n                return i\\n            if str(i)+\":\"+str(j) in memo:\\n                return memo[str(i)+\":\"+str(j)]\\n            m=(i+j)//2\\n            ans=999999999999999999\\n            for item in range(m,j):\\n                left=guess(i,item-1)\\n                right=guess(item+1,j)\\n                a=max(left,right)+item\\n                ans=min(a,ans)\\n            memo[str(i)+\":\"+str(j)]=ans\\n            return ans\\n        memo={}",
                "codeTag": "Java"
            },
            {
                "id": 1815887,
                "title": "java-solution",
                "content": "static int memo[][];\\n    static int n;\\n\\n    public int getMoneyAmount(int m) {\\n        n = m;\\n        memo = new int[n+1][n+1];\\n        for (int [] x:memo) {\\n            Arrays.fill(x, -1);\\n        }\\n        return dp(1, n);\\n    }\\n    \\n    public static int dp(int s, int e){\\n        if(s >= e)return 0;\\n\\t\\t\\n\\t\\t //the idea is to  compute the maximum amount of money I need to pay with my guesses ranging from s to e.\\n            //Since I want to minimize my payoff, I\\'ll choose the starting point [s,e] that has the minimum payoff.\\n            //But for each starting point, I\\'ll choose the maximum amount of money I pay, since I need the worst case scenario.\\n        if(memo[s][e] != -1)return memo[s][e];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = s ; i<= e ; i++){\\n            ans = Math.min(ans, i + Math.max(dp(s, i-1), dp(i+1, e)));\\n        }\\n        return memo[s][e] = ans;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "static int memo[][];\\n    static int n;\\n\\n    public int getMoneyAmount(int m) {\\n        n = m;\\n        memo = new int[n+1][n+1];\\n        for (int [] x:memo) {\\n            Arrays.fill(x, -1);\\n        }\\n        return dp(1, n);\\n    }\\n    \\n    public static int dp(int s, int e){\\n        if(s >= e)return 0;\\n\\t\\t\\n\\t\\t //the idea is to  compute the maximum amount of money I need to pay with my guesses ranging from s to e.\\n            //Since I want to minimize my payoff, I\\'ll choose the starting point [s,e] that has the minimum payoff.\\n            //But for each starting point, I\\'ll choose the maximum amount of money I pay, since I need the worst case scenario.\\n        if(memo[s][e] != -1)return memo[s][e];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = s ; i<= e ; i++){\\n            ans = Math.min(ans, i + Math.max(dp(s, i-1), dp(i+1, e)));\\n        }\\n        return memo[s][e] = ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1809080,
                "title": "c-100-lines-of-explain-like-im-five-10-lines-crisp-code-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> f; // memoization \\n    \\n    int memo(int i, int j){\\n        \\n        /*\\n        - currently game played b/w numbers: i,i+1,i+2....j-1,j\\n        \\n        - returns the minimum amount of money I need to guarantee a win regardless of what number other picks in [i, j]\\n\\n        */\\n        \\n        if(f[i][j] != -1) return f[i][j];\\n        \\n        // If i == j:\\n        // Then there is only one number hence my guess will always be right, so I pay 0 money\\n        if(i == j) return  f[i][j] = 0;\\n        \\n        \\n        \\n        int min_k = INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            \\n            /* \\n            - Let\\' say in the first try, I guess the number k (i<=k<=j)\\n            - In the best case, my guess k itself is right and so I pay 0 money\\n            \\n            - However, what if my guess k is not right?\\n            - So, there are two cases:\\n                [L] Either k is too high for him, in which case the game moves to [i...k-1]\\n                [R] Else, k is too low for him, in which case the game moves to [k+1...j]\\n            \\n            - Lets, say the minimum money required to guarantee a win in case [L] = minL\\n            - And, say the minimum money required to guarantee a win in case [R] = minR\\n            \\n            - Now, the question I ask you is:\\n            Q. What is the minimum money rqd to GUARANTEE A WIN in [i..j] given that I guessed k in the first try?\\n            A. Okay, lets see\\n                - [Case1] We are lucky and our guess is right=> Min. money rqd to win in [i..j] = 0\\n                - [CaseL] We are unlucky, and k is high for him=> Min. money rqd to win in [i..j] = k + minL\\n                - [CaseR] We are unlucky, ans k is low for him=> Min. money rqd to win in [i..j] = k + minR\\n                - It is worth noting that, we dont have control over what he chose in the first place\\n                \\n                - Hence, In the WORST CASE SCENARIO, FOR ME TO WIN, I need NO MORE THAN: MAX(Case1, CaseL, CaseR) money\\n                - Meaning that, In the worst case, he chose a number such that, in order for me to win I had to \\n                spend the maximum money \\n                \\n                - Since \"I MUST GUARANTEE A WIN, SO I MUST EVEN WIN IN THE WORST CASE SCENARIO\" \\n                hence I need NO MORE THAN = MAX(0, k+minL, k+minR) money to WIN IN WORST CASE\\n                \\n                -HENCE the MINIMUM AMOUNT OF MONEY RQD TO GUARANTEE A WIN in [i...j] GIVEN THAT I  CHOSE k IN FIRST TRY is equal to = MAX(0, k+minL, k+minR) money [which corresponds to the worst case scenario]\\n                \\n\\n                                \\n            \\n            - OKAY, so for a particular value of k, we have found out:\\n            \\n              min_k = MIN AMOUNT OF MONEY RQD TO GUARANTEE A WIN in [i...j] GIVEN THAT **\"I CHOSE k IN THE FIRST TRY\"**\\n              \\n            \\n            - But, I HAVE THE FREEDOM TO CHOSE ANY VALUE OF k (in the range [i...j]) IN MY FIRST TRY!\\n            \\n            - Hence, I WILL CHOSE THAT k in THE FIST TRY WHICH CORRESPONDS TO THE MINIMUM VALUE OF min_k OVER ALL k.\\n        \\n            */\\n            \\n            int minL = (k == i ? 0 : memo(i,k-1));\\n            int minR = (k == j ? 0 : memo(k+1,j));\\n            \\n            \\n            int worstCase = max( { 0, k+minL, k+minR  }  );\\n            \\n            min_k = min(min_k, worstCase);\\n        }\\n        \\n        return  f[i][j] = min_k;\\n    }\\n    \\n    \\n    int getMoneyAmount(int n) {\\n        f.resize(n+1, vector<int>(n+1, -1));\\n        \\n        return memo(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> f; // memoization \\n    \\n    int memo(int i, int j){\\n        \\n        /*\\n        - currently game played b/w numbers: i,i+1,i+2....j-1,j\\n        \\n        - returns the minimum amount of money I need to guarantee a win regardless of what number other picks in [i, j]\\n\\n        */\\n        \\n        if(f[i][j] != -1) return f[i][j];\\n        \\n        // If i == j:\\n        // Then there is only one number hence my guess will always be right, so I pay 0 money\\n        if(i == j) return  f[i][j] = 0;\\n        \\n        \\n        \\n        int min_k = INT_MAX;\\n        for(int k=i;k<=j;k++){\\n            \\n            /* \\n            - Let\\' say in the first try, I guess the number k (i<=k<=j)\\n            - In the best case, my guess k itself is right and so I pay 0 money\\n            \\n            - However, what if my guess k is not right?\\n            - So, there are two cases:\\n                [L] Either k is too high for him, in which case the game moves to [i...k-1]\\n                [R] Else, k is too low for him, in which case the game moves to [k+1...j]\\n            \\n            - Lets, say the minimum money required to guarantee a win in case [L] = minL\\n            - And, say the minimum money required to guarantee a win in case [R] = minR\\n            \\n            - Now, the question I ask you is:\\n            Q. What is the minimum money rqd to GUARANTEE A WIN in [i..j] given that I guessed k in the first try?\\n            A. Okay, lets see\\n                - [Case1] We are lucky and our guess is right=> Min. money rqd to win in [i..j] = 0\\n                - [CaseL] We are unlucky, and k is high for him=> Min. money rqd to win in [i..j] = k + minL\\n                - [CaseR] We are unlucky, ans k is low for him=> Min. money rqd to win in [i..j] = k + minR\\n                - It is worth noting that, we dont have control over what he chose in the first place\\n                \\n                - Hence, In the WORST CASE SCENARIO, FOR ME TO WIN, I need NO MORE THAN: MAX(Case1, CaseL, CaseR) money\\n                - Meaning that, In the worst case, he chose a number such that, in order for me to win I had to \\n                spend the maximum money \\n                \\n                - Since \"I MUST GUARANTEE A WIN, SO I MUST EVEN WIN IN THE WORST CASE SCENARIO\" \\n                hence I need NO MORE THAN = MAX(0, k+minL, k+minR) money to WIN IN WORST CASE\\n                \\n                -HENCE the MINIMUM AMOUNT OF MONEY RQD TO GUARANTEE A WIN in [i...j] GIVEN THAT I  CHOSE k IN FIRST TRY is equal to = MAX(0, k+minL, k+minR) money [which corresponds to the worst case scenario]\\n                \\n\\n                                \\n            \\n            - OKAY, so for a particular value of k, we have found out:\\n            \\n              min_k = MIN AMOUNT OF MONEY RQD TO GUARANTEE A WIN in [i...j] GIVEN THAT **\"I CHOSE k IN THE FIRST TRY\"**\\n              \\n            \\n            - But, I HAVE THE FREEDOM TO CHOSE ANY VALUE OF k (in the range [i...j]) IN MY FIRST TRY!\\n            \\n            - Hence, I WILL CHOSE THAT k in THE FIST TRY WHICH CORRESPONDS TO THE MINIMUM VALUE OF min_k OVER ALL k.\\n        \\n            */\\n            \\n            int minL = (k == i ? 0 : memo(i,k-1));\\n            int minR = (k == j ? 0 : memo(k+1,j));\\n            \\n            \\n            int worstCase = max( { 0, k+minL, k+minR  }  );\\n            \\n            min_k = min(min_k, worstCase);\\n        }\\n        \\n        return  f[i][j] = min_k;\\n    }\\n    \\n    \\n    int getMoneyAmount(int n) {\\n        f.resize(n+1, vector<int>(n+1, -1));\\n        \\n        return memo(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710920,
                "title": "c-2-dp-solutions-top-down-bottom-up",
                "content": "The diea of a top-down solution is to find out minimum worse case each section of 1 - n at each starting point.\\n\\nFor example, if n = 4, we will need to calculate the maximum cost if we first pick 1, 2, 3 or 4, while returning the minimum of all of the first picks. If we first picked 1, we will need to calculate the maximum cost if we second pick 2, 3 or 4. until there is only 1 option left where we return 0.\\n\\nTime complexity: ~O(n^3), for subset of size 1 to n, we have to iterate (1 to n) with a fixed length window. Within the window, we have to calculate the maximum cost of each starting point of the sub-array.\\n\\nSpace complexity: O(n^2) for the 2D array storing minimum cost for each start, end pair.\\n\\nTop-down solution:\\n```\\nclass Solution {\\nprivate:\\n    int helper(int start, int end, vector<vector<int>> &memo) {\\n        if (start >= end) return 0;\\n        if (memo[start][end] != INT_MAX) return memo[start][end];\\n        \\n        int res = INT_MAX;\\n        \\n        for (int i = start; i <= end; i++) {\\n            int temp = i;\\n            temp += max(helper(start, i - 1, memo), helper(i + 1, end, memo));\\n            res = min(res, temp);\\n        }\\n        \\n        memo[start][end] = res;\\n        return res;\\n    }\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> memo (n + 1, vector<int>(n + 1, INT_MAX));\\n        return helper(1, n, memo);\\n    }\\n};\\n```\\n\\nFor the bottom-up varient, we build the case starting 1 number remaining, then build the minimum cost from 2 number remaining to n number remaining\\n\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp (n + 1, vector<int>(n + 1, 0));\\n        \\n        for (int len = 2; len <= n; len++) {\\n            int maxStart = n - len + 1;\\n            for (int start = 1; start <= maxStart; start++) {\\n                int end = start + len - 1;\\n                int temp = INT_MAX;\\n                for (int i = start; i <= end; i++) {\\n                    if (i == start) {\\n                        temp = min(temp, i + dp[i + 1][end]);\\n                    } else if (i == end) {\\n                        temp = min(temp, i + dp[start][i - 1]);\\n                    } else {\\n                        temp = min(temp, i + max(dp[start][i - 1], dp[i + 1][end]));\\n                    }\\n                }\\n                dp[start][end] = temp;\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n\\t```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(int start, int end, vector<vector<int>> &memo) {\\n        if (start >= end) return 0;\\n        if (memo[start][end] != INT_MAX) return memo[start][end];\\n        \\n        int res = INT_MAX;\\n        \\n        for (int i = start; i <= end; i++) {\\n            int temp = i;\\n            temp += max(helper(start, i - 1, memo), helper(i + 1, end, memo));\\n            res = min(res, temp);\\n        }\\n        \\n        memo[start][end] = res;\\n        return res;\\n    }\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> memo (n + 1, vector<int>(n + 1, INT_MAX));\\n        return helper(1, n, memo);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp (n + 1, vector<int>(n + 1, 0));\\n        \\n        for (int len = 2; len <= n; len++) {\\n            int maxStart = n - len + 1;\\n            for (int start = 1; start <= maxStart; start++) {\\n                int end = start + len - 1;\\n                int temp = INT_MAX;\\n                for (int i = start; i <= end; i++) {\\n                    if (i == start) {\\n                        temp = min(temp, i + dp[i + 1][end]);\\n                    } else if (i == end) {\\n                        temp = min(temp, i + dp[start][i - 1]);\\n                    } else {\\n                        temp = min(temp, i + max(dp[start][i - 1], dp[i + 1][end]));\\n                    }\\n                }\\n                dp[start][end] = temp;\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1702290,
                "title": "sinkinben-c-interval-dp",
                "content": "### 375. Guess Number Higher or Lower II\\n\\nInterval dynamic programming.\\n\\n- Let `dp[i, j]` denote the minimum amount of money we need, to guess a number in range `[i, j]` (and guarantee to figure it out).\\n- If we guess `k` in `(i, j)`, and we guess wrong. Then we should pay `k` dollars. To figure the number out in range `[i, j]`, and we need pay `max(dp[i, k - 1], dp[k + 1, j])` dollars more.\\n- The `max(dp[i, k - 1], dp[k + 1, j])` means, if `k` is wrong, and someone tell you that you should guess in its left or right. But for these two branch, we should choose the worse one, since we need to **guarantee a win**.\\n\\nThat is to say:\\n```text\\nfor (k = i + 1 to j - 1)\\n  dp[i, j] = min(max(dp[i, k - 1], dp[k + 1, j]) + k)\\n```\\n\\nHere is our code:\\n```cpp\\nclass Solution {\\npublic:\\n    const int INF = 0x3f3f3f3f;\\n    int getMoneyAmount(int n) \\n    {\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        for (int i = 0; i <= n; ++i)\\n        {\\n            dp[i][i] = 0;\\n            if (i + 1 <= n) dp[i][i + 1] = i;\\n            if (i + 2 <= n) dp[i][i + 2] = i + 1;\\n        }\\n        \\n        for (int d = 3; d <= n; ++d)\\n        {\\n            for (int i = 1; i + d <= n; ++i)\\n            {\\n                int j = i + d;\\n                dp[i][j] = INT_MAX;\\n                for (int k = i + 1; k + 1 <= j; ++k)\\n                    dp[i][j] = min(dp[i][j], max(dp[i][k - 1], dp[k + 1][j]) + k);\\n            }\\n        }\\n        return dp[1][n];\\n\\n    }\\n};\\n\\n/*\\n * dp[i, j] denote minimum amount of money we need, to guess a number in range [i, j] (and guarantee to figure it out)\\n * dp[i, j] = min(max(dp[i, k - 1], dp[k + 1, j]) + k) for every `k` satisfying i <= k - 1 and k + 1 <= j\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```text\\nfor (k = i + 1 to j - 1)\\n  dp[i, j] = min(max(dp[i, k - 1], dp[k + 1, j]) + k)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const int INF = 0x3f3f3f3f;\\n    int getMoneyAmount(int n) \\n    {\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        for (int i = 0; i <= n; ++i)\\n        {\\n            dp[i][i] = 0;\\n            if (i + 1 <= n) dp[i][i + 1] = i;\\n            if (i + 2 <= n) dp[i][i + 2] = i + 1;\\n        }\\n        \\n        for (int d = 3; d <= n; ++d)\\n        {\\n            for (int i = 1; i + d <= n; ++i)\\n            {\\n                int j = i + d;\\n                dp[i][j] = INT_MAX;\\n                for (int k = i + 1; k + 1 <= j; ++k)\\n                    dp[i][j] = min(dp[i][j], max(dp[i][k - 1], dp[k + 1][j]) + k);\\n            }\\n        }\\n        return dp[1][n];\\n\\n    }\\n};\\n\\n/*\\n * dp[i, j] denote minimum amount of money we need, to guess a number in range [i, j] (and guarantee to figure it out)\\n * dp[i, j] = min(max(dp[i, k - 1], dp[k + 1, j]) + k) for every `k` satisfying i <= k - 1 and k + 1 <= j\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666215,
                "title": "c-recursive-and-bottom-up-fully-explained",
                "content": "**INTUITION**\\nIn question it\\'s said that we need to provide the minimum amount for winning, no matter what the number was picked.\\nThis gives us a clue that we need to assume the worst that is possible if we want to win in any condition.\\n\\nNow, our player would select strategies according to the given recurrence.\\n\\n```\\nfunc(1,n) = min_{for all num} (max(num + func(1, num - 1) , num + func(num + 1, n))\\n```\\n*What does it demonstrates?*\\n\\nOur player would have to simulate this recurrence and pick/play the `num` (corresponding to the least possible amount to win) if they wants to win in minimum amount possible.\\n\\nEach time they play `num` we ask what worse could happen?\\n\\nCase(i): The actual number might be in `[num + 1 , n]`\\nCase(ii): The actual number might be in `[1, num-1]`\\n\\nAnd we know that we want to win in any condition therefore we will assume the worst:\\n\\nWhich is done by asking for `max((num + func(1, num - 1) , num + func(num + 1, n))`\\n\\n**Recursive Implementation**\\n```\\nvector<vector<int>> dp;\\nint rec(int low , int high){\\n\\tif(low >= high) return 0;\\n\\tif(dp[low][high] != -1) return dp[low][high];\\n\\n\\tint ans = INT_MAX;\\n\\tfor(int i = low ; i <= high ; i++){\\n\\t\\t//guessed i\\n\\t\\tint case1 = i + rec(low , i - 1);//guessed i and it is higher than expected\\n\\t\\tint case2 = i + rec(i + 1 , high);//guessed i and it is lower than expected\\n\\t\\tans = min(ans , max(case1, case2));\\n\\t}\\n\\treturn dp[low][high] = ans;\\n}\\n```\\n**Iterative implementation**\\n```\\nint bottomup(int n){\\n\\tvector<vector<int>> dp(n + 1 , vector<int>(n + 1 , 0));\\n\\n\\tfor(int window = 1 ; window < n ; window++){\\n\\t\\tfor(int low = 1 ; low <= n - window ; low++){\\n\\t\\t\\tint high = low + window;\\n\\t\\t\\tint ans = INT_MAX;\\n\\t\\t\\tfor(int num = low ; num <= high ; num++){\\n\\t\\t\\t\\tint case1 = num + (num - 1 >= 0 ? dp[low][num - 1] : 0);\\n\\t\\t\\t\\tint case2 = num + (num + 1 <= n  ? dp[num + 1][high] : 0);\\n\\t\\t\\t\\tans = min(ans , max(case1 , case2));\\n\\t\\t\\t}\\n\\t\\t\\tdp[low][high] = ans;\\n\\t\\t}\\n\\t}\\n\\treturn dp[1][n];\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nfunc(1,n) = min_{for all num} (max(num + func(1, num - 1) , num + func(num + 1, n))\\n```\n```\\nvector<vector<int>> dp;\\nint rec(int low , int high){\\n\\tif(low >= high) return 0;\\n\\tif(dp[low][high] != -1) return dp[low][high];\\n\\n\\tint ans = INT_MAX;\\n\\tfor(int i = low ; i <= high ; i++){\\n\\t\\t//guessed i\\n\\t\\tint case1 = i + rec(low , i - 1);//guessed i and it is higher than expected\\n\\t\\tint case2 = i + rec(i + 1 , high);//guessed i and it is lower than expected\\n\\t\\tans = min(ans , max(case1, case2));\\n\\t}\\n\\treturn dp[low][high] = ans;\\n}\\n```\n```\\nint bottomup(int n){\\n\\tvector<vector<int>> dp(n + 1 , vector<int>(n + 1 , 0));\\n\\n\\tfor(int window = 1 ; window < n ; window++){\\n\\t\\tfor(int low = 1 ; low <= n - window ; low++){\\n\\t\\t\\tint high = low + window;\\n\\t\\t\\tint ans = INT_MAX;\\n\\t\\t\\tfor(int num = low ; num <= high ; num++){\\n\\t\\t\\t\\tint case1 = num + (num - 1 >= 0 ? dp[low][num - 1] : 0);\\n\\t\\t\\t\\tint case2 = num + (num + 1 <= n  ? dp[num + 1][high] : 0);\\n\\t\\t\\t\\tans = min(ans , max(case1 , case2));\\n\\t\\t\\t}\\n\\t\\t\\tdp[low][high] = ans;\\n\\t\\t}\\n\\t}\\n\\treturn dp[1][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1657388,
                "title": "c-recursion-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMoney(int start, int end, vector<vector<int>> &memo) {\\n        if (start >= end) return 0;\\n        \\n        if (memo.at(start).at(end) != -1) return memo.at(start).at(end);\\n        \\n        int minMoney = INT_MAX;\\n        for (int i = start; i <= end; i++){\\n            int lower  = minimumMoney(start, i - 1, memo);\\n            int higher = minimumMoney(i + 1, end, memo);\\n            int money  = i + max(lower, higher);\\n                        \\n            minMoney = min(minMoney, money);\\n        }\\n        \\n        return memo.at(start).at(end) = minMoney;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> memo(n + 1, vector<int>(n + 1, -1));\\n        \\n        return minimumMoney(0, n, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoney(int start, int end, vector<vector<int>> &memo) {\\n        if (start >= end) return 0;\\n        \\n        if (memo.at(start).at(end) != -1) return memo.at(start).at(end);\\n        \\n        int minMoney = INT_MAX;\\n        for (int i = start; i <= end; i++){\\n            int lower  = minimumMoney(start, i - 1, memo);\\n            int higher = minimumMoney(i + 1, end, memo);\\n            int money  = i + max(lower, higher);\\n                        \\n            minMoney = min(minMoney, money);\\n        }\\n        \\n        return memo.at(start).at(end) = minMoney;\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> memo(n + 1, vector<int>(n + 1, -1));\\n        \\n        return minimumMoney(0, n, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518307,
                "title": "python-dp-memoziation-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n        Consider the numbers are in range 1-n.\\n        We need to check for all numbers from 1 to n for which the total penalty is minimum.\\n        Suppose we guessed a number k between 1-n, therefore, our penalty would be =>\\n            k + max(penalty for numbers in the range 1 to k-1, penalty for numbers in the range k+1 to n)\\n            as after every guess we would know when the target is lower than or greater than our guess.\\n        Now we just need to find the penalty for all k in the range 1-n and the k which gives the minimum penalty would be our answer.\\n    \"\"\"\\n    def dp(self, start, end, lookup):\\n        if start >= end:\\n            return 0\\n        if (start, end) not in lookup:\\n            money = sys.maxsize\\n            for penalty in range(start, end+1):\\n                money = min(money, penalty + max(self.dp(start, penalty - 1, lookup), self.dp(penalty+1, end, lookup)))\\n            lookup[(start, end)] = money\\n        return lookup[(start, end)]\\n        \\n    def getMoneyAmount(self, n: int) -> int:\\n        return self.dp(1, n, {})\\n    \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n        Consider the numbers are in range 1-n.\\n        We need to check for all numbers from 1 to n for which the total penalty is minimum.\\n        Suppose we guessed a number k between 1-n, therefore, our penalty would be =>\\n            k + max(penalty for numbers in the range 1 to k-1, penalty for numbers in the range k+1 to n)\\n            as after every guess we would know when the target is lower than or greater than our guess.\\n        Now we just need to find the penalty for all k in the range 1-n and the k which gives the minimum penalty would be our answer.\\n    \"\"\"\\n    def dp(self, start, end, lookup):\\n        if start >= end:\\n            return 0\\n        if (start, end) not in lookup:\\n            money = sys.maxsize\\n            for penalty in range(start, end+1):\\n                money = min(money, penalty + max(self.dp(start, penalty - 1, lookup), self.dp(penalty+1, end, lookup)))\\n            lookup[(start, end)] = money\\n        return lookup[(start, end)]\\n        \\n    def getMoneyAmount(self, n: int) -> int:\\n        return self.dp(1, n, {})\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437801,
                "title": "java-recursive-dp-solution",
                "content": "```\\n// Recursive DP Solution\\n// Time complexity: O(n^3)\\n// Space complexity: O(n^2)\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        if (n <= 1) return 0;\\n        int[][] dp = new int[n+1][n+1];\\n        return explore(0, n, dp);\\n    }\\n    \\n    private int explore(int left, int right, int[][] dp) {\\n        if (left >= right) return 0;\\n        if (dp[left][right] > 0) return dp[left][right];\\n        int minCost = Integer.MAX_VALUE;\\n        for (int i = left; i <= right; i++) {\\n            int cost = i + Math.max(explore(left, i-1, dp), explore(i+1, right, dp));   // max to consider the worst case.\\n            minCost = Math.min(minCost, cost);\\n        }\\n        dp[left][right] = minCost;\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Recursive DP Solution\\n// Time complexity: O(n^3)\\n// Space complexity: O(n^2)\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        if (n <= 1) return 0;\\n        int[][] dp = new int[n+1][n+1];\\n        return explore(0, n, dp);\\n    }\\n    \\n    private int explore(int left, int right, int[][] dp) {\\n        if (left >= right) return 0;\\n        if (dp[left][right] > 0) return dp[left][right];\\n        int minCost = Integer.MAX_VALUE;\\n        for (int i = left; i <= right; i++) {\\n            int cost = i + Math.max(explore(left, i-1, dp), explore(i+1, right, dp));   // max to consider the worst case.\\n            minCost = Math.min(minCost, cost);\\n        }\\n        dp[left][right] = minCost;\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416152,
                "title": "python3-dp-solution-time-beats-70-space-beats-88",
                "content": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\\n        for length in range(2, n + 1):\\n            for left in range(1, n - length + 2):\\n                right = left + length - 1\\n                dp[left][right] = float(\\'inf\\')\\n                for k in range(left + 1, right):\\n                    dp[left][right] = min(dp[left][right], max(dp[left][k - 1], dp[k + 1][right]) + k)\\n                if left + 1 = right:\\n                    dp[left][left + 1] = left\\n        return dp[1][n]\\n    #the idea of my solution is to find the best case in worst case. what does it mean? \\n    #we know the big interval relys on small interval, so we will only study the smallest case\\n    #if the interval is 0, dp[i][i] what is the value of this interval? it has to be 0, because you dont need to guess\\n    #what if the interval is 2, impossible to have interval 1, interval is 2 the value should be the smaller number\\n    #lets look at this example: [1,2] [2,3] you definatly gonna pick the cheap one, because after you pick one the answer\\n    #will be the another. \\n    #because all the even interval will rely on the dp of interval 2, so once the dp[i][i + 1] is solved, the whole problem is solved !\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\\n        for length in range(2, n + 1):\\n            for left in range(1, n - length + 2):\\n                right = left + length - 1\\n                dp[left][right] = float(\\'inf\\')\\n                for k in range(left + 1, right):\\n                    dp[left][right] = min(dp[left][right], max(dp[left][k - 1], dp[k + 1][right]) + k)\\n                if left + 1 = right:\\n                    dp[left][left + 1] = left\\n        return dp[1][n]\\n    #the idea of my solution is to find the best case in worst case. what does it mean? \\n    #we know the big interval relys on small interval, so we will only study the smallest case\\n    #if the interval is 0, dp[i][i] what is the value of this interval? it has to be 0, because you dont need to guess\\n    #what if the interval is 2, impossible to have interval 1, interval is 2 the value should be the smaller number\\n    #lets look at this example: [1,2] [2,3] you definatly gonna pick the cheap one, because after you pick one the answer\\n    #will be the another. \\n    #because all the even interval will rely on the dp of interval 2, so once the dp[i][i + 1] is solved, the whole problem is solved !\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412008,
                "title": "simple-o-n-3-solution-bottom-up-approach",
                "content": "```\\nint getMoneyAmount(int n) {\\n        int dp[n+1][n+1];\\n        for(int i=0; i<=n; i++) for(int j=0; j<=n; j++) dp[i][j]=0;\\n        for(int i=1; i<n; i++) dp[i][i+1] = i;\\n        for(int i=2; i<n; i++){\\n            int x = 0;\\n            int y = i;\\n            while(y<=n){\\n                dp[x][y] = INT_MAX;\\n                for(int k=x+1; k<=y-1; k++) \\n                    dp[x][y] = min(dp[x][y], k+max(dp[x][k-1],dp[k+1][y]));\\n                dp[x][y] = min(dp[x][y], x+dp[x+1][y]);\\n                dp[x][y] = min(dp[x][y], y+dp[x][y-1]);\\n                x++, y++;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint getMoneyAmount(int n) {\\n        int dp[n+1][n+1];\\n        for(int i=0; i<=n; i++) for(int j=0; j<=n; j++) dp[i][j]=0;\\n        for(int i=1; i<n; i++) dp[i][i+1] = i;\\n        for(int i=2; i<n; i++){\\n            int x = 0;\\n            int y = i;\\n            while(y<=n){\\n                dp[x][y] = INT_MAX;\\n                for(int k=x+1; k<=y-1; k++) \\n                    dp[x][y] = min(dp[x][y], k+max(dp[x][k-1],dp[k+1][y]));\\n                dp[x][y] = min(dp[x][y], x+dp[x+1][y]);\\n                dp[x][y] = min(dp[x][y], y+dp[x][y-1]);\\n                x++, y++;\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1406933,
                "title": "c-solution-and-explanation-for-beginners",
                "content": "The examples actually gives a great hint for what we should use. Notice that we can break down every \"play\" as a binary tree of decisions. This implies that we can run recursion quite easily. \\n\\nSuppose that we have a magical method `T(i, j)` that gives us the minimum money needed that will guarantee us a win guessing a number from `i` to `j`. We can use this method to our advantage and evaluate the worst case for every decision and pick the minimum one out of it all. \\n\\nPut this into a recurrence relationship and we will get `T(i, j) = min_k(max(T(i, k - 1), T(k + 1, j)) + k)`. We also can note that `if i >= j then T(i, j) = 0`.  It\\'s not hard to see that we will have repetetive visits, therefore, we can memorize our search states. Here is the implementation.\\n```\\nclass Solution {\\n    vector<vector<int>> mem;\\n\\n    int helper(int left, int right) {\\n        if (left >= right) return 0;\\n        if (mem[left][right] == -1) {\\n            mem[left][right] = INT_MAX;\\n\\n            for (int i = right; i >= left; i--) {\\n                mem[left][right] = min(mem[left][right], max(helper(left, i - 1), helper(i + 1, right)) + i);\\n            }\\n        }\\n\\n        return mem[left][right];\\n    }\\n\\npublic:\\n    int getMoneyAmount(int n) {\\n        mem = vector<vector<int>>(n + 1, vector<int>(n + 1, -1));\\n        return helper(1, n);\\n    }\\n};\\n```\\nSpace complexity is `O(n^2)` time complexity is also `O(n^2)`.  Like most memorization, we can transform this into dp\\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        for (int right = 2; right <= n; right++) {\\n            for (int left = right - 1; left >= 1; left--) {\\n                dp[left][right] = INT_MAX;\\n                for (int k = right - 1; k > left; k--) {\\n                    dp[left][right] = min(dp[left][right], max(dp[left][k - 1], dp[k + 1][right]) + k);\\n                }\\n\\n                if (left + 1 == right) dp[left][right] = left;\\n            }\\n        }\\n\\n        return dp[1][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> mem;\\n\\n    int helper(int left, int right) {\\n        if (left >= right) return 0;\\n        if (mem[left][right] == -1) {\\n            mem[left][right] = INT_MAX;\\n\\n            for (int i = right; i >= left; i--) {\\n                mem[left][right] = min(mem[left][right], max(helper(left, i - 1), helper(i + 1, right)) + i);\\n            }\\n        }\\n\\n        return mem[left][right];\\n    }\\n\\npublic:\\n    int getMoneyAmount(int n) {\\n        mem = vector<vector<int>>(n + 1, vector<int>(n + 1, -1));\\n        return helper(1, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        for (int right = 2; right <= n; right++) {\\n            for (int left = right - 1; left >= 1; left--) {\\n                dp[left][right] = INT_MAX;\\n                for (int k = right - 1; k > left; k--) {\\n                    dp[left][right] = min(dp[left][right], max(dp[left][k - 1], dp[k + 1][right]) + k);\\n                }\\n\\n                if (left + 1 == right) dp[left][right] = left;\\n            }\\n        }\\n\\n        return dp[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406675,
                "title": "python-dp-ac-in-python-tle-in-c",
                "content": "Python (around 40% faster)\\n```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        ans=-sys.maxsize\\n        if n in (1,2):\\n            return n-1\\n        @lru_cache(None)\\n        def dp(l,h):\\n            if l>=h:\\n                return 0\\n            ans=sys.maxsize\\n            for k in range(l,h+1):\\n                a=dp(l,k-1)+k\\n                b=dp(k+1,h)+k\\n                ans=min(ans,max(a,b))\\n            return ans\\n        return dp(1,n)\\n```\\nTLE in C++,weird :(\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> memo;\\n    int dp(int l,int h){\\n        if (memo.find({l,h})!=memo.end()) return memo[{l,h}];\\n        if (l>=h) return 0;\\n        int ans=INT_MAX;\\n        for (int k=l;k<=h;k++){\\n            int a=dp(l,k-1)+k,b=dp(k+1,h)+k;\\n            ans=min(ans,max(a,b));\\n        }\\n        memo[{l,h}]=ans;\\n        return ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        return dp(1,n);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        ans=-sys.maxsize\\n        if n in (1,2):\\n            return n-1\\n        @lru_cache(None)\\n        def dp(l,h):\\n            if l>=h:\\n                return 0\\n            ans=sys.maxsize\\n            for k in range(l,h+1):\\n                a=dp(l,k-1)+k\\n                b=dp(k+1,h)+k\\n                ans=min(ans,max(a,b))\\n            return ans\\n        return dp(1,n)\\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> memo;\\n    int dp(int l,int h){\\n        if (memo.find({l,h})!=memo.end()) return memo[{l,h}];\\n        if (l>=h) return 0;\\n        int ans=INT_MAX;\\n        for (int k=l;k<=h;k++){\\n            int a=dp(l,k-1)+k,b=dp(k+1,h)+k;\\n            ans=min(ans,max(a,b));\\n        }\\n        memo[{l,h}]=ans;\\n        return ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        return dp(1,n);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400227,
                "title": "java-dp-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int dp[][]=new int[n+1][n+1];\\n        for(int i=n;i>=1;i--){\\n            for(int j=i;j<=n;j++){\\n                if(i==j)\\n                {\\n                    //In case Range is of form 1-1, 2-2, 3-3, 4-4\\n                    dp[i][j]=0;\\n                    continue;\\n                }else if(j==i+1){\\n                    //In case Range is of form 1-2,2-3,3-4. In this case we just choose the minimum of two numbers.\\n                    dp[i][j]=i;\\n                    continue;\\n                }\\n                /*\\n                In case range is of type i-j with more than 1 elements in between like 1-3 or 1-4 or 2-5\\n                Take an example of Range 1-5\\n                We take all k in between 1-5 i.e 2,3,5 and calculate \\n                dp[i][j]=Math.min(dp[i][j], k+Math.max(dp[i][k-1], dp[k+1][j]))\\n                \\n                a. Now why k+Math.max(dp[i][k-1], dp[k+1][j]) ? Because for every pivot or k we need to find the worst case.\\n                b. Now why Math.min(dp[i][j], k+Math.max(dp[i][k-1], dp[k+1][j])) ? Because that\\'s the point of the dp solution to find most optimal k such that even if we take the worst case as in step a, but overall it\\'s minimized.\\n                */\\n                dp[i][j]=Integer.MAX_VALUE;\\n                for(int k=i+1;k<j;k++)\\n                    dp[i][j]=Math.min(dp[i][j], k+Math.max(dp[i][k-1], dp[k+1][j]));\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```\\n\\nSimilar Question Solved in similar way : [877. Stone Game](https://leetcode.com/problems/stone-game/) : https://leetcode.com/submissions/detail/537568861/\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int dp[][]=new int[n+1][n+1];\\n        for(int i=n;i>=1;i--){\\n            for(int j=i;j<=n;j++){\\n                if(i==j)\\n                {\\n                    //In case Range is of form 1-1, 2-2, 3-3, 4-4\\n                    dp[i][j]=0;\\n                    continue;\\n                }else if(j==i+1){\\n                    //In case Range is of form 1-2,2-3,3-4. In this case we just choose the minimum of two numbers.\\n                    dp[i][j]=i;\\n                    continue;\\n                }\\n                /*\\n                In case range is of type i-j with more than 1 elements in between like 1-3 or 1-4 or 2-5\\n                Take an example of Range 1-5\\n                We take all k in between 1-5 i.e 2,3,5 and calculate \\n                dp[i][j]=Math.min(dp[i][j], k+Math.max(dp[i][k-1], dp[k+1][j]))\\n                \\n                a. Now why k+Math.max(dp[i][k-1], dp[k+1][j]) ? Because for every pivot or k we need to find the worst case.\\n                b. Now why Math.min(dp[i][j], k+Math.max(dp[i][k-1], dp[k+1][j])) ? Because that\\'s the point of the dp solution to find most optimal k such that even if we take the worst case as in step a, but overall it\\'s minimized.\\n                */\\n                dp[i][j]=Integer.MAX_VALUE;\\n                for(int k=i+1;k<j;k++)\\n                    dp[i][j]=Math.min(dp[i][j], k+Math.max(dp[i][k-1], dp[k+1][j]));\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338659,
                "title": "c-2-solutions-bottom-up-and-top-down-dp",
                "content": "\\nBottom-up DP:\\nRuntime: 156 ms, faster than 56.71% of C++ online submissions\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getMoneyAmount(int n) {\\n       \\n        vector<vector<int>>dp(n+2, vector<int>(n+2, 0));\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<n-i+1; j++){\\n                dp[j][j+i] = INT_MAX;\\n                for(int k=j; k<=j+i; k++)\\n                    dp[j][j+i] = min(dp[j][j+i], k + max(dp[j][k-1], dp[k+1][j+i]));\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n}\\n```\\n\\nTop Down DP:\\nRuntime: 192 ms, faster than 36.21% of C++ online submissions\\n\\n```\\nclass Solution {\\npublic:\\nint getMoneyAmountHelper(int i, int j, vector<vector<int>>& m){\\n        \\n        if(m[i][j] != INT_MAX)\\n            return m[i][j];\\n        \\n        if(i >=j){\\n            m[i][j] = 0;\\n            return 0;\\n        }\\n        \\n        int minMoney = INT_MAX;\\n        for(int k=i; k<=j; k++){\\n            minMoney = min(minMoney, k + max(getMoneyAmountHelper(i,k-1, m), getMoneyAmountHelper(k+1, j, m)));\\n        }\\n        \\n        m[i][j] = minMoney;\\n        return minMoney;\\n        \\n    }\\n    int getMoneyAmount(int n) {\\n        \\n        vector<vector<int>>m(n+2, vector<int>(n+2, INT_MAX));\\n        return getMoneyAmountHelper(1, n, m);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getMoneyAmount(int n) {\\n       \\n        vector<vector<int>>dp(n+2, vector<int>(n+2, 0));\\n        \\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<n-i+1; j++){\\n                dp[j][j+i] = INT_MAX;\\n                for(int k=j; k<=j+i; k++)\\n                    dp[j][j+i] = min(dp[j][j+i], k + max(dp[j][k-1], dp[k+1][j+i]));\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\nint getMoneyAmountHelper(int i, int j, vector<vector<int>>& m){\\n        \\n        if(m[i][j] != INT_MAX)\\n            return m[i][j];\\n        \\n        if(i >=j){\\n            m[i][j] = 0;\\n            return 0;\\n        }\\n        \\n        int minMoney = INT_MAX;\\n        for(int k=i; k<=j; k++){\\n            minMoney = min(minMoney, k + max(getMoneyAmountHelper(i,k-1, m), getMoneyAmountHelper(k+1, j, m)));\\n        }\\n        \\n        m[i][j] = minMoney;\\n        return minMoney;\\n        \\n    }\\n    int getMoneyAmount(int n) {\\n        \\n        vector<vector<int>>m(n+2, vector<int>(n+2, INT_MAX));\\n        return getMoneyAmountHelper(1, n, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319963,
                "title": "variation-of-matrix-chain-multiplication",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][201];\\n    \\n    int helper(int i,int j){\\n         \\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=INT_MAX;\\n        for (int p=i;p<=j;p++){\\n            int temp=p+max(helper(i,p-1),helper(p+1,j));\\n            ans=min(ans,temp);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        \\n     for(int i=0;i<201;i++)\\n            for(int j=0;j<201;j++) \\n                dp[i][j]=-1;\\n        \\n        return helper(1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][201];\\n    \\n    int helper(int i,int j){\\n         \\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=INT_MAX;\\n        for (int p=i;p<=j;p++){\\n            int temp=p+max(helper(i,p-1),helper(p+1,j));\\n            ans=min(ans,temp);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        \\n     for(int i=0;i<201;i++)\\n            for(int j=0;j<201;j++) \\n                dp[i][j]=-1;\\n        \\n        return helper(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302230,
                "title": "javascript-memo-search",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar getMoneyAmount = function(n) {\\n    function toKey(...args) {\\n        return args.join(\\'|\\')\\n    }\\n    \\n    // key => result of key\\n    const map = new Map()\\n    function solve(fromVal, toVal) {\\n        if (toVal <= fromVal)  return 0\\n        if (toVal === fromVal + 1)  return fromVal\\n        \\n        const key = toKey(fromVal, toVal)\\n        if (map.has(key))   return map.get(key)\\n        \\n        let result = Infinity\\n        for (let midVal = fromVal;\\n            midVal <= toVal; midVal++) {\\n            let leftResult = solve(fromVal, -1 + midVal)\\n            let rightResult = solve(1 + midVal, toVal)\\n            let outcome = midVal + Math.max(leftResult, rightResult)\\n            result = Math.min(result, outcome)\\n        }        \\n        \\n        map.set(key, result)\\n        return result\\n    }\\n    \\n    \\n    let result = solve(1, n)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar getMoneyAmount = function(n) {\\n    function toKey(...args) {\\n        return args.join(\\'|\\')\\n    }\\n    \\n    // key => result of key\\n    const map = new Map()\\n    function solve(fromVal, toVal) {\\n        if (toVal <= fromVal)  return 0\\n        if (toVal === fromVal + 1)  return fromVal\\n        \\n        const key = toKey(fromVal, toVal)\\n        if (map.has(key))   return map.get(key)\\n        \\n        let result = Infinity\\n        for (let midVal = fromVal;\\n            midVal <= toVal; midVal++) {\\n            let leftResult = solve(fromVal, -1 + midVal)\\n            let rightResult = solve(1 + midVal, toVal)\\n            let outcome = midVal + Math.max(leftResult, rightResult)\\n            result = Math.min(result, outcome)\\n        }        \\n        \\n        map.set(key, result)\\n        return result\\n    }\\n    \\n    \\n    let result = solve(1, n)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1271635,
                "title": "dp-based-sol",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    int dp[201][201];\\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(1,n);\\n    }\\n    int solve(int m,int n){\\n       int ans = INT_MAX;\\n       if(m == n)\\n       return 0;\\n       if(dp[m][n]!=-1)\\n       return dp[m][n];\\n       else\\n       {\\n          for(int k = m;k <= n;k++)\\n          {\\n              int a;\\n              if(k == m)\\n              a = k+solve(k+1,n);\\n              else if(k == n)\\n              a = k+solve(m,k-1);\\n              else\\n              {\\n                int b = solve(k+1,n);\\n                int c = solve(m,k-1);\\n                a = k+(max(b,c));\\n              }\\n              ans = min(ans,a);\\n         }\\n         return dp[m][n] = ans;\\n       }\\n    }\\n    \\n};\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[201][201];\\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(1,n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1264441,
                "title": "python-solution-dp-based",
                "content": "```\\nclass Solution(object):\\n    def getMoneyAmount(self, n):\\n        \\n#         memo = {}\\n#         def getMoneyRec(left, right):\\n            \\n#             if left >= right:\\n#                 return 0\\n            \\n#             if (left, right) in memo:\\n#                 return memo[(left, right)]\\n            \\n            \\n#             minima = float(\"inf\")\\n#             for k in range(left, right):\\n#                 minima = min(minima, max(getMoneyRec(left, k-1), getMoneyRec(k+1, right))+k)\\n            \\n#             memo[(left, right)] = minima\\n#             return minima\\n        \\n        \\n#         return getMoneyRec(1, n)\\n\\n        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\\n        \\n        for gap in range(1, n):\\n            for i in range(1, n-gap+1):\\n                j = i + gap\\n                dp[i][j] = float(\"inf\")\\n                for k in range(i, j):\\n                    dp[i][j] = min(dp[i][j], max(dp[i][k-1], dp[k+1][j])+k)\\n        \\n        return dp[1][n]\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def getMoneyAmount(self, n):\\n        \\n#         memo = {}",
                "codeTag": "Java"
            },
            {
                "id": 1227040,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int recur (int start, int end, vector < vector <int> >& dp) {\\n        if (start >= end) return 0;\\n        if (dp[start][end] != INT_MAX) return dp[start][end];\\n        for (int i = start; i <= end; i++) {\\n            dp[start][end] = min(dp[start][end] ,max(i + recur(start, i - 1, dp),i + recur(i + 1, end, dp)));\\n        }\\n        return dp[start][end];\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        vector < vector <int> > dp(n + 1, vector <int> (n + 1, INT_MAX));\\n        return recur(0, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int recur (int start, int end, vector < vector <int> >& dp) {\\n        if (start >= end) return 0;\\n        if (dp[start][end] != INT_MAX) return dp[start][end];\\n        for (int i = start; i <= end; i++) {\\n            dp[start][end] = min(dp[start][end] ,max(i + recur(start, i - 1, dp),i + recur(i + 1, end, dp)));\\n        }\\n        return dp[start][end];\\n    }\\n    \\n    int getMoneyAmount(int n) {\\n        vector < vector <int> > dp(n + 1, vector <int> (n + 1, INT_MAX));\\n        return recur(0, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210669,
                "title": "code-with-explanation",
                "content": "* This question can be solved using dynamic programming.\\n* The states of dp will be left and right boundary in which n lies.\\n* We have to find the answer in the range [1,n], by using the concept of dynamic programming we will break it into smaller subproblems.\\n\\n*Example*\\nSay n=10 and we choose 5 as the first number, Now three cases arises\\nIst case: Target number is 5, then 5 is the answer.\\n2nd case: Target number is less than 5, then answer will be 5+answer for range [1,4]\\n3rd case: Target number is greater than 5, then answer will be 5+answer for range [6,10]\\n\\nSince we have to guarantee the \\'win\\' so we have to take minimum money which will satisfy all three cases, So we will take the maximum of all three cases.\\n```\\npublic class Solution {\\n    public int getMoneyAmount(int n) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int jminusi = 1; jminusi < n; jminusi++) {\\n            for (int i = 0; i + jminusi <= n; i++) {\\n                int j = i + jminusi;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = i; k <= j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j],\\n                                        k + Math.max(k - 1 >= i ? dp[i][k - 1] : 0,\\n                                                     j >= k + 1 ? dp[k + 1][j] : 0));\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int getMoneyAmount(int n) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int jminusi = 1; jminusi < n; jminusi++) {\\n            for (int i = 0; i + jminusi <= n; i++) {\\n                int j = i + jminusi;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = i; k <= j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j],\\n                                        k + Math.max(k - 1 >= i ? dp[i][k - 1] : 0,\\n                                                     j >= k + 1 ? dp[k + 1][j] : 0));\\n                }\\n            }\\n        }\\n        return dp[1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193097,
                "title": "c-dp-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int f(int i,int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int it=i;it<=j;it++)\\n        {\\n            ans=min(ans,it+max(f(i,it-1),f(it+1,j)));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int f(int i,int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int it=i;it<=j;it++)\\n        {\\n            ans=min(ans,it+max(f(i,it-1),f(it+1,j)));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030517,
                "title": "easy-to-understand-recursion-memoization-tabulation-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int recursion(int st, int end)\\n    {\\n        if(st>end || st==end)\\n        {\\n            return 0 ;\\n        }\\n        \\n        int current_state_ans=1e8;\\n        \\n        for(int it=st;it<=end;it++)\\n        {\\n            int left= recursion(st,it-1);\\n            int right= recursion(it+1,end);\\n            \\n            int temp_ans= max(left,right)+ it;\\n            current_state_ans= min(current_state_ans, temp_ans);\\n            \\n        }\\n        \\n        return current_state_ans;\\n    }\\n    \\n    int memoization(int st, int end, vector<vector<int>>&dp) //bottom up, TLE for n=25\\n    {\\n        if(st>end || st==end)\\n        {\\n            return dp[st][end] =0 ;\\n        }\\n        \\n        if(dp[st][end]!=-1) return dp[st][end];\\n        \\n        int current_state_ans=1e8;\\n        \\n        for(int it=st;it<=end;it++)\\n        {\\n            int left, right;\\n            \\n            if(dp[st][it-1]!=-1) left= dp[st][it-1]; //further optimization- no use as still TLE\\n            else left= recursion(st,it-1);\\n            \\n            if(dp[it+1][end]!=-1) right= dp[it+1][end]; //further optimization- no use as still TLE\\n            else right= recursion(it+1,end);\\n            \\n            int temp_ans= max(left,right)+ it;\\n            current_state_ans= min(current_state_ans, temp_ans);\\n            \\n        }\\n        \\n        return dp[st][end]= current_state_ans;\\n    }\\n    \\n    \\n    int tabulation(int n, vector<vector<int>>&dp) // to resolve tle at n=25 ( works)\\n    {\\n        for(int gap=0;gap<=n;gap++)\\n        {\\n            for(int i=0,j=gap;j<=n;i++,j++)\\n            {\\n                if(gap==0) {dp[i][j]=0; continue;}\\n                if(gap==1 && i!=0) { dp[i][j]=i ;continue;}\\n                \\n                int curr_state=1e8;\\n                \\n                for(int k=i;k<=j;k++)\\n                {\\n                    int l=0,r=0;\\n                    \\n                    if(k-1>0)\\n                        l= dp[i][k-1];\\n                    \\n                    if(k+1<=n)\\n                        r= dp[k+1][j];\\n                    \\n                    int temp_ans = max(l,r)+k;\\n                    \\n                    curr_state= min( curr_state, temp_ans);\\n                    \\n                }\\n                \\n                dp[i][j]=curr_state;\\n            }\\n        }\\n        return dp[1][n];\\n        \\n    }\\n        \\n    \\n    int getMoneyAmount(int n) {\\n        //return recursion(1,n);\\n        \\n        vector<vector<int>>dp(n+1, vector<int>(n+1,0));\\n        \\n        //return memoization(1,n,dp);\\n        \\n        return tabulation(n,dp);\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int recursion(int st, int end)\\n    {\\n        if(st>end || st==end)\\n        {\\n            return 0 ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1005262,
                "title": "python-dp-tabulation-o-n-2",
                "content": "Build larger solutions after solving smaller ones. Use dp\\\\[l][r], which represents minimum cost to solve problem \\\\[l, r]\\n\\n1. scan all sizes\\n2. slide problem window from left to right\\n3. apply all possible split value. cost at split value is: split_value + max(dp\\\\[l][split-1], dp\\\\[split+1][r]) (use bound checks on window edges)\\n4. dp\\\\[l,r] = minimum result for all split values on given inteval \\\\[l,r]. \\n\\nHardest part of implementation is configuring the indexing correctly xD (beware of off-by-ones). Use simple cases to guide you.\\n\\n```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        \\n        # only using n+1 to reflect 1-based indexing of nodes\\n        dp = [[float(\"inf\")] * (n+1) for row in range(n+1)]\\n        \\n        # single node solutions - no cost\\n        for i in range(1, n+1):\\n            dp[i][i] = 0\\n            \\n        # n-node solutions... min for all(split value + max(left, right))\\n        for size in range(2, n+1):\\n            for left in range(1, n+1-size+1):\\n                # dp[l][r] = min(split value + max(left, right))\\n                best = float(\"inf\")\\n                for split in range(left, left + size):\\n                    if split == left: # can\\'t access anything to the left\\n                        res = split + dp[split+1][left+size-1]\\n                    elif split == n: # can\\'t access anything to the right\\n                        res = split + dp[left][split-1]\\n                    else: \\n                        res = split + max(dp[left][split-1], dp[split+1][left+size-1])\\n                        \\n                    best = min(res, best)\\n                    \\n                dp[left][left+size-1] = best\\n            \\n        # dp[1][n] yields minimum for global problem\\n        return dp[1][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        \\n        # only using n+1 to reflect 1-based indexing of nodes\\n        dp = [[float(\"inf\")] * (n+1) for row in range(n+1)]\\n        \\n        # single node solutions - no cost\\n        for i in range(1, n+1):\\n            dp[i][i] = 0\\n            \\n        # n-node solutions... min for all(split value + max(left, right))\\n        for size in range(2, n+1):\\n            for left in range(1, n+1-size+1):\\n                # dp[l][r] = min(split value + max(left, right))\\n                best = float(\"inf\")\\n                for split in range(left, left + size):\\n                    if split == left: # can\\'t access anything to the left\\n                        res = split + dp[split+1][left+size-1]\\n                    elif split == n: # can\\'t access anything to the right\\n                        res = split + dp[left][split-1]\\n                    else: \\n                        res = split + max(dp[left][split-1], dp[split+1][left+size-1])\\n                        \\n                    best = min(res, best)\\n                    \\n                dp[left][left+size-1] = best\\n            \\n        # dp[1][n] yields minimum for global problem\\n        return dp[1][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983945,
                "title": "dp-in-c-cool-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n   int ans(vector<vector<int>>&dp, int s, int e){\\n       \\n       if(s>=e){\\n           return 0;\\n       }\\n       \\n       if(dp[s][e]!=0){\\n           return dp[s][e];\\n       }\\n       \\n       int mn = INT_MAX;\\n       for(int i = s; i<=e; i++){\\n           int res = i + max(ans(dp,i+1,e), ans(dp,s,i-1));\\n           mn = min(mn,res);\\n       }\\n       dp[s][e] = mn;\\n       return mn;\\n       \\n   } \\n    \\n    \\n    \\n    \\n    \\n    int getMoneyAmount(int n) {\\n        //t dp[201][201];\\n        int m = 201;\\n        vector<vector<int>> dp(m,vector<int>(m,0));\\n       /*or(int i =0; i<=200; i++){\\n            for(int j =0; j<=200; j++){\\n                dp[i][j] =0;\\n            }\\n        }\\n        */\\n        return ans(dp,1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   int ans(vector<vector<int>>&dp, int s, int e){\\n       \\n       if(s>=e){\\n           return 0;\\n       }\\n       \\n       if(dp[s][e]!=0){\\n           return dp[s][e];\\n       }\\n       \\n       int mn = INT_MAX;\\n       for(int i = s; i<=e; i++){\\n           int res = i + max(ans(dp,i+1,e), ans(dp,s,i-1));\\n           mn = min(mn,res);\\n       }\\n       dp[s][e] = mn;\\n       return mn;\\n       \\n   } \\n    \\n    \\n    \\n    \\n    \\n    int getMoneyAmount(int n) {\\n        //t dp[201][201];\\n        int m = 201;\\n        vector<vector<int>> dp(m,vector<int>(m,0));\\n       /*or(int i =0; i<=200; i++){\\n            for(int j =0; j<=200; j++){\\n                dp[i][j] =0;\\n            }\\n        }\\n        */\\n        return ans(dp,1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951875,
                "title": "i-find-this-problem-similar-to-egg-dropping-problem",
                "content": "**Here is my memoized code**\\n```\\nclass Solution\\n{\\n    public int getMoneyAmount(int n)\\n    {\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i = 0; i <= n; i++)\\n        {\\n            for(int j = 0; j <= n; j++)\\n            {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return getMoney(1, n, dp);\\n    }\\n    int getMoney(int start, int end, int[][] dp)\\n    {\\n        if(start >= end)\\n        {\\n            return 0;\\n        }\\n        if(dp[start][ end] != -1)\\n        {\\n            return dp[start][end];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i = start; i <= end; i++)\\n        {\\n            int low = i + getMoney(start, i-1, dp);\\n            int high = i + getMoney(i+1, end, dp);\\n            int temp = Math.max(low, high);\\n            min = Math.min(temp, min);\\n        }\\n        return dp[start][end] = min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int getMoneyAmount(int n)\\n    {\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i = 0; i <= n; i++)\\n        {\\n            for(int j = 0; j <= n; j++)\\n            {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return getMoney(1, n, dp);\\n    }\\n    int getMoney(int start, int end, int[][] dp)\\n    {\\n        if(start >= end)\\n        {\\n            return 0;\\n        }\\n        if(dp[start][ end] != -1)\\n        {\\n            return dp[start][end];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i = start; i <= end; i++)\\n        {\\n            int low = i + getMoney(start, i-1, dp);\\n            int high = i + getMoney(i+1, end, dp);\\n            int temp = Math.max(low, high);\\n            min = Math.min(temp, min);\\n        }\\n        return dp[start][end] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938661,
                "title": "python-top-down-and-bottom-up-dp-solutions",
                "content": "<details>\\n\\n<summary><b>Approach: (click to show)</b></summary>\\n\\nStart with a range of (low, high) = (1, n) because these are the bounds given by the problem.\\nThen try guessing all of the numbers between low and high (inclusive).\\n\\nWhen you guess num, it costs you num points and your friend will tell you if you were too low or too high.  \\nDepending on what your friend says, this reduces the range of numbers you need to consider into:\\n1. numbers between low and num - 1\\n2. or numbers between num + 1 and high\\n\\nThe total cost is then num plus the maximum of cost of the two remaining ranges.  \\nWe choose the maximum because we want to **\"guarantee\"** a win so we assume a worst case \\nscenario that n is always in the more expensive of the two remaining ranges.  \\nThen we take the minimum cost guess for all the guesses between low and high, which assumes that we guess optimally.\\n\\n</details>\\n\\n<details>\\n\\n<summary><b>Additional Insights: (click to show)</b></summary>\\n\\nCheck out the <a href=\"https://oeis.org/A276128\" target=\"_blank\"><b>online encyclopedia of integer sequences</b></a> for this sequence.  \\n\\n</details>\\n\\n<br>\\n\\n**Top Down DP:**\\n```python\\n# Top Down DP: 3228ms 52%\\ndef getMoneyAmount(self, n: int) -> int:\\n\\t@functools.lru_cache(None)\\n\\tdef helper(low, high):\\n\\t\\tif low >= high:\\n\\t\\t\\treturn 0\\n\\t\\treturn min(num + max(helper(low, num - 1), helper(num + 1, high)) for num in range(low, high + 1))\\n\\treturn helper(1, n)\\n```\\n\\n<br>\\n\\n<details>\\n\\n<summary><b>Transformation from Top Down to Bottom Up: (click to show)</b></summary>\\n\\nThis approach is not perfect, but these steps usually work to convert Top Down DP to Bottom Up DP:\\n\\n1. Replace @functools.lru_cache memoization with a dp array.\\n    * The dp array is 2D because we have 2 arguments in helper.\\n    * The two dimensions of dp are the ranges of the 2 arguments, low is 1 to n and high is 1 to n.\\n2. Iterate over the ranges for low and high.\\n    * Generally the ranges need to be reversed ```range(n, 0, -1) = reversed(range(1, n+1))```\\n    * Notice that high is never less than low.\\n3. Copy and paste the top-down helper function into the for-loop.\\n    * replace helper(x, y) with dp[x][y]\\n    * replace return(...) with dp[low][high] = ...\\n\\n</details>\\n\\n<br>\\n\\n**Bottom Up DP:**\\n```python\\n# Bottom Up DP: 2212 ms 71%\\ndef getMoneyAmount(self, n: int) -> int:\\n\\tdp = [[0 for _ in range(n+2)] for _ in range(n+2)]\\n\\tfor low in range(n, 0, -1):\\n\\t\\tfor high in range(low+1, n+1):\\n\\t\\t\\tdp[low][high] = min(num + max(dp[low][num-1], dp[num+1][high]) for num in range(low, high + 1))\\n\\treturn dp[1][n]\\n```",
                "solutionTags": [],
                "code": "```python\\n# Top Down DP: 3228ms 52%\\ndef getMoneyAmount(self, n: int) -> int:\\n\\t@functools.lru_cache(None)\\n\\tdef helper(low, high):\\n\\t\\tif low >= high:\\n\\t\\t\\treturn 0\\n\\t\\treturn min(num + max(helper(low, num - 1), helper(num + 1, high)) for num in range(low, high + 1))\\n\\treturn helper(1, n)\\n```\n```range(n, 0, -1) = reversed(range(1, n+1))```\n```python\\n# Bottom Up DP: 2212 ms 71%\\ndef getMoneyAmount(self, n: int) -> int:\\n\\tdp = [[0 for _ in range(n+2)] for _ in range(n+2)]\\n\\tfor low in range(n, 0, -1):\\n\\t\\tfor high in range(low+1, n+1):\\n\\t\\t\\tdp[low][high] = min(num + max(dp[low][num-1], dp[num+1][high]) for num in range(low, high + 1))\\n\\treturn dp[1][n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 937323,
                "title": "javascript-dfs-dp",
                "content": "reference: https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/84764/Simple-DP-solution-with-explanation~~\\n```\\n////////////////////////// DFS 188ms  71.74% fast /////////////////////////////\\nlet memo;\\nconst getMoneyAmount = (n) => {\\n    memo = initialize2DArrayNew(n + 1, n + 1);\\n    return dfs(1, n);\\n};\\n\\nconst dfs = (start, end) => {\\n    if (start >= end) return 0;\\n    if (memo[start][end] > 0) return memo[start][end];\\n    let res = Number.MAX_VALUE;\\n    for (let i = start; i <= end; i++) {\\n        let tmp = i + Math.max(dfs(start, i - 1), dfs(i + 1, end));\\n        res = Math.min(res, tmp);\\n    }\\n    memo[start][end] = res;\\n    return res;\\n};\\n\\nconst initialize2DArrayNew = (m, n) => {\\n    let data = [];\\n    for (let i = 0; i < m; i++) {\\n        let tmp = new Array(n).fill(0);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n\\n///////////////////////// DP 116ms 100% fast /////////////////////////////////\\nconst getMoneyAmount = (n) => {\\n    let dp = initialize2DArrayNew(n + 1, n + 1);\\n    for (let i = 2; i <= n; i++) {\\n        for (let j = i - 1; j > 0; j--) {\\n            let min = Number.MAX_VALUE;\\n            for (let k = j + 1; k < i; k++) {\\n                let tmp = k + Math.max(dp[j][k - 1], dp[k + 1][i]);\\n                min = Math.min(min, tmp);\\n            }\\n            dp[j][i] = j + 1 == i ? j : min;\\n        }\\n    }\\n    return dp[1][n];\\n};\\n\\nconst initialize2DArrayNew = (m, n) => {\\n    let data = [];\\n    for (let i = 0; i < m; i++) {\\n        let tmp = new Array(n).fill(0);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n////////////////////////// DFS 188ms  71.74% fast /////////////////////////////\\nlet memo;\\nconst getMoneyAmount = (n) => {\\n    memo = initialize2DArrayNew(n + 1, n + 1);\\n    return dfs(1, n);\\n};\\n\\nconst dfs = (start, end) => {\\n    if (start >= end) return 0;\\n    if (memo[start][end] > 0) return memo[start][end];\\n    let res = Number.MAX_VALUE;\\n    for (let i = start; i <= end; i++) {\\n        let tmp = i + Math.max(dfs(start, i - 1), dfs(i + 1, end));\\n        res = Math.min(res, tmp);\\n    }\\n    memo[start][end] = res;\\n    return res;\\n};\\n\\nconst initialize2DArrayNew = (m, n) => {\\n    let data = [];\\n    for (let i = 0; i < m; i++) {\\n        let tmp = new Array(n).fill(0);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n\\n///////////////////////// DP 116ms 100% fast /////////////////////////////////\\nconst getMoneyAmount = (n) => {\\n    let dp = initialize2DArrayNew(n + 1, n + 1);\\n    for (let i = 2; i <= n; i++) {\\n        for (let j = i - 1; j > 0; j--) {\\n            let min = Number.MAX_VALUE;\\n            for (let k = j + 1; k < i; k++) {\\n                let tmp = k + Math.max(dp[j][k - 1], dp[k + 1][i]);\\n                min = Math.min(min, tmp);\\n            }\\n            dp[j][i] = j + 1 == i ? j : min;\\n        }\\n    }\\n    return dp[1][n];\\n};\\n\\nconst initialize2DArrayNew = (m, n) => {\\n    let data = [];\\n    for (let i = 0; i < m; i++) {\\n        let tmp = new Array(n).fill(0);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937096,
                "title": "c-dfs-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(1,n);\\n    }\\n    \\n    int dfs(int l,int r){\\n        if(l>r)return 0;\\n        if(l==r){\\n            return 0;\\n        }\\n        if(dp[l][r]!=-1)return dp[l][r];\\n        int res=INT_MAX;\\n        \\n        for(int i=l;i<=r;i++){\\n            res=min(res,i+max(dfs(l,i-1),dfs(i+1,r)));\\n        }\\n        dp[l][r]=res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int getMoneyAmount(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(1,n);\\n    }\\n    \\n    int dfs(int l,int r){\\n        if(l>r)return 0;\\n        if(l==r){\\n            return 0;\\n        }\\n        if(dp[l][r]!=-1)return dp[l][r];\\n        int res=INT_MAX;\\n        \\n        for(int i=l;i<=r;i++){\\n            res=min(res,i+max(dfs(l,i-1),dfs(i+1,r)));\\n        }\\n        dp[l][r]=res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889239,
                "title": "java-with-memoization",
                "content": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n+1][n+1];\\n        return find(1, n, dp);\\n    }\\n    \\n    int find(int low, int high, int[][] dp) {\\n        if(low>=high) return 0;\\n        if(dp[low][high]!=0) return dp[low][high];\\n        int min =Integer.MAX_VALUE;\\n        \\n        for(int i=low+(high-low)/2;i<=high;i++) {\\n            int res = i+ Math.max(find(low, i-1, dp), find(i+1, high, dp));\\n            min = Math.min(res, min);\\n        }\\n        dp[low][high]=min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n+1][n+1];\\n        return find(1, n, dp);\\n    }\\n    \\n    int find(int low, int high, int[][] dp) {\\n        if(low>=high) return 0;\\n        if(dp[low][high]!=0) return dp[low][high];\\n        int min =Integer.MAX_VALUE;\\n        \\n        for(int i=low+(high-low)/2;i<=high;i++) {\\n            int res = i+ Math.max(find(low, i-1, dp), find(i+1, high, dp));\\n            min = Math.min(res, min);\\n        }\\n        dp[low][high]=min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863725,
                "title": "cpp14-dp-with-memoization-solution",
                "content": "```\\n/// ashish gupta fan club \\n/// @fan of ashish gupta, lord of dp\\nclass Solution {\\npublic:\\n    int dp[205][205]; \\n    int solve(int a , int b)\\n    {\\n        if(a > b ) return 0;\\n        if(a == b) return 0;\\n        /// a .. b\\n        if(dp[a][b] != -1) return dp[a][b];  \\n        int maxx = 1e9;\\n        for(int i = a ; i <= b ; ++i){\\n            /// if my guessed number is i\\n            maxx = min(maxx , max({0 , i + solve(a , i-1) , i + solve(i + 1 , b)}));\\n        }\\n        dp[a][b] = maxx; \\n        return maxx ;\\n    }\\n\\n    int getMoneyAmount(int n) {\\n        for(int i = 0 ; i < 205 ; ++i){\\n            for(int j = 0 ; j < 205 ; ++j){\\n                dp[i][j] = -1; \\n            }\\n        }\\n        return solve(1 , n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/// ashish gupta fan club \\n/// @fan of ashish gupta, lord of dp\\nclass Solution {\\npublic:\\n    int dp[205][205]; \\n    int solve(int a , int b)\\n    {\\n        if(a > b ) return 0;\\n        if(a == b) return 0;\\n        /// a .. b\\n        if(dp[a][b] != -1) return dp[a][b];  \\n        int maxx = 1e9;\\n        for(int i = a ; i <= b ; ++i){\\n            /// if my guessed number is i\\n            maxx = min(maxx , max({0 , i + solve(a , i-1) , i + solve(i + 1 , b)}));\\n        }\\n        dp[a][b] = maxx; \\n        return maxx ;\\n    }\\n\\n    int getMoneyAmount(int n) {\\n        for(int i = 0 ; i < 205 ; ++i){\\n            for(int j = 0 ; j < 205 ; ++j){\\n                dp[i][j] = -1; \\n            }\\n        }\\n        return solve(1 , n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813676,
                "title": "python3-top-down-dp",
                "content": "It should be decently clear that this is a dp problem. Here, a top-down version is implemented here. Define `fn(lo, hi)` as the cost of guessing a number `x` where `lo <= x <= hi`. Then, \\n\\n1) `fn(lo, hi) = 0` if `lo >= hi` (i.e. no need to guess);\\n2) `fn(lo, hi) = min(mid + max(fn(lo, mid-1), fn(mid+1, hi)) for mid in range(lo, hi+1)`; \\n\\n```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(lo, hi): \\n            \"\"\"The cost of guessing a number where lo <= x <= hi.\"\"\"\\n            if lo >= hi: return 0 # no need to guess \\n            ans = inf\\n            for mid in range(lo, hi+1): \\n                ans = min(ans, mid + max(fn(lo, mid-1), fn(mid+1, hi)))\\n            return ans \\n        \\n        return fn(1, n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMoneyAmount(self, n: int) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(lo, hi): \\n            \"\"\"The cost of guessing a number where lo <= x <= hi.\"\"\"\\n            if lo >= hi: return 0 # no need to guess \\n            ans = inf\\n            for mid in range(lo, hi+1): \\n                ans = min(ans, mid + max(fn(lo, mid-1), fn(mid+1, hi)))\\n            return ans \\n        \\n        return fn(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795052,
                "title": "c-easy-recursive-dp",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int recur(int l,int r,vector<vector<int>>&dp)\\n    {\\n        if(l>=r)  //If n=1 ans=0 as I know he would have guesses that number only\\n            return 0;\\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        int ans=10000;\\n        for(int i=l;i<=r;i++)\\n        {\\n            int k=max(i+recur(i+1,r,dp),i+recur(l,i-1,dp));\\n            ans=min(ans,k);\\n        }\\n        return dp[l][r]=ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return recur(1,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int recur(int l,int r,vector<vector<int>>&dp)\\n    {\\n        if(l>=r)  //If n=1 ans=0 as I know he would have guesses that number only\\n            return 0;\\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        int ans=10000;\\n        for(int i=l;i<=r;i++)\\n        {\\n            int k=max(i+recur(i+1,r,dp),i+recur(l,i-1,dp));\\n            ans=min(ans,k);\\n        }\\n        return dp[l][r]=ans;\\n    }\\n    int getMoneyAmount(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        return recur(1,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772099,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        // dp[i][j] = dp[i][k-1] + (k) + dp[k+1][j] for k in range(i+1, j)\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i=1; i<n; i++) dp[i][i+1] = i;\\n        \\n        for(int i=n-2; i>0; i--){\\n            for(int j=i+2; j<n+1; j++){\\n                for(int k=i+1; k<j; k++){\\n                    if(dp[i][j] == 0) dp[i][j] = Math.max(dp[i][k-1], dp[k+1][j]) + k;\\n                    else dp[i][j] = Math.min(dp[i][j], Math.max(dp[i][k-1], dp[k+1][j]) + k);\\n                }\\n            }\\n        }\\n    \\n        return dp[1][n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        // dp[i][j] = dp[i][k-1] + (k) + dp[k+1][j] for k in range(i+1, j)\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i=1; i<n; i++) dp[i][i+1] = i;\\n        \\n        for(int i=n-2; i>0; i--){\\n            for(int j=i+2; j<n+1; j++){\\n                for(int k=i+1; k<j; k++){\\n                    if(dp[i][j] == 0) dp[i][j] = Math.max(dp[i][k-1], dp[k+1][j]) + k;\\n                    else dp[i][j] = Math.min(dp[i][j], Math.max(dp[i][k-1], dp[k+1][j]) + k);\\n                }\\n            }\\n        }\\n    \\n        return dp[1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631835,
                "title": "python3-simply-minmax-search-with-lru-cache-memoization-faster-than-40",
                "content": "\\tclass Solution:\\n\\t\\tdef getMoneyAmount(self, n: int) -> int:\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t- starting from [lo, hi]\\n\\t\\t\\t- at each step, choose a number n in [lo, hi], the range is partitioned into two parts \\n\\t\\t\\t- [lo, n-1], [n+1, hi], with cost n\\n\\t\\t\\t- calculate the max risk/pay of this choice between left and right\\n\\t\\t\\t- find the min of the max risks with different choice of n\\n\\t\\t\\t- return this min\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef minCost(lo, hi):\\n\\t\\t\\t\\tif lo >= hi: return 0 # known\\n\\t\\t\\t\\tmin_cost = float(\\'inf\\')\\n\\t\\t\\t\\tfor n in range(lo, hi+1):\\n\\t\\t\\t\\t\\tcost_n = n + max(minCost(lo, n-1), minCost(n + 1, hi))\\n\\t\\t\\t\\t\\tmin_cost = min(min_cost, cost_n)\\n\\t\\t\\t\\treturn min_cost\\n\\n\\t\\t\\treturn minCost(1, n)\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef getMoneyAmount(self, n: int) -> int:\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t- starting from [lo, hi]\\n\\t\\t\\t- at each step, choose a number n in [lo, hi], the range is partitioned into two parts \\n\\t\\t\\t- [lo, n-1], [n+1, hi], with cost n\\n\\t\\t\\t- calculate the max risk/pay of this choice between left and right\\n\\t\\t\\t- find the min of the max risks with different choice of n\\n\\t\\t\\t- return this min\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t@functools.lru_cache(None)\\n\\t\\t\\tdef minCost(lo, hi):\\n\\t\\t\\t\\tif lo >= hi: return 0 # known\\n\\t\\t\\t\\tmin_cost = float(\\'inf\\')\\n\\t\\t\\t\\tfor n in range(lo, hi+1):\\n\\t\\t\\t\\t\\tcost_n = n + max(minCost(lo, n-1), minCost(n + 1, hi))\\n\\t\\t\\t\\t\\tmin_cost = min(min_cost, cost_n)\\n\\t\\t\\t\\treturn min_cost\\n\\n\\t\\t\\treturn minCost(1, n)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 626943,
                "title": "clean-java-version",
                "content": "```\\npublic int getMoneyAmount(int n) {\\n   int[][] dp = new int[n+1][n+1];\\n    for(int r=2; r<=n; r++){\\n      dp[r-1][r] = r-1;\\n      \\n      for(int l=r-2; l>0; l--){\\n        int min = Integer.MAX_VALUE;\\n        for(int k=l+1; k<r; k++){\\n          int max = k + Math.max(dp[l][k-1], dp[k+1][r]);\\n          min = Math.min(min, max);\\n        }\\n        dp[l][r] = globalMin;\\n      }\\n    }\\n    return dp[1][n];\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMoneyAmount(int n) {\\n   int[][] dp = new int[n+1][n+1];\\n    for(int r=2; r<=n; r++){\\n      dp[r-1][r] = r-1;\\n      \\n      for(int l=r-2; l>0; l--){\\n        int min = Integer.MAX_VALUE;\\n        for(int k=l+1; k<r; k++){\\n          int max = k + Math.max(dp[l][k-1], dp[k+1][r]);\\n          min = Math.min(min, max);\\n        }\\n        dp[l][r] = globalMin;\\n      }\\n    }\\n    return dp[1][n];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 603450,
                "title": "c-tow-down-dp-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tvector<vector<int>> dp;\\n\\t\\tint dfs(int left, int right)\\n\\t\\t{\\n\\t\\t\\tif(left==right) return 0;\\n\\t\\t\\tif(dp[left][right]) return dp[left][right];\\n\\t\\t\\tdp[left][right]=INT_MAX/2;\\n\\t\\t\\tfor(int i=left;i<=right;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i==left)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdp[left][right]=min(dp[left][right],i+dfs(i+1,right));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(i==right)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdp[left][right]=min(dp[left][right],i+dfs(left,i-1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdp[left][right]=min(dp[left][right],i+max(dfs(left,i-1),dfs(i+1,right)));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[left][right];\\n\\t\\t}\\n\\t\\tint getMoneyAmount(int n) {\\n\\t\\t\\tdp.assign(n+1,vector<int>(n+1));\\n\\t\\t\\tdfs(1,n);\\n\\t\\t\\treturn dp[1][n];  \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tvector<vector<int>> dp;\\n\\t\\tint dfs(int left, int right)\\n\\t\\t{\\n\\t\\t\\tif(left==right) return 0;\\n\\t\\t\\tif(dp[left][right]) return dp[left][right];\\n\\t\\t\\tdp[left][right]=INT_MAX/2;\\n\\t\\t\\tfor(int i=left;i<=right;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i==left)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdp[left][right]=min(dp[left][right],i+dfs(i+1,right));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 600744,
                "title": "simple-top-down-java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n + 1][n + 1];\\n        return get(dp, 1, n);\\n    }\\n    \\n    private int get(int[][] dp, int start, int end) {\\n        if (start >= end) return 0;\\n        if (dp[start][end] != 0) return dp[start][end];\\n        dp[start][end] = Integer.MAX_VALUE;\\n        for (int i = start; i <= end; i++) {\\n            int cost = i + Math.max(get(dp, start, i - 1), get(dp, i + 1, end));\\n            dp[start][end] = Math.min(dp[start][end], cost);\\n        }\\n        return dp[start][end];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n + 1][n + 1];\\n        return get(dp, 1, n);\\n    }\\n    \\n    private int get(int[][] dp, int start, int end) {\\n        if (start >= end) return 0;\\n        if (dp[start][end] != 0) return dp[start][end];\\n        dp[start][end] = Integer.MAX_VALUE;\\n        for (int i = start; i <= end; i++) {\\n            int cost = i + Math.max(get(dp, start, i - 1), get(dp, i + 1, end));\\n            dp[start][end] = Math.min(dp[start][end], cost);\\n        }\\n        return dp[start][end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561927,
                "title": "go-golang-dp-0ms-solution",
                "content": "DP evolves on the length of the interval (variable k). Check every point that divides the interval [i, ..., i + k] into two, i.e., [i,...,j - 1] and [j + 1, ..., i + k]. Pick the one with the lowest cost.\\n```\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc getMoneyAmount(n int) int {\\n    dp := make([][]int, n + 1)\\n    for i := 1; i <= n; i ++{\\n        dp[i] = make([]int, n + 1)\\n    }\\n    for i := 1; i < n; i ++{\\n        dp[i][i + 1] = i\\n    }\\n    for k := 2; k < n; k ++{ //length of the interval\\n        for i := 1; i + k <= n; i ++{ //head of the interval\\n            min := math.MaxInt32\\n            for j := i + 1; j <= i + k - 1; j ++ { //a point that divides the interval into two, i.e., [i,...,j - 1] and [j + 1, ..., i + k]\\n                if tmp := max(dp[i][j - 1], dp[j + 1][i + k]) + j; tmp < min {\\n                    min = tmp\\n                }        \\n            }\\n            dp[i][i + k] = min\\n        }\\n    }\\n    return dp[1][n]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc getMoneyAmount(n int) int {\\n    dp := make([][]int, n + 1)\\n    for i := 1; i <= n; i ++{\\n        dp[i] = make([]int, n + 1)\\n    }\\n    for i := 1; i < n; i ++{\\n        dp[i][i + 1] = i\\n    }\\n    for k := 2; k < n; k ++{ //length of the interval\\n        for i := 1; i + k <= n; i ++{ //head of the interval\\n            min := math.MaxInt32\\n            for j := i + 1; j <= i + k - 1; j ++ { //a point that divides the interval into two, i.e., [i,...,j - 1] and [j + 1, ..., i + k]\\n                if tmp := max(dp[i][j - 1], dp[j + 1][i + k]) + j; tmp < min {\\n                    min = tmp\\n                }        \\n            }\\n            dp[i][i + k] = min\\n        }\\n    }\\n    return dp[1][n]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 555755,
                "title": "java-dp-solution",
                "content": "```java\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n+1][n+1];\\n        // If there are two numbers to select from,\\n        // we have to pay the cost of the lowest one.\\n        for (int i = 1; i < n; i++) {\\n            dp[i][i+1] = i;\\n        }\\n        \\n        \\n        for (int l = 3; l <= n; l++) {\\n            for (int i = 1; i <= n-l+1; i++) {\\n                int j = i + l - 1;\\n                int min = Integer.MAX_VALUE;\\n                for (int k = i; k < j; k++) {\\n                    min = Math.min(min, k + Math.max(dp[i][k-1], dp[k+1][j]));\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int getMoneyAmount(int n) {\\n        int[][] dp = new int[n+1][n+1];\\n        // If there are two numbers to select from,\\n        // we have to pay the cost of the lowest one.\\n        for (int i = 1; i < n; i++) {\\n            dp[i][i+1] = i;\\n        }\\n        \\n        \\n        for (int l = 3; l <= n; l++) {\\n            for (int i = 1; i <= n-l+1; i++) {\\n                int j = i + l - 1;\\n                int min = Integer.MAX_VALUE;\\n                for (int k = i; k < j; k++) {\\n                    min = Math.min(min, k + Math.max(dp[i][k-1], dp[k+1][j]));\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n        \\n        return dp[1][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564565,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1566571,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1567757,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1568162,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1567722,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1568167,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1566504,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1569703,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1569860,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1569278,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1564565,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1566571,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1567757,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1568162,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1567722,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1568167,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1566504,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1569703,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1569860,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1569278,
                "content": [
                    {
                        "username": "grodrigues3",
                        "content": "Can you guys define the problem a little more and improve the test case. \\n\\nThe example provided for n=10 does not actually give the solution to the problem (it shows 21 as the result of the provided guessing pattern); however, if you run a custom testcase the leetcode server say the answer is 16.  Can you explain how we arrive at 16.  If the number is 8 and we choose 5 7 9, we pay $21.  How does one do better than that?\\n\\nAdditionally, the question states:  Given a particular n \\u2265 1, find out how much money you need to have to guarantee a win.  Well, this wording is ambiguous, as I should be able to always return n(n+1)/2 to give the sum of all numbers from 1 to n.  That would certainly guarantee a win, right?  I think you are looking for the **minimum** amount of money you need to guarantee a win.  If so, can you specify that and improve the example to reflect it (and show how the answer 16 is achieved)."
                    },
                    {
                        "username": "avadheshG",
                        "content": "Is it only me who is not able to understand the question ?"
                    },
                    {
                        "username": "akshaypeherkar2002",
                        "content": "me too \\uD83D\\uDE22"
                    },
                    {
                        "username": "SOLA89",
                        "content": "Since we are not playing the game rather **planning ahead** while solving this problem, the answer of the opponent for a guess is **irrelevant**.\\n\\n**State:** `dp(i, j)= minimum money required to guess the correct number from range 1 to n`\\n\\n For each guess i, our main problem dp(1,n) will be divided into two sub-problem dp(1, i-1) and dp(i+1, n). In the worst case, our guess i can be incorrect and our solution can be either in  sub-problem dp(1, i-1) or dp(i+1, n) and incur cost(i) for incorrect guess i. To get the minimum required cost, we have to take minimum of cost for all possible gusses from i to n.\\n \\n**Recurrence:** `dp(1, n): MIN ( (i + MAX(dp(1, i-1), dp(i+1, n) ) ) for all i from 1 to n)`\\n\\n` why MAX(dp(1, i-1), dp(i+1, n) )`. **Again we are not playing the game rather we are planning ahead**. During planning the winning strategy, we do not know where is our solution after guessing i, the solution can be in sub-problem dp(1, i-1) or dp(i+1, n), Thus, we have to be prepared for the worst case cost while planning- thus taking max of the cost from sub-problem dp(1, i-1) and dp(i+1, n).\\n\\n**Base case:**\\n   \\t`dp(i,j) = 0 if i >= j`\\n\\n"
                    },
                    {
                        "username": "mania4u",
                        "content": "This post is just for people who get confused for the question. Because i understand the question until i read the upvoted solution. LOL.\\n\\nFirst thing i want to say is that binary search is not the optimised approach for this question. Because the sum is needed for consideration as well. I love the word \"biased search\" mentioned by @jiaozihan and it\\'s very precise for this quesiton. If we have 10 as an example, we should use 7 rather than 5 as the middle number. Because 7 is the balance number with the left side sum (1+2+3+4+5+6+7=28) is close to the the right side sum (8 + 9 + 10 = 27). If we have bigger range, the number should be smaller; if we have smaller range, the number should be bigger. The total number for the left and the right should be close. The best balance point should be root 2 divided by 2 and the basic result should be around 0.7. Well, hope this can be a little helpful to all."
                    },
                    {
                        "username": "knight6",
                        "content": "Hi, thanks for explaining. I understood how we selected 7 in the starting, but after that, in the left subtree, we should have selected 4 according to that logic right? (1+2+3+4) = 10 and (5+6)=11. Why did we select 3 as the root for the left subtree?"
                    },
                    {
                        "username": "phaniram28",
                        "content": "how would one know, optimal pick its not at the middle or centroid???\\nafter looking at solutions, it became obvious, but how would one arrive to this conclusion in real interview settings??\\n \\n consider [1,10], if we pick 5 the cost of wrong guess for answers positioned on right is higher than cost of wrong guess for answeres positioned on left, so there is asymmetry and picking middle is not optimal !! \\n \\n -- how would one arrive to this in interview\\n \\n"
                    },
                    {
                        "username": "bamboopanda",
                        "content": "I can not work out this test case manually in my head.\\n\\nI blame lack of coffee and look for more enlightened guidance."
                    },
                    {
                        "username": "zerghua",
                        "content": "should it be 3+5+1?"
                    },
                    {
                        "username": "1005155946",
                        "content": "does he use binary search way to guess the unswer? if yes , we can get the most money when I pick n. Else the answer should 2+3+4+5+...+n."
                    },
                    {
                        "username": "vipulnarula657",
                        "content": "The problem expects you to minimize the maximum amount you would have to pay in order to win, surely there is different cost required to win in case of different guess but our goal is to calculate the minimum amount needed to guess the number between 1...n , \\nresult = Math.min(result,amount(i))\\nwhere amount(i) is the worst case possible amount for guessing number i.\\nNow what is this worst case?\\nassume n =3\\n\\n1. You have picked 1, in the best case 1 might be the number you would have to guess, hence the amount(i)=0, but we are not bothered about that , we are concerned with the worst case , i,e 1 is not the picked number\\nhence cost when 1 is picked is = 1+ cost from(2,3);\\n2. you picked 2 , in the best case 2 is the answere and the cost is 0, but the in the worst case either 3 or either 1 is the answer, and the upon guessing a number you always get to know that wether the picked number is greater or less than the number , hence we would know is 1 is the answer or 3 is the answer. hence worst case cost is 2;\\n3. Picking 3 the worst case cost would be 3+ cost from(1,2);\\n4. Final cost would be the minimum of all these worst case costs.\\n5 We have to do this recusively to get the answer\\n\\nI hope this might help others.\\n\\nEdit: thanks to @lllegion for the comment , \\nThe natural question to ask is why binary search wont give you the oiptimal answer, to which my best guess is the problem has failed to mention that the guesser is making absolutely random guesses and is not trying to optimise his approach of guessing and is unaware of an algorithm to search optimally."
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "Even the dp solution wont be suffient if the guesser is making random guess. What if he guesses sequentially and the picked number is the last number? In this case, the dp solution is smaller than the actual cost"
                    },
                    {
                        "username": "linghengzhu",
                        "content": "according the the code, the overall time can be writen like this:\\n1+2+.............+n\\n1+2+.......+n-1\\n1+2+...+n-2\\n......\\n1+2\\n1\\nSo the recursive formula is **f(n)-f(n-1)=n(n+1)/2**, where f(n) is the overall time.\\ntake the second derivative: **f(n)\\'\\'-f(n-1)\\'\\'=1,   --------(1)**\\nsuppose that f(n)=dn^3+cn^2+bn+a,\\nthen according to (1), d=1/6,\\nYou can easily figure out that if there is n^4 or higher level in f(n), the right side of (1) cannot be a constant, and if the highest level is n^2, the right side of (1) should be 0.\\nAs a result, the time compleity is O(n^3)."
                    }
                ]
            },
            {
                "id": 1574269,
                "content": [
                    {
                        "username": "kangroo",
                        "content": "they haven\\'t given any function that will return of it is lower or higher. how are you guys solving this?"
                    },
                    {
                        "username": "ned1m",
                        "content": "Frankly speaking, I don\\'t understand what this question is all about, let alone think of a solution. Before I can think of a solution or understand other people\\'s solution, I need to have a grasp of the question.\\n\\nFor example, if I follow the logic, then for if n = 10, then with $16, I am guaranteed to win.\\n\\nFirst, I pick 7 and you say higher\\nNext I pick 9. If you say higher, I pick 10, if you say lower I pick 8. So I only get to pay $16.\\n\\nAlternatively, If I pick 7 and you say lower\\nNext I pick 3\\nif You say higher, I will pick 5 and game up. I am only paying $15\\nIf you say lower, I pick 1 and game up. I only need to pay $11\\n\\nThis is why it seems confusing to me.\\n\\nedit: I see, the example given confused me.\\n"
                    },
                    {
                        "username": "kakashidinho",
                        "content": "Let say there are 5 numbers, the host picked an unknown number X. The player has to guess a number,\\n- if he guesses number 3, what is the worst case that can happen? the worst case money = max(money needed to win if X is in [1,2] range, money needed to win if X is in range [4,5]). Since if he has worse case money, it doesn\\'t matter if X is in left or right of 3, since he will have enough money to win either case.\\n- Similarly, if he guesses 2, he needs worse case money to win no matter X is in [1] or [3,5] ranges.\\n\\nNote, that he purposely computes the worst case money for every guess in range [1,n] to guarantee a win for every guess. Now the final thing to do, is finding the guess with minimal worst case money. If he chooses that guess and brings its worst case money, he will win the game with minimal cost. This is the best thing he can do."
                    },
                    {
                        "username": "tambourine",
                        "content": "I'm trying to improve so I just joined but for every question I've looked at that involves DP I've been stuck. I can't seem to figure out what the subproblem should be, how it should be modeled in a matrix, how to iterate, and im amazed how other people come up with these solutions (if i can understand the solutions which often i can't.). Is there some trick to coming up with these solutions or do you just have to be smart?"
                    },
                    {
                        "username": "andulas",
                        "content": "Is it just me or is the question confusing?\\n\\nFirstly,\\n\\nI know n. Only if I know the value of the number in that was thought of (or rather for which I pay 0$), I can simulate the amount that can give me a guaranteed win? Secondly, it says \"the amount needed for a guaranteed win\". It never says minimum?"
                    },
                    {
                        "username": "shubhamshrishrimal",
                        "content": "Found this very tricky question : \\nhttps://leetcode.com/problems/guess-number-higher-or-lower-ii/\\n\\nMy intiution for the approach was. And then sum up the path from root node to the one node before the leaf node. Now we find the maximum path in the tree. So, if we create a complete bst then this should give the least sum for the right most branch going from root to the leaf node. \\n\\nCan someone help proving mathematically or the intuition why this approach goes wrong. I struggled in trying to prove this mathematically, but could not do it. \\nOr even what is the intuition behind the actual approach that is the dynamic programming based approach."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "1.  I don't quite understand the example.  Why the game is over after I end up paying 21$ ?  The fourth round I would be able to give the correct answer '8' (if I'm not stupid).  Is it because that would not be counted strictly as a \"guess\" any more OR it is because I will be running out of my money? \\n\\n2.  To \"guarantee a win\" , I have to assume the guesser is not that smart . i.e:  he always picks the wrong number until he is able to guess the target correctly.  E.g:  for n =10 , and the target is 8,  he would pick 1, 2,3,4,5,6,7, 10,9 , that sums to 47 already."
                    },
                    {
                        "username": "SR2311",
                        "content": "So lets say You and I hate each other to the core.\\nNow lets say you are the one who is supposed to read my mind and say what number I thought of.\\n\\nMe: I choose a number\\n\\nYou: Begin guessing. (All the best as I am evil will make sure you go down the rabbit hole)\\n\\nYou : Inside your head tell yourself hey you idiot even I am evil and if you will put me down the bad path I will make sure to start off with a number that will cost me minimum no matter what number you pick.\\n\\nEnough of story :P\\n\\nMoral of the story:\\n\\nYou will choose your starting number from [i...j] such that  choosing that  will cost you minimum for the choice  I make [ that is, my pick is the bad branch of your start point in other words I will pick a number that will cost you the most for your start point of all numbers]\\n\\nFor eg [1,2,3,4,5]\\n\\nI am not showing you the calculation\\nfor every start number you pick, lets assume the following\\n1--> I choose 5 why ?it will cost the max of all other choices [Assume it is 20, for rest i.e 4,3,2 it is <20]\\n2--> I choose 3 why i?t will cost the max of all other choices [Assume it is 24, for rest i.e 4,5,1 it is <24]\\n3--> I choose 1 why i?t will cost the max of all other choices [Assume it is 27, for rest i.e 4,5,2 it is <27]]\\n4--> I choose 2 why i?t will cost the max of all other choices [Assume it is 16, for rest i.e 1,3,5 it is <16]\\n5--> I choose 4 why i?t will cost the max of all other choices [Assume it is 18, for rest i.e 1,2,3 it is <18]\\n\\nNote : again I repeat I havent calculated above values it is just a random guess to explain the audience\\n\\nSo of all the above cost you will start of with min of all costs that is 4 as it costs 16\\n\\n\\n"
                    },
                    {
                        "username": "21bcs069",
                        "content": "if you clearly look at the tree then you find this is nothing but of N-ary  tree and you are trying to find height , not exactly same but little difference \\nin max and min function. \\nanswer=min(answer ,i + maximum (a,b)) with a for loop to find  \\nMAXIMUM SPENT WITH IN A GIVEN TREE, BUT \\nMINIMUM OF ALL DIFFERENT  TREE\\'S SPENT."
                    },
                    {
                        "username": "melancholymethane",
                        "content": "This problem is asking:\n1. Pretend to build a BST from {1 .. n}\n2. Sum up the value of non-leaf nodes on each path.\n3. Choose the path with the maximum sum, and denote it as sum1 of BST1.\n4. By adjusting the structure of BST, we will get different sums (sum1, sum2, ..., sumN). What is the minimum possible sum along them?"
                    }
                ]
            },
            {
                "id": 1570089,
                "content": [
                    {
                        "username": "kangroo",
                        "content": "they haven\\'t given any function that will return of it is lower or higher. how are you guys solving this?"
                    },
                    {
                        "username": "ned1m",
                        "content": "Frankly speaking, I don\\'t understand what this question is all about, let alone think of a solution. Before I can think of a solution or understand other people\\'s solution, I need to have a grasp of the question.\\n\\nFor example, if I follow the logic, then for if n = 10, then with $16, I am guaranteed to win.\\n\\nFirst, I pick 7 and you say higher\\nNext I pick 9. If you say higher, I pick 10, if you say lower I pick 8. So I only get to pay $16.\\n\\nAlternatively, If I pick 7 and you say lower\\nNext I pick 3\\nif You say higher, I will pick 5 and game up. I am only paying $15\\nIf you say lower, I pick 1 and game up. I only need to pay $11\\n\\nThis is why it seems confusing to me.\\n\\nedit: I see, the example given confused me.\\n"
                    },
                    {
                        "username": "kakashidinho",
                        "content": "Let say there are 5 numbers, the host picked an unknown number X. The player has to guess a number,\\n- if he guesses number 3, what is the worst case that can happen? the worst case money = max(money needed to win if X is in [1,2] range, money needed to win if X is in range [4,5]). Since if he has worse case money, it doesn\\'t matter if X is in left or right of 3, since he will have enough money to win either case.\\n- Similarly, if he guesses 2, he needs worse case money to win no matter X is in [1] or [3,5] ranges.\\n\\nNote, that he purposely computes the worst case money for every guess in range [1,n] to guarantee a win for every guess. Now the final thing to do, is finding the guess with minimal worst case money. If he chooses that guess and brings its worst case money, he will win the game with minimal cost. This is the best thing he can do."
                    },
                    {
                        "username": "tambourine",
                        "content": "I'm trying to improve so I just joined but for every question I've looked at that involves DP I've been stuck. I can't seem to figure out what the subproblem should be, how it should be modeled in a matrix, how to iterate, and im amazed how other people come up with these solutions (if i can understand the solutions which often i can't.). Is there some trick to coming up with these solutions or do you just have to be smart?"
                    },
                    {
                        "username": "andulas",
                        "content": "Is it just me or is the question confusing?\\n\\nFirstly,\\n\\nI know n. Only if I know the value of the number in that was thought of (or rather for which I pay 0$), I can simulate the amount that can give me a guaranteed win? Secondly, it says \"the amount needed for a guaranteed win\". It never says minimum?"
                    },
                    {
                        "username": "shubhamshrishrimal",
                        "content": "Found this very tricky question : \\nhttps://leetcode.com/problems/guess-number-higher-or-lower-ii/\\n\\nMy intiution for the approach was. And then sum up the path from root node to the one node before the leaf node. Now we find the maximum path in the tree. So, if we create a complete bst then this should give the least sum for the right most branch going from root to the leaf node. \\n\\nCan someone help proving mathematically or the intuition why this approach goes wrong. I struggled in trying to prove this mathematically, but could not do it. \\nOr even what is the intuition behind the actual approach that is the dynamic programming based approach."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "1.  I don't quite understand the example.  Why the game is over after I end up paying 21$ ?  The fourth round I would be able to give the correct answer '8' (if I'm not stupid).  Is it because that would not be counted strictly as a \"guess\" any more OR it is because I will be running out of my money? \\n\\n2.  To \"guarantee a win\" , I have to assume the guesser is not that smart . i.e:  he always picks the wrong number until he is able to guess the target correctly.  E.g:  for n =10 , and the target is 8,  he would pick 1, 2,3,4,5,6,7, 10,9 , that sums to 47 already."
                    },
                    {
                        "username": "SR2311",
                        "content": "So lets say You and I hate each other to the core.\\nNow lets say you are the one who is supposed to read my mind and say what number I thought of.\\n\\nMe: I choose a number\\n\\nYou: Begin guessing. (All the best as I am evil will make sure you go down the rabbit hole)\\n\\nYou : Inside your head tell yourself hey you idiot even I am evil and if you will put me down the bad path I will make sure to start off with a number that will cost me minimum no matter what number you pick.\\n\\nEnough of story :P\\n\\nMoral of the story:\\n\\nYou will choose your starting number from [i...j] such that  choosing that  will cost you minimum for the choice  I make [ that is, my pick is the bad branch of your start point in other words I will pick a number that will cost you the most for your start point of all numbers]\\n\\nFor eg [1,2,3,4,5]\\n\\nI am not showing you the calculation\\nfor every start number you pick, lets assume the following\\n1--> I choose 5 why ?it will cost the max of all other choices [Assume it is 20, for rest i.e 4,3,2 it is <20]\\n2--> I choose 3 why i?t will cost the max of all other choices [Assume it is 24, for rest i.e 4,5,1 it is <24]\\n3--> I choose 1 why i?t will cost the max of all other choices [Assume it is 27, for rest i.e 4,5,2 it is <27]]\\n4--> I choose 2 why i?t will cost the max of all other choices [Assume it is 16, for rest i.e 1,3,5 it is <16]\\n5--> I choose 4 why i?t will cost the max of all other choices [Assume it is 18, for rest i.e 1,2,3 it is <18]\\n\\nNote : again I repeat I havent calculated above values it is just a random guess to explain the audience\\n\\nSo of all the above cost you will start of with min of all costs that is 4 as it costs 16\\n\\n\\n"
                    },
                    {
                        "username": "21bcs069",
                        "content": "if you clearly look at the tree then you find this is nothing but of N-ary  tree and you are trying to find height , not exactly same but little difference \\nin max and min function. \\nanswer=min(answer ,i + maximum (a,b)) with a for loop to find  \\nMAXIMUM SPENT WITH IN A GIVEN TREE, BUT \\nMINIMUM OF ALL DIFFERENT  TREE\\'S SPENT."
                    },
                    {
                        "username": "melancholymethane",
                        "content": "This problem is asking:\n1. Pretend to build a BST from {1 .. n}\n2. Sum up the value of non-leaf nodes on each path.\n3. Choose the path with the maximum sum, and denote it as sum1 of BST1.\n4. By adjusting the structure of BST, we will get different sums (sum1, sum2, ..., sumN). What is the minimum possible sum along them?"
                    }
                ]
            },
            {
                "id": 1573393,
                "content": [
                    {
                        "username": "kangroo",
                        "content": "they haven\\'t given any function that will return of it is lower or higher. how are you guys solving this?"
                    },
                    {
                        "username": "ned1m",
                        "content": "Frankly speaking, I don\\'t understand what this question is all about, let alone think of a solution. Before I can think of a solution or understand other people\\'s solution, I need to have a grasp of the question.\\n\\nFor example, if I follow the logic, then for if n = 10, then with $16, I am guaranteed to win.\\n\\nFirst, I pick 7 and you say higher\\nNext I pick 9. If you say higher, I pick 10, if you say lower I pick 8. So I only get to pay $16.\\n\\nAlternatively, If I pick 7 and you say lower\\nNext I pick 3\\nif You say higher, I will pick 5 and game up. I am only paying $15\\nIf you say lower, I pick 1 and game up. I only need to pay $11\\n\\nThis is why it seems confusing to me.\\n\\nedit: I see, the example given confused me.\\n"
                    },
                    {
                        "username": "kakashidinho",
                        "content": "Let say there are 5 numbers, the host picked an unknown number X. The player has to guess a number,\\n- if he guesses number 3, what is the worst case that can happen? the worst case money = max(money needed to win if X is in [1,2] range, money needed to win if X is in range [4,5]). Since if he has worse case money, it doesn\\'t matter if X is in left or right of 3, since he will have enough money to win either case.\\n- Similarly, if he guesses 2, he needs worse case money to win no matter X is in [1] or [3,5] ranges.\\n\\nNote, that he purposely computes the worst case money for every guess in range [1,n] to guarantee a win for every guess. Now the final thing to do, is finding the guess with minimal worst case money. If he chooses that guess and brings its worst case money, he will win the game with minimal cost. This is the best thing he can do."
                    },
                    {
                        "username": "tambourine",
                        "content": "I'm trying to improve so I just joined but for every question I've looked at that involves DP I've been stuck. I can't seem to figure out what the subproblem should be, how it should be modeled in a matrix, how to iterate, and im amazed how other people come up with these solutions (if i can understand the solutions which often i can't.). Is there some trick to coming up with these solutions or do you just have to be smart?"
                    },
                    {
                        "username": "andulas",
                        "content": "Is it just me or is the question confusing?\\n\\nFirstly,\\n\\nI know n. Only if I know the value of the number in that was thought of (or rather for which I pay 0$), I can simulate the amount that can give me a guaranteed win? Secondly, it says \"the amount needed for a guaranteed win\". It never says minimum?"
                    },
                    {
                        "username": "shubhamshrishrimal",
                        "content": "Found this very tricky question : \\nhttps://leetcode.com/problems/guess-number-higher-or-lower-ii/\\n\\nMy intiution for the approach was. And then sum up the path from root node to the one node before the leaf node. Now we find the maximum path in the tree. So, if we create a complete bst then this should give the least sum for the right most branch going from root to the leaf node. \\n\\nCan someone help proving mathematically or the intuition why this approach goes wrong. I struggled in trying to prove this mathematically, but could not do it. \\nOr even what is the intuition behind the actual approach that is the dynamic programming based approach."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "1.  I don't quite understand the example.  Why the game is over after I end up paying 21$ ?  The fourth round I would be able to give the correct answer '8' (if I'm not stupid).  Is it because that would not be counted strictly as a \"guess\" any more OR it is because I will be running out of my money? \\n\\n2.  To \"guarantee a win\" , I have to assume the guesser is not that smart . i.e:  he always picks the wrong number until he is able to guess the target correctly.  E.g:  for n =10 , and the target is 8,  he would pick 1, 2,3,4,5,6,7, 10,9 , that sums to 47 already."
                    },
                    {
                        "username": "SR2311",
                        "content": "So lets say You and I hate each other to the core.\\nNow lets say you are the one who is supposed to read my mind and say what number I thought of.\\n\\nMe: I choose a number\\n\\nYou: Begin guessing. (All the best as I am evil will make sure you go down the rabbit hole)\\n\\nYou : Inside your head tell yourself hey you idiot even I am evil and if you will put me down the bad path I will make sure to start off with a number that will cost me minimum no matter what number you pick.\\n\\nEnough of story :P\\n\\nMoral of the story:\\n\\nYou will choose your starting number from [i...j] such that  choosing that  will cost you minimum for the choice  I make [ that is, my pick is the bad branch of your start point in other words I will pick a number that will cost you the most for your start point of all numbers]\\n\\nFor eg [1,2,3,4,5]\\n\\nI am not showing you the calculation\\nfor every start number you pick, lets assume the following\\n1--> I choose 5 why ?it will cost the max of all other choices [Assume it is 20, for rest i.e 4,3,2 it is <20]\\n2--> I choose 3 why i?t will cost the max of all other choices [Assume it is 24, for rest i.e 4,5,1 it is <24]\\n3--> I choose 1 why i?t will cost the max of all other choices [Assume it is 27, for rest i.e 4,5,2 it is <27]]\\n4--> I choose 2 why i?t will cost the max of all other choices [Assume it is 16, for rest i.e 1,3,5 it is <16]\\n5--> I choose 4 why i?t will cost the max of all other choices [Assume it is 18, for rest i.e 1,2,3 it is <18]\\n\\nNote : again I repeat I havent calculated above values it is just a random guess to explain the audience\\n\\nSo of all the above cost you will start of with min of all costs that is 4 as it costs 16\\n\\n\\n"
                    },
                    {
                        "username": "21bcs069",
                        "content": "if you clearly look at the tree then you find this is nothing but of N-ary  tree and you are trying to find height , not exactly same but little difference \\nin max and min function. \\nanswer=min(answer ,i + maximum (a,b)) with a for loop to find  \\nMAXIMUM SPENT WITH IN A GIVEN TREE, BUT \\nMINIMUM OF ALL DIFFERENT  TREE\\'S SPENT."
                    },
                    {
                        "username": "melancholymethane",
                        "content": "This problem is asking:\n1. Pretend to build a BST from {1 .. n}\n2. Sum up the value of non-leaf nodes on each path.\n3. Choose the path with the maximum sum, and denote it as sum1 of BST1.\n4. By adjusting the structure of BST, we will get different sums (sum1, sum2, ..., sumN). What is the minimum possible sum along them?"
                    }
                ]
            },
            {
                "id": 1571647,
                "content": [
                    {
                        "username": "kangroo",
                        "content": "they haven\\'t given any function that will return of it is lower or higher. how are you guys solving this?"
                    },
                    {
                        "username": "ned1m",
                        "content": "Frankly speaking, I don\\'t understand what this question is all about, let alone think of a solution. Before I can think of a solution or understand other people\\'s solution, I need to have a grasp of the question.\\n\\nFor example, if I follow the logic, then for if n = 10, then with $16, I am guaranteed to win.\\n\\nFirst, I pick 7 and you say higher\\nNext I pick 9. If you say higher, I pick 10, if you say lower I pick 8. So I only get to pay $16.\\n\\nAlternatively, If I pick 7 and you say lower\\nNext I pick 3\\nif You say higher, I will pick 5 and game up. I am only paying $15\\nIf you say lower, I pick 1 and game up. I only need to pay $11\\n\\nThis is why it seems confusing to me.\\n\\nedit: I see, the example given confused me.\\n"
                    },
                    {
                        "username": "kakashidinho",
                        "content": "Let say there are 5 numbers, the host picked an unknown number X. The player has to guess a number,\\n- if he guesses number 3, what is the worst case that can happen? the worst case money = max(money needed to win if X is in [1,2] range, money needed to win if X is in range [4,5]). Since if he has worse case money, it doesn\\'t matter if X is in left or right of 3, since he will have enough money to win either case.\\n- Similarly, if he guesses 2, he needs worse case money to win no matter X is in [1] or [3,5] ranges.\\n\\nNote, that he purposely computes the worst case money for every guess in range [1,n] to guarantee a win for every guess. Now the final thing to do, is finding the guess with minimal worst case money. If he chooses that guess and brings its worst case money, he will win the game with minimal cost. This is the best thing he can do."
                    },
                    {
                        "username": "tambourine",
                        "content": "I'm trying to improve so I just joined but for every question I've looked at that involves DP I've been stuck. I can't seem to figure out what the subproblem should be, how it should be modeled in a matrix, how to iterate, and im amazed how other people come up with these solutions (if i can understand the solutions which often i can't.). Is there some trick to coming up with these solutions or do you just have to be smart?"
                    },
                    {
                        "username": "andulas",
                        "content": "Is it just me or is the question confusing?\\n\\nFirstly,\\n\\nI know n. Only if I know the value of the number in that was thought of (or rather for which I pay 0$), I can simulate the amount that can give me a guaranteed win? Secondly, it says \"the amount needed for a guaranteed win\". It never says minimum?"
                    },
                    {
                        "username": "shubhamshrishrimal",
                        "content": "Found this very tricky question : \\nhttps://leetcode.com/problems/guess-number-higher-or-lower-ii/\\n\\nMy intiution for the approach was. And then sum up the path from root node to the one node before the leaf node. Now we find the maximum path in the tree. So, if we create a complete bst then this should give the least sum for the right most branch going from root to the leaf node. \\n\\nCan someone help proving mathematically or the intuition why this approach goes wrong. I struggled in trying to prove this mathematically, but could not do it. \\nOr even what is the intuition behind the actual approach that is the dynamic programming based approach."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "1.  I don't quite understand the example.  Why the game is over after I end up paying 21$ ?  The fourth round I would be able to give the correct answer '8' (if I'm not stupid).  Is it because that would not be counted strictly as a \"guess\" any more OR it is because I will be running out of my money? \\n\\n2.  To \"guarantee a win\" , I have to assume the guesser is not that smart . i.e:  he always picks the wrong number until he is able to guess the target correctly.  E.g:  for n =10 , and the target is 8,  he would pick 1, 2,3,4,5,6,7, 10,9 , that sums to 47 already."
                    },
                    {
                        "username": "SR2311",
                        "content": "So lets say You and I hate each other to the core.\\nNow lets say you are the one who is supposed to read my mind and say what number I thought of.\\n\\nMe: I choose a number\\n\\nYou: Begin guessing. (All the best as I am evil will make sure you go down the rabbit hole)\\n\\nYou : Inside your head tell yourself hey you idiot even I am evil and if you will put me down the bad path I will make sure to start off with a number that will cost me minimum no matter what number you pick.\\n\\nEnough of story :P\\n\\nMoral of the story:\\n\\nYou will choose your starting number from [i...j] such that  choosing that  will cost you minimum for the choice  I make [ that is, my pick is the bad branch of your start point in other words I will pick a number that will cost you the most for your start point of all numbers]\\n\\nFor eg [1,2,3,4,5]\\n\\nI am not showing you the calculation\\nfor every start number you pick, lets assume the following\\n1--> I choose 5 why ?it will cost the max of all other choices [Assume it is 20, for rest i.e 4,3,2 it is <20]\\n2--> I choose 3 why i?t will cost the max of all other choices [Assume it is 24, for rest i.e 4,5,1 it is <24]\\n3--> I choose 1 why i?t will cost the max of all other choices [Assume it is 27, for rest i.e 4,5,2 it is <27]]\\n4--> I choose 2 why i?t will cost the max of all other choices [Assume it is 16, for rest i.e 1,3,5 it is <16]\\n5--> I choose 4 why i?t will cost the max of all other choices [Assume it is 18, for rest i.e 1,2,3 it is <18]\\n\\nNote : again I repeat I havent calculated above values it is just a random guess to explain the audience\\n\\nSo of all the above cost you will start of with min of all costs that is 4 as it costs 16\\n\\n\\n"
                    },
                    {
                        "username": "21bcs069",
                        "content": "if you clearly look at the tree then you find this is nothing but of N-ary  tree and you are trying to find height , not exactly same but little difference \\nin max and min function. \\nanswer=min(answer ,i + maximum (a,b)) with a for loop to find  \\nMAXIMUM SPENT WITH IN A GIVEN TREE, BUT \\nMINIMUM OF ALL DIFFERENT  TREE\\'S SPENT."
                    },
                    {
                        "username": "melancholymethane",
                        "content": "This problem is asking:\n1. Pretend to build a BST from {1 .. n}\n2. Sum up the value of non-leaf nodes on each path.\n3. Choose the path with the maximum sum, and denote it as sum1 of BST1.\n4. By adjusting the structure of BST, we will get different sums (sum1, sum2, ..., sumN). What is the minimum possible sum along them?"
                    }
                ]
            },
            {
                "id": 1569101,
                "content": [
                    {
                        "username": "kangroo",
                        "content": "they haven\\'t given any function that will return of it is lower or higher. how are you guys solving this?"
                    },
                    {
                        "username": "ned1m",
                        "content": "Frankly speaking, I don\\'t understand what this question is all about, let alone think of a solution. Before I can think of a solution or understand other people\\'s solution, I need to have a grasp of the question.\\n\\nFor example, if I follow the logic, then for if n = 10, then with $16, I am guaranteed to win.\\n\\nFirst, I pick 7 and you say higher\\nNext I pick 9. If you say higher, I pick 10, if you say lower I pick 8. So I only get to pay $16.\\n\\nAlternatively, If I pick 7 and you say lower\\nNext I pick 3\\nif You say higher, I will pick 5 and game up. I am only paying $15\\nIf you say lower, I pick 1 and game up. I only need to pay $11\\n\\nThis is why it seems confusing to me.\\n\\nedit: I see, the example given confused me.\\n"
                    },
                    {
                        "username": "kakashidinho",
                        "content": "Let say there are 5 numbers, the host picked an unknown number X. The player has to guess a number,\\n- if he guesses number 3, what is the worst case that can happen? the worst case money = max(money needed to win if X is in [1,2] range, money needed to win if X is in range [4,5]). Since if he has worse case money, it doesn\\'t matter if X is in left or right of 3, since he will have enough money to win either case.\\n- Similarly, if he guesses 2, he needs worse case money to win no matter X is in [1] or [3,5] ranges.\\n\\nNote, that he purposely computes the worst case money for every guess in range [1,n] to guarantee a win for every guess. Now the final thing to do, is finding the guess with minimal worst case money. If he chooses that guess and brings its worst case money, he will win the game with minimal cost. This is the best thing he can do."
                    },
                    {
                        "username": "tambourine",
                        "content": "I'm trying to improve so I just joined but for every question I've looked at that involves DP I've been stuck. I can't seem to figure out what the subproblem should be, how it should be modeled in a matrix, how to iterate, and im amazed how other people come up with these solutions (if i can understand the solutions which often i can't.). Is there some trick to coming up with these solutions or do you just have to be smart?"
                    },
                    {
                        "username": "andulas",
                        "content": "Is it just me or is the question confusing?\\n\\nFirstly,\\n\\nI know n. Only if I know the value of the number in that was thought of (or rather for which I pay 0$), I can simulate the amount that can give me a guaranteed win? Secondly, it says \"the amount needed for a guaranteed win\". It never says minimum?"
                    },
                    {
                        "username": "shubhamshrishrimal",
                        "content": "Found this very tricky question : \\nhttps://leetcode.com/problems/guess-number-higher-or-lower-ii/\\n\\nMy intiution for the approach was. And then sum up the path from root node to the one node before the leaf node. Now we find the maximum path in the tree. So, if we create a complete bst then this should give the least sum for the right most branch going from root to the leaf node. \\n\\nCan someone help proving mathematically or the intuition why this approach goes wrong. I struggled in trying to prove this mathematically, but could not do it. \\nOr even what is the intuition behind the actual approach that is the dynamic programming based approach."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "1.  I don't quite understand the example.  Why the game is over after I end up paying 21$ ?  The fourth round I would be able to give the correct answer '8' (if I'm not stupid).  Is it because that would not be counted strictly as a \"guess\" any more OR it is because I will be running out of my money? \\n\\n2.  To \"guarantee a win\" , I have to assume the guesser is not that smart . i.e:  he always picks the wrong number until he is able to guess the target correctly.  E.g:  for n =10 , and the target is 8,  he would pick 1, 2,3,4,5,6,7, 10,9 , that sums to 47 already."
                    },
                    {
                        "username": "SR2311",
                        "content": "So lets say You and I hate each other to the core.\\nNow lets say you are the one who is supposed to read my mind and say what number I thought of.\\n\\nMe: I choose a number\\n\\nYou: Begin guessing. (All the best as I am evil will make sure you go down the rabbit hole)\\n\\nYou : Inside your head tell yourself hey you idiot even I am evil and if you will put me down the bad path I will make sure to start off with a number that will cost me minimum no matter what number you pick.\\n\\nEnough of story :P\\n\\nMoral of the story:\\n\\nYou will choose your starting number from [i...j] such that  choosing that  will cost you minimum for the choice  I make [ that is, my pick is the bad branch of your start point in other words I will pick a number that will cost you the most for your start point of all numbers]\\n\\nFor eg [1,2,3,4,5]\\n\\nI am not showing you the calculation\\nfor every start number you pick, lets assume the following\\n1--> I choose 5 why ?it will cost the max of all other choices [Assume it is 20, for rest i.e 4,3,2 it is <20]\\n2--> I choose 3 why i?t will cost the max of all other choices [Assume it is 24, for rest i.e 4,5,1 it is <24]\\n3--> I choose 1 why i?t will cost the max of all other choices [Assume it is 27, for rest i.e 4,5,2 it is <27]]\\n4--> I choose 2 why i?t will cost the max of all other choices [Assume it is 16, for rest i.e 1,3,5 it is <16]\\n5--> I choose 4 why i?t will cost the max of all other choices [Assume it is 18, for rest i.e 1,2,3 it is <18]\\n\\nNote : again I repeat I havent calculated above values it is just a random guess to explain the audience\\n\\nSo of all the above cost you will start of with min of all costs that is 4 as it costs 16\\n\\n\\n"
                    },
                    {
                        "username": "21bcs069",
                        "content": "if you clearly look at the tree then you find this is nothing but of N-ary  tree and you are trying to find height , not exactly same but little difference \\nin max and min function. \\nanswer=min(answer ,i + maximum (a,b)) with a for loop to find  \\nMAXIMUM SPENT WITH IN A GIVEN TREE, BUT \\nMINIMUM OF ALL DIFFERENT  TREE\\'S SPENT."
                    },
                    {
                        "username": "melancholymethane",
                        "content": "This problem is asking:\n1. Pretend to build a BST from {1 .. n}\n2. Sum up the value of non-leaf nodes on each path.\n3. Choose the path with the maximum sum, and denote it as sum1 of BST1.\n4. By adjusting the structure of BST, we will get different sums (sum1, sum2, ..., sumN). What is the minimum possible sum along them?"
                    }
                ]
            },
            {
                "id": 1575850,
                "content": [
                    {
                        "username": "kangroo",
                        "content": "they haven\\'t given any function that will return of it is lower or higher. how are you guys solving this?"
                    },
                    {
                        "username": "ned1m",
                        "content": "Frankly speaking, I don\\'t understand what this question is all about, let alone think of a solution. Before I can think of a solution or understand other people\\'s solution, I need to have a grasp of the question.\\n\\nFor example, if I follow the logic, then for if n = 10, then with $16, I am guaranteed to win.\\n\\nFirst, I pick 7 and you say higher\\nNext I pick 9. If you say higher, I pick 10, if you say lower I pick 8. So I only get to pay $16.\\n\\nAlternatively, If I pick 7 and you say lower\\nNext I pick 3\\nif You say higher, I will pick 5 and game up. I am only paying $15\\nIf you say lower, I pick 1 and game up. I only need to pay $11\\n\\nThis is why it seems confusing to me.\\n\\nedit: I see, the example given confused me.\\n"
                    },
                    {
                        "username": "kakashidinho",
                        "content": "Let say there are 5 numbers, the host picked an unknown number X. The player has to guess a number,\\n- if he guesses number 3, what is the worst case that can happen? the worst case money = max(money needed to win if X is in [1,2] range, money needed to win if X is in range [4,5]). Since if he has worse case money, it doesn\\'t matter if X is in left or right of 3, since he will have enough money to win either case.\\n- Similarly, if he guesses 2, he needs worse case money to win no matter X is in [1] or [3,5] ranges.\\n\\nNote, that he purposely computes the worst case money for every guess in range [1,n] to guarantee a win for every guess. Now the final thing to do, is finding the guess with minimal worst case money. If he chooses that guess and brings its worst case money, he will win the game with minimal cost. This is the best thing he can do."
                    },
                    {
                        "username": "tambourine",
                        "content": "I'm trying to improve so I just joined but for every question I've looked at that involves DP I've been stuck. I can't seem to figure out what the subproblem should be, how it should be modeled in a matrix, how to iterate, and im amazed how other people come up with these solutions (if i can understand the solutions which often i can't.). Is there some trick to coming up with these solutions or do you just have to be smart?"
                    },
                    {
                        "username": "andulas",
                        "content": "Is it just me or is the question confusing?\\n\\nFirstly,\\n\\nI know n. Only if I know the value of the number in that was thought of (or rather for which I pay 0$), I can simulate the amount that can give me a guaranteed win? Secondly, it says \"the amount needed for a guaranteed win\". It never says minimum?"
                    },
                    {
                        "username": "shubhamshrishrimal",
                        "content": "Found this very tricky question : \\nhttps://leetcode.com/problems/guess-number-higher-or-lower-ii/\\n\\nMy intiution for the approach was. And then sum up the path from root node to the one node before the leaf node. Now we find the maximum path in the tree. So, if we create a complete bst then this should give the least sum for the right most branch going from root to the leaf node. \\n\\nCan someone help proving mathematically or the intuition why this approach goes wrong. I struggled in trying to prove this mathematically, but could not do it. \\nOr even what is the intuition behind the actual approach that is the dynamic programming based approach."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "1.  I don't quite understand the example.  Why the game is over after I end up paying 21$ ?  The fourth round I would be able to give the correct answer '8' (if I'm not stupid).  Is it because that would not be counted strictly as a \"guess\" any more OR it is because I will be running out of my money? \\n\\n2.  To \"guarantee a win\" , I have to assume the guesser is not that smart . i.e:  he always picks the wrong number until he is able to guess the target correctly.  E.g:  for n =10 , and the target is 8,  he would pick 1, 2,3,4,5,6,7, 10,9 , that sums to 47 already."
                    },
                    {
                        "username": "SR2311",
                        "content": "So lets say You and I hate each other to the core.\\nNow lets say you are the one who is supposed to read my mind and say what number I thought of.\\n\\nMe: I choose a number\\n\\nYou: Begin guessing. (All the best as I am evil will make sure you go down the rabbit hole)\\n\\nYou : Inside your head tell yourself hey you idiot even I am evil and if you will put me down the bad path I will make sure to start off with a number that will cost me minimum no matter what number you pick.\\n\\nEnough of story :P\\n\\nMoral of the story:\\n\\nYou will choose your starting number from [i...j] such that  choosing that  will cost you minimum for the choice  I make [ that is, my pick is the bad branch of your start point in other words I will pick a number that will cost you the most for your start point of all numbers]\\n\\nFor eg [1,2,3,4,5]\\n\\nI am not showing you the calculation\\nfor every start number you pick, lets assume the following\\n1--> I choose 5 why ?it will cost the max of all other choices [Assume it is 20, for rest i.e 4,3,2 it is <20]\\n2--> I choose 3 why i?t will cost the max of all other choices [Assume it is 24, for rest i.e 4,5,1 it is <24]\\n3--> I choose 1 why i?t will cost the max of all other choices [Assume it is 27, for rest i.e 4,5,2 it is <27]]\\n4--> I choose 2 why i?t will cost the max of all other choices [Assume it is 16, for rest i.e 1,3,5 it is <16]\\n5--> I choose 4 why i?t will cost the max of all other choices [Assume it is 18, for rest i.e 1,2,3 it is <18]\\n\\nNote : again I repeat I havent calculated above values it is just a random guess to explain the audience\\n\\nSo of all the above cost you will start of with min of all costs that is 4 as it costs 16\\n\\n\\n"
                    },
                    {
                        "username": "21bcs069",
                        "content": "if you clearly look at the tree then you find this is nothing but of N-ary  tree and you are trying to find height , not exactly same but little difference \\nin max and min function. \\nanswer=min(answer ,i + maximum (a,b)) with a for loop to find  \\nMAXIMUM SPENT WITH IN A GIVEN TREE, BUT \\nMINIMUM OF ALL DIFFERENT  TREE\\'S SPENT."
                    },
                    {
                        "username": "melancholymethane",
                        "content": "This problem is asking:\n1. Pretend to build a BST from {1 .. n}\n2. Sum up the value of non-leaf nodes on each path.\n3. Choose the path with the maximum sum, and denote it as sum1 of BST1.\n4. By adjusting the structure of BST, we will get different sums (sum1, sum2, ..., sumN). What is the minimum possible sum along them?"
                    }
                ]
            },
            {
                "id": 1571648,
                "content": [
                    {
                        "username": "kangroo",
                        "content": "they haven\\'t given any function that will return of it is lower or higher. how are you guys solving this?"
                    },
                    {
                        "username": "ned1m",
                        "content": "Frankly speaking, I don\\'t understand what this question is all about, let alone think of a solution. Before I can think of a solution or understand other people\\'s solution, I need to have a grasp of the question.\\n\\nFor example, if I follow the logic, then for if n = 10, then with $16, I am guaranteed to win.\\n\\nFirst, I pick 7 and you say higher\\nNext I pick 9. If you say higher, I pick 10, if you say lower I pick 8. So I only get to pay $16.\\n\\nAlternatively, If I pick 7 and you say lower\\nNext I pick 3\\nif You say higher, I will pick 5 and game up. I am only paying $15\\nIf you say lower, I pick 1 and game up. I only need to pay $11\\n\\nThis is why it seems confusing to me.\\n\\nedit: I see, the example given confused me.\\n"
                    },
                    {
                        "username": "kakashidinho",
                        "content": "Let say there are 5 numbers, the host picked an unknown number X. The player has to guess a number,\\n- if he guesses number 3, what is the worst case that can happen? the worst case money = max(money needed to win if X is in [1,2] range, money needed to win if X is in range [4,5]). Since if he has worse case money, it doesn\\'t matter if X is in left or right of 3, since he will have enough money to win either case.\\n- Similarly, if he guesses 2, he needs worse case money to win no matter X is in [1] or [3,5] ranges.\\n\\nNote, that he purposely computes the worst case money for every guess in range [1,n] to guarantee a win for every guess. Now the final thing to do, is finding the guess with minimal worst case money. If he chooses that guess and brings its worst case money, he will win the game with minimal cost. This is the best thing he can do."
                    },
                    {
                        "username": "tambourine",
                        "content": "I'm trying to improve so I just joined but for every question I've looked at that involves DP I've been stuck. I can't seem to figure out what the subproblem should be, how it should be modeled in a matrix, how to iterate, and im amazed how other people come up with these solutions (if i can understand the solutions which often i can't.). Is there some trick to coming up with these solutions or do you just have to be smart?"
                    },
                    {
                        "username": "andulas",
                        "content": "Is it just me or is the question confusing?\\n\\nFirstly,\\n\\nI know n. Only if I know the value of the number in that was thought of (or rather for which I pay 0$), I can simulate the amount that can give me a guaranteed win? Secondly, it says \"the amount needed for a guaranteed win\". It never says minimum?"
                    },
                    {
                        "username": "shubhamshrishrimal",
                        "content": "Found this very tricky question : \\nhttps://leetcode.com/problems/guess-number-higher-or-lower-ii/\\n\\nMy intiution for the approach was. And then sum up the path from root node to the one node before the leaf node. Now we find the maximum path in the tree. So, if we create a complete bst then this should give the least sum for the right most branch going from root to the leaf node. \\n\\nCan someone help proving mathematically or the intuition why this approach goes wrong. I struggled in trying to prove this mathematically, but could not do it. \\nOr even what is the intuition behind the actual approach that is the dynamic programming based approach."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "1.  I don't quite understand the example.  Why the game is over after I end up paying 21$ ?  The fourth round I would be able to give the correct answer '8' (if I'm not stupid).  Is it because that would not be counted strictly as a \"guess\" any more OR it is because I will be running out of my money? \\n\\n2.  To \"guarantee a win\" , I have to assume the guesser is not that smart . i.e:  he always picks the wrong number until he is able to guess the target correctly.  E.g:  for n =10 , and the target is 8,  he would pick 1, 2,3,4,5,6,7, 10,9 , that sums to 47 already."
                    },
                    {
                        "username": "SR2311",
                        "content": "So lets say You and I hate each other to the core.\\nNow lets say you are the one who is supposed to read my mind and say what number I thought of.\\n\\nMe: I choose a number\\n\\nYou: Begin guessing. (All the best as I am evil will make sure you go down the rabbit hole)\\n\\nYou : Inside your head tell yourself hey you idiot even I am evil and if you will put me down the bad path I will make sure to start off with a number that will cost me minimum no matter what number you pick.\\n\\nEnough of story :P\\n\\nMoral of the story:\\n\\nYou will choose your starting number from [i...j] such that  choosing that  will cost you minimum for the choice  I make [ that is, my pick is the bad branch of your start point in other words I will pick a number that will cost you the most for your start point of all numbers]\\n\\nFor eg [1,2,3,4,5]\\n\\nI am not showing you the calculation\\nfor every start number you pick, lets assume the following\\n1--> I choose 5 why ?it will cost the max of all other choices [Assume it is 20, for rest i.e 4,3,2 it is <20]\\n2--> I choose 3 why i?t will cost the max of all other choices [Assume it is 24, for rest i.e 4,5,1 it is <24]\\n3--> I choose 1 why i?t will cost the max of all other choices [Assume it is 27, for rest i.e 4,5,2 it is <27]]\\n4--> I choose 2 why i?t will cost the max of all other choices [Assume it is 16, for rest i.e 1,3,5 it is <16]\\n5--> I choose 4 why i?t will cost the max of all other choices [Assume it is 18, for rest i.e 1,2,3 it is <18]\\n\\nNote : again I repeat I havent calculated above values it is just a random guess to explain the audience\\n\\nSo of all the above cost you will start of with min of all costs that is 4 as it costs 16\\n\\n\\n"
                    },
                    {
                        "username": "21bcs069",
                        "content": "if you clearly look at the tree then you find this is nothing but of N-ary  tree and you are trying to find height , not exactly same but little difference \\nin max and min function. \\nanswer=min(answer ,i + maximum (a,b)) with a for loop to find  \\nMAXIMUM SPENT WITH IN A GIVEN TREE, BUT \\nMINIMUM OF ALL DIFFERENT  TREE\\'S SPENT."
                    },
                    {
                        "username": "melancholymethane",
                        "content": "This problem is asking:\n1. Pretend to build a BST from {1 .. n}\n2. Sum up the value of non-leaf nodes on each path.\n3. Choose the path with the maximum sum, and denote it as sum1 of BST1.\n4. By adjusting the structure of BST, we will get different sums (sum1, sum2, ..., sumN). What is the minimum possible sum along them?"
                    }
                ]
            },
            {
                "id": 1569958,
                "content": [
                    {
                        "username": "kangroo",
                        "content": "they haven\\'t given any function that will return of it is lower or higher. how are you guys solving this?"
                    },
                    {
                        "username": "ned1m",
                        "content": "Frankly speaking, I don\\'t understand what this question is all about, let alone think of a solution. Before I can think of a solution or understand other people\\'s solution, I need to have a grasp of the question.\\n\\nFor example, if I follow the logic, then for if n = 10, then with $16, I am guaranteed to win.\\n\\nFirst, I pick 7 and you say higher\\nNext I pick 9. If you say higher, I pick 10, if you say lower I pick 8. So I only get to pay $16.\\n\\nAlternatively, If I pick 7 and you say lower\\nNext I pick 3\\nif You say higher, I will pick 5 and game up. I am only paying $15\\nIf you say lower, I pick 1 and game up. I only need to pay $11\\n\\nThis is why it seems confusing to me.\\n\\nedit: I see, the example given confused me.\\n"
                    },
                    {
                        "username": "kakashidinho",
                        "content": "Let say there are 5 numbers, the host picked an unknown number X. The player has to guess a number,\\n- if he guesses number 3, what is the worst case that can happen? the worst case money = max(money needed to win if X is in [1,2] range, money needed to win if X is in range [4,5]). Since if he has worse case money, it doesn\\'t matter if X is in left or right of 3, since he will have enough money to win either case.\\n- Similarly, if he guesses 2, he needs worse case money to win no matter X is in [1] or [3,5] ranges.\\n\\nNote, that he purposely computes the worst case money for every guess in range [1,n] to guarantee a win for every guess. Now the final thing to do, is finding the guess with minimal worst case money. If he chooses that guess and brings its worst case money, he will win the game with minimal cost. This is the best thing he can do."
                    },
                    {
                        "username": "tambourine",
                        "content": "I'm trying to improve so I just joined but for every question I've looked at that involves DP I've been stuck. I can't seem to figure out what the subproblem should be, how it should be modeled in a matrix, how to iterate, and im amazed how other people come up with these solutions (if i can understand the solutions which often i can't.). Is there some trick to coming up with these solutions or do you just have to be smart?"
                    },
                    {
                        "username": "andulas",
                        "content": "Is it just me or is the question confusing?\\n\\nFirstly,\\n\\nI know n. Only if I know the value of the number in that was thought of (or rather for which I pay 0$), I can simulate the amount that can give me a guaranteed win? Secondly, it says \"the amount needed for a guaranteed win\". It never says minimum?"
                    },
                    {
                        "username": "shubhamshrishrimal",
                        "content": "Found this very tricky question : \\nhttps://leetcode.com/problems/guess-number-higher-or-lower-ii/\\n\\nMy intiution for the approach was. And then sum up the path from root node to the one node before the leaf node. Now we find the maximum path in the tree. So, if we create a complete bst then this should give the least sum for the right most branch going from root to the leaf node. \\n\\nCan someone help proving mathematically or the intuition why this approach goes wrong. I struggled in trying to prove this mathematically, but could not do it. \\nOr even what is the intuition behind the actual approach that is the dynamic programming based approach."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "1.  I don't quite understand the example.  Why the game is over after I end up paying 21$ ?  The fourth round I would be able to give the correct answer '8' (if I'm not stupid).  Is it because that would not be counted strictly as a \"guess\" any more OR it is because I will be running out of my money? \\n\\n2.  To \"guarantee a win\" , I have to assume the guesser is not that smart . i.e:  he always picks the wrong number until he is able to guess the target correctly.  E.g:  for n =10 , and the target is 8,  he would pick 1, 2,3,4,5,6,7, 10,9 , that sums to 47 already."
                    },
                    {
                        "username": "SR2311",
                        "content": "So lets say You and I hate each other to the core.\\nNow lets say you are the one who is supposed to read my mind and say what number I thought of.\\n\\nMe: I choose a number\\n\\nYou: Begin guessing. (All the best as I am evil will make sure you go down the rabbit hole)\\n\\nYou : Inside your head tell yourself hey you idiot even I am evil and if you will put me down the bad path I will make sure to start off with a number that will cost me minimum no matter what number you pick.\\n\\nEnough of story :P\\n\\nMoral of the story:\\n\\nYou will choose your starting number from [i...j] such that  choosing that  will cost you minimum for the choice  I make [ that is, my pick is the bad branch of your start point in other words I will pick a number that will cost you the most for your start point of all numbers]\\n\\nFor eg [1,2,3,4,5]\\n\\nI am not showing you the calculation\\nfor every start number you pick, lets assume the following\\n1--> I choose 5 why ?it will cost the max of all other choices [Assume it is 20, for rest i.e 4,3,2 it is <20]\\n2--> I choose 3 why i?t will cost the max of all other choices [Assume it is 24, for rest i.e 4,5,1 it is <24]\\n3--> I choose 1 why i?t will cost the max of all other choices [Assume it is 27, for rest i.e 4,5,2 it is <27]]\\n4--> I choose 2 why i?t will cost the max of all other choices [Assume it is 16, for rest i.e 1,3,5 it is <16]\\n5--> I choose 4 why i?t will cost the max of all other choices [Assume it is 18, for rest i.e 1,2,3 it is <18]\\n\\nNote : again I repeat I havent calculated above values it is just a random guess to explain the audience\\n\\nSo of all the above cost you will start of with min of all costs that is 4 as it costs 16\\n\\n\\n"
                    },
                    {
                        "username": "21bcs069",
                        "content": "if you clearly look at the tree then you find this is nothing but of N-ary  tree and you are trying to find height , not exactly same but little difference \\nin max and min function. \\nanswer=min(answer ,i + maximum (a,b)) with a for loop to find  \\nMAXIMUM SPENT WITH IN A GIVEN TREE, BUT \\nMINIMUM OF ALL DIFFERENT  TREE\\'S SPENT."
                    },
                    {
                        "username": "melancholymethane",
                        "content": "This problem is asking:\n1. Pretend to build a BST from {1 .. n}\n2. Sum up the value of non-leaf nodes on each path.\n3. Choose the path with the maximum sum, and denote it as sum1 of BST1.\n4. By adjusting the structure of BST, we will get different sums (sum1, sum2, ..., sumN). What is the minimum possible sum along them?"
                    }
                ]
            },
            {
                "id": 2052517,
                "content": [
                    {
                        "username": "kangroo",
                        "content": "they haven\\'t given any function that will return of it is lower or higher. how are you guys solving this?"
                    },
                    {
                        "username": "ned1m",
                        "content": "Frankly speaking, I don\\'t understand what this question is all about, let alone think of a solution. Before I can think of a solution or understand other people\\'s solution, I need to have a grasp of the question.\\n\\nFor example, if I follow the logic, then for if n = 10, then with $16, I am guaranteed to win.\\n\\nFirst, I pick 7 and you say higher\\nNext I pick 9. If you say higher, I pick 10, if you say lower I pick 8. So I only get to pay $16.\\n\\nAlternatively, If I pick 7 and you say lower\\nNext I pick 3\\nif You say higher, I will pick 5 and game up. I am only paying $15\\nIf you say lower, I pick 1 and game up. I only need to pay $11\\n\\nThis is why it seems confusing to me.\\n\\nedit: I see, the example given confused me.\\n"
                    },
                    {
                        "username": "kakashidinho",
                        "content": "Let say there are 5 numbers, the host picked an unknown number X. The player has to guess a number,\\n- if he guesses number 3, what is the worst case that can happen? the worst case money = max(money needed to win if X is in [1,2] range, money needed to win if X is in range [4,5]). Since if he has worse case money, it doesn\\'t matter if X is in left or right of 3, since he will have enough money to win either case.\\n- Similarly, if he guesses 2, he needs worse case money to win no matter X is in [1] or [3,5] ranges.\\n\\nNote, that he purposely computes the worst case money for every guess in range [1,n] to guarantee a win for every guess. Now the final thing to do, is finding the guess with minimal worst case money. If he chooses that guess and brings its worst case money, he will win the game with minimal cost. This is the best thing he can do."
                    },
                    {
                        "username": "tambourine",
                        "content": "I'm trying to improve so I just joined but for every question I've looked at that involves DP I've been stuck. I can't seem to figure out what the subproblem should be, how it should be modeled in a matrix, how to iterate, and im amazed how other people come up with these solutions (if i can understand the solutions which often i can't.). Is there some trick to coming up with these solutions or do you just have to be smart?"
                    },
                    {
                        "username": "andulas",
                        "content": "Is it just me or is the question confusing?\\n\\nFirstly,\\n\\nI know n. Only if I know the value of the number in that was thought of (or rather for which I pay 0$), I can simulate the amount that can give me a guaranteed win? Secondly, it says \"the amount needed for a guaranteed win\". It never says minimum?"
                    },
                    {
                        "username": "shubhamshrishrimal",
                        "content": "Found this very tricky question : \\nhttps://leetcode.com/problems/guess-number-higher-or-lower-ii/\\n\\nMy intiution for the approach was. And then sum up the path from root node to the one node before the leaf node. Now we find the maximum path in the tree. So, if we create a complete bst then this should give the least sum for the right most branch going from root to the leaf node. \\n\\nCan someone help proving mathematically or the intuition why this approach goes wrong. I struggled in trying to prove this mathematically, but could not do it. \\nOr even what is the intuition behind the actual approach that is the dynamic programming based approach."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "1.  I don't quite understand the example.  Why the game is over after I end up paying 21$ ?  The fourth round I would be able to give the correct answer '8' (if I'm not stupid).  Is it because that would not be counted strictly as a \"guess\" any more OR it is because I will be running out of my money? \\n\\n2.  To \"guarantee a win\" , I have to assume the guesser is not that smart . i.e:  he always picks the wrong number until he is able to guess the target correctly.  E.g:  for n =10 , and the target is 8,  he would pick 1, 2,3,4,5,6,7, 10,9 , that sums to 47 already."
                    },
                    {
                        "username": "SR2311",
                        "content": "So lets say You and I hate each other to the core.\\nNow lets say you are the one who is supposed to read my mind and say what number I thought of.\\n\\nMe: I choose a number\\n\\nYou: Begin guessing. (All the best as I am evil will make sure you go down the rabbit hole)\\n\\nYou : Inside your head tell yourself hey you idiot even I am evil and if you will put me down the bad path I will make sure to start off with a number that will cost me minimum no matter what number you pick.\\n\\nEnough of story :P\\n\\nMoral of the story:\\n\\nYou will choose your starting number from [i...j] such that  choosing that  will cost you minimum for the choice  I make [ that is, my pick is the bad branch of your start point in other words I will pick a number that will cost you the most for your start point of all numbers]\\n\\nFor eg [1,2,3,4,5]\\n\\nI am not showing you the calculation\\nfor every start number you pick, lets assume the following\\n1--> I choose 5 why ?it will cost the max of all other choices [Assume it is 20, for rest i.e 4,3,2 it is <20]\\n2--> I choose 3 why i?t will cost the max of all other choices [Assume it is 24, for rest i.e 4,5,1 it is <24]\\n3--> I choose 1 why i?t will cost the max of all other choices [Assume it is 27, for rest i.e 4,5,2 it is <27]]\\n4--> I choose 2 why i?t will cost the max of all other choices [Assume it is 16, for rest i.e 1,3,5 it is <16]\\n5--> I choose 4 why i?t will cost the max of all other choices [Assume it is 18, for rest i.e 1,2,3 it is <18]\\n\\nNote : again I repeat I havent calculated above values it is just a random guess to explain the audience\\n\\nSo of all the above cost you will start of with min of all costs that is 4 as it costs 16\\n\\n\\n"
                    },
                    {
                        "username": "21bcs069",
                        "content": "if you clearly look at the tree then you find this is nothing but of N-ary  tree and you are trying to find height , not exactly same but little difference \\nin max and min function. \\nanswer=min(answer ,i + maximum (a,b)) with a for loop to find  \\nMAXIMUM SPENT WITH IN A GIVEN TREE, BUT \\nMINIMUM OF ALL DIFFERENT  TREE\\'S SPENT."
                    },
                    {
                        "username": "melancholymethane",
                        "content": "This problem is asking:\n1. Pretend to build a BST from {1 .. n}\n2. Sum up the value of non-leaf nodes on each path.\n3. Choose the path with the maximum sum, and denote it as sum1 of BST1.\n4. By adjusting the structure of BST, we will get different sums (sum1, sum2, ..., sumN). What is the minimum possible sum along them?"
                    }
                ]
            },
            {
                "id": 2018001,
                "content": [
                    {
                        "username": "kangroo",
                        "content": "they haven\\'t given any function that will return of it is lower or higher. how are you guys solving this?"
                    },
                    {
                        "username": "ned1m",
                        "content": "Frankly speaking, I don\\'t understand what this question is all about, let alone think of a solution. Before I can think of a solution or understand other people\\'s solution, I need to have a grasp of the question.\\n\\nFor example, if I follow the logic, then for if n = 10, then with $16, I am guaranteed to win.\\n\\nFirst, I pick 7 and you say higher\\nNext I pick 9. If you say higher, I pick 10, if you say lower I pick 8. So I only get to pay $16.\\n\\nAlternatively, If I pick 7 and you say lower\\nNext I pick 3\\nif You say higher, I will pick 5 and game up. I am only paying $15\\nIf you say lower, I pick 1 and game up. I only need to pay $11\\n\\nThis is why it seems confusing to me.\\n\\nedit: I see, the example given confused me.\\n"
                    },
                    {
                        "username": "kakashidinho",
                        "content": "Let say there are 5 numbers, the host picked an unknown number X. The player has to guess a number,\\n- if he guesses number 3, what is the worst case that can happen? the worst case money = max(money needed to win if X is in [1,2] range, money needed to win if X is in range [4,5]). Since if he has worse case money, it doesn\\'t matter if X is in left or right of 3, since he will have enough money to win either case.\\n- Similarly, if he guesses 2, he needs worse case money to win no matter X is in [1] or [3,5] ranges.\\n\\nNote, that he purposely computes the worst case money for every guess in range [1,n] to guarantee a win for every guess. Now the final thing to do, is finding the guess with minimal worst case money. If he chooses that guess and brings its worst case money, he will win the game with minimal cost. This is the best thing he can do."
                    },
                    {
                        "username": "tambourine",
                        "content": "I'm trying to improve so I just joined but for every question I've looked at that involves DP I've been stuck. I can't seem to figure out what the subproblem should be, how it should be modeled in a matrix, how to iterate, and im amazed how other people come up with these solutions (if i can understand the solutions which often i can't.). Is there some trick to coming up with these solutions or do you just have to be smart?"
                    },
                    {
                        "username": "andulas",
                        "content": "Is it just me or is the question confusing?\\n\\nFirstly,\\n\\nI know n. Only if I know the value of the number in that was thought of (or rather for which I pay 0$), I can simulate the amount that can give me a guaranteed win? Secondly, it says \"the amount needed for a guaranteed win\". It never says minimum?"
                    },
                    {
                        "username": "shubhamshrishrimal",
                        "content": "Found this very tricky question : \\nhttps://leetcode.com/problems/guess-number-higher-or-lower-ii/\\n\\nMy intiution for the approach was. And then sum up the path from root node to the one node before the leaf node. Now we find the maximum path in the tree. So, if we create a complete bst then this should give the least sum for the right most branch going from root to the leaf node. \\n\\nCan someone help proving mathematically or the intuition why this approach goes wrong. I struggled in trying to prove this mathematically, but could not do it. \\nOr even what is the intuition behind the actual approach that is the dynamic programming based approach."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "1.  I don't quite understand the example.  Why the game is over after I end up paying 21$ ?  The fourth round I would be able to give the correct answer '8' (if I'm not stupid).  Is it because that would not be counted strictly as a \"guess\" any more OR it is because I will be running out of my money? \\n\\n2.  To \"guarantee a win\" , I have to assume the guesser is not that smart . i.e:  he always picks the wrong number until he is able to guess the target correctly.  E.g:  for n =10 , and the target is 8,  he would pick 1, 2,3,4,5,6,7, 10,9 , that sums to 47 already."
                    },
                    {
                        "username": "SR2311",
                        "content": "So lets say You and I hate each other to the core.\\nNow lets say you are the one who is supposed to read my mind and say what number I thought of.\\n\\nMe: I choose a number\\n\\nYou: Begin guessing. (All the best as I am evil will make sure you go down the rabbit hole)\\n\\nYou : Inside your head tell yourself hey you idiot even I am evil and if you will put me down the bad path I will make sure to start off with a number that will cost me minimum no matter what number you pick.\\n\\nEnough of story :P\\n\\nMoral of the story:\\n\\nYou will choose your starting number from [i...j] such that  choosing that  will cost you minimum for the choice  I make [ that is, my pick is the bad branch of your start point in other words I will pick a number that will cost you the most for your start point of all numbers]\\n\\nFor eg [1,2,3,4,5]\\n\\nI am not showing you the calculation\\nfor every start number you pick, lets assume the following\\n1--> I choose 5 why ?it will cost the max of all other choices [Assume it is 20, for rest i.e 4,3,2 it is <20]\\n2--> I choose 3 why i?t will cost the max of all other choices [Assume it is 24, for rest i.e 4,5,1 it is <24]\\n3--> I choose 1 why i?t will cost the max of all other choices [Assume it is 27, for rest i.e 4,5,2 it is <27]]\\n4--> I choose 2 why i?t will cost the max of all other choices [Assume it is 16, for rest i.e 1,3,5 it is <16]\\n5--> I choose 4 why i?t will cost the max of all other choices [Assume it is 18, for rest i.e 1,2,3 it is <18]\\n\\nNote : again I repeat I havent calculated above values it is just a random guess to explain the audience\\n\\nSo of all the above cost you will start of with min of all costs that is 4 as it costs 16\\n\\n\\n"
                    },
                    {
                        "username": "21bcs069",
                        "content": "if you clearly look at the tree then you find this is nothing but of N-ary  tree and you are trying to find height , not exactly same but little difference \\nin max and min function. \\nanswer=min(answer ,i + maximum (a,b)) with a for loop to find  \\nMAXIMUM SPENT WITH IN A GIVEN TREE, BUT \\nMINIMUM OF ALL DIFFERENT  TREE\\'S SPENT."
                    },
                    {
                        "username": "melancholymethane",
                        "content": "This problem is asking:\n1. Pretend to build a BST from {1 .. n}\n2. Sum up the value of non-leaf nodes on each path.\n3. Choose the path with the maximum sum, and denote it as sum1 of BST1.\n4. By adjusting the structure of BST, we will get different sums (sum1, sum2, ..., sumN). What is the minimum possible sum along them?"
                    }
                ]
            },
            {
                "id": 2002915,
                "content": [
                    {
                        "username": "yo-mama",
                        "content": "wdym  \"regardless of what number I pick.\" Like I\\'m guessing in all cases? then I have to return an array for each case cuz there is a chance I guess the number on the first try and spend 0 dollars. You\\'ll tell me what the number is but you won\\'t cuz you don\\'t actually have a number. Like wth is this question???\\n\\nSounds like the meme questions you see: \"I weigh 100kg. How fast can I run?\" Dunno man."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "Yes, The user can pick any number between 1 and n .\\nyou have to solve it in a way such that it works for all values in the range.\\nYou might try to solve all cases and return the minimum."
                    },
                    {
                        "username": "JohnZ1107",
                        "content": "Nice question but I didn\\'t figure out until saw the Solutions."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "I tried doing this by using simple maths formula of \\n  =n * log (n) / ( 2 * log (2) )\\ngot this formula by thinking that binary search will go on log n(base 2) times and average penalty would be n/2.\\n\\nIt passed the initial 3 testcase and giving an answer near the actual answer\\n(sometimes by +-1)\\nIs there a way to calculate the answer using simple formula?\\n"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "super egg drop\\n"
                    },
                    {
                        "username": "dash_dash",
                        "content": "is it the most disliked question ever ??"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, i have seen questions with 4k dislikes"
                    },
                    {
                        "username": "tanmaytoshniwal8",
                        "content": "is there any fuction from which we can check that the number we pick is correct or not\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "how to approach these type of questions ??\\n"
                    },
                    {
                        "username": "surYeah",
                        "content": "the problem description sounds like a variation of egg drop problem "
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I saw a solution that beats 100%, he stored all the answer for 1-200 and proudly saying 100% beating solution. Seriously? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\ndp[i][j] = minimum amount of money I need to prepare to guarantee I can win a game, given nums[i:j]\\n```\\n\\nGiven a num 5, which means, there is an array [1, 2, 3, 4, 5]\\n\\nIf I pick 3 at first time, and unfortunately I pick wrong one. Now system will let me know I should guess higher or guess lower\\n-> if system tell me I should guess higher; the best solution for me is always pick up 4 \\n(because even I guess wrong again, I lose 3+4)\\n(but, if I pick 5, and I guess wrong again, I lose 3+5)\\n\\n-> if system tell me I should guess lower; the best solution for me is always pick up 1\\n(because even I guess wrong again, I lose 3+1)\\n(but, if I pick 5, and I guess wrong again, I lose 3+2)\\n\\nBUT!!!!!\\nWe dont know whether system will tell me I should guess higher or guess lower.\\nHence, when I decide to pick up 3 first, I should prepare 7 dollars to guarantee I can always win the game\\n\\n```\\nHence, dp[i][j] = min( dp[i][j], nums[k] + max(dp[i][k-1], dp[k+1][j]) )\\n```"
                    }
                ]
            },
            {
                "id": 1992009,
                "content": [
                    {
                        "username": "yo-mama",
                        "content": "wdym  \"regardless of what number I pick.\" Like I\\'m guessing in all cases? then I have to return an array for each case cuz there is a chance I guess the number on the first try and spend 0 dollars. You\\'ll tell me what the number is but you won\\'t cuz you don\\'t actually have a number. Like wth is this question???\\n\\nSounds like the meme questions you see: \"I weigh 100kg. How fast can I run?\" Dunno man."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "Yes, The user can pick any number between 1 and n .\\nyou have to solve it in a way such that it works for all values in the range.\\nYou might try to solve all cases and return the minimum."
                    },
                    {
                        "username": "JohnZ1107",
                        "content": "Nice question but I didn\\'t figure out until saw the Solutions."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "I tried doing this by using simple maths formula of \\n  =n * log (n) / ( 2 * log (2) )\\ngot this formula by thinking that binary search will go on log n(base 2) times and average penalty would be n/2.\\n\\nIt passed the initial 3 testcase and giving an answer near the actual answer\\n(sometimes by +-1)\\nIs there a way to calculate the answer using simple formula?\\n"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "super egg drop\\n"
                    },
                    {
                        "username": "dash_dash",
                        "content": "is it the most disliked question ever ??"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, i have seen questions with 4k dislikes"
                    },
                    {
                        "username": "tanmaytoshniwal8",
                        "content": "is there any fuction from which we can check that the number we pick is correct or not\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "how to approach these type of questions ??\\n"
                    },
                    {
                        "username": "surYeah",
                        "content": "the problem description sounds like a variation of egg drop problem "
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I saw a solution that beats 100%, he stored all the answer for 1-200 and proudly saying 100% beating solution. Seriously? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\ndp[i][j] = minimum amount of money I need to prepare to guarantee I can win a game, given nums[i:j]\\n```\\n\\nGiven a num 5, which means, there is an array [1, 2, 3, 4, 5]\\n\\nIf I pick 3 at first time, and unfortunately I pick wrong one. Now system will let me know I should guess higher or guess lower\\n-> if system tell me I should guess higher; the best solution for me is always pick up 4 \\n(because even I guess wrong again, I lose 3+4)\\n(but, if I pick 5, and I guess wrong again, I lose 3+5)\\n\\n-> if system tell me I should guess lower; the best solution for me is always pick up 1\\n(because even I guess wrong again, I lose 3+1)\\n(but, if I pick 5, and I guess wrong again, I lose 3+2)\\n\\nBUT!!!!!\\nWe dont know whether system will tell me I should guess higher or guess lower.\\nHence, when I decide to pick up 3 first, I should prepare 7 dollars to guarantee I can always win the game\\n\\n```\\nHence, dp[i][j] = min( dp[i][j], nums[k] + max(dp[i][k-1], dp[k+1][j]) )\\n```"
                    }
                ]
            },
            {
                "id": 1985712,
                "content": [
                    {
                        "username": "yo-mama",
                        "content": "wdym  \"regardless of what number I pick.\" Like I\\'m guessing in all cases? then I have to return an array for each case cuz there is a chance I guess the number on the first try and spend 0 dollars. You\\'ll tell me what the number is but you won\\'t cuz you don\\'t actually have a number. Like wth is this question???\\n\\nSounds like the meme questions you see: \"I weigh 100kg. How fast can I run?\" Dunno man."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "Yes, The user can pick any number between 1 and n .\\nyou have to solve it in a way such that it works for all values in the range.\\nYou might try to solve all cases and return the minimum."
                    },
                    {
                        "username": "JohnZ1107",
                        "content": "Nice question but I didn\\'t figure out until saw the Solutions."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "I tried doing this by using simple maths formula of \\n  =n * log (n) / ( 2 * log (2) )\\ngot this formula by thinking that binary search will go on log n(base 2) times and average penalty would be n/2.\\n\\nIt passed the initial 3 testcase and giving an answer near the actual answer\\n(sometimes by +-1)\\nIs there a way to calculate the answer using simple formula?\\n"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "super egg drop\\n"
                    },
                    {
                        "username": "dash_dash",
                        "content": "is it the most disliked question ever ??"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, i have seen questions with 4k dislikes"
                    },
                    {
                        "username": "tanmaytoshniwal8",
                        "content": "is there any fuction from which we can check that the number we pick is correct or not\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "how to approach these type of questions ??\\n"
                    },
                    {
                        "username": "surYeah",
                        "content": "the problem description sounds like a variation of egg drop problem "
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I saw a solution that beats 100%, he stored all the answer for 1-200 and proudly saying 100% beating solution. Seriously? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\ndp[i][j] = minimum amount of money I need to prepare to guarantee I can win a game, given nums[i:j]\\n```\\n\\nGiven a num 5, which means, there is an array [1, 2, 3, 4, 5]\\n\\nIf I pick 3 at first time, and unfortunately I pick wrong one. Now system will let me know I should guess higher or guess lower\\n-> if system tell me I should guess higher; the best solution for me is always pick up 4 \\n(because even I guess wrong again, I lose 3+4)\\n(but, if I pick 5, and I guess wrong again, I lose 3+5)\\n\\n-> if system tell me I should guess lower; the best solution for me is always pick up 1\\n(because even I guess wrong again, I lose 3+1)\\n(but, if I pick 5, and I guess wrong again, I lose 3+2)\\n\\nBUT!!!!!\\nWe dont know whether system will tell me I should guess higher or guess lower.\\nHence, when I decide to pick up 3 first, I should prepare 7 dollars to guarantee I can always win the game\\n\\n```\\nHence, dp[i][j] = min( dp[i][j], nums[k] + max(dp[i][k-1], dp[k+1][j]) )\\n```"
                    }
                ]
            },
            {
                "id": 1984689,
                "content": [
                    {
                        "username": "yo-mama",
                        "content": "wdym  \"regardless of what number I pick.\" Like I\\'m guessing in all cases? then I have to return an array for each case cuz there is a chance I guess the number on the first try and spend 0 dollars. You\\'ll tell me what the number is but you won\\'t cuz you don\\'t actually have a number. Like wth is this question???\\n\\nSounds like the meme questions you see: \"I weigh 100kg. How fast can I run?\" Dunno man."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "Yes, The user can pick any number between 1 and n .\\nyou have to solve it in a way such that it works for all values in the range.\\nYou might try to solve all cases and return the minimum."
                    },
                    {
                        "username": "JohnZ1107",
                        "content": "Nice question but I didn\\'t figure out until saw the Solutions."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "I tried doing this by using simple maths formula of \\n  =n * log (n) / ( 2 * log (2) )\\ngot this formula by thinking that binary search will go on log n(base 2) times and average penalty would be n/2.\\n\\nIt passed the initial 3 testcase and giving an answer near the actual answer\\n(sometimes by +-1)\\nIs there a way to calculate the answer using simple formula?\\n"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "super egg drop\\n"
                    },
                    {
                        "username": "dash_dash",
                        "content": "is it the most disliked question ever ??"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, i have seen questions with 4k dislikes"
                    },
                    {
                        "username": "tanmaytoshniwal8",
                        "content": "is there any fuction from which we can check that the number we pick is correct or not\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "how to approach these type of questions ??\\n"
                    },
                    {
                        "username": "surYeah",
                        "content": "the problem description sounds like a variation of egg drop problem "
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I saw a solution that beats 100%, he stored all the answer for 1-200 and proudly saying 100% beating solution. Seriously? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\ndp[i][j] = minimum amount of money I need to prepare to guarantee I can win a game, given nums[i:j]\\n```\\n\\nGiven a num 5, which means, there is an array [1, 2, 3, 4, 5]\\n\\nIf I pick 3 at first time, and unfortunately I pick wrong one. Now system will let me know I should guess higher or guess lower\\n-> if system tell me I should guess higher; the best solution for me is always pick up 4 \\n(because even I guess wrong again, I lose 3+4)\\n(but, if I pick 5, and I guess wrong again, I lose 3+5)\\n\\n-> if system tell me I should guess lower; the best solution for me is always pick up 1\\n(because even I guess wrong again, I lose 3+1)\\n(but, if I pick 5, and I guess wrong again, I lose 3+2)\\n\\nBUT!!!!!\\nWe dont know whether system will tell me I should guess higher or guess lower.\\nHence, when I decide to pick up 3 first, I should prepare 7 dollars to guarantee I can always win the game\\n\\n```\\nHence, dp[i][j] = min( dp[i][j], nums[k] + max(dp[i][k-1], dp[k+1][j]) )\\n```"
                    }
                ]
            },
            {
                "id": 1968018,
                "content": [
                    {
                        "username": "yo-mama",
                        "content": "wdym  \"regardless of what number I pick.\" Like I\\'m guessing in all cases? then I have to return an array for each case cuz there is a chance I guess the number on the first try and spend 0 dollars. You\\'ll tell me what the number is but you won\\'t cuz you don\\'t actually have a number. Like wth is this question???\\n\\nSounds like the meme questions you see: \"I weigh 100kg. How fast can I run?\" Dunno man."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "Yes, The user can pick any number between 1 and n .\\nyou have to solve it in a way such that it works for all values in the range.\\nYou might try to solve all cases and return the minimum."
                    },
                    {
                        "username": "JohnZ1107",
                        "content": "Nice question but I didn\\'t figure out until saw the Solutions."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "I tried doing this by using simple maths formula of \\n  =n * log (n) / ( 2 * log (2) )\\ngot this formula by thinking that binary search will go on log n(base 2) times and average penalty would be n/2.\\n\\nIt passed the initial 3 testcase and giving an answer near the actual answer\\n(sometimes by +-1)\\nIs there a way to calculate the answer using simple formula?\\n"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "super egg drop\\n"
                    },
                    {
                        "username": "dash_dash",
                        "content": "is it the most disliked question ever ??"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, i have seen questions with 4k dislikes"
                    },
                    {
                        "username": "tanmaytoshniwal8",
                        "content": "is there any fuction from which we can check that the number we pick is correct or not\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "how to approach these type of questions ??\\n"
                    },
                    {
                        "username": "surYeah",
                        "content": "the problem description sounds like a variation of egg drop problem "
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I saw a solution that beats 100%, he stored all the answer for 1-200 and proudly saying 100% beating solution. Seriously? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\ndp[i][j] = minimum amount of money I need to prepare to guarantee I can win a game, given nums[i:j]\\n```\\n\\nGiven a num 5, which means, there is an array [1, 2, 3, 4, 5]\\n\\nIf I pick 3 at first time, and unfortunately I pick wrong one. Now system will let me know I should guess higher or guess lower\\n-> if system tell me I should guess higher; the best solution for me is always pick up 4 \\n(because even I guess wrong again, I lose 3+4)\\n(but, if I pick 5, and I guess wrong again, I lose 3+5)\\n\\n-> if system tell me I should guess lower; the best solution for me is always pick up 1\\n(because even I guess wrong again, I lose 3+1)\\n(but, if I pick 5, and I guess wrong again, I lose 3+2)\\n\\nBUT!!!!!\\nWe dont know whether system will tell me I should guess higher or guess lower.\\nHence, when I decide to pick up 3 first, I should prepare 7 dollars to guarantee I can always win the game\\n\\n```\\nHence, dp[i][j] = min( dp[i][j], nums[k] + max(dp[i][k-1], dp[k+1][j]) )\\n```"
                    }
                ]
            },
            {
                "id": 1960042,
                "content": [
                    {
                        "username": "yo-mama",
                        "content": "wdym  \"regardless of what number I pick.\" Like I\\'m guessing in all cases? then I have to return an array for each case cuz there is a chance I guess the number on the first try and spend 0 dollars. You\\'ll tell me what the number is but you won\\'t cuz you don\\'t actually have a number. Like wth is this question???\\n\\nSounds like the meme questions you see: \"I weigh 100kg. How fast can I run?\" Dunno man."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "Yes, The user can pick any number between 1 and n .\\nyou have to solve it in a way such that it works for all values in the range.\\nYou might try to solve all cases and return the minimum."
                    },
                    {
                        "username": "JohnZ1107",
                        "content": "Nice question but I didn\\'t figure out until saw the Solutions."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "I tried doing this by using simple maths formula of \\n  =n * log (n) / ( 2 * log (2) )\\ngot this formula by thinking that binary search will go on log n(base 2) times and average penalty would be n/2.\\n\\nIt passed the initial 3 testcase and giving an answer near the actual answer\\n(sometimes by +-1)\\nIs there a way to calculate the answer using simple formula?\\n"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "super egg drop\\n"
                    },
                    {
                        "username": "dash_dash",
                        "content": "is it the most disliked question ever ??"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, i have seen questions with 4k dislikes"
                    },
                    {
                        "username": "tanmaytoshniwal8",
                        "content": "is there any fuction from which we can check that the number we pick is correct or not\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "how to approach these type of questions ??\\n"
                    },
                    {
                        "username": "surYeah",
                        "content": "the problem description sounds like a variation of egg drop problem "
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I saw a solution that beats 100%, he stored all the answer for 1-200 and proudly saying 100% beating solution. Seriously? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\ndp[i][j] = minimum amount of money I need to prepare to guarantee I can win a game, given nums[i:j]\\n```\\n\\nGiven a num 5, which means, there is an array [1, 2, 3, 4, 5]\\n\\nIf I pick 3 at first time, and unfortunately I pick wrong one. Now system will let me know I should guess higher or guess lower\\n-> if system tell me I should guess higher; the best solution for me is always pick up 4 \\n(because even I guess wrong again, I lose 3+4)\\n(but, if I pick 5, and I guess wrong again, I lose 3+5)\\n\\n-> if system tell me I should guess lower; the best solution for me is always pick up 1\\n(because even I guess wrong again, I lose 3+1)\\n(but, if I pick 5, and I guess wrong again, I lose 3+2)\\n\\nBUT!!!!!\\nWe dont know whether system will tell me I should guess higher or guess lower.\\nHence, when I decide to pick up 3 first, I should prepare 7 dollars to guarantee I can always win the game\\n\\n```\\nHence, dp[i][j] = min( dp[i][j], nums[k] + max(dp[i][k-1], dp[k+1][j]) )\\n```"
                    }
                ]
            },
            {
                "id": 1950352,
                "content": [
                    {
                        "username": "yo-mama",
                        "content": "wdym  \"regardless of what number I pick.\" Like I\\'m guessing in all cases? then I have to return an array for each case cuz there is a chance I guess the number on the first try and spend 0 dollars. You\\'ll tell me what the number is but you won\\'t cuz you don\\'t actually have a number. Like wth is this question???\\n\\nSounds like the meme questions you see: \"I weigh 100kg. How fast can I run?\" Dunno man."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "Yes, The user can pick any number between 1 and n .\\nyou have to solve it in a way such that it works for all values in the range.\\nYou might try to solve all cases and return the minimum."
                    },
                    {
                        "username": "JohnZ1107",
                        "content": "Nice question but I didn\\'t figure out until saw the Solutions."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "I tried doing this by using simple maths formula of \\n  =n * log (n) / ( 2 * log (2) )\\ngot this formula by thinking that binary search will go on log n(base 2) times and average penalty would be n/2.\\n\\nIt passed the initial 3 testcase and giving an answer near the actual answer\\n(sometimes by +-1)\\nIs there a way to calculate the answer using simple formula?\\n"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "super egg drop\\n"
                    },
                    {
                        "username": "dash_dash",
                        "content": "is it the most disliked question ever ??"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, i have seen questions with 4k dislikes"
                    },
                    {
                        "username": "tanmaytoshniwal8",
                        "content": "is there any fuction from which we can check that the number we pick is correct or not\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "how to approach these type of questions ??\\n"
                    },
                    {
                        "username": "surYeah",
                        "content": "the problem description sounds like a variation of egg drop problem "
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I saw a solution that beats 100%, he stored all the answer for 1-200 and proudly saying 100% beating solution. Seriously? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\ndp[i][j] = minimum amount of money I need to prepare to guarantee I can win a game, given nums[i:j]\\n```\\n\\nGiven a num 5, which means, there is an array [1, 2, 3, 4, 5]\\n\\nIf I pick 3 at first time, and unfortunately I pick wrong one. Now system will let me know I should guess higher or guess lower\\n-> if system tell me I should guess higher; the best solution for me is always pick up 4 \\n(because even I guess wrong again, I lose 3+4)\\n(but, if I pick 5, and I guess wrong again, I lose 3+5)\\n\\n-> if system tell me I should guess lower; the best solution for me is always pick up 1\\n(because even I guess wrong again, I lose 3+1)\\n(but, if I pick 5, and I guess wrong again, I lose 3+2)\\n\\nBUT!!!!!\\nWe dont know whether system will tell me I should guess higher or guess lower.\\nHence, when I decide to pick up 3 first, I should prepare 7 dollars to guarantee I can always win the game\\n\\n```\\nHence, dp[i][j] = min( dp[i][j], nums[k] + max(dp[i][k-1], dp[k+1][j]) )\\n```"
                    }
                ]
            },
            {
                "id": 1945649,
                "content": [
                    {
                        "username": "yo-mama",
                        "content": "wdym  \"regardless of what number I pick.\" Like I\\'m guessing in all cases? then I have to return an array for each case cuz there is a chance I guess the number on the first try and spend 0 dollars. You\\'ll tell me what the number is but you won\\'t cuz you don\\'t actually have a number. Like wth is this question???\\n\\nSounds like the meme questions you see: \"I weigh 100kg. How fast can I run?\" Dunno man."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "Yes, The user can pick any number between 1 and n .\\nyou have to solve it in a way such that it works for all values in the range.\\nYou might try to solve all cases and return the minimum."
                    },
                    {
                        "username": "JohnZ1107",
                        "content": "Nice question but I didn\\'t figure out until saw the Solutions."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "I tried doing this by using simple maths formula of \\n  =n * log (n) / ( 2 * log (2) )\\ngot this formula by thinking that binary search will go on log n(base 2) times and average penalty would be n/2.\\n\\nIt passed the initial 3 testcase and giving an answer near the actual answer\\n(sometimes by +-1)\\nIs there a way to calculate the answer using simple formula?\\n"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "super egg drop\\n"
                    },
                    {
                        "username": "dash_dash",
                        "content": "is it the most disliked question ever ??"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, i have seen questions with 4k dislikes"
                    },
                    {
                        "username": "tanmaytoshniwal8",
                        "content": "is there any fuction from which we can check that the number we pick is correct or not\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "how to approach these type of questions ??\\n"
                    },
                    {
                        "username": "surYeah",
                        "content": "the problem description sounds like a variation of egg drop problem "
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I saw a solution that beats 100%, he stored all the answer for 1-200 and proudly saying 100% beating solution. Seriously? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\ndp[i][j] = minimum amount of money I need to prepare to guarantee I can win a game, given nums[i:j]\\n```\\n\\nGiven a num 5, which means, there is an array [1, 2, 3, 4, 5]\\n\\nIf I pick 3 at first time, and unfortunately I pick wrong one. Now system will let me know I should guess higher or guess lower\\n-> if system tell me I should guess higher; the best solution for me is always pick up 4 \\n(because even I guess wrong again, I lose 3+4)\\n(but, if I pick 5, and I guess wrong again, I lose 3+5)\\n\\n-> if system tell me I should guess lower; the best solution for me is always pick up 1\\n(because even I guess wrong again, I lose 3+1)\\n(but, if I pick 5, and I guess wrong again, I lose 3+2)\\n\\nBUT!!!!!\\nWe dont know whether system will tell me I should guess higher or guess lower.\\nHence, when I decide to pick up 3 first, I should prepare 7 dollars to guarantee I can always win the game\\n\\n```\\nHence, dp[i][j] = min( dp[i][j], nums[k] + max(dp[i][k-1], dp[k+1][j]) )\\n```"
                    }
                ]
            },
            {
                "id": 1922054,
                "content": [
                    {
                        "username": "yo-mama",
                        "content": "wdym  \"regardless of what number I pick.\" Like I\\'m guessing in all cases? then I have to return an array for each case cuz there is a chance I guess the number on the first try and spend 0 dollars. You\\'ll tell me what the number is but you won\\'t cuz you don\\'t actually have a number. Like wth is this question???\\n\\nSounds like the meme questions you see: \"I weigh 100kg. How fast can I run?\" Dunno man."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "Yes, The user can pick any number between 1 and n .\\nyou have to solve it in a way such that it works for all values in the range.\\nYou might try to solve all cases and return the minimum."
                    },
                    {
                        "username": "JohnZ1107",
                        "content": "Nice question but I didn\\'t figure out until saw the Solutions."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "I tried doing this by using simple maths formula of \\n  =n * log (n) / ( 2 * log (2) )\\ngot this formula by thinking that binary search will go on log n(base 2) times and average penalty would be n/2.\\n\\nIt passed the initial 3 testcase and giving an answer near the actual answer\\n(sometimes by +-1)\\nIs there a way to calculate the answer using simple formula?\\n"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "super egg drop\\n"
                    },
                    {
                        "username": "dash_dash",
                        "content": "is it the most disliked question ever ??"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, i have seen questions with 4k dislikes"
                    },
                    {
                        "username": "tanmaytoshniwal8",
                        "content": "is there any fuction from which we can check that the number we pick is correct or not\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "how to approach these type of questions ??\\n"
                    },
                    {
                        "username": "surYeah",
                        "content": "the problem description sounds like a variation of egg drop problem "
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I saw a solution that beats 100%, he stored all the answer for 1-200 and proudly saying 100% beating solution. Seriously? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\ndp[i][j] = minimum amount of money I need to prepare to guarantee I can win a game, given nums[i:j]\\n```\\n\\nGiven a num 5, which means, there is an array [1, 2, 3, 4, 5]\\n\\nIf I pick 3 at first time, and unfortunately I pick wrong one. Now system will let me know I should guess higher or guess lower\\n-> if system tell me I should guess higher; the best solution for me is always pick up 4 \\n(because even I guess wrong again, I lose 3+4)\\n(but, if I pick 5, and I guess wrong again, I lose 3+5)\\n\\n-> if system tell me I should guess lower; the best solution for me is always pick up 1\\n(because even I guess wrong again, I lose 3+1)\\n(but, if I pick 5, and I guess wrong again, I lose 3+2)\\n\\nBUT!!!!!\\nWe dont know whether system will tell me I should guess higher or guess lower.\\nHence, when I decide to pick up 3 first, I should prepare 7 dollars to guarantee I can always win the game\\n\\n```\\nHence, dp[i][j] = min( dp[i][j], nums[k] + max(dp[i][k-1], dp[k+1][j]) )\\n```"
                    }
                ]
            },
            {
                "id": 1919273,
                "content": [
                    {
                        "username": "yo-mama",
                        "content": "wdym  \"regardless of what number I pick.\" Like I\\'m guessing in all cases? then I have to return an array for each case cuz there is a chance I guess the number on the first try and spend 0 dollars. You\\'ll tell me what the number is but you won\\'t cuz you don\\'t actually have a number. Like wth is this question???\\n\\nSounds like the meme questions you see: \"I weigh 100kg. How fast can I run?\" Dunno man."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "Yes, The user can pick any number between 1 and n .\\nyou have to solve it in a way such that it works for all values in the range.\\nYou might try to solve all cases and return the minimum."
                    },
                    {
                        "username": "JohnZ1107",
                        "content": "Nice question but I didn\\'t figure out until saw the Solutions."
                    },
                    {
                        "username": "sridhartuli",
                        "content": "I tried doing this by using simple maths formula of \\n  =n * log (n) / ( 2 * log (2) )\\ngot this formula by thinking that binary search will go on log n(base 2) times and average penalty would be n/2.\\n\\nIt passed the initial 3 testcase and giving an answer near the actual answer\\n(sometimes by +-1)\\nIs there a way to calculate the answer using simple formula?\\n"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "super egg drop\\n"
                    },
                    {
                        "username": "dash_dash",
                        "content": "is it the most disliked question ever ??"
                    },
                    {
                        "username": "niteshsaxena03",
                        "content": "nah, i have seen questions with 4k dislikes"
                    },
                    {
                        "username": "tanmaytoshniwal8",
                        "content": "is there any fuction from which we can check that the number we pick is correct or not\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "how to approach these type of questions ??\\n"
                    },
                    {
                        "username": "surYeah",
                        "content": "the problem description sounds like a variation of egg drop problem "
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "I saw a solution that beats 100%, he stored all the answer for 1-200 and proudly saying 100% beating solution. Seriously? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "```\\ndp[i][j] = minimum amount of money I need to prepare to guarantee I can win a game, given nums[i:j]\\n```\\n\\nGiven a num 5, which means, there is an array [1, 2, 3, 4, 5]\\n\\nIf I pick 3 at first time, and unfortunately I pick wrong one. Now system will let me know I should guess higher or guess lower\\n-> if system tell me I should guess higher; the best solution for me is always pick up 4 \\n(because even I guess wrong again, I lose 3+4)\\n(but, if I pick 5, and I guess wrong again, I lose 3+5)\\n\\n-> if system tell me I should guess lower; the best solution for me is always pick up 1\\n(because even I guess wrong again, I lose 3+1)\\n(but, if I pick 5, and I guess wrong again, I lose 3+2)\\n\\nBUT!!!!!\\nWe dont know whether system will tell me I should guess higher or guess lower.\\nHence, when I decide to pick up 3 first, I should prepare 7 dollars to guarantee I can always win the game\\n\\n```\\nHence, dp[i][j] = min( dp[i][j], nums[k] + max(dp[i][k-1], dp[k+1][j]) )\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Heaters",
        "question_content": "<p>Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.</p>\n\n<p>Every house can be warmed, as long as the house is within the heater&#39;s warm radius range.&nbsp;</p>\n\n<p>Given the positions of <code>houses</code> and <code>heaters</code> on a horizontal line, return <em>the minimum radius standard of heaters&nbsp;so that those heaters could cover all houses.</em></p>\n\n<p><strong>Notice</strong> that&nbsp;all the <code>heaters</code> follow your radius standard, and the warm radius will the same.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> houses = [1,2,3], heaters = [2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> houses = [1,2,3,4], heaters = [1,4]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The two heaters were placed at positions 1 and 4. We need to use a radius 1 standard, then all the houses can be warmed.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> houses = [1,5], heaters = [2]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= houses.length, heaters.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= houses[i], heaters[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 95887,
                "title": "c-clean-solution-with-explanation",
                "content": "Sorting is `O(n log n)`. The rest is `O(n)`. \\nHere, `A = houses` and `H = heaters`.\\n```\\nclass Solution {\\npublic:\\n/*\\nExample:    h = house,  * = heater  M = INT_MAX\\n\\n        h   h   h   h   h   h   h   h   h    houses\\n        1   2   3   4   5   6   7   8   9    index\\n        *           *       *                heaters\\n                \\n        0   2   1   0   1   0   -   -   -    (distance to nearest RHS heater)\\n        0   1   2   0   1   0   1   2   3    (distance to nearest LHS heater)\\n\\n        0   1   1   0   1   0   1   2   3    (res = minimum of above two)\\n\\nResult is maximum value in res, which is 3.\\n*/\\n    int findRadius(vector<int>& A, vector<int>& H) {\\n        sort(A.begin(), A.end());\\n        sort(H.begin(), H.end());\\n        vector<int> res(A.size(), INT_MAX); \\n        \\n        // For each house, calculate distance to nearest RHS heater\\n        for (int i = 0, h = 0; i < A.size() && h < H.size(); ) {\\n            if (A[i] <= H[h]) { res[i] = H[h] - A[i]; i++; }\\n            else { h++; }\\n        }\\n        \\n        // For each house, calculate distance to nearest LHS heater\\n        for (int i = A.size()-1, h = H.size()-1; i >= 0 && h >= 0; ) {\\n            if (A[i] >= H[h]) { res[i] = min(res[i], A[i] - H[h]); i--; }\\n            else { h--; }\\n        }\\n       \\n        return *max_element(res.begin(), res.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\nExample:    h = house,  * = heater  M = INT_MAX\\n\\n        h   h   h   h   h   h   h   h   h    houses\\n        1   2   3   4   5   6   7   8   9    index\\n        *           *       *                heaters\\n                \\n        0   2   1   0   1   0   -   -   -    (distance to nearest RHS heater)\\n        0   1   2   0   1   0   1   2   3    (distance to nearest LHS heater)\\n\\n        0   1   1   0   1   0   1   2   3    (res = minimum of above two)\\n\\nResult is maximum value in res, which is 3.\\n*/\\n    int findRadius(vector<int>& A, vector<int>& H) {\\n        sort(A.begin(), A.end());\\n        sort(H.begin(), H.end());\\n        vector<int> res(A.size(), INT_MAX); \\n        \\n        // For each house, calculate distance to nearest RHS heater\\n        for (int i = 0, h = 0; i < A.size() && h < H.size(); ) {\\n            if (A[i] <= H[h]) { res[i] = H[h] - A[i]; i++; }\\n            else { h++; }\\n        }\\n        \\n        // For each house, calculate distance to nearest LHS heater\\n        for (int i = A.size()-1, h = H.size()-1; i >= 0 && h >= 0; ) {\\n            if (A[i] >= H[h]) { res[i] = min(res[i], A[i] - H[h]); i--; }\\n            else { h--; }\\n        }\\n       \\n        return *max_element(res.begin(), res.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95886,
                "title": "short-and-clean-java-binary-search-solution",
                "content": "The idea is to leverage decent ```Arrays.binarySearch()``` function provided by Java.\\n1. For each ```house```, find its position between those ```heaters``` (thus we need the ```heaters``` array to be sorted). \\n2. Calculate the distances between this ```house``` and left ```heater``` and right ```heater```, get a ```MIN``` value of those two values. Corner cases are there is no left or right heater.\\n3. Get ```MAX``` value among distances in step 2. It's the answer.\\n\\nTime complexity: max(O(nlogn), O(mlogn)) - m is the length of houses, n is the length of heaters.\\n\\n```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        int result = Integer.MIN_VALUE;\\n        \\n        for (int house : houses) {\\n            int index = Arrays.binarySearch(heaters, house);\\n            if (index < 0) {\\n        \\tindex = -(index + 1);\\n            }\\n            int dist1 = index - 1 >= 0 ? house - heaters[index - 1] : Integer.MAX_VALUE;\\n            int dist2 = index < heaters.length ? heaters[index] - house : Integer.MAX_VALUE;\\n        \\n            result = Math.max(result, Math.min(dist1, dist2));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Arrays.binarySearch()```\n```house```\n```heaters```\n```heaters```\n```house```\n```heater```\n```heater```\n```MIN```\n```MAX```\n```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        int result = Integer.MIN_VALUE;\\n        \\n        for (int house : houses) {\\n            int index = Arrays.binarySearch(heaters, house);\\n            if (index < 0) {\\n        \\tindex = -(index + 1);\\n            }\\n            int dist1 = index - 1 >= 0 ? house - heaters[index - 1] : Integer.MAX_VALUE;\\n            int dist2 = index < heaters.length ? heaters[index] - house : Integer.MAX_VALUE;\\n        \\n            result = Math.max(result, Math.min(dist1, dist2));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95881,
                "title": "simple-java-solution-with-2-pointers",
                "content": "Based on 2 pointers, the idea is to find the nearest heater for each house, by comparing the next heater with the current heater.\\n```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        int i = 0, j = 0, res = 0;\\n        while (i < houses.length) {\\n            while (j < heaters.length - 1\\n                && Math.abs(heaters[j + 1] - houses[i]) <= Math.abs(heaters[j] - houses[i])) {\\n                j++;\\n            }\\n            res = Math.max(res, Math.abs(heaters[j] - houses[i]));\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nUpdated solution inspired by @StefanPochmann \\n```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        int i = 0, res = 0;\\n        for (int house : houses) {\\n            while (i < heaters.length - 1 && heaters[i] + heaters[i + 1] <= house * 2) {\\n                i++;\\n            }\\n            res = Math.max(res, Math.abs(heaters[i] - house));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        int i = 0, j = 0, res = 0;\\n        while (i < houses.length) {\\n            while (j < heaters.length - 1\\n                && Math.abs(heaters[j + 1] - houses[i]) <= Math.abs(heaters[j] - houses[i])) {\\n                j++;\\n            }\\n            res = Math.max(res, Math.abs(heaters[j] - houses[i]));\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        int i = 0, res = 0;\\n        for (int house : houses) {\\n            while (i < heaters.length - 1 && heaters[i] + heaters[i + 1] <= house * 2) {\\n                i++;\\n            }\\n            res = Math.max(res, Math.abs(heaters[i] - house));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95875,
                "title": "short-python",
                "content": "Go through houses and heaters in ascending order. My `i` points to the current closest heater. Go to the next heater if the current house coordinate is larger than or equal to the middle between the current and the next heater.\\n\\n    def findRadius(self, houses, heaters):\\n        heaters = sorted(heaters) + [float('inf')]\\n        i = r = 0\\n        for x in sorted(houses):\\n            while x >= sum(heaters[i:i+2]) / 2.:\\n                i += 1\\n            r = max(r, abs(heaters[i] - x))\\n        return r\\n\\nI btw started with\\n&nbsp;&nbsp;&nbsp;&nbsp;`while abs(heaters[i+1] - x) <= abs(heaters[i] - x):`,\\nthe straight-forward check whether the next heater is closer than the current. Then I thought I probably don't need `abs` if I just use\\n&nbsp;&nbsp;&nbsp;&nbsp;`while heaters[i+1] - x <= x - heaters[i]:`.\\nThat's obviously correct if `x` is between the heaters, because then that's the correct distances of `x` to the two heaters. Less obviously (but imho not surprisingly) it's also correct if `x` isn't between them. Finally, after rewriting it to\\n&nbsp;&nbsp;&nbsp;&nbsp;`while heaters[i] + heaters[i+1] <= 2 * x:`\\nI realized what that meant :-)\\n\\n---\\nUpdate: Another solution by using binary search, inspired by others:\\n\\n    def findRadius(self, houses, heaters):\\n        heaters.sort()\\n        return max(min(abs(house - heater)\\n                       for i in [bisect.bisect(heaters, house)]\\n                       for heater in heaters[i-(i>0):i+1])\\n                   for house in houses)",
                "solutionTags": [],
                "code": "Go through houses and heaters in ascending order. My `i` points to the current closest heater. Go to the next heater if the current house coordinate is larger than or equal to the middle between the current and the next heater.\\n\\n    def findRadius(self, houses, heaters):\\n        heaters = sorted(heaters) + [float('inf')]\\n        i = r = 0\\n        for x in sorted(houses):\\n            while x >= sum(heaters[i:i+2]) / 2.:\\n                i += 1\\n            r = max(r, abs(heaters[i] - x))\\n        return r\\n\\nI btw started with\\n&nbsp;&nbsp;&nbsp;&nbsp;`while abs(heaters[i+1] - x) <= abs(heaters[i] - x):`,\\nthe straight-forward check whether the next heater is closer than the current. Then I thought I probably don't need `abs` if I just use\\n&nbsp;&nbsp;&nbsp;&nbsp;`while heaters[i+1] - x <= x - heaters[i]:`.\\nThat's obviously correct if `x` is between the heaters, because then that's the correct distances of `x` to the two heaters. Less obviously (but imho not surprisingly) it's also correct if `x` isn't between them. Finally, after rewriting it to\\n&nbsp;&nbsp;&nbsp;&nbsp;`while heaters[i] + heaters[i+1] <= 2 * x:`\\nI realized what that meant :-)\\n\\n---\\nUpdate: Another solution by using binary search, inspired by others:\\n\\n    def findRadius(self, houses, heaters):\\n        heaters.sort()\\n        return max(min(abs(house - heater)\\n                       for i in [bisect.bisect(heaters, house)]\\n                       for heater in heaters[i-(i>0):i+1])\\n                   for house in houses)",
                "codeTag": "Python3"
            },
            {
                "id": 95878,
                "title": "10-lines-python-with-easy-understanding",
                "content": "Add two imaginary heaters at the infinite, then any house can be always between two heaters. Find the shortest distance of the two and compare it to the answer.\\n\\n``` python\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        houses.sort()\\n        heaters.sort()\\n        heaters=[float('-inf')]+heaters+[float('inf')] # add 2 fake heaters\\n        ans,i = 0,0\\n        for house in houses:\\n            while house > heaters[i+1]:  # search to put house between heaters\\n                i +=1\\n            dis = min (house - heaters[i], heaters[i+1]- house)\\n            ans = max(ans, dis)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        houses.sort()\\n        heaters.sort()\\n        heaters=[float('-inf')]+heaters+[float('inf')] # add 2 fake heaters\\n        ans,i = 0,0\\n        for house in houses:\\n            while house > heaters[i+1]:  # search to put house between heaters\\n                i +=1\\n            dis = min (house - heaters[i], heaters[i+1]- house)\\n            ans = max(ans, dis)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95928,
                "title": "java-treeset-log-n-solution-with-explanation",
                "content": "Initially I was trying TreeSet  as it provides easier way to find the lowerBound and upperBound. While I mistakenly reversed the min and max relationship when updating the global min radius result. Thanks to @ckcz123 's solution and I realized my error and made it right. \\nThe idea using TreeSet is first put heaters' location into the tree, then iterate the houses' location finding the smallest radius with which one of the closest heaters may cover. Say heaters[1, 4] , houses[1,2,3,4]. When we scan the house = 1, found closest heater is at 1, so the global max till house at 1 is 0; then when house = 2, found the closest heater is min(house at 2 - heater at 1, heater at 4 - house at 2) = 1, which means the heater at 1 can cover the house at 2 and we do not need to use heater at 4. In the end, we may found the global res (min radius required) and remember that some of the heaters may not be effectively used as long as all the houses are already covered. O(logn) for TreeSet operations in this solution, but need O(heater) space which is not as good as binary search solution.\\n```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        TreeSet<Integer> treeset = new TreeSet<>();\\n        for (int heater : heaters) treeset.add(heater);\\n        int res = 0;\\n        for (int house : houses) {\\n            Integer upper = treeset.ceiling(house); \\n            Integer lower = treeset.floor(house);\\n            res = Math.max(res, Math.min(upper == null ? Integer.MAX_VALUE : upper - house, lower == null ? Integer.MAX_VALUE : house - lower));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        TreeSet<Integer> treeset = new TreeSet<>();\\n        for (int heater : heaters) treeset.add(heater);\\n        int res = 0;\\n        for (int house : houses) {\\n            Integer upper = treeset.ceiling(house); \\n            Integer lower = treeset.floor(house);\\n            res = Math.max(res, Math.min(upper == null ? Integer.MAX_VALUE : upper - house, lower == null ? Integer.MAX_VALUE : house - lower));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95909,
                "title": "c-solution-using-lower-bound-binary-search-with-comments",
                "content": "```\\nint findRadius(vector<int>& houses, vector<int>& heaters) {\\n    sort(heaters.begin(), heaters.end());\\n    int minRadius = 0;\\n    for (int i = 0; i < houses.size(); i++) {\\n    \\t// search for the closest heater whose position is at least the current house's position\\n    \\tauto larger = lower_bound(heaters.begin(), heaters.end(), houses[i]);\\n    \\tint curRadius = INT_MAX;\\n    \\t// if there is such a heater, update the radius for that heater to cover this house if necessary\\n    \\tif (larger != heaters.end())\\n    \\t    curRadius = *larger - houses[i];\\n    \\t// if the heater we found is not the first one, then the previous heater is the closest heater\\n    \\t// whose position is smaller than the current house's position\\n    \\tif (larger != heaters.begin()) {\\n    \\t    auto smaller = larger - 1;\\n    \\t   // the heater with the smaller required radius to cover the house wins\\n    \\t    curRadius = min(curRadius, houses[i] - *smaller);\\n    \\t}\\n    \\tminRadius = max(minRadius, curRadius);\\n    }\\n    return minRadius;\\n}\\n```\\nEdit: As @rui-guo-180 points out, some test cases were introduced to fail this kind of solution (I have tried to sort the houses and then optimize the binary search range and it didn't help). The weird thing is, the exact same algorithm written in Java can still pass.",
                "solutionTags": [],
                "code": "```\\nint findRadius(vector<int>& houses, vector<int>& heaters) {\\n    sort(heaters.begin(), heaters.end());\\n    int minRadius = 0;\\n    for (int i = 0; i < houses.size(); i++) {\\n    \\t// search for the closest heater whose position is at least the current house's position\\n    \\tauto larger = lower_bound(heaters.begin(), heaters.end(), houses[i]);\\n    \\tint curRadius = INT_MAX;\\n    \\t// if there is such a heater, update the radius for that heater to cover this house if necessary\\n    \\tif (larger != heaters.end())\\n    \\t    curRadius = *larger - houses[i];\\n    \\t// if the heater we found is not the first one, then the previous heater is the closest heater\\n    \\t// whose position is smaller than the current house's position\\n    \\tif (larger != heaters.begin()) {\\n    \\t    auto smaller = larger - 1;\\n    \\t   // the heater with the smaller required radius to cover the house wins\\n    \\t    curRadius = min(curRadius, houses[i] - *smaller);\\n    \\t}\\n    \\tminRadius = max(minRadius, curRadius);\\n    }\\n    return minRadius;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151808,
                "title": "python-easy-to-understand-bisect-solution",
                "content": "```\\nclass Solution:\\n    def findRadius(self, houses, heaters):\\n        heaters.sort()\\n        r = 0\\n        for h in houses:\\n            ind = bisect.bisect_left(heaters, h)\\n            if ind == len(heaters):\\n                r = max(r, h - heaters[-1])\\n            elif ind == 0:\\n                r = max(r, heaters[0] - h)\\n            else:\\n                r = max(r, min(heaters[ind] - h, h - heaters[ind - 1]))\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses, heaters):\\n        heaters.sort()\\n        r = 0\\n        for h in houses:\\n            ind = bisect.bisect_left(heaters, h)\\n            if ind == len(heaters):\\n                r = max(r, h - heaters[-1])\\n            elif ind == 0:\\n                r = max(r, heaters[0] - h)\\n            else:\\n                r = max(r, min(heaters[ind] - h, h - heaters[ind - 1]))\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666843,
                "title": "c-binary-search-easy-with-explained-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool blackBox(vector<int>& houses, vector<int>& heaters, int n, int m, int radius){\\n        int i=0, j=0; //2 pointers\\n        \\n        while(i<n){\\n            if(j == m){ \\n                return false;//coz we have no heater left to cover rest of the houses, so this cant be answer\\n            }\\n            \\n            int l = heaters[j] - radius; //get the left range\\n            int r = heaters[j] + radius; //get the right range\\n            if(houses[i] < l or houses[i] > r){\\n                j++; //if current house is not in the range, check with next heater\\n            }\\n            else{\\n                i++; //if current heater can cover the current house then check for the next house\\n            }\\n        }\\n        \\n        return true; //if i==n states that we are able to cover all the houses with a given number of heater(can be 1 or all) so this mid as radiuse can be one answer\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        \\n        int n = houses.size();\\n        int m = heaters.size();\\n        \\n        int low = 0; //cann\\'t define as 1, coz there will be a case where all the heaters will be at all the houses resp.\\n        int high = max(*max_element(houses.begin(),houses.end()),*max_element(heaters.begin(),heaters.end())); //to reduce search space, will also work if defined as 1e9\\n        \\n        int ans = 0;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            cout<<mid<<endl;\\n            if(blackBox(houses,heaters,n,m,mid)==true){ //called the blackbox to find that is it possible for current radius to be the ans\\n                ans = mid;\\n                high = mid - 1; //to minimise the ans;\\n            }\\n            else{\\n                low = mid + 1; //go to the right coz this mid can\\'t be one answer;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool blackBox(vector<int>& houses, vector<int>& heaters, int n, int m, int radius){\\n        int i=0, j=0; //2 pointers\\n        \\n        while(i<n){\\n            if(j == m){ \\n                return false;//coz we have no heater left to cover rest of the houses, so this cant be answer\\n            }\\n            \\n            int l = heaters[j] - radius; //get the left range\\n            int r = heaters[j] + radius; //get the right range\\n            if(houses[i] < l or houses[i] > r){\\n                j++; //if current house is not in the range, check with next heater\\n            }\\n            else{\\n                i++; //if current heater can cover the current house then check for the next house\\n            }\\n        }\\n        \\n        return true; //if i==n states that we are able to cover all the houses with a given number of heater(can be 1 or all) so this mid as radiuse can be one answer\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        \\n        int n = houses.size();\\n        int m = heaters.size();\\n        \\n        int low = 0; //cann\\'t define as 1, coz there will be a case where all the heaters will be at all the houses resp.\\n        int high = max(*max_element(houses.begin(),houses.end()),*max_element(heaters.begin(),heaters.end())); //to reduce search space, will also work if defined as 1e9\\n        \\n        int ans = 0;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            cout<<mid<<endl;\\n            if(blackBox(houses,heaters,n,m,mid)==true){ //called the blackbox to find that is it possible for current radius to be the ans\\n                ans = mid;\\n                high = mid - 1; //to minimise the ans;\\n            }\\n            else{\\n                low = mid + 1; //go to the right coz this mid can\\'t be one answer;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 95889,
                "title": "simple-c-solution",
                "content": "Simple idea, sort and then iterate to the nearest point, not too much conor cases\\n```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        if (heaters.size() == 0) {\\n            return 0;\\n        }\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        int radius = 0;\\n        int index = 0;\\n        for (int i = 0; i < houses.size(); i++) {\\n            while (index + 1 < heaters.size() && (abs(heaters[index+1] - houses[i]) <= abs(heaters[index] - houses[i]))) {\\n                index++;\\n            }\\n            radius = max(radius, abs(heaters[index] - houses[i]));\\n        }\\n        return radius;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        if (heaters.size() == 0) {\\n            return 0;\\n        }\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        int radius = 0;\\n        int index = 0;\\n        for (int i = 0; i < houses.size(); i++) {\\n            while (index + 1 < heaters.size() && (abs(heaters[index+1] - houses[i]) <= abs(heaters[index] - houses[i]))) {\\n                index++;\\n            }\\n            radius = max(radius, abs(heaters[index] - houses[i]));\\n        }\\n        return radius;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562372,
                "title": "python-99-7-explained-in-details-with-tips",
                "content": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        \\n        houses=sorted(houses)\\n        heaters=sorted(heaters)\\n        \\n        heaters = heaters + [float(\\'inf\\')]\\n        i1,i2,r = 0,1,0\\n\\n        for h in houses:\\n            while h >= heaters[i2]:\\n                i1,i2 = i2,i1+1\\n            r = max(r,min(abs(h - heaters[i1]),heaters[i2] - h))            \\n        return r\\n```\\n\\n\\nSo on a high level, the idea is simple - we check every house and find the minimum distance to the 2 closest heaters. Once we finish the scan, we need to find the max value from those distances and it will be the heater radius we are looking for.\\n\\nThat sounds easy, but there are a few catches.\\n\\n1. The problem description doesn\\'t say if the houses and heaters are unique and ordered. So we should be ready for the worst and clean up the input data. Sorting array definitely helps. In theory, if our data have a lot of non-unique values, we might get some advantage of converting them to sets, but with the test data provided we spend more time looking for non-unique elements rather than saving but cleaning them out, so we just sort the arrays:\\n\\n```\\n        houses=sorted(houses)\\n        heaters=sorted(heaters)\\n```\\n\\n2. Ok, now we need to find 2 closest heaters. The problem is there could be just one heater.  Then we would need to add a lot of checks at every loop verifying if we have more than one heater or not. That would burn a lot of CPU time. So a common trick is to expand the array with some fake elements to guarantee that we always have another element. In this case we can either just add one element with max possible value `+inf` to the end of heaters - that way we are guaranteed to have a least one heater after any house. Or we can add `+inf` to the end and `-inf` to the beginning - that way we can guarantee that any house will be between 2 heaters.  In this solution we are going to add just one extra heater, there is another post by @nbismoi with a 2 extra heater solution.\\n\\n```\\nheaters = heaters + [float(\\'inf\\')]\\n```\\n\\n3. Now let\\'s define some variables.  We are going to use 3:\\n\\n`i1,i2` - the indexes of the 2 neighbour heaters. Since we added a heater to the end, we should have at least 2 heaters (actually, the description doesn\\'t guarantee that houses and heaters are non-empty, so if we want to make the solution more universal, we can add some checks like `if house ...` `if heaters ...`  to check for trivial solutions). So we can start with pointing them to 0 and 1.\\n`r` - this is going to be our return value. Since this is going to be the max value accross all distances, we initialize it with `0` and let it go up from there.\\n\\n```\\n        i1,i2,r = 0,1,0\\n```\\n\\n4. Ok, now is the main loop. Let\\'s say we picked a house `h`. We also have two heaters: `heaters[i1]` and `heaters[i2]`.  They can be positioned in 3 possible ways:\\n\\n- `house - heater1 - heater2` - house is before both heaters - ok\\n- `heater1 - house - heater2` - house is between heaters - ok\\n-` heater1 - heater2 - house` - house is after both heaters - time to find new neighbour heaters\\n\\nSince we added a `+inf` element to the end of the heater list, we are always guaranteed to have a heater after any house. So what we are going to do is once we see that both heaters are placed before a house, we are going to pick the next neighbour heater to the right. In other words, if we see first two positions, we calculate distances to the existing heater1/heater2 and find a minimum and once we are in the third position - we update our neigbour heaters. \\n\\nOnce we identified two heaters for each house, we update r to keep it to be the max value of all min distances to the neighbours.\\n\\n```\\n        for h in houses:\\n            while h >= heaters[i2]:\\n                i1,i2 = i2,i1+1\\n            r = max(r,min(abs(h - heaters[i1]),heaters[i2] - h)) \\n```\\n\\nOk, now we just need to return the result:\\n\\n```\\n        return r \\n```\\n\\nFor comparison, here is @nbismoi\\'s solution with two extra heaters:\\n\\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        ans = 0\\n        pos = 0\\n        heaters = [float(\\'-inf\\')] + heaters + [float(\\'inf\\')]\\n        for house in houses:\\n            while house >= heaters[pos]:\\n                pos += 1\\n            r = min(house - heaters[pos - 1], heaters[pos] - house)\\n            ans = max(ans, r)\\n        return ans\\n```\\n\\nPrepending `-inf` could be an expensive operation (generally it\\'s cheap to append to the list but more expensive to prepend), but since we are always guaranteed to have a house between two heaters, so `house - heater1 - heater2` is not possible and we don\\'t need to do `abs(h - heaters[i1])`.\\n\\nBased on the test results looks like both approache show very comparable and very high performance results in >99% range.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        \\n        houses=sorted(houses)\\n        heaters=sorted(heaters)\\n        \\n        heaters = heaters + [float(\\'inf\\')]\\n        i1,i2,r = 0,1,0\\n\\n        for h in houses:\\n            while h >= heaters[i2]:\\n                i1,i2 = i2,i1+1\\n            r = max(r,min(abs(h - heaters[i1]),heaters[i2] - h))            \\n        return r\\n```\n```\\n        houses=sorted(houses)\\n        heaters=sorted(heaters)\\n```\n```\\nheaters = heaters + [float(\\'inf\\')]\\n```\n```\\n        i1,i2,r = 0,1,0\\n```\n```\\n        for h in houses:\\n            while h >= heaters[i2]:\\n                i1,i2 = i2,i1+1\\n            r = max(r,min(abs(h - heaters[i1]),heaters[i2] - h)) \\n```\n```\\n        return r \\n```\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        ans = 0\\n        pos = 0\\n        heaters = [float(\\'-inf\\')] + heaters + [float(\\'inf\\')]\\n        for house in houses:\\n            while house >= heaters[pos]:\\n                pos += 1\\n            r = min(house - heaters[pos - 1], heaters[pos] - house)\\n            ans = max(ans, r)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925552,
                "title": "java-short-and-clean-binary-search-solution",
                "content": "The idea is: for each house in int[] houses, find the closest heater to that house. Naively, for each house we can linearly scan the int[] heaters array from left to right. However a more efficient solution is to sort the heaters array first so that we can do binary search to find the closest heater for each house.\\n\\n```\\npublic int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        int min = Integer.MIN_VALUE;\\n        for (int house : houses) {\\n            int ind = findClosest(heaters, house);\\n            min = Math.max(min, Math.abs(heaters[ind] - house));\\n        }\\n        return min;\\n    }\\n    private int findClosest(int[] array, int target) {\\n        int left = 0;\\n        int right = array.length - 1;\\n        int result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (Math.abs(array[mid] - target) < Math.abs(array[result] - target)) {\\n                result = mid;\\n            }\\n            if (array[mid] == target) {\\n                return mid;\\n            } else if (array[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\t```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\npublic int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        int min = Integer.MIN_VALUE;\\n        for (int house : houses) {\\n            int ind = findClosest(heaters, house);\\n            min = Math.max(min, Math.abs(heaters[ind] - house));\\n        }\\n        return min;\\n    }\\n    private int findClosest(int[] array, int target) {\\n        int left = 0;\\n        int right = array.length - 1;\\n        int result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (Math.abs(array[mid] - target) < Math.abs(array[result] - target)) {\\n                result = mid;\\n            }\\n            if (array[mid] == target) {\\n                return mid;\\n            } else if (array[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 95919,
                "title": "java-easy-solution",
                "content": "Hi there! I am sharing my solution. The idea is to find the closest heater to each house and take maximum of the closest distances. Thus initially it is necessary to sort both houses and heaters by their coordinates. Then assign two pointers, one for houses and another for heaters. Then start traversing the houses. If the ith house is located between j-1th heater and jth heater, then take distance to the closest one and check whether it is the maximum radius found so far. The corner cases are when a house is located before the 1st heater, and when a house is located after the last heater. At the corner case position, there are only distance to consider. That's it. I think code will clarify the idea more.\\n\\nP.S: Do not forget to sort houses and heaters at the beginning. Most  contestants seem to get wrong answer, because they assumed the input to be sorted already (including me:=)).\\n```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        if(houses == null || houses.length == 0) return 0;\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        int ans = 0;\\n        int i  = 0;\\n        int j = 0;\\n        while(i<houses.length){\\n            if(houses[i] <= heaters[j]){ //if house is located before heater j.\\n                if(j == 0){ // corner case when the heater is the first  one\\n                    ans = Math.max(ans, heaters[j]-houses[i]);\\n                    i++;\\n                    continue;\\n                }\\n            } else { // if house is located after some heater, \\n                while(j!=heaters.length-1 && heaters[j]<houses[i]){ // then find a heater that stands after the house\\n                    j++;\\n                }\\n                if(j == 0 || heaters[j] < houses[i]){ // corner cases if j is 0 or there is no more heaters\\n                    ans = Math.max(ans, houses[i]-heaters[j]);\\n                    i++;\\n                    continue;\\n                }\\n            }\\n            int dist = Math.min(houses[i]-heaters[j-1], heaters[j]-houses[i]); // if house is located between jth and j-1th heaters\\n            ans = Math.max(ans, dist);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        if(houses == null || houses.length == 0) return 0;\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        int ans = 0;\\n        int i  = 0;\\n        int j = 0;\\n        while(i<houses.length){\\n            if(houses[i] <= heaters[j]){ //if house is located before heater j.\\n                if(j == 0){ // corner case when the heater is the first  one\\n                    ans = Math.max(ans, heaters[j]-houses[i]);\\n                    i++;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 497433,
                "title": "javascript-binary-search",
                "content": "```javascript\\n/**\\n * @param {number[]} houses\\n * @param {number[]} heaters\\n * @return {number}\\n */\\nvar findRadius = function(houses, heaters) {\\n  heaters.sort((a, b) => a - b);\\n  return Math.max(...houses.map(h => findMinDistance(h, heaters)));\\n};\\n\\nconst findMinDistance = (house, heaters) => {\\n  let left = 0;\\n  let right = heaters.length - 1;\\n  while (left <= right) {\\n    const mid = left + ((right - left) >> 1);\\n    if (heaters[mid] <= house && house <= heaters[mid + 1]) {\\n      return Math.min(house - heaters[mid], heaters[mid + 1] - house);\\n    } else if (heaters[mid] <= house) {\\n      left = mid + 1;\\n    } else {\\n      right = mid - 1;\\n    }\\n  }\\n  if (left === 0) return heaters[0] - house;\\n  if (left === heaters.length) return house - heaters[heaters.length - 1];\\n};\\n```\\n* 30/30 cases passed (92 ms)\\n* Your runtime beats 98.08 % of javascript submissions\\n* Your memory usage beats 33.33 % of javascript submissions (39.8 MB)",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} houses\\n * @param {number[]} heaters\\n * @return {number}\\n */\\nvar findRadius = function(houses, heaters) {\\n  heaters.sort((a, b) => a - b);\\n  return Math.max(...houses.map(h => findMinDistance(h, heaters)));\\n};\\n\\nconst findMinDistance = (house, heaters) => {\\n  let left = 0;\\n  let right = heaters.length - 1;\\n  while (left <= right) {\\n    const mid = left + ((right - left) >> 1);\\n    if (heaters[mid] <= house && house <= heaters[mid + 1]) {\\n      return Math.min(house - heaters[mid], heaters[mid + 1] - house);\\n    } else if (heaters[mid] <= house) {\\n      left = mid + 1;\\n    } else {\\n      right = mid - 1;\\n    }\\n  }\\n  if (left === 0) return heaters[0] - house;\\n  if (left === heaters.length) return house - heaters[heaters.length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 274555,
                "title": "python-short-and-easy-explained-one-pointer-o-nlogn-o-1",
                "content": "**Algorithm**\\nAfter sorting the inputs, we loop through the houses and find the minimum distance to the left and right closests heaters.\\nWe mantain a pointer to lookup at the closests heaters, while looping through the houses:\\n* `i` represents the index of the closest left heater\\n* `i+1` represents the index of the closest left heater \\n\\n**Analysis**\\nThere is no extra space used.\\nGiven the two sort methods used, the runtime complexity is min(NlogN, MlogM) where N and M are the sizes of the two inputs.\\nIf the array were initially sorted, this algorithm would have linear runtime.\\n\\n```\\ndef findRadius(houses, heaters):    \\n\\thouses.sort()\\n    heaters.sort()\\n    N, i, maxRadius = len(heaters), 0, 0\\n\\n\\tfor house in houses:\\n\\t\\twhile i+1 < N and heaters[i+1] < house:\\n            i += 1\\n        maxRadius = max(maxRadius, min([abs(h-house) for h in heaters[i:i+2]]))    \\n\\n    return maxRadius\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findRadius(houses, heaters):    \\n\\thouses.sort()\\n    heaters.sort()\\n    N, i, maxRadius = len(heaters), 0, 0\\n\\n\\tfor house in houses:\\n\\t\\twhile i+1 < N and heaters[i+1] < house:\\n            i += 1\\n        maxRadius = max(maxRadius, min([abs(h-house) for h in heaters[i:i+2]]))    \\n\\n    return maxRadius\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 95888,
                "title": "a-binary-search-solution",
                "content": "We're more likely to come up with the merge procedure algorithm, where we first sort the two vectors and then find the two surrounding heaters for each house. This is O(mlogm + nlogn + m + n) time.\\n\\nYet we have another binary search approach where only the heaters array need to be sorted. For each house, we apply binary search twice to find its left and right neighbor heaters to compute the radius for it to be covered. This algorithm is O(nlogn + mlogn), better than the merge one.\\n```\\n/***\\n     * \\\\Note\\n     * assume both vectors are in sorted order\\n     * \\n     * \\\\Algorithm\\n     * for each house in houses, apply binary search in heaters,\\n     * to find its closest left heater, and closest right side heater.\\n     * left = BsearchNoGreaterThan (house, heaters);\\n     * right= BsearchNoSmallerThan (house, heaters);\\n     * \\n     * HEATER_TO_RADIUS(heater, house)  (heater == -1 ? INT_MAX : abs(house - heater))\\n     * radius = min (HEATER_TO_RADIUS(left, house), HEATER_2_RADIUS(right, house));\\n     * \\n     * return max {radius for each house}\\n     * \\n     * \\\\Analysis\\n     * O(m * 2logn) = O(mlogn) time, O(1) auxiliary space\\n     */\\n    int findRadiusBSearch(vector<int>& houses, vector<int>& heaters) {\\n        int ret = 0;\\n        \\n        /* the input is not necessarily sorted */\\n        sort (heaters.begin(), heaters.end());\\n        for (int i = 0; i < houses.size(); i++) {\\n            int leftHeater = BSearchNoGreaterThan (heaters, houses[i]);\\n            int rightHeater= BSearchNoSmallerThan (heaters, houses[i]);\\n            \\n            //cout << leftHeater << \" \" << houses[i] << \" \" << rightHeater << endl;\\n            #define HEATER2R(ht, hs)    (ht == -1 ? INT_MAX : abs(hs - ht))\\n            int radius = min (HEATER2R(leftHeater, houses[i]), HEATER2R(rightHeater, houses[i]));\\n            ret = max (radius, ret);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int BSearchNoGreaterThan (vector<int>& nums, int target) {\\n        int lo = 0;\\n        int hi = nums.size() - 1;\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo + 1) / 2;\\n            if (nums[mid] <= target) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        if (lo == hi && nums[lo] <= target) {\\n            return nums[lo];\\n        }\\n        \\n        /* not found */\\n        return -1;\\n    }\\n    \\n    int BSearchNoSmallerThan (vector<int>& nums, int target) {\\n        int lo = 0;\\n        int hi = nums.size() - 1;\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (target <= nums[mid]) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        if (lo == hi && target <= nums[lo]) {\\n            return nums[lo];\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/***\\n     * \\\\Note\\n     * assume both vectors are in sorted order\\n     * \\n     * \\\\Algorithm\\n     * for each house in houses, apply binary search in heaters,\\n     * to find its closest left heater, and closest right side heater.\\n     * left = BsearchNoGreaterThan (house, heaters);\\n     * right= BsearchNoSmallerThan (house, heaters);\\n     * \\n     * HEATER_TO_RADIUS(heater, house)  (heater == -1 ? INT_MAX : abs(house - heater))\\n     * radius = min (HEATER_TO_RADIUS(left, house), HEATER_2_RADIUS(right, house));\\n     * \\n     * return max {radius for each house}\\n     * \\n     * \\\\Analysis\\n     * O(m * 2logn) = O(mlogn) time, O(1) auxiliary space\\n     */\\n    int findRadiusBSearch(vector<int>& houses, vector<int>& heaters) {\\n        int ret = 0;\\n        \\n        /* the input is not necessarily sorted */\\n        sort (heaters.begin(), heaters.end());\\n        for (int i = 0; i < houses.size(); i++) {\\n            int leftHeater = BSearchNoGreaterThan (heaters, houses[i]);\\n            int rightHeater= BSearchNoSmallerThan (heaters, houses[i]);\\n            \\n            //cout << leftHeater << \" \" << houses[i] << \" \" << rightHeater << endl;\\n            #define HEATER2R(ht, hs)    (ht == -1 ? INT_MAX : abs(hs - ht))\\n            int radius = min (HEATER2R(leftHeater, houses[i]), HEATER2R(rightHeater, houses[i]));\\n            ret = max (radius, ret);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int BSearchNoGreaterThan (vector<int>& nums, int target) {\\n        int lo = 0;\\n        int hi = nums.size() - 1;\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo + 1) / 2;\\n            if (nums[mid] <= target) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        if (lo == hi && nums[lo] <= target) {\\n            return nums[lo];\\n        }\\n        \\n        /* not found */\\n        return -1;\\n    }\\n    \\n    int BSearchNoSmallerThan (vector<int>& nums, int target) {\\n        int lo = 0;\\n        int hi = nums.size() - 1;\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (target <= nums[mid]) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        if (lo == hi && target <= nums[lo]) {\\n            return nums[lo];\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1686074,
                "title": "java-sort-two-pointers-clean-with-picture-briefly-explained",
                "content": "![image](https://assets.leetcode.com/users/images/0a37244d-c1f7-4354-9fe8-e7a0e94e1a70_1642048298.9994001.png)\\n![image](https://assets.leetcode.com/users/images/b1e2a7b9-ac47-430c-9d0f-319202bb8d57_1642048404.021388.png)\\n![image](https://assets.leetcode.com/users/images/256cd4d2-b6dc-40e2-9d94-f1690d9eb904_1642048435.5740945.png)\\n![image](https://assets.leetcode.com/users/images/d0d5bfe1-2c65-42f3-a462-71039382191e_1642048441.9954638.png)\\n\\n\\n```java\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        if(houses == null || houses.length == 0 || heaters == null || heaters.length == 0){\\n            return 0;\\n        }\\n        \\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        int n = houses.length;\\n        int m = heaters.length; \\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        int res = 0;\\n        while(i < n && j < m){\\n            // for each heaters[j],  compare to heaters[j + 1]\\n            int dist1 = Math.abs(heaters[j] - houses[i]);\\n            int dist2 = Integer.MAX_VALUE;\\n            if(j + 1 < m){\\n                dist2 = Math.abs(heaters[j + 1] - houses[i]);\\n            }\\n            // if j closer to i than j + 1, settle and i ++;\\n            if(dist1 < dist2){\\n                res = Math.max(res, dist1);\\n                i++;\\n            // else j++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        if(houses == null || houses.length == 0 || heaters == null || heaters.length == 0){\\n            return 0;\\n        }\\n        \\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        int n = houses.length;\\n        int m = heaters.length; \\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        int res = 0;\\n        while(i < n && j < m){\\n            // for each heaters[j],  compare to heaters[j + 1]\\n            int dist1 = Math.abs(heaters[j] - houses[i]);\\n            int dist2 = Integer.MAX_VALUE;\\n            if(j + 1 < m){\\n                dist2 = Math.abs(heaters[j + 1] - houses[i]);\\n            }\\n            // if j closer to i than j + 1, settle and i ++;\\n            if(dist1 < dist2){\\n                res = Math.max(res, dist1);\\n                i++;\\n            // else j++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516011,
                "title": "c-binary-search-90-70",
                "content": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        int radius = 0;\\n        sort(heaters.begin(), heaters.end());\\n        for(auto house : houses) {\\n            if(house <= heaters.front()) {\\n                radius = max(radius, heaters.front() - house);\\n                continue;\\n            }\\n            if(house >= heaters.back()) {\\n                radius = max(radius, house - heaters.back());\\n                continue;\\n            }\\n            radius = max(radius, findAjacentHeaters(house, heaters));\\n        }\\n        return radius;\\n    }\\nprivate:\\n    int findAjacentHeaters(int house, vector<int>& heaters) {\\n        int radius = 0;\\n        int l = 0;\\n        int r = heaters.size() - 1;\\n        while(l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if(heaters[mid] == house) return 0;\\n            if(heaters[mid] < house) l = mid + 1;\\n            if(heaters[mid] > house) r = mid - 1;\\n        }\\n        return min(heaters[l]-house, house-heaters[r]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        int radius = 0;\\n        sort(heaters.begin(), heaters.end());\\n        for(auto house : houses) {\\n            if(house <= heaters.front()) {\\n                radius = max(radius, heaters.front() - house);\\n                continue;\\n            }\\n            if(house >= heaters.back()) {\\n                radius = max(radius, house - heaters.back());\\n                continue;\\n            }\\n            radius = max(radius, findAjacentHeaters(house, heaters));\\n        }\\n        return radius;\\n    }\\nprivate:\\n    int findAjacentHeaters(int house, vector<int>& heaters) {\\n        int radius = 0;\\n        int l = 0;\\n        int r = heaters.size() - 1;\\n        while(l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if(heaters[mid] == house) return 0;\\n            if(heaters[mid] < house) l = mid + 1;\\n            if(heaters[mid] > house) r = mid - 1;\\n        }\\n        return min(heaters[l]-house, house-heaters[r]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329918,
                "title": "python-binary-search-sliding-index",
                "content": "Intuitively, we want to figure out the closest heater for each house. And then we collect those distance and pick the maximum.\\n\\nSo if we sorted the heaters first, then we can use binary search each house on heaters array to find the closest heaters. We can add two pivots (-\\u221E, +\\u221E) at two ends to handle border issue.\\n```\\ndef findRadius(houses, heaters):\\n\\theaters = [float(\\'-inf\\')] + sorted(heaters) + [float(\\'inf\\')]\\n\\tr = 0\\n\\tfor house in houses:\\n\\t\\ti = bisect.bisect(heaters, house)\\n\\t\\tr = max(r, min(house-heaters[i-1], heaters[i]-house))\\n\\treturn r\\n```\\nSuppose len(houses) = m and len(heaters) = n, time complexity is O((m+n)logn).\\n\\nBesides, if the density of houses is far less then heaters, we can also sort houses and slide closest heater\\'s index without need of binary search:\\n```\\ndef findRadius(houses, heaters):\\n\\theaters = sorted(heaters) + [float(\\'inf\\')]\\n\\ti = r = 0\\n\\tfor x in sorted(houses):\\n\\t\\twhile x >= sum(heaters[i:i+2]) / 2: \\n\\t\\t\\ti += 1\\n\\t\\tr = max(r, abs(x-heaters[i]))\\n\\treturn r\\n```\\nTime complexity is O(nlogn + mlogm + n) = O(nlogn + mlogm).",
                "solutionTags": [],
                "code": "```\\ndef findRadius(houses, heaters):\\n\\theaters = [float(\\'-inf\\')] + sorted(heaters) + [float(\\'inf\\')]\\n\\tr = 0\\n\\tfor house in houses:\\n\\t\\ti = bisect.bisect(heaters, house)\\n\\t\\tr = max(r, min(house-heaters[i-1], heaters[i]-house))\\n\\treturn r\\n```\n```\\ndef findRadius(houses, heaters):\\n\\theaters = sorted(heaters) + [float(\\'inf\\')]\\n\\ti = r = 0\\n\\tfor x in sorted(houses):\\n\\t\\twhile x >= sum(heaters[i:i+2]) / 2: \\n\\t\\t\\ti += 1\\n\\t\\tr = max(r, abs(x-heaters[i]))\\n\\treturn r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 95978,
                "title": "5-line-solution-directly-using-std-lower-bound-for-binary-search-detailed-explanation-with-picture-illustration",
                "content": "**Key observation:** Each house should be covered by its nearest heater. The nearest heater to a house is either next right to it or next left to it, whichever is closer.\\n\\nAlgorithm:\\n1. Sort heaters `vector<int> hts` by positions (O(N<sub>heater</sub>logN<sub>heater</sub>));\\n2. For each house `h`, use `std::lower_bound` to find the nearest heater and update the overall min heater radius (O(logN<sub>heater</sub>) for each house). Note\\n   * Next right heater position: `i = lower_bound(hts.begin(), hts.end(), h)`. \\n   * Next left heater position: `--i` for the iterator above . \\n\\nThe overall time complexity is O((N<sub>house</sub>+N<sub>heater</sub>)logN<sub>heater</sub>).\\n![0_1481520322846_heaters.JPG](/uploads/files/1481520303403-heaters.jpg) \\n```\\n    int findRadius(vector<int>& houses, vector<int>& hts) {\\n      sort(hts.begin(), hts.end()); int res = 0; \\n      for (int h:houses) { // find nearest distance to heaters\\n        auto i = lower_bound(hts.begin(), hts.end(), h); // next right heater\\n        res = max(res, min(i!=hts.begin()? h-*(--i):INT_MAX, i!=hts.end()? *i - h:INT_MAX));\\n      }\\n      return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n    int findRadius(vector<int>& houses, vector<int>& hts) {\\n      sort(hts.begin(), hts.end()); int res = 0; \\n      for (int h:houses) { // find nearest distance to heaters\\n        auto i = lower_bound(hts.begin(), hts.end(), h); // next right heater\\n        res = max(res, min(i!=hts.begin()? h-*(--i):INT_MAX, i!=hts.end()? *i - h:INT_MAX));\\n      }\\n      return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 554748,
                "title": "python-3-simple-solution",
                "content": "```\\n\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        ans = 0\\n        pos = 0\\n        heaters = [float(\\'-inf\\')] + heaters + [float(\\'inf\\')]\\n        for house in houses:\\n            while house >= heaters[pos]:\\n                pos += 1\\n            r = min(house - heaters[pos - 1], heaters[pos] - house)\\n            ans = max(ans, r)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        ans = 0\\n        pos = 0\\n        heaters = [float(\\'-inf\\')] + heaters + [float(\\'inf\\')]\\n        for house in houses:\\n            while house >= heaters[pos]:\\n                pos += 1\\n            r = min(house - heaters[pos - 1], heaters[pos] - house)\\n            ans = max(ans, r)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006672,
                "title": "python3-binary-search",
                "content": "# Intuition\\n\\nSince the heaters array cannot be empty, every house would have a heater that is the closest one to that house. The goal is to calculate the distance to the closest heater for every house and then return the maximum among them. By doing this we will fulfill the requirement of the problem to have every house covered by heaters.\\n\\n# Approach\\n\\nA brute force solution for this problem is to iterate over array `houses`, calculate the distance between every heater and the house and take the minimum value among them. After that take the maximum value among the minimums. \\nThis solution, thought, will exceed the time limit. How can we improve it?\\nInstead of iterating through the whole `heaters` array, we could use Binary Search to find the heater that is the closest to the house.\\nTo perform Binary Search, we need array `heaters` to be sorted. After finding the closest heater, we subtract value of the house from it to get the minimum distance, and then we update maximum distance.\\nAfter the iteration over houses is done, maximum distance would be the answer.\\n\\n# Complexity\\n- Time complexity:\\n\\nTo have array `heaters` sorted, we would need $$O(n *log(n))$$ time (Timsort)\\nTo perform binary search for every element in array `houses` we need $$O(m*log(n))$$ time\\nTotal time complexity would be $$O((n+m)*log(n))$$, where `n` is the length of array `heaters` and `m` is the length of array `houses`\\n\\n- Space complexity:\\n\\nTo have array `heaters` sorted, we would need $$O(n)$$ space (Timsort)\\nTo perform binary search we only need $$O(1)$$ space\\nTotal space complexity would be $$O(n)$$, where `n` is the length of array `heaters`\\n\\n# Code\\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        abs_dist = float(\"-inf\")\\n        n = len(heaters)\\n        heaters.sort()\\n        for i in houses:\\n            cur_dist = abs(self.findClosest(heaters, n, i) - i)\\n            abs_dist = max(abs_dist, cur_dist)\\n        return abs_dist\\n\\n    def findClosest(self, arr, n, target):\\n        if (target <= arr[0]):\\n            return arr[0]\\n        if (target >= arr[n - 1]):\\n            return arr[n - 1]\\n    \\n        i = 0\\n        j = n\\n        mid = 0\\n        while (i < j):\\n            mid = (i + j) // 2\\n            if (arr[mid] == target):\\n                return arr[mid]\\n            if (target < arr[mid]):\\n                if (mid > 0 and target > arr[mid - 1]):\\n                    return self.getClosest(arr[mid - 1], arr[mid], target)\\n                j = mid\\n            else:\\n                if (mid < n - 1 and target < arr[mid + 1]):\\n                    return self.getClosest(arr[mid], arr[mid + 1], target)\\n                i = mid + 1\\n\\n        return arr[mid]\\n\\n    def getClosest(self, val1, val2, target):\\n        if (target - val1 >= val2 - target):\\n            return val2\\n        else:\\n            return val1\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        abs_dist = float(\"-inf\")\\n        n = len(heaters)\\n        heaters.sort()\\n        for i in houses:\\n            cur_dist = abs(self.findClosest(heaters, n, i) - i)\\n            abs_dist = max(abs_dist, cur_dist)\\n        return abs_dist\\n\\n    def findClosest(self, arr, n, target):\\n        if (target <= arr[0]):\\n            return arr[0]\\n        if (target >= arr[n - 1]):\\n            return arr[n - 1]\\n    \\n        i = 0\\n        j = n\\n        mid = 0\\n        while (i < j):\\n            mid = (i + j) // 2\\n            if (arr[mid] == target):\\n                return arr[mid]\\n            if (target < arr[mid]):\\n                if (mid > 0 and target > arr[mid - 1]):\\n                    return self.getClosest(arr[mid - 1], arr[mid], target)\\n                j = mid\\n            else:\\n                if (mid < n - 1 and target < arr[mid + 1]):\\n                    return self.getClosest(arr[mid], arr[mid + 1], target)\\n                i = mid + 1\\n\\n        return arr[mid]\\n\\n    def getClosest(self, val1, val2, target):\\n        if (target - val1 >= val2 - target):\\n            return val2\\n        else:\\n            return val1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188394,
                "title": "explanation-when-and-why-could-we-use-2-pointers",
                "content": "When should we use pointers? when we know that pointers are going towards one direction and never go backward. \\nWhen should we move a pointer? when we\\'ve done the calculation of current position, move to next position may have better solution, we move the pointer. \\n\\nFor this question:\\n- basic idea: for each house, find the closet heater for it \\n- i is pointer for houses, j is pointer for heaters. \\n- sort the two lists \\n- we start from the smallest indexed house, and smallest indexed heater.  For a pair of house i and heater j, we calculate current distance. \\n- if the distance from this house i to next heater j + 1 is smaller than current distance, it means that next heater is closer to current house, so we move to next heater ( j++). \\n- else, j is the closest heater to i, update result and move to next house i++ \\n- be ware of edge cases \\n\\nSo, why can we move j forward to j+1, without worrying about checking distance between house i + 1with heater j?\\nFor example:\\n---- heater 5------heater 6---------\\n--------------------------house 3-------house 4-----\\nHere if we know the distance from heater 5 to house 3 is farther than it from heater 6 to house 3. So for house 4, heater 5 is also farther comparing to heater 6:\\n\\nhouse4 - heater5 = (house4 - house3) + (house3 - heater5)\\nhouse4 - heater6 = (house4 - house3) + (house3 - heater6)\\n\\nSo for  house 4, we dont have to worry about heater 5, we only need to check heater 6 and beyond. This is exactly why we can use 2 pointers here: WE NEVER GO BACK. \\n        \\n```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        int m = houses.length;\\n        int n = heaters.length;\\n        int i = 0, j = 0;\\n        int radius = 0;\\n        \\n        while (i < m && j < n) {\\n            // find closet heater for house i \\n            int currR = Math.abs(heaters[j] - houses[i]);\\n            int nextR = Integer.MAX_VALUE;\\n            // check distance from next heater j + 1 to current house i\\n            if (j < n - 1) {\\n                nextR = Math.abs(heaters[j + 1] - houses[i]);\\n            }\\n            // compare heater j and heater j + 1, if j is closer, or j is the last heater, update result and move to next house:\\n            if (currR < nextR) {\\n                radius = Math.max(radius, currR);\\n                i++;\\n            }\\n            // else if j+1 is closer, move to next heater:\\n            else {\\n                j++;\\n            }\\n        }\\n        \\n        return radius;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        int m = houses.length;\\n        int n = heaters.length;\\n        int i = 0, j = 0;\\n        int radius = 0;\\n        \\n        while (i < m && j < n) {\\n            // find closet heater for house i \\n            int currR = Math.abs(heaters[j] - houses[i]);\\n            int nextR = Integer.MAX_VALUE;\\n            // check distance from next heater j + 1 to current house i\\n            if (j < n - 1) {\\n                nextR = Math.abs(heaters[j + 1] - houses[i]);\\n            }\\n            // compare heater j and heater j + 1, if j is closer, or j is the last heater, update result and move to next house:\\n            if (currR < nextR) {\\n                radius = Math.max(radius, currR);\\n                i++;\\n            }\\n            // else if j+1 is closer, move to next heater:\\n            else {\\n                j++;\\n            }\\n        }\\n        \\n        return radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080771,
                "title": "easiest-to-understand-modified-binary-search",
                "content": "I think this is the easiest and most understanble solution running in ```O(NlogM)```.  (unless I am missing somethng totally obvious in which case please do point it out)\\n\\nBasically the idea is that each house needs to be covered by some heater. There are 2 options: a house is either on a heater or it isn\\'t.\\n\\n1) If a house is on a heater then we skip that house - it won\\'t change at all the radius that we consider\\n2) If a house is not on a heater then we simply need to find the distance to the closest heater and if we find the maximum for all the houses like that we arrive at the solution.\\n\\nThe above idea can be implemented as follows:\\n\\n```\\n  int res = Integer.MIN_VALUE;\\n  for (int house: houses) {\\n      int distance = Integer.MAX_VALUE;\\n      for (int i = 0; i < heaters.length; i++) {\\n          distance = Math.min(Math.abs(heaters[i] - house), distance);\\n      }\\n      res = Math.max(distance, res);\\n  }\\n  return res;\\n```\\nThe above solution gets AC(Accepted) and it has a runtime of: ```O(N*M)``` where `N` is the number of houses and `M` is the number of heatesr.\\n\\nHowever, we can do better. Binary search can be used to find the exact index of a number or `-1` if the number doesn\\'t exist, we can modify binary-search to yield the index of the nearest number. For our problem this means that we can find the index of the closest heater in ```O(logM)```.  Thus we can simplify the above solution to:\\n\\n```\\npublic int findRadius(int[] houses, int[] heaters) {\\n\\n\\tint res = Integer.MIN_VALUE;\\n\\tArrays.sort(heaters);\\n\\n\\tfor (int house: houses)\\n\\t\\tres = Math.max(Math.abs(heaters[nearestNumber(house, heaters)] - house), res);\\n\\n\\treturn res;\\n}\\nstatic int nearestNumber(int n, int[] a) {\\n\\tint low = 0;\\n\\tint high = a.length - 1, nearestIndex = 0;\\n\\tint distance = Integer.MAX_VALUE;\\n\\n\\twhile (low<= high) {\\n\\n\\t\\tint mid = low + (high - low) / 2;\\n\\n\\t\\tif (distance > Math.abs(a[mid] - n)) {\\n\\n\\t\\t\\tdistance = Math.abs(a[mid] - n);\\n\\t\\t\\tnearestIndex = mid;\\n\\t\\t}\\n\\n\\t\\tif (a[mid] == n) return mid;\\n\\n\\t\\telse if (n<a[mid]) high = mid - 1;\\n\\n\\t\\telse low = mid + 1;\\n\\t}\\n\\treturn nearestIndex;\\n\\n}\\n```\\nThus we obtain a solution with time-complexity of ```O(Nlogm)```.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```O(NlogM)```\n```\\n  int res = Integer.MIN_VALUE;\\n  for (int house: houses) {\\n      int distance = Integer.MAX_VALUE;\\n      for (int i = 0; i < heaters.length; i++) {\\n          distance = Math.min(Math.abs(heaters[i] - house), distance);\\n      }\\n      res = Math.max(distance, res);\\n  }\\n  return res;\\n```\n```O(N*M)```\n```O(logM)```\n```\\npublic int findRadius(int[] houses, int[] heaters) {\\n\\n\\tint res = Integer.MIN_VALUE;\\n\\tArrays.sort(heaters);\\n\\n\\tfor (int house: houses)\\n\\t\\tres = Math.max(Math.abs(heaters[nearestNumber(house, heaters)] - house), res);\\n\\n\\treturn res;\\n}\\nstatic int nearestNumber(int n, int[] a) {\\n\\tint low = 0;\\n\\tint high = a.length - 1, nearestIndex = 0;\\n\\tint distance = Integer.MAX_VALUE;\\n\\n\\twhile (low<= high) {\\n\\n\\t\\tint mid = low + (high - low) / 2;\\n\\n\\t\\tif (distance > Math.abs(a[mid] - n)) {\\n\\n\\t\\t\\tdistance = Math.abs(a[mid] - n);\\n\\t\\t\\tnearestIndex = mid;\\n\\t\\t}\\n\\n\\t\\tif (a[mid] == n) return mid;\\n\\n\\t\\telse if (n<a[mid]) high = mid - 1;\\n\\n\\t\\telse low = mid + 1;\\n\\t}\\n\\treturn nearestIndex;\\n\\n}\\n```\n```O(Nlogm)```",
                "codeTag": "Unknown"
            },
            {
                "id": 866206,
                "title": "easy-python-100-speed-pre-sorting",
                "content": "**Easy Python | 100% Speed | Pre-Sorting**\\n\\nEasy Python Solution based on the following concepts:\\n\\n* If we pre-sorted the arrays \"A\" and \"B\" (Houses and Heaters), it would be very easy to find the closest heaters to any house. We could use binary search, or even better, we could \"walk\" (iterate) through each house updating our closest heaters in O(1) Time.\\n\\n* The final answer corresponds to the largest radius required to heat any house. The required radius for each house can be calculated as the minimum distance to the closest heater.\\n\\nThe code below implements these ideas to solve the problem with O( A log A + B log B ) Time/Space Complexity. If the arrays were already sorted, the \"Main Routine\" could actually run with O( A + B ) Time Complexity and O(1) Space Complexity.\\n\\nI hope the explanation was helpful.\\nCheers,\\n\\n```\\nclass Solution:\\n    def findRadius(self, A, B):\\n        # 1) Pre-sorting Step\\n        A.sort()\\n        B.sort()\\n        #\\n        # 2) Main Algorithm\\n        last  = len(B) - 1\\n        x1,x2 = 0,0\\n        res   = 0\\n        for y in A:\\n            while x2 < last and y > B[x2]:\\n                x1, x2 = x2, x2+1\\n            d1,d2 = abs(B[x1] - y), abs(B[x2] - y)\\n            res   = max( res , min(d1,d2) )\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, A, B):\\n        # 1) Pre-sorting Step\\n        A.sort()\\n        B.sort()\\n        #\\n        # 2) Main Algorithm\\n        last  = len(B) - 1\\n        x1,x2 = 0,0\\n        res   = 0\\n        for y in A:\\n            while x2 < last and y > B[x2]:\\n                x1, x2 = x2, x2+1\\n            d1,d2 = abs(B[x1] - y), abs(B[x2] - y)\\n            res   = max( res , min(d1,d2) )\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755599,
                "title": "java-merge-2-sorted-array",
                "content": "```\\n    public int findRadius(int[] houses, int[] hs) {\\n        Arrays.sort(houses);\\n        Arrays.sort(hs);\\n        int res = 0, i = 0;\\n        for (int h : houses) {\\n            while (i < hs.length - 1 && hs[i] <= h) i++;\\n            res = Math.max(res, Math.min(Math.abs(h - (i > 0 ? hs[i - 1] : hs[0])), Math.abs(hs[i] - h)));\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findRadius(int[] houses, int[] hs) {\\n        Arrays.sort(houses);\\n        Arrays.sort(hs);\\n        int res = 0, i = 0;\\n        for (int h : houses) {\\n            while (i < hs.length - 1 && hs[i] <= h) i++;\\n            res = Math.max(res, Math.min(Math.abs(h - (i > 0 ? hs[i - 1] : hs[0])), Math.abs(hs[i] - h)));\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693188,
                "title": "c-different-binary-search-sol-based-on-painter-s-partition-problem-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/heaters/submissions/\\n    \\n    Solution is very similar to Painter\\'s partition problem.\\n    We do the binary search on the search space for radius.\\n    For each radius we check if all the houses can be covered or not,\\n    if it can be covered, we try to look for the smallest radius that can cover it.\\n    \\n    \\n    TC: for sorting the arrays: O(mlogm + nlogn)\\n        for doing binary search O(nlog(INT_MAX))\\n*/\\n\\nclass Solution {\\npublic:\\n    // Checks if with the given radius all the houses can be covered or not\\n    bool housesCovered(vector<int> houses, vector<int>& heaters,\\n                       int radius) {\\n        int left = heaters[0] - radius;\\n        int right = heaters[0] + radius;\\n        int heater_idx = 0, house_idx = 0;\\n        \\n        while(house_idx < houses.size()) {\\n            if(houses[house_idx] >= left && houses[house_idx] <= right) {\\n                ++house_idx;\\n            }\\n            else {\\n                ++heater_idx;\\n                if(heater_idx == heaters.size())\\n                    return false;\\n                left = heaters[heater_idx] - radius;\\n                right = heaters[heater_idx] + radius;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // TC: O(nlogn + mlogm + nlogn)\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        if(houses.empty())\\n            return true;\\n        if(heaters.empty())\\n            return false;\\n        \\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        int low = 0, high = abs(max(houses.back(), heaters.back()) - houses.front());\\n        \\n        while(low < high) {\\n            int radius = low + (high - low) / 2;\\n            // check if the radius is enough to cover all the houses\\n            if(housesCovered(houses, heaters, radius))\\n                high = radius;\\n            else\\n                low = radius + 1;\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/heaters/submissions/\\n    \\n    Solution is very similar to Painter\\'s partition problem.\\n    We do the binary search on the search space for radius.\\n    For each radius we check if all the houses can be covered or not,\\n    if it can be covered, we try to look for the smallest radius that can cover it.\\n    \\n    \\n    TC: for sorting the arrays: O(mlogm + nlogn)\\n        for doing binary search O(nlog(INT_MAX))\\n*/\\n\\nclass Solution {\\npublic:\\n    // Checks if with the given radius all the houses can be covered or not\\n    bool housesCovered(vector<int> houses, vector<int>& heaters,\\n                       int radius) {\\n        int left = heaters[0] - radius;\\n        int right = heaters[0] + radius;\\n        int heater_idx = 0, house_idx = 0;\\n        \\n        while(house_idx < houses.size()) {\\n            if(houses[house_idx] >= left && houses[house_idx] <= right) {\\n                ++house_idx;\\n            }\\n            else {\\n                ++heater_idx;\\n                if(heater_idx == heaters.size())\\n                    return false;\\n                left = heaters[heater_idx] - radius;\\n                right = heaters[heater_idx] + radius;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // TC: O(nlogn + mlogm + nlogn)\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        if(houses.empty())\\n            return true;\\n        if(heaters.empty())\\n            return false;\\n        \\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        int low = 0, high = abs(max(houses.back(), heaters.back()) - houses.front());\\n        \\n        while(low < high) {\\n            int radius = low + (high - low) / 2;\\n            // check if the radius is enough to cover all the houses\\n            if(housesCovered(houses, heaters, radius))\\n                high = radius;\\n            else\\n                low = radius + 1;\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 121152,
                "title": "easy-python3-o-nlogn-solution",
                "content": "Each house is either heated by the heater before it or by the heater after it, and the min of them is the radius required by that house, and the max of the radius required by each house is the answer we need. The special case is the house does not have a heater before it or a heater after it. \\n```\\nclass Solution:\\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        houses.sort()\\n        heaters.sort()\\n        radius = 0\\n        i = 0\\n        for house in houses:\\n            while i < len(heaters) and heaters[i] < house:\\n                i += 1\\n            if i == 0:\\n                radius = max(radius, heaters[i] - house)\\n            elif i == len(heaters):\\n                return max(radius, houses[-1] - heaters[-1])\\n            else:\\n                radius = max(radius, min(heaters[i]-house, house-heaters[i-1]))\\n        return radius\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        houses.sort()\\n        heaters.sort()\\n        radius = 0\\n        i = 0\\n        for house in houses:\\n            while i < len(heaters) and heaters[i] < house:\\n                i += 1\\n            if i == 0:\\n                radius = max(radius, heaters[i] - house)\\n            elif i == len(heaters):\\n                return max(radius, houses[-1] - heaters[-1])\\n            else:\\n                radius = max(radius, min(heaters[i]-house, house-heaters[i-1]))\\n        return radius\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634133,
                "title": "c-solution-binary-search-on-answer-explained-approach",
                "content": "# Intuition\\nAs the arrays are sorted and we need to minimize the answer so we can think of applying Binary Search on Answer\\n\\n# Approach\\nWe\\'ll create a range on the radius of heaters. Then we\\'ll apply binary search on that range. If current value is valid radius we\\'ll store this radius then we\\'ll move h to mid-1 to find a lower answer. If it is not valid we\\'ll move l to mid+1 to find answer in higher range. To check if the current value is valid or not, we\\'ll traverse the houses array and for each house we\\'ll find lower bound of (houses[i]-radius) in heaters array. If there exists no lower bound or the value of lower bound exceeds houses[i]+radius then we\\'ll return false else we\\'ll check for next house.\\n\\n# Complexity\\n- Time complexity:\\nT.C = O(log(10^9)xNx(logM)) where N is size of houses array and M is size of heaters array\\n\\n\\n# Code\\n```\\n//BINARY SEARCH ON ANSWER \\n\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {       \\n        int heat = heaters.size();\\n        int hou = houses.size();\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        int l = 0;\\n        int h = max(abs(houses[0]-heaters[heat-1]), abs(houses[hou-1]-heaters[0]));\\n        int ans = -1;\\n        int mid = l+(h-l)/2;\\n        while(l <= h)\\n        {\\n            mid = l+(h-l)/2;\\n            if(solve(houses, heaters, mid))\\n            {\\n               ans = mid;\\n               h = mid-1;\\n            }else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool solve(vector<int>& houses, vector<int>& heaters, int rad)\\n    {\\n       bool found = true;\\n       for(int i = 0;i < houses.size(); i++)\\n       {\\n         auto it1 = lower_bound(heaters.begin(), heaters.end(), houses[i]-rad);\\n         if(it1 == heaters.end())\\n         {\\n            return false;\\n         }\\n         if(*it1 > houses[i]+rad)\\n         {\\n            return false;\\n         }\\n       }\\n       return true;\\n    }\\n};\\n```\\n\\n**Do upvote if you found it helpful !\\uD83D\\uDE00\\uD83D\\uDE00**",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n//BINARY SEARCH ON ANSWER \\n\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {       \\n        int heat = heaters.size();\\n        int hou = houses.size();\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        int l = 0;\\n        int h = max(abs(houses[0]-heaters[heat-1]), abs(houses[hou-1]-heaters[0]));\\n        int ans = -1;\\n        int mid = l+(h-l)/2;\\n        while(l <= h)\\n        {\\n            mid = l+(h-l)/2;\\n            if(solve(houses, heaters, mid))\\n            {\\n               ans = mid;\\n               h = mid-1;\\n            }else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool solve(vector<int>& houses, vector<int>& heaters, int rad)\\n    {\\n       bool found = true;\\n       for(int i = 0;i < houses.size(); i++)\\n       {\\n         auto it1 = lower_bound(heaters.begin(), heaters.end(), houses[i]-rad);\\n         if(it1 == heaters.end())\\n         {\\n            return false;\\n         }\\n         if(*it1 > houses[i]+rad)\\n         {\\n            return false;\\n         }\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878479,
                "title": "c-solution",
                "content": "**C++:**\\n\\n```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        const int nhouses = houses.size(), nheaters = heaters.size();\\n        vector<int> result(nhouses,INT_MAX); //find minimal distance\\n        for(int i=0,j=0;i<nhouses && j<nheaters;){ //calc distance to nearest right heater\\n            if(heaters[j]>=houses[i])   result[i] = heaters[j]-houses[i],  ++i;\\n            else    ++j;          \\n        }\\n        for(int i=nhouses-1,j=nheaters-1;i>=0 && j>=0;){ //calc distance to nearest left heater\\n            if(houses[i]>=heaters[j])   result[i] = min(result[i], houses[i]-heaters[j]), --i;\\n            else    --j;\\n        }\\n        return *max_element(result.begin(),result.end());\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        const int nhouses = houses.size(), nheaters = heaters.size();\\n        vector<int> result(nhouses,INT_MAX); //find minimal distance\\n        for(int i=0,j=0;i<nhouses && j<nheaters;){ //calc distance to nearest right heater\\n            if(heaters[j]>=houses[i])   result[i] = heaters[j]-houses[i],  ++i;\\n            else    ++j;          \\n        }\\n        for(int i=nhouses-1,j=nheaters-1;i>=0 && j>=0;){ //calc distance to nearest left heater\\n            if(houses[i]>=heaters[j])   result[i] = min(result[i], houses[i]-heaters[j]), --i;\\n            else    --j;\\n        }\\n        return *max_element(result.begin(),result.end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258849,
                "title": "java-binary-search-with-detailed-explanation",
                "content": "I don\\'t think this is an easy question... It\\'s non-trivial to come up with the binary search solution. \\nFirst we need to sort the heaters array. We need to check the position of the house in the heater array, which can be done by binary search. In this process, we can get the minimum radius needed for this house. Then for all the houses, we pick the **largest** minimum radius such that this radius can cover all the houses.\\n\\nThe time complexity is mlogn + nlogn, where m is the number of elements in the houses array and n is the number of elements in the heaters array.\\n\\n```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        int r = 0;\\n        for (int house : houses) {\\n            r = Math.max(r, minRadius(house, heaters));\\n        }\\n        return r;\\n    }\\n    \\n    // heaters are already sorted\\n    private int minRadius(int house, int[] heaters) {\\n        int low = 0, high = heaters.length - 1, minR = Integer.MAX_VALUE;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (heaters[mid] == house) return 0;\\n            else if (heaters[mid] > house) {\\n                minR = Math.min(minR, heaters[mid] - house);\\n                high = mid - 1;\\n            } else {\\n                minR = Math.min(minR, house - heaters[mid]);\\n                low = mid + 1;\\n            }\\n        }\\n        return minR;\\n    }  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        int r = 0;\\n        for (int house : houses) {\\n            r = Math.max(r, minRadius(house, heaters));\\n        }\\n        return r;\\n    }\\n    \\n    // heaters are already sorted\\n    private int minRadius(int house, int[] heaters) {\\n        int low = 0, high = heaters.length - 1, minR = Integer.MAX_VALUE;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (heaters[mid] == house) return 0;\\n            else if (heaters[mid] > house) {\\n                minR = Math.min(minR, heaters[mid] - house);\\n                high = mid - 1;\\n            } else {\\n                minR = Math.min(minR, house - heaters[mid]);\\n                low = mid + 1;\\n            }\\n        }\\n        return minR;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95973,
                "title": "binary-search-in-python",
                "content": "The idea is that for every house, you want to find the closest 2 heaters, and whichever in the 2 that is closer should warm this house. Iterate through the houses, use binary search to find the closest 2 heaters, update answer.\\n\\n```\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        \\n        heaters.sort()\\n        \\n        ans = 0\\n        \\n        for h in houses:\\n            hi = bisect.bisect_left(heaters, h)\\n            left = heaters[hi-1] if hi-1 >= 0 else float('-inf')\\n            right = heaters[hi] if hi < len(heaters) else float('inf')\\n            ans = max(ans, min(h-left, right-h))\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        \\n        heaters.sort()\\n        \\n        ans = 0\\n        \\n        for h in houses:\\n            hi = bisect.bisect_left(heaters, h)\\n            left = heaters[hi-1] if hi-1 >= 0 else float('-inf')\\n            right = heaters[hi] if hi < len(heaters) else float('inf')\\n            ans = max(ans, min(h-left, right-h))\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355888,
                "title": "simple-and-easy-to-understand-c-solution-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        vector <int> v(houses.size(),INT_MAX);\\n\\n        for(int i=0,h=0;i<houses.size() && h<heaters.size();){\\n            if(houses[i]<=heaters[h]){\\n                v[i]=heaters[h]-houses[i];\\n                i++;\\n            }\\n            else{\\n                h++;\\n            }\\n        }\\n\\n        for(int i=houses.size()-1,h=heaters.size()-1;i>=0 && h>=0;){\\n            if(houses[i]>=heaters[h]){\\n                v[i]=min(houses[i]-heaters[h],v[i]);\\n                i--;\\n            }\\n            else{\\n                h--;\\n            }\\n        }\\n\\n        return *max_element(v.begin(),v.end());\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        vector <int> v(houses.size(),INT_MAX);\\n\\n        for(int i=0,h=0;i<houses.size() && h<heaters.size();){\\n            if(houses[i]<=heaters[h]){\\n                v[i]=heaters[h]-houses[i];\\n                i++;\\n            }\\n            else{\\n                h++;\\n            }\\n        }\\n\\n        for(int i=houses.size()-1,h=heaters.size()-1;i>=0 && h>=0;){\\n            if(houses[i]>=heaters[h]){\\n                v[i]=min(houses[i]-heaters[h],v[i]);\\n                i--;\\n            }\\n            else{\\n                h--;\\n            }\\n        }\\n\\n        return *max_element(v.begin(),v.end());\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013060,
                "title": "c-binary-search-detailed-explanation",
                "content": "# Approach\\n* If we observe carefully we can see that every house will be warmed by its just left heater or just right heater for optimal results.\\n\\n![image](https://assets.leetcode.com/users/images/7e152a78-b57d-4b0c-a6e2-590fc52db2ce_1651824036.3722546.png)\\n\\n* So we can find upper bound of each house position in heaters array to find its next heater on the right.\\n* (Upper bound - 1) will be the heater just on the left.\\n* If upper bound == length then we don\\'t have heater on the right of house as in case of house at 9.\\n* If upper bound == 0 then we don\\'t have heater on the left of the house as in case of house at 2.\\n* We mark the minimum radius required by the house in a map.\\n* Answer will be the maximum radius required stored in map.\\n\\n```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        \\n        int i, n = houses.size(), m = heaters.size();  \\n        int ans = INT_MIN, nextHeater, prevHeater, curr;\\n        \\n        map<int, int> mp;\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        \\n        for(i=0;i<n;i++)\\n        {\\n            curr = houses[i];\\n            nextHeater = upper_bound(heaters.begin(), heaters.end(), curr) - heaters.begin();\\n            prevHeater = nextHeater - 1;\\n            \\n            if(nextHeater == 0)\\n                mp[houses[i]] = heaters[nextHeater] - houses[i];\\n            else if (nextHeater == m)\\n                mp[houses[i]] = houses[i] - heaters[prevHeater];\\n            else\\n                mp[houses[i]] = min(heaters[nextHeater] - houses[i], houses[i] - heaters[prevHeater]);\\n        }\\n        for(auto el : mp)\\n            ans = max(ans, el.second);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Please upvote if you liked the explanation.***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        \\n        int i, n = houses.size(), m = heaters.size();  \\n        int ans = INT_MIN, nextHeater, prevHeater, curr;\\n        \\n        map<int, int> mp;\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        \\n        for(i=0;i<n;i++)\\n        {\\n            curr = houses[i];\\n            nextHeater = upper_bound(heaters.begin(), heaters.end(), curr) - heaters.begin();\\n            prevHeater = nextHeater - 1;\\n            \\n            if(nextHeater == 0)\\n                mp[houses[i]] = heaters[nextHeater] - houses[i];\\n            else if (nextHeater == m)\\n                mp[houses[i]] = houses[i] - heaters[prevHeater];\\n            else\\n                mp[houses[i]] = min(heaters[nextHeater] - houses[i], houses[i] - heaters[prevHeater]);\\n        }\\n        for(auto el : mp)\\n            ans = max(ans, el.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700540,
                "title": "clear-explanation-with-c-code-binary-search-on-answer",
                "content": "```\\n\\n// This is the check function here if the current mid value satsisfies the answer we will return true else we will return false;\\n\\nbool check(int mid,vector<int>& houses, vector<int>& heaters)\\n    {\\n      int  n=heaters.size();\\n        for(auto h:houses )\\n        {\\n             auto m=lower_bound(heaters.begin(),heaters.end(),h-mid)-heaters.begin(); \\n\\t\\t\\t //Here we will check that if the current house has some heater in the range between  h-mid && h+mid;\\n\\t\\t\\t // if there is no heater in that range we will return false\\n            if(m==n)\\n            {\\n            return false;\\n            }\\n         \\n            if(heaters[m]>h+mid)\\n            {\\n                return false;\\n            }\\n                                     \\n        }\\nreturn true;\\n    \\n    }\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        // first we will sort the house vector and the heaters vector.\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n       int l,mid,r;\\n        l=0;\\n        \\n        r=1000000000; \\n        while(l<r)\\n        {\\n           mid=l+(r-l)/2;\\n            cout<<mid<<endl;\\n            if(check(mid,houses,heaters))\\n            {\\n                \\n             r=mid;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n```\\nif u have any doubt or any suggestion please do comment",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\n// This is the check function here if the current mid value satsisfies the answer we will return true else we will return false;\\n\\nbool check(int mid,vector<int>& houses, vector<int>& heaters)\\n    {\\n      int  n=heaters.size();\\n        for(auto h:houses )\\n        {\\n             auto m=lower_bound(heaters.begin(),heaters.end(),h-mid)-heaters.begin(); \\n\\t\\t\\t //Here we will check that if the current house has some heater in the range between  h-mid && h+mid;\\n\\t\\t\\t // if there is no heater in that range we will return false\\n            if(m==n)\\n            {\\n            return false;\\n            }\\n         \\n            if(heaters[m]>h+mid)\\n            {\\n                return false;\\n            }\\n                                     \\n        }\\nreturn true;\\n    \\n    }\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        // first we will sort the house vector and the heaters vector.\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n       int l,mid,r;\\n        l=0;\\n        \\n        r=1000000000; \\n        while(l<r)\\n        {\\n           mid=l+(r-l)/2;\\n            cout<<mid<<endl;\\n            if(check(mid,houses,heaters))\\n            {\\n                \\n             r=mid;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1126492,
                "title": "binary-search-solution",
                "content": "JAVA CODE IS:\\n# \\n```\\nclass Solution {\\n    int find(int arr[],int target)\\n    {\\n        int l=0,r=arr.length-1;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(arr[m]==target) return 0;\\n            else if(arr[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        return Math.min(r>=0 ? target-arr[r] : Integer.MAX_VALUE,l<arr.length ? arr[l]-target : Integer.MAX_VALUE);\\n    }\\npublic int findRadius(int[] houses, int[] heaters) \\n{\\n          int res=0; \\n          Arrays.sort(heaters);\\n          for(int pos : houses)\\n             res=Math.max(res,find(heaters,pos)); \\n        return res;\\n    }\\n}\\n```\\nTIME : O(nlogn)\\nSPACE : O(1)\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int find(int arr[],int target)\\n    {\\n        int l=0,r=arr.length-1;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(arr[m]==target) return 0;\\n            else if(arr[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        return Math.min(r>=0 ? target-arr[r] : Integer.MAX_VALUE,l<arr.length ? arr[l]-target : Integer.MAX_VALUE);\\n    }\\npublic int findRadius(int[] houses, int[] heaters) \\n{\\n          int res=0; \\n          Arrays.sort(heaters);\\n          for(int pos : houses)\\n             res=Math.max(res,find(heaters,pos)); \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730893,
                "title": "python-simple-bisect-solution",
                "content": "```\\nimport bisect\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        heaters = [float(\\'-inf\\')]  + heaters + [float(\\'inf\\')]\\n        heaters.sort()\\n        mini = 0\\n        for h in houses:\\n            i = bisect.bisect(heaters, h)\\n            dist = min(abs(heaters[i] - h), abs(heaters[i-1] - h) )\\n            mini = max(mini, dist)\\n        return mini\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        heaters = [float(\\'-inf\\')]  + heaters + [float(\\'inf\\')]\\n        heaters.sort()\\n        mini = 0\\n        for h in houses:\\n            i = bisect.bisect(heaters, h)\\n            dist = min(abs(heaters[i] - h), abs(heaters[i-1] - h) )\\n            mini = max(mini, dist)\\n        return mini\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417895,
                "title": "plain-python-solution-w-o-bisect-lib",
                "content": "I agree that the `bisect` is useful and powerful, but I would like to try to implement it with plain python to see how complicated it is.\\n\\n1. First, we sort the house position array and the heater position array.\\n\\n2. Second, for each house, we make 2 check if it does not locate between two adjecent heaters. If they does not, we could calculate the needed radius with `max` function. \\n\\n3. Third, if the house between 2 heaters, we use binary search to locate the position.\\nWith the left and right pointer, we could get the mid pointer.\\n\\n\\t1. If the house locates just on some heater\\'s position, we do nothing.\\n\\n\\t2. If the house position is lesser than the `heaters[mid]`, we do a further check if the `mid + 1` falls in valid range, and check if  `heater[mid + 1] > h` to know if the house is sorround by  `heater[mid] ` and  `heater[mid + 1]`. If not, just let the binary search continue.\\nAnd the same idea for if the house position is greater than the `heaters[mid]`.\\n\\n\\t- Note that the house must locate between two heaters, so the checking process in the binary search is good enough to get the correct minimum radius for every house.\\n\\n- We keep the left pointer among all the house checking processes, because the left pointer do increase for our house positions is in an ascending order.  This trick did provide some speeding up.\\n\\n```\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        heaters.sort()\\n        houses.sort()\\n        rad = 0\\n        l = 0\\n        for h in houses:\\n            if h < heaters[0]:\\n                rad = max(rad, heaters[0] - h)\\n            elif h > heaters[-1]:\\n                rad = max(rad, h - heaters[-1])\\n            else:\\n                r = len(heaters) - 1\\n                while l <= r:\\n                    mid = (l + r) // 2\\n                    if heaters[mid] == h:\\n                        break\\n                    if h < heaters[mid]:\\n                        if mid - 1 >= 0 and heaters[mid - 1] < h:\\n                            rad = max(rad, min(h - heaters[mid-1], heaters[mid] - h))\\n                            break\\n                        r = mid - 1\\n                    else:\\n                        if mid + 1 < len(heaters) and heaters[mid + 1] > h:\\n                            rad = max(rad, min(h - heaters[mid], heaters[mid+1] - h))\\n                            break\\n                        l = mid + 1\\n        return rad\\n```\\nAt last, the result I got is listed as below.\\n\\n> Runtime: 500 ms, faster than 13.21% of Python3 online submissions for Heaters.\\n> Memory Usage: 17.2 MB, less than 8.33% of Python3 online submissions for Heaters.\\n\\nConclusion: Use bisect to save your lifetime.\\nThanks for reading.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        heaters.sort()\\n        houses.sort()\\n        rad = 0\\n        l = 0\\n        for h in houses:\\n            if h < heaters[0]:\\n                rad = max(rad, heaters[0] - h)\\n            elif h > heaters[-1]:\\n                rad = max(rad, h - heaters[-1])\\n            else:\\n                r = len(heaters) - 1\\n                while l <= r:\\n                    mid = (l + r) // 2\\n                    if heaters[mid] == h:\\n                        break\\n                    if h < heaters[mid]:\\n                        if mid - 1 >= 0 and heaters[mid - 1] < h:\\n                            rad = max(rad, min(h - heaters[mid-1], heaters[mid] - h))\\n                            break\\n                        r = mid - 1\\n                    else:\\n                        if mid + 1 < len(heaters) and heaters[mid + 1] > h:\\n                            rad = max(rad, min(h - heaters[mid], heaters[mid+1] - h))\\n                            break\\n                        l = mid + 1\\n        return rad\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388674,
                "title": "easy-c-solution-using-binary-search",
                "content": "Runtime: 80 ms, faster than 74.46% of C++ online submissions for Heaters.\\nMemory Usage: 11.2 MB, less than 71.43% of C++ online submissions for Heaters.\\n\\n```\\nint findRadius(vector<int>& houses, vector<int>& heaters) {\\n        \\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        int res = 0;\\n        int low = 0;\\n        int high;\\n        \\n        for(int h : houses)\\n        {\\n            high = heaters.size() - 1;\\n            if(heaters[low] == h || heaters[high] == h)\\n                continue;\\n            \\n            while(high - low > 1)\\n            {\\n                int mid = (high + low) >> 1;\\n                \\n                if(heaters[mid] > h)\\n                    high = mid;\\n                else\\n                    low = mid;\\n            }\\n            \\n            res = max(res, min(abs(heaters[low] - h), abs(heaters[high] - h)));\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "Runtime: 80 ms, faster than 74.46% of C++ online submissions for Heaters.\\nMemory Usage: 11.2 MB, less than 71.43% of C++ online submissions for Heaters.\\n\\n```\\nint findRadius(vector<int>& houses, vector<int>& heaters) {\\n        \\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        int res = 0;\\n        int low = 0;\\n        int high;\\n        \\n        for(int h : houses)\\n        {\\n            high = heaters.size() - 1;\\n            if(heaters[low] == h || heaters[high] == h)\\n                continue;\\n            \\n            while(high - low > 1)\\n            {\\n                int mid = (high + low) >> 1;\\n                \\n                if(heaters[mid] > h)\\n                    high = mid;\\n                else\\n                    low = mid;\\n            }\\n            \\n            res = max(res, min(abs(heaters[low] - h), abs(heaters[high] - h)));\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3281181,
                "title": "475-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Sort the houses and heaters in ascending order.\\n2. Initialize a variable result to 0.\\n3. For each house, find the closest heater to the left and right using binary search (i.e. use bisect.bisect_right to find the first heater to the right of the house, then subtract 1 to get the closest heater to the left. Do the same with bisect.bisect_left to find the closest heater to the right).\\n4. If the house is to the left of all heaters, use the closest heater to the left and calculate the distance between the house and the heater.\\n5. If the house is to the right of all heaters, use the closest heater to the right and calculate the distance between the house and the heater.\\n6. If the house is between two heaters, use the closer of the two and calculate the distance between the house and the closer heater.\\n7. Update the result variable with the maximum distance calculated so far.\\n8. Return the result variable as the minimum radius of the heaters required to cover all houses.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        # Sort the houses and heaters\\n        houses.sort()\\n        heaters.sort()\\n\\n        # Initialize the result to 0\\n        result = 0\\n\\n        # For each house, find the closest heater to the left and the right\\n        for house in houses:\\n            left = bisect.bisect_right(heaters, house) - 1\\n            right = bisect.bisect_left(heaters, house)\\n\\n            # If the house is to the left of all heaters, use the closest heater to the left\\n            if left < 0:\\n                result = max(result, heaters[0] - house)\\n            # If the house is to the right of all heaters, use the closest heater to the right\\n            elif right >= len(heaters):\\n                result = max(result, house - heaters[-1])\\n            # If the house is between two heaters, use the closer of the two\\n            else:\\n                result = max(result, min(house - heaters[left], heaters[right] - house))\\n\\n        # Return the result\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        # Sort the houses and heaters\\n        houses.sort()\\n        heaters.sort()\\n\\n        # Initialize the result to 0\\n        result = 0\\n\\n        # For each house, find the closest heater to the left and the right\\n        for house in houses:\\n            left = bisect.bisect_right(heaters, house) - 1\\n            right = bisect.bisect_left(heaters, house)\\n\\n            # If the house is to the left of all heaters, use the closest heater to the left\\n            if left < 0:\\n                result = max(result, heaters[0] - house)\\n            # If the house is to the right of all heaters, use the closest heater to the right\\n            elif right >= len(heaters):\\n                result = max(result, house - heaters[-1])\\n            # If the house is between two heaters, use the closer of the two\\n            else:\\n                result = max(result, min(house - heaters[left], heaters[right] - house))\\n\\n        # Return the result\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711430,
                "title": "python-99-84-speed-o-1-memory",
                "content": "# Intuition\\nmax min problem\\n\\n# Approach\\nSort all of the lists.\\nChecking for every house closest heater and solving max min problem.\\nFor example:\\n-1 = heater\\n1 = house\\n\\n1|1|1|1|-1|1|1|1|1|-1|1|1|1|1\\nHere we should try for every house find closest heater. Compare it to max value, which we already have, save if it\\'s necessary. Go next.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$ - worst/average case\\n$$O(n)$$ - best case\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n\\n        if len(heaters) == 1:\\n            return max(abs(houses[0] - heaters[0]), abs(houses[-1] - heaters[0]))\\n\\n        m_value = -1\\n        f, s, ind_heat = heaters[0], heaters[1], 2\\n        for i in range(len(houses)):\\n            while houses[i] > s and ind_heat < len(heaters):\\n                f, s = s, heaters[ind_heat]\\n                ind_heat += 1\\n            m_value = max(m_value, min(abs(houses[i] - f), abs(houses[i] - s)))\\n        return m_value\\n                \\n\\n\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n\\n        if len(heaters) == 1:\\n            return max(abs(houses[0] - heaters[0]), abs(houses[-1] - heaters[0]))\\n\\n        m_value = -1\\n        f, s, ind_heat = heaters[0], heaters[1], 2\\n        for i in range(len(houses)):\\n            while houses[i] > s and ind_heat < len(heaters):\\n                f, s = s, heaters[ind_heat]\\n                ind_heat += 1\\n            m_value = max(m_value, min(abs(houses[i] - f), abs(houses[i] - s)))\\n        return m_value\\n                \\n\\n\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933263,
                "title": "python-easy-understanding-greedy-solution",
                "content": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        res = 0\\n        heater = 0\\n        \\n        for h in houses:\\n            while heater + 1 < len(heaters) and heaters[heater + 1] == heaters[heater]:                  # Avoid duplicates\\n                heater += 1\\n            while heater + 1 < len(heaters) and abs(heaters[heater + 1] - h) < abs(heaters[heater] - h): # If using next heater is more efficient\\n                heater += 1                                                                              # Then use next heater\\n            \\n            res = max(res, abs(heaters[heater] - h))        # Update its range to house\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        res = 0\\n        heater = 0\\n        \\n        for h in houses:\\n            while heater + 1 < len(heaters) and heaters[heater + 1] == heaters[heater]:                  # Avoid duplicates\\n                heater += 1\\n            while heater + 1 < len(heaters) and abs(heaters[heater + 1] - h) < abs(heaters[heater] - h): # If using next heater is more efficient\\n                heater += 1                                                                              # Then use next heater\\n            \\n            res = max(res, abs(heaters[heater] - h))        # Update its range to house\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1618366,
                "title": "a-3-point-stencil-solution-inspired-from-fluid-dynamics",
                "content": "- Sort both the arrays, `houses` and `heaters`\\n- Let `N=sizeof(houses), M=sizeof(heaters)` \\n- Keep two pointers, `i for indexing houses`, `j for indexing heaters`\\n- For every `houses[i]`, compute its distance from the heaters `heaters[j-1], heaters[j], heaters[j+1]` i.e.,\\n-- `abs(heaters[j-1] - houses[i])`\\n-- `abs(heaters[j+1] - houses[i])`\\n-- `abs(heaters[j] - houses[i])`\\nCompute the minimum of these distances. Maximize this minimum for all `i={0, ..., N-1}`\\n\\n```\\n            |  i  |\\n    |  j-1  |  j  | j+1 |\\t\\t \\n```\\nIn (computational) Fluid Dynamics, this kind of strategy is used often for reconstrcting and limiting solutions. For example, `(heaters[j+1]-heaters[j])/dx` is nothing but forward difference, whereas `(heaters[j]-heaters[j-1])/dx` denotes backward difference. The forward and backward differences are an approximation to the gradient of a quantity (first order Taylor expansion). For sufficiently small `dx`, both the values must be close. If not, then there is an issue in the computed solution. It\\'s called `shock`.\\n\\n```\\nint findRadius(vector<int>& houses, vector<int>& heaters) {\\n\\tint dist = 0;\\n\\n\\tsort(houses.begin(), houses.end());\\n\\tsort(heaters.begin(), heaters.end());\\n\\n\\tint N = houses.size();\\n\\tint M = heaters.size();\\n\\tint i=0, j=0;\\n\\n\\twhile(i<N && j<M) {            \\n\\t\\tif(houses[i]<=heaters[j]) {\\n\\t\\t\\tint left   = j-1>=0 ? abs(heaters[j-1]-houses[i]) : INT_MAX;\\n\\t\\t\\tint center =          abs(heaters[j]-houses[i]);\\n\\t\\t\\tint right  = j+1<M  ? abs(heaters[j+1]-houses[i]) : INT_MAX;\\n\\t\\t\\tdist = max(dist, min({left, center, right}));\\n\\t\\t\\t++i;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t++j;\\n\\t\\t}\\n\\t}\\n\\n\\tif(i<N) { dist = max(dist, abs(heaters.back()-houses.back())); }\\n\\n\\treturn dist;\\n}\\n```\\n\\nSince we have sorted `heaters`, we know that `heaters[j+1] >= heaters[j]`, therefore we can eliminate the comparison to right stencil `j+1`\\n\\n```\\nint findRadius(vector<int>& houses, vector<int>& heaters) {\\n\\tint dist = 0;\\n\\n\\tsort(houses.begin(), houses.end());\\n\\tsort(heaters.begin(), heaters.end());\\n\\n\\tint N = houses.size();\\n\\tint M = heaters.size();\\n\\tint i=0, j=0;\\n\\n\\twhile(i<N && j<M) {            \\n\\t\\tif(houses[i]<=heaters[j]) {\\n\\t\\t\\tint left   = j-1>=0 ? (houses[i]-heaters[j-1]) : INT_MAX;\\n\\t\\t\\tint center =          (heaters[j]-houses[i]);\\n\\t\\t\\tdist = max(dist, min(left, center));\\n\\t\\t\\t++i;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t++j;\\n\\t\\t}\\n\\t}\\n\\n\\tif(i<N) { dist = max(dist, abs(heaters.back()-houses.back())); }\\n\\n\\treturn dist;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n            |  i  |\\n    |  j-1  |  j  | j+1 |\\t\\t \\n```\n```\\nint findRadius(vector<int>& houses, vector<int>& heaters) {\\n\\tint dist = 0;\\n\\n\\tsort(houses.begin(), houses.end());\\n\\tsort(heaters.begin(), heaters.end());\\n\\n\\tint N = houses.size();\\n\\tint M = heaters.size();\\n\\tint i=0, j=0;\\n\\n\\twhile(i<N && j<M) {            \\n\\t\\tif(houses[i]<=heaters[j]) {\\n\\t\\t\\tint left   = j-1>=0 ? abs(heaters[j-1]-houses[i]) : INT_MAX;\\n\\t\\t\\tint center =          abs(heaters[j]-houses[i]);\\n\\t\\t\\tint right  = j+1<M  ? abs(heaters[j+1]-houses[i]) : INT_MAX;\\n\\t\\t\\tdist = max(dist, min({left, center, right}));\\n\\t\\t\\t++i;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t++j;\\n\\t\\t}\\n\\t}\\n\\n\\tif(i<N) { dist = max(dist, abs(heaters.back()-houses.back())); }\\n\\n\\treturn dist;\\n}\\n```\n```\\nint findRadius(vector<int>& houses, vector<int>& heaters) {\\n\\tint dist = 0;\\n\\n\\tsort(houses.begin(), houses.end());\\n\\tsort(heaters.begin(), heaters.end());\\n\\n\\tint N = houses.size();\\n\\tint M = heaters.size();\\n\\tint i=0, j=0;\\n\\n\\twhile(i<N && j<M) {            \\n\\t\\tif(houses[i]<=heaters[j]) {\\n\\t\\t\\tint left   = j-1>=0 ? (houses[i]-heaters[j-1]) : INT_MAX;\\n\\t\\t\\tint center =          (heaters[j]-houses[i]);\\n\\t\\t\\tdist = max(dist, min(left, center));\\n\\t\\t\\t++i;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t++j;\\n\\t\\t}\\n\\t}\\n\\n\\tif(i<N) { dist = max(dist, abs(heaters.back()-houses.back())); }\\n\\n\\treturn dist;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1506995,
                "title": "simple-c-easy-to-understand-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        int m=heaters.size(),n=houses.size(),pos=0,z=0;\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int no=houses[i];\\n            while(pos+1<m && (abs(heaters[pos+1]-no)<=abs(heaters[pos]-no)))\\n                pos++;\\n            z=max(z,abs(heaters[pos]-no));\\n        }\\n        return z;\\n    }\\n};\\nUpvote if you like :)",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1498356,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& house, vector<int>& heaters) \\n    {\\n        sort(house.begin(),house.end());\\n        sort(heaters.begin(),heaters.end());\\n        int ans=0;\\n        for(int i=0;i<house.size();i++)\\n        {\\n            int idx=lower_bound(heaters.begin(),heaters.end(),house[i])-heaters.begin();\\n            int x=INT_MAX,y=INT_MAX;\\n            if(idx<heaters.size())\\n            {\\n                y=heaters[idx]-house[i];\\n            }\\n            if(idx-1>=0)\\n            {\\n                x=house[i]-heaters[idx-1];\\n            }\\n            int temp=min(x,y);\\n            ans=max(temp,ans);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int findRadius(vector<int>& house, vector<int>& heaters) \\n    {\\n        sort(house.begin(),house.end());\\n        sort(heaters.begin(),heaters.end());\\n        int ans=0;\\n        for(int i=0;i<house.size();i++)\\n        {\\n            int idx=lower_bound(heaters.begin(),heaters.end(),house[i])-heaters.begin();\\n            int x=INT_MAX,y=INT_MAX;\\n            if(idx<heaters.size())\\n            {\\n                y=heaters[idx]-house[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1246254,
                "title": "python-solution-using-binary-sort",
                "content": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        n=len(heaters)\\n        d={}\\n        # setting maximum value for each house so that we can find minimum aterwords\\n        for i in houses:\\n            d[i]=float(inf)\\n            \\n        for i in houses:\\n            low=0\\n            high=n\\n            \\n            while(low<high):\\n                mid= low+(high-low)//2\\n                \\n                if heaters[mid]==i:\\n                    d[i]=abs(i-heaters[mid])\\n                    break\\n                elif heaters[mid]<i:\\n                    low=mid+1\\n                    d[i]=min(d[i],abs(i-heaters[mid]))\\n                else:\\n                    high=mid\\n                    d[i]=min(d[i],abs(i-heaters[mid]))\\n        #print(d)\\n        res=0\\n        for i in d:\\n            res=max(res,d[i])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        n=len(heaters)\\n        d={}\\n        # setting maximum value for each house so that we can find minimum aterwords\\n        for i in houses:\\n            d[i]=float(inf)\\n            \\n        for i in houses:\\n            low=0\\n            high=n\\n            \\n            while(low<high):\\n                mid= low+(high-low)//2\\n                \\n                if heaters[mid]==i:\\n                    d[i]=abs(i-heaters[mid])\\n                    break\\n                elif heaters[mid]<i:\\n                    low=mid+1\\n                    d[i]=min(d[i],abs(i-heaters[mid]))\\n                else:\\n                    high=mid\\n                    d[i]=min(d[i],abs(i-heaters[mid]))\\n        #print(d)\\n        res=0\\n        for i in d:\\n            res=max(res,d[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957176,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(), heaters.end() );\\n        int minR = 0;\\n        for( auto x : houses ){\\n            int l=0, r=heaters.size()-1;\\n            while( l < r ){\\n                int mid = l + r >> 1;\\n                if( heaters[mid] >= x )\\n                    r = mid;\\n                else\\n                    l = mid + 1;\\n            }\\n            int dist = r > 0 ? min(x-heaters[r-1], abs(x-heaters[r])) : abs(x-heaters[r]);\\n            minR = max(minR, dist);\\n        }\\n        \\n        return minR;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(), heaters.end() );\\n        int minR = 0;\\n        for( auto x : houses ){\\n            int l=0, r=heaters.size()-1;\\n            while( l < r ){\\n                int mid = l + r >> 1;\\n                if( heaters[mid] >= x )\\n                    r = mid;\\n                else\\n                    l = mid + 1;\\n            }\\n            int dist = r > 0 ? min(x-heaters[r-1], abs(x-heaters[r])) : abs(x-heaters[r]);\\n            minR = max(minR, dist);\\n        }\\n        \\n        return minR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329868,
                "title": "python-one-pass-through-houses",
                "content": "* one pass solution\\n* run time O(L(houses) + 2nlogn), space O(1)\\n```\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        N, i, r = len(heaters), 0, 0\\n        for house in houses:\\n            while i+1 < N and heaters[i+1] < house:\\n                i += 1\\n            r = max(r, min([abs(heat - house) for heat in heaters[i:i+2]]))\\n            # print(r)\\n        return r\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        N, i, r = len(heaters), 0, 0\\n        for house in houses:\\n            while i+1 < N and heaters[i+1] < house:\\n                i += 1\\n            r = max(r, min([abs(heat - house) for heat in heaters[i:i+2]]))\\n            # print(r)\\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 95906,
                "title": "python-8-lines-short-and-clean",
                "content": "For each house find distance to closest heater.  Take the max distance of these which is the radius needed.\\n```\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        houses.sort()\\n        heaters.sort()\\n        j,radius = 0,0\\n        for house in houses:\\n            while j+1 < len(heaters) and abs(heaters[j+1]-house) <= abs(heaters[j]-house):\\n                j += 1\\n            radius = max(radius,abs(heaters[j]-house))\\n        return radius",
                "solutionTags": [],
                "code": "For each house find distance to closest heater.  Take the max distance of these which is the radius needed.\\n```\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        houses.sort()\\n        heaters.sort()\\n        j,radius = 0,0\\n        for house in houses:\\n            while j+1 < len(heaters) and abs(heaters[j+1]-house) <= abs(heaters[j]-house):\\n                j += 1\\n            radius = max(radius,abs(heaters[j]-house))\\n        return radius",
                "codeTag": "Java"
            },
            {
                "id": 95934,
                "title": "17-lines-of-code-o-n-logn-simple-java-solution",
                "content": "Just traverse houses array from left to right and greedily pickup the closest heater.\\n\\n```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        int heaterIdx = 0;\\n        int res = 0;\\n        for (int i = 0; i < houses.length; i++) {\\n            while (heaterIdx != heaters.length - 1 && Math.abs(heaters[heaterIdx + 1] - houses[i]) <= Math.abs(heaters[heaterIdx] - houses[i])) {\\n                heaterIdx++;\\n            }\\n            \\n            res = Math.max(res, Math.abs(heaters[heaterIdx] - houses[i]));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        int heaterIdx = 0;\\n        int res = 0;\\n        for (int i = 0; i < houses.length; i++) {\\n            while (heaterIdx != heaters.length - 1 && Math.abs(heaters[heaterIdx + 1] - houses[i]) <= Math.abs(heaters[heaterIdx] - houses[i])) {\\n                heaterIdx++;\\n            }\\n            \\n            res = Math.max(res, Math.abs(heaters[heaterIdx] - houses[i]));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95983,
                "title": "java-easy-solution-with-explanation",
                "content": "The basic idea is that, for every house location in the `houses` array, we try to locate the positions of the heaters right before and after this house, and calculate the distances.\\n\\n```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        // pre represents the heater that's ahead of the current house\\n        int pre = heaters[0];\\n        // index of the heater\\n        int i = 0;\\n        int res = 0;\\n        for (int house : houses) {\\n            // looking for the heater that's immediately after the current house\\n            while (i < heaters.length - 1 && heaters[i] < house) {\\n                pre = heaters[i];\\n                i++;\\n            }\\n            \\n            int distanceToPreHeater = Math.abs(house - pre);\\n            int distanceToAfterHeater = Math.abs(house - heaters[i]);\\n            res = Math.max(res, Math.min(distanceToPreHeater, distanceToAfterHeater));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        // pre represents the heater that's ahead of the current house\\n        int pre = heaters[0];\\n        // index of the heater\\n        int i = 0;\\n        int res = 0;\\n        for (int house : houses) {\\n            // looking for the heater that's immediately after the current house\\n            while (i < heaters.length - 1 && heaters[i] < house) {\\n                pre = heaters[i];\\n                i++;\\n            }\\n            \\n            int distanceToPreHeater = Math.abs(house - pre);\\n            int distanceToAfterHeater = Math.abs(house - heaters[i]);\\n            res = Math.max(res, Math.min(distanceToPreHeater, distanceToAfterHeater));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632431,
                "title": "c-solution-binary-search-on-answer-short-readable-and-concise",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    // time complexity of check func. is O(m+n) \\n    // where m and n are size of houses and heaters respectively\\n    bool check(int mid,vector<int>& houses, vector<int>& heaters){\\n        int i = 0,j = 0;\\n        while(j<heaters.size()){\\n            int leftLimit = heaters[j]-mid;\\n            int rightLimit = heaters[j]+mid;\\n            if(i<houses.size() && houses[i]<leftLimit){\\n                return false;\\n            }\\n            while(i<houses.size() && houses[i]>=leftLimit && houses[i]<=rightLimit){\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i!=houses.size()) return false;\\n        return true;\\n    }\\n\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        int l = 0,h = 1e9;\\n        int ans = -1;\\n        while(l<=h){\\n            int mid = l+(h-l)/2;\\n            if(check(mid,houses,heaters)){\\n                ans = mid;\\n                h = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // time complexity of check func. is O(m+n) \\n    // where m and n are size of houses and heaters respectively\\n    bool check(int mid,vector<int>& houses, vector<int>& heaters){\\n        int i = 0,j = 0;\\n        while(j<heaters.size()){\\n            int leftLimit = heaters[j]-mid;\\n            int rightLimit = heaters[j]+mid;\\n            if(i<houses.size() && houses[i]<leftLimit){\\n                return false;\\n            }\\n            while(i<houses.size() && houses[i]>=leftLimit && houses[i]<=rightLimit){\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(i!=houses.size()) return false;\\n        return true;\\n    }\\n\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        int l = 0,h = 1e9;\\n        int ans = -1;\\n        while(l<=h){\\n            int mid = l+(h-l)/2;\\n            if(check(mid,houses,heaters)){\\n                ans = mid;\\n                h = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480058,
                "title": "java-sorting-binary-search-two-pointers",
                "content": "### Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n### Code\\n``` java []\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int i=0, j=(int)1e9;\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        while(i<=j){\\n            int mid = (i+j)/2;\\n\\n            if(isPossible(houses,heaters,mid)){\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n        return i;\\n    }\\n\\n\\n    private boolean isPossible(int[] houses,int[] heaters,int r){\\n        int i=0, j=0;\\n        while(i<houses.length){\\n            if(houses[i]<heaters[j]-r){\\n                return false;\\n            }\\n            if(houses[i]>heaters[j]+r){\\n                if(++j==heaters.length){\\n                    return false;\\n                }\\n                i--;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int i=0, j=(int)1e9;\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        while(i<=j){\\n            int mid = (i+j)/2;\\n\\n            if(isPossible(houses,heaters,mid)){\\n                j=mid-1;\\n            }\\n            else{\\n                i=mid+1;\\n            }\\n        }\\n        return i;\\n    }\\n\\n\\n    private boolean isPossible(int[] houses,int[] heaters,int r){\\n        int i=0, j=0;\\n        while(i<houses.length){\\n            if(houses[i]<heaters[j]-r){\\n                return false;\\n            }\\n            if(houses[i]>heaters[j]+r){\\n                if(++j==heaters.length){\\n                    return false;\\n                }\\n                i--;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332260,
                "title": "easy-approach-using-bs-must-read-the-approach-to-understand-the-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas we read question we get to find that we need the min distance between the house and the heater on both the side of the house . From this we get to know that we need the floor and ceil value for every house , inorder to get the min distance to warm the house.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfinding the floor and ceil distance for each house from the heater.\\n# Complexity\\n- Time complexity:n(logm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int BSf(vector<int>&heaters,int key){\\n        int low=0;\\n        int res=-1;\\n        int high=heaters.size()-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(heaters[mid]==key){\\n                return 0;\\n            }else if(heaters[mid]>key){\\n                high=mid-1;\\n            }else if(heaters[mid]<key){\\n                res=key-heaters[mid];\\n                low=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n       int BSc(vector<int>&heaters,int key){\\n        int low=0;\\n        int res=-1;\\n        int high=heaters.size()-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(heaters[mid]==key){\\n                return 0;\\n            }else if(heaters[mid]>key){\\n                res=heaters[mid]-key;\\n               high=mid-1;\\n            }else if(heaters[mid]<key){\\n                low=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {     int n=houses.size();\\n        sort(heaters.begin(),heaters.end());\\n        vector<int>a;\\n        for(int i=0;i<n;i++){\\n            int x=BSf(heaters,houses[i]);\\n            int y=BSc(heaters,houses[i]);\\n            cout<<x<<y<<endl;\\n            if(x==-1){\\n                a.push_back(y);\\n            }else if(y==-1){\\n                a.push_back(x);\\n            }else{\\n                a.push_back(min(x,y));\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<a.size();i++){\\n            ans=max(ans,a[i]);\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int BSf(vector<int>&heaters,int key){\\n        int low=0;\\n        int res=-1;\\n        int high=heaters.size()-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(heaters[mid]==key){\\n                return 0;\\n            }else if(heaters[mid]>key){\\n                high=mid-1;\\n            }else if(heaters[mid]<key){\\n                res=key-heaters[mid];\\n                low=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n       int BSc(vector<int>&heaters,int key){\\n        int low=0;\\n        int res=-1;\\n        int high=heaters.size()-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(heaters[mid]==key){\\n                return 0;\\n            }else if(heaters[mid]>key){\\n                res=heaters[mid]-key;\\n               high=mid-1;\\n            }else if(heaters[mid]<key){\\n                low=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {     int n=houses.size();\\n        sort(heaters.begin(),heaters.end());\\n        vector<int>a;\\n        for(int i=0;i<n;i++){\\n            int x=BSf(heaters,houses[i]);\\n            int y=BSc(heaters,houses[i]);\\n            cout<<x<<y<<endl;\\n            if(x==-1){\\n                a.push_back(y);\\n            }else if(y==-1){\\n                a.push_back(x);\\n            }else{\\n                a.push_back(min(x,y));\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<a.size();i++){\\n            ans=max(ans,a[i]);\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2546300,
                "title": "java-short-simple-maximum-of-all-minimum-distances",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {    \\n        // calculate the minimum distance to each heater for each house.\\n        // get the maximum of the minimum\\n        // assume heaters and houses are sorted\\n        int maxMin = Integer.MIN_VALUE;\\n        for(int h : houses){\\n            int houseMin = Integer.MAX_VALUE;\\n            for(int heater : heaters){\\n                houseMin = Math.min(Math.abs(heater - h), houseMin);\\n            }\\n            if(houseMin > maxMin) maxMin = houseMin;\\n        }\\n        return maxMin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {    \\n        // calculate the minimum distance to each heater for each house.\\n        // get the maximum of the minimum\\n        // assume heaters and houses are sorted\\n        int maxMin = Integer.MIN_VALUE;\\n        for(int h : houses){\\n            int houseMin = Integer.MAX_VALUE;\\n            for(int heater : heaters){\\n                houseMin = Math.min(Math.abs(heater - h), houseMin);\\n            }\\n            if(houseMin > maxMin) maxMin = houseMin;\\n        }\\n        return maxMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337618,
                "title": "c-binary-search-99-faster-clean-solution",
                "content": "PLEASE UPVOTE IF THIS SOLUTION HELPS YOU\\n\\n```\\n int distance(vector<int> &nums,int key)\\n    { \\n        int low = 0;\\n        int high = nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid = low + ((high-low)>>1);\\n            \\n            if(nums[mid] == key)\\n            {\\n                return 0;\\n            }\\n            else if(nums[mid]>key)\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        if(low == nums.size())\\n            return key-nums[high];\\n        else if(high == -1)\\n             return nums[low]-key;\\n        \\n        return min(nums[low]-key,key-nums[high]);\\n    }\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        ios::sync_with_stdio(NULL);\\n        cin.tie(NULL);\\n        sort(heaters.begin(),heaters.end());\\n        \\n        int ans = INT_MIN;\\n        for(int h : houses)\\n        {\\n            int dis = distance(heaters,h);\\n            ans = max(dis,ans);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n int distance(vector<int> &nums,int key)\\n    { \\n        int low = 0;\\n        int high = nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid = low + ((high-low)>>1);\\n            \\n            if(nums[mid] == key)\\n            {\\n                return 0;\\n            }\\n            else if(nums[mid]>key)\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        if(low == nums.size())\\n            return key-nums[high];\\n        else if(high == -1)\\n             return nums[low]-key;\\n        \\n        return min(nums[low]-key,key-nums[high]);\\n    }\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        ios::sync_with_stdio(NULL);\\n        cin.tie(NULL);\\n        sort(heaters.begin(),heaters.end());\\n        \\n        int ans = INT_MIN;\\n        for(int h : houses)\\n        {\\n            int dis = distance(heaters,h);\\n            ans = max(dis,ans);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2058096,
                "title": "simple-c-sort-first-then-apply-two-pointers",
                "content": "Sort both arrays. Then use two pointers to get the distance between house A and closest heater.\\n```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        int res=0, m=houses.size(), n=heaters.size();\\n        int i=0, j=0;  //two pointers\\n        while(i<m && j<n) {\\n            while (j<n && houses[i]>=heaters[j]) j++;  //find the first heater over houses[i]\\n            if (j<n) {\\n                int dist = (j==0)?heaters[0]-houses[i]:min(houses[i]-heaters[j-1], heaters[j]-houses[i]);\\n                res = max(dist, res); \\n                i++;\\n            }\\n        }\\n        \\n        while(i<m) res = max(res, houses[i++]-heaters.back());\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        int res=0, m=houses.size(), n=heaters.size();\\n        int i=0, j=0;  //two pointers\\n        while(i<m && j<n) {\\n            while (j<n && houses[i]>=heaters[j]) j++;  //find the first heater over houses[i]\\n            if (j<n) {\\n                int dist = (j==0)?heaters[0]-houses[i]:min(houses[i]-heaters[j-1], heaters[j]-houses[i]);\\n                res = max(dist, res); \\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1813779,
                "title": "binary-search-python",
                "content": "\\n```\\nIn a anutshell, \\n\\tFor each house, we find the distance to the nearest heater.\\nMax of the above distances, is the result.\\n\\nFor eg:\\n\\nhouses        1 2 3 4 5\\nheaters         h.    h\\n\\nfor house 1,\\n\\tnearest heater is at distance 1, i.e at position 2\\nfor house 2,\\n\\tnearest heater is at distance 0, i.e at position 2\\nfor house 3,\\n\\tnearest heater is at distance 1, i.e at position 2\\nfor house 4,\\n\\tnearest heater is at distance 1, i.e at position 5\\nfor house 5,\\n\\tnearest heater is at distance 0, i.e at position 5\\n\\nthe maximum of all the above distances = max(1, 0, 1, 1, 0) = 1 (answer)\\n\\nFor finding nearest heater, we can use binary search ( O(logn) time complexity )\\n\\n```\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n       \\n        heaters.sort() # so that we can use binary search\\n        result = float(\"-inf\")\\n        for house in houses:\\n            distanceToNearestHeater = self.bs(house, heaters)\\n            result = max(result, distanceToNearestHeater)\\n        return result\\n            \\n    def bs(self, house, heaters):\\n        if len(heaters) == 1: # if only 1 heater present, then its obvious\\n            return abs(house - heaters[0])\\n        \\n        left = 0\\n        right = len(heaters) - 1\\n        justGreater, justSmaller = -1, -1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if house == heaters[mid]: # if heater at position of house, 0 distance\\n                return 0\\n            \\n            if house < heaters[mid]:\\n                justGreater = heaters[mid]\\n                right = mid - 1\\n            else:\\n                justSmaller = heaters[mid]\\n                left = mid + 1\\n                \\n        # if we have 2 heaters available, return min of, distance from house to those heaters.\\n        if justGreater != -1 and justSmaller != -1: \\n            return min(abs(house - justGreater), abs(house - justSmaller))\\n        \\n        # if we dont have a heater towards right, return distance from house to nearest left heater\\n        if justGreater == -1:\\n            return abs(house - justSmaller)\\n        # if we dont have a heater towards left, return distance from house to nearest right heater\\n        else:\\n            return abs(house - justGreater)\\n```\\n\\nTime Complexity - O(nlogn)\\nSpace Complexity - O(1)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nIn a anutshell, \\n\\tFor each house, we find the distance to the nearest heater.\\nMax of the above distances, is the result.\\n\\nFor eg:\\n\\nhouses        1 2 3 4 5\\nheaters         h.    h\\n\\nfor house 1,\\n\\tnearest heater is at distance 1, i.e at position 2\\nfor house 2,\\n\\tnearest heater is at distance 0, i.e at position 2\\nfor house 3,\\n\\tnearest heater is at distance 1, i.e at position 2\\nfor house 4,\\n\\tnearest heater is at distance 1, i.e at position 5\\nfor house 5,\\n\\tnearest heater is at distance 0, i.e at position 5\\n\\nthe maximum of all the above distances = max(1, 0, 1, 1, 0) = 1 (answer)\\n\\nFor finding nearest heater, we can use binary search ( O(logn) time complexity )\\n\\n```\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n       \\n        heaters.sort() # so that we can use binary search\\n        result = float(\"-inf\")\\n        for house in houses:\\n            distanceToNearestHeater = self.bs(house, heaters)\\n            result = max(result, distanceToNearestHeater)\\n        return result\\n            \\n    def bs(self, house, heaters):\\n        if len(heaters) == 1: # if only 1 heater present, then its obvious\\n            return abs(house - heaters[0])\\n        \\n        left = 0\\n        right = len(heaters) - 1\\n        justGreater, justSmaller = -1, -1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if house == heaters[mid]: # if heater at position of house, 0 distance\\n                return 0\\n            \\n            if house < heaters[mid]:\\n                justGreater = heaters[mid]\\n                right = mid - 1\\n            else:\\n                justSmaller = heaters[mid]\\n                left = mid + 1\\n                \\n        # if we have 2 heaters available, return min of, distance from house to those heaters.\\n        if justGreater != -1 and justSmaller != -1: \\n            return min(abs(house - justGreater), abs(house - justSmaller))\\n        \\n        # if we dont have a heater towards right, return distance from house to nearest left heater\\n        if justGreater == -1:\\n            return abs(house - justSmaller)\\n        # if we dont have a heater towards left, return distance from house to nearest right heater\\n        else:\\n            return abs(house - justGreater)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637749,
                "title": "c-binary-search-easy-to-understand",
                "content": "**475. Heaters**\\n\\nIt\\'s a binary search problem.\\n\\n+ For each house `house[i]` , we should choose its nearest heater, and let `radius[i]` denote the distance between them. This choosing strategy will make the radius of heater as small as possible.\\n+ Among all the houses, each of them will have a ideal radius, and the max value `max(radius[0, ..., i])` is what we want.\\n+ So, we firstly sort the array `heaters`, and perform a binary-search on it to find its nearest house.\\n\\nHint: In this code,`rdis` represent distance between the heater and the nearest house on the heater\\'s right side. So does the `ldis`.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    const int INTMAX = ~(1 << 31);\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(), heaters.end());\\n        int radius = 0, n = heaters.size();\\n        \\n        for (int house : houses)\\n        {\\n            int ridx = upper_bound(heaters.begin(), heaters.end(), house) - heaters.begin();\\n            int lidx = ridx - 1;\\n            \\n            int rdis = ridx >= n ? INTMAX : heaters[ridx] - house;\\n            int ldis = lidx < 0 ? INTMAX : house - heaters[lidx];\\n            \\n            radius = max(radius, min(rdis, ldis));\\n        }\\n        \\n        return radius;\\n    }\\n};\\n```\\n\\nSince the `upper_bound` in STL is a little slow, we can imlpement `binarySearch` by ourselves.\\n```cpp\\nclass Solution {\\npublic:\\n    const int INTMAX = ~(1 << 31);\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(), heaters.end());\\n        int radius = 0, n = heaters.size();\\n        \\n        for (int house : houses)\\n        {\\n            int ridx = binarySearch(heaters, house);\\n            int lidx = ridx - 1;\\n            \\n            int rdis = ridx >= n ? INTMAX : heaters[ridx] - house;\\n            int ldis = lidx < 0 ? INTMAX : house - heaters[lidx];\\n            \\n            radius = max(radius, min(rdis, ldis));\\n        }\\n        \\n        return radius;\\n    }\\n    \\n    int binarySearch(vector<int> &heaters, int val)\\n    {\\n        int n = heaters.size();\\n        int l = 0, r = n - 1;\\n        while (l <= r)\\n        {\\n            int m = l + (r - l) / 2;\\n            if (val < heaters[m]) r = m - 1;\\n            else l = m + 1;\\n        }\\n        if (r < 0) return 0;\\n        return heaters[r] > val ? r : r + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    const int INTMAX = ~(1 << 31);\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(), heaters.end());\\n        int radius = 0, n = heaters.size();\\n        \\n        for (int house : houses)\\n        {\\n            int ridx = upper_bound(heaters.begin(), heaters.end(), house) - heaters.begin();\\n            int lidx = ridx - 1;\\n            \\n            int rdis = ridx >= n ? INTMAX : heaters[ridx] - house;\\n            int ldis = lidx < 0 ? INTMAX : house - heaters[lidx];\\n            \\n            radius = max(radius, min(rdis, ldis));\\n        }\\n        \\n        return radius;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const int INTMAX = ~(1 << 31);\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(), heaters.end());\\n        int radius = 0, n = heaters.size();\\n        \\n        for (int house : houses)\\n        {\\n            int ridx = binarySearch(heaters, house);\\n            int lidx = ridx - 1;\\n            \\n            int rdis = ridx >= n ? INTMAX : heaters[ridx] - house;\\n            int ldis = lidx < 0 ? INTMAX : house - heaters[lidx];\\n            \\n            radius = max(radius, min(rdis, ldis));\\n        }\\n        \\n        return radius;\\n    }\\n    \\n    int binarySearch(vector<int> &heaters, int val)\\n    {\\n        int n = heaters.size();\\n        int l = 0, r = n - 1;\\n        while (l <= r)\\n        {\\n            int m = l + (r - l) / 2;\\n            if (val < heaters[m]) r = m - 1;\\n            else l = m + 1;\\n        }\\n        if (r < 0) return 0;\\n        return heaters[r] > val ? r : r + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636852,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        heaters.sort()\\n        ans = k = 0 \\n        for x in sorted(houses):\\n            while k < len(heaters) and heaters[k] < x: k += 1\\n            cand = inf \\n            if k < len(heaters): cand = min(cand, heaters[k] - x)\\n            if k: cand = min(cand, x - heaters[k-1])\\n            ans = max(ans, cand)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        heaters.sort()\\n        ans = k = 0 \\n        for x in sorted(houses):\\n            while k < len(heaters) and heaters[k] < x: k += 1\\n            cand = inf \\n            if k < len(heaters): cand = min(cand, heaters[k] - x)\\n            if k: cand = min(cand, x - heaters[k-1])\\n            ans = max(ans, cand)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291965,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n     static class Pair{\\n         int floor;\\n         int ceil;\\n         Pair(int floor, int ceil){\\n           this.floor = floor;\\n           this.ceil = ceil;\\n         }\\n     }\\n    public int findRadius(int[] houses, int[] heaters) {\\n        \\n        Arrays.sort(heaters);\\n        int range = 0;\\n        for(int i = 0;i < houses.length ; i++){\\n            int house = houses[i];\\n            Pair p = bs(heaters, house);\\n            int d1 = p.floor == -1 ? Integer.MAX_VALUE : house - p.floor;\\n            int d2 = p.ceil == -1 ? Integer.MAX_VALUE : p.ceil - house;\\n            range = Math.max(range,Math.min(d1,d2));\\n            \\n        }\\n        return range;\\n    }\\n    private Pair bs(int arr[], int val){\\n       int l = 0;\\n       int r = arr.length - 1;\\n       Pair p = new Pair(-1,-1);\\n       \\n      while(l <= r){\\n         int mid = l + (r - l)/2;\\n         if(arr[mid] == val){\\n           return new Pair(arr[mid],arr[mid]);\\n         }\\n        else if(arr[mid] < val){\\n            l = mid + 1;\\n            p.floor = arr[mid];\\n        }\\n        else{\\n          r = mid - 1;\\n          p.ceil = arr[mid];\\n        }\\n      }\\n      return p;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     static class Pair{\\n         int floor;\\n         int ceil;\\n         Pair(int floor, int ceil){\\n           this.floor = floor;\\n           this.ceil = ceil;\\n         }\\n     }\\n    public int findRadius(int[] houses, int[] heaters) {\\n        \\n        Arrays.sort(heaters);\\n        int range = 0;\\n        for(int i = 0;i < houses.length ; i++){\\n            int house = houses[i];\\n            Pair p = bs(heaters, house);\\n            int d1 = p.floor == -1 ? Integer.MAX_VALUE : house - p.floor;\\n            int d2 = p.ceil == -1 ? Integer.MAX_VALUE : p.ceil - house;\\n            range = Math.max(range,Math.min(d1,d2));\\n            \\n        }\\n        return range;\\n    }\\n    private Pair bs(int arr[], int val){\\n       int l = 0;\\n       int r = arr.length - 1;\\n       Pair p = new Pair(-1,-1);\\n       \\n      while(l <= r){\\n         int mid = l + (r - l)/2;\\n         if(arr[mid] == val){\\n           return new Pair(arr[mid],arr[mid]);\\n         }\\n        else if(arr[mid] < val){\\n            l = mid + 1;\\n            p.floor = arr[mid];\\n        }\\n        else{\\n          r = mid - 1;\\n          p.ceil = arr[mid];\\n        }\\n      }\\n      return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892278,
                "title": "clean-and-simple-c-solution-with-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& houses, vector<int>& heaters,long long int d){\\n        int l=0,r=0;\\n        while(l<houses.size()){// checking if heaters satisfy houses with given radius \\n            while(r<heaters.size()&&!((houses[l]>=heaters[r]-d)&&(houses[l]<=heaters[r]+d)))\\n                r++;\\n            if(r>=heaters.size()||(!((houses[l]>=heaters[r]-d)&&(houses[l]<=heaters[r]+d))))\\n                return false;\\n            else l++;\\n        }\\n        return true;\\n    }\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        long long int l=0,r=max(abs(heaters[heaters.size()-1]-houses[0]),abs(heaters[0]-houses[houses.size()-1]))+10;\\n        // l = lower bound for radius ( 0 because heaters position == houses position )\\n        // r = upper bound for radius (difference between last heater and first house or first heater and last house)\\n        long long int ans=0;\\n        while(l<=r){// binary search for radius\\n            long long int mid=(l+r)/2;\\n            if(check(houses,heaters,mid)) // to check if this radius fullfills the houses\\n                ans=mid,r=mid-1; // update answer and continue for smaller radius \\n            else l=mid+1;// houses not fullfilled , search for bigger radius\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& houses, vector<int>& heaters,long long int d){\\n        int l=0,r=0;\\n        while(l<houses.size()){// checking if heaters satisfy houses with given radius \\n            while(r<heaters.size()&&!((houses[l]>=heaters[r]-d)&&(houses[l]<=heaters[r]+d)))\\n                r++;\\n            if(r>=heaters.size()||(!((houses[l]>=heaters[r]-d)&&(houses[l]<=heaters[r]+d))))\\n                return false;\\n            else l++;\\n        }\\n        return true;\\n    }\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        long long int l=0,r=max(abs(heaters[heaters.size()-1]-houses[0]),abs(heaters[0]-houses[houses.size()-1]))+10;\\n        // l = lower bound for radius ( 0 because heaters position == houses position )\\n        // r = upper bound for radius (difference between last heater and first house or first heater and last house)\\n        long long int ans=0;\\n        while(l<=r){// binary search for radius\\n            long long int mid=(l+r)/2;\\n            if(check(houses,heaters,mid)) // to check if this radius fullfills the houses\\n                ans=mid,r=mid-1; // update answer and continue for smaller radius \\n            else l=mid+1;// houses not fullfilled , search for bigger radius\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841064,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * @param {number[]} houses\\n * @param {number[]} heaters\\n * @return {number}\\n */\\nvar findRadius = function(houses, heaters) {\\n    houses.sort((a,b)=> a - b);\\n    heaters.sort((a,b)=> a - b);\\n    var i = 0, res = 0;\\n    for (var house of houses) {\\n        while (i < heaters.length - 1 && heaters[i] + heaters[i + 1] <= house * 2) {\\n                i++;\\n            }\\n        res = Math.max(res, Math.abs(heaters[i] - house));\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} houses\\n * @param {number[]} heaters\\n * @return {number}\\n */\\nvar findRadius = function(houses, heaters) {\\n    houses.sort((a,b)=> a - b);\\n    heaters.sort((a,b)=> a - b);\\n    var i = 0, res = 0;\\n    for (var house of houses) {\\n        while (i < heaters.length - 1 && heaters[i] + heaters[i + 1] <= house * 2) {\\n                i++;\\n            }\\n        res = Math.max(res, Math.abs(heaters[i] - house));\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777806,
                "title": "javascript-simple-solution-beats-100-memory-and-5-time",
                "content": "Hi, \\n\\nI started out with using binary search but reading through the discussions, I found a simpler solution through finding the nearest neighbor and modified @SheryJack001\\'s code to pass all tests.\\n\\n```\\nfunction findNearest(house, heaters) {\\n  let min = 9999999999;\\n  for (let i in heaters) min = Math.min(min, Math.abs(heaters[i] - house));\\n  return min;\\n}\\n\\nvar findRadius = function (houses, heaters) {\\n  let minRadius = 0;\\n  let nearestHeater = 0;\\n  for (let i in houses)\\n    if (!heaters.includes(houses[i])) {\\n      nearestHeater = findNearest(houses[i], heaters);\\n      if (minRadius <= nearestHeater) minRadius = nearestHeater;\\n    }\\n  return minRadius;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findNearest(house, heaters) {\\n  let min = 9999999999;\\n  for (let i in heaters) min = Math.min(min, Math.abs(heaters[i] - house));\\n  return min;\\n}\\n\\nvar findRadius = function (houses, heaters) {\\n  let minRadius = 0;\\n  let nearestHeater = 0;\\n  for (let i in houses)\\n    if (!heaters.includes(houses[i])) {\\n      nearestHeater = findNearest(houses[i], heaters);\\n      if (minRadius <= nearestHeater) minRadius = nearestHeater;\\n    }\\n  return minRadius;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699683,
                "title": "python-binary-search-o-mlogn-solution",
                "content": "\\tclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        # binary search\\n\\t\\t# length of houses --- m\\n\\t\\t# length of heaters --- n\\n        # O(mlogn)time O(1)space (m >= n)\\n        heaters.sort() #O(nlogn)\\n        radius = 0\\n        for h in houses:\\n            distance = self.binary_search(h, heaters)\\n            radius = max(radius, distance)\\n        return radius\\n    \\n    def binary_search(self, house, heaters):\\n        left = 0\\n        right = len(heaters)-1\\n        mid = (left+right)//2\\n        while left <= right:\\n            if house < heaters[mid]:\\n                right = mid - 1\\n            elif house > heaters[mid]:\\n                left = mid + 1\\n            else:\\n                return 0\\n            mid = (left+right)//2\\n        if right < 0:\\n            return heaters[left]-house\\n        elif left > len(heaters)-1:\\n            return house-heaters[right]\\n        else:  \\n            return min(heaters[left]-house, house-heaters[right])\\n\\n        \\n        \\n        \\n        \\n",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "\\tclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        # binary search\\n\\t\\t# length of houses --- m\\n\\t\\t# length of heaters --- n\\n        # O(mlogn)time O(1)space (m >= n)\\n        heaters.sort() #O(nlogn)\\n        radius = 0\\n        for h in houses:\\n            distance = self.binary_search(h, heaters)\\n            radius = max(radius, distance)\\n        return radius\\n    \\n    def binary_search(self, house, heaters):\\n        left = 0\\n        right = len(heaters)-1\\n        mid = (left+right)//2\\n        while left <= right:\\n            if house < heaters[mid]:\\n                right = mid - 1\\n            elif house > heaters[mid]:\\n                left = mid + 1\\n            else:\\n                return 0\\n            mid = (left+right)//2\\n        if right < 0:\\n            return heaters[left]-house\\n        elif left > len(heaters)-1:\\n            return house-heaters[right]\\n        else:  \\n            return min(heaters[left]-house, house-heaters[right])\\n\\n        \\n        \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 539500,
                "title": "java-binary-search-with-explaination",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        \\n        int minHeaterRadius = Integer.MIN_VALUE;\\n        \\n        for (int housePosition: houses) {\\n            int rightHeaterPosition = findClosestRightHeater(heaters, housePosition);\\n            \\n            if (rightHeaterPosition == housePosition) {\\n                minHeaterRadius = Math.max(minHeaterRadius, 0);\\n            } else {\\n                int leftHeaterPosition = rightHeaterPosition > 0 ? rightHeaterPosition - 1 : rightHeaterPosition;\\n                \\n                int leftHeaterDistance = Math.abs(housePosition - heaters[leftHeaterPosition]);\\n                int rightHeaterDistance = Math.abs(housePosition - heaters[rightHeaterPosition]);\\n                \\n                minHeaterRadius = Math.max(minHeaterRadius, Math.min(leftHeaterDistance, rightHeaterDistance));\\n            }\\n        }\\n        \\n        return minHeaterRadius;\\n    }\\n    \\n    private int findClosestRightHeater(int[] heaters, int position) {\\n        int left = 0;\\n        int right = heaters.length - 1;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (heaters[mid] == position) {\\n                return mid;\\n            } else if (heaters[mid] > position) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```\\n\\n**Thoughts before Coding**\\n- For each of the houses, we want to find the distance to the closest heater\\n\\t- We need to keep track of the largest minimum distance, this will be the minimum distance that our heater will need\\n- What is the brute force approach?\\n\\t- For each other the houses, we check all of the heaters to find the closest one\\n\\t\\t- What is the time complexity?\\n\\t\\t\\t- O(house * heater)\\n- Since we are searching for an index, we can use binary search\\n\\t- But, we will need our heaters to be sorted first\\n\\t- We can sort out heaters at O(hlogh) and then our binary search will take O(logh)\\n\\t- Then to find the nearest heater for each house\\n\\t\\t- Our runtime will become O(houses * log(heaters))\\n- What if we can\\'t a heater at our current house\\'s location in the binary search?\\n\\t- We will need to find the closest location to the left/right of our house for the heater\\n\\t\\t- We can do this in 2 binary searches\\n\\t\\t\\t- One binary search is to find the heater at the exact / higher index\\n\\t\\t\\t- One binary search is to find the heater at the lower index (only executes if we did not find exact index)\\n\\t\\t\\t- When searching for our value at the higher index,\\n\\t\\t\\t\\t- if we actually found our target value at an index, we do not need to search the lower index anymore\\n\\t\\t\\t\\t- This is because we already found an index that can give a heater radius of 0\\n\\t\\t- How do we find the heater location at the exact index (right on the house) or a minimum distance that is to the right of our house?\\n\\t\\t\\t- Lets walk through an example\\n\\t\\t\\t\\t- Imagine we have the array [1, 4, 5, 9, 10] and we are trying to look for a heater at position 8\\n\\t\\t\\t\\t\\t- Our middle value will be 5, this is too low, so we search to the right\\n\\t\\t\\t\\t\\t\\t- [9, 10]\\n\\t\\t\\t\\t\\t- Our mid value is now 9, which is greater than 8. This value may be the minimum value that is greater than our target value\\n\\t\\t\\t\\t\\t\\t- we will need to search left, left -> mid (inclusive)\\n\\t\\t\\t\\t\\t\\t- [9]\\n\\t\\t\\t\\t\\t- When our left index equals our right index, we have found the index that we need\\n\\t\\t\\t\\t\\t- What if our middle value equals our target value?\\n\\t\\t\\t\\t\\t\\t- We can just return the mid index, we have found heater at the same location of the house\\n\\t   - If the location of the heater that we search before is not located exactly at the house index\\n\\t\\t\\t- we will need to find the closest left index of our house\\n\\t\\t\\t- Lets walk through the same example\\n\\t\\t\\t\\t- Imagine we have the array [1, 4, 5, 9, 10] and we are trying to look for 8\\n\\t\\t\\t\\t\\t- Our middle value (5) is too small, but this may be the smaller value that we need\\n\\t\\t\\t\\t\\t\\t- we will search to the right, mid (inclusive) -> right [5, 9, 10]\\n\\t\\t\\t\\t\\t- Our mid value is (9), which is too big, so we search to the left\\n\\t\\t\\t\\t\\t\\t- We will search left -> mid (exclusive) [5]\\n\\t\\t\\t\\t\\t- When our left index equals our right index, we have found the value we need\\n\\t\\t- After we find our closest left/right or exact index, we can find our the minimal distance from the heater for this specific house\\n\\n**Optimizations**\\n- Do we really need 2 binary search?\\n\\t- If we find the closest heater index to the right\\n\\t\\t- Then we can just subtract 1 to the index to get the closest left index for the heater location\\n\\n**Answer**\\n- We will first sort our heater locations array, which will allow us to find the closest heater for each house\\n- We will have minimum heater radius variable to hold the result, this will be initially Integer.MIN_VALUE\\n- We will iterate through the locations of our houses\\n\\t- For each location of house\\n\\t\\t- We will search for the closest heater that is at a location equal to or greater than our house location first\\n\\t\\t\\t- How do we find the closest right heater location?\\n\\t\\t\\t\\t- We will perform a modified binary search\\n\\t\\t\\t\\t\\t- if our mid element equals our target value\\n\\t\\t\\t\\t\\t\\t- We will return our mid element\\n\\t\\t\\t\\t\\t- if our mid element is greater than our target value\\n\\t\\t\\t\\t\\t\\t- We will search left -> mid (inclusive)\\n\\t\\t\\t\\t\\t- else (our mid element is less than our target value)\\n\\t\\t\\t\\t\\t\\t- search left -> mid (exclusive)\\n\\t\\t\\t\\t- When our left and right index equals, we have found the minimum heater location that is to the right of the house\\n\\t\\t- If our closest heater is not at our current house index, we will need to find the closest heater location to the left of our current house\\n\\t\\t\\t- This value will then later be used to compare with our right closest heater\\n\\t\\t\\t- How do we find our closest left heater location?\\n\\t\\t\\t\\t- Since we have our closest right index, we can just subtract 1 from it.\\n\\t\\t- We have to find the distance from our current house to our closest left heater\\n\\t\\t- We have to find the distance from our current house to our closest right heater\\n\\t\\t- The closer heater is the one we will pick, Math.min(left heater distance, right heater distance)\\n\\t\\t\\t- We will update our minimum heater radius if our closer heater is greater than our current min\\n- Return our minimum heater radius variable\\n\\n**What is the time and space complexity?**\\n- Time complexity = O(klogk) + O(hlogk), where k is the number of heaters, and h is the number of houses\\n\\t- O(klogk) - sorting our heaters array\\n\\t- O(hlogk) - for each of our houses, find the closest heater\\n- Space complexity = O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        \\n        int minHeaterRadius = Integer.MIN_VALUE;\\n        \\n        for (int housePosition: houses) {\\n            int rightHeaterPosition = findClosestRightHeater(heaters, housePosition);\\n            \\n            if (rightHeaterPosition == housePosition) {\\n                minHeaterRadius = Math.max(minHeaterRadius, 0);\\n            } else {\\n                int leftHeaterPosition = rightHeaterPosition > 0 ? rightHeaterPosition - 1 : rightHeaterPosition;\\n                \\n                int leftHeaterDistance = Math.abs(housePosition - heaters[leftHeaterPosition]);\\n                int rightHeaterDistance = Math.abs(housePosition - heaters[rightHeaterPosition]);\\n                \\n                minHeaterRadius = Math.max(minHeaterRadius, Math.min(leftHeaterDistance, rightHeaterDistance));\\n            }\\n        }\\n        \\n        return minHeaterRadius;\\n    }\\n    \\n    private int findClosestRightHeater(int[] heaters, int position) {\\n        int left = 0;\\n        int right = heaters.length - 1;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (heaters[mid] == position) {\\n                return mid;\\n            } else if (heaters[mid] > position) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515168,
                "title": "detailed-explanation-with-pictures-ruby-solution-100",
                "content": "## What do we looking for?\\n\\nWhen starting to solve a task, important part is to define what we really need to fine. And in this case we need to find maximum value of minimum distance from a home to a header. Each home has it own nearest heater. So what we need is to find maximum distance to such heater among all houses.\\n\\nOn the picture nearest heater fro houses #1 and #2 is `H1` and nearest for home three is `H2`.  Shortest Distance from Home1 to `H1` is 2, from Home2 to `H1` is 1, and from Home3 to `H2` is 2 again. So maximum nearest heater to a house stays in 2 point, this is the answer.\\n\\n![We are seeking for a maximum value of nearest distance from a home to a heater](https://assets.leetcode.com/users/user9697n/image_1582225384.png)\\n\\n\\n## Some interesting rule.\\n\\nFor example nearest heater `Hi` found for a house1. The distance till `Hi` is smaller for house1 then distance till left one `Hi-1`, and right one `Hi+1` heaters.  So for the next house: house2, as a nearest heaters we need to consider only `Hi` and heaters that stay further right way. Because as house2 has moved forward from house1 distance between house2 and `Hi-1` even greater than distance between house1 and `Hi-1` so we can eliminate `Hi-1` from consideration.\\n\\n![When we found nearest heater for a home, search for next home started from the same heater.](https://assets.leetcode.com/users/user9697n/image_1582225486.png)\\n\\n## The algorithm is ready.\\n\\n1. Get minimum distance till a header from each home to a heaters.\\n2. Select maximum value from all this distance.\\n\\nIt possible to do in `O(N+M)` where `N` is number of houses and `M` is number of heaters. Need to involve two pointers `i` for homes, and `j` for heaters. When we considering home pointed by `i` pointer, we seeking heater on minimum distance moving `j` right. When such heater is found, and we switched to a next home we continuing search for nearest heater from the same position of `j` pointer.\\n\\n```Ruby\\n# 475. Heaters\\n# https://leetcode.com/problems/heaters/\\n# Runtime: 80 ms, faster than 100.00% of Ruby online submissions for Heaters.\\n# Memory Usage: 11.3 MB, less than 100.00% of Ruby online submissions for Heaters.\\n# @param {Integer[]} houses\\n# @param {Integer[]} heaters\\n# @return {Integer}\\ndef find_radius(houses, heaters)\\n    houses.sort!\\n    heaters.sort!\\n    heaters.push(Float::INFINITY)\\n    max_min_distance = 0\\n    j = 0 # heater pointer\\n    (0...houses.size).each do |i|\\n        distance = (heaters[j] - houses[i]).abs\\n        while j+1 < heaters.size \\n            new_distance = (heaters[j+1] - houses[i]).abs\\n            break if new_distance > distance\\n            j += 1\\n            distance = new_distance\\n        end\\n        max_min_distance = distance if distance > max_min_distance\\n    end\\n    max_min_distance\\n    \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# 475. Heaters\\n# https://leetcode.com/problems/heaters/\\n# Runtime: 80 ms, faster than 100.00% of Ruby online submissions for Heaters.\\n# Memory Usage: 11.3 MB, less than 100.00% of Ruby online submissions for Heaters.\\n# @param {Integer[]} houses\\n# @param {Integer[]} heaters\\n# @return {Integer}\\ndef find_radius(houses, heaters)\\n    houses.sort!\\n    heaters.sort!\\n    heaters.push(Float::INFINITY)\\n    max_min_distance = 0\\n    j = 0 # heater pointer\\n    (0...houses.size).each do |i|\\n        distance = (heaters[j] - houses[i]).abs\\n        while j+1 < heaters.size \\n            new_distance = (heaters[j+1] - houses[i]).abs\\n            break if new_distance > distance\\n            j += 1\\n            distance = new_distance\\n        end\\n        max_min_distance = distance if distance > max_min_distance\\n    end\\n    max_min_distance\\n    \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 112105,
                "title": "python-binary-search-but-is-slow",
                "content": "\"\"\"\\ndef findRadius(self, houses, heaters):\\n        \\n       \\n     \\n        heaters.sort()\\n        radius=0\\n        for house in houses:\\n            left=0\\n            right=len(heaters)-1\\n            middle=(left+right)//2\\n            \\n            while left<right-1:\\n                middle=(left+right)//2\\n                if house==heaters[middle]:\\n                    left=right=middle\\n                    break\\n                if house<heaters[middle]:right=middle\\n                else:left=middle\\n                    \\n            if left==right:radius=max(radius,min(abs(house-heaters[left]),abs(house-heaters[middle])))\\n            else: radius=max(radius,min(abs(house-heaters[left]),abs(house-heaters[right])))\\n                \\n        return radius\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\ndef findRadius(self, houses, heaters):\\n        \\n       \\n     \\n        heaters.sort()\\n        radius=0\\n        for house in houses:\\n            left=0\\n            right=len(heaters)-1\\n            middle=(left+right)//2\\n            \\n            while left<right-1:\\n                middle=(left+right)//2\\n                if house==heaters[middle]:\\n                    left=right=middle\\n                    break\\n                if house<heaters[middle]:right=middle\\n                else:left=middle\\n                    \\n            if left==right:radius=max(radius,min(abs(house-heaters[left]),abs(house-heaters[middle])))\\n            else: radius=max(radius,min(abs(house-heaters[left]),abs(house-heaters[right])))\\n                \\n        return radius\\n\"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 95902,
                "title": "swift-solution-binary-search",
                "content": "```\\nclass Solution {\\n    func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int {\\n        var heaters = heaters.sorted()\\n        var result = Int.min\\n        \\n        for house in houses {\\n            var i = binarySearch(heaters, house)\\n            if i < 0 {\\n                i = -(i + 1)\\n            }\\n            let rightDistance = i - 1 >= 0 ? (house - heaters[i - 1]) : Int.max\\n            let leftDistance = i < heaters.count ? (heaters[i] - house) : Int.max\\n            \\n            result = max(result, min(rightDistance, leftDistance))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func binarySearch(_ nums: [Int], _ num: Int) -> Int {\\n        var left = 0\\n        var right = nums.count - 1\\n        var middle = 0\\n        \\n        while left <= right {\\n            middle = (left + right) / 2\\n            if nums[middle] < num {\\n                left = middle + 1\\n            } else {\\n                right = middle - 1\\n            }\\n        }\\n        \\n        return left\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findRadius(_ houses: [Int], _ heaters: [Int]) -> Int {\\n        var heaters = heaters.sorted()\\n        var result = Int.min\\n        \\n        for house in houses {\\n            var i = binarySearch(heaters, house)\\n            if i < 0 {\\n                i = -(i + 1)\\n            }\\n            let rightDistance = i - 1 >= 0 ? (house - heaters[i - 1]) : Int.max\\n            let leftDistance = i < heaters.count ? (heaters[i] - house) : Int.max\\n            \\n            result = max(result, min(rightDistance, leftDistance))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func binarySearch(_ nums: [Int], _ num: Int) -> Int {\\n        var left = 0\\n        var right = nums.count - 1\\n        var middle = 0\\n        \\n        while left <= right {\\n            middle = (left + right) / 2\\n            if nums[middle] < num {\\n                left = middle + 1\\n            } else {\\n                right = middle - 1\\n            }\\n        }\\n        \\n        return left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95920,
                "title": "python-binary-search-for-beginners-concise-but-easy-to-understand",
                "content": "I am new to Python myself and I wrote the binary search part instead of using builtin function. I noticed that some other implementations use two searches for both left nearest and right nearest heaters, while here I only use one search for the single nearest heater. I also noticed the condition of numbers being smaller than 10**9 but my code got accepted without taking care of it.\\n\\n````\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        heaters.sort()           #first sort the heaters\\n        n = len(heaters) - 1\\n        maxDist = 0\\n        for h in houses:         #then for each house search for the nearest heater\\n            Lo = 0\\n            Hi = n\\n            while Hi - Lo > 1:   #stop when there are two candidates (instead of one)\\n                Mid = (Lo+Hi) // 2\\n                if heaters[Mid] < h:\\n                    Lo = Mid     #instead of Lo = mid+1 in common binary search cases\\n                else:\\n                    Hi = Mid\\n            maxDist = max(maxDist,min(abs(heaters[Lo]-h),abs(heaters[Hi]-h)))\\n        return maxDist\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        heaters.sort()           #first sort the heaters\\n        n = len(heaters) - 1\\n        maxDist = 0\\n        for h in houses:         #then for each house search for the nearest heater\\n            Lo = 0\\n            Hi = n\\n            while Hi - Lo > 1:   #stop when there are two candidates (instead of one)\\n                Mid = (Lo+Hi) // 2\\n                if heaters[Mid] < h:\\n                    Lo = Mid     #instead of Lo = mid+1 in common binary search cases\\n                else:\\n                    Hi = Mid\\n            maxDist = max(maxDist,min(abs(heaters[Lo]-h),abs(heaters[Hi]-h)))\\n        return maxDist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95916,
                "title": "java-binary-search-solution",
                "content": "Idea: Search the left heater and right heater for each house. Then we can get the distance a house to its nearest heater. The maximum distance is the radius.\\n\\nTime Complexity: O(nlogn + mlogn), \\nwhere m = houses.length, n = heaters.length.\\n\\n```\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters); // nlogn\\n        final int N = heaters.length;\\n        int maxRadius = 0;\\n        for(int house : houses){ // m * logn\\n            int index = Arrays.binarySearch(heaters, house);\\n            if(index<0) index = -index-1;\\n            int dist_r = index<N ? heaters[index] - house : Integer.MAX_VALUE; // right heater\\n            int dist_l = index>0 ? house - heaters[index-1] : Integer.MAX_VALUE; // left heater\\n            maxRadius = Math.max(maxRadius, Math.min(dist_l, dist_r)); // max, min\\n        }\\n        return maxRadius;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters); // nlogn\\n        final int N = heaters.length;\\n        int maxRadius = 0;\\n        for(int house : houses){ // m * logn\\n            int index = Arrays.binarySearch(heaters, house);\\n            if(index<0) index = -index-1;\\n            int dist_r = index<N ? heaters[index] - house : Integer.MAX_VALUE; // right heater\\n            int dist_l = index>0 ? house - heaters[index-1] : Integer.MAX_VALUE; // left heater\\n            maxRadius = Math.max(maxRadius, Math.min(dist_l, dist_r)); // max, min\\n        }\\n        return maxRadius;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95942,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Heaters** https://leetcode.com/problems/heaters/\\n\\n**Binary Search: Closest heater to each house**\\n* Given a house i, say j is the location of the closest heater to it. Say distI(i) = abs(i-j) is the minimum distance between the house i and a heater. The solution of our problem is to find max(dist(0), dist(1), dist(2), ...dist(n-1)).\\n* We can sort the input heaters. Then for every house i, we find the leftmost index idx in the sorted heater list to insert the position of this house using binary search.\\n* idx can be 0, len(heaters), or lie between 0 and len(heaters). We can use this to find dist(i).\\n\\n**bisect module in Python**\\n* Key idea is to use bisect_left in the bisect module. bisect_left returns the leftmost index in sorted list to insert a given element\\n* Think of the leftmost index where you will add the new element and push all the remaining on the right by 1 so that the new array still remains sorted. This visualization immediately tells us why bisect_left([1,2,3], 4) will be 3 or bisect_left([1,2,3], 2.5) will 2.\\n* http://stackoverflow.com/questions/20297249/when-are-bisect-left-and-bisect-right-not-equal\\n\\n**Code**\\n```\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        heaters.sort()\\n        max_so_far = float('-inf')\\n        for x in houses:\\n            idx = bisect_left(heaters, x)\\n            if 0<idx<len(heaters):\\n                dist = min(x-heaters[idx-1], heaters[idx]-x)\\n            else:\\n                dist = heaters[0]-x if idx == 0 else x - heaters[-1]\\n            max_so_far = max(dist, max_so_far)\\n        return max_so_far\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        heaters.sort()\\n        max_so_far = float('-inf')\\n        for x in houses:\\n            idx = bisect_left(heaters, x)\\n            if 0<idx<len(heaters):\\n                dist = min(x-heaters[idx-1], heaters[idx]-x)\\n            else:\\n                dist = heaters[0]-x if idx == 0 else x - heaters[-1]\\n            max_so_far = max(dist, max_so_far)\\n        return max_so_far\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95946,
                "title": "simple-c-with-two-sorts",
                "content": "As an alternative to sorting just heaters and using binary search, we can sort both heaters and houses, and then go through one m + n loop. The run-time is similar, however, this solution may be easier to read. Also, the run-time could be better when a number of heaters is large, or when when most of heaters are outside of the houses location.\\n\\n```\\nint findRadius(vector<int>& houses, vector<int>& heaters) \\n{\\n    auto curHeater = 0, maxDistance = 0;\\n    auto heatersSize = heaters.size();\\n    \\n    if (heatersSize > 0)\\n    {\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        for (auto house : houses)\\n        {\\n            while (curHeater + 1 < heatersSize && abs(house - heaters[curHeater + 1]) <= abs(house - heaters[curHeater]))\\n            {\\n                ++curHeater; // cycle to the closest heater.\\n            }\\n            \\n            maxDistance = max (maxDistance, abs(house - heaters[curHeater]));\\n        }\\n    }\\n\\n    return maxDistance;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findRadius(vector<int>& houses, vector<int>& heaters) \\n{\\n    auto curHeater = 0, maxDistance = 0;\\n    auto heatersSize = heaters.size();\\n    \\n    if (heatersSize > 0)\\n    {\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        for (auto house : houses)\\n        {\\n            while (curHeater + 1 < heatersSize && abs(house - heaters[curHeater + 1]) <= abs(house - heaters[curHeater]))\\n            {\\n                ++curHeater; // cycle to the closest heater.\\n            }\\n            \\n            maxDistance = max (maxDistance, abs(house - heaters[curHeater]));\\n        }\\n    }\\n\\n    return maxDistance;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95930,
                "title": "no-need-consider-boundary-condition-c",
                "content": "```\\nint findRadius(vector<int>& houses, vector<int>& heaters) {\\n        heaters.push_back(INT_MAX);\\n        heaters.push_back(INT_MIN);\\n        sort(heaters.begin(), heaters.end());\\n        long long res = 0;\\n        for (p : houses){\\n            int p1 = lower_bound(heaters.begin(), heaters.end(), p)-heaters.begin();\\n            int p2 = p1-1;\\n            long long temp = min( ((long long)heaters[p1]-p), ((long long)p-heaters[p2]));\\n            res = max(res, temp);\\n        }\\n        return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findRadius(vector<int>& houses, vector<int>& heaters) {\\n        heaters.push_back(INT_MAX);\\n        heaters.push_back(INT_MIN);\\n        sort(heaters.begin(), heaters.end());\\n        long long res = 0;\\n        for (p : houses){\\n            int p1 = lower_bound(heaters.begin(), heaters.end(), p)-heaters.begin();\\n            int p2 = p1-1;\\n            long long temp = min( ((long long)heaters[p1]-p), ((long long)p-heaters[p2]));\\n            res = max(res, temp);\\n        }\\n        return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3920842,
                "title": "binary-search-on-radius-ie-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search on radius(ie.answer), and store the smallest valid radius.\\n\\n\\n# Complexity\\n- Time complexity: $$O(radius * log(max(heaters_i, houses_i)))$$ \\nAs we explore smaller radius the `can` loop takes more time. In worst case `radius =`$$O(n+n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n  public boolean can(int r, int[] houses, int[] heaters) {\\n    int prevHouseIdx = -1;\\n    for(int i = 0; i < heaters.length; i++) {\\n      int from = heaters[i]-r;\\n      int to   = heaters[i]+r;\\n      for(int j = prevHouseIdx+1; j < houses.length; j++){\\n        if(houses[j]<=to && houses[j]>=from){\\n          prevHouseIdx++;\\n        }\\n        else break;\\n      }\\n      if(prevHouseIdx >= houses.length-1)return true;\\n    }\\n    return prevHouseIdx>= houses.length-1;\\n  }\\n  public int findRadius(int[] houses, int[] heaters) {\\n    Arrays.sort(houses);\\n    Arrays.sort(heaters);\\n    int lo = 0, hi = 1000000004;\\n    int mid, ans = hi;\\n    while(lo <= hi) {\\n      mid = (lo+hi)/2;\\n      if(can(mid, houses, heaters)){\\n        ans = mid;\\n        hi = mid - 1;\\n      } else lo = mid + 1;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public boolean can(int r, int[] houses, int[] heaters) {\\n    int prevHouseIdx = -1;\\n    for(int i = 0; i < heaters.length; i++) {\\n      int from = heaters[i]-r;\\n      int to   = heaters[i]+r;\\n      for(int j = prevHouseIdx+1; j < houses.length; j++){\\n        if(houses[j]<=to && houses[j]>=from){\\n          prevHouseIdx++;\\n        }\\n        else break;\\n      }\\n      if(prevHouseIdx >= houses.length-1)return true;\\n    }\\n    return prevHouseIdx>= houses.length-1;\\n  }\\n  public int findRadius(int[] houses, int[] heaters) {\\n    Arrays.sort(houses);\\n    Arrays.sort(heaters);\\n    int lo = 0, hi = 1000000004;\\n    int mid, ans = hi;\\n    while(lo <= hi) {\\n      mid = (lo+hi)/2;\\n      if(can(mid, houses, heaters)){\\n        ans = mid;\\n        hi = mid - 1;\\n      } else lo = mid + 1;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893481,
                "title": "binary-search-on-answer",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n  bool isValid(int mid, vector<int> &houses, vector<int> &heaters)\\n{\\n\\n    int i = 0;\\n    int n = heaters.size();\\n    int j = 0;\\n    int m = houses.size();\\n\\n    while (i < n and j < m)\\n    {\\n        if (abs(heaters[i] - houses[j]) <= mid)\\n        {\\n            j++;\\n        }\\n        else\\n        {\\n            i++;\\n        }\\n    }\\n\\n    if(i < n) return true;\\n    return false;\\n}\\nint findRadius(vector<int> &houses, vector<int> &heaters)\\n{\\n    sort(heaters.begin(), heaters.end());\\n    sort(houses.begin(), houses.end());\\n    int lb = 0;\\n    int ub = 1e9;\\n    int ans = -1;\\n    while (lb <= ub)\\n    {\\n        int mid = lb + (ub - lb) / 2;\\n        if (isValid(mid, houses, heaters))\\n        {\\n            ans = mid;\\n            ub = mid - 1;\\n        }\\n        else\\n        {\\n            lb = mid + 1;\\n        }\\n    }\\n    return ans;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n  bool isValid(int mid, vector<int> &houses, vector<int> &heaters)\\n{\\n\\n    int i = 0;\\n    int n = heaters.size();\\n    int j = 0;\\n    int m = houses.size();\\n\\n    while (i < n and j < m)\\n    {\\n        if (abs(heaters[i] - houses[j]) <= mid)\\n        {\\n            j++;\\n        }\\n        else\\n        {\\n            i++;\\n        }\\n    }\\n\\n    if(i < n) return true;\\n    return false;\\n}\\nint findRadius(vector<int> &houses, vector<int> &heaters)\\n{\\n    sort(heaters.begin(), heaters.end());\\n    sort(houses.begin(), houses.end());\\n    int lb = 0;\\n    int ub = 1e9;\\n    int ans = -1;\\n    while (lb <= ub)\\n    {\\n        int mid = lb + (ub - lb) / 2;\\n        if (isValid(mid, houses, heaters))\\n        {\\n            ans = mid;\\n            ub = mid - 1;\\n        }\\n        else\\n        {\\n            lb = mid + 1;\\n        }\\n    }\\n    return ans;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782307,
                "title": "simple-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(Number of houses+ Number of heaters)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        heaters.sort()\\n        houses.sort()\\n        ans = 0\\n        j = 0\\n        for i in range(len(heaters)):\\n            if i == 0:\\n                mini = houses[0]\\n            else:\\n                mini = (heaters[i-1] + heaters[i])//2\\n            if i == len(heaters)-1:\\n                maxi = houses[-1]\\n            else:\\n                maxi = (heaters[i+1] + heaters[i])//2\\n            while j < len(houses) and mini <= houses[j] <= maxi:\\n                ans = max(ans,abs(heaters[i] - houses[j]))\\n                j += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        heaters.sort()\\n        houses.sort()\\n        ans = 0\\n        j = 0\\n        for i in range(len(heaters)):\\n            if i == 0:\\n                mini = houses[0]\\n            else:\\n                mini = (heaters[i-1] + heaters[i])//2\\n            if i == len(heaters)-1:\\n                maxi = houses[-1]\\n            else:\\n                maxi = (heaters[i+1] + heaters[i])//2\\n            while j < len(houses) and mini <= houses[j] <= maxi:\\n                ans = max(ans,abs(heaters[i] - houses[j]))\\n                j += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746428,
                "title": "easy-to-understand-c-solution-using-lower-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        int n = houses.size(), m = heaters.size();\\n        int ans = 0;\\n        for(auto h : houses){\\n            int id = lower_bound(heaters.begin(), heaters.end(), h) - heaters.begin();\\n            int right = id>= m ? INT_MAX : heaters[id] - h;\\n            int left = id-1 < 0 ? INT_MAX : h - heaters[id-1];\\n            ans = max(ans,min(right,left) );\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        int n = houses.size(), m = heaters.size();\\n        int ans = 0;\\n        for(auto h : houses){\\n            int id = lower_bound(heaters.begin(), heaters.end(), h) - heaters.begin();\\n            int right = id>= m ? INT_MAX : heaters[id] - h;\\n            int left = id-1 < 0 ? INT_MAX : h - heaters[id-1];\\n            ans = max(ans,min(right,left) );\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444861,
                "title": "binary-search-python-explained",
                "content": "# Intuition\\nset the left and right pointer over heater arrays and for every house in house array find the nearest heater present near it.\\nFor each house we are supposed to find the nearest array located to it.\\nFrom that found locations return the maximum distance as the max radius required by any one of the heater to reach a house.\\nThree cases\\n`1. curr house has heater itself -> radius req = 0 for that house`\\n`2. the heater[mid] < currHouse thus shift left pointer to find if nearer heater exits in right`\\n`3. heater[mid] > currHouse shift right pointer`\\nreturn the maxSeenRadius among them as your ans.\\n\\n# Code\\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        maxRadiusSeen = 0\\n        heaters.sort()\\n        for i in range(len(houses)):\\n            left = 0\\n            right = len(heaters) - 1\\n            radiusReq = float(\\'inf\\')\\n            while left < right:\\n                mid = (left + right) // 2\\n                if heaters[mid] == houses[i]:\\n                    radiusReq = 0\\n                    break\\n                elif heaters[mid] < houses[i]:\\n                    radiusReq = min(radiusReq, abs(heaters[mid] - houses[i]))\\n                    left = mid + 1\\n                else:\\n                    radiusReq = min(radiusReq, abs(heaters[mid] - houses[i]))\\n                    right = mid\\n            radiusReq = min(radiusReq, abs(heaters[left] - houses[i]))\\n            maxRadiusSeen = max(maxRadiusSeen, radiusReq)\\n        return(maxRadiusSeen)\\n                    \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        maxRadiusSeen = 0\\n        heaters.sort()\\n        for i in range(len(houses)):\\n            left = 0\\n            right = len(heaters) - 1\\n            radiusReq = float(\\'inf\\')\\n            while left < right:\\n                mid = (left + right) // 2\\n                if heaters[mid] == houses[i]:\\n                    radiusReq = 0\\n                    break\\n                elif heaters[mid] < houses[i]:\\n                    radiusReq = min(radiusReq, abs(heaters[mid] - houses[i]))\\n                    left = mid + 1\\n                else:\\n                    radiusReq = min(radiusReq, abs(heaters[mid] - houses[i]))\\n                    right = mid\\n            radiusReq = min(radiusReq, abs(heaters[left] - houses[i]))\\n            maxRadiusSeen = max(maxRadiusSeen, radiusReq)\\n        return(maxRadiusSeen)\\n                    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024001,
                "title": "beats-space-complexity-99-8-simple-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        c=0\\n        houses.sort()\\n        heaters.sort()\\n        dist=[]\\n        for i in houses:\\n            res=bisect_left(heaters,i)\\n            if(res==0):\\n                dist.append(abs(heaters[res]-i))\\n            elif (res>= len(heaters)):\\n                dist.append(abs(heaters[-1]-i))\\n            else:\\n                dist.append(min(abs(heaters[res]-i),abs(heaters[res-1]-i)))\\n            \\n        return max(dist)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        c=0\\n        houses.sort()\\n        heaters.sort()\\n        dist=[]\\n        for i in houses:\\n            res=bisect_left(heaters,i)\\n            if(res==0):\\n                dist.append(abs(heaters[res]-i))\\n            elif (res>= len(heaters)):\\n                dist.append(abs(heaters[-1]-i))\\n            else:\\n                dist.append(min(abs(heaters[res]-i),abs(heaters[res-1]-i)))\\n            \\n        return max(dist)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809861,
                "title": "simple-binary-search",
                "content": "class Solution {\\npublic:\\n\\n    int bound(vector<int>& heaters,int &l,int &r,int t){\\n         l=0,r=heaters.size()-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(heaters[mid]==t){\\n                return mid;}\\n            else if(heaters[mid]<t){\\n                 l=mid+1;\\n            }\\n            else  r=mid-1;\\n        }\\n        return l;//returns upper bound\\n    }\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n         sort(heaters.begin(), heaters.end());\\n        int l=0,r=0;// our fun will return upperbound and lowerbound will be in r\\n        int maxi=0;\\n        int n=heaters.size()-1;\\n        for(auto i:houses){\\n            l=0,r=n;\\n            int high=bound(heaters,l,r,i);\\n            int low=r;\\n            if(high>n){\\n                maxi=max(maxi,abs(heaters[low]-i));\\n            }\\n            else if(low<0){\\n                maxi=max(maxi,abs(heaters[high]-i));\\n            }\\n           else  maxi=max(maxi,min(abs(heaters[high]-i),abs(heaters[low]-i)));\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int bound(vector<int>& heaters,int &l,int &r,int t){\\n         l=0,r=heaters.size()-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(heaters[mid]==t){\\n                return mid;}",
                "codeTag": "Java"
            },
            {
                "id": 2540596,
                "title": "heaters-t-o-m-n-lgm-s-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/25efd613-ce3d-42c2-920b-6b7dd55af673_1662476994.7251983.jpeg)\\n\\n```\\n#iterate over houses\\n#sort the heaters to do binary search\\n#add dummy boundary values to heaters to cover edge cases\\n#find the nearest heater using binary search\\n#result radius would be the max distance between a house and the heater\\nclass Solution:\\n    #T=O((m+n)lgm), S=O(1)\\n    #n=len(houses),m=len(heaters)\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        def bs(target):\\n            #T=O(lgm)\\n            l,r = 0, len(heaters)-1\\n            while l<r:\\n                m = l + (r-l)//2\\n                if target <= heaters[m]:\\n                    r = m\\n                else:\\n                    l = m+1\\n            return l\\n        \\n        heaters = [float(\\'-inf\\')] + heaters + [float(\\'inf\\')]\\n        #T=O(mlgm)\\n        heaters.sort()\\n        radius = 0\\n        \\n        #T=O(n)\\n        for house in houses:\\n            #T=O(lgm)\\n            i = bs(house)\\n            radius = max(radius, min((heaters[i] - house), (house - heaters[i-1])))\\n        return radius\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n#iterate over houses\\n#sort the heaters to do binary search\\n#add dummy boundary values to heaters to cover edge cases\\n#find the nearest heater using binary search\\n#result radius would be the max distance between a house and the heater\\nclass Solution:\\n    #T=O((m+n)lgm), S=O(1)\\n    #n=len(houses),m=len(heaters)\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        def bs(target):\\n            #T=O(lgm)\\n            l,r = 0, len(heaters)-1\\n            while l<r:\\n                m = l + (r-l)//2\\n                if target <= heaters[m]:\\n                    r = m\\n                else:\\n                    l = m+1\\n            return l\\n        \\n        heaters = [float(\\'-inf\\')] + heaters + [float(\\'inf\\')]\\n        #T=O(mlgm)\\n        heaters.sort()\\n        radius = 0\\n        \\n        #T=O(n)\\n        for house in houses:\\n            #T=O(lgm)\\n            i = bs(house)\\n            radius = max(radius, min((heaters[i] - house), (house - heaters[i-1])))\\n        return radius\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516103,
                "title": "python-soln-77-runtime",
                "content": "We can loop through all houses and find the closest heaters to its left and right using a binary search, after which we can decide if the left or right heater is closer. Every time we calculate this closest distance, we can update radius = max(radius, closest distance).\\n```\\nclass Solution(object):\\n    #function to return the positions of the closest heaters to the left and the right of itself\\n    def findClosest(self, house, heaters):\\n        low = 0\\n        high = len(heaters)-1\\n        mid = (low + high) // 2\\n        while low + 1 < high:\\n            if heaters[mid] == house:\\n                return (mid, -1)\\n            elif heaters[mid] < house:\\n                low = mid\\n                mid = (low + high) // 2\\n            elif heaters[mid] > house:\\n                high = mid\\n                mid = (low + high) // 2\\n        if house > heaters[mid]:\\n            if mid + 1 > len(heaters)-1:\\n                return (mid, -1)\\n            return (mid, mid + 1)\\n        return (mid - 1, mid)\\n        \\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        radius = 0\\n        heaters.sort()\\n        for house in houses:\\n            close = self.findClosest(house, heaters)\\n            first = close[0]\\n            second = close[1]\\n            temp = 0\\n            if first >= 0 and second >= 0:\\n                temp = min(abs(heaters[second]-house), abs(heaters[first]-house))\\n            elif first >= 0:\\n                temp = abs(heaters[first]-house)\\n            elif second >= 0:\\n                temp = abs(heaters[second]-house)\\n            radius = max(radius, temp)\\n        return radius\\n\\t\\t```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    #function to return the positions of the closest heaters to the left and the right of itself\\n    def findClosest(self, house, heaters):\\n        low = 0\\n        high = len(heaters)-1\\n        mid = (low + high) // 2\\n        while low + 1 < high:\\n            if heaters[mid] == house:\\n                return (mid, -1)\\n            elif heaters[mid] < house:\\n                low = mid\\n                mid = (low + high) // 2\\n            elif heaters[mid] > house:\\n                high = mid\\n                mid = (low + high) // 2\\n        if house > heaters[mid]:\\n            if mid + 1 > len(heaters)-1:\\n                return (mid, -1)\\n            return (mid, mid + 1)\\n        return (mid - 1, mid)\\n        \\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        radius = 0\\n        heaters.sort()\\n        for house in houses:\\n            close = self.findClosest(house, heaters)\\n            first = close[0]\\n            second = close[1]\\n            temp = 0\\n            if first >= 0 and second >= 0:\\n                temp = min(abs(heaters[second]-house), abs(heaters[first]-house))\\n            elif first >= 0:\\n                temp = abs(heaters[first]-house)\\n            elif second >= 0:\\n                temp = abs(heaters[second]-house)\\n            radius = max(radius, temp)\\n        return radius\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2513745,
                "title": "python-greedy-o-nlogn-runtime-and-o-1-extra-space",
                "content": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        \\n        max_r = 0\\n        heater = 0\\n        \\n        for i,house in enumerate(houses):\\n            # Greedy: check if the next heater will shorter the radius compared to the current one\\n            # it will always improve the max_r as the later index houses will stay on the RHS of current house\\n\\t\\t\\t# and if the next heater will reduce the radius, therefore next heater will also reduce  the radius for later house\\n            while heater + 1 < len(heaters) and abs(heaters[heater] - house) >= abs(heaters[heater+1] - house):\\n                heater+=1\\n            max_r = max(max_r, abs(heaters[heater] - house))\\n        return max_r\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses.sort()\\n        heaters.sort()\\n        \\n        max_r = 0\\n        heater = 0\\n        \\n        for i,house in enumerate(houses):\\n            # Greedy: check if the next heater will shorter the radius compared to the current one\\n            # it will always improve the max_r as the later index houses will stay on the RHS of current house\\n\\t\\t\\t# and if the next heater will reduce the radius, therefore next heater will also reduce  the radius for later house\\n            while heater + 1 < len(heaters) and abs(heaters[heater] - house) >= abs(heaters[heater+1] - house):\\n                heater+=1\\n            max_r = max(max_r, abs(heaters[heater] - house))\\n        return max_r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267446,
                "title": "easy-python-solution-with-90-sc-and-50-tc",
                "content": "```\\ndef findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n\\tdef isValid(rad):\\n\\t\\th = 0\\n\\t\\ti = 0\\n\\t\\twhile(i < len(houses)):\\n\\t\\t\\tif(abs(houses[i] - heaters[h]) <= rad):\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\th += 1\\n\\t\\t\\tif(h == len(heaters)):\\n\\t\\t\\t\\treturn 0\\n\\t\\treturn 1\\n\\thouses.sort()\\n\\theaters.sort()\\n\\ti, j = 0, 1000000000\\n\\tans = 0\\n\\twhile(i <= j):\\n\\t\\tmid = i+(j-i)//2\\n\\t\\tif(isValid(mid)):\\n\\t\\t\\tj = mid-1\\n\\t\\t\\tans = mid\\n\\t\\telse:\\n\\t\\t\\ti = mid+1\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ndef findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n\\tdef isValid(rad):\\n\\t\\th = 0\\n\\t\\ti = 0\\n\\t\\twhile(i < len(houses)):\\n\\t\\t\\tif(abs(houses[i] - heaters[h]) <= rad):\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\th += 1\\n\\t\\t\\tif(h == len(heaters)):\\n\\t\\t\\t\\treturn 0\\n\\t\\treturn 1\\n\\thouses.sort()\\n\\theaters.sort()\\n\\ti, j = 0, 1000000000\\n\\tans = 0\\n\\twhile(i <= j):\\n\\t\\tmid = i+(j-i)//2\\n\\t\\tif(isValid(mid)):\\n\\t\\t\\tj = mid-1\\n\\t\\t\\tans = mid\\n\\t\\telse:\\n\\t\\t\\ti = mid+1\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2267442,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int val, vector<int>& houses, vector<int>& heaters){\\n        int i=0, j=0;\\n        while(j<heaters.size() && i<houses.size()){\\n            int x = houses[i];\\n            int y = heaters[j]-val;\\n            int z = heaters[j]+val;\\n            if(x>=y && x<=z){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return i==houses.size();\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        int l=0, r=INT_MAX;\\n        int res = INT_MAX;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(mid,houses,heaters)){\\n                res = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int val, vector<int>& houses, vector<int>& heaters){\\n        int i=0, j=0;\\n        while(j<heaters.size() && i<houses.size()){\\n            int x = houses[i];\\n            int y = heaters[j]-val;\\n            int z = heaters[j]+val;\\n            if(x>=y && x<=z){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return i==houses.size();\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        int l=0, r=INT_MAX;\\n        int res = INT_MAX;\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(check(mid,houses,heaters)){\\n                res = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265002,
                "title": "heaters-java-easy-binary-search",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int maxRad=-1;\\n        Arrays.sort(heaters);\\n        \\n        for(int i=0;i<houses.length;i++){\\n            int rad=binarySearch(heaters,houses[i]);\\n            maxRad=Math.max(maxRad, rad);\\n        }\\n        \\n        return maxRad;\\n    }\\n    \\n    public int binarySearch(int[] heaters, int house){\\n        int lo=0;\\n        int hi=heaters.length-1;\\n        \\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            \\n            if(heaters[mid]==house){\\n                return 0;\\n            }\\n            \\n            if(house<heaters[mid]){\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        int prev=(lo==0)?Integer.MAX_VALUE:heaters[lo-1];\\n        int pres=(lo==heaters.length)?Integer.MAX_VALUE:heaters[lo];\\n        \\n        \\n        return Math.min(Math.abs(house-prev),Math.abs(pres-house));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int maxRad=-1;\\n        Arrays.sort(heaters);\\n        \\n        for(int i=0;i<houses.length;i++){\\n            int rad=binarySearch(heaters,houses[i]);\\n            maxRad=Math.max(maxRad, rad);\\n        }\\n        \\n        return maxRad;\\n    }\\n    \\n    public int binarySearch(int[] heaters, int house){\\n        int lo=0;\\n        int hi=heaters.length-1;\\n        \\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            \\n            if(heaters[mid]==house){\\n                return 0;\\n            }\\n            \\n            if(house<heaters[mid]){\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        int prev=(lo==0)?Integer.MAX_VALUE:heaters[lo-1];\\n        int pres=(lo==heaters.length)?Integer.MAX_VALUE:heaters[lo];\\n        \\n        \\n        return Math.min(Math.abs(house-prev),Math.abs(pres-house));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171783,
                "title": "c-predicate-function-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(int radius, vector<int>& houses, vector<int>& heaters) {\\n            \\n           int i = 0, j = 0;\\n           while(i < houses.size() && j < heaters.size()) {\\n               if(houses[i] >= (heaters[j] - radius)  && houses[i] <= (heaters[j] + radius)) \\n               {\\n                   i++;\\n               }\\n               \\n               else {\\n                   j++;\\n               }\\n           }\\n        \\n          return i == houses.size();\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n          int lo = 0, hi = 1e9;\\n          int mid;\\n          int ans = -1;\\n          sort(houses.begin(), houses.end());\\n          sort(heaters.begin(), heaters.end());\\n         \\n          while(lo <= hi) {\\n              mid = lo + (hi - lo) / 2;\\n              \\n              if(isValid(mid, houses, heaters)){\\n                  ans = mid;\\n                  hi = mid - 1;\\n              }\\n              \\n              else {\\n                  lo = mid + 1;\\n              }\\n          }\\n        \\n        \\n           return ans;\\n          \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isValid(int radius, vector<int>& houses, vector<int>& heaters) {\\n            \\n           int i = 0, j = 0;\\n           while(i < houses.size() && j < heaters.size()) {\\n               if(houses[i] >= (heaters[j] - radius)  && houses[i] <= (heaters[j] + radius)) \\n               {\\n                   i++;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 2068529,
                "title": "java-binary-search-on-solution-sorting",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] house, int[] heater) \\n    {\\n        int n=house.length;\\n        Arrays.sort(house);\\n        Arrays.sort(heater);\\n        \\n        int min=0;int f=-1;\\n        int max=Integer.MAX_VALUE;\\n        \\n        while(min<=max)\\n        {\\n            int mid=min+(max-min)/2;\\n            \\n            if(isPossible(house,heater,mid))\\n            {\\n                f=mid;\\n                max=mid-1;\\n            }\\n            \\n            else\\n            min=mid+1;\\n        }\\n        \\n        return f;\\n    }\\n    \\n    public boolean isPossible(int[] house, int[] heater,int r)\\n    {\\n        int curr=0;\\n        int min=heater[curr]-r;\\n        int max=heater[curr]+r;\\n        int i;\\n        for(i=0;i<house.length;i++)\\n        {\\n            if(house[i]>=min && house[i]<=max)\\n            continue;\\n            \\n            curr++;\\n            while(curr<heater.length)\\n            {\\n                min=heater[curr]-r;\\n                max=heater[curr]+r;\\n                \\n                if(house[i]>=min && house[i]<=max)\\n                break;\\n                \\n                curr++;\\n            }  \\n        }\\n        \\n        if(i<house.length-1 || curr>=heater.length)\\n        return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] house, int[] heater) \\n    {\\n        int n=house.length;\\n        Arrays.sort(house);\\n        Arrays.sort(heater);\\n        \\n        int min=0;int f=-1;\\n        int max=Integer.MAX_VALUE;\\n        \\n        while(min<=max)\\n        {\\n            int mid=min+(max-min)/2;\\n            \\n            if(isPossible(house,heater,mid))\\n            {\\n                f=mid;\\n                max=mid-1;\\n            }\\n            \\n            else\\n            min=mid+1;\\n        }\\n        \\n        return f;\\n    }\\n    \\n    public boolean isPossible(int[] house, int[] heater,int r)\\n    {\\n        int curr=0;\\n        int min=heater[curr]-r;\\n        int max=heater[curr]+r;\\n        int i;\\n        for(i=0;i<house.length;i++)\\n        {\\n            if(house[i]>=min && house[i]<=max)\\n            continue;\\n            \\n            curr++;\\n            while(curr<heater.length)\\n            {\\n                min=heater[curr]-r;\\n                max=heater[curr]+r;\\n                \\n                if(house[i]>=min && house[i]<=max)\\n                break;\\n                \\n                curr++;\\n            }  \\n        }\\n        \\n        if(i<house.length-1 || curr>=heater.length)\\n        return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031808,
                "title": "simple-clean-java-code-one-pass",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        \\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        int radius = 0;\\n        int i = 0;\\n        \\n        for(int house: houses){\\n            \\n            while(i<heaters.length && heaters[i]<house){\\n                i += 1;\\n            }\\n            \\n            int minRadius = Integer.MAX_VALUE;\\n            \\n            if(i<heaters.length){\\n                minRadius = heaters[i]-house;\\n            }\\n            \\n            if(i>0){\\n                minRadius = Math.min(house-heaters[i-1], minRadius);\\n            }\\n            \\n            radius = Math.max(radius, minRadius);\\n\\n            \\n        }\\n        \\n        return radius;\\n        \\n        \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        \\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        \\n        int radius = 0;\\n        int i = 0;\\n        \\n        for(int house: houses){\\n            \\n            while(i<heaters.length && heaters[i]<house){\\n                i += 1;\\n            }\\n            \\n            int minRadius = Integer.MAX_VALUE;\\n            \\n            if(i<heaters.length){\\n                minRadius = heaters[i]-house;\\n            }\\n            \\n            if(i>0){\\n                minRadius = Math.min(house-heaters[i-1], minRadius);\\n            }\\n            \\n            radius = Math.max(radius, minRadius);\\n\\n            \\n        }\\n        \\n        return radius;\\n        \\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025536,
                "title": "c-binary-search-on-left-right-simple-solution-with-explanation",
                "content": "For each house, we want to find closest two heaters on its left and right side and determine the smaller one as `val` , which is the distance of closest heater to this house. Iterate this process for all houses and find the maximum one among all `val`.\\n\\nNote that in order to find left and right closest heaters, we need to sort `heaters` first and execute binary search on given `house[i]`.\\n\\n```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        int res = 0;\\n        sort(heaters.begin(), heaters.end());\\n        for (auto &house: houses) {\\n            auto pos = upper_bound(heaters.begin(), heaters.end(), house);\\n            int left = INT_MAX, right = INT_MAX;\\n            if (pos != heaters.end()) {\\n                right = *pos-house;\\n            }\\n            if (pos != heaters.begin()) {\\n                left = house-*prev(pos);\\n            }\\n            res = max(res, min(left, right));\\n        }\\n        return res;\\n    }\\n};\\n```\\n`n` : size of `houses` , `m` : size of `heaters`\\n* Time: `O(mlogm + nlogm)`\\n* Space: `O(logm)` for sort recursion stack space\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        int res = 0;\\n        sort(heaters.begin(), heaters.end());\\n        for (auto &house: houses) {\\n            auto pos = upper_bound(heaters.begin(), heaters.end(), house);\\n            int left = INT_MAX, right = INT_MAX;\\n            if (pos != heaters.end()) {\\n                right = *pos-house;\\n            }\\n            if (pos != heaters.begin()) {\\n                left = house-*prev(pos);\\n            }\\n            res = max(res, min(left, right));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021114,
                "title": "java-binray-search-using-ceil-and-floor",
                "content": "```\\n\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int n = houses.length, m = heaters.length;\\n        \\n        Arrays.sort(heaters);\\n        \\n        int ans = -(int)(1e8);\\n        \\n        for (int val: houses) {\\n            int[] cf = ceilFloor(heaters, val);\\n            // ceil @ 0 & floor @ 1\\n            int ceil = cf[0], floor = cf[1];\\n            int d1 = Math.abs(ceil - val), d2 = Math.abs(floor - val);\\n            \\n            ans = Math.max(ans, Math.min(d1, d2));\\n        }\\n        return ans;\\n    }\\n    \\n    // ans[0] = ceil, ans[1] = floor\\n    public int[] ceilFloor(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] ans = {Integer.MAX_VALUE, Integer.MAX_VALUE};\\n        int si = 0, ei = n;\\n        \\n        while (si < ei) {\\n            int mid = (si + ei) >> 1;\\n            if (k == arr[mid]) {\\n                ans[0] = ans[1] = k;\\n                return ans;\\n                \\n            } else if (k < arr[mid]) {\\n                ans[0] = arr[mid];\\n                ei = mid;\\n            } else {\\n                ans[1] = arr[mid];\\n                si = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int n = houses.length, m = heaters.length;\\n        \\n        Arrays.sort(heaters);\\n        \\n        int ans = -(int)(1e8);\\n        \\n        for (int val: houses) {\\n            int[] cf = ceilFloor(heaters, val);\\n            // ceil @ 0 & floor @ 1\\n            int ceil = cf[0], floor = cf[1];\\n            int d1 = Math.abs(ceil - val), d2 = Math.abs(floor - val);\\n            \\n            ans = Math.max(ans, Math.min(d1, d2));\\n        }\\n        return ans;\\n    }\\n    \\n    // ans[0] = ceil, ans[1] = floor\\n    public int[] ceilFloor(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] ans = {Integer.MAX_VALUE, Integer.MAX_VALUE};\\n        int si = 0, ei = n;\\n        \\n        while (si < ei) {\\n            int mid = (si + ei) >> 1;\\n            if (k == arr[mid]) {\\n                ans[0] = ans[1] = k;\\n                return ans;\\n                \\n            } else if (k < arr[mid]) {\\n                ans[0] = arr[mid];\\n                ei = mid;\\n            } else {\\n                ans[1] = arr[mid];\\n                si = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014954,
                "title": "classic-binary-search-solution-c-simple-solution",
                "content": "Intuition : Use **binary search** to **eliminate half of the search range each time** till we find the minimum value,\\n\\nSmall Details: \\n* The houses and heaters array are **not sorted**, therefore we need to sort them before we begin the search\\n* mid = (l+r)/2 will find the lower bound of the range of valid values,\\n* We can only update the minimum value when isHeated is true,\\n* isHeated determines if the radius is valid \\n\\n```\\nclass Solution {\\npublic:\\n    int n ,m;\\n    bool isHeated(vector<int>& houses, vector<int>& heaters,int radius){\\n        int house=0,heater=0;\\n        while((house<n)&&(heater<m)){\\n            if( abs(houses[house]-heaters[heater])<= radius){\\n                ++house;\\n            }\\n            else{\\n                ++heater;\\n            }\\n        }\\n        \\n        return (house==n && heater<m );\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        \\n        n = houses.size(),m = heaters.size();\\n        int l = 0 ,r=INT_MAX/2-1,mn=r,mid;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n\\t\\t\\t\\n            if(isHeated(houses,heaters,mid)){\\n                mn =min(mn,mid);\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return mn;\\n    }\\n};\\n```\\n\\nMore problems like this :\\n* https://leetcode.com/problems/minimum-time-to-complete-trips/\\n* https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\n* https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/",
                "solutionTags": [
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n ,m;\\n    bool isHeated(vector<int>& houses, vector<int>& heaters,int radius){\\n        int house=0,heater=0;\\n        while((house<n)&&(heater<m)){\\n            if( abs(houses[house]-heaters[heater])<= radius){\\n                ++house;\\n            }\\n            else{\\n                ++heater;\\n            }\\n        }\\n        \\n        return (house==n && heater<m );\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        \\n        n = houses.size(),m = heaters.size();\\n        int l = 0 ,r=INT_MAX/2-1,mn=r,mid;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n\\t\\t\\t\\n            if(isHeated(houses,heaters,mid)){\\n                mn =min(mn,mid);\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964961,
                "title": "java-treeset-solution",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        TreeSet<Integer> s = new TreeSet<>();\\n        for (int ht:heaters) {\\n            s.add(ht);\\n        }\\n        int a = 0;\\n        for (int ho:houses) {\\n            Integer lo = s.floor(ho);\\n            Integer hi = s.ceiling(ho);\\n            if (lo==null) {\\n                a = Math.max(a, Math.abs(hi-ho));\\n            } else {\\n                if (hi==null) {\\n                    a = Math.max(a, Math.abs(lo-ho));\\n                } else {\\n                    a = Math.max(a, Math.min(Math.abs(lo-ho), Math.abs(hi-ho)));\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        TreeSet<Integer> s = new TreeSet<>();\\n        for (int ht:heaters) {\\n            s.add(ht);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1920554,
                "title": "easy-c",
                "content": "```\\n\\nHint : Find nearest heater for every house and max of that will be the answer.\\n\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(),heaters.end());\\n        \\n        int ans = -1;\\n        for(auto it : houses){\\n            \\n            int id = lower_bound(heaters.begin(),heaters.end(), it)-heaters.begin();\\n             if(id==heaters.size())id-=1;\\n            if(id==0){\\n               ans = max(abs(heaters[id]-it), ans); \\n            } else {\\n               \\n                int left = abs(heaters[id-1]-it);\\n                int same = abs(heaters[id]-it);\\n                ans = max(ans,min(left,same));\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(),heaters.end());\\n        \\n        int ans = -1;\\n        for(auto it : houses){\\n            \\n            int id = lower_bound(heaters.begin(),heaters.end(), it)-heaters.begin();\\n             if(id==heaters.size())id-=1;\\n            if(id==0){\\n               ans = max(abs(heaters[id]-it), ans); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1842910,
                "title": "binary-search-the-range-value-c-solution",
                "content": "In this approach we will binary search on the range which satisifes the condition that all houses are heated\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& houses, vector<int>& heaters, int range) {\\n        int i = houses.size()-1, j = heaters.size()-1;\\n        while(i>=0 && j>=0) {\\n            int minRange = heaters[j]-range;\\n            int maxRange = heaters[j]+range;\\n            if(houses[i] >= minRange && houses[i] <= maxRange) {\\n                i--;\\n            } else j--;\\n        }\\n        if(i!=-1)return false;\\n        return true;\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        int l = 0, r = max(houses[houses.size()-1], heaters[heaters.size()-1]);\\n        \\n        int mid = r;\\n        int res = r;\\n        \\n        while(l<=r) {\\n            mid = l+(r-l)/2;\\n            if(check(houses, heaters, mid)) {\\n                r = mid-1;\\n                res = mid;\\n            } else l = mid+1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& houses, vector<int>& heaters, int range) {\\n        int i = houses.size()-1, j = heaters.size()-1;\\n        while(i>=0 && j>=0) {\\n            int minRange = heaters[j]-range;\\n            int maxRange = heaters[j]+range;\\n            if(houses[i] >= minRange && houses[i] <= maxRange) {\\n                i--;\\n            } else j--;\\n        }\\n        if(i!=-1)return false;\\n        return true;\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        int l = 0, r = max(houses[houses.size()-1], heaters[heaters.size()-1]);\\n        \\n        int mid = r;\\n        int res = r;\\n        \\n        while(l<=r) {\\n            mid = l+(r-l)/2;\\n            if(check(houses, heaters, mid)) {\\n                r = mid-1;\\n                res = mid;\\n            } else l = mid+1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828223,
                "title": "simple-bs-solution",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        int answer = Integer.MIN_VALUE;\\n        for(int house: houses){\\n            int location = searchInsert(heaters,house);\\n            if(location==0)\\n                answer=Math.max(answer,heaters[0]-house);\\n            else if(location==heaters.length)\\n                answer=Math.max(answer,house-heaters[heaters.length-1]);\\n            else\\n                answer=Math.max(answer,Math.min(house-heaters[location-1],heaters[location]-house));\\n        }\\n        return answer;\\n    }\\n    public int searchInsert(int[] nums, int target) {\\n        int lo=0,hi=nums.length-1;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(nums[mid]==target) return mid;\\n            else if(nums[mid]>target) hi=mid-1;\\n            else lo=mid+1;\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        int answer = Integer.MIN_VALUE;\\n        for(int house: houses){\\n            int location = searchInsert(heaters,house);\\n            if(location==0)\\n                answer=Math.max(answer,heaters[0]-house);\\n            else if(location==heaters.length)\\n                answer=Math.max(answer,house-heaters[heaters.length-1]);\\n            else\\n                answer=Math.max(answer,Math.min(house-heaters[location-1],heaters[location]-house));\\n        }\\n        return answer;\\n    }\\n    public int searchInsert(int[] nums, int target) {\\n        int lo=0,hi=nums.length-1;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(nums[mid]==target) return mid;\\n            else if(nums[mid]>target) hi=mid-1;\\n            else lo=mid+1;\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803734,
                "title": "python-simple-o-n-log-n-with-explanation",
                "content": "```py\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        heaters = sorted(set(heaters) | {-float(\\'inf\\'), float(\\'inf\\')})\\n\\n        ans = 0\\n\\n        for x in houses:\\n            i = bisect_left(heaters, x)\\n            ans = max(ans, min(abs(heaters[i - 1] - x), abs(heaters[i] - x)))\\n\\n        return ans\\n```\\n\\n- The idea is to go through every house and look at heaters to its left and right.\\n- In the optimal setup the nearest heater to the house should heat it, so the radius will corresponding to the distance between the house and the narest heater.\\n- So for every house, find the nearest heater to its left and the one to its right (using binary search).\\n- Of course, the answer will be the largest (max) such \\'nearest heater radius\\'. So we do a `max` of `min(ans, nearest heater radius)`.\\n- Finally, I add `+\\u221E` and `-\\u221E` to the heaters list to simplify handling the edges.\\n",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```py\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        heaters = sorted(set(heaters) | {-float(\\'inf\\'), float(\\'inf\\')})\\n\\n        ans = 0\\n\\n        for x in houses:\\n            i = bisect_left(heaters, x)\\n            ans = max(ans, min(abs(heaters[i - 1] - x), abs(heaters[i] - x)))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797806,
                "title": "clean-implementation-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        //Sort Both Arrays\\n        //Idea is to find the nearest heater to each house in both directions: Left and Right\\n        //Note: There is a room for space optimization, currently O(2N) just for simplicity\\n        \\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        int n = houses.size();\\n        int m = heaters.size();\\n        \\n        vector<int> rhs(n, INT_MAX);\\n        vector<int> lhs(n, INT_MAX);\\n        \\n        //Find nearest heater at RHS\\n        int i=0, j=0;\\n        while(i < houses.size() && j < heaters.size()){\\n            if(houses[i] <= heaters[j]){ //if position of house is lesser than that of heater\\n                rhs[i] = heaters[j] - houses[i];\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        \\n        //Find nearest heater at LHS\\n        i=n-1, j=m-1;\\n        while(i>=0 && j>=0){\\n            if(houses[i] >= heaters[j]){\\n                lhs[i] = houses[i] - heaters[j];\\n                i--;\\n            }else{\\n                j--;\\n            }\\n        }\\n        \\n        int maxRadius = 0;\\n        //find max radius using both LHS and RHS array\\n        for(int i=0; i<n; i++){\\n            maxRadius = max(maxRadius, min(lhs[i], rhs[i]));\\n        }\\n        return maxRadius;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        //Sort Both Arrays\\n        //Idea is to find the nearest heater to each house in both directions: Left and Right\\n        //Note: There is a room for space optimization, currently O(2N) just for simplicity\\n        \\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        int n = houses.size();\\n        int m = heaters.size();\\n        \\n        vector<int> rhs(n, INT_MAX);\\n        vector<int> lhs(n, INT_MAX);\\n        \\n        //Find nearest heater at RHS\\n        int i=0, j=0;\\n        while(i < houses.size() && j < heaters.size()){\\n            if(houses[i] <= heaters[j]){ //if position of house is lesser than that of heater\\n                rhs[i] = heaters[j] - houses[i];\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        \\n        //Find nearest heater at LHS\\n        i=n-1, j=m-1;\\n        while(i>=0 && j>=0){\\n            if(houses[i] >= heaters[j]){\\n                lhs[i] = houses[i] - heaters[j];\\n                i--;\\n            }else{\\n                j--;\\n            }\\n        }\\n        \\n        int maxRadius = 0;\\n        //find max radius using both LHS and RHS array\\n        for(int i=0; i<n; i++){\\n            maxRadius = max(maxRadius, min(lhs[i], rhs[i]));\\n        }\\n        return maxRadius;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761111,
                "title": "java-concise-o-nlogn-99-beats",
                "content": "```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        int i = 0, maxDistance = 0; // max distance between a heater and house pair is minimum radius\\n        // Find nearest heater for every house.\\n        // Analogous to mid point theorem. mid = (heaters[i] + heaters[i + 1])/2.0. And if house >= mid, then move else not.\\n        for (int house : houses) {\\n            while (i + 1 < heaters.length && house > (heaters[i] + heaters[i + 1]) / 2) {\\n                i++;\\n            }\\n            maxDistance = Math.max(maxDistance, Math.abs(heaters[i] - house));\\n        }\\n        \\n        return maxDistance;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        int i = 0, maxDistance = 0; // max distance between a heater and house pair is minimum radius\\n        // Find nearest heater for every house.\\n        // Analogous to mid point theorem. mid = (heaters[i] + heaters[i + 1])/2.0. And if house >= mid, then move else not.\\n        for (int house : houses) {\\n            while (i + 1 < heaters.length && house > (heaters[i] + heaters[i + 1]) / 2) {\\n                i++;\\n            }\\n            maxDistance = Math.max(maxDistance, Math.abs(heaters[i] - house));\\n        }\\n        \\n        return maxDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735202,
                "title": "python-o-nlogn-solution",
                "content": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        \\n        heaters.sort()  # O(nlog(n))\\n        nHeaters=len(heaters)\\n        radius=0\\n        \\n        for house in houses: # O(n)\\n            closestHeater=float(\\'inf\\') \\n            start, end = 0, nHeaters-1\\n            \\n\\t\\t\\t# binary search on heaters to find the closest \\n\\t\\t\\t# heater to the current house\\n\\t\\t\\t\\n            while start<=end: # O(log(n))\\n                mid=(start+end)//2\\n                if heaters[mid]==house:\\n                    closestHeater=0\\n                    break\\n                \\n                closestHeater=min(abs(heaters[mid]-house), closestHeater)\\n                \\n                if heaters[mid]>house:\\n                    end=mid-1\\n                else:\\n                    start=mid+1\\n                    \\n            radius=max(radius, closestHeater)\\n        \\n        return radius\\n        \\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        \\n        heaters.sort()  # O(nlog(n))\\n        nHeaters=len(heaters)\\n        radius=0\\n        \\n        for house in houses: # O(n)\\n            closestHeater=float(\\'inf\\') \\n            start, end = 0, nHeaters-1\\n            \\n\\t\\t\\t# binary search on heaters to find the closest \\n\\t\\t\\t# heater to the current house\\n\\t\\t\\t\\n            while start<=end: # O(log(n))\\n                mid=(start+end)//2\\n                if heaters[mid]==house:\\n                    closestHeater=0\\n                    break\\n                \\n                closestHeater=min(abs(heaters[mid]-house), closestHeater)\\n                \\n                if heaters[mid]>house:\\n                    end=mid-1\\n                else:\\n                    start=mid+1\\n                    \\n            radius=max(radius, closestHeater)\\n        \\n        return radius\\n        \\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1709958,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        int j = 0;\\n        int res = 0;\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        for(int i = 0;i<houses.size();i++){\\n            while(j<heaters.size()-1 && abs(heaters[j]-houses[i]) >= abs(heaters[j+1]-houses[i])){\\n                j++;\\n            }\\n            res = max(res,abs(heaters[j]-houses[i]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        int j = 0;\\n        int res = 0;\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        for(int i = 0;i<houses.size();i++){\\n            while(j<heaters.size()-1 && abs(heaters[j]-houses[i]) >= abs(heaters[j+1]-houses[i])){\\n                j++;\\n            }\\n            res = max(res,abs(heaters[j]-houses[i]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709198,
                "title": "c-concise-two-pointers-solution",
                "content": "```\\npublic int FindRadius(int[] houses, int[] heaters) {\\n        Array.Sort(houses);\\n        Array.Sort(heaters);\\n        var minRadius = 0;\\n        var k = 0; // heaters index\\n        for (int i=0; i<houses.Length; i++) {\\n            while (k < heaters.Length-1 && Math.Abs(heaters[k+1]-houses[i]) <= Math.Abs(heaters[k]-houses[i])) {\\n                k++;\\n            }\\n            minRadius = Math.Max(Math.Abs(heaters[k]-houses[i]), minRadius);\\n        }\\n        return minRadius;\\n    }\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\npublic int FindRadius(int[] houses, int[] heaters) {\\n        Array.Sort(houses);\\n        Array.Sort(heaters);\\n        var minRadius = 0;\\n        var k = 0; // heaters index\\n        for (int i=0; i<houses.Length; i++) {\\n            while (k < heaters.Length-1 && Math.Abs(heaters[k+1]-houses[i]) <= Math.Abs(heaters[k]-houses[i])) {\\n                k++;\\n            }\\n            minRadius = Math.Max(Math.Abs(heaters[k]-houses[i]), minRadius);\\n        }\\n        return minRadius;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1696533,
                "title": "simple-c-solution-using-lower-bound",
                "content": "we simply just check the position of each element of house in heater. And calculate the min distance of first heater which we got from both left and right side(if exists) as,r1 . At last for each r1 we calculate the max value(radius) which is necessary i,e. \"ans\". and return it.\\n```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& house, vector<int>& heater) {\\n        int n = house.size();\\n        int radius = 0;\\n        int ans = 0;\\n        sort(heater.begin(),heater.end());\\n        for(int i=0;i<n;i++){\\n            int r1 = 0;int x,y;int c1 = INT_MAX;int c2 = INT_MAX;\\n            auto it = lower_bound(heater.begin(),heater.end(),house[i]);  // for calculating the first left indexed value of heater equal to or greater then house[i].\\n            if(it != heater.end()){\\n                x = it - heater.begin();\\n                c1 = abs(heater[x]-house[i]);\\n            }\\n            if(it != heater.begin()){\\n                it--;\\n                y = it-heater.begin();\\n                c2 = abs(house[i]-heater[y]);\\n            }\\n            r1 = min(c1,c2);\\n            ans = max(r1,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThank u : )",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& house, vector<int>& heater) {\\n        int n = house.size();\\n        int radius = 0;\\n        int ans = 0;\\n        sort(heater.begin(),heater.end());\\n        for(int i=0;i<n;i++){\\n            int r1 = 0;int x,y;int c1 = INT_MAX;int c2 = INT_MAX;\\n            auto it = lower_bound(heater.begin(),heater.end(),house[i]);  // for calculating the first left indexed value of heater equal to or greater then house[i].\\n            if(it != heater.end()){\\n                x = it - heater.begin();\\n                c1 = abs(heater[x]-house[i]);\\n            }\\n            if(it != heater.begin()){\\n                it--;\\n                y = it-heater.begin();\\n                c2 = abs(house[i]-heater[y]);\\n            }\\n            r1 = min(c1,c2);\\n            ans = max(r1,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686076,
                "title": "java-sort-binary-search-with-picture-briefly-explained",
                "content": "![image](https://assets.leetcode.com/users/images/743c7cac-899e-4c51-966e-ede8b358c29e_1642048175.1444464.png)\\n```java\\npublic class Solution {\\n    /**\\n     * @param houses: positions of houses\\n     * @param heaters: positions of heaters\\n     * @return: the minimum radius standard of heaters\\n     */\\n    public int findRadius(int[] houses, int[] heaters) {\\n        if(houses == null || houses.length == 0 || heaters == null || heaters.length == 0){\\n            return 0;\\n        }\\n\\n        // copy the heaters for sorting in ascending order\\n        int n = heaters.length;\\n        int[] copy = new int[n];\\n        for(int i = 0; i < n; i++){\\n            copy[i] = heaters[i];\\n        }\\n\\n        Arrays.sort(copy);\\n\\n        // for each house, find closest heater distance. Then max\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 0; i < houses.length; i++){\\n            int distance = getMinRadiu(houses[i], copy);\\n            res = Math.max(res, distance);\\n        }\\n        return res;\\n    }\\n\\n    private int getMinRadiu(int house, int[] heaters){\\n        int start = 0;\\n        int end = heaters.length - 1;\\n        while(start + 1 < end){\\n            int mid = start + (end - start) / 2;\\n            if(heaters[mid] <= house){\\n                start = mid;\\n            }else{\\n                end = mid;\\n            }\\n        }\\n\\n        int leftDistance = Math.abs(heaters[start] - house);\\n        int rightDistance = Math.abs(heaters[end] - house);\\n\\n        return Math.min(leftDistance, rightDistance);\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\npublic class Solution {\\n    /**\\n     * @param houses: positions of houses\\n     * @param heaters: positions of heaters\\n     * @return: the minimum radius standard of heaters\\n     */\\n    public int findRadius(int[] houses, int[] heaters) {\\n        if(houses == null || houses.length == 0 || heaters == null || heaters.length == 0){\\n            return 0;\\n        }\\n\\n        // copy the heaters for sorting in ascending order\\n        int n = heaters.length;\\n        int[] copy = new int[n];\\n        for(int i = 0; i < n; i++){\\n            copy[i] = heaters[i];\\n        }\\n\\n        Arrays.sort(copy);\\n\\n        // for each house, find closest heater distance. Then max\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 0; i < houses.length; i++){\\n            int distance = getMinRadiu(houses[i], copy);\\n            res = Math.max(res, distance);\\n        }\\n        return res;\\n    }\\n\\n    private int getMinRadiu(int house, int[] heaters){\\n        int start = 0;\\n        int end = heaters.length - 1;\\n        while(start + 1 < end){\\n            int mid = start + (end - start) / 2;\\n            if(heaters[mid] <= house){\\n                start = mid;\\n            }else{\\n                end = mid;\\n            }\\n        }\\n\\n        int leftDistance = Math.abs(heaters[start] - house);\\n        int rightDistance = Math.abs(heaters[end] - house);\\n\\n        return Math.min(leftDistance, rightDistance);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683877,
                "title": "heaters-c-simple-solution-binary-search",
                "content": "**C++ Simple Solution**\\n\\n* If we observe carefully we have to find out the max value of min distance of closest heater of every house.\\n* So we traverse the entire house vector and for every house we find out the closest two heaters and minimum distance form it and so forth we maximize this value.\\n* So problem ultimately turns out to be finding the ceil and floor of every bvalue of house vector.\\n\\nTC : O(nlogn) SC : O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    pair<int,int> binarySearch(vector<int> &arr, int key, int n){\\n        int lo = 0;\\n        int hi = n-1;\\n        pair<int,int> res;\\n        res.first = -1;\\n        res.second = -1;\\n\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(arr[mid] == key){\\n                res.first = arr[mid];\\n                res.second = arr[mid];\\n                break;\\n            }else if(arr[mid] < key){\\n                res.first = arr[mid];\\n                lo = mid + 1;\\n            }else{\\n                res.second = arr[mid];\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(), heaters.end());\\n        int ans = INT_MIN;\\n        int n = houses.size();\\n        int m = heaters.size();\\n\\n        //Traverse the entire houses array and find out the floor and ceil of every value\\n        for(int i=0;i<n;i++){\\n            int hp = houses[i];\\n            pair<int, int> val = binarySearch(heaters, hp, m);\\n\\n            int d1, d2;\\n            d1 = (val.first == -1 ? INT_MAX : hp - val.first);\\n            d2 = (val.second == -1 ? INT_MAX : val.second - hp);\\n\\n            int currval = min(d1, d2);\\n            ans = max (ans, currval);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    pair<int,int> binarySearch(vector<int> &arr, int key, int n){\\n        int lo = 0;\\n        int hi = n-1;\\n        pair<int,int> res;\\n        res.first = -1;\\n        res.second = -1;\\n\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(arr[mid] == key){\\n                res.first = arr[mid];\\n                res.second = arr[mid];\\n                break;\\n            }else if(arr[mid] < key){\\n                res.first = arr[mid];\\n                lo = mid + 1;\\n            }else{\\n                res.second = arr[mid];\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(), heaters.end());\\n        int ans = INT_MIN;\\n        int n = houses.size();\\n        int m = heaters.size();\\n\\n        //Traverse the entire houses array and find out the floor and ceil of every value\\n        for(int i=0;i<n;i++){\\n            int hp = houses[i];\\n            pair<int, int> val = binarySearch(heaters, hp, m);\\n\\n            int d1, d2;\\n            d1 = (val.first == -1 ? INT_MAX : hp - val.first);\\n            d2 = (val.second == -1 ? INT_MAX : val.second - hp);\\n\\n            int currval = min(d1, d2);\\n            ans = max (ans, currval);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673590,
                "title": "java-binary-search-sorting-two-pointer-clear-code",
                "content": "Please upvote if you find it useful! Or leave comments and suggestions below.\\nI will try my best to answer them! THANK YOU!\\n```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters); \\n        int left = 0, right = 1000000001;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (!canCoverAllHouses(houses, heaters, mid)) {\\n                left = mid + 1;\\n            }else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    // two pointer O(n) to determine if all houses can be covered by the heaters\\n    private boolean canCoverAllHouses(int[] houses, int[] heaters, int dist) {\\n        // i for houses, j for heaters\\n        int i = 0, j = 0;\\n        \\n        while (i < houses.length) {\\n            int curHouse = houses[i++];\\n            \\n            while (j < heaters.length && Math.abs(curHouse - heaters[j]) > dist) {\\n                j++;\\n            }\\n            \\n            if (j >= heaters.length) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters); \\n        int left = 0, right = 1000000001;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (!canCoverAllHouses(houses, heaters, mid)) {\\n                left = mid + 1;\\n            }else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    // two pointer O(n) to determine if all houses can be covered by the heaters\\n    private boolean canCoverAllHouses(int[] houses, int[] heaters, int dist) {\\n        // i for houses, j for heaters\\n        int i = 0, j = 0;\\n        \\n        while (i < houses.length) {\\n            int curHouse = houses[i++];\\n            \\n            while (j < heaters.length && Math.abs(curHouse - heaters[j]) > dist) {\\n                j++;\\n            }\\n            \\n            if (j >= heaters.length) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648995,
                "title": "easy-to-understand-beats-92-with-explanation-java-and-python",
                "content": "Since the radius of all heaters is the same,  we need to find the maximum of all heaters\\' radius. For each houses[i], we need to find the closest 2 heaters (if applicable) and get the mininum distance between those two. For each houses[i ], there are three cases we need to consider:\\ncase 1) heaters[0] >= houses[i], that means the min distance would be from houses[i] to heaters[0].\\n![image](https://assets.leetcode.com/users/images/ee5b410a-2647-4721-a408-b715a5b7ad14_1640542542.7807658.png)\\ncase 2) heaters[len-1] <= houses[i], that means the min distance would be from house[i] to heaters[heaters.len-1].\\n![image](https://assets.leetcode.com/users/images/38efbbe7-9a95-4ab5-a0b1-e8c9c5a2b07b_1640542576.888275.png)\\ncase 3) houses[i] in between heaters[j] and heaters[j+1], we need to get minimum distance from houses[i] to both of those two heaters.\\n![image](https://assets.leetcode.com/users/images/1186cdf8-84d3-4553-932e-8df13d801b14_1640542590.031931.png)\\nAfter sorted heaters array, we dont need to go back if we iterate the array, we only need to use heaters[j] and heaters[j+1]  to compare. \\n```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n\\t\\t//sort both arrays to make sure the smaller locations in the front.\\n        Arrays.sort(houses); //O(nlogn)\\n        Arrays.sort(heaters); //O(mlogm)\\n        \\n        int j = 0; \\n        int radius = 0, res = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < houses.length; i++) { // O(n)\\n\\t\\t\\t//iterate heaters \\n            while (j < heaters.length && heaters[j] < houses[i]) { // j doesn\\'t go back, so O(m)\\n                j++;\\n            }\\n\\t\\t\\t//case 2: the last one (greatest number in heaters) is less the houses[i], the closest distance is from current house to the last heater\\'s location.\\n            if (j == heaters.length)\\n                radius = Math.abs(houses[i] - heaters[j-1]);\\n            else if (j == 0) // case 1: edge case\\n                radius = Math.abs(houses[i] - heaters[j]);\\n            else  // case 3: houses[i] is in between.\\n                radius = Math.min(Math.abs(houses[i] - heaters[j]), Math.abs(houses[i] - heaters[j - 1]));\\n\\t\\t\\t// find the max in radius.\\n            res = Math.max(res, radius);\\n        }\\n        return res;\\n    }\\n}\\n\\nTime Complexity: O(m+n)\\nSpace Complexity: O(1)\\n```\\nPython\\n```\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        houses.sort()\\n        heaters.sort()\\n        m, n = len(heaters), len(houses)\\n        j, radius, res = 0, 0, 0\\n        \\n        for i in range(n):\\n            while j < m and heaters[j] < houses[i]:\\n                j += 1\\n            \\n            if j == len(heaters):\\n                radius = abs(houses[i] - heaters[j-1])\\n            elif j == 0:\\n                radius = abs(houses[i] - heaters[j])\\n            else :\\n                radius = min(abs(houses[i] - heaters[j]), abs(houses[i] - heaters[j - 1]))\\n            res = max(res, radius)\\n        return res\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n\\t\\t//sort both arrays to make sure the smaller locations in the front.\\n        Arrays.sort(houses); //O(nlogn)\\n        Arrays.sort(heaters); //O(mlogm)\\n        \\n        int j = 0; \\n        int radius = 0, res = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i < houses.length; i++) { // O(n)\\n\\t\\t\\t//iterate heaters \\n            while (j < heaters.length && heaters[j] < houses[i]) { // j doesn\\'t go back, so O(m)\\n                j++;\\n            }\\n\\t\\t\\t//case 2: the last one (greatest number in heaters) is less the houses[i], the closest distance is from current house to the last heater\\'s location.\\n            if (j == heaters.length)\\n                radius = Math.abs(houses[i] - heaters[j-1]);\\n            else if (j == 0) // case 1: edge case\\n                radius = Math.abs(houses[i] - heaters[j]);\\n            else  // case 3: houses[i] is in between.\\n                radius = Math.min(Math.abs(houses[i] - heaters[j]), Math.abs(houses[i] - heaters[j - 1]));\\n\\t\\t\\t// find the max in radius.\\n            res = Math.max(res, radius);\\n        }\\n        return res;\\n    }\\n}\\n\\nTime Complexity: O(m+n)\\nSpace Complexity: O(1)\\n```\n```\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type heaters: List[int]\\n        :rtype: int\\n        \"\"\"\\n        houses.sort()\\n        heaters.sort()\\n        m, n = len(heaters), len(houses)\\n        j, radius, res = 0, 0, 0\\n        \\n        for i in range(n):\\n            while j < m and heaters[j] < houses[i]:\\n                j += 1\\n            \\n            if j == len(heaters):\\n                radius = abs(houses[i] - heaters[j-1])\\n            elif j == 0:\\n                radius = abs(houses[i] - heaters[j])\\n            else :\\n                radius = min(abs(houses[i] - heaters[j]), abs(houses[i] - heaters[j - 1]))\\n            res = max(res, radius)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591831,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    typedef long long ll;\\n    bool check(ll m,vector<int> house,vector<int> heater){\\n        \\n        int c=0;\\n        int n=house.size();\\n        int j=0,k=heater.size();\\n        for(int i=0;i<n;i++){\\n            if(j==k)return false;\\n            ll t=heater[j],x=house[i];\\n            if(t-m>x || t+m<x){\\n                j++;\\n                i--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int findRadius(vector<int>& house, vector<int>& heater) {\\n        \\n        ll l=0,h=INT_MAX;\\n        ll ans;\\n        \\n        sort(house.begin(),house.end());\\n        sort(heater.begin(),heater.end());\\n        \\n        while(l<=h){\\n            ll m=(l+h)/2;\\n            \\n            if(check(m,house,heater)){\\n                ans=m;\\n                h=m-1;\\n            }else{\\n                l=m+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    typedef long long ll;\\n    bool check(ll m,vector<int> house,vector<int> heater){\\n        \\n        int c=0;\\n        int n=house.size();\\n        int j=0,k=heater.size();\\n        for(int i=0;i<n;i++){\\n            if(j==k)return false;\\n            ll t=heater[j],x=house[i];\\n            if(t-m>x || t+m<x){\\n                j++;\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1519900,
                "title": "python-binary-search-clean",
                "content": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        \\n        nHeater = len(heaters)\\n        heaters.sort()\\n        maxDistance = - math.inf\\n        for house in houses:\\n            index = bisect_left(heaters, house)\\n            if index == 0:\\n                maxDistance = max(maxDistance, abs(house-heaters[index]))\\n            elif index == nHeater:\\n                maxDistance = max(maxDistance, abs(house-heaters[index-1]))\\n            else:\\n                maxDistance = max(maxDistance, min(abs(house-heaters[index-1]), abs(house-heaters[index])))\\n        return maxDistance\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        \\n        nHeater = len(heaters)\\n        heaters.sort()\\n        maxDistance = - math.inf\\n        for house in houses:\\n            index = bisect_left(heaters, house)\\n            if index == 0:\\n                maxDistance = max(maxDistance, abs(house-heaters[index]))\\n            elif index == nHeater:\\n                maxDistance = max(maxDistance, abs(house-heaters[index-1]))\\n            else:\\n                maxDistance = max(maxDistance, min(abs(house-heaters[index-1]), abs(house-heaters[index])))\\n        return maxDistance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507527,
                "title": "c-two-solution-100-fast",
                "content": "\\t//Using Binary Search\\n\\tclass Solution {\\n\\tpublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(),heaters.end());\\n        heaters.push_back(INT_MAX);\\n        int ans=0;\\n        for(int i=0;i<houses.size();++i){\\n            int hopos=houses[i];\\n            int low=0,high=heaters.size()-1,ld=INT_MAX,rd=INT_MAX;\\n            while(low <= high){\\n                int mid=(low+high)/2;\\n                if(heaters[mid] == hopos){\\n                    ld=0;rd=0;\\n                    break;\\n                } else if(hopos < heaters[mid]){\\n                    rd=heaters[mid]-hopos;\\n                    high=mid-1;\\n                } else { \\n                    ld=hopos-heaters[mid];\\n                    low=mid+1;\\n                }\\n            }\\n            ans=max(ans,min(ld,rd));\\n        }\\n        return ans;\\n    }\\n\\t};\\n\\t\\n\\t//Leveraging the use of Binary Search\\n\\tclass Solution {\\n\\tpublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        int radius=0,t_radius;\\n        int j=0;\\n        heaters.push_back(INT_MAX);\\n        for(int i=0;i<houses.size();i++)\\n        {\\n               while(heaters[j]<houses[i])\\n                  j++;\\n            if(j==0)\\n                radius=max(radius,heaters[j]-houses[i]);\\n            else\\n            {\\n                t_radius=min(heaters[j]-houses[i],houses[i]-heaters[j-1]);\\n                radius=max(radius,t_radius);\\n            }\\n        }\\n        return radius;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(),heaters.end());\\n        heaters.push_back(INT_MAX);\\n        int ans=0;\\n        for(int i=0;i<houses.size();++i){\\n            int hopos=houses[i];\\n            int low=0,high=heaters.size()-1,ld=INT_MAX,rd=INT_MAX;\\n            while(low <= high){\\n                int mid=(low+high)/2;\\n                if(heaters[mid] == hopos){\\n                    ld=0;rd=0;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1477900,
                "title": "c-solution-using-set",
                "content": "```\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        set<int> house_set, heater_set;\\n        for(int house : houses) house_set.insert(house);\\n        for(int heater : heaters) heater_set.insert(heater);       \\n        int max_r=0;\\n        for(int house : house_set) {\\n            auto close_heater=heater_set.lower_bound(house);\\n            int close_r=INT_MAX;\\n            if(close_heater!=heater_set.end()) close_r=*close_heater-house;\\n            if(close_heater!=heater_set.begin()) close_r=min(close_r, house-*(--close_heater));\\n            max_r=max(max_r, close_r);\\n        }\\n        return max_r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        set<int> house_set, heater_set;\\n        for(int house : houses) house_set.insert(house);\\n        for(int heater : heaters) heater_set.insert(heater);       \\n        int max_r=0;\\n        for(int house : house_set) {\\n            auto close_heater=heater_set.lower_bound(house);\\n            int close_r=INT_MAX;\\n            if(close_heater!=heater_set.end()) close_r=*close_heater-house;\\n            if(close_heater!=heater_set.begin()) close_r=min(close_r, house-*(--close_heater));\\n            max_r=max(max_r, close_r);\\n        }\\n        return max_r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1472397,
                "title": "java-binary-search",
                "content": "```\\npublic int findClosest(int[] heaters, int house) {\\n    if(house < heaters[0]) return heaters[0];\\n    if(house > heaters[heaters.length-1]) return heaters[heaters.length-1];\\n    \\n    int left = 0, right = heaters.length - 1;\\n    while(left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if(heaters[mid] == house) return heaters[mid];\\n        else if(heaters[mid] > house) right = mid - 1;\\n        else left = mid + 1;\\n    }\\n    \\n    return Math.abs(heaters[left] - house) < Math.abs(heaters[right] - house) ? heaters[left] : heaters[right];\\n}\\n\\npublic int findRadius(int[] houses, int[] heaters) {\\n    int radius = 0;\\n    Arrays.sort(heaters);\\n    for(int house: houses) {\\n        int heater = findClosest(heaters, house);\\n        radius = Math.max(radius, Math.abs(heater - house));\\n    }\\n    \\n    return radius;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findClosest(int[] heaters, int house) {\\n    if(house < heaters[0]) return heaters[0];\\n    if(house > heaters[heaters.length-1]) return heaters[heaters.length-1];\\n    \\n    int left = 0, right = heaters.length - 1;\\n    while(left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if(heaters[mid] == house) return heaters[mid];\\n        else if(heaters[mid] > house) right = mid - 1;\\n        else left = mid + 1;\\n    }\\n    \\n    return Math.abs(heaters[left] - house) < Math.abs(heaters[right] - house) ? heaters[left] : heaters[right];\\n}\\n\\npublic int findRadius(int[] houses, int[] heaters) {\\n    int radius = 0;\\n    Arrays.sort(heaters);\\n    for(int house: houses) {\\n        int heater = findClosest(heaters, house);\\n        radius = Math.max(radius, Math.abs(heater - house));\\n    }\\n    \\n    return radius;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400595,
                "title": "java-using-modified-binary-search-and-sorting-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int max = 0;\\n        Arrays.sort(heaters);\\n\\n        for (int i = 0; i < houses.length; i++) {\\n            \\n            // search the heater closest to the current house houses[i]\\n            int dist = Integer.MAX_VALUE;\\n            int low  = 0;\\n            int high = heaters.length - 1;\\n            while (low <= high) {\\n                int mid = (high - low)/2 + low;\\n                if (heaters[mid] > houses[i]) high = mid - 1;\\n                else if (heaters[mid] < houses[i]) low = mid + 1;\\n                else {\\n                    low = mid;\\n                    break;\\n                }\\n            }\\n            \\n            if (high < 0) dist = heaters[0] - houses[i];\\n            else if (low >= heaters.length)\\n                dist = houses[i] - heaters[heaters.length - 1];\\n            else dist = Math.min(Math.abs(heaters[low] - houses[i]), \\n                                Math.abs(heaters[high] - houses[i]));\\n            max = Math.max(max, dist);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int max = 0;\\n        Arrays.sort(heaters);\\n\\n        for (int i = 0; i < houses.length; i++) {\\n            \\n            // search the heater closest to the current house houses[i]\\n            int dist = Integer.MAX_VALUE;\\n            int low  = 0;\\n            int high = heaters.length - 1;\\n            while (low <= high) {\\n                int mid = (high - low)/2 + low;\\n                if (heaters[mid] > houses[i]) high = mid - 1;\\n                else if (heaters[mid] < houses[i]) low = mid + 1;\\n                else {\\n                    low = mid;\\n                    break;\\n                }\\n            }\\n            \\n            if (high < 0) dist = heaters[0] - houses[i];\\n            else if (low >= heaters.length)\\n                dist = houses[i] - heaters[heaters.length - 1];\\n            else dist = Math.min(Math.abs(heaters[low] - houses[i]), \\n                                Math.abs(heaters[high] - houses[i]));\\n            max = Math.max(max, dist);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365372,
                "title": "c-binary-search-easy",
                "content": "```\\n\\n```public:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n       long long int i,j,l=0,r=INT_MAX,res=-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            j=0;\\n            for(i=0;i<heaters.size();i++)\\n            {\\n                while(j<houses.size()&&abs(houses[j]-heaters[i])<=mid)\\n                {\\n                    j++;\\n                }\\n            }\\n            if(j==houses.size())\\n            {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1364844,
                "title": "c-binary-search-and-two-pointers",
                "content": "We do a binary search on the radius value. How do we validate if the generated radius is enough? That can be done with the help of two pointers, which enables us to do each validation is ```O(N+M)``` time. For this 2 pointer approaach to work, we must sort both the arrays first and for each heater start checking from the start of the remaining houses and update it.\\n\\n```\\n#define itr(v) v.begin(),v.end()\\nint findRadius(vector<int>& houses, vector<int>& heaters) \\n{\\n\\tsort(itr(heaters));\\n\\tsort(itr(houses));\\n\\tint start=0,end=1e9;\\n\\twhile(start<end)\\n\\t{\\n\\t\\tint q=start+(end-start)/2;\\n\\t\\tint j=0; // variable pointing to the next non-heated house\\n\\t\\tfor(int i=0;i<heaters.size();++i)\\n\\t\\t\\twhile(j<houses.size()&&houses[j]>=heaters[i]-q&&houses[j]<=heaters[i]+q)\\n\\t\\t\\t\\tj++;\\n\\t\\tif(j==houses.size())\\n\\t\\t\\tend=q;\\n\\t\\telse start=q+1;\\n\\t}\\n\\treturn end;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```O(N+M)```\n```\\n#define itr(v) v.begin(),v.end()\\nint findRadius(vector<int>& houses, vector<int>& heaters) \\n{\\n\\tsort(itr(heaters));\\n\\tsort(itr(houses));\\n\\tint start=0,end=1e9;\\n\\twhile(start<end)\\n\\t{\\n\\t\\tint q=start+(end-start)/2;\\n\\t\\tint j=0; // variable pointing to the next non-heated house\\n\\t\\tfor(int i=0;i<heaters.size();++i)\\n\\t\\t\\twhile(j<houses.size()&&houses[j]>=heaters[i]-q&&houses[j]<=heaters[i]+q)\\n\\t\\t\\t\\tj++;\\n\\t\\tif(j==houses.size())\\n\\t\\t\\tend=q;\\n\\t\\telse start=q+1;\\n\\t}\\n\\treturn end;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1299802,
                "title": "c-binary-search-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int leftBinary(vector<int>& houses, vector<int>& heaters, int pos){\\n        int n=houses.size();\\n        int m=heaters.size();\\n        int ans=-1;\\n        int l=0;\\n        int r=m-1;\\n        \\n        //Find nearest heater to the left of house at position pos\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(heaters[m]==pos)\\n                return m;\\n            else if(heaters[m]>pos){\\n                r=m-1;\\n            }\\n            else{\\n                ans=m;\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int rightBinary(vector<int>& houses, vector<int>& heaters, int pos){\\n        int n=houses.size();\\n        int m=heaters.size();\\n        int ans=-1;\\n        int l=0;\\n        int r=m-1;\\n        \\n        //Find nearest heater to the right of house at position pos\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(heaters[m]==pos)\\n                return m;\\n            else if(heaters[m]>pos){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        \\n        int n=houses.size();\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int pos=houses[i];\\n            int leftIndex = leftBinary(houses,heaters,pos);\\n            int rightIndex = rightBinary(houses,heaters,pos);\\n            //cout<<leftIndex<<\" \"<<rightIndex<<endl;\\n            if(leftIndex!=-1 && rightIndex!=-1)\\n                ans=max(ans,min(pos-heaters[leftIndex],heaters[rightIndex]-pos));\\n            else if(leftIndex==-1)\\n                ans=max(ans,heaters[rightIndex]-pos);\\n            else\\n                ans=max(ans,pos-heaters[leftIndex]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leftBinary(vector<int>& houses, vector<int>& heaters, int pos){\\n        int n=houses.size();\\n        int m=heaters.size();\\n        int ans=-1;\\n        int l=0;\\n        int r=m-1;\\n        \\n        //Find nearest heater to the left of house at position pos\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(heaters[m]==pos)\\n                return m;\\n            else if(heaters[m]>pos){\\n                r=m-1;\\n            }\\n            else{\\n                ans=m;\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int rightBinary(vector<int>& houses, vector<int>& heaters, int pos){\\n        int n=houses.size();\\n        int m=heaters.size();\\n        int ans=-1;\\n        int l=0;\\n        int r=m-1;\\n        \\n        //Find nearest heater to the right of house at position pos\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(heaters[m]==pos)\\n                return m;\\n            else if(heaters[m]>pos){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(),houses.end());\\n        sort(heaters.begin(),heaters.end());\\n        \\n        int n=houses.size();\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int pos=houses[i];\\n            int leftIndex = leftBinary(houses,heaters,pos);\\n            int rightIndex = rightBinary(houses,heaters,pos);\\n            //cout<<leftIndex<<\" \"<<rightIndex<<endl;\\n            if(leftIndex!=-1 && rightIndex!=-1)\\n                ans=max(ans,min(pos-heaters[leftIndex],heaters[rightIndex]-pos));\\n            else if(leftIndex==-1)\\n                ans=max(ans,heaters[rightIndex]-pos);\\n            else\\n                ans=max(ans,pos-heaters[leftIndex]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1235154,
                "title": "simple-python-solution-o-nlog-n",
                "content": "The ide behind this solution is:\\n- to check all houses between each heater pair and find the minimal distance to cover\\n- add -max, +max to ensure that all houses are inside heaters\\n\\n```\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        houses.sort()\\n        \\n        heaters.append(-sys.maxint)\\n        heaters.append(sys.maxint)\\n        heaters.sort()\\n        \\n        res, j = 0, 0\\n        for i in range(1, len(heaters)):\\n            while j < len(houses) and houses[j] <= heaters[i]:\\n                res = max(res, min(heaters[i]-houses[j], abs(heaters[i-1]-houses[j])))\\n                j += 1\\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "The ide behind this solution is:\\n- to check all houses between each heater pair and find the minimal distance to cover\\n- add -max, +max to ensure that all houses are inside heaters\\n\\n```\\nclass Solution(object):\\n    def findRadius(self, houses, heaters):\\n        houses.sort()\\n        \\n        heaters.append(-sys.maxint)\\n        heaters.append(sys.maxint)\\n        heaters.sort()\\n        \\n        res, j = 0, 0\\n        for i in range(1, len(heaters)):\\n            while j < len(houses) and houses[j] <= heaters[i]:\\n                res = max(res, min(heaters[i]-houses[j], abs(heaters[i-1]-houses[j])))\\n                j += 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1125100,
                "title": "java-binarysearch-naiveapproach",
                "content": "1. We can calculate required radius by BinarySearch\\n2. For checking if every house can be warmed or not \\n\\t2.1 We can check if for every house there is a heater within its (pos+radius),(pos-radius)\\n\\t2.2 We can check it using TreeSet\\n\\n```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int minRadius = 0;\\n        int maxRadius = 1_000_000_000;\\n        TreeSet<Integer> heatersSet = new TreeSet<>();\\n        for(int i:heaters) heatersSet.add(i);\\n        \\n        while(minRadius<maxRadius){\\n            int mid = minRadius + (maxRadius-minRadius) / 2;\\n            if(isWarmed(houses,mid,heatersSet)) maxRadius = mid;\\n            else minRadius = mid+1;\\n        }\\n        return minRadius;\\n        \\n    }\\n    public boolean isWarmed(int[] houses,int radius,TreeSet<Integer> heaters){\\n        for(int i:houses){\\n            Integer heater = heaters.floor(i+radius);\\n            if(heater == null || Math.abs(i-heater) > radius) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int minRadius = 0;\\n        int maxRadius = 1_000_000_000;\\n        TreeSet<Integer> heatersSet = new TreeSet<>();\\n        for(int i:heaters) heatersSet.add(i);\\n        \\n        while(minRadius<maxRadius){\\n            int mid = minRadius + (maxRadius-minRadius) / 2;\\n            if(isWarmed(houses,mid,heatersSet)) maxRadius = mid;\\n            else minRadius = mid+1;\\n        }\\n        return minRadius;\\n        \\n    }\\n    public boolean isWarmed(int[] houses,int radius,TreeSet<Integer> heaters){\\n        for(int i:houses){\\n            Integer heater = heaters.floor(i+radius);\\n            if(heater == null || Math.abs(i-heater) > radius) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119352,
                "title": "binary-search-over-possible-radii",
                "content": "Binary search over the possible radii over [1, 10^9]\\n* For each possible radius, check if all houses can be covered = O ( houses_len * log (10^9) )\\n* To achieve O(N) for each check over all houses, we need O(1) to check each house. So we need O(1) to find nearest heaters given a house. One solution is to use a map:\\n\\t* Sort heaters to help find nearest heaters given a house in O(logn) time. Sort time = O( heaters_len * log(heaters_len) )\\n\\t* For each house, find (via binary search) nearest heater(s): time = O( houses_len * log(heaters_len) ); record the heater(s) in the map\\n\\n\\nOverall\\nTime: max {O( heaters_len * log(heaters_len) ), O( houses_len * log(heaters_len) ), O ( houses_len * log (10^9) ) }\\nSpace: O(houses_len) for the map\\n\\n\\nPS: poor performance. It beats only ~10% in time and space. However I do feel this is a more generic solution, which may easily extend to 2-D, 3-D, ..., n-dimentional use cases, where the ordering is ambiguous.\\n\\n\\n```\\nclass Solution {\\n    \\n    int[] houses;\\n    int[] heaters;\\n    \\n    // find nearest heater(s) for each house\\n    Map<Integer, Set<Integer>> map = new HashMap<>();\\n    \\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        this.houses = houses;\\n        this.heaters = heaters;\\n        computeNearestHeaters();\\n            \\n        int lo = 0, hi = 1000_000_000;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (isValid(mid)) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return hi;\\n    }\\n\\n    void computeNearestHeaters() {\\n        for (int h : houses) {\\n            int insert = Arrays.binarySearch(heaters, h);\\n            \\n            if (insert < 0) {\\n                Set<Integer> set = new HashSet<>();\\n                insert = -insert - 1;\\n                if (insert == 0) {\\n                    set.add(heaters[0]);\\n                }\\n                else if (insert == heaters.length) {\\n                    set.add(heaters[heaters.length - 1]);\\n                }\\n                else {\\n                    set.add(heaters[insert]);\\n                    set.add(heaters[insert - 1]);\\n                }\\n                map.put(h, set);\\n            } \\n            // if insertion >= 0, there is a heater sitting at house\\n        }\\n    }\\n    \\n    boolean isValid(int radius) {\\n        for (int house : houses) {\\n            if (map.containsKey(house)) {\\n                boolean covered = false;\\n                for (int heater : map.get(house)) {\\n                    if (house >= heater - radius \\n                        && house <= heater + radius) {\\n                        covered = true;\\n                    }\\n                }\\n                if (!covered) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n(for myself only) The binary search solution mostly accepted:\\n\\n```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        \\n        int res = 0;\\n        for (int house : houses) {\\n            int insert = Arrays.binarySearch(heaters, house);\\n            if (insert >= 0) continue;\\n            \\n            insert = -1 - insert;\\n            int leftRadius = Integer.MAX_VALUE, rightRadius = Integer.MAX_VALUE;\\n            \\n            // all heaters on RHS of the house\\n            if (insert == 0) {\\n                rightRadius = heaters[0] - house;\\n            }\\n            \\n            // all heaters on LHS of the house\\n            else if (insert == heaters.length) {\\n                leftRadius = house - heaters[heaters.length - 1];\\n            }\\n\\n            // heaters present on both LHS and RHS of the house\\n            else {\\n                leftRadius = house - heaters[insert - 1];\\n                rightRadius = heaters[insert] - house;\\n            }\\n            \\n            int radiusNeeded = Math.min(leftRadius, rightRadius);\\n            res = Math.max(res, radiusNeeded);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[] houses;\\n    int[] heaters;\\n    \\n    // find nearest heater(s) for each house\\n    Map<Integer, Set<Integer>> map = new HashMap<>();\\n    \\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        this.houses = houses;\\n        this.heaters = heaters;\\n        computeNearestHeaters();\\n            \\n        int lo = 0, hi = 1000_000_000;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (isValid(mid)) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return hi;\\n    }\\n\\n    void computeNearestHeaters() {\\n        for (int h : houses) {\\n            int insert = Arrays.binarySearch(heaters, h);\\n            \\n            if (insert < 0) {\\n                Set<Integer> set = new HashSet<>();\\n                insert = -insert - 1;\\n                if (insert == 0) {\\n                    set.add(heaters[0]);\\n                }\\n                else if (insert == heaters.length) {\\n                    set.add(heaters[heaters.length - 1]);\\n                }\\n                else {\\n                    set.add(heaters[insert]);\\n                    set.add(heaters[insert - 1]);\\n                }\\n                map.put(h, set);\\n            } \\n            // if insertion >= 0, there is a heater sitting at house\\n        }\\n    }\\n    \\n    boolean isValid(int radius) {\\n        for (int house : houses) {\\n            if (map.containsKey(house)) {\\n                boolean covered = false;\\n                for (int heater : map.get(house)) {\\n                    if (house >= heater - radius \\n                        && house <= heater + radius) {\\n                        covered = true;\\n                    }\\n                }\\n                if (!covered) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(heaters);\\n        \\n        int res = 0;\\n        for (int house : houses) {\\n            int insert = Arrays.binarySearch(heaters, house);\\n            if (insert >= 0) continue;\\n            \\n            insert = -1 - insert;\\n            int leftRadius = Integer.MAX_VALUE, rightRadius = Integer.MAX_VALUE;\\n            \\n            // all heaters on RHS of the house\\n            if (insert == 0) {\\n                rightRadius = heaters[0] - house;\\n            }\\n            \\n            // all heaters on LHS of the house\\n            else if (insert == heaters.length) {\\n                leftRadius = house - heaters[heaters.length - 1];\\n            }\\n\\n            // heaters present on both LHS and RHS of the house\\n            else {\\n                leftRadius = house - heaters[insert - 1];\\n                rightRadius = heaters[insert] - house;\\n            }\\n            \\n            int radiusNeeded = Math.min(leftRadius, rightRadius);\\n            res = Math.max(res, radiusNeeded);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107273,
                "title": "c-sort-o-n-with-some-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n\\t\\tsort(houses.begin(), houses.end()); // make sure they are ascending\\n        sort(heaters.begin(), heaters.end());\\n        // if the size of heater is 1, just check for the boundary case\\n        if(heaters.size()==1)   return max(abs(houses[0]-heaters[0]), abs(houses.back()-heaters[0]));\\n        \\n        int ans=0, j=0;\\n        for(int i=0 ; i<houses.size() ; i++){\\n\\t\\t    // shift to next if the radius needed for j heater is larger j+1\\n            while(j<(heaters.size()-1) && abs(houses[i]-heaters[j])>=abs(houses[i]-heaters[j+1])){\\n                j++;\\n            }\\n            // update the ans\\n            ans = max(ans, abs(houses[i]-heaters[j]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n\\t\\tsort(houses.begin(), houses.end()); // make sure they are ascending\\n        sort(heaters.begin(), heaters.end());\\n        // if the size of heater is 1, just check for the boundary case\\n        if(heaters.size()==1)   return max(abs(houses[0]-heaters[0]), abs(houses.back()-heaters[0]));\\n        \\n        int ans=0, j=0;\\n        for(int i=0 ; i<houses.size() ; i++){\\n\\t\\t    // shift to next if the radius needed for j heater is larger j+1\\n            while(j<(heaters.size()-1) && abs(houses[i]-heaters[j])>=abs(houses[i]-heaters[j+1])){\\n                j++;\\n            }\\n            // update the ans\\n            ans = max(ans, abs(houses[i]-heaters[j]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098934,
                "title": "c-100-runtime-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(begin(houses),end(houses));\\n        sort(begin(heaters),end(heaters));\\n        int result{0}, heaterIndex{0};\\n        for (int h:houses){\\n            int dist = abs(heaters[heaterIndex]-h);\\n            for(int j = heaterIndex+1; j<heaters.size();j++){\\n                int dist1 = abs(heaters[j]-h);\\n                if (dist1<=dist){\\n                    dist = dist1;\\n                    heaterIndex = j;\\n                }\\n                else break;\\n            }\\n            result = max(result, dist);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(begin(houses),end(houses));\\n        sort(begin(heaters),end(heaters));\\n        int result{0}, heaterIndex{0};\\n        for (int h:houses){\\n            int dist = abs(heaters[heaterIndex]-h);\\n            for(int j = heaterIndex+1; j<heaters.size();j++){\\n                int dist1 = abs(heaters[j]-h);\\n                if (dist1<=dist){\\n                    dist = dist1;\\n                    heaterIndex = j;\\n                }\\n                else break;\\n            }\\n            result = max(result, dist);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032862,
                "title": "c-beats-98-no-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        int n=houses.size();\\n        int m=heaters.size();\\n        vector<int> a(n, INT_MAX);\\n        \\n        for(int i=0,j=0;i<n && j<m;){\\n            if(houses[i]<=heaters[j]){\\n                a[i]=heaters[j]-houses[i];\\n                i++;\\n            }\\n            else\\n                j++;\\n        }\\n        \\n        for(int i=n-1,j=m-1;i>=0 && j>=0;){\\n            if(houses[i]>=heaters[j]){\\n                a[i]=min(houses[i]-heaters[j],a[i]);\\n                i--;\\n            }\\n            else\\n                j--;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            ans=max(ans,a[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        int n=houses.size();\\n        int m=heaters.size();\\n        vector<int> a(n, INT_MAX);\\n        \\n        for(int i=0,j=0;i<n && j<m;){\\n            if(houses[i]<=heaters[j]){\\n                a[i]=heaters[j]-houses[i];\\n                i++;\\n            }\\n            else\\n                j++;\\n        }\\n        \\n        for(int i=n-1,j=m-1;i>=0 && j>=0;){\\n            if(houses[i]>=heaters[j]){\\n                a[i]=min(houses[i]-heaters[j],a[i]);\\n                i--;\\n            }\\n            else\\n                j--;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            ans=max(ans,a[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015720,
                "title": "simple-c-solution-with-explanation",
                "content": "First sort houses and heaters respectively, then for each house, calculate the min distance to the left and right side heaters. The result is the maximum of those mins.\\n\\n```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(begin(houses), end(houses));\\n        sort(begin(heaters), end(heaters));\\n        \\n        int i = 0;\\n        int res = 0;\\n        \\n        for (auto house : houses) {\\n            // Move heater to the right side of current house\\n            while(i<heaters.size() && house > heaters[i]){\\n                i++;\\n            }\\n            // Calculate distance to the left and right side heater\\n            int left = i==0? INT_MAX : house-heaters[i-1];\\n            int right = i == heaters.size()? INT_MAX : heaters[i]-house;\\n                     \\n            res = max(res, min(left, right));\\n        }\\n\\n        return res;                          \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(begin(houses), end(houses));\\n        sort(begin(heaters), end(heaters));\\n        \\n        int i = 0;\\n        int res = 0;\\n        \\n        for (auto house : houses) {\\n            // Move heater to the right side of current house\\n            while(i<heaters.size() && house > heaters[i]){\\n                i++;\\n            }\\n            // Calculate distance to the left and right side heater\\n            int left = i==0? INT_MAX : house-heaters[i-1];\\n            int right = i == heaters.size()? INT_MAX : heaters[i]-house;\\n                     \\n            res = max(res, min(left, right));\\n        }\\n\\n        return res;                          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903756,
                "title": "python-clean-simple-solution-o-nlogn-with-explanation",
                "content": "First, let\\'s reformulate the problem statement. For any given house, we want to find the distance of the heater CLOSEST to it. We want to find the MAX of these heater distances. This gives us the minimum REQUIRED radius to cover all houses. A O(n^2) solution is relatively simple. Iterate over all houses: For each house, iterate over all heaters, get the shortest distance. After all distances are collected, get the max. \\n\\nBut we can do better. First, note that any duplicates are useless information for the problem, since we are interested in distance. Multiple heaters in one location does not magnify power, and multiple houses in one location does not require more heat. Next, note that if we sort both lists, the problem structure signficantly reduces the space we have to search. Iterate over sorted houses: For each house, iterate over heaters and get the shortest distance. But how many heaters do we need to iterate over? We know house[n] is greater than its neighbor house[n-1]. If the closest heater to house[n-1] is heater[t], then we know the closest heater to house[n], house[n] being GREATER than house[n-1], CANNOT fall to the left of heater[t]. In fact, it must be heater[t] or heater[some value greater than t]. \\n\\nThere is also a nice \"peak\" structure to the problem. Imagine we are iterating over heaters for a given house. If we encounter a distance smaller than all distances seen previously, and the distance after that is greater than the min distance we just encountered, we know we can stop looking. Any heater after is only getting further away than the min distance. \\n\\nAs a result, we can see that our iteration makes exactly one pass over the heater list. Let len(heaters) = m, len(houses) = n. Our Big O runtime is O(nlogn + mlogm) in order to sort the two lists. Iteration drops out in Big O terms, since that only requires O(m) work.\\n\\nHere is the code: \\n\\n```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses,heaters = list(set(houses)),list(set(heaters)) #get rid of duplicates, they are inconsequential\\n        houses,heaters = sorted(houses),sorted(heaters)\\n        min_rad,start = 0,0\\n        heater_len = len(heaters)\\n        for house in houses:\\n            rad = float(\\'inf\\')\\n            for n in range(start,heater_len):\\n                dist = abs(house-heaters[n])\\n                if dist >= rad:\\n                    start = max(n-1,0) #don\\'t want zero index spilling back to -1\\n                    break\\n                if dist < rad:\\n                    rad = dist\\n            if rad > min_rad:\\n                min_rad = rad\\n        return min_rad\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\\n        houses,heaters = list(set(houses)),list(set(heaters)) #get rid of duplicates, they are inconsequential\\n        houses,heaters = sorted(houses),sorted(heaters)\\n        min_rad,start = 0,0\\n        heater_len = len(heaters)\\n        for house in houses:\\n            rad = float(\\'inf\\')\\n            for n in range(start,heater_len):\\n                dist = abs(house-heaters[n])\\n                if dist >= rad:\\n                    start = max(n-1,0) #don\\'t want zero index spilling back to -1\\n                    break\\n                if dist < rad:\\n                    rad = dist\\n            if rad > min_rad:\\n                min_rad = rad\\n        return min_rad\\n```",
                "codeTag": "Java"
            },
            {
                "id": 901045,
                "title": "o-n-after-sorting-beat-100-no-need-for-binary-search",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        long left = Integer.MIN_VALUE, right = heaters[0];\\n        int j = 0;\\n        long minRadium = 0;\\n        for (int i = 0; i < houses.length; i++) {\\n            while (houses[i] > right) {\\n                j++;\\n                left = heaters[j-1];\\n                if (j >= heaters.length) {\\n                    right = Integer.MAX_VALUE;\\n                } else {\\n                    right = heaters[j];\\n                }\\n            }\\n            minRadium = Math.max(minRadium, Math.min(houses[i]-left, right-houses[i]));\\n        }\\n        return (int)minRadium;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        long left = Integer.MIN_VALUE, right = heaters[0];\\n        int j = 0;\\n        long minRadium = 0;\\n        for (int i = 0; i < houses.length; i++) {\\n            while (houses[i] > right) {\\n                j++;\\n                left = heaters[j-1];\\n                if (j >= heaters.length) {\\n                    right = Integer.MAX_VALUE;\\n                } else {\\n                    right = heaters[j];\\n                }\\n            }\\n            minRadium = Math.max(minRadium, Math.min(houses[i]-left, right-houses[i]));\\n        }\\n        return (int)minRadium;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900124,
                "title": "easy-to-understand-binary-search-2-pointer-approach",
                "content": "We binary search for minimum radius between 0 and ```N```.\\n\\nTC: O(N*log(M))\\n\\n```\\nN: min(no. of heaters, no. of houses)\\nM: max(distance between first heater and last house, distance between last heater and first house)\\n```\\n\\n```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        int htcount = heaters.length;\\n        int hcount = houses.length;\\n        int hi = Math.max(Math.abs(houses[0]-heaters[htcount-1]),Math.abs(houses[hcount-1]-heaters[0]));\\n        int lo=0;\\n        int ans=hi;\\n        while(lo<=hi) {\\n            int mid=lo+(hi-lo)/2;\\n            if (allWarm(mid,houses,heaters)) {\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else {\\n                lo=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    boolean allWarm(int r,int[]houses,int[]heaters) {\\n        int iHouse=0;\\n        int jHeater=0;\\n        while(iHouse<houses.length && jHeater<heaters.length) {\\n            if (houses[iHouse]>=heaters[jHeater]-r && houses[iHouse]<=heaters[jHeater]+r) {\\n                iHouse++;\\n            }\\n            else {\\n                jHeater++;\\n            }\\n        }\\n        return iHouse==houses.length;\\n    }\\n\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```N```\n```\\nN: min(no. of heaters, no. of houses)\\nM: max(distance between first heater and last house, distance between last heater and first house)\\n```\n```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        int htcount = heaters.length;\\n        int hcount = houses.length;\\n        int hi = Math.max(Math.abs(houses[0]-heaters[htcount-1]),Math.abs(houses[hcount-1]-heaters[0]));\\n        int lo=0;\\n        int ans=hi;\\n        while(lo<=hi) {\\n            int mid=lo+(hi-lo)/2;\\n            if (allWarm(mid,houses,heaters)) {\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else {\\n                lo=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    boolean allWarm(int r,int[]houses,int[]heaters) {\\n        int iHouse=0;\\n        int jHeater=0;\\n        while(iHouse<houses.length && jHeater<heaters.length) {\\n            if (houses[iHouse]>=heaters[jHeater]-r && houses[iHouse]<=heaters[jHeater]+r) {\\n                iHouse++;\\n            }\\n            else {\\n                jHeater++;\\n            }\\n        }\\n        return iHouse==houses.length;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896728,
                "title": "clean-binary-search-30-nlog-n-complexity",
                "content": "```\\nbool fun(int val,vector<int>& house,vector<int>& heaters)\\n    {\\n        for(int i : house)\\n        {\\n            int strt=i-val;\\n            int end=i+val;\\n            auto it = upper_bound(heaters.begin(),heaters.end(),end);\\n            auto it2=lower_bound(heaters.begin(),heaters.end(),strt);\\n            if(it==it2) return(0);\\n        }\\n        return(1);\\n    }\\n    \\n    \\n    int findRadius(vector<int>& house, vector<int>& heaters) \\n    {\\n        sort(heaters.begin(),heaters.end());\\n        \\n        int lo=0,hi=1e9;\\n        int ans;\\n        while(hi>=lo)\\n        {\\n            int mid=(lo+hi)/2;\\n            if(fun(mid,house,heaters))\\n            {\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else lo=mid+1;\\n        }\\n        return(ans);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nbool fun(int val,vector<int>& house,vector<int>& heaters)\\n    {\\n        for(int i : house)\\n        {\\n            int strt=i-val;\\n            int end=i+val;\\n            auto it = upper_bound(heaters.begin(),heaters.end(),end);\\n            auto it2=lower_bound(heaters.begin(),heaters.end(),strt);\\n            if(it==it2) return(0);\\n        }\\n        return(1);\\n    }\\n    \\n    \\n    int findRadius(vector<int>& house, vector<int>& heaters) \\n    {\\n        sort(heaters.begin(),heaters.end());\\n        \\n        int lo=0,hi=1e9;\\n        int ans;\\n        while(hi>=lo)\\n        {\\n            int mid=(lo+hi)/2;\\n            if(fun(mid,house,heaters))\\n            {\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else lo=mid+1;\\n        }\\n        return(ans);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 865296,
                "title": "getting-tle-for-o-mlogn-binary-search-solution",
                "content": "Getting TLE for O(mlogn) solution \\nPlease help.\\n\\nhttps://leetcode.com/submissions/detail/400924389/\\n\\n`\\nclass Solution {\\npublic:\\n    \\n    int getRight(vector<int> v, int val) {\\n        int f=0, l=v.size()-1; int mid=(f+l)/2;\\n        while(f<l) {\\n            if(v[mid]==val)return mid;\\n            if(v[mid]<val) f=mid+1;\\n            else l=mid;\\n            mid=(f+l)/2;\\n        }\\n        return mid;\\n    }\\n    \\n    int abs(int a) {\\n        if(a<0)return -a;return a;\\n    }\\n    \\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        // find nearmost left and nearmost right of all houses in heaters array 1 by 1\\n        // ans is max (min(left dis, right dis)) for all houses\\n        int left, right, ans=0;\\n        sort(heaters.begin(), heaters.end());\\n        for(int i=0; i<houses.size(); i++) {\\n            right = getRight(heaters, houses[i]);\\n            left = (heaters[right]>houses[i] && right>0)?right-1:right;\\n            ans=max(ans, min(abs(houses[i]-heaters[left]), abs(heaters[right]-houses[i])));\\n        }\\n        return ans;\\n    }\\n};\\n`",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int getRight(vector<int> v, int val) {\\n        int f=0, l=v.size()-1; int mid=(f+l)/2;\\n        while(f<l) {\\n            if(v[mid]==val)return mid;\\n            if(v[mid]<val) f=mid+1;\\n            else l=mid;\\n            mid=(f+l)/2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 846877,
                "title": "java-o-nlogn-solution-using-treeset",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        for(int heater: heaters)\\n            tree.add(heater -1);\\n        int radius  = Integer.MIN_VALUE;\\n        for(int i : houses){\\n            i = i-1;\\n            if(tree.contains(i))\\n                radius = Math.max(radius, 0);\\n            else{\\n                Integer lower = tree.lower(i);\\n                Integer higher = tree.higher(i);\\n                if(lower != null && higher != null)\\n                    radius = Math.max(radius, Math.min(higher -i, i- lower));\\n                else if(higher != null)\\n                    radius = Math.max(radius, higher - i);\\n                else if(lower != null)\\n                    radius = Math.max(radius, i - lower);\\n            }\\n        }\\n        return radius;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        for(int heater: heaters)\\n            tree.add(heater -1);\\n        int radius  = Integer.MIN_VALUE;\\n        for(int i : houses){\\n            i = i-1;\\n            if(tree.contains(i))\\n                radius = Math.max(radius, 0);\\n            else{\\n                Integer lower = tree.lower(i);\\n                Integer higher = tree.higher(i);\\n                if(lower != null && higher != null)\\n                    radius = Math.max(radius, Math.min(higher -i, i- lower));\\n                else if(higher != null)\\n                    radius = Math.max(radius, higher - i);\\n                else if(lower != null)\\n                    radius = Math.max(radius, i - lower);\\n            }\\n        }\\n        return radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778869,
                "title": "really-cost-time-understanding-how-to-use-binary-search-intuitive-figure",
                "content": "![image](https://assets.leetcode.com/users/images/ce85ade8-2f7c-4ca5-b7b7-85b77c8b5e89_1596853510.2052042.png)\\n\\nCost my time understanding how to employ binary search for this problem:\\n\\nPython code:\\n```\\nclass Solution:\\n    def findRadius(self, houses, heaters):\\n        # \\u6BCF\\u4E2Ahouse\\uFF0C\\u5BFB\\u627E\\u8DDD\\u79BB\\u5B83\\u6700\\u8FD1\\u7684heater!\\n        # heater.position >= house.position\\u7684\\u6700\\u5C0F\\u7684heater.position \\u7136\\u540E\\u6BD4\\u8F83heater \\u548Cheater-1\\u54EA\\u4E2A\\u8DDD\\u79BBhouse\\u66F4\\u8FD1\\n        houses = sorted(houses)\\n        heaters = sorted(heaters)\\n        \\n        def bsearch(house, heaters):\\n            left = 0\\n            right = len(heaters)\\n            while left < right:\\n                mid = left + (right - left)//2\\n                if heaters[mid] >= house:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            # now left \\u6700\\u5C0F\\uFF0C\\u5E76\\u4E14\\u6EE1\\u8DB3heaters[left] >= house\\n            # \\u5BFB\\u627E\\u6700\\u5C0F\\u8DDD\\u79BB\\uFF01\\n            mindis = 2**31-1\\n            if 0<=left<len(heaters):\\n                mindis = heaters[left] - house\\n            if left-1>=0:\\n                mindis = min(mindis, abs(heaters[left-1] - house))\\n            return mindis\\n        \\n        ans = -1\\n        for house in houses:\\n            mindis = bsearch(house, heaters)\\n            if ans == -1 or mindis > ans:\\n                ans = mindis\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRadius(self, houses, heaters):\\n        # \\u6BCF\\u4E2Ahouse\\uFF0C\\u5BFB\\u627E\\u8DDD\\u79BB\\u5B83\\u6700\\u8FD1\\u7684heater!\\n        # heater.position >= house.position\\u7684\\u6700\\u5C0F\\u7684heater.position \\u7136\\u540E\\u6BD4\\u8F83heater \\u548Cheater-1\\u54EA\\u4E2A\\u8DDD\\u79BBhouse\\u66F4\\u8FD1\\n        houses = sorted(houses)\\n        heaters = sorted(heaters)\\n        \\n        def bsearch(house, heaters):\\n            left = 0\\n            right = len(heaters)\\n            while left < right:\\n                mid = left + (right - left)//2\\n                if heaters[mid] >= house:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            # now left \\u6700\\u5C0F\\uFF0C\\u5E76\\u4E14\\u6EE1\\u8DB3heaters[left] >= house\\n            # \\u5BFB\\u627E\\u6700\\u5C0F\\u8DDD\\u79BB\\uFF01\\n            mindis = 2**31-1\\n            if 0<=left<len(heaters):\\n                mindis = heaters[left] - house\\n            if left-1>=0:\\n                mindis = min(mindis, abs(heaters[left-1] - house))\\n            return mindis\\n        \\n        ans = -1\\n        for house in houses:\\n            mindis = bsearch(house, heaters)\\n            if ans == -1 or mindis > ans:\\n                ans = mindis\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756605,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} houses\\n * @param {number[]} heaters\\n * @return {number}\\n */\\nvar findRadius = function(houses, heaters) {\\n    var findNearest = (n,heaters)=>{\\n        var min = 9999999999;\\n        for(var i = 0;i<heaters.length;i++){\\n            min = Math.min(min, Math.abs(heaters[i] - n))\\n        }\\n        return min;\\n    }\\n    var res = -1;\\n    for(var i = 0;i<houses.length;i++){\\n        var currNearest = findNearest(houses[i],heaters);\\n        if(res<currNearest){\\n            res = currNearest;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} houses\\n * @param {number[]} heaters\\n * @return {number}\\n */\\nvar findRadius = function(houses, heaters) {\\n    var findNearest = (n,heaters)=>{\\n        var min = 9999999999;\\n        for(var i = 0;i<heaters.length;i++){\\n            min = Math.min(min, Math.abs(heaters[i] - n))\\n        }\\n        return min;\\n    }\\n    var res = -1;\\n    for(var i = 0;i<houses.length;i++){\\n        var currNearest = findNearest(houses[i],heaters);\\n        if(res<currNearest){\\n            res = currNearest;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751647,
                "title": "python-binary-search-iterative-and-recursive",
                "content": "\\tRecursive\\n\\tclass Solution(object):\\n\\t\\tdef findRadius(self, houses, heaters):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type houses: List[int]\\n\\t\\t\\t:type heaters: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\theaters.sort()\\n\\t\\t\\tres = float(\\'-inf\\')\\n\\t\\t\\tfor i in range(len(houses)):\\n\\t\\t\\t\\tself.pos = float(\\'inf\\')\\n\\t\\t\\t\\tself.dfs(houses[i], heaters, 0, len(heaters) - 1)\\n\\t\\t\\t\\tres = max(res, abs(self.pos - houses[i]))\\n\\t\\t\\treturn res\\n\\n\\t\\tdef dfs(self, index, heaters, left, right):\\n\\t\\t\\tif left > right: return\\n\\t\\t\\tmid = (left + right) / 2\\n\\t\\t\\tif abs(heaters[mid] - index) < abs(index - self.pos):\\n\\t\\t\\t\\tself.pos = heaters[mid]\\n\\t\\t\\tif heaters[mid] < index:\\n\\t\\t\\t\\tself.dfs(index, heaters, mid + 1, right)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tself.dfs(index, heaters, left, mid - 1)\\n\\n\\n\\tIterative\\n\\tclass Solution(object):\\n\\t\\tdef findRadius(self, houses, heaters):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type houses: List[int]\\n\\t\\t\\t:type heaters: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\theaters.sort()\\n\\t\\t\\tres = float(\\'-inf\\')\\n\\t\\t\\tfor i in range(len(houses)):\\n\\t\\t\\t\\ttarget = self.binary_search(houses[i], heaters)\\n\\t\\t\\t\\tres = max(res, abs(target - houses[i]))\\n\\t\\t\\treturn res\\n\\n\\t\\tdef binary_search(self, pos, heaters):\\n\\t\\t\\tleft, right = 0, len(heaters) - 1\\n\\t\\t\\ttarget = float(\\'inf\\')\\n\\n\\t\\t\\twhile left <= right:\\n\\t\\t\\t\\tmid = (left + right)/2\\n\\t\\t\\t\\tif abs(heaters[mid] - pos) < abs(target - pos):\\n\\t\\t\\t\\t\\ttarget = heaters[mid]\\n\\t\\t\\t\\tif heaters[mid] > pos:\\n\\t\\t\\t\\t\\tright = mid - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\treturn target",
                "solutionTags": [],
                "code": "\\tRecursive\\n\\tclass Solution(object):\\n\\t\\tdef findRadius(self, houses, heaters):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type houses: List[int]\\n\\t\\t\\t:type heaters: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\theaters.sort()\\n\\t\\t\\tres = float(\\'-inf\\')\\n\\t\\t\\tfor i in range(len(houses)):\\n\\t\\t\\t\\tself.pos = float(\\'inf\\')\\n\\t\\t\\t\\tself.dfs(houses[i], heaters, 0, len(heaters) - 1)\\n\\t\\t\\t\\tres = max(res, abs(self.pos - houses[i]))\\n\\t\\t\\treturn res\\n\\n\\t\\tdef dfs(self, index, heaters, left, right):\\n\\t\\t\\tif left > right: return\\n\\t\\t\\tmid = (left + right) / 2\\n\\t\\t\\tif abs(heaters[mid] - index) < abs(index - self.pos):\\n\\t\\t\\t\\tself.pos = heaters[mid]\\n\\t\\t\\tif heaters[mid] < index:\\n\\t\\t\\t\\tself.dfs(index, heaters, mid + 1, right)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tself.dfs(index, heaters, left, mid - 1)\\n\\n\\n\\tIterative\\n\\tclass Solution(object):\\n\\t\\tdef findRadius(self, houses, heaters):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type houses: List[int]\\n\\t\\t\\t:type heaters: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\theaters.sort()\\n\\t\\t\\tres = float(\\'-inf\\')\\n\\t\\t\\tfor i in range(len(houses)):\\n\\t\\t\\t\\ttarget = self.binary_search(houses[i], heaters)\\n\\t\\t\\t\\tres = max(res, abs(target - houses[i]))\\n\\t\\t\\treturn res\\n\\n\\t\\tdef binary_search(self, pos, heaters):\\n\\t\\t\\tleft, right = 0, len(heaters) - 1\\n\\t\\t\\ttarget = float(\\'inf\\')\\n\\n\\t\\t\\twhile left <= right:\\n\\t\\t\\t\\tmid = (left + right)/2\\n\\t\\t\\t\\tif abs(heaters[mid] - pos) < abs(target - pos):\\n\\t\\t\\t\\t\\ttarget = heaters[mid]\\n\\t\\t\\t\\tif heaters[mid] > pos:\\n\\t\\t\\t\\t\\tright = mid - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\treturn target",
                "codeTag": "Java"
            },
            {
                "id": 744395,
                "title": "rust-solutions",
                "content": "### 1. Brute Force\\n```Rust\\nimpl Solution {\\n    pub fn find_radius(houses: Vec<i32>, heaters: Vec<i32>) -> i32 {\\n        let mut min_radius = 0;\\n\\n        for house in &houses {\\n            let mut min_distance = std::i32::MAX;\\n\\n            for heater in &heaters {\\n                min_distance = min_distance.min((heater - house).abs());\\n            }\\n\\n            min_radius = min_radius.max(min_distance);\\n        }\\n\\n        min_radius\\n    }\\n}\\n```\\n\\n### 2. Two Pointers\\n```Rust\\nimpl Solution {\\n    pub fn find_radius(houses: Vec<i32>, heaters: Vec<i32>) -> i32 {\\n        let mut houses = houses;\\n        let mut heaters = heaters;\\n        houses.sort_unstable();\\n        heaters.sort_unstable();\\n\\n        let mut i = 0;\\n        let mut min_radius = 0;\\n\\n        for j in 0..houses.len() {\\n            while i < heaters.len() - 1 && heaters[i + 1] < houses[j] {\\n                i += 1;\\n            }\\n\\n            let mut min_distance = (houses[j] - heaters[i]).abs();\\n            if i < heaters.len() - 1 {\\n                min_distance = min_distance.min(heaters[i + 1] - houses[j]);\\n            }\\n\\n            min_radius = min_radius.max(min_distance);\\n        }\\n\\n        min_radius\\n    }\\n}\\n```\\n\\n### 3. Binary Search\\n```Rust\\nimpl Solution {\\n    pub fn find_radius(houses: Vec<i32>, heaters: Vec<i32>) -> i32 {\\n        let mut heaters = heaters;\\n        heaters.sort_unstable();\\n\\n        let mut min_radius = 0;\\n\\n        for house in houses {\\n            if let Err(i) = heaters.binary_search(&house) {\\n                min_radius = min_radius.max(\\n                    if i == 0 {\\n                        heaters[0] - house\\n                    } else if i == heaters.len() {\\n                        house - heaters[i - 1]\\n                    } else {\\n                        (heaters[i] - house).min(house - heaters[i - 1])\\n                    }\\n                );\\n            }\\n        }\\n\\n        min_radius\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn find_radius(houses: Vec<i32>, heaters: Vec<i32>) -> i32 {\\n        let mut min_radius = 0;\\n\\n        for house in &houses {\\n            let mut min_distance = std::i32::MAX;\\n\\n            for heater in &heaters {\\n                min_distance = min_distance.min((heater - house).abs());\\n            }\\n\\n            min_radius = min_radius.max(min_distance);\\n        }\\n\\n        min_radius\\n    }\\n}\\n```\n```Rust\\nimpl Solution {\\n    pub fn find_radius(houses: Vec<i32>, heaters: Vec<i32>) -> i32 {\\n        let mut houses = houses;\\n        let mut heaters = heaters;\\n        houses.sort_unstable();\\n        heaters.sort_unstable();\\n\\n        let mut i = 0;\\n        let mut min_radius = 0;\\n\\n        for j in 0..houses.len() {\\n            while i < heaters.len() - 1 && heaters[i + 1] < houses[j] {\\n                i += 1;\\n            }\\n\\n            let mut min_distance = (houses[j] - heaters[i]).abs();\\n            if i < heaters.len() - 1 {\\n                min_distance = min_distance.min(heaters[i + 1] - houses[j]);\\n            }\\n\\n            min_radius = min_radius.max(min_distance);\\n        }\\n\\n        min_radius\\n    }\\n}\\n```\n```Rust\\nimpl Solution {\\n    pub fn find_radius(houses: Vec<i32>, heaters: Vec<i32>) -> i32 {\\n        let mut heaters = heaters;\\n        heaters.sort_unstable();\\n\\n        let mut min_radius = 0;\\n\\n        for house in houses {\\n            if let Err(i) = heaters.binary_search(&house) {\\n                min_radius = min_radius.max(\\n                    if i == 0 {\\n                        heaters[0] - house\\n                    } else if i == heaters.len() {\\n                        house - heaters[i - 1]\\n                    } else {\\n                        (heaters[i] - house).min(house - heaters[i - 1])\\n                    }\\n                );\\n            }\\n        }\\n\\n        min_radius\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 664443,
                "title": "c-clean-binary-search-o-nlgn",
                "content": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(), heaters.end());\\n        int res = 0;\\n        for(auto& house : houses){\\n            int l = 0, r = heaters.size()-1, diff = INT_MAX;\\n            while(l <= r){\\n                int mid = l + (r-l)/2;\\n                diff = min(diff, abs(heaters[mid] - house));\\n                if( heaters[mid] < house){\\n                    l = mid + 1;\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n            res = max(res, diff);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        sort(heaters.begin(), heaters.end());\\n        int res = 0;\\n        for(auto& house : houses){\\n            int l = 0, r = heaters.size()-1, diff = INT_MAX;\\n            while(l <= r){\\n                int mid = l + (r-l)/2;\\n                diff = min(diff, abs(heaters[mid] - house));\\n                if( heaters[mid] < house){\\n                    l = mid + 1;\\n                }else{\\n                    r = mid - 1;\\n                }\\n            }\\n            res = max(res, diff);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664394,
                "title": "simple-solution-thinking-in-term-of-taking-house-to-heater-and-not-heater-to-house",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        TreeSet<Integer> ts = new TreeSet();\\n        for(int heater : heaters) ts.add(heater);\\n        int max = 0;\\n        for(int house : houses){\\n          Integer floor = ts.floor(house);\\n          Integer ceil = ts.ceiling(house);\\n          int left = 0;\\n          int right = 0;\\n          if(floor == null){\\n            left = Integer.MAX_VALUE;\\n          } else{\\n            left = house - floor;\\n          }\\n          if(ceil == null){\\n            right = Integer.MAX_VALUE;\\n          } else{\\n            right = ceil - house;\\n          }\\n          max = Math.max(max, Math.min(left, right));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        TreeSet<Integer> ts = new TreeSet();\\n        for(int heater : heaters) ts.add(heater);\\n        int max = 0;\\n        for(int house : houses){\\n          Integer floor = ts.floor(house);\\n          Integer ceil = ts.ceiling(house);\\n          int left = 0;\\n          int right = 0;\\n          if(floor == null){\\n            left = Integer.MAX_VALUE;\\n          } else{\\n            left = house - floor;\\n          }\\n          if(ceil == null){\\n            right = Integer.MAX_VALUE;\\n          } else{\\n            right = ceil - house;\\n          }\\n          max = Math.max(max, Math.min(left, right));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642584,
                "title": "c-stl-binary-search-using-lower-bound",
                "content": "class Solution {\\npublic:\\n\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n     int radius=INT_MIN;\\n     sort(heaters.begin(),heaters.end());\\n     vector<int>::iterator it;\\n     for(int house:houses)\\n     {\\n         it=lower_bound(heaters.begin(),heaters.end(),house);\\n         \\n         if(it==heaters.begin()) radius=max(radius,abs(*it-house));\\n         else if(it==heaters.end()) radius=max(radius,abs(*(it-1)-house));\\n         else radius=max(radius,min(abs(*it-house),abs(*(it-1)-house)));\\n     }\\n    return radius;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n     int radius=INT_MIN;\\n     sort(heaters.begin(),heaters.end());\\n     vector<int>::iterator it;\\n     for(int house:houses)\\n     {\\n         it=lower_bound(heaters.begin(),heaters.end(),house);\\n         \\n         if(it==heaters.begin()) radius=max(radius,abs(*it-house));\\n         else if(it==heaters.end()) radius=max(radius,abs(*(it-1)-house));\\n         else radius=max(radius,min(abs(*it-house),abs(*(it-1)-house)));\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 633284,
                "title": "c-solution-using-lower-bound-o-n-lg-m",
                "content": "Complexity: O(n*lgm) where n = size of houses array and m = size of heaters array.\\n```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        int ans = INT_MIN;\\n        sort(heaters.begin(),heaters.end());\\n        vector<int>::iterator it;\\n        for(int i: houses){\\n            it = lower_bound(heaters.begin(),heaters.end(),i);\\n            if(it == heaters.begin()) ans = max(ans,*it - i);\\n            else if(it == heaters.end()) ans = max(ans,i - *(it-1));\\n            else ans = max(ans, min(i - *(it-1), *it - i));\\n        }\\n        return ans;\\n    }\\n};\\n//[1,2,3], [2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        int ans = INT_MIN;\\n        sort(heaters.begin(),heaters.end());\\n        vector<int>::iterator it;\\n        for(int i: houses){\\n            it = lower_bound(heaters.begin(),heaters.end(),i);\\n            if(it == heaters.begin()) ans = max(ans,*it - i);\\n            else if(it == heaters.end()) ans = max(ans,i - *(it-1));\\n            else ans = max(ans, min(i - *(it-1), *it - i));\\n        }\\n        return ans;\\n    }\\n};\\n//[1,2,3], [2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595623,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nSort the homes and heaters.  Let `L` and `R`, be the index of first two heaters which we will use as a \"sliding window\" as we search for the closest heaters to each `i`-th home.  Return the maximum of the minimum distances from each home and its closest heater.\\n\\n**There are 4 use cases to consider:**\\n\\n* **Case 1:**  if the `i`-th home is to the left of the current \"sliding window\" of heaters at `L` and `R`, then the heater at `L` is the closest\\n* **Case 2:** if the `i`-th home is in between the current \"sliding window\" of heaters at `L` and `R`, then choose the minimum distance to the heater on the left at `L` and the heater on the right at `R`\\n* **Case 3:** if the `i`-th home is to the right of the current \"sliding window\" of heaters at `L` and `R` and there exists another heater to the right of `R`, then \"slide\" the window (ie. increment `L` and `R` by `1`) and try finding the closest heater for the `i`-th home with this next \"window\".\\n* **Case 4:** if the `i`-th home is to the right of the current \"sliding window\" of heaters at `L` and `R` and there does *NOT* exist another heater to the right of `R`, then we can no longer \"slide\" our window.  The heater at `L` is the closest heater.\\n\\n*Example: Case 1*\\n```\\nhouses  = [1, 3, 5, 7]\\nheaters = [2, 4, 6]\\n\\n           i   L     R\\n           \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\nposition =  1  2  3  4  5  6  7\\n```\\n\\n*Example: Case 2*\\n```\\nhouses  = [1, 3, 5, 7]\\nheaters = [2, 4, 6]\\n\\n               L  i  R\\n           \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\nposition =  1  2  3  4  5  6  7\\n```\\n\\n*Example: Case 3*\\n```\\nhouses  = [1, 3, 5, 7]\\nheaters = [2, 4, 6]\\n\\n               L     R  i\\n           \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\nposition =  1  2  3  4  5  6  7\\n```\\n\\n*Example: Case 4*\\n```\\nhouses  = [1, 3, 5, 7]\\nheaters = [2, 4, 6]\\n\\n                           L   i   R\\n           \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\nposition =  1  2  3  4  5  6  7\\n```\\n\\n---\\n\\n*Javascript*\\n```\\nlet findRadius = (home, heat, max = 0) => {\\n    home.sort((a, b) => a - b);\\n    heat.sort((a, b) => a - b);\\n    let M = home.length,\\n        N = heat.length;\\n    let i = 0,\\n        L = 0,\\n        R = 1;\\n    for (let i = 0; i < home.length;) {\\n        let min = Infinity;\\n        if (home[i] <= heat[L]) {     // case 1: \\uD83C\\uDFE0i <-- \\uD83D\\uDD25L\\n            min = heat[L] - home[i];\\n        } else if (R < N) {\\n            if (home[i] <= heat[R]) { // case 2: \\uD83D\\uDD25L --> \\uD83C\\uDFE0i <-- \\uD83D\\uDD25R\\n                min = Math.min(\\n                    home[i] - heat[L],\\n                    heat[R] - home[i]\\n                );\\n            } else {                  // case 3: \\uD83D\\uDD25L \\uD83D\\uDD25R --> \\uD83C\\uDFE0i\\n                ++L, ++R; continue;\\n            }\\n        } else {                      // case 4: \\uD83D\\uDD25L --> \\uD83C\\uDFE0i  (R == N, so there is no \\uD83D\\uDD25R)\\n            min = home[i] - heat[L];\\n        }\\n        max = Math.max(max, min);\\n        ++i;\\n    }\\n    return max;\\n};\\n```\\n\\n---\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findRadius(VI& home, VI& heat, int max = 0) {\\n        sort(home.begin(), home.end());\\n        sort(heat.begin(), heat.end());\\n        int M = home.size(),\\n            N = heat.size();\\n        auto i = 0,\\n             L = 0,\\n             R = 1;\\n        for (auto i{ 0 }; i < M;) {\\n            auto min = int(1e9 + 7);\\n            if (home[i] <= heat[L]) {     // case 1: \\uD83C\\uDFE0i <-- \\uD83D\\uDD25L\\n                min = heat[L] - home[i];\\n            } else if (R < N) {\\n                if (home[i] <= heat[R]) { // case 2: \\uD83D\\uDD25L --> \\uD83C\\uDFE0i <-- \\uD83D\\uDD25R\\n                    min = std::min(\\n                        home[i] - heat[L],\\n                        heat[R] - home[i]\\n                    );\\n                } else {                  // case 3: \\uD83D\\uDD25L \\uD83D\\uDD25R --> \\uD83C\\uDFE0i\\n                    ++L, ++R; continue;\\n                }\\n            } else {                      // case 4: \\uD83D\\uDD25L --> \\uD83C\\uDFE0i  (R == N, so there is no \\uD83D\\uDD25R)\\n                min = home[i] - heat[L];\\n            }\\n            max = std::max(max, min);\\n            ++i;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nhouses  = [1, 3, 5, 7]\\nheaters = [2, 4, 6]\\n\\n           i   L     R\\n           \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\nposition =  1  2  3  4  5  6  7\\n```\n```\\nhouses  = [1, 3, 5, 7]\\nheaters = [2, 4, 6]\\n\\n               L  i  R\\n           \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\nposition =  1  2  3  4  5  6  7\\n```\n```\\nhouses  = [1, 3, 5, 7]\\nheaters = [2, 4, 6]\\n\\n               L     R  i\\n           \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\nposition =  1  2  3  4  5  6  7\\n```\n```\\nhouses  = [1, 3, 5, 7]\\nheaters = [2, 4, 6]\\n\\n                           L   i   R\\n           \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\uD83D\\uDD25 \\uD83C\\uDFE0 \\nposition =  1  2  3  4  5  6  7\\n```\n```\\nlet findRadius = (home, heat, max = 0) => {\\n    home.sort((a, b) => a - b);\\n    heat.sort((a, b) => a - b);\\n    let M = home.length,\\n        N = heat.length;\\n    let i = 0,\\n        L = 0,\\n        R = 1;\\n    for (let i = 0; i < home.length;) {\\n        let min = Infinity;\\n        if (home[i] <= heat[L]) {     // case 1: \\uD83C\\uDFE0i <-- \\uD83D\\uDD25L\\n            min = heat[L] - home[i];\\n        } else if (R < N) {\\n            if (home[i] <= heat[R]) { // case 2: \\uD83D\\uDD25L --> \\uD83C\\uDFE0i <-- \\uD83D\\uDD25R\\n                min = Math.min(\\n                    home[i] - heat[L],\\n                    heat[R] - home[i]\\n                );\\n            } else {                  // case 3: \\uD83D\\uDD25L \\uD83D\\uDD25R --> \\uD83C\\uDFE0i\\n                ++L, ++R; continue;\\n            }\\n        } else {                      // case 4: \\uD83D\\uDD25L --> \\uD83C\\uDFE0i  (R == N, so there is no \\uD83D\\uDD25R)\\n            min = home[i] - heat[L];\\n        }\\n        max = Math.max(max, min);\\n        ++i;\\n    }\\n    return max;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findRadius(VI& home, VI& heat, int max = 0) {\\n        sort(home.begin(), home.end());\\n        sort(heat.begin(), heat.end());\\n        int M = home.size(),\\n            N = heat.size();\\n        auto i = 0,\\n             L = 0,\\n             R = 1;\\n        for (auto i{ 0 }; i < M;) {\\n            auto min = int(1e9 + 7);\\n            if (home[i] <= heat[L]) {     // case 1: \\uD83C\\uDFE0i <-- \\uD83D\\uDD25L\\n                min = heat[L] - home[i];\\n            } else if (R < N) {\\n                if (home[i] <= heat[R]) { // case 2: \\uD83D\\uDD25L --> \\uD83C\\uDFE0i <-- \\uD83D\\uDD25R\\n                    min = std::min(\\n                        home[i] - heat[L],\\n                        heat[R] - home[i]\\n                    );\\n                } else {                  // case 3: \\uD83D\\uDD25L \\uD83D\\uDD25R --> \\uD83C\\uDFE0i\\n                    ++L, ++R; continue;\\n                }\\n            } else {                      // case 4: \\uD83D\\uDD25L --> \\uD83C\\uDFE0i  (R == N, so there is no \\uD83D\\uDD25R)\\n                min = home[i] - heat[L];\\n            }\\n            max = std::max(max, min);\\n            ++i;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552584,
                "title": "binary-search",
                "content": "int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        \\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        int res = 0;\\n        int low = 0;\\n        int high;\\n        \\n        for(int h : houses)\\n        {\\n            high = heaters.size() - 1;\\n            if(heaters[low] == h || heaters[high] == h)\\n                continue;\\n            \\n            while(high - low > 1)\\n            {\\n                int mid = (high + low) >> 1;\\n                \\n                if(heaters[mid] > h)\\n                    high = mid;\\n                else\\n                    low = mid;\\n            }\\n            \\n            res = max(res, min(abs(heaters[low] - h), abs(heaters[high] - h)));\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        \\n        sort(houses.begin(), houses.end());\\n        sort(heaters.begin(), heaters.end());\\n        \\n        int res = 0;\\n        int low = 0;\\n        int high;\\n        \\n        for(int h : houses)\\n        {\\n            high = heaters.size() - 1;\\n            if(heaters[low] == h || heaters[high] == h)\\n                continue;\\n            \\n            while(high - low > 1)\\n            {\\n                int mid = (high + low) >> 1;\\n                \\n                if(heaters[mid] > h)\\n                    high = mid;\\n                else\\n                    low = mid;\\n            }\\n            \\n            res = max(res, min(abs(heaters[low] - h), abs(heaters[high] - h)));\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 519572,
                "title": "c-binary-search-solution-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int FindRadius(int[] houses, int[] heaters) {\\n        //binary search approach\\n        Array.Sort(heaters);\\n        var maxRadius = int.MinValue;\\n        for(var i = 0; i < houses.Length; i++){\\n            maxRadius = Math.Max(maxRadius, findMinDistance(houses[i], heaters));\\n        }\\n        return maxRadius;\\n    }\\n    \\n    private int findMinDistance(int i, int[] heaters){\\n        int lo = 0;\\n        int hi = heaters.Length - 1;\\n        int mid = 0;\\n        while(lo + 1 < hi){\\n            mid = (lo + hi) / 2;\\n            if(heaters[mid] == i) return 0;\\n            if(heaters[mid] > i)\\n                hi = mid;\\n            else\\n                lo = mid;\\n        }\\n        return Math.Min(Math.Abs(i - heaters[lo]), Math.Abs(i - heaters[hi]));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindRadius(int[] houses, int[] heaters) {\\n        //binary search approach\\n        Array.Sort(heaters);\\n        var maxRadius = int.MinValue;\\n        for(var i = 0; i < houses.Length; i++){\\n            maxRadius = Math.Max(maxRadius, findMinDistance(houses[i], heaters));\\n        }\\n        return maxRadius;\\n    }\\n    \\n    private int findMinDistance(int i, int[] heaters){\\n        int lo = 0;\\n        int hi = heaters.Length - 1;\\n        int mid = 0;\\n        while(lo + 1 < hi){\\n            mid = (lo + hi) / 2;\\n            if(heaters[mid] == i) return 0;\\n            if(heaters[mid] > i)\\n                hi = mid;\\n            else\\n                lo = mid;\\n        }\\n        return Math.Min(Math.Abs(i - heaters[lo]), Math.Abs(i - heaters[hi]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 511444,
                "title": "simple-java-solution-max-result-and-min-radiu-only-beats-5",
                "content": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int res = 0;\\n        for(int house : houses) {\\n            int t = Integer.MAX_VALUE;\\n            for(int heater : heaters) {\\n                t = Math.min(t, Math.abs(house - heater));\\n            }\\n            res = Math.max(res, t);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        int res = 0;\\n        for(int house : houses) {\\n            int t = Integer.MAX_VALUE;\\n            for(int heater : heaters) {\\n                t = Math.min(t, Math.abs(house - heater));\\n            }\\n            res = Math.max(res, t);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509637,
                "title": "go-48ms-94-binary-search",
                "content": "```go\\nfunc findRadius(houses []int, heaters []int) int {\\n    sort.Ints(houses)\\n    sort.Ints(heaters)\\n    heaters = append(heaters, 2100000000)\\n    nearest := 0\\n    for _, v := range houses {\\n        if distance := findNearestDistance(heaters, v); distance > nearest {\\n            nearest = distance\\n        }\\n    }\\n    return nearest\\n}\\n\\nfunc findNearestDistance(heaters []int, housePos int) int {\\n    l, r := 0, len(heaters)-1\\n    // find first GE\\n    for l <= r {\\n        m := (l+r)>>1\\n        if heaters[m] >= housePos {\\n            r = m - 1\\n        } else {\\n            l = m + 1\\n        }\\n    }\\n    distance := heaters[l] - housePos\\n    if l - 1 >= 0 {\\n        if distance > housePos - heaters[l-1] {\\n            distance = housePos - heaters[l-1]\\n        } \\n    }\\n    return distance\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```go\\nfunc findRadius(houses []int, heaters []int) int {\\n    sort.Ints(houses)\\n    sort.Ints(heaters)\\n    heaters = append(heaters, 2100000000)\\n    nearest := 0\\n    for _, v := range houses {\\n        if distance := findNearestDistance(heaters, v); distance > nearest {\\n            nearest = distance\\n        }\\n    }\\n    return nearest\\n}\\n\\nfunc findNearestDistance(heaters []int, housePos int) int {\\n    l, r := 0, len(heaters)-1\\n    // find first GE\\n    for l <= r {\\n        m := (l+r)>>1\\n        if heaters[m] >= housePos {\\n            r = m - 1\\n        } else {\\n            l = m + 1\\n        }\\n    }\\n    distance := heaters[l] - housePos\\n    if l - 1 >= 0 {\\n        if distance > housePos - heaters[l-1] {\\n            distance = housePos - heaters[l-1]\\n        } \\n    }\\n    return distance\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480718,
                "title": "java-binary-search",
                "content": "\\'\\'\\'\\nclass Solution {\\n\\n    public int findRadius(int[] houses, int[] heaters) {\\n\\t\\tArrays.sort(houses);\\n\\t\\tArrays.sort(heaters);\\n\\t\\t\\n        int max = 0;\\n        // Iterate through all houses:\\n\\t\\tfor(int i=0; i<houses.length; ++i){\\n            if(houses[i] <= heaters[0]){        // when house is to the left of all heaters:\\n                max = max < (heaters[0] - houses[i])? (heaters[0] - houses[i]): max;\\n            }\\n            else if(houses[i] >= heaters[heaters.length-1]){   // when house is to the right of all heaters:\\n                max = max < (houses[i] - heaters[heaters.length-1])? (houses[i] - heaters[heaters.length-1]): max;\\n            }\\n            else{       // when house has heaters on both left an right:\\n                int cur = helper(heaters, houses[i]);\\n                max = max < cur? cur: max;\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    // Binary search to find the best radius for the house:\\n    private int helper(int[] heaters, int house){\\n        int lo = 0, hi = heaters.length-1;\\n        while(lo <= hi){\\n            int mid = lo + ((hi - lo) >> 1);\\n            if(house == heaters[mid]) return 0;\\n            else if(house > heaters[mid] && house < heaters[mid + 1]){\\n                return (heaters[mid + 1] - house) < (house - heaters[mid])? (heaters[mid + 1] - house): (house - heaters[mid]);\\n            } \\n            else if(house < heaters[mid]) hi = mid - 1;\\n            else lo = mid + 1;\\n        }\\n        return -1; // This should not happen. Codes are not expected to reach here.\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int findRadius(int[] houses, int[] heaters) {\\n\\t\\tArrays.sort(houses);\\n\\t\\tArrays.sort(heaters);\\n\\t\\t\\n        int max = 0;\\n        // Iterate through all houses:\\n\\t\\tfor(int i=0; i<houses.length; ++i){\\n            if(houses[i] <= heaters[0]){        // when house is to the left of all heaters:\\n                max = max < (heaters[0] - houses[i])? (heaters[0] - houses[i]): max;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 454863,
                "title": "java-clean-and-easy-solution",
                "content": "```\\npublic int findRadius(int[] houses, int[] heaters) {\\n\\tArrays.sort(houses);\\n\\tArrays.sort(heaters);\\n\\tint j = 0, rad = 0;\\n\\tfor(int i=0; i<houses.length; i++) {\\n\\t\\twhile(j<heaters.length-1 && Math.abs(heaters[j+1]-houses[i])<=Math.abs(heaters[j]-houses[i])) \\n\\t\\t\\tj++;   //Get to the nearest heater so as to get the min distance in next step\\n\\t\\trad = Math.max(rad, Math.abs(heaters[j]-houses[i]));   // We need max of all minimum distances to ensure coverage.\\n\\t}\\n\\treturn rad;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findRadius(int[] houses, int[] heaters) {\\n\\tArrays.sort(houses);\\n\\tArrays.sort(heaters);\\n\\tint j = 0, rad = 0;\\n\\tfor(int i=0; i<houses.length; i++) {\\n\\t\\twhile(j<heaters.length-1 && Math.abs(heaters[j+1]-houses[i])<=Math.abs(heaters[j]-houses[i])) \\n\\t\\t\\tj++;   //Get to the nearest heater so as to get the min distance in next step\\n\\t\\trad = Math.max(rad, Math.abs(heaters[j]-houses[i]));   // We need max of all minimum distances to ensure coverage.\\n\\t}\\n\\treturn rad;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453566,
                "title": "c-75-100-pretty-basic-option",
                "content": "Loop through sorted houses and find closest heater, that will be the min distance to a heater for this house.\\nthen do the same for the next house.  If it\\'s min is greater, then save that as gmax.  gmax will then be the greatest\\ndistance from any house to the closest heater.  Since we sort the arrays, we can save the last heater as our starting\\npoint for the next house, and since we can break when the distance to heaters starts to diverge again the main loop is nearly O(n). \\nRegardless, this solution only works if sorted so overall performance is limited by the sort..\\n\\n```\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        int min = INT_MAX;\\n        int gmax = 0;\\n        int dif;\\n        int lastHeaterIdx = 0;\\n\\n        sort(heaters.begin(), heaters.end());\\n        sort(houses.begin(), houses.end());\\n        \\n        for(int i = 0; i < houses.size(); i++)\\n        {\\n            for(int j = lastHeaterIdx; j < heaters.size(); j++)\\n            {\\n                //what is the closes heater to this house\\n                dif = abs(heaters[j] - houses[i]);\\n                if(dif < min){\\n                    min = dif;\\n                    lastHeaterIdx = j;\\n                }\\n                else if(dif > min) {\\n                    //once heaters start moving away from this house we don\\'t need to look at any more heaters\\n                    break;\\n                }\\n            }\\n\\n            //should now have the closest heater to this house\\n            if(min > gmax){\\n                gmax = min;\\n            }\\n\\n            min = INT_MAX;\\n        }\\n        \\n        return(gmax);\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n        int min = INT_MAX;\\n        int gmax = 0;\\n        int dif;\\n        int lastHeaterIdx = 0;\\n\\n        sort(heaters.begin(), heaters.end());\\n        sort(houses.begin(), houses.end());\\n        \\n        for(int i = 0; i < houses.size(); i++)\\n        {\\n            for(int j = lastHeaterIdx; j < heaters.size(); j++)\\n            {\\n                //what is the closes heater to this house\\n                dif = abs(heaters[j] - houses[i]);\\n                if(dif < min){\\n                    min = dif;\\n                    lastHeaterIdx = j;\\n                }\\n                else if(dif > min) {\\n                    //once heaters start moving away from this house we don\\'t need to look at any more heaters\\n                    break;\\n                }\\n            }\\n\\n            //should now have the closest heater to this house\\n            if(min > gmax){\\n                gmax = min;\\n            }\\n\\n            min = INT_MAX;\\n        }\\n        \\n        return(gmax);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451000,
                "title": "c-solution-using-binary-search-with-comments-o-1-space-and-99-06-fast",
                "content": "**Algorithm:**\\n1. Sort heaters position which is required for binary search\\n2. Find nearest heater on left and right of each house using binary search\\n3. Update the answer to find maximum heater distance for each house\\n\\n**Code:**\\n```\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n\\tint ans = 0;\\n\\t\\n\\t// STEP-1\\n\\t\\n\\t// sort heaters position for binary search\\n\\tsort(heaters.begin(), heaters.end());\\n\\t\\n\\t// Find nearest heater on the left and right of each house using binary search\\n\\tfor (int i = 0; i<houses.size(); i++)\\n\\t{\\n\\t// hp - current house position\\n\\t// rp - to store nearest heater position on right\\n\\t// rp - to store nearest heater position on left\\n\\t\\tint hp = houses[i];\\n\\t\\tint rp = -1;\\n\\t\\tint lp = -1;\\n\\t\\t\\n\\t// STEP-2\\n\\t\\n\\t// start binary search\\n\\t\\tint left = 0;\\n\\t\\tint right = heaters.size() - 1;\\n\\t\\twhile (left <= right)\\n\\t\\t{\\n\\t\\t\\tint mid = left + (-left + right) / 2;\\n\\t\\t\\tif (heaters[mid] >= hp)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (rp == -1)\\n\\t\\t\\t\\t\\trp = heaters[mid];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\trp = min(rp, heaters[mid]);\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n                if (lp == -1)\\n\\t\\t\\t\\t\\tlp = heaters[mid];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlp = max(lp, heaters[mid]);\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t// temp - to store nearest heater for the current house\\n\\t// rp - hp => distance between right nearest heater and house\\n\\t// hp - lp => distance between left nearest heater and house\\n\\t\\n\\t\\tint temp = INT_MAX;\\n\\t\\tif (rp != -1)\\n\\t\\t{\\n\\t\\t\\ttemp = rp - hp;\\n\\t\\t}\\n\\t\\tif (lp != -1)\\n\\t\\t{\\n\\t\\t\\ttemp = min(temp, hp - lp);\\n\\t\\t}\\n\\t// STEP-3\\n\\t\\n\\t// update ans for every house\\n\\t\\tans = max(ans, temp);\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\\n\\tint ans = 0;\\n\\t\\n\\t// STEP-1\\n\\t\\n\\t// sort heaters position for binary search\\n\\tsort(heaters.begin(), heaters.end());\\n\\t\\n\\t// Find nearest heater on the left and right of each house using binary search\\n\\tfor (int i = 0; i<houses.size(); i++)\\n\\t{\\n\\t// hp - current house position\\n\\t// rp - to store nearest heater position on right\\n\\t// rp - to store nearest heater position on left\\n\\t\\tint hp = houses[i];\\n\\t\\tint rp = -1;\\n\\t\\tint lp = -1;\\n\\t\\t\\n\\t// STEP-2\\n\\t\\n\\t// start binary search\\n\\t\\tint left = 0;\\n\\t\\tint right = heaters.size() - 1;\\n\\t\\twhile (left <= right)\\n\\t\\t{\\n\\t\\t\\tint mid = left + (-left + right) / 2;\\n\\t\\t\\tif (heaters[mid] >= hp)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (rp == -1)\\n\\t\\t\\t\\t\\trp = heaters[mid];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\trp = min(rp, heaters[mid]);\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n                if (lp == -1)\\n\\t\\t\\t\\t\\tlp = heaters[mid];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tlp = max(lp, heaters[mid]);\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t// temp - to store nearest heater for the current house\\n\\t// rp - hp => distance between right nearest heater and house\\n\\t// hp - lp => distance between left nearest heater and house\\n\\t\\n\\t\\tint temp = INT_MAX;\\n\\t\\tif (rp != -1)\\n\\t\\t{\\n\\t\\t\\ttemp = rp - hp;\\n\\t\\t}\\n\\t\\tif (lp != -1)\\n\\t\\t{\\n\\t\\t\\ttemp = min(temp, hp - lp);\\n\\t\\t}\\n\\t// STEP-3\\n\\t\\n\\t// update ans for every house\\n\\t\\tans = max(ans, temp);\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437392,
                "title": "java-o-nlogn-mlogm-sort-pointer",
                "content": "We will try to find the closest heater for each house and keep the maximum of these distances.\\nThe useful observation: the closest heater for the current house is located into the segment from heater closest to the previous house to closest heater after this house. In this case, the search in the sorted arrays would be O(m + n).\\nSo the steps are:\\n* Sort arrays\\n* Find the closest heater for each house using a pointer for the heater\\n\\n```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        int curHeater = 0;\\n        int min = 0;\\n        for (int i = 0; i < houses.length; i++) {\\n            int curDist = Math.abs(houses[i] - heaters[curHeater]);\\n            while (curHeater + 1 < heaters.length && heaters[curHeater + 1] < houses[i]) {\\n                curHeater++;\\n                curDist = Math.min(curDist, houses[i] - heaters[curHeater]);\\n            }\\n            if (curHeater + 1 < heaters.length) {\\n                curDist = Math.min(curDist, heaters[curHeater + 1] - houses[i]);\\n            }\\n            min = Math.max(min, curDist);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findRadius(int[] houses, int[] heaters) {\\n        Arrays.sort(houses);\\n        Arrays.sort(heaters);\\n        int curHeater = 0;\\n        int min = 0;\\n        for (int i = 0; i < houses.length; i++) {\\n            int curDist = Math.abs(houses[i] - heaters[curHeater]);\\n            while (curHeater + 1 < heaters.length && heaters[curHeater + 1] < houses[i]) {\\n                curHeater++;\\n                curDist = Math.min(curDist, houses[i] - heaters[curHeater]);\\n            }\\n            if (curHeater + 1 < heaters.length) {\\n                curDist = Math.min(curDist, heaters[curHeater + 1] - houses[i]);\\n            }\\n            min = Math.max(min, curDist);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386748,
                "title": "binary-search-solution-with-explanation",
                "content": "The binary search of index can lead to either index of heater where house is already present or next index of heater, so we need to check the closet distance between heater & house and previous heater & house. Then we find max of them to get minimum possible distance that would be cover all houses by given heaters.\\n\\n``` csharp\\npublic class Solution \\n{\\n    public int FindRadius(int[] houses, int[] heaters) \\n    {\\n        Array.Sort(heaters); \\n        int radius = 0;\\n        \\n        if(houses.Length == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        if(heaters.Length == 0)\\n        {\\n            return int.MaxValue;\\n        }\\n        \\n        foreach(int house in houses)\\n        {\\n            int index = Array.BinarySearch(heaters, house);\\n            if(index < 0)\\n            {\\n                index = ~index;\\n            }  \\n            \\n            int distance = int.MaxValue;                        \\n            if(index >= 0 && index < heaters.Length)\\n            {\\n                distance = heaters[index] - house;\\n            }           \\n            \\n            if(index > 0 && index <= heaters.Length)\\n            {   \\n                distance = Math.Min(distance, house - heaters[index - 1]);\\n            }  \\n            \\n            radius = Math.Max(radius, distance);            \\n        }\\n        \\n        return radius;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "``` csharp\\npublic class Solution \\n{\\n    public int FindRadius(int[] houses, int[] heaters) \\n    {\\n        Array.Sort(heaters); \\n        int radius = 0;\\n        \\n        if(houses.Length == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        if(heaters.Length == 0)\\n        {\\n            return int.MaxValue;\\n        }\\n        \\n        foreach(int house in houses)\\n        {\\n            int index = Array.BinarySearch(heaters, house);\\n            if(index < 0)\\n            {\\n                index = ~index;\\n            }  \\n            \\n            int distance = int.MaxValue;                        \\n            if(index >= 0 && index < heaters.Length)\\n            {\\n                distance = heaters[index] - house;\\n            }           \\n            \\n            if(index > 0 && index <= heaters.Length)\\n            {   \\n                distance = Math.Min(distance, house - heaters[index - 1]);\\n            }  \\n            \\n            radius = Math.Max(radius, distance);            \\n        }\\n        \\n        return radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380196,
                "title": "solution-in-python-3-three-lines",
                "content": "```\\nclass Solution:\\n    def findRadius(self, h: List[int], t: List[int]) -> int:\\n    \\tLT, M, _, _ = len(t)-1, [0,0], h.sort(), t.sort()\\n    \\tfor i in h: M = (lambda x: [max(M[0],min(abs(i-t[x-1]),abs(i-t[x]))),x])(bisect.bisect(t,i,M[1],LT))\\n    \\treturn M[0]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRadius(self, h: List[int], t: List[int]) -> int:\\n    \\tLT, M, _, _ = len(t)-1, [0,0], h.sort(), t.sort()\\n    \\tfor i in h: M = (lambda x: [max(M[0],min(abs(i-t[x-1]),abs(i-t[x]))),x])(bisect.bisect(t,i,M[1],LT))\\n    \\treturn M[0]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564936,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1566946,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1571745,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1567271,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1568406,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1572471,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1969682,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 2049633,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 2030218,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1999180,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1564936,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1566946,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1571745,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1567271,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1568406,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1572471,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1969682,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 2049633,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 2030218,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            },
            {
                "id": 1999180,
                "content": [
                    {
                        "username": "NickBunich",
                        "content": "Why do I have to run test cases to figure out what are the expected results?"
                    },
                    {
                        "username": "wx4",
                        "content": "Cool problem, but seems more like a medium than an easy."
                    },
                    {
                        "username": "ChrisGao",
                        "content": "* the input array is sorted , but the test case is unsorted\\u3002"
                    },
                    {
                        "username": "lovedsp210",
                        "content": "![0_1481434089890_Screen Shot 2016-12-10 at 8.39.46 PM.png](/uploads/files/1481434091861-screen-shot-2016-12-10-at-8.39.46-pm.png) \\n\\n\\nFor example 2, the output is 1. But in the explanation, \"We need to use radius 2 standard\". It is confusing."
                    },
                    {
                        "username": "splorgdar",
                        "content": "This is the worst problem statement and examples I have seen on leetcode!\\nI refuse to participate. >:(\\nAre we working with a range or a sequence? Make up your damn mind! You can\\'t have it both ways.\\nTest cases, problem statement and examples are all inconsistent.\\nWaste of time."
                    },
                    {
                        "username": "arashnouri",
                        "content": "Someone should update this problem."
                    },
                    {
                        "username": "coder_sd",
                        "content": "good problem for logical thinking"
                    },
                    {
                        "username": "Plasticc",
                        "content": "This problem would be much better if the input were guaranteed to be sorted and unique. Duplicates do not complicate the solution to this problem and serve only to yet again require a \"unique and sort\" step to every solution. Why?"
                    },
                    {
                        "username": "pandeynikhil8",
                        "content": "Input: houses = [1, 5], heaters = [2]\\nOutput: 3\\nExplanation: The heater was placed at position 2. Using a radius of 3, the first house at position 1 and the second house at position 5 can both be warmed.\\n"
                    },
                    {
                        "username": "done100",
                        "content": "The testcases may have data that multiple houses/heaters are at the same position. You may need to consider such case in your code. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Distribute Candies",
        "question_content": "<p>Alice has <code>n</code> candies, where the <code>i<sup>th</sup></code> candy is of type <code>candyType[i]</code>. Alice noticed that she started to gain weight, so she visited a doctor.</p>\n\n<p>The doctor advised Alice to only eat <code>n / 2</code> of the candies she has (<code>n</code> is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor&#39;s advice.</p>\n\n<p>Given the integer array <code>candyType</code> of length <code>n</code>, return <em>the <strong>maximum</strong> number of different types of candies she can eat if she only eats </em><code>n / 2</code><em> of them</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candyType = [1,1,2,2,3,3]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candyType = [1,1,2,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> candyType = [6,6,6,6]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == candyType.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>n</code>&nbsp;is even.</li>\n\t<li><code>-10<sup>5</sup> &lt;= candyType[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 102868,
                "title": "python-straightforward-with-explanation",
                "content": "There are ```len(set(candies))``` unique candies, and the sister picks only ```len(candies) / 2``` of them, so she can't have more than this amount.\\n\\nFor example, if there are 5 unique candies, then if she is picking 4 candies, she will take 4 unique ones.  If she is picking 7 candies, then she will only take 5 unique ones.\\n\\n```\\ndef distributeCandies(self, candies):\\n    return min(len(candies) / 2, len(set(candies)))\\n```",
                "solutionTags": [],
                "code": "```len(set(candies))```\n```len(candies) / 2```\n```\\ndef distributeCandies(self, candies):\\n    return min(len(candies) / 2, len(set(candies)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 102946,
                "title": "c-1-liner",
                "content": "```\\nint distributeCandies(vector<int>& c) {\\n    return min(unordered_set<int>(begin(c), end(c)).size(), c.size() / 2);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint distributeCandies(vector<int>& c) {\\n    return min(unordered_set<int>(begin(c), end(c)).size(), c.size() / 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102879,
                "title": "java-solution-3-lines-hashset",
                "content": "Thanks @wmcalyj , modified to use HashSet.\\n```\\npublic class Solution {\\n    public int distributeCandies(int[] candies) {\\n        Set<Integer> kinds = new HashSet<>();\\n        for (int candy : candies) kinds.add(candy);\\n        return kinds.size() >= candies.length / 2 ? candies.length / 2 : kinds.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int distributeCandies(int[] candies) {\\n        Set<Integer> kinds = new HashSet<>();\\n        for (int candy : candies) kinds.add(candy);\\n        return kinds.size() >= candies.length / 2 ? candies.length / 2 : kinds.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102870,
                "title": "c-bitset-beats-99-60",
                "content": "The idea is to use biset as hash table instead of unordered_set.\\n```\\nint distributeCandies(vector<int>& candies) {\\n        bitset<200001> hash;\\n        int count = 0;\\n        for (int i : candies) {\\n            if (!hash.test(i+100000)) {\\n               count++;\\n               hash.set(i+100000);\\n            }\\n        }\\n        int n = candies.size();\\n        return min(count, n/2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint distributeCandies(vector<int>& candies) {\\n        bitset<200001> hash;\\n        int count = 0;\\n        for (int i : candies) {\\n            if (!hash.test(i+100000)) {\\n               count++;\\n               hash.set(i+100000);\\n            }\\n        }\\n        int n = candies.size();\\n        return min(count, n/2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102866,
                "title": "1-line-javascript-o-n-solution-using-set",
                "content": "```\\nvar distributeCandies = function(candies) {\\n    return Math.min(new Set(candies).size, candies.length / 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function(candies) {\\n    return Math.min(new Set(candies).size, candies.length / 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102924,
                "title": "c-clean-code-2-solutions-set-and-sort",
                "content": "**Set - O(N) time, O(N) space**\\nWe can use a set to count all unique kinds of candies, but even all candies are unique, the sister cannot get more than half.\\n(Even though in reality my GF would always get more than half.)\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        unordered_set<int> kinds;\\n        for (int kind : candies) {\\n            kinds.insert(kind);\\n        }\\n        return min(kinds.size(), candies.size() / 2);\\n    }\\n};\\n```\\nUsing range constructor as @i_square suggested:\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        return min(unordered_set<int>(candies.begin(), candies.end()).size(), candies.size() / 2);\\n    }\\n};\\n```\\n**Sort - O(N logN) time, O(1) space**\\nOr we can sort the candies by kinds, count kind if different than the prevous:\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        size_t kinds = 0;\\n        sort(candies.begin(), candies.end());\\n        for (int i = 0; i < candies.size(); i++) {\\n            kinds += i == 0 || candies[i] != candies[i - 1];\\n        }\\n        return min(kinds, candies.size() / 2);\\n    }\\n};\\n```\\nThe counter can start from 1 since there is no test case for empty input:\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        size_t kinds = 1;\\n        sort(candies.begin(), candies.end());\\n        for (int i = 0; i < candies.size(); i++) {\\n            kinds += candies[i] != candies[i - 1];\\n        }\\n        return min(kinds, candies.size() / 2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        unordered_set<int> kinds;\\n        for (int kind : candies) {\\n            kinds.insert(kind);\\n        }\\n        return min(kinds.size(), candies.size() / 2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        return min(unordered_set<int>(candies.begin(), candies.end()).size(), candies.size() / 2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        size_t kinds = 0;\\n        sort(candies.begin(), candies.end());\\n        for (int i = 0; i < candies.size(); i++) {\\n            kinds += i == 0 || candies[i] != candies[i - 1];\\n        }\\n        return min(kinds, candies.size() / 2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        size_t kinds = 1;\\n        sort(candies.begin(), candies.end());\\n        for (int i = 0; i < candies.size(); i++) {\\n            kinds += candies[i] != candies[i - 1];\\n        }\\n        return min(kinds, candies.size() / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087856,
                "title": "java-3-codes-beats-100",
                "content": "Solution is to choose as many unique candy types as we can without exceeding the hard limit of n / 2 so the problem reduces to counting how many distinct candy types are there.\\n\\n**Approach 1: HashSet**\\nMost obvious and versatile choice for our use case is to use a HashSet.\\n\\n```\\n// 33 ms. 62%\\npublic int distributeCandies(int[] candyType) {\\n    Set<Integer> set = new HashSet<>();\\n    for(int candy: candyType) {\\n        set.add(candy);\\n    }\\n    return Math.min(candyType.length / 2, set.size());\\n}\\n```\\n\\n**Approach 2: Boolean array**\\nLeveraging on input limits, we can use a boolean array to achieve better runtime.\\n\\n```\\n// 3 ms. 100%\\npublic int distributeCandies(int[] candyType) {\\n    boolean[] type = new boolean[200001];\\n    int count = 0, max = candyType.length / 2;\\n    for(int candy: candyType) {\\n        int t = candy + 100000;\\n        if(!type[t]) {\\n            if(++count == max) return max;\\n            type[t] = true;\\n        }\\n    }\\n    return count;\\n}\\n```\\n\\n**Approach 3: BitSet**\\nWe can alternatively use a bitset if we\\'d like to optimize space.\\n\\n```\\n// 6 ms. 98.66%\\npublic int distributeCandies(int[] candyType) {\\n    BitSet bits = new BitSet(200001);\\n    int count = 0, max = candyType.length / 2;\\n    for(int candy: candyType) {\\n        int t = candy + 100000;\\n        if(!bits.get(t)) {\\n            if(++count == max) return max;\\n            bits.set(t);\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 33 ms. 62%\\npublic int distributeCandies(int[] candyType) {\\n    Set<Integer> set = new HashSet<>();\\n    for(int candy: candyType) {\\n        set.add(candy);\\n    }\\n    return Math.min(candyType.length / 2, set.size());\\n}\\n```\n```\\n// 3 ms. 100%\\npublic int distributeCandies(int[] candyType) {\\n    boolean[] type = new boolean[200001];\\n    int count = 0, max = candyType.length / 2;\\n    for(int candy: candyType) {\\n        int t = candy + 100000;\\n        if(!type[t]) {\\n            if(++count == max) return max;\\n            type[t] = true;\\n        }\\n    }\\n    return count;\\n}\\n```\n```\\n// 6 ms. 98.66%\\npublic int distributeCandies(int[] candyType) {\\n    BitSet bits = new BitSet(200001);\\n    int count = 0, max = candyType.length / 2;\\n    for(int candy: candyType) {\\n        int t = candy + 100000;\\n        if(!bits.get(t)) {\\n            if(++count == max) return max;\\n            bits.set(t);\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1087789,
                "title": "python-oneliner-explained",
                "content": "Alice needs to eat exactly `n//2` candies and the question is how many types she can eat. There are two restrictions we have here:\\n\\n1. `len(Counter(candies))` is how many candies type we have at all, and we can not eat more than this number types of candies.\\n2. `len(candies)//2` is exaclty how many candies Alice must eat, so we can not eat more than this number (she can eat less and then eat any other candies to have exactly the half).\\n\\nNotice also, that these two conditions are **sufficient and enough**: strategy is the following: first eat one candy of each type until it is possible and then if we have eaten less than half, eat any candies to make it half.\\n\\n**Complexity**: time complexity is `O(n)`, where `n` is total number of candies, space complexity is also `O(n)`.\\n\\n```\\nclass Solution:\\n    def distributeCandies(self, candies):\\n        return min(len(candies)//2, len(Counter(candies)))\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies):\\n        return min(len(candies)//2, len(Counter(candies)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402699,
                "title": "python-easy-solution",
                "content": "```\\ndef distributeCandies(self, candyType: List[int]) -> int:\\n        # half length of candyType list\\n        candy_len = int(len(candyType)/2)\\n        # no of of unique candies \\n        unique_candy_len = len(set(candyType))\\n        return min(candy_len,unique_candy_len)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef distributeCandies(self, candyType: List[int]) -> int:\\n        # half length of candyType list\\n        candy_len = int(len(candyType)/2)\\n        # no of of unique candies \\n        unique_candy_len = len(set(candyType))\\n        return min(candy_len,unique_candy_len)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1087771,
                "title": "c-two-lines-only-super-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        int types_num = set<int>(candies.begin(), candies.end()).size();\\n        return types_num > candies.size()/2 ? candies.size()/2 : types_num;\\n    }\\n};\\n```\\n**LIKE IT? PLEASE UPVOTE...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        int types_num = set<int>(candies.begin(), candies.end()).size();\\n        return types_num > candies.size()/2 ? candies.size()/2 : types_num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572326,
                "title": "hashset-easy-solution",
                "content": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int num : candyType )set.add(num);\\n        return set.size()>=(candyType.length/2)?candyType.length/2:set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int num : candyType )set.add(num);\\n        return set.size()>=(candyType.length/2)?candyType.length/2:set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087773,
                "title": "python-one-liner-simple-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: List[int]) -> int:\\n        return min(len(candyType)//2, len(set(candyType)))\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: List[int]) -> int:\\n        return min(len(candyType)//2, len(set(candyType)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044024,
                "title": "c-solution-98-faster-time-and-96-lesser-space-distribute-candies",
                "content": "```\\nint distributeCandies(vector<int>& candyType) {\\n        bitset<200001> bit(0);//200001 covers the range (10^-5 , 10^5)\\n        int n = candyType.size();\\n        for(int i=0;i<n;++i)bit.set(candyType[i]+100000);\\n        n/=2;\\n        int count = bit.count();\\n        return min(n,count);\\n    }",
                "solutionTags": [],
                "code": "```\\nint distributeCandies(vector<int>& candyType) {\\n        bitset<200001> bit(0);//200001 covers the range (10^-5 , 10^5)\\n        int n = candyType.size();\\n        for(int i=0;i<n;++i)bit.set(candyType[i]+100000);\\n        n/=2;\\n        int count = bit.count();\\n        return min(n,count);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 799502,
                "title": "c-2-line-super-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        int types_num = set<int>(candies.begin(), candies.end()).size();\\n        return types_num > candies.size()/2 ? candies.size()/2 : types_num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        int types_num = set<int>(candies.begin(), candies.end()).size();\\n        return types_num > candies.size()/2 ? candies.size()/2 : types_num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298893,
                "title": "575-time-92-8-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a set to store unique candy types.\\n2. Traverse through the input array and add each candy type to the set.\\n3. Find the length of the input array and divide it by 2 to get the maximum number of candies Alice can eat.\\n4. Find the length of the set of unique candy types.\\n5. Return the minimum between the length of the set of unique candy types and the maximum number of candies Alice can eat.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        # Use set to count the number of unique candies\\n        unique_candies = set(candyType)\\n        \\n        # Return the minimum between the number of unique candies and half the length of the input array\\n        return min(len(unique_candies), len(candyType)//2)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        # Use set to count the number of unique candies\\n        unique_candies = set(candyType)\\n        \\n        # Return the minimum between the number of unique candies and half the length of the input array\\n        return min(len(unique_candies), len(candyType)//2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 119460,
                "title": "c-java-python-1-liner",
                "content": "She **cannot get more than half** even if the all the candies are different.\\n\\nC++\\n```\\nint distributeCandies(vector<int>& candies) {\\n    return min(candies.size() / 2, unordered_set<int>(candies.begin(), candies.end()).size()); \\n}\\n```\\n\\nJava\\n```\\npublic int distributeCandies(int[] candies) {\\n    return Math.min(candies.length / 2, IntStream.of(candies).boxed().collect(Collectors.toSet()).size());\\n}\\n```\\n\\n\\nPython\\n```\\ndef distributeCandies(self, candies):\\n    return min(len(candies) / 2, len(set(candies)))\\n```",
                "solutionTags": [],
                "code": "```\\nint distributeCandies(vector<int>& candies) {\\n    return min(candies.size() / 2, unordered_set<int>(candies.begin(), candies.end()).size()); \\n}\\n```\n```\\npublic int distributeCandies(int[] candies) {\\n    return Math.min(candies.length / 2, IntStream.of(candies).boxed().collect(Collectors.toSet()).size());\\n}\\n```\n```\\ndef distributeCandies(self, candies):\\n    return min(len(candies) / 2, len(set(candies)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 102951,
                "title": "python-1-line",
                "content": "class Solution(object):\\n\\n    def distributeCandies(self, candies):\\n    \\treturn min(len(candies) / 2,len(set(candies)))",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\n    def distributeCandies(self, candies):\\n    \\treturn min(len(candies) / 2,len(set(candies)))",
                "codeTag": "Java"
            },
            {
                "id": 3459892,
                "title": "easy-unordered-set-solution-o-n-time-complexity",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore elements of given vector in an unordered_set. Since the unordered_set stores only unique elements the occurence of each element will be 1 only.\\nNow we know she can eat only n/2 candies of different types so if the number of distinct elements is greater or equal to n/2 then she can have only n/2 candies irrespectiv of the distinct elements.\\nBut if the number is less than n/2 then the option is the number of distinct cnadies only.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int n = candyType.size();\\n        unordered_set<int> s(candyType.begin(), candyType.end());\\n        if(s.size() >= n/2){\\n            return n/2;\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int n = candyType.size();\\n        unordered_set<int> s(candyType.begin(), candyType.end());\\n        if(s.size() >= n/2){\\n            return n/2;\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684284,
                "title": "3-line-java-solution",
                "content": "\\n    public int distributeCandies(int[] candyType) {\\n        int n = candyType.length;\\n        Set<Integer> set = new HashSet();\\n        for(int candy : candyType)\\n            set.add(candy);\\n        return Math.min(set.size(), n/2);\\n    }\\n\\t\\t //plz !!! upvote",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "\\n    public int distributeCandies(int[] candyType) {\\n        int n = candyType.length;\\n        Set<Integer> set = new HashSet();\\n        for(int candy : candyType)\\n            set.add(candy);\\n        return Math.min(set.size(), n/2);\\n    }\\n\\t\\t //plz !!! upvote",
                "codeTag": "Unknown"
            },
            {
                "id": 2219608,
                "title": "c-easy-solution",
                "content": "Hope this helps : )\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        sort(candyType.begin(),candyType.end());\\n        int count = 1;\\n        for(int i = 0;i<candyType.size();i++){\\n            for(int j = i+1;j<candyType.size();j++){\\n                if(candyType[i]==candyType[j]){\\n                    continue;\\n                }\\n                else if(candyType[i]!=candyType[j]){\\n                    i=j;\\n                    i--;\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        int n = candyType.size()/2;\\n        if(count == n){\\n            return n;\\n        }\\n        else{\\n            return min(count,n);\\n        }\\n    }\\n};\\n```\\nMake sure to upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        sort(candyType.begin(),candyType.end());\\n        int count = 1;\\n        for(int i = 0;i<candyType.size();i++){\\n            for(int j = i+1;j<candyType.size();j++){\\n                if(candyType[i]==candyType[j]){\\n                    continue;\\n                }\\n                else if(candyType[i]!=candyType[j]){\\n                    i=j;\\n                    i--;\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        int n = candyType.size()/2;\\n        if(count == n){\\n            return n;\\n        }\\n        else{\\n            return min(count,n);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800420,
                "title": "python-one-liner-simplest-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: List[int]) -> int:\\n        return len(candies)//2 if len(set(candies)) > len(candies)//2 else len(set(candies))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: List[int]) -> int:\\n        return len(candies)//2 if len(set(candies)) > len(candies)//2 else len(set(candies))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365785,
                "title": "100-100-java-4-solution-optimisations",
                "content": "Using Hash technique\\n37 ms, faster than 83.75%\\n\\n```\\n\\n/**\\n * Important observation is that, if there are n types of candies then sister is more likely to have n types of candies\\n * 1. if; distribution of candies > types of candies -> sister will have all kind of candies for sure\\n * 2. else distribution of candies < types of candies -> sister will can not have all types of candies as her share is smaller then types\\n * <p>\\n * O(n) / O (n)\\n */\\nclass DistributeCandiesUsingHash {\\n    public int distributeCandies(int[] candies) {\\n\\n        if (candies == null || candies.length == 0)\\n            return 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < candies.length; i++) {\\n            int c = candies[i];\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n\\n        int types = map.size();\\n        int total = candies.length;\\n\\n        int equal = total / 2;\\n\\n        if (equal < types)\\n            return equal;\\n        else\\n            return types;\\n\\n\\n    }\\n\\n\\n    /**\\n     * You don\\'t need to count till end of array. Since if \\'distribution of candies > types of candies\\' then for sure she\\'ll get all\\n     * kind of candies; Since distribution of candies = length / 2\\n     * <p>\\n     * <p>\\n     * Runtime: 37 ms, faster than 83.75% of Java online submissions for Distribute Candies.\\n     * Memory Usage: 40.4 MB, less than 100.00% of Java online submissions for Distribute Candies.\\n     *\\n     * @param candies\\n     * @return\\n     */\\n    public int distributeCandiesFaster(int[] candies) {\\n\\n        if (candies == null || candies.length == 0)\\n            return 0;\\n\\n        Set<Integer> set = new HashSet<>();\\n        int types = 0;\\n\\n        for (int i = 0; i < candies.length && types < candies.length / 2; i++) {\\n            int c = candies[i];\\n            if (!set.contains(c))\\n                types++;\\n            set.add(c);\\n        }\\n\\n        return types;\\n\\n\\n    }\\n}\\n\\n```\\n\\nUsing Bit set:\\n11 ms, faster than 96.95%\\n\\n```\\n\\n/**\\n * Important observation is that, if there are n types of candies then sister is more likely to have n types of candies\\n * 1. if; distribution of candies > types of candies -> sister will have all kind of candies for sure\\n * 2. else distribution of candies < types of candies -> sister will can not have all types of candies as her share is smaller then types\\n * <p>\\n * Since types of candies are fixed  range [-100,000, 100,000].\\n * Then we can use bitSet to count the types\\n * <p>\\n * Runtime: 11 ms, faster than 96.95% of Java online submissions for Distribute Candies.\\n * Memory Usage: 45.1 MB, less than 47.37% of Java online submissions for Distribute Candies.\\n */\\n\\nclass DistributeCandiesUsingBit {\\n\\n\\n    public int distributeCandies(int[] candies) {\\n        if (candies == null || candies.length == 0)\\n            return 0;\\n\\n        int types = 0;\\n        final int offset = 100000;\\n        BitSet bitSet = new BitSet(100000 * 2 + 1);\\n\\n        for (int i = 0; i < candies.length && types < candies.length >> 1; i++) {\\n\\n            int c = candies[i] + offset;\\n\\n            if (!bitSet.get(c))\\n                types++;\\n            bitSet.set(c);\\n\\n\\n        }\\n\\n        return types;\\n\\n\\n    }\\n}\\n\\n```\\n\\nUsing boolean array: This will reduce the overall task to manage a bit\\n6 ms, faster than 100% \\n```\\nclass DistributeCandiesUsingBoolean {\\n\\n\\n    public int distributeCandies(int[] candies) {\\n        if (candies == null || candies.length == 0)\\n            return 0;\\n\\n        final int offset = 100000;\\n        boolean[] set = new boolean[2 * offset + 1];\\n        int types = 0;\\n        for (int i = 0; i < candies.length && types < candies.length >> 1; i++) {\\n\\n            if (!set[candies[i] + offset]) {\\n                types++;\\n                set[candies[i] + offset] = true;\\n            }\\n        }\\n        return types;\\n\\n\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * Important observation is that, if there are n types of candies then sister is more likely to have n types of candies\\n * 1. if; distribution of candies > types of candies -> sister will have all kind of candies for sure\\n * 2. else distribution of candies < types of candies -> sister will can not have all types of candies as her share is smaller then types\\n * <p>\\n * O(n) / O (n)\\n */\\nclass DistributeCandiesUsingHash {\\n    public int distributeCandies(int[] candies) {\\n\\n        if (candies == null || candies.length == 0)\\n            return 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < candies.length; i++) {\\n            int c = candies[i];\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n\\n        int types = map.size();\\n        int total = candies.length;\\n\\n        int equal = total / 2;\\n\\n        if (equal < types)\\n            return equal;\\n        else\\n            return types;\\n\\n\\n    }\\n\\n\\n    /**\\n     * You don\\'t need to count till end of array. Since if \\'distribution of candies > types of candies\\' then for sure she\\'ll get all\\n     * kind of candies; Since distribution of candies = length / 2\\n     * <p>\\n     * <p>\\n     * Runtime: 37 ms, faster than 83.75% of Java online submissions for Distribute Candies.\\n     * Memory Usage: 40.4 MB, less than 100.00% of Java online submissions for Distribute Candies.\\n     *\\n     * @param candies\\n     * @return\\n     */\\n    public int distributeCandiesFaster(int[] candies) {\\n\\n        if (candies == null || candies.length == 0)\\n            return 0;\\n\\n        Set<Integer> set = new HashSet<>();\\n        int types = 0;\\n\\n        for (int i = 0; i < candies.length && types < candies.length / 2; i++) {\\n            int c = candies[i];\\n            if (!set.contains(c))\\n                types++;\\n            set.add(c);\\n        }\\n\\n        return types;\\n\\n\\n    }\\n}\\n\\n```\n```\\n\\n/**\\n * Important observation is that, if there are n types of candies then sister is more likely to have n types of candies\\n * 1. if; distribution of candies > types of candies -> sister will have all kind of candies for sure\\n * 2. else distribution of candies < types of candies -> sister will can not have all types of candies as her share is smaller then types\\n * <p>\\n * Since types of candies are fixed  range [-100,000, 100,000].\\n * Then we can use bitSet to count the types\\n * <p>\\n * Runtime: 11 ms, faster than 96.95% of Java online submissions for Distribute Candies.\\n * Memory Usage: 45.1 MB, less than 47.37% of Java online submissions for Distribute Candies.\\n */\\n\\nclass DistributeCandiesUsingBit {\\n\\n\\n    public int distributeCandies(int[] candies) {\\n        if (candies == null || candies.length == 0)\\n            return 0;\\n\\n        int types = 0;\\n        final int offset = 100000;\\n        BitSet bitSet = new BitSet(100000 * 2 + 1);\\n\\n        for (int i = 0; i < candies.length && types < candies.length >> 1; i++) {\\n\\n            int c = candies[i] + offset;\\n\\n            if (!bitSet.get(c))\\n                types++;\\n            bitSet.set(c);\\n\\n\\n        }\\n\\n        return types;\\n\\n\\n    }\\n}\\n\\n```\n```\\nclass DistributeCandiesUsingBoolean {\\n\\n\\n    public int distributeCandies(int[] candies) {\\n        if (candies == null || candies.length == 0)\\n            return 0;\\n\\n        final int offset = 100000;\\n        boolean[] set = new boolean[2 * offset + 1];\\n        int types = 0;\\n        for (int i = 0; i < candies.length && types < candies.length >> 1; i++) {\\n\\n            if (!set[candies[i] + offset]) {\\n                types++;\\n                set[candies[i] + offset] = true;\\n            }\\n        }\\n        return types;\\n\\n\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102858,
                "title": "1-liner-java-and-python",
                "content": "Given `n` (even) candies, the sister can at most get `n / 2` of them (distributed evenly). And if there are `k` kinds, `k` is also the upper bound of the number of kinds the sister can get.\\n\\n`n / 2` is simply `candies.length / 2`. To compute `k`, a traditional way is to use a hash map to count occurrences. And a shorter way is to use Java 8 streams.\\n\\n**1-liner Java 8 stream**\\n```\\nclass Solution {\\n    public int distributeCandies(int[] candies) {\\n        return Integer.min((int) Stream.of(candies).distinct().count(), candies.length / 2);\\n    }\\n}\\n```\\n\\n**Traditional HashMap**\\n```\\nclass Solution {\\n    public int distributeCandies(int[] candies) {\\n        final Map<Integer, Integer> kinds = new HashMap<>();\\n        for (final int candy : candies) {\\n            if (kinds.containsKey(candy)) {\\n                kinds.put(candy, kinds.get(candy) + 1);\\n            } else {\\n                kinds.put(candy, 1);\\n            }\\n        }\\n        return Integer.min(kinds.size(), candies.length / 2);\\n    }\\n}\\n```\\n\\n**Python 1-liner**\\nComputing `k` is just the use case of `Counter`.\\n```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def distributeCandies(self, candies):\\n        \"\"\"\\n        :type candies: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return min(len(Counter(candies)), len(candies) / 2)      \\n```\\nWith Java 8 streams, 1-liner becomes more likely for Java :-)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candies) {\\n        return Integer.min((int) Stream.of(candies).distinct().count(), candies.length / 2);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int distributeCandies(int[] candies) {\\n        final Map<Integer, Integer> kinds = new HashMap<>();\\n        for (final int candy : candies) {\\n            if (kinds.containsKey(candy)) {\\n                kinds.put(candy, kinds.get(candy) + 1);\\n            } else {\\n                kinds.put(candy, 1);\\n            }\\n        }\\n        return Integer.min(kinds.size(), candies.length / 2);\\n    }\\n}\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def distributeCandies(self, candies):\\n        \"\"\"\\n        :type candies: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return min(len(Counter(candies)), len(candies) / 2)      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463752,
                "title": "beats-100-tc-simple-if-else-easily-understandable-python-solution",
                "content": "# Approach\\n - Converts the array ```candyType``` to a set which gonna contain only discrete values\\n - if ```eat <= len(dis_candyType)``` it means there are enough options available (i.e. Here every candy Alice eats is of different type)\\n - elif ```eat > len(dis_candyType)``` not enough options available \\n (i.e. Here Alice will have ```len(dis_candyType)``` different types of candies)\\n# Complexity\\n- Time complexity:\\nBeats 100%\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        l = len(candyType)\\n        eat = l//2\\n        dis_candyType = set(candyType)\\n\\n        if eat <= len(dis_candyType):\\n            return eat\\n\\n        elif eat > len(dis_candyType):\\n            return len(dis_candyType) \\n\\n# Please Upvote if you like it :)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```candyType```\n```eat <= len(dis_candyType)```\n```eat > len(dis_candyType)```\n```len(dis_candyType)```\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        l = len(candyType)\\n        eat = l//2\\n        dis_candyType = set(candyType)\\n\\n        if eat <= len(dis_candyType):\\n            return eat\\n\\n        elif eat > len(dis_candyType):\\n            return len(dis_candyType) \\n\\n# Please Upvote if you like it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215477,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        unordered_set<int>s;\\n        \\n        int n=candyType.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(candyType[i]);\\n        }\\n        n/=2;\\n        if(s.size()<n)\\n        {\\n            return s.size();\\n        }\\n        return  n;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/2410b22b-c672-4e1a-afc3-35e120195b30_1676997814.3927085.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        unordered_set<int>s;\\n        \\n        int n=candyType.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(candyType[i]);\\n        }\\n        n/=2;\\n        if(s.size()<n)\\n        {\\n            return s.size();\\n        }\\n        return  n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892083,
                "title": "java-one-liner-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> s = new HashSet<>();\\n        for (int x : candyType) {\\n            s.add(x);\\n        }\\n        return Math.min(candyType.length >> 1, s.size());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> s = new HashSet<>();\\n        for (int x : candyType) {\\n            s.add(x);\\n        }\\n        return Math.min(candyType.length >> 1, s.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668580,
                "title": "java-easy-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int distributeCandies(int[] candyType) {\\n\\t\\t\\tHashSet<Integer>hs=new HashSet<>();\\n\\t\\t\\tfor(int i:candyType)\\n\\t\\t\\t\\ths.add(i);\\n\\t\\t\\tint r=candyType.length/2;\\n\\t\\t\\tif(hs.size()<r)\\n\\t\\t\\t   return hs.size();\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn r;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int distributeCandies(int[] candyType) {\\n\\t\\t\\tHashSet<Integer>hs=new HashSet<>();\\n\\t\\t\\tfor(int i:candyType)\\n\\t\\t\\t\\ths.add(i);\\n\\t\\t\\tint r=candyType.length/2;\\n\\t\\t\\tif(hs.size()<r)\\n\\t\\t\\t   return hs.size();\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn r;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1945669,
                "title": "c-beginners-frndly-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& a) {\\n        unordered_set<int> s;        // declaration of set\\n        for(int i=0;i<a.size();i++)\\n            s.insert(a[i]);                       // insertion in set\\n        \\n        int x=min(s.size(),a.size()/2);       // finding minimum of half of total and different kinds of candies\\n        return x;                      // returning the answer\\n        \\n        \\n    }\\n};\\n```\\nKINDLY UPVOTE <3 !!",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& a) {\\n        unordered_set<int> s;        // declaration of set\\n        for(int i=0;i<a.size();i++)\\n            s.insert(a[i]);                       // insertion in set\\n        \\n        int x=min(s.size(),a.size()/2);       // finding minimum of half of total and different kinds of candies\\n        return x;                      // returning the answer\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598554,
                "title": "simple-c-solution-runtime-faster-than-79-79-memory-usage-less-than-62-37",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        unordered_set<int> s;\\n        int n = candyType.size();\\n        for(int i=0;i<n;i++){\\n            s.insert(candyType[i]);\\n        }\\n        if(n/2 < s.size()){\\n            return n/2;\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        unordered_set<int> s;\\n        int n = candyType.size();\\n        for(int i=0;i<n;i++){\\n            s.insert(candyType[i]);\\n        }\\n        if(n/2 < s.size()){\\n            return n/2;\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088129,
                "title": "javascript-one-liner",
                "content": "```javascript\\nvar distributeCandies = function(candyType) {\\n    return Math.min(candyType.length/2,  new Set(candyType).size)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar distributeCandies = function(candyType) {\\n    return Math.min(candyType.length/2,  new Set(candyType).size)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1088082,
                "title": "java-1-liner-using-hashset",
                "content": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        return Math.min(candyType.length / 2, Arrays.stream(candyType).boxed().collect(Collectors.toSet()).size());\\n    }\\n}\\n```\\n\\n`TC - O(n)`\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        return Math.min(candyType.length / 2, Arrays.stream(candyType).boxed().collect(Collectors.toSet()).size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088072,
                "title": "rust-solution",
                "content": "```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distribute_candies(candy_type: Vec<i32>) -> i32 {\\n        let len = candy_type.len();\\n        let hashset: HashSet<i32> = candy_type.into_iter().collect();\\n        std::cmp::min(len / 2, hashset.len()) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distribute_candies(candy_type: Vec<i32>) -> i32 {\\n        let len = candy_type.len();\\n        let hashset: HashSet<i32> = candy_type.into_iter().collect();\\n        std::cmp::min(len / 2, hashset.len()) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1087845,
                "title": "distribute-candies-js-python-java-c-set-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIn order to solve this problem, we need to identify how many unique types of candy there are. The easiest method to find unique values is with a **set**. If we convert our input array of candy types (**C**) to a set, then it will only contain unique values, and thus the size of the set will represent the number of different candy types.\\n\\nThe only other thing to remember is that we\\'re constrained to at most **C.length / 2** pieces, per the instructions, so we need to use a **min()** boundary before we **return** our answer.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJava alone does not have an easy **set** constructor from an **int array**. Any such solution would have to invole boxing the primitive **int**s into **Integer**s before converting to a **HashSet**, so it\\'s easier just to build the **HashSet** iteratively via a **for loop**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n```javascript\\nconst distributeCandies = C => Math.min((new Set(C)).size, C.length / 2)\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n```python\\nclass Solution:\\n    def distributeCandies(self, C: List[int]) -> int:\\n        return min(len(set(C)), len(C) // 2)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\n```java\\nclass Solution {\\n    public int distributeCandies(int[] C) {\\n        Set<Integer> cset = new HashSet<>();\\n        for (int c : C) cset.add(c)\\n        return Math.min(cset.size(), C.length / 2);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n```c++\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& C) {\\n        unordered_set<int> cset(begin(C), end(C));\\n        return min(cset.size(), C.size() / 2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst distributeCandies = C => Math.min((new Set(C)).size, C.length / 2)\\n```\n```python\\nclass Solution:\\n    def distributeCandies(self, C: List[int]) -> int:\\n        return min(len(set(C)), len(C) // 2)\\n```\n```java\\nclass Solution {\\n    public int distributeCandies(int[] C) {\\n        Set<Integer> cset = new HashSet<>();\\n        for (int c : C) cset.add(c)\\n        return Math.min(cset.size(), C.length / 2);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& C) {\\n        unordered_set<int> cset(begin(C), end(C));\\n        return min(cset.size(), C.size() / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087842,
                "title": "js-python-java-c-set-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIn order to solve this problem, we need to identify how many unique types of candy there are. The easiest method to find unique values is with a **set**. If we convert our input array of candy types (**C**) to a set, then it will only contain unique values, and thus the size of the set will represent the number of different candy types.\\n\\nThe only other thing to remember is that we\\'re constrained to at most **C.length / 2** pieces, per the instructions, so we need to use a **min()** boundary before we **return** our answer.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJava alone does not have an easy **set** constructor from an **int array**. Any such solution would have to invole boxing the primitive **int**s into **Integer**s before converting to a **HashSet**, so it\\'s easier just to build the **HashSet** iteratively via a **for loop**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n```javascript\\nconst distributeCandies = C => Math.min((new Set(C)).size, C.length / 2)\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n```python\\nclass Solution:\\n    def distributeCandies(self, C: List[int]) -> int:\\n        return min(len(set(C)), len(C) // 2)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\n```java\\nclass Solution {\\n    public int distributeCandies(int[] C) {\\n        Set<Integer> cset = new HashSet<>();\\n        for (int c : C) cset.add(c)\\n        return Math.min(cset.size(), C.length / 2);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n```c++\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& C) {\\n        unordered_set<int> cset(begin(C), end(C));\\n        return min(cset.size(), C.size() / 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nconst distributeCandies = C => Math.min((new Set(C)).size, C.length / 2)\\n```\n```python\\nclass Solution:\\n    def distributeCandies(self, C: List[int]) -> int:\\n        return min(len(set(C)), len(C) // 2)\\n```\n```java\\nclass Solution {\\n    public int distributeCandies(int[] C) {\\n        Set<Integer> cset = new HashSet<>();\\n        for (int c : C) cset.add(c)\\n        return Math.min(cset.size(), C.length / 2);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& C) {\\n        unordered_set<int> cset(begin(C), end(C));\\n        return min(cset.size(), C.size() / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668969,
                "title": "javascript-python3-c-1-liners",
                "content": "**Synopsis:**\\n\\nSimply return the minimum of unique candies and half the length of `A`.  This conclusion was derived from the following 2 use cases:\\n\\n* **Case 1:** if less than half of the candies are unique, then give all those unique candies to the sister\\n* **Case 2:** if more than half of the candies are unique, then we can give at most half to the sister\\n\\n*Javascript*\\n```\\nlet distributeCandies = A => Math.min(new Set(A).size, A.length / 2);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def distributeCandies(self, A: List[int]) -> int:\\n        return min(len(set(A)), len(A) // 2)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    int distributeCandies(VI& A) {\\n        return min(Set{ A.begin(), A.end() }.size(), A.size() / 2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet distributeCandies = A => Math.min(new Set(A).size, A.length / 2);\\n```\n```\\nclass Solution:\\n    def distributeCandies(self, A: List[int]) -> int:\\n        return min(len(set(A)), len(A) // 2)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    int distributeCandies(VI& A) {\\n        return min(Set{ A.begin(), A.end() }.size(), A.size() / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575969,
                "title": "pyhton-hashmap-beats-nearly-90",
                "content": "**[Pyhton], hashmap, beats nearly 90%**\\nIf there is anything not perfect, please feel free to indicate my problems.\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: List[int]) -> int:\\n            d = dict()\\n            dict_size = 0\\n            for num in candies:\\n                if num not in d:\\n                    d[num] = 1\\n                    dict_size += 1\\n                    \\n            list_size = len(candies) // 2\\n            \\n            result = list_size if list_size < dict_size else dict_size\\n            return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: List[int]) -> int:\\n            d = dict()\\n            dict_size = 0\\n            for num in candies:\\n                if num not in d:\\n                    d[num] = 1\\n                    dict_size += 1\\n                    \\n            list_size = len(candies) // 2\\n            \\n            result = list_size if list_size < dict_size else dict_size\\n            return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374549,
                "title": "c-2-line-solution-using-hash-set",
                "content": "Runtime: 284 ms, faster than 72.52% of C++ online submissions for Distribute Candies.\\nMemory Usage: 51.1 MB, less than 33.33% of C++ online submissions for Distribute Candies.\\n\\n```\\nint distributeCandies(vector<int>& candies) {\\n        \\n        unordered_set<int> mp;\\n        for(int i : candies) mp.insert(i);\\n        \\n        return min(candies.size()/2, mp.size());\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Runtime: 284 ms, faster than 72.52% of C++ online submissions for Distribute Candies.\\nMemory Usage: 51.1 MB, less than 33.33% of C++ online submissions for Distribute Candies.\\n\\n```\\nint distributeCandies(vector<int>& candies) {\\n        \\n        unordered_set<int> mp;\\n        for(int i : candies) mp.insert(i);\\n        \\n        return min(candies.size()/2, mp.size());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 336396,
                "title": "one-line-python",
                "content": "```\\nclass Solution(object):\\n    def distributeCandies(self, candies):\\n        return min(len(candies)//2, len(set(candies)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def distributeCandies(self, candies):\\n        return min(len(candies)//2, len(set(candies)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102888,
                "title": "java-solution-beats-99-07",
                "content": "Based on Bucket Sort:\\n<pre><code>\\n    public int distributeCandies(int[] candies) {\\n        int[] b = new int[200001];\\n        int nonEmptyBucketNo = 0;\\n        for (int i : candies) if (b[i + 100000]++ == 0) nonEmptyBucketNo++;\\n        return nonEmptyBucketNo <= candies.length / 2 ? nonEmptyBucketNo : candies.length / 2;\\n    }\\n</code></pre>",
                "solutionTags": [],
                "code": "Based on Bucket Sort:\\n<pre><code>\\n    public int distributeCandies(int[] candies) {\\n        int[] b = new int[200001];\\n        int nonEmptyBucketNo = 0;\\n        for (int i : candies) if (b[i + 100000]++ == 0) nonEmptyBucketNo++;\\n        return nonEmptyBucketNo <= candies.length / 2 ? nonEmptyBucketNo : candies.length / 2;\\n    }\\n</code></pre>",
                "codeTag": "Unknown"
            },
            {
                "id": 102939,
                "title": "java-8-one-line-solution-o-n",
                "content": "```\\npublic class Solution {\\n    public int distributeCandies(int[] candies) {\\n        return Math.min(candies.length / 2, IntStream.of(candies).boxed().collect(Collectors.toSet()).size());\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int distributeCandies(int[] candies) {\\n        return Math.min(candies.length / 2, IntStream.of(candies).boxed().collect(Collectors.toSet()).size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966822,
                "title": "easy-solution-in-c-time-complexity-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) \\n    {\\n        map<int,int>m;\\n        for(int i=0;i<candyType.size();i++)\\n        {\\n            m[candyType[i]]++;\\n        }\\n        int eat = candyType.size()/2;\\n        //return eat;\\n        int type = m.size();\\n        cout<<type<<endl;\\n        if(eat>=type)\\n        {\\n            return type;\\n        }\\n        else\\n        {\\n            return eat;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) \\n    {\\n        map<int,int>m;\\n        for(int i=0;i<candyType.size();i++)\\n        {\\n            m[candyType[i]]++;\\n        }\\n        int eat = candyType.size()/2;\\n        //return eat;\\n        int type = m.size();\\n        cout<<type<<endl;\\n        if(eat>=type)\\n        {\\n            return type;\\n        }\\n        else\\n        {\\n            return eat;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3586348,
                "title": "single-line-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe take the given array and make it a set and compare it with half of the length of the given array and take the least value among them \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(set(candyType)),len(candyType)//2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(set(candyType)),len(candyType)//2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405015,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int distributeCandies(vector<int>& candies) {\\n    bitset<200001> bitset;\\n\\n    for (const int candy : candies)\\n      bitset.set(candy + 100000);\\n\\n    return min(candies.size() / 2, bitset.count());\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        a=len(candyType)//2\\n        b=len(set(candyType))\\n        return min(a,b)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n\\n        int n= candyType.length;\\n        int min= Integer.MAX_VALUE;\\n        int max= Integer.MIN_VALUE;\\n        \\n        int typesOfNum= 0;\\n\\n        for(int i : candyType) {\\n            min= Math.min(min, i);\\n            max= Math.max(max, i);\\n        }\\n        boolean arr[]= new boolean[max-min+1];\\n\\n        for(int i : candyType) {\\n            int j= i - min;\\n\\n            if(!arr[j]) {\\n                arr[j]= true;\\n                typesOfNum++;\\n            }\\n        }\\n        return Math.min(n/2, typesOfNum);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int distributeCandies(vector<int>& candies) {\\n    bitset<200001> bitset;\\n\\n    for (const int candy : candies)\\n      bitset.set(candy + 100000);\\n\\n    return min(candies.size() / 2, bitset.count());\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        a=len(candyType)//2\\n        b=len(set(candyType))\\n        return min(a,b)\\n```\n```Java []\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n\\n        int n= candyType.length;\\n        int min= Integer.MAX_VALUE;\\n        int max= Integer.MIN_VALUE;\\n        \\n        int typesOfNum= 0;\\n\\n        for(int i : candyType) {\\n            min= Math.min(min, i);\\n            max= Math.max(max, i);\\n        }\\n        boolean arr[]= new boolean[max-min+1];\\n\\n        for(int i : candyType) {\\n            int j= i - min;\\n\\n            if(!arr[j]) {\\n                arr[j]= true;\\n                typesOfNum++;\\n            }\\n        }\\n        return Math.min(n/2, typesOfNum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281917,
                "title": "c-solution-82-48-time-54-53-space-used-unordered-set",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(unique elements)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType);\\n};\\n/***************************************************************/\\nint Solution::distributeCandies(vector<int>& candyType) {\\n    int i, n;\\n    unordered_set<int> s;\\n    n = candyType.size();\\n    for (i = 0; i < n; ++i) {\\n        s.insert(candyType[i]);\\n    }\\n    if (n/2 <= s.size()) {\\n        return n/2;\\n    } else {\\n        return s.size();\\n    }\\n}\\n/***************************************************************/\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType);\\n};\\n/***************************************************************/\\nint Solution::distributeCandies(vector<int>& candyType) {\\n    int i, n;\\n    unordered_set<int> s;\\n    n = candyType.size();\\n    for (i = 0; i < n; ++i) {\\n        s.insert(candyType[i]);\\n    }\\n    if (n/2 <= s.size()) {\\n        return n/2;\\n    } else {\\n        return s.size();\\n    }\\n}\\n/***************************************************************/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947653,
                "title": "python-3-lines-faster-than-98-93-simple-explained",
                "content": "**Note:** In the tags, I put Ordered Set there but the set doesn\\'t actually have any order.\\n## Please \\uD83D\\uDC4D\\uD83C\\uDFFB\\uD83D\\uDC4D\\uD83C\\uDFFB\\uD83D\\uDC4D\\uD83C\\uDFFB\\uD83D\\uDC4D\\uD83C\\uDFFB\\uD83D\\uDC4D\\uD83C\\uDFFB\\uD83D\\uDC4D\\uD83C\\uDFFB if u like!!\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType):\\n        n = len(candyType) // 2 # just get the number of candies you can eat\\n        LEN = len(set(candyType)) # types of different candies\\n        return min(n, LEN) # use min() to get the max types we can get\\n```\\n![image.png](https://assets.leetcode.com/users/images/2214ba90-c367-4ae0-b62a-c44c309bd34e_1671929564.8890448.png)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType):\\n        n = len(candyType) // 2 # just get the number of candies you can eat\\n        LEN = len(set(candyType)) # types of different candies\\n        return min(n, LEN) # use min() to get the max types we can get\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922870,
                "title": "o-n-c-unordered-maps-easy-to-understand-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        // Using to store new candy type\\n        unordered_map<int, int> candy;\\n        int count = 0;\\n        for (int i = 0; i < candyType.size(); i++) {\\n            // Checking if the candy was already present or not\\n            // If not then we can increase the count \\n            if (!candy[candyType[i]]) {\\n                count++;\\n                // If the count reaches n/2, we can stop as \\n                // Alice can\\'t eat more than n/2 candies\\n                if (count == candyType.size() / 2) {\\n                    return candyType.size() / 2;\\n                }\\n            }\\n            // Adding the candy if it\\'s not in our Candy storage\\n            candy[candyType[i]]++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**If you have any doubts, you can ask in the comment section.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        // Using to store new candy type\\n        unordered_map<int, int> candy;\\n        int count = 0;\\n        for (int i = 0; i < candyType.size(); i++) {\\n            // Checking if the candy was already present or not\\n            // If not then we can increase the count \\n            if (!candy[candyType[i]]) {\\n                count++;\\n                // If the count reaches n/2, we can stop as \\n                // Alice can\\'t eat more than n/2 candies\\n                if (count == candyType.size() / 2) {\\n                    return candyType.size() / 2;\\n                }\\n            }\\n            // Adding the candy if it\\'s not in our Candy storage\\n            candy[candyType[i]]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906734,
                "title": "javascript-noob-solution",
                "content": "# Intuition\\nI thought this was complicated because the description was a bit vague. I knew i needed a loop to go through the array and keep track of unique integers.\\n\\n# Approach\\nI started with an object to store my integers and a count of their occurances in an object(count{...}) Then i used an if statement to see if the amount of keys was less than the N /2 requirement. I would return the number of keys(unique integers) if so and else i\\'d return N/2(candyType.length/2).\\n(I\\'m new to coding so trying to explain my reasoning is tough)\\n# Complexity\\n- Time complexity:\\n??? O(n)\\nnot sure\\n\\n- Space complexity:\\n???\\n# Code\\n```\\n/**\\n * @param {number[]} candyType\\n * @return {number}\\n */\\nvar distributeCandies = function(candyType) {\\n    var count = {};\\n    for(let i = 0; i<candyType.length; i++) {\\n        var num = candyType[i]\\n       count[num] = count[num] ? +1 : 1;\\n    }\\n        if(Object.keys(count).length < candyType.length/2) {\\n            return Object.keys(count).length\\n        } else {\\n            return candyType.length/2\\n        }\\n };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} candyType\\n * @return {number}\\n */\\nvar distributeCandies = function(candyType) {\\n    var count = {};\\n    for(let i = 0; i<candyType.length; i++) {\\n        var num = candyType[i]\\n       count[num] = count[num] ? +1 : 1;\\n    }\\n        if(Object.keys(count).length < candyType.length/2) {\\n            return Object.keys(count).length\\n        } else {\\n            return candyType.length/2\\n        }\\n };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715097,
                "title": "java-solution-using-hashmap",
                "content": "If the solution is helpful please upvote this.\\n\\n```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i<candyType.length; i++)\\n        {\\n            map.put(candyType[i], map.getOrDefault(candyType[i], 0)+1);\\n        }\\n        \\n        int permit = candyType.length / 2;\\n        \\n        if(map.size() < permit)\\n        {\\n            return map.size();\\n        }\\n        \\n        return permit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i<candyType.length; i++)\\n        {\\n            map.put(candyType[i], map.getOrDefault(candyType[i], 0)+1);\\n        }\\n        \\n        int permit = candyType.length / 2;\\n        \\n        if(map.size() < permit)\\n        {\\n            return map.size();\\n        }\\n        \\n        return permit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632227,
                "title": "python-210ms-simplest-approach-using-len-set-and-min",
                "content": "\\t\\t\\t\\tclass Solution:\\n\\t\\t\\t\\t\\tdef distributeCandies(self, candyType: List[int]) -> int:\\n\\t\\t\\t\\t\\t\\ta=len(candyType)//2\\n\\t\\t\\t\\t\\t\\tb=len(set(candyType))\\n\\t\\t\\t\\t\\t\\treturn min(a,b)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\t\\t\\tclass Solution:\\n\\t\\t\\t\\t\\tdef distributeCandies(self, candyType: List[int]) -> int:\\n\\t\\t\\t\\t\\t\\ta=len(candyType)//2\\n\\t\\t\\t\\t\\t\\tb=len(set(candyType))\\n\\t\\t\\t\\t\\t\\treturn min(a,b)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2509029,
                "title": "javascript-one-liner",
                "content": "```\\nvar distributeCandies = function(candyType) {\\n\\t// The Set will remove all of the duplicates from candyType\\n    return Math.min(candyType.length / 2, new Set(candyType).size);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar distributeCandies = function(candyType) {\\n\\t// The Set will remove all of the duplicates from candyType\\n    return Math.min(candyType.length / 2, new Set(candyType).size);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2434933,
                "title": "one-liner-python-waku-waku",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return int(min(len(set(candyType)), len(candyType)/2))\\n```\\n![image](https://assets.leetcode.com/users/images/84af8c25-50d1-4d89-bfe6-ced1c280bf9d_1660665502.2503111.jpeg)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return int(min(len(set(candyType)), len(candyType)/2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050286,
                "title": "java-hashset-5-line-code",
                "content": "class Solution {\\n    public int distributeCandies(int[] candyType) {\\n     HashSet<Integer> h = new HashSet<>();\\n      int count = 0;\\n      for(int i =0 ;i< candyType.length ; i++){\\n        \\n             h.add(candyType[i]);\\n                   \\n      }\\n      return Math.min(candyType.length/2 , h.size());\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int distributeCandies(int[] candyType) {\\n     HashSet<Integer> h = new HashSet<>();\\n      int count = 0;\\n      for(int i =0 ;i< candyType.length ; i++){\\n        \\n             h.add(candyType[i]);\\n                   \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1874829,
                "title": "c-solution-sorting-easily-understandable-o-log-n",
                "content": "```\\nint cmp_func(const void *a, const void *b)\\n{\\n    return (*(int *)a - *(int *)b);\\n}\\n\\nint distributeCandies(int* candyType, int candyTypeSize)\\n{    \\n    int different_candy_cnt = 1;\\n    int edible_candies = candyTypeSize / 2;\\n    \\n    qsort(candyType, candyTypeSize, sizeof(int), cmp_func);\\n    \\n    for (int i = 0, j = 0; j  < candyTypeSize; j++) {\\n        if (candyType[i] != candyType[j]) {\\n            i = j;\\n            different_candy_cnt++;\\n        }\\n    }\\n    \\n    return (edible_candies > different_candy_cnt) ? different_candy_cnt : edible_candies;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp_func(const void *a, const void *b)\\n{\\n    return (*(int *)a - *(int *)b);\\n}\\n\\nint distributeCandies(int* candyType, int candyTypeSize)\\n{    \\n    int different_candy_cnt = 1;\\n    int edible_candies = candyTypeSize / 2;\\n    \\n    qsort(candyType, candyTypeSize, sizeof(int), cmp_func);\\n    \\n    for (int i = 0, j = 0; j  < candyTypeSize; j++) {\\n        if (candyType[i] != candyType[j]) {\\n            i = j;\\n            different_candy_cnt++;\\n        }\\n    }\\n    \\n    return (edible_candies > different_candy_cnt) ? different_candy_cnt : edible_candies;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1872551,
                "title": "distribute-candies-solution-java",
                "content": "class Solution {\\n  public int distributeCandies(int[] candies) {\\n    BitSet bitset = new BitSet(200001);\\n\\n    for (final int candy : candies)\\n      bitset.set(candy + 100000);\\n\\n    return Math.min(candies.length / 2, bitset.cardinality());\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Hash Table"
                ],
                "code": "class Solution {\\n  public int distributeCandies(int[] candies) {\\n    BitSet bitset = new BitSet(200001);\\n\\n    for (final int candy : candies)\\n      bitset.set(candy + 100000);\\n\\n    return Math.min(candies.length / 2, bitset.cardinality());\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1425421,
                "title": "java-using-bitset",
                "content": "```\\nclass Solution {\\n    int m = 100000;\\n    public int distributeCandies(int[] candyType) {\\n        BitSet bset = new BitSet();\\n        int count = 0;\\n        int len = candyType.length/2;\\n        for(int i:candyType){\\n            if(!bset.get(i+m)) {\\n                if(++count == len) return count;\\n                bset.set(i+m);\\n            }\\n        }\\n        return count;  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m = 100000;\\n    public int distributeCandies(int[] candyType) {\\n        BitSet bset = new BitSet();\\n        int count = 0;\\n        int len = candyType.length/2;\\n        for(int i:candyType){\\n            if(!bset.get(i+m)) {\\n                if(++count == len) return count;\\n                bset.set(i+m);\\n            }\\n        }\\n        return count;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393015,
                "title": "short-sweet-c-solution",
                "content": "```\\nint distributeCandies(vector<int>& candyType) {\\n        set<int> s;\\n        for (auto i:candyType)\\n            s.insert(i);\\n        if (s.size() > candyType.size()/2)\\n            return candyType.size()/2;\\n        else\\n            return s.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint distributeCandies(vector<int>& candyType) {\\n        set<int> s;\\n        for (auto i:candyType)\\n            s.insert(i);\\n        if (s.size() > candyType.size()/2)\\n            return candyType.size()/2;\\n        else\\n            return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1233758,
                "title": "easy-java-4-lines-code",
                "content": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int c : candyType) set.add(c);\\n        \\n        int eat = candyType.length/2;\\n        return set.size()<eat ? set.size() : eat;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int c : candyType) set.add(c);\\n        \\n        int eat = candyType.length/2;\\n        return set.size()<eat ? set.size() : eat;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1185411,
                "title": "c-o-nlogn-faster-than-96-20-simple-solution",
                "content": "Alternate Solution [here](https://github.com/prishitakadam/LeetCode/blob/master/Problems/575.%20Distribute%20Candies.cpp). \\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int unique = 1;\\n        sort(candyType.begin(), candyType.end());\\n        int* p = candyType.data();\\n        \\n        for(int i=0; i<candyType.size()-1; i++){\\n            if(p[i] != p[i+1])\\n                unique++;\\n        }\\n        \\n        if(unique < candyType.size()/2)\\n            return unique;\\n        else\\n            return candyType.size()/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int unique = 1;\\n        sort(candyType.begin(), candyType.end());\\n        int* p = candyType.data();\\n        \\n        for(int i=0; i<candyType.size()-1; i++){\\n            if(p[i] != p[i+1])\\n                unique++;\\n        }\\n        \\n        if(unique < candyType.size()/2)\\n            return unique;\\n        else\\n            return candyType.size()/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116294,
                "title": "faster-than-98-69-of-c-online-submissions",
                "content": "I have first sorted the vector, then I have tried to find the unique element. \\nAfter doing that, the code does either of the following:-\\n1 . If number of distinct elements is less than half the size of the vector, return the former\\n2. Else, return the latter.\\n\\nHere is the code:-\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int disc = 0;\\n        sort(candyType.begin(),candyType.end());\\n        for(int i = 0;i < candyType.size();i++){\\n            while(i < candyType.size() - 1 && candyType[i] == candyType[i+1])\\n                i++;\\n            disc++;\\n        }\\n        int res = candyType.size()/2;\\n        if(disc > res)\\n            return res;\\n        return disc;\\n    }   \\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int disc = 0;\\n        sort(candyType.begin(),candyType.end());\\n        for(int i = 0;i < candyType.size();i++){\\n            while(i < candyType.size() - 1 && candyType[i] == candyType[i+1])\\n                i++;\\n            disc++;\\n        }\\n        int res = candyType.size()/2;\\n        if(disc > res)\\n            return res;\\n        return disc;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088032,
                "title": "js-one-liner-easy-understanding-solution",
                "content": "```\\nvar distributeCandies = function(candyType) {\\n    return Math.min(candyType.length / 2, new Set(candyType).size);\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function(candyType) {\\n    return Math.min(candyType.length / 2, new Set(candyType).size);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1088016,
                "title": "python-one-liner-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType) //2, len(set(candyType)))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType) //2, len(set(candyType)))",
                "codeTag": "Java"
            },
            {
                "id": 1087927,
                "title": "python-3-easy-fast-no-set-o-n",
                "content": "- To eat the maximum number of different types, Alice needs to eat the minimum number of every type. In other words she eats all types (by one candy) or a half of total number of candies.  \\n- Use set to control uniqueness. Set syntax `{*...}` is faster than set function `set(...)`.\\n- Time complexity is `O(n)`. Space complexity is `O(n)`.\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType) >> 1, len({*candyType}))\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType) >> 1, len({*candyType}))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087867,
                "title": "distribute-candies-c-using-set",
                "content": "1. Find unique candies by using a set\\n2. Return min of (unique candies(size of set) and half the no of candies)\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        set<int> st;\\n        for (auto candie: candies)\\n            st.insert(candie);\\n        return min(st.size(), candies.size()/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        set<int> st;\\n        for (auto candie: candies)\\n            st.insert(candie);\\n        return min(st.size(), candies.size()/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087866,
                "title": "distribute-candies-c-o-n-1-liner-easy-explained",
                "content": "The solution and observations upon which it is based is mentioned below: \\n* The answer to the question can be atmost `candyType.size() / 2` since Alice can\\'t eat more than half of the total candies.\\n* We start by choosing different types of *candyType*. A chosen candyType will be inserted into a hashset so that we won\\'t select the same one again. \\n* The above step will be done iteratively till we either **reach the end of array** or number of chosen different candyType denoted by **`ans` becomes `candyType.size() / 2`**, since it can\\'t be anymore than that.\\n\\nNote: The above loop might end even with only 1 candyType selected which may be less than the maximum `n/2` candy amount allowed to be selected. But we are only concerned with selecting **maximum different candyTypes**  and not maximum candies. \\n\\n```\\nint distributeCandies(vector<int>& candyType) {\\n    int ans = 0, n = candyType.size(), i = 0;\\n    unordered_set<int>s;\\n        \\n    while(i < n && ans < (n / 2)){\\n        if(s.find(candyType[i]) == s.end())\\n            s.insert(candyType[i]), ans++;\\n        i++;\\n    }\\n    return ans;\\n}\\n```\\n\\n**Time Complexity**: **`O(N)`**, for iterating once through `candyType` at max. Insertion into hashset has amortized time-complexity of `O(1)`.\\n\\n**Space Complexity**: **`O(N)`**, for maintaining the hashset.\\n\\n--------------------\\nNow for those who came for 1-liners, the above solution can be compacted into a 1-liner as below (referred from [@votrubac\\'s post](https://leetcode.com/problems/distribute-candies/discuss/102946/C%2B%2B-1-liner)) - \\n```\\nint distributeCandies(vector<int>& candyType) {\\n    return min(size(unordered_set<int>(begin(candyType), end(candyType))), size(candyType) / 2);\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint distributeCandies(vector<int>& candyType) {\\n    int ans = 0, n = candyType.size(), i = 0;\\n    unordered_set<int>s;\\n        \\n    while(i < n && ans < (n / 2)){\\n        if(s.find(candyType[i]) == s.end())\\n            s.insert(candyType[i]), ans++;\\n        i++;\\n    }\\n    return ans;\\n}\\n```\n```\\nint distributeCandies(vector<int>& candyType) {\\n    return min(size(unordered_set<int>(begin(candyType), end(candyType))), size(candyType) / 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1087764,
                "title": "python-c-paraphrase-for-easy-understanding",
                "content": "# Paraphrase\\n\"Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them\" can be  Paraphrased to \\n\"Find the maximum number of different elements, but not more than `n / 2`\".\\nFinding amount of unique elements is quite basic thing in programming, it can be done with `set`, and to be sure we do not exceed `n / 2` we add `min(..., n / 2)`.\\n\\n## Python code:\\n```\\nclass Solution:\\n  def distributeCandies(self, candyType: List[int]) -> int:\\n    return min(len(candyType) // 2, len(set(candyType)))\\n```\\n\\n## C++ code:\\n```\\nclass Solution {\\n  public:\\n    int distributeCandies(vector<int>& candyType) {\\n      return min(\\n        unordered_set(candyType.begin(), candyType.end()).size(), \\n        candyType.size() / 2\\n      );\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def distributeCandies(self, candyType: List[int]) -> int:\\n    return min(len(candyType) // 2, len(set(candyType)))\\n```\n```\\nclass Solution {\\n  public:\\n    int distributeCandies(vector<int>& candyType) {\\n      return min(\\n        unordered_set(candyType.begin(), candyType.end()).size(), \\n        candyType.size() / 2\\n      );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075089,
                "title": "javascript-runtime-124-ms-faster-than-95-40-memory-usage-51-9-mb-less-than-87-87",
                "content": "```\\n/**\\n * @param {number[]} candyType\\n * @return {number}\\n */\\nvar distributeCandies = function(candyType) {\\n    let set = new Set(candyType);\\n    let min = Math.min(candyType.length / 2, set.size);\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} candyType\\n * @return {number}\\n */\\nvar distributeCandies = function(candyType) {\\n    let set = new Set(candyType);\\n    let min = Math.min(candyType.length / 2, set.size);\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009724,
                "title": "1-line-python-solution",
                "content": "``` python\\nreturn min(len(set(candyType)), len(candyType) / 2)\\n```",
                "solutionTags": [],
                "code": "``` python\\nreturn min(len(set(candyType)), len(candyType) / 2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 996994,
                "title": "c-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        \\n        int n=candyType.size();\\n        unordered_set<int> set;\\n        \\n        for(int i=0; i<n; i++){\\n            set.insert(candyType[i]);\\n        }\\n        \\n        if(n/2 < set.size()){\\n            return n/2;\\n        }else{\\n            return set.size();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        \\n        int n=candyType.size();\\n        unordered_set<int> set;\\n        \\n        for(int i=0; i<n; i++){\\n            set.insert(candyType[i]);\\n        }\\n        \\n        if(n/2 < set.size()){\\n            return n/2;\\n        }else{\\n            return set.size();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745531,
                "title": "python-3-one-liner",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: List[int]) -> int:\\n        return min(len(set(candies)),len(candies)//2)",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: List[int]) -> int:\\n        return min(len(set(candies)),len(candies)//2)",
                "codeTag": "Java"
            },
            {
                "id": 460143,
                "title": "single-line-c",
                "content": "```csharp\\npublic int DistributeCandies(int[] candies) => Math.Min(candies.Distinct().Count(), candies.Count()/2);\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int DistributeCandies(int[] candies) => Math.Min(candies.Distinct().Count(), candies.Count()/2);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 393874,
                "title": "solution-in-python-3-one-line",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, C: List[int]) -> int:\\n    \\treturn min(len(C)//2,len(set(C)))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, C: List[int]) -> int:\\n    \\treturn min(len(C)//2,len(set(C)))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 383377,
                "title": "python3-easy-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: List[int]) -> int:\\n        unique = len(set(candies))\\n        half = len(candies) // 2\\n        \\n        return unique if unique < half else half\\n```\\nRuntime: 912 ms, faster than 98.86% of Python3 online submissions for Distribute Candies.\\nMemory Usage: 15.8 MB, less than 8.33% of Python3 online submissions for Distribute Candies.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: List[int]) -> int:\\n        unique = len(set(candies))\\n        half = len(candies) // 2\\n        \\n        return unique if unique < half else half\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359572,
                "title": "c-clean-code",
                "content": "```\\npublic int DistributeCandies_2(int[] candies)\\n    {\\n        HashSet<int> hs = new HashSet<int>(candies);\\n        return hs.Count < candies.Length / 2 ? hs.Count : candies.Length / 2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int DistributeCandies_2(int[] candies)\\n    {\\n        HashSet<int> hs = new HashSet<int>(candies);\\n        return hs.Count < candies.Length / 2 ? hs.Count : candies.Length / 2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 322207,
                "title": "javascript-solution-faster-than-99-74-of-javascript-submissions-with-comments",
                "content": "```javascript\\n/**\\n * @param {number[]} candies\\n * @return {number}\\n *\\n * We get the number of unique candies by creating a Set out of the candies array\\n * We then return either the equal share (which is 1/2 of the candies) or the number of unique candies,\\n *   whichever is smaller.\\n *\\n * If the equal share is smaller, we have to return that regardless of how many unique candies there are\\n *   because we can\\'t give more than the equal share\\n * If the number of unique candies is smaller, we have to return that regardless of what the equal share is\\n *   because we are only counting unique candies.\\n */\\nvar distributeCandies = function(candies) {\\n    const equalShare = candies.length / 2;\\n    const uniqueCandies = new Set(candies).size;\\n    \\n    return  equalShare > uniqueCandies ? uniqueCandies : equalShare\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[]} candies\\n * @return {number}\\n *\\n * We get the number of unique candies by creating a Set out of the candies array\\n * We then return either the equal share (which is 1/2 of the candies) or the number of unique candies,\\n *   whichever is smaller.\\n *\\n * If the equal share is smaller, we have to return that regardless of how many unique candies there are\\n *   because we can\\'t give more than the equal share\\n * If the number of unique candies is smaller, we have to return that regardless of what the equal share is\\n *   because we are only counting unique candies.\\n */\\nvar distributeCandies = function(candies) {\\n    const equalShare = candies.length / 2;\\n    const uniqueCandies = new Set(candies).size;\\n    \\n    return  equalShare > uniqueCandies ? uniqueCandies : equalShare\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 296071,
                "title": "very-simple-java-solution-using-set",
                "content": "```\\n\\tint numberOfCandies = candies.length;\\n\\tSet<Integer> typesOfCandies = new HashSet<>();\\n\\tfor(int candy : candies)\\n\\t{\\n\\t\\ttypesOfCandies.add(candy);\\n\\t}\\n\\t\\n\\tint type = typesOfCandies.size();\\n\\tint sisterHalf = numberOfCandies / 2;\\n\\t\\n\\treturn Math.min(type, sisterHalf);",
                "solutionTags": [],
                "code": "```\\n\\tint numberOfCandies = candies.length;\\n\\tSet<Integer> typesOfCandies = new HashSet<>();\\n\\tfor(int candy : candies)\\n\\t{\\n\\t\\ttypesOfCandies.add(candy);\\n\\t}\\n\\t\\n\\tint type = typesOfCandies.size();\\n\\tint sisterHalf = numberOfCandies / 2;\\n\\t\\n\\treturn Math.min(type, sisterHalf);",
                "codeTag": "Unknown"
            },
            {
                "id": 284725,
                "title": "java-hashset",
                "content": "```java\\nclass Solution {  \\n    // 1 1 2  | 3 4 5\\n    // 5 unique number\\n    // 6 number totol    \\n    // because 6/2 <= 5\\n    // sister gets 6 / 2 = 3 unique number\\n    \\n    // 1 1 1 | 1 1 2\\n    // 2 unique number\\n    // 6 number total\\n    // because 6/2 > 2\\n    // sister gets 2 unique number\\n    \\n    // 1 1\\n    // 1 unique\\n    // 2 number total\\n    // 2/2 <= 1\\n    // sister gets 1 unique number \\n\\n    public int distributeCandies(int[] candies) {\\n        Set<Integer> unique = new HashSet<>();\\n        for (int i : candies) unique.add(i);\\n        \\n        return Math.min(candies.length / 2, unique.size());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {  \\n    // 1 1 2  | 3 4 5\\n    // 5 unique number\\n    // 6 number totol    \\n    // because 6/2 <= 5\\n    // sister gets 6 / 2 = 3 unique number\\n    \\n    // 1 1 1 | 1 1 2\\n    // 2 unique number\\n    // 6 number total\\n    // because 6/2 > 2\\n    // sister gets 2 unique number\\n    \\n    // 1 1\\n    // 1 unique\\n    // 2 number total\\n    // 2/2 <= 1\\n    // sister gets 1 unique number \\n\\n    public int distributeCandies(int[] candies) {\\n        Set<Integer> unique = new HashSet<>();\\n        for (int i : candies) unique.add(i);\\n        \\n        return Math.min(candies.length / 2, unique.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226080,
                "title": "c-solution-in-2-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        unordered_set<int> s(candies.begin(), candies.end());\\n        return min(s.size(), candies.size() / 2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        unordered_set<int> s(candies.begin(), candies.end());\\n        return min(s.size(), candies.size() / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221529,
                "title": "rust-one-liner-36-ms",
                "content": "```\\nuse std::collections::HashSet;\\nuse std::cmp::min;\\n\\nimpl Solution {\\n    pub fn distribute_candies(candies: Vec<i32>) -> i32 {\\n        min(candies.iter().collect::<HashSet<_>>().len(), candies.len() / 2) as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\nuse std::cmp::min;\\n\\nimpl Solution {\\n    pub fn distribute_candies(candies: Vec<i32>) -> i32 {\\n        min(candies.iter().collect::<HashSet<_>>().len(), candies.len() / 2) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213854,
                "title": "javascript-1-line-solution-and-the-faster-one",
                "content": "**1 line solution (176ms)**\\n```\\nconst distributeCandies = candies => Math.min(candies.length / 2, new Set(candies).size)\\n```\\n\\n* Tips\\n\\t1. ES6 (Arrow function)\\n\\t2. Math(min)\\n\\t3. Set\\n\\n* Explanation\\n\\tFisrt, use **Set**\\'s feature to exclude repeat kind of candies.\\n\\tSecondly, since sister or brother could gets at most half of candies, if every candy is different kind, he/she at most have half number of total candies kinds. There are two situations:\\n\\t1. Number of kinds of candies are larger than **half** of total number of candies, he/she could get at most half of total number of candies kinds.\\n\\t2. On the contrary, he/she could get at most number of kinds of candis.\\n\\n\\tIn sum, this function should return minimum of total kinds of candies and half of total number of candies.\\n\\n\\tHowever, this solution isn\\'t fast enough because it should stop counting after kinds of candies are larger than half of total number of candies. The following is faster solution.\\n\\n**Faster solution (132 ms)**\\n```\\nvar distributeCandies = function(candies) {\\n    let half = candies.length / 2\\n    let set = new Set()\\n    for(let i = 0; i < candies.length; ++i) {\\n        set.add(candies[i])\\n        if(set.size >= half) return half\\n    }\\n    return set.size\\n};\\n```\\n\\n* Explanation\\n\\tIf set\\'s size has already larger than **half**, directly return **half**. At worst condition, it would save half of time. You may question why you don\\'t use `forEach` or `look up table`. `forEach` couldn\\'t stop in processing and `look up table` wastes lots of memory and doesn\\'t work better in effeciency.\\n\\t\\nFeel free to leave comments below and improve my code and idea. :)",
                "solutionTags": [],
                "code": "```\\nconst distributeCandies = candies => Math.min(candies.length / 2, new Set(candies).size)\\n```\n```\\nvar distributeCandies = function(candies) {\\n    let half = candies.length / 2\\n    let set = new Set()\\n    for(let i = 0; i < candies.length; ++i) {\\n        set.add(candies[i])\\n        if(set.size >= half) return half\\n    }\\n    return set.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179059,
                "title": "js-one-liner-o-n-time-and-space-complexity-with-explanation",
                "content": "Let\\'s imagine two types of situations.\\n1. Half or more of candies are from different kind. Which means we can give the sister at most half of the kinds. In this way, the maximum amount the sister would get LEN / 2 (the size is even)\\n2. Less than half of all the candies are different. In this situation the best (or the worst for the brother) is when the sister gets all these different kind of candies, and the brother gets the rest. In this case, the sister would get at most the amount of the unique candies.\\n\\n```const distributeCandies = c => Math.min(c.length / 2, new Set(c).size);```",
                "solutionTags": [],
                "code": "```const distributeCandies = c => Math.min(c.length / 2, new Set(c).size);```",
                "codeTag": "Unknown"
            },
            {
                "id": 140566,
                "title": "two-line-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        set<int> s(candies.begin(),candies.end()); \\n        return min((int) candies.size()/2,(int) s.size());\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        set<int> s(candies.begin(),candies.end()); \\n        return min((int) candies.size()/2,(int) s.size());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102895,
                "title": "c-o-n-pragmatic-approach-easy-to-understand-with-comments",
                "content": "Hey all\\n\\nI used a kinda common sense approach to solving this problem. I imagined that the brother and sister were real and dealt with it the way I would in real life; (revealing me to be a terribly unjust uncle).\\n\\nMy solution ended up being surprisingly efficient so I decided to share it.\\n\\n```\\npublic int DistributeCandies(int[] candies) {\\n        \\n        var uniqueCandies = new Dictionary<int, int>();\\n        // Count the number of TYPES of candies by adding each type to a list (using a hash).\\n        foreach (var candy in candies)\\n        {\\n            uniqueCandies[candy] = 1;\\n        }\\n        \\n        // Assume that the sister will get one of each TYPE of candy and that her brother gets the rest.\\n        // (This assumes she gets the maximum possible number of TYPES of candies.)\\n        int sistersCandies = uniqueCandies.Keys.Count;\\n        int brothersCandies = candies.Length - sistersCandies;\\n        \\n        // The only time she wouldn't get this maximum number of candies is if she has MORE candies than her brother.\\n        // In this case, she needs to share so that they have at least got the same number of candies.\\n        // In other words, she splits the difference with her brother.\\n        int diff = sistersCandies - brothersCandies;\\n        if (diff <= 0)\\n        {\\n            return sistersCandies;\\n        }\\n        // Split the difference:\\n        return sistersCandies - (diff / 2);\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int DistributeCandies(int[] candies) {\\n        \\n        var uniqueCandies = new Dictionary<int, int>();\\n        // Count the number of TYPES of candies by adding each type to a list (using a hash).\\n        foreach (var candy in candies)\\n        {\\n            uniqueCandies[candy] = 1;\\n        }\\n        \\n        // Assume that the sister will get one of each TYPE of candy and that her brother gets the rest.\\n        // (This assumes she gets the maximum possible number of TYPES of candies.)\\n        int sistersCandies = uniqueCandies.Keys.Count;\\n        int brothersCandies = candies.Length - sistersCandies;\\n        \\n        // The only time she wouldn't get this maximum number of candies is if she has MORE candies than her brother.\\n        // In this case, she needs to share so that they have at least got the same number of candies.\\n        // In other words, she splits the difference with her brother.\\n        int diff = sistersCandies - brothersCandies;\\n        if (diff <= 0)\\n        {\\n            return sistersCandies;\\n        }\\n        // Split the difference:\\n        return sistersCandies - (diff / 2);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102941,
                "title": "ruby-solution",
                "content": "```\\ndef distribute_candies(candies)\\n  [candies.uniq.size, candies.size / 2].min\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef distribute_candies(candies)\\n  [candies.uniq.size, candies.size / 2].min\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 102942,
                "title": "java-hashset-solution",
                "content": "    public int distributeCandies(int[] candies) {\\n        Set<Integer> set = new HashSet<>();\\n        for(Integer candie : candies) {\\n            set.add(candie);\\n            if(set.size() == candies.length/2) return set.size();\\n        }\\n        return Math.min(set.size(), candies.length/2);\\n    }",
                "solutionTags": [],
                "code": "    public int distributeCandies(int[] candies) {\\n        Set<Integer> set = new HashSet<>();\\n        for(Integer candie : candies) {\\n            set.add(candie);\\n            if(set.size() == candies.length/2) return set.size();\\n        }\\n        return Math.min(set.size(), candies.length/2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3934894,
                "title": "beats-95-at-time-and-space",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& c) {\\n        sort(c.begin(),c.end());\\n        int diff=1;\\n        for(int i=1;i<c.size();i++){\\n            if(diff==c.size()/2)    return diff;\\n            if(c[i]>c[i-1]) diff++;\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& c) {\\n        sort(c.begin(),c.end());\\n        int diff=1;\\n        for(int i=1;i<c.size();i++){\\n            if(diff==c.size()/2)    return diff;\\n            if(c[i]>c[i-1]) diff++;\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920516,
                "title": "easy-approach-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> set = new HashSet();\\n        for(int i:candyType) set.add(i);\\n        if(set.size()>(candyType.length/2))\\n        return candyType.length/2;\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> set = new HashSet();\\n        for(int i:candyType) set.add(i);\\n        if(set.size()>(candyType.length/2))\\n        return candyType.length/2;\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591406,
                "title": "c-easy-approach-using-set-t-c-o-n",
                "content": "**INTUTION :-\\n can_eat finds the how many candies alice can eat\\n  using set we can find unique candies alice have \\n  \\n  if set_size==can_eat ( i.e. if number of candies alice can eat is equals to unique candies alice has)\\n  return set_size or can_eat\\n  \\n  else if can_eat>set_size (i.e. if the number of candies alice can eat is greater than unique candies alice has)\\n  return set_size\\n  \\n  else can_eat<set_size (i.e. if the number of candies alice can eat is less than unique candies she has)\\n  return can_eat\\n  ***\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int size=candyType.size();\\n        int can_eat=size/2;\\n        \\n        set<int>s;\\n        for(int i=0;i<size;i++){\\n            s.insert(candyType[i]);\\n        }\\n        \\n        int set_size=s.size();\\n        \\n        if(can_eat==set_size)\\n            return set_size;\\n        \\n        else if(can_eat>set_size)\\n            return set_size;\\n             \\n        return can_eat;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/1090f69e-1af1-47d9-a8f3-683aef3213de_1685765006.3005984.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int size=candyType.size();\\n        int can_eat=size/2;\\n        \\n        set<int>s;\\n        for(int i=0;i<size;i++){\\n            s.insert(candyType[i]);\\n        }\\n        \\n        int set_size=s.size();\\n        \\n        if(can_eat==set_size)\\n            return set_size;\\n        \\n        else if(can_eat>set_size)\\n            return set_size;\\n             \\n        return can_eat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355551,
                "title": "distribute-candies-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m), where m<=n, n = size of input vector\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int i;\\n        unordered_set<int> unique_candies;\\n        for(i=0 ; i<candyType.size() ; i++)\\n        {\\n            unique_candies.insert(candyType[i]);\\n        }\\n        if((unique_candies.size())<=(candyType.size()/2))\\n            return unique_candies.size();\\n        return candyType.size()/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int i;\\n        unordered_set<int> unique_candies;\\n        for(i=0 ; i<candyType.size() ; i++)\\n        {\\n            unique_candies.insert(candyType[i]);\\n        }\\n        if((unique_candies.size())<=(candyType.size()/2))\\n            return unique_candies.size();\\n        return candyType.size()/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232429,
                "title": "php-solution-easy",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $candyType\\n     * @return Integer\\n     */\\n    function distributeCandies($candyType) {\\n        $getCandy = count($candyType) / 2;\\n        $uniqueCandyType = array_unique($candyType);\\n        return $getCandy <= count($uniqueCandyType) ? $getCandy : count($uniqueCandyType);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $candyType\\n     * @return Integer\\n     */\\n    function distributeCandies($candyType) {\\n        $getCandy = count($candyType) / 2;\\n        $uniqueCandyType = array_unique($candyType);\\n        return $getCandy <= count($uniqueCandyType) ? $getCandy : count($uniqueCandyType);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226429,
                "title": "brute-force-approach-o-nlogn-c",
                "content": "# Intuition\\nTo use sets to take into the number fo distinct chocolates available and then find out the number of chocolates she can eat.\\n\\n# Approach\\n1. Insert all the distinct elements from the vector given as input into a set.\\n2. The solution is minimum of **n/2 : maximum number chocolates she can have** and **the size of the sets s which indicates the maximum number of distinct chocolates she has.**\\n\\n# Complexity\\n- Time complexity: **O(nlogn)**\\n\\n\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        set <int> s;\\n        int n = candyType.size();\\n        for(int i = 0;i < n;i++) s.insert(candyType[i]);\\n        int a=n/2, b=s.size();\\n        int x = min(a,b);\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        set <int> s;\\n        int n = candyType.size();\\n        for(int i = 0;i < n;i++) s.insert(candyType[i]);\\n        int a=n/2, b=s.size();\\n        int x = min(a,b);\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3164805,
                "title": "3-line-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> set = new HashSet();\\n        for (int i : candyType) set.add(i);\\n        return Math.min(set.size(), candyType.length / 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> set = new HashSet();\\n        for (int i : candyType) set.add(i);\\n        return Math.min(set.size(), candyType.length / 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163187,
                "title": "simple-explained-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        int types_num = set<int>(candies.begin(), candies.end()).size();\\n        return types_num > candies.size()/2 ? candies.size()/2 : types_num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ruby",
                    "Bash",
                    "Swift",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candies) {\\n        int types_num = set<int>(candies.begin(), candies.end()).size();\\n        return types_num > candies.size()/2 ? candies.size()/2 : types_num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060415,
                "title": "python-python3-esay-soultion-to-understand",
                "content": "# Approach\\nMy approach was to loop over the candys, each candy I see I will add to the result counter and save it in a hashset. If we see a candy that already was seen then we skip it, else we add it. we do it until we reached n/2 candys or we got to the end of the list.\\n\\n# Complexity\\n- Time complexity:\\nO(n) becuase we went over the array once\\n\\n- Space complexity:\\nO(n) becuase we saved at most n/2 numbers.\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        seen = {}\\n        i = 0\\n        amount_allowed = 0\\n        while(i<len(candyType) and amount_allowed<len(candyType)//2):\\n            if seen.get(candyType[i],0)==0:\\n                amount_allowed+=1\\n                seen[candyType[i]] = 1\\n            i+=1\\n        return amount_allowed\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        seen = {}\\n        i = 0\\n        amount_allowed = 0\\n        while(i<len(candyType) and amount_allowed<len(candyType)//2):\\n            if seen.get(candyType[i],0)==0:\\n                amount_allowed+=1\\n                seen[candyType[i]] = 1\\n            i+=1\\n        return amount_allowed\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995808,
                "title": "beats-80-beginner-friendly-o-n-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n\\n    Set<Integer>st=new HashSet<>();\\n\\n    for(int i=0;i<candyType.length;i++){\\n        st.add(candyType[i]);\\n        if(st.size()>candyType.length/2)return candyType.length/2;\\n    }\\n\\n    return st.size();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n\\n    Set<Integer>st=new HashSet<>();\\n\\n    for(int i=0;i<candyType.length;i++){\\n        st.add(candyType[i]);\\n        if(st.size()>candyType.length/2)return candyType.length/2;\\n    }\\n\\n    return st.size();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973108,
                "title": "javasscript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} candyType\\n * @return {number}\\n */\\nvar distributeCandies = function(candyType) {\\n    const half = Math.floor(candyType.length/2)\\n    const numberTypes = Array.from(new Set(candyType))\\n    if(numberTypes.length > half) {\\n        return half\\n    } else {\\n        return numberTypes.length\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} candyType\\n * @return {number}\\n */\\nvar distributeCandies = function(candyType) {\\n    const half = Math.floor(candyType.length/2)\\n    const numberTypes = Array.from(new Set(candyType))\\n    if(numberTypes.length > half) {\\n        return half\\n    } else {\\n        return numberTypes.length\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2938181,
                "title": "just-one-line-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType)//2, len(set(candyType)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType)//2, len(set(candyType)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872762,
                "title": "java-solution-using-hashset-o-n",
                "content": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> typeCandySet = new HashSet<>();\\n        int halfLength = candyType.length/2;\\n\\n        for (int c : candyType) {\\n            if (typeCandySet.size() >= halfLength)\\n                return halfLength;\\n            typeCandySet.add(c);\\n        }\\n        return Math.min(typeCandySet.size(), halfLength);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> typeCandySet = new HashSet<>();\\n        int halfLength = candyType.length/2;\\n\\n        for (int c : candyType) {\\n            if (typeCandySet.size() >= halfLength)\\n                return halfLength;\\n            typeCandySet.add(c);\\n        }\\n        return Math.min(typeCandySet.size(), halfLength);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854708,
                "title": "java-hashset-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\t\\n        Set<Integer> set = new HashSet<>();\\n        for (int c : candyType) set.add(c);\\n\\t\\t\\n        return Math.min(set.size(), candyType.length / 2);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\t\\n        Set<Integer> set = new HashSet<>();\\n        for (int c : candyType) set.add(c);\\n\\t\\t\\n        return Math.min(set.size(), candyType.length / 2);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784059,
                "title": "java-3-lines-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int type : candyType) set.add(type);\\n        return Math.min(candyType.length / 2, set.size());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int type : candyType) set.add(type);\\n        return Math.min(candyType.length / 2, set.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708824,
                "title": "java-simple-solution",
                "content": "**//Dev Bhayani**\\n\\nclass Solution {\\n    public int distributeCandies(int[] a) {\\n        ArrayList<Integer>l1=new ArrayList<>();\\n        Arrays.sort(a);\\n        for(int i=0;i<a.length-1;i++)\\n        {\\n            if(a[i]!=a[i+1])\\n            {\\n                l1.add(a[i]);\\n            }\\n        }\\n        \\n            l1.add(a[a.length-1]);\\n        \\n        // for(int i=0;i<l1.size();i++)\\n        // {\\n        //     System.out.println(l1.get(i));\\n        // }\\n        if(l1.size()>=a.length/2)\\n        {\\n            return a.length/2;\\n        }\\n        else\\n        {\\n            return l1.size();\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int distributeCandies(int[] a) {\\n        ArrayList<Integer>l1=new ArrayList<>();\\n        Arrays.sort(a);\\n        for(int i=0;i<a.length-1;i++)\\n        {\\n            if(a[i]!=a[i+1])\\n            {\\n                l1.add(a[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2611130,
                "title": "python-oneliner-easy-solution-using-sets",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(list(set(candyType))),int(len(candyType)/2))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(list(set(candyType))),int(len(candyType)/2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506784,
                "title": "100-3-type-solutions-2-arr-and-1-hashmap-all-are-easy-fast-solutions",
                "content": "```\\nPLEASE UPVOTE IF YOU LIIKE\\n```\\n```\\n        boolean[] b = new boolean[200001];\\n        int count = 0;\\n        for(int i : ct){\\n            int temp = i + 100000;\\n            if (!b[temp]){\\n                if (++count == ct.length / 2) return count;\\n                b[temp] = true;\\n            }\\n        }\\n        return count;\\n        \\n        \\n//         Map<Integer, Integer> map = new HashMap<>();\\n//         for(int i: ct) map.put(i, 1);\\n\\n//         int count = 0;\\n//         int temp = ct.length / 2;\\n\\n//         for(int i: map.keySet()){\\n//             if (temp-- == 0) break;\\n//             count++;\\n//         }\\n//         return count;\\n        \\n        \\n//         Arrays.sort(ct);\\n//         int len = ct.length;\\n//         int count = 0;\\n//         int temp = len / 2;\\n//         for (int i = 0; i < len && temp > 0; i++) {\\n//             while (i < len - 1 && ct[i] == ct[i+1]){\\n//                 i++;\\n//             }\\n//             count++;\\n//             temp--;\\n//         }\\n\\n//         return count;\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2501297,
                "title": "java-o-n-hashset-approach",
                "content": "Please Upvote if Helpful\\n\\n***\\n\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        \\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int i = 0;i < candyType.length;i++) {\\n            set.add(candyType[i]);\\n        }\\n        \\n        return Math.min(set.size(), candyType.length / 2);\\n    }\\n}\\n\\n***",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int distributeCandies(int[] candyType) {\\n        \\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int i = 0;i < candyType.length;i++) {\\n            set.add(candyType[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2477526,
                "title": "javascript-simple-solution-with-hashmap",
                "content": "```\\nvar distributeCandies = function(candyType) {\\n    const hashmap = {};\\n    let output = 0;\\n\\n    for (let i = 0; i < candyType.length; i++) {\\n        if (!hashmap[candyType[i]]) output++;\\n        hashmap[candyType[i]] = i + 1;\\n        if (output === Math.floor(candyType.length/2)) return output;\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function(candyType) {\\n    const hashmap = {};\\n    let output = 0;\\n\\n    for (let i = 0; i < candyType.length; i++) {\\n        if (!hashmap[candyType[i]]) output++;\\n        hashmap[candyType[i]] = i + 1;\\n        if (output === Math.floor(candyType.length/2)) return output;\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2473517,
                "title": "python-o-n-tc-o-n-sc",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef distributeCandies(self, candyType: List[int]) -> int:\\n\\t\\t\\tnew = set(candyType)\\n\\t\\t\\tnew_length = len(new)\\n\\t\\t\\tlength = len(candyType)\\n\\n\\t\\t\\treturn min(length // 2, new_length)\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef distributeCandies(self, candyType: List[int]) -> int:\\n\\t\\t\\tnew = set(candyType)\\n\\t\\t\\tnew_length = len(new)\\n\\t\\t\\tlength = len(candyType)\\n\\n\\t\\t\\treturn min(length // 2, new_length)\\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2389236,
                "title": "c-simple-beats-99-with-explanation",
                "content": "* Took a simplified approach after trying the problem with use of sets.\\n* Here we simlpy sort the array and traverse through it in search of different types of candies\\n* If the number is less than n/2 we return the number as it is OR else we return n/2 for bigger or equal values.The idea is that if there are more than n/2 different types of candies we return n/2 as she can only eat n/2 candies.\\n\\n\\n\\n\\n  ```\\n  int distributeCandies(vector<int>& candyType) {\\n    int n =candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        int unique=1;\\n        int curr=candyType[0];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(candyType[i]!=curr)\\n            {\\n                curr=candyType[i];\\n                unique++;\\n            }\\n        }\\n        \\n        if(unique<n/2)\\n        {\\n            return unique;\\n        }\\n        else \\n            return n/2;\\n            \\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n  int distributeCandies(vector<int>& candyType) {\\n    int n =candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        int unique=1;\\n        int curr=candyType[0];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(candyType[i]!=curr)\\n            {\\n                curr=candyType[i];\\n                unique++;\\n            }\\n        }\\n        \\n        if(unique<n/2)\\n        {\\n            return unique;\\n        }\\n        else \\n            return n/2;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2360470,
                "title": "java-fastest-without-set-and-hashmap-very-easy",
                "content": "```\\n    public int distributeCandies(int[] candyType) {\\n        Arrays.sort(candyType);\\n        int type = candyType[0];\\n        int count = 1;\\n        for(int i:candyType){\\n            if(i!=type){\\n                count++;\\n                type=i;\\n            }\\n        }\\n        if(count<candyType.length/2) return count;\\n        else return candyType.length/2;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n    public int distributeCandies(int[] candyType) {\\n        Arrays.sort(candyType);\\n        int type = candyType[0];\\n        int count = 1;\\n        for(int i:candyType){\\n            if(i!=type){\\n                count++;\\n                type=i;\\n            }\\n        }\\n        if(count<candyType.length/2) return count;\\n        else return candyType.length/2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2360346,
                "title": "java-hashset-solution-4-lines-of-code",
                "content": "\\tclass Solution {\\n\\t\\tpublic int distributeCandies(int[] candyType) {\\n\\t\\t\\tint n = candyType.length;\\n\\t\\t\\tSet<Integer> set = new HashSet<>();\\n\\t\\t\\tfor(int i:candyType) set.add(i);\\n\\t\\t\\treturn Math.min(n/2,set.size());\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int distributeCandies(int[] candyType) {\\n\\t\\t\\tint n = candyType.length;\\n\\t\\t\\tSet<Integer> set = new HashSet<>();\\n\\t\\t\\tfor(int i:candyType) set.add(i);\\n\\t\\t\\treturn Math.min(n/2,set.size());\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2352225,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        int n2=candyType.length/2;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<candyType.length;i++){\\n            map.put(candyType[i],map.getOrDefault(candyType[i],0)+1);       \\n        }\\n        int size=map.size();\\n        int cont=0;\\n        System.out.println(map);\\n        if(size>n2)return n2;\\n       \\n        \\n        return size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        int n2=candyType.length/2;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<candyType.length;i++){\\n            map.put(candyType[i],map.getOrDefault(candyType[i],0)+1);       \\n        }\\n        int size=map.size();\\n        int cont=0;\\n        System.out.println(map);\\n        if(size>n2)return n2;\\n       \\n        \\n        return size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253810,
                "title": "c-2-easy-solutions",
                "content": "- Sol1.  Sorting candy types;\\nTime complexity: O(nlogn), \\nSpace: O(1);\\n```\\nclass Solution {\\npublic:\\n    \\n    //Sol1. using sort then O(nlogn), O(1) space\\n    int distributeCandies(vector<int>& candyType) {\\n\\n        sort(candyType.begin(), candyType.end());\\n        int type = 1;\\n        int n = candyType.size();\\n        for(int i = 1;i<n;i++){\\n            if(type >= n/2)  break;\\n            if(candyType[i] != candyType[i-1]) \\n                type++;\\n        }\\n        return type;\\n        \\n    }  \\n```\\n- Sol2. Using hashmap;\\nTime complexity: O(n);\\nSpace O(n);\\n```\\n    //Sol2. using map: time O(n), space O(n)\\n    int distributeCandies(vector<int>& candyType) {\\n        //set type = 0 first;\\n        unordered_map<int,int> mm;\\n        int type = 0;\\n        int n = candyType.size();\\n        for(int candy: candyType){\\n            mm[candy]++;\\n            if(mm[candy]==1) \\n                type++;\\n            if(type>=n/2) \\n                break;\\n        }\\n        return type;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //Sol1. using sort then O(nlogn), O(1) space\\n    int distributeCandies(vector<int>& candyType) {\\n\\n        sort(candyType.begin(), candyType.end());\\n        int type = 1;\\n        int n = candyType.size();\\n        for(int i = 1;i<n;i++){\\n            if(type >= n/2)  break;\\n            if(candyType[i] != candyType[i-1]) \\n                type++;\\n        }\\n        return type;\\n        \\n    }  \\n```\n```\\n    //Sol2. using map: time O(n), space O(n)\\n    int distributeCandies(vector<int>& candyType) {\\n        //set type = 0 first;\\n        unordered_map<int,int> mm;\\n        int type = 0;\\n        int n = candyType.size();\\n        for(int candy: candyType){\\n            mm[candy]++;\\n            if(mm[candy]==1) \\n                type++;\\n            if(type>=n/2) \\n                break;\\n        }\\n        return type;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215578,
                "title": "javascript-optimised-solution-with-set",
                "content": "```\\nvar distributeCandies = function(candyType) {\\n    let set = new Set();\\n    for(let candy of candyType) {\\n        if(!set.has(candy)) {\\n            set.add(candy);            \\n        }\\n        if(set.size == candyType.length/2) return set.size;\\n    }\\n    return set.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function(candyType) {\\n    let set = new Set();\\n    for(let candy of candyType) {\\n        if(!set.has(candy)) {\\n            set.add(candy);            \\n        }\\n        if(set.size == candyType.length/2) return set.size;\\n    }\\n    return set.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192174,
                "title": "c-simple-solution-hashset",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int canEat = candyType.size()/2;\\n        set<int> set;\\n        for(int i=0;i<candyType.size();i++) set.insert(candyType[i]);\\n        if(canEat <= set.size())    return canEat;\\n        return set.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int canEat = candyType.size()/2;\\n        set<int> set;\\n        for(int i=0;i<candyType.size();i++) set.insert(candyType[i]);\\n        if(canEat <= set.size())    return canEat;\\n        return set.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183167,
                "title": "simple-c-program-without-hash-without-unordered-set",
                "content": "class Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        sort(candyType.begin(),candyType.end());\\n        int n = candyType.size();\\n        int j = n/2;\\n        vector<int>t;\\n        int m=candyType[0];\\n        t.push_back(m);\\n        for(int i=0 ; i<n;i++){\\n            if(candyType[i]!= m){\\n                t.push_back(m);\\n                m=candyType[i];\\n            }\\n        }\\n        int a=t.size();\\n        return min(a,j);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        sort(candyType.begin(),candyType.end());\\n        int n = candyType.size();\\n        int j = n/2;\\n        vector<int>t;\\n        int m=candyType[0];\\n        t.push_back(m);\\n        for(int i=0 ; i<n;i++){\\n            if(candyType[i]!= m){\\n                t.push_back(m);\\n                m=candyType[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2179549,
                "title": "distribute-candies",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n     int n=candyType.size();\\n        int ans=n/2;\\n        set<int>s;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(candyType[i]);\\n        }\\n        int ssize=s.size();\\n        if(ssize==ans)\\n        {\\n            return ans;\\n        }\\n        if(ssize==1)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return min(ans,ssize);\\n        }\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n     int n=candyType.size();\\n        int ans=n/2;\\n        set<int>s;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(candyType[i]);\\n        }\\n        int ssize=s.size();\\n        if(ssize==ans)\\n        {\\n            return ans;\\n        }\\n        if(ssize==1)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return min(ans,ssize);\\n        }\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178322,
                "title": "python-solution-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        n=len(candyType)\\n        l=set(candyType)\\n        if len(l)==n//2:\\n            return len(l)\\n        elif len(l)>n//2:\\n            return n//2\\n        else:\\n            return len(l)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        n=len(candyType)\\n        l=set(candyType)\\n        if len(l)==n//2:\\n            return len(l)\\n        elif len(l)>n//2:\\n            return n//2\\n        else:\\n            return len(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099469,
                "title": "python-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        candyMap = {}\\n        nums = 0\\n        \\n        for i in candyType:\\n            if i not in candyMap:\\n                nums += 1\\n                candyMap[i] = 1\\n                \\n        return len(candyType) // 2 if len(candyType) // 2 < nums else nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        candyMap = {}\\n        nums = 0\\n        \\n        for i in candyType:\\n            if i not in candyMap:\\n                nums += 1\\n                candyMap[i] = 1\\n                \\n        return len(candyType) // 2 if len(candyType) // 2 < nums else nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046247,
                "title": "easy-java-hash-set-solution",
                "content": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> types = new HashSet<>();\\n        for(int type : candyType){\\n            types.add(type);\\n        }\\n        return Math.min(types.size(), candyType.length/2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> types = new HashSet<>();\\n        for(int type : candyType){\\n            types.add(type);\\n        }\\n        return Math.min(types.size(), candyType.length/2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035012,
                "title": "85-fastest-simple-java-set-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n          Set<Integer>set=new HashSet<>();\\n        for(int type : candyType)set.add(type);\\n        return Math.min(candyType.length/2,set.size());\\n    }\\n}\\n```\\n\\n# Time : O(n) linear\\n# Space : O(n) linear\\n# \\n# Please Upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n          Set<Integer>set=new HashSet<>();\\n        for(int type : candyType)set.add(type);\\n        return Math.min(candyType.length/2,set.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996161,
                "title": "c-solution-using-unique",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int n=candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        candyType.erase(unique(candyType.begin(),candyType.end()),candyType.end());\\n        int x=candyType.size();\\n        if(x>= n/2)\\n            return n/2;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int n=candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        candyType.erase(unique(candyType.begin(),candyType.end()),candyType.end());\\n        int x=candyType.size();\\n        if(x>= n/2)\\n            return n/2;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937804,
                "title": "one-line-javascript-solution",
                "content": "```\\nvar distributeCandies = function(candyType) { \\n    return Math.min(new Set(candyType).size, candyType.length / 2)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar distributeCandies = function(candyType) { \\n    return Math.min(new Set(candyType).size, candyType.length / 2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914872,
                "title": "c-unordered-set-one-line-solution",
                "content": "```\\nint distributeCandies(vector<int>& ct) {\\n        return min(unordered_set(ct.begin(), ct.end()).size(), ct.size()/2);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint distributeCandies(vector<int>& ct) {\\n        return min(unordered_set(ct.begin(), ct.end()).size(), ct.size()/2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910821,
                "title": "python-solution-time-o-n-memory-o-n",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int: \\n        candySet = set(candyType)\\n        \\n        return min(len(candyType)//2, len(candySet))\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int: \\n        candySet = set(candyType)\\n        \\n        return min(len(candyType)//2, len(candySet))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775589,
                "title": "solution-with-hashset-java",
                "content": "class Solution {\\n   public int distributeCandies(int[] candyType) {\\n        int length = candyType.length;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int j : candyType) {\\n            set.add(j);\\n        }\\n        if (set.size() < length / 2) {\\n            return set.size();\\n        }\\n        return length/2;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n   public int distributeCandies(int[] candyType) {\\n        int length = candyType.length;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int j : candyType) {\\n            set.add(j);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1775078,
                "title": "simple-straight-forward-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int n=candyType.size()/2;\\n        set<int> s;\\n        for(int x:candyType){\\n            s.insert(x);\\n        }\\n        int sz=s.size();\\n        return min(n,sz);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int n=candyType.size()/2;\\n        set<int> s;\\n        for(int x:candyType){\\n            s.insert(x);\\n        }\\n        int sz=s.size();\\n        return min(n,sz);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772640,
                "title": "python-solution",
                "content": "# class Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        n = len(candyType)//2\\n        l = set(candyType)\\n        return n if len(l) >= n else len(l)",
                "solutionTags": [],
                "code": "# class Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        n = len(candyType)//2\\n        l = set(candyType)\\n        return n if len(l) >= n else len(l)",
                "codeTag": "Java"
            },
            {
                "id": 1642783,
                "title": "java-hashset",
                "content": "```\\n  public int distributeCandies(int[] candyType) {\\n\\t\\tint size = candyType.length / 2;\\n\\n        Set<Integer> upperLimit = new HashSet<>();\\n\\n        for (int i : candyType) {\\n            upperLimit.add(i);\\n        }\\n\\n        int actualSize = upperLimit.size();\\n\\n        return actualSize < size ? actualSize : size;\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\n  public int distributeCandies(int[] candyType) {\\n\\t\\tint size = candyType.length / 2;\\n\\n        Set<Integer> upperLimit = new HashSet<>();\\n\\n        for (int i : candyType) {\\n            upperLimit.add(i);\\n        }\\n\\n        int actualSize = upperLimit.size();\\n\\n        return actualSize < size ? actualSize : size;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1609781,
                "title": "c-simple-faster-than-98-82",
                "content": "![image](https://assets.leetcode.com/users/images/e0e949af-32ab-4867-acea-c902ad28aaca_1638543749.290484.png)\\n\\n```\\npublic class Solution {\\n    public int DistributeCandies(int[] candyType) {\\n        \\n        \\n        //  Hashset to get rid of duplicates\\n               \\n        var obj = new HashSet<int>(candyType);\\n        \\n        //  If Checks\\n        \\n        if (obj.Count == 1) return obj.Count; \\n        \\n        if (candyType.Length % 2 == 0 && candyType.Length/2 <= obj.Count)\\n            return candyType.Length/2;\\n        \\n        return obj.Count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int DistributeCandies(int[] candyType) {\\n        \\n        \\n        //  Hashset to get rid of duplicates\\n               \\n        var obj = new HashSet<int>(candyType);\\n        \\n        //  If Checks\\n        \\n        if (obj.Count == 1) return obj.Count; \\n        \\n        if (candyType.Length % 2 == 0 && candyType.Length/2 <= obj.Count)\\n            return candyType.Length/2;\\n        \\n        return obj.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595570,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& c) {\\n        set<int> s;\\n        int n = c.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            s.insert(c[i]);\\n        }\\n        int ans = s.size();\\n        ans = min(ans,n / 2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& c) {\\n        set<int> s;\\n        int n = c.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            s.insert(c[i]);\\n        }\\n        int ans = s.size();\\n        ans = min(ans,n / 2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572226,
                "title": "java-hashmap-easy-solution",
                "content": "```\\nclass Solution {\\n    \\n    public static int distributeCandies(int[] candyType) {\\n\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int candies = candyType.length/2;\\n\\n        for (int i=0; i<candyType.length; i++){\\n\\n            if(!map.containsKey(candyType[i])){\\n                map.put(candyType[i],1);\\n            } else {\\n                map.put(candyType[i],map.get(candyType[i])+1);\\n            }\\n        }\\n        return Math.min(candies, map.size());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static int distributeCandies(int[] candyType) {\\n\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int candies = candyType.length/2;\\n\\n        for (int i=0; i<candyType.length; i++){\\n\\n            if(!map.containsKey(candyType[i])){\\n                map.put(candyType[i],1);\\n            } else {\\n                map.put(candyType[i],map.get(candyType[i])+1);\\n            }\\n        }\\n        return Math.min(candies, map.size());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564866,
                "title": "easy-java-solution-using-set",
                "content": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        int n=candyType.length/2;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<candyType.length;i++)\\n        {\\n          set.add(candyType[i]);    \\n        }\\n        return Math.min(set.size(),n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        int n=candyType.length/2;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<candyType.length;i++)\\n        {\\n          set.add(candyType[i]);    \\n        }\\n        return Math.min(set.size(),n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545615,
                "title": "c-easy-method",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        unordered_map<int,int> mymap;\\n        int eatable=candyType.size()/2;\\n        for (int i=0;i<candyType.size();i++){\\n            mymap[candyType[i]]++;\\n        }\\n        if (mymap.size()==eatable){return eatable;}\\n        else if (mymap.size()<eatable){return mymap.size();}\\n        else{return eatable;}\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        unordered_map<int,int> mymap;\\n        int eatable=candyType.size()/2;\\n        for (int i=0;i<candyType.size();i++){\\n            mymap[candyType[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1512258,
                "title": "c-o-n-time-very-easy-solution-using-set",
                "content": "class Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        set<int> v;\\n        for(int i=0;i<candyType.size();i++)\\n        {\\n            v.insert(candyType[i]);\\n        }\\n        int k=candyType.size()/2;\\n        if(v.size()==1)\\n            return 1;\\n        else if(v.size()==k)\\n            return k;\\n        else if(v.size()>k)\\n            return k;\\n        else\\n            return v.size();\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        set<int> v;\\n        for(int i=0;i<candyType.size();i++)\\n        {\\n            v.insert(candyType[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1489411,
                "title": "javascript-js-1-liner-98-faster-solution",
                "content": "```\\nvar distributeCandies = function(candyType) {\\n    return Math.min(candyType.length/2, new Set(candyType).size)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function(candyType) {\\n    return Math.min(candyType.length/2, new Set(candyType).size)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474223,
                "title": "python-easy-solution-75-faster-using-counter",
                "content": "**One Liner Solution using return - Slow method**\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType) // 2, len(Counter(candyType)))\\n```\\n\\n**Using Collections module - Faster method**\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        cnt = Counter(candyType)\\n        output = len(candyType)//2\\n        if len(cnt) >= output:\\n            return output\\n        else:\\n            return len(cnt)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType) // 2, len(Counter(candyType)))\\n```\n```\\nfrom collections import Counter\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        cnt = Counter(candyType)\\n        output = len(candyType)//2\\n        if len(cnt) >= output:\\n            return output\\n        else:\\n            return len(cnt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444006,
                "title": "simple-java-solution-o-n-time",
                "content": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer>hset=new HashSet<Integer>();\\n        for(int i:candyType)hset.add(i);\\n        return hset.size() > candyType.length/2 ? candyType.length/2 : hset.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        Set<Integer>hset=new HashSet<Integer>();\\n        for(int i:candyType)hset.add(i);\\n        return hset.size() > candyType.length/2 ? candyType.length/2 : hset.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437294,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} candyType\\n * @return {number}\\n */\\nvar distributeCandies = function (candyType) {\\n  return candyType.length / 2 > new Set(candyType).size\\n    ? new Set(candyType).size\\n    : candyType.length / 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} candyType\\n * @return {number}\\n */\\nvar distributeCandies = function (candyType) {\\n  return candyType.length / 2 > new Set(candyType).size\\n    ? new Set(candyType).size\\n    : candyType.length / 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400823,
                "title": "rust-28ms-using-hashset",
                "content": "```\\nimpl Solution {\\n    pub fn distribute_candies(candy_type: Vec<i32>) -> i32 {\\n            use std::collections::HashSet;\\n    use std::iter::FromIterator;\\n    let max_no_of_candies = candy_type.len() / 2;\\n    let unique_candies: HashSet<i32> = HashSet::from_iter(candy_type);\\n    if max_no_of_candies > unique_candies.len(){\\n        unique_candies.len() as i32\\n    } else {\\n        max_no_of_candies as i32\\n    }\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn distribute_candies(candy_type: Vec<i32>) -> i32 {\\n            use std::collections::HashSet;\\n    use std::iter::FromIterator;\\n    let max_no_of_candies = candy_type.len() / 2;\\n    let unique_candies: HashSet<i32> = HashSet::from_iter(candy_type);\\n    if max_no_of_candies > unique_candies.len(){\\n        unique_candies.len() as i32\\n    } else {\\n        max_no_of_candies as i32\\n    }\\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1316200,
                "title": "c-solution-98-48-faster",
                "content": "```\\nint l = candyType.size();\\nsort(candyType.begin(), candyType.end());\\ncandyType.erase(unique(candyType.begin(), candyType.end()), candyType.end());\\nint r = candyType.size();\\nif (l / 2 >= r)\\n    return r;\\nelse\\n    return l / 2;\\n```",
                "solutionTags": [],
                "code": "```\\nint l = candyType.size();\\nsort(candyType.begin(), candyType.end());\\ncandyType.erase(unique(candyType.begin(), candyType.end()), candyType.end());\\nint r = candyType.size();\\nif (l / 2 >= r)\\n    return r;\\nelse\\n    return l / 2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313951,
                "title": "rust-solution-with-set",
                "content": "```\\nimpl Solution {\\n    pub fn distribute_candies(candy_type: Vec<i32>) -> i32 {\\n        let set: std::collections::HashSet<_> = candy_type.iter().collect();\\n        let cl = candy_type.len() / 2;\\n        cl.min(set.len()) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distribute_candies(candy_type: Vec<i32>) -> i32 {\\n        let set: std::collections::HashSet<_> = candy_type.iter().collect();\\n        let cl = candy_type.len() / 2;\\n        cl.min(set.len()) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1281277,
                "title": "java-faster-than-96-84-simple-3-lines-solution-using-set",
                "content": "\\tpublic int distributeCandies(int[] candyType) {\\n\\t\\t\\tSet<Integer> set = new HashSet<Integer>(candyType.length);\\n\\t\\t\\tfor(int i:candyType) set.add(i);\\n\\t\\t\\treturn candyType.length/2>=set.size()?set.size():candyType.length/2;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int distributeCandies(int[] candyType) {\\n\\t\\t\\tSet<Integer> set = new HashSet<Integer>(candyType.length);\\n\\t\\t\\tfor(int i:candyType) set.add(i);\\n\\t\\t\\treturn candyType.length/2>=set.size()?set.size():candyType.length/2;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1243303,
                "title": "java-hashset-sol",
                "content": "```\\npublic int distributeCandies(int[] candyType) \\n    {\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        int cnt=(candyType.length/2);\\n        for (int candy: candyType) \\n        {\\n            hs.add(candy);\\n        }\\n        return Math.min(hs.size(),cnt);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int distributeCandies(int[] candyType) \\n    {\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        int cnt=(candyType.length/2);\\n        for (int candy: candyType) \\n        {\\n            hs.add(candy);\\n        }\\n        return Math.min(hs.size(),cnt);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1236358,
                "title": "easy-solution-with-explanation",
                "content": "### * if you like the solution please vote so it can reach maximum people\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        sl=len(list(set(candyType))) # count  of different candies.\\n        a=len(candyType)/2 # count of how many he can eat.\\n        if a>sl: # if count of how many he can it is greter than count of available candies we return available candies count\\n            return int(sl) \\n        return int(a) # else if count of available candies is greter than he can eat we return maximum no. that is a which he can eat\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        sl=len(list(set(candyType))) # count  of different candies.\\n        a=len(candyType)/2 # count of how many he can eat.\\n        if a>sl: # if count of how many he can it is greter than count of available candies we return available candies count\\n            return int(sl) \\n        return int(a) # else if count of available candies is greter than he can eat we return maximum no. that is a which he can eat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235318,
                "title": "c-1-liner-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        return min(unordered_set<int>(candyType.begin(),candyType.end()).size(), candyType.size()/2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        return min(unordered_set<int>(candyType.begin(),candyType.end()).size(), candyType.size()/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198593,
                "title": "problem-575-simple-c-solution-with-explanations",
                "content": "### Solution\\n\\nTo maximize the different types of candy Alice can eat, she should eat a different type for each of the n/2 pieces, if possible. If it\\'s not possible because there aren\\'t enough different types of candy to do that, she should eat one of each different type and then duplicates of whatever she wants.\\n\\nWe use a set to find the number of distinct candies. Then if there are at least n/2 distinct candies, Alice can eat n/2 distinct candies. Otherwise, she can eat as many distinct candies as there are distinct candies.\\n\\n```cpp\\nint distributeCandies(vector<int>& candyType) {\\n  unordered_set<int> unique_candies;\\n  for (int n : candyType) unique_candies.insert(n);\\n\\n  return min(unique_candies.size(), candyType.size() / 2);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nint distributeCandies(vector<int>& candyType) {\\n  unordered_set<int> unique_candies;\\n  for (int n : candyType) unique_candies.insert(n);\\n\\n  return min(unique_candies.size(), candyType.size() / 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1194862,
                "title": "100-faster-solution-one-liner",
                "content": "![image](https://assets.leetcode.com/users/images/3827c40f-4e3a-4938-b6b3-010e30b05fa6_1620326380.8694487.png)\\n\\n```\\npublic class Solution {\\n    public int DistributeCandies(int[] cType) {\\n        return Math.Min((new HashSet<int>(cType)).Count, cType.Length/2); \\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int DistributeCandies(int[] cType) {\\n        return Math.Min((new HashSet<int>(cType)).Count, cType.Length/2); \\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190745,
                "title": "python-solution-using-vairables-and-set",
                "content": "\\n```\\n\\n```class Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        s = set(candyType)\\n        ls = len(s)\\n        l = len(candyType)\\n        h = int(l//2)\\n        if ls>=h:\\n            return int(h)\\n        else:\\n            return int(ls)",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120058,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n            Set<Integer> uniqueCandies = new HashSet<>();\\n        for (int candy : candyType) {\\n            uniqueCandies.add(candy);\\n        }\\n\\n        int maximumCandiesToConsume = candyType.length / 2;\\n\\n        return uniqueCandies.size() < maximumCandiesToConsume ? uniqueCandies.size() : maximumCandiesToConsume;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n            Set<Integer> uniqueCandies = new HashSet<>();\\n        for (int candy : candyType) {\\n            uniqueCandies.add(candy);\\n        }\\n\\n        int maximumCandiesToConsume = candyType.length / 2;\\n\\n        return uniqueCandies.size() < maximumCandiesToConsume ? uniqueCandies.size() : maximumCandiesToConsume;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102144,
                "title": "python-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        if len(candyType) / 2 >= len(set(candyType)):\\n            return len(set(candyType))\\n        else:\\n            return int(len(candyType) / 2)\\n       \\n            ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        if len(candyType) / 2 >= len(set(candyType)):\\n            return len(set(candyType))\\n        else:\\n            return int(len(candyType) / 2)\\n       \\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 1091627,
                "title": "javascript-with-set-beats-100",
                "content": "```\\n/**\\n * @param {number[]} candyType\\n * @return {number}\\n */\\nfunction distributeCandies(candyType) {\\n    const types = new Set(candyType);\\n    const available = Math.floor(candyType.length / 2);\\n    \\n    return Math.min(types.size, available);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} candyType\\n * @return {number}\\n */\\nfunction distributeCandies(candyType) {\\n    const types = new Set(candyType);\\n    const available = Math.floor(candyType.length / 2);\\n    \\n    return Math.min(types.size, available);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089992,
                "title": "c-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        unordered_map <int,int> m;\\n        int n = candyType.size();\\n        \\n        for (int i:candyType) m[i]++;\\n        \\n        if (m.size() <= n/2)  return  m.size();\\n        return n/2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        unordered_map <int,int> m;\\n        int n = candyType.size();\\n        \\n        for (int i:candyType) m[i]++;\\n        \\n        if (m.size() <= n/2)  return  m.size();\\n        return n/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1755762,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1765555,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1827350,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 2002510,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1773157,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1575542,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1974842,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1819343,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1792290,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1790599,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1755762,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1765555,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1827350,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 2002510,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1773157,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1575542,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1974842,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1819343,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1792290,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            },
            {
                "id": 1790599,
                "content": [
                    {
                        "username": "Its_Hussain",
                        "content": "me after watching that this question has 1.2k likes and 1.2k dislikes.\\n\\n\"Perfectly balanced, as all things should be.\""
                    },
                    {
                        "username": "papitochi",
                        "content": "[@kd_5304](/kd_5304) same"
                    },
                    {
                        "username": "kd_5304",
                        "content": "That\\'s the first thing I noticed!"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Why so many dislikes? Sure it\\'s really simple, but nor offensive."
                    },
                    {
                        "username": "KershKersh",
                        "content": "*not"
                    },
                    {
                        "username": "karthikdileep003",
                        "content": "Leetcoders aggressively downvoting easy problems\\nAlso them when see a hard problem : \\n\"Oh no! its really hard!. I\\'m dumb\""
                    },
                    {
                        "username": "user5400vw",
                        "content": "the biggest challenge is interpreting the problem statement."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "maxy20113318",
                        "content": "![image](https://assets.leetcode.com/users/images/8d6eb71a-2c2c-4c2f-9d0a-88bb51f7c7d2_1626413798.1260612.png)\\n"
                    },
                    {
                        "username": "distDev",
                        "content": "Terrible description of the problem, I didn\\'t even understand what exactly to do. The number of dislikes confused me, I was looking for a trick in this problem, so the first solution turned out to be very long and complicated. I was surprised when my solution didn\\'t pass the tests.\\n\\nThen I decided to try the stupidest solution and it turned out to be the right one. The description is terrible, I can see why there are so many dislikes. The problem is simple, you can solve it in 1 line, but you don\\'t understand what you need to do here at all. Count the rest of candies? Stack candies of the same types? "
                    },
                    {
                        "username": "Mansisinghh",
                        "content": "Use HashSet \\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<candyType.length;i++){\\n            set.add(candyType[i]);\\n        }\\n        int candytoeat=candyType.length/2;\\n        if(set.size()>=candytoeat){\\n            return candytoeat;\\n        }\\n        return set.size();\\n    }\\n}"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 90 % in space and time complexiy both\\n\\n```\\nclass Solution {\\npublic:\\n    int distributeCandies(vector<int>& candyType) {\\n        int types=1;\\n        int current = candyType[0];\\n        int length = candyType.size();\\n        sort(candyType.begin(),candyType.end());\\n        if(length == 1) return 1;\\n        for(int i=1;i<length;i++){\\n            if(candyType[i-1] != candyType[i] ){\\n                candyType[i-1] = candyType[i];\\n                types++;\\n            }\\n        }\\n        return min(types,length/2);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "hello i m a new world in leetcode\\n\\n\\nclass Solution {\\n\\n     public:\\n    int distributeCandies(vector<int>candies)\\n    {\\n    int cnt =0;\\n\\n    unordered_map<int,int>m;\\n\\n    for(int i=0;i<candies.size();i++)\\n    {\\n        if(m.find(candies[i])== m.end()){\\n\\n            m.insert({candies[i],1});\\n            cnt++;\\n        }\\n        else\\n        { \\n            m[candies[i]]++;\\n        }\\n    }\\n\\n    int ans = cnt < candies.size()/2?cnt :candies.size()/2;\\n    return ans;\\n}\\n\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Implement Magic Dictionary",
        "question_content": "<p>Design a data structure that is initialized with a list of <strong>different</strong> words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure.</p>\n\n<p>Implement the&nbsp;<code>MagicDictionary</code>&nbsp;class:</p>\n\n<ul>\n\t<li><code>MagicDictionary()</code>&nbsp;Initializes the object.</li>\n\t<li><code>void buildDict(String[]&nbsp;dictionary)</code>&nbsp;Sets the data structure&nbsp;with an array of distinct strings <code>dictionary</code>.</li>\n\t<li><code>bool search(String searchWord)</code> Returns <code>true</code> if you can change <strong>exactly one character</strong> in <code>searchWord</code> to match any string in the data structure, otherwise returns <code>false</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]\n[[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]\n<strong>Output</strong>\n[null, null, false, true, false, false]\n\n<strong>Explanation</strong>\nMagicDictionary magicDictionary = new MagicDictionary();\nmagicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);\nmagicDictionary.search(&quot;hello&quot;); // return False\nmagicDictionary.search(&quot;hhllo&quot;); // We can change the second &#39;h&#39; to &#39;e&#39; to match &quot;hello&quot; so we return True\nmagicDictionary.search(&quot;hell&quot;); // return False\nmagicDictionary.search(&quot;leetcoded&quot;); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;dictionary.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;dictionary[i].length &lt;= 100</code></li>\n\t<li><code>dictionary[i]</code> consists of only lower-case English letters.</li>\n\t<li>All the strings in&nbsp;<code>dictionary</code>&nbsp;are <strong>distinct</strong>.</li>\n\t<li><code>1 &lt;=&nbsp;searchWord.length &lt;= 100</code></li>\n\t<li><code>searchWord</code>&nbsp;consists of only lower-case English letters.</li>\n\t<li><code>buildDict</code>&nbsp;will be called only once before <code>search</code>.</li>\n\t<li>At most <code>100</code> calls will be made to <code>search</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 107446,
                "title": "easy-14-lines-java-solution-hashmap",
                "content": "1. For each word in ```dict```, for each char, remove the char and put the rest of the word as key, a pair of index of the removed char and the char as ```part of``` value list into a map. e.g.\\n\"hello\" -> {\"ello\":[[0, 'h']], \"hllo\":[[1, 'e']], \"helo\":[[2, 'l'],[3, 'l']], \"hell\":[[4, 'o']]}\\n2. During search, generate the keys as in step 1. When we see there's pair of same index but different char in the value array, we know the answer is true. e.g.\\n\"healo\" when remove ```a```, key is \"helo\" and there is a pair [2, 'l'] which has same index but different char. Then the answer is true;\\n\\n```\\nclass MagicDictionary {\\n\\n    Map<String, List<int[]>> map = new HashMap<>();\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s : dict) {\\n            for (int i = 0; i < s.length(); i++) {\\n                String key = s.substring(0, i) + s.substring(i + 1);\\n                int[] pair = new int[] {i, s.charAt(i)};\\n                \\n                List<int[]> val = map.getOrDefault(key, new ArrayList<int[]>());\\n                val.add(pair);\\n                \\n                map.put(key, val);\\n            }\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        for (int i = 0; i < word.length(); i++) {\\n            String key = word.substring(0, i) + word.substring(i + 1);\\n            if (map.containsKey(key)) {\\n                for (int[] pair : map.get(key)) {\\n                    if (pair[0] == i && pair[1] != word.charAt(i)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```dict```\n```part of```\n```a```\n```\\nclass MagicDictionary {\\n\\n    Map<String, List<int[]>> map = new HashMap<>();\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s : dict) {\\n            for (int i = 0; i < s.length(); i++) {\\n                String key = s.substring(0, i) + s.substring(i + 1);\\n                int[] pair = new int[] {i, s.charAt(i)};\\n                \\n                List<int[]> val = map.getOrDefault(key, new ArrayList<int[]>());\\n                val.add(pair);\\n                \\n                map.put(key, val);\\n            }\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        for (int i = 0; i < word.length(); i++) {\\n            String key = word.substring(0, i) + word.substring(i + 1);\\n            if (map.containsKey(key)) {\\n                for (int[] pair : map.get(key)) {\\n                    if (pair[0] == i && pair[1] != word.charAt(i)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107454,
                "title": "python-without-26-factor-in-complexity",
                "content": "A word `'apple'` has neighbors `'*pple', 'a*ple', 'ap*le', 'app*e', 'appl*'`.  When searching for a target word like `'apply'`, we know that a necessary condition is a neighbor of `'apply'` is a neighbor of some source word in our magic dictionary.  If there is more than one source word that does this, then at least one of those source words will be different from the target word.  Otherwise, we need to check that the source doesn't equal the target.\\n\\n```python\\nclass MagicDictionary(object):\\n    def _candidates(self, word):\\n        for i in xrange(len(word)):\\n            yield word[:i] + '*' + word[i+1:]\\n            \\n    def buildDict(self, words):\\n        self.words = set(words)\\n        self.near = collections.Counter(cand for word in words\\n                                        for cand in self._candidates(word))\\n\\n    def search(self, word):\\n        return any(self.near[cand] > 1 or \\n                   self.near[cand] == 1 and word not in self.words\\n                   for cand in self._candidates(word))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass MagicDictionary(object):\\n    def _candidates(self, word):\\n        for i in xrange(len(word)):\\n            yield word[:i] + '*' + word[i+1:]\\n            \\n    def buildDict(self, words):\\n        self.words = set(words)\\n        self.near = collections.Counter(cand for word in words\\n                                        for cand in self._candidates(word))\\n\\n    def search(self, word):\\n        return any(self.near[cand] > 1 or \\n                   self.near[cand] == 1 and word not in self.words\\n                   for cand in self._candidates(word))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379194,
                "title": "c-easy-solution-using-trie",
                "content": "```\\nstruct T{\\n    bool end=false;\\n    T* c[26];\\n    T(){\\n        end=false;\\n        memset(c, NULL, sizeof(c));\\n    }\\n};\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    T* root;\\n    MagicDictionary() {\\n        root = new T();\\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        int n=dict.size();\\n        // build the trie\\n        for(int i=0;i<n;i++)\\n        {\\n            T* node=root;\\n            string word=dict[i];\\n            for(int j=0;j<word.size();j++)\\n            {\\n                if(!node->c[dict[i][j]-\\'a\\'])\\n                    node->c[dict[i][j]-\\'a\\']=new T();\\n                node=node->c[dict[i][j]-\\'a\\'];\\n            }\\n            node->end=true;\\n        }\\n    }\\n    \\n    bool helper(string word)\\n    {\\n        T* node=root;\\n        int n=word.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!node->c[word[i]-\\'a\\'])\\n                return false;\\n            node=node->c[word[i]-\\'a\\'];\\n        }\\n        return node->end;\\n    }\\n    \\n    bool search(string sword) {\\n        int n=sword.size();\\n        string word=sword;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(\\'a\\'+j==sword[i])\\n                    continue;\\n                word[i]=\\'a\\'+j;\\n                if(helper(word))\\n                    return true;\\n            }\\n            word[i]=sword[i];\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nPlease upvote if it helps you in any way :)",
                "solutionTags": [],
                "code": "```\\nstruct T{\\n    bool end=false;\\n    T* c[26];\\n    T(){\\n        end=false;\\n        memset(c, NULL, sizeof(c));\\n    }\\n};\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    T* root;\\n    MagicDictionary() {\\n        root = new T();\\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        int n=dict.size();\\n        // build the trie\\n        for(int i=0;i<n;i++)\\n        {\\n            T* node=root;\\n            string word=dict[i];\\n            for(int j=0;j<word.size();j++)\\n            {\\n                if(!node->c[dict[i][j]-\\'a\\'])\\n                    node->c[dict[i][j]-\\'a\\']=new T();\\n                node=node->c[dict[i][j]-\\'a\\'];\\n            }\\n            node->end=true;\\n        }\\n    }\\n    \\n    bool helper(string word)\\n    {\\n        T* node=root;\\n        int n=word.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!node->c[word[i]-\\'a\\'])\\n                return false;\\n            node=node->c[word[i]-\\'a\\'];\\n        }\\n        return node->end;\\n    }\\n    \\n    bool search(string sword) {\\n        int n=sword.size();\\n        string word=sword;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(\\'a\\'+j==sword[i])\\n                    continue;\\n                word[i]=\\'a\\'+j;\\n                if(helper(word))\\n                    return true;\\n            }\\n            word[i]=sword[i];\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107453,
                "title": "easiest-java-with-trie-no-need-to-count-the-number-of-changes",
                "content": "Below is my accepted java code.\\nFirst build a trie tree, and in search(String word) function, we just edit every character from 'a' to 'z' and search the new string. \\n (This process is like \"word ladder\")\\n\\n````\\nclass MagicDictionary {\\n    class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        boolean isWord;\\n        public TrieNode() {}\\n    }\\n    TrieNode root;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s : dict) {\\n            TrieNode node = root;\\n            for (char c : s.toCharArray()) {\\n                if (node.children[c - 'a'] == null) {\\n                    node.children[c - 'a'] = new TrieNode();\\n                }\\n                node = node.children[c - 'a'];\\n            }\\n            node.isWord = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        char[] arr = word.toCharArray();\\n        for (int i = 0; i < word.length(); i++) {\\n            for (char c = 'a'; c <= 'z'; c++) {\\n                if (arr[i] == c) {\\n                    continue;\\n                }\\n                char org = arr[i];\\n                arr[i] = c;\\n                if (helper(new String(arr), root)) {\\n                    return true;\\n                }\\n                arr[i] = org;\\n            }\\n        }\\n        return false;\\n    }\\n    public boolean helper(String s, TrieNode root) {\\n        TrieNode node = root;\\n        for (char c : s.toCharArray()) {\\n            if (node.children[c - 'a'] == null) {\\n                return false;\\n            }\\n            node = node.children[c - 'a'];\\n        }\\n        return node.isWord;\\n    }\\n}\\n````",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "````\\nclass MagicDictionary {\\n    class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        boolean isWord;\\n        public TrieNode() {}\\n    }\\n    TrieNode root;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s : dict) {\\n            TrieNode node = root;\\n            for (char c : s.toCharArray()) {\\n                if (node.children[c - 'a'] == null) {\\n                    node.children[c - 'a'] = new TrieNode();\\n                }\\n                node = node.children[c - 'a'];\\n            }\\n            node.isWord = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        char[] arr = word.toCharArray();\\n        for (int i = 0; i < word.length(); i++) {\\n            for (char c = 'a'; c <= 'z'; c++) {\\n                if (arr[i] == c) {\\n                    continue;\\n                }\\n                char org = arr[i];\\n                arr[i] = c;\\n                if (helper(new String(arr), root)) {\\n                    return true;\\n                }\\n                arr[i] = org;\\n            }\\n        }\\n        return false;\\n    }\\n    public boolean helper(String s, TrieNode root) {\\n        TrieNode node = root;\\n        for (char c : s.toCharArray()) {\\n            if (node.children[c - 'a'] == null) {\\n                return false;\\n            }\\n            node = node.children[c - 'a'];\\n        }\\n        return node.isWord;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107466,
                "title": "python-intuitive-solution-using-dictionary",
                "content": "The basic idea here is very simple: we construct a dictionary, whose key is the length of the given words, and the value is a list containing the words with the same length specified in the key. And when we search a word (say word \"hello\") in the magic dictionary, we only need to check those words in dic[len(\"hellow\")], ( named candi in my code). Simple and quite intuitive but beat 90% :-)\\n\\n```\\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.wordsdic={}\\n\\n    def buildDict(self, dict):\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        :type dict: List[str]\\n        :rtype: void\\n        \"\"\"\\n        for i in dict:\\n            self.wordsdic[len(i)]=self.wordsdic.get(len(i),[])+[i]\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        for candi in self.wordsdic.get(len(word),[]):\\n                countdiff=0\\n                for j in range(len(word)):\\n                    if candi[j]!=word[j]:\\n                        countdiff+=1\\n                if countdiff==1:\\n                    return True\\n        return False\\n                    \\n        \\n\\n\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dict)\\n# param_2 = obj.search(word)\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.wordsdic={}\\n\\n    def buildDict(self, dict):\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        :type dict: List[str]\\n        :rtype: void\\n        \"\"\"\\n        for i in dict:\\n            self.wordsdic[len(i)]=self.wordsdic.get(len(i),[])+[i]\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        for candi in self.wordsdic.get(len(word),[]):\\n                countdiff=0\\n                for j in range(len(word)):\\n                    if candi[j]!=word[j]:\\n                        countdiff+=1\\n                if countdiff==1:\\n                    return True\\n        return False\\n                    \\n        \\n\\n\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dict)\\n# param_2 = obj.search(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107467,
                "title": "python-trie-way",
                "content": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.isAend = False\\n        self.contains = {}\\nclass MagicDictionary(object):\\n    def __init__(self):\\n        self.root = TrieNode()\\n    def addWord(self, word):\\n        r = self.root\\n        for chr in word:\\n            if chr not in r.contains:\\n                r.contains[chr] = TrieNode()\\n            r = r.contains[chr]\\n        r.isAend = True\\n\\n    def findWord(self, remain, r, word):\\n        if not word:\\n            return True if remain == 0 and r.isAend else False\\n        for key in r.contains.keys():\\n            if key == word[0]:\\n                if self.findWord(remain, r.contains[key], word[1:]):\\n                    return True\\n            elif remain == 1:\\n                if self.findWord(0, r.contains[key], word[1:]):\\n                    return True\\n        return False\\n    def buildDict(self, dict):\\n        for word in dict:\\n            self.addWord(word)\\n    def search(self, word):\\n        return self.findWord(1, self.root, word)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.isAend = False\\n        self.contains = {}\\nclass MagicDictionary(object):\\n    def __init__(self):\\n        self.root = TrieNode()\\n    def addWord(self, word):\\n        r = self.root\\n        for chr in word:\\n            if chr not in r.contains:\\n                r.contains[chr] = TrieNode()\\n            r = r.contains[chr]\\n        r.isAend = True\\n\\n    def findWord(self, remain, r, word):\\n        if not word:\\n            return True if remain == 0 and r.isAend else False\\n        for key in r.contains.keys():\\n            if key == word[0]:\\n                if self.findWord(remain, r.contains[key], word[1:]):\\n                    return True\\n            elif remain == 1:\\n                if self.findWord(0, r.contains[key], word[1:]):\\n                    return True\\n        return False\\n    def buildDict(self, dict):\\n        for word in dict:\\n            self.addWord(word)\\n    def search(self, word):\\n        return self.findWord(1, self.root, word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190786,
                "title": "c-trie-solution",
                "content": "`updated 2020/09/15`\\nThe original code can\\'t pass OJ anymore. Please see updated code below.\\n```\\nclass Node{\\npublic:\\n    vector<Node*> next;\\n    bool isWord;\\n    Node(){\\n        isWord = false;\\n        next = vector<Node*>(26, NULL);\\n    }\\n};\\n\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(string s){\\n        Node* cur = root;\\n        for(char c: s){\\n            if(cur->next[c - \\'a\\'] == NULL)\\n                cur->next[c - \\'a\\'] = new Node();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->isWord = true;\\n    }\\n    \\n    bool find(string s){\\n        Node* cur = root;\\n        for(char c: s){\\n            if(cur->next[c - \\'a\\'] == NULL)\\n                return false;\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        return cur->isWord;\\n    }\\n};\\n\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        trie = new Trie();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for(string s: dict){\\n            trie->insert(s);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        for(int i = 0; i < word.size(); i++){\\n            for(int j = 0; j < 26; j++){\\n                char c = j + \\'a\\';\\n                if(c == word[i]) continue;\\n                char oriChar = word[i];\\n                word[i] = c;\\n                if(trie->find(word))\\n                    return true;\\n                word[i] = oriChar;\\n            }\\n        }\\n        return false;\\n    }\\nprivate:\\n    Trie* trie;\\n};\\n ```\\n \\n`updated 2020/09/15`\\nThe OJ has changed the time limit, so my original code can\\'t pass.\\nI updated my code to do dfs to optimize.\\n```\\nclass Node{\\npublic:\\n    vector<Node*> next;\\n    bool isWord;\\n    Node(){\\n        isWord = false;\\n        next = vector<Node*>(26, NULL);\\n    }\\n};\\n\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(string s){\\n        Node* cur = root;\\n        for(char c: s){\\n            if(cur->next[c - \\'a\\'] == NULL)\\n                cur->next[c - \\'a\\'] = new Node();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->isWord = true;\\n    }\\n    \\n    bool find(string s, int cur_idx, int change = 0, Node* cur = NULL) {\\n        if (!cur) cur = root;\\n        if (cur_idx == s.size()) return cur->isWord && change == 1;\\n        Node* next = cur->next[s[cur_idx] - \\'a\\'];\\n        if (change == 1) {\\n            if (!next) return false;\\n            else return find(s, cur_idx + 1, 1, next);\\n        } else {\\n            if (next && find(s, cur_idx + 1, 0, next)) return true;\\n            for (int i = 0; i < 26; i++) {\\n                if (s[cur_idx] == \\'a\\' + i) continue;\\n                if (cur->next[i] && find(s, cur_idx + 1, 1, cur->next[i])) return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        trie = new Trie();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for(string s: dict){\\n            trie->insert(s);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        return trie->find(word, 0);\\n    }\\nprivate:\\n    Trie* trie;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Node{\\npublic:\\n    vector<Node*> next;\\n    bool isWord;\\n    Node(){\\n        isWord = false;\\n        next = vector<Node*>(26, NULL);\\n    }\\n};\\n\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(string s){\\n        Node* cur = root;\\n        for(char c: s){\\n            if(cur->next[c - \\'a\\'] == NULL)\\n                cur->next[c - \\'a\\'] = new Node();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->isWord = true;\\n    }\\n    \\n    bool find(string s){\\n        Node* cur = root;\\n        for(char c: s){\\n            if(cur->next[c - \\'a\\'] == NULL)\\n                return false;\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        return cur->isWord;\\n    }\\n};\\n\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        trie = new Trie();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for(string s: dict){\\n            trie->insert(s);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        for(int i = 0; i < word.size(); i++){\\n            for(int j = 0; j < 26; j++){\\n                char c = j + \\'a\\';\\n                if(c == word[i]) continue;\\n                char oriChar = word[i];\\n                word[i] = c;\\n                if(trie->find(word))\\n                    return true;\\n                word[i] = oriChar;\\n            }\\n        }\\n        return false;\\n    }\\nprivate:\\n    Trie* trie;\\n};\\n ```\n```\\nclass Node{\\npublic:\\n    vector<Node*> next;\\n    bool isWord;\\n    Node(){\\n        isWord = false;\\n        next = vector<Node*>(26, NULL);\\n    }\\n};\\n\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(string s){\\n        Node* cur = root;\\n        for(char c: s){\\n            if(cur->next[c - \\'a\\'] == NULL)\\n                cur->next[c - \\'a\\'] = new Node();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->isWord = true;\\n    }\\n    \\n    bool find(string s, int cur_idx, int change = 0, Node* cur = NULL) {\\n        if (!cur) cur = root;\\n        if (cur_idx == s.size()) return cur->isWord && change == 1;\\n        Node* next = cur->next[s[cur_idx] - \\'a\\'];\\n        if (change == 1) {\\n            if (!next) return false;\\n            else return find(s, cur_idx + 1, 1, next);\\n        } else {\\n            if (next && find(s, cur_idx + 1, 0, next)) return true;\\n            for (int i = 0; i < 26; i++) {\\n                if (s[cur_idx] == \\'a\\' + i) continue;\\n                if (cur->next[i] && find(s, cur_idx + 1, 1, cur->next[i])) return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        trie = new Trie();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for(string s: dict){\\n            trie->insert(s);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        return trie->find(word, 0);\\n    }\\nprivate:\\n    Trie* trie;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148165,
                "title": "clean-java-code-with-trie",
                "content": "```\\nclass MagicDictionary {\\n    class Trie{\\n        boolean isEnd;\\n        Map<Character, Trie> children;\\n        Trie(){\\n            children = new HashMap();\\n        }\\n    }\\n    Trie root;\\n    \\n    public MagicDictionary() {\\n        root = new Trie();\\n    }\\n    \\n    public void buildDict(String[] dict) {\\n        for(String s : dict){\\n            Trie curr = root;\\n            for(char c : s.toCharArray()){\\n                if(!curr.children.containsKey(c)){\\n                    curr.children.put(c, new Trie());\\n                }\\n                curr = curr.children.get(c);\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n    \\n    public boolean search(String word) {\\n        return search(word, 0, root, false);\\n    }\\n    public boolean search(String word, int i, Trie node, boolean flag){\\n        if(i < word.length()){\\n            if(node.children.containsKey(word.charAt(i))){\\n                if(search(word, i+1, node.children.get(word.charAt(i)), flag)){\\n                    return true;\\n                }\\n            }\\n            if(!flag){\\n                for(char c: node.children.keySet()){\\n                    if(c!= word.charAt(i) && search(word, i+1, node.children.get(c), true)) return true;\\n                }\\n            }\\n            return false;\\n        }\\n        return flag && node.isEnd;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n    class Trie{\\n        boolean isEnd;\\n        Map<Character, Trie> children;\\n        Trie(){\\n            children = new HashMap();\\n        }\\n    }\\n    Trie root;\\n    \\n    public MagicDictionary() {\\n        root = new Trie();\\n    }\\n    \\n    public void buildDict(String[] dict) {\\n        for(String s : dict){\\n            Trie curr = root;\\n            for(char c : s.toCharArray()){\\n                if(!curr.children.containsKey(c)){\\n                    curr.children.put(c, new Trie());\\n                }\\n                curr = curr.children.get(c);\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n    \\n    public boolean search(String word) {\\n        return search(word, 0, root, false);\\n    }\\n    public boolean search(String word, int i, Trie node, boolean flag){\\n        if(i < word.length()){\\n            if(node.children.containsKey(word.charAt(i))){\\n                if(search(word, i+1, node.children.get(word.charAt(i)), flag)){\\n                    return true;\\n                }\\n            }\\n            if(!flag){\\n                for(char c: node.children.keySet()){\\n                    if(c!= word.charAt(i) && search(word, i+1, node.children.get(c), true)) return true;\\n                }\\n            }\\n            return false;\\n        }\\n        return flag && node.isEnd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177342,
                "title": "66ms-prefix-tree-trie-java-with-explanation",
                "content": "**Thought**\\nWe could build a trie using word in dicts. If two words differ by one character only, they will be within the branches regardless of the mismatched character.\\n```\\nFor example, dict = [\"ooo\", \"ooa\"] and search(\"oxo\"), they have one character mismatched, \\n\\no - o [mismatched here, cntMismatched = 1] - a [mismatched here, cntMismatched = 2, backtrack]\\n\\t\\t\\t\\t           - o - exhausted [cntMismatched = 1, return true]\\n  \\n```\\n**Code**\\n```\\n    /** Initialize your data structure here. */\\n    \\n    private static Node root;\\n    public MagicDictionary() {\\n        root = new Node();       \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        buildTrie(dict);\\n    }\\n    \\n    private void buildTrie(String[] dict) {\\n        Node ptr;\\n        for (String word : dict) {\\n            ptr = root;\\n            for (char ch : word.toCharArray()) {\\n                int order = ch - \\'a\\';\\n                if (ptr.children[order] == null)\\n                    ptr.children[order] = new Node();\\n                ptr = ptr.children[order];\\n            }\\n            ptr.isWordEnd = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {        \\n        return dfs(0, word, root, 0);\\n    }\\n    \\n    private boolean dfs(int curId, String word, Node parentPtr, int cntMismatched) {\\n        \\n        if (cntMismatched > 1) {\\n            return false;\\n        }\\n        \\n        if (curId == word.length()) {       \\n            return parentPtr.isWordEnd && cntMismatched == 1;\\n        }\\n\\n        \\n        for (int i = 0; i < 26; i++) {          \\n            int order = word.charAt(curId) - \\'a\\';\\n            if (parentPtr.children[i] == null)\\n                continue;       \\n            if (order != i) {\\n                if (dfs(curId + 1, word, parentPtr.children[i], cntMismatched + 1))\\n                    return true;\\n            } else {\\n                if (dfs(curId + 1, word, parentPtr.children[i], cntMismatched))\\n                    return true;\\n            }\\n        }     \\n       \\n        return false;\\n    }\\n    \\n    class Node {\\n        \\n        Node[] children;\\n        boolean isWordEnd;\\n        \\n        public Node() {\\n            children = new Node[26];\\n            isWordEnd = false;\\n        }\\n    } \\n```\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\nFor example, dict = [\"ooo\", \"ooa\"] and search(\"oxo\"), they have one character mismatched, \\n\\no - o [mismatched here, cntMismatched = 1] - a [mismatched here, cntMismatched = 2, backtrack]\\n\\t\\t\\t\\t           - o - exhausted [cntMismatched = 1, return true]\\n  \\n```\n```\\n    /** Initialize your data structure here. */\\n    \\n    private static Node root;\\n    public MagicDictionary() {\\n        root = new Node();       \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        buildTrie(dict);\\n    }\\n    \\n    private void buildTrie(String[] dict) {\\n        Node ptr;\\n        for (String word : dict) {\\n            ptr = root;\\n            for (char ch : word.toCharArray()) {\\n                int order = ch - \\'a\\';\\n                if (ptr.children[order] == null)\\n                    ptr.children[order] = new Node();\\n                ptr = ptr.children[order];\\n            }\\n            ptr.isWordEnd = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {        \\n        return dfs(0, word, root, 0);\\n    }\\n    \\n    private boolean dfs(int curId, String word, Node parentPtr, int cntMismatched) {\\n        \\n        if (cntMismatched > 1) {\\n            return false;\\n        }\\n        \\n        if (curId == word.length()) {       \\n            return parentPtr.isWordEnd && cntMismatched == 1;\\n        }\\n\\n        \\n        for (int i = 0; i < 26; i++) {          \\n            int order = word.charAt(curId) - \\'a\\';\\n            if (parentPtr.children[i] == null)\\n                continue;       \\n            if (order != i) {\\n                if (dfs(curId + 1, word, parentPtr.children[i], cntMismatched + 1))\\n                    return true;\\n            } else {\\n                if (dfs(curId + 1, word, parentPtr.children[i], cntMismatched))\\n                    return true;\\n            }\\n        }     \\n       \\n        return false;\\n    }\\n    \\n    class Node {\\n        \\n        Node[] children;\\n        boolean isWordEnd;\\n        \\n        public Node() {\\n            children = new Node[26];\\n            isWordEnd = false;\\n        }\\n    } \\n```",
                "codeTag": "Java"
            },
            {
                "id": 320197,
                "title": "simple-python-solution",
                "content": "Please see and vote for my solutions for\\n[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/320224/Simple-Python-solution)\\n[1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/409075/standard-python-prefix-tree-solution)\\n[1032. Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/320837/Standard-Python-Trie-Solution)\\n[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/319361/Simple-Python-solution)\\n[676. Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/320197/Simple-Python-solution)\\n[677. Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/320237/Simple-Python-solution)\\n[745. Prefix and Suffix Search](https://leetcode.com/problems/prefix-and-suffix-search/discuss/320712/Different-Python-solutions-with-thinking-process)\\n[425. Word Squares](https://leetcode.com/problems/word-squares/discuss/320916/Easily-implemented-Python-solution%3A-Backtrack-%2B-Trie)\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n[336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/discuss/316960/Different-Python-solutions%3A-brute-force-dictionary-Trie)\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass MagicDictionary:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.trie = Trie()\\n\\n    def buildDict(self, words: List[str]) -> None:\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        \"\"\"\\n        for w in words:\\n            self.trie.insert(w)\\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        \"\"\"\\n        def dfs(node, i, word):\\n            if i == len(word):\\n                return node.isEnd and self.modified\\n            if self.modified:\\n                if word[i] in node.children:\\n                    return dfs(node.children[word[i]], i + 1, word)\\n                else:\\n                    return False\\n            else:\\n                for c in node.children:\\n                    self.modified = c != word[i]\\n                    if dfs(node.children[c], i + 1, word):\\n                            return True\\n                return False\\n        \\n        self.modified = False\\n        return dfs(self.trie.root, 0, word)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass MagicDictionary:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.trie = Trie()\\n\\n    def buildDict(self, words: List[str]) -> None:\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        \"\"\"\\n        for w in words:\\n            self.trie.insert(w)\\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        \"\"\"\\n        def dfs(node, i, word):\\n            if i == len(word):\\n                return node.isEnd and self.modified\\n            if self.modified:\\n                if word[i] in node.children:\\n                    return dfs(node.children[word[i]], i + 1, word)\\n                else:\\n                    return False\\n            else:\\n                for c in node.children:\\n                    self.modified = c != word[i]\\n                    if dfs(node.children[c], i + 1, word):\\n                            return True\\n                return False\\n        \\n        self.modified = False\\n        return dfs(self.trie.root, 0, word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107500,
                "title": "efficient-python-trie-solution-without-traversing-all-characters-a-z-at-each-step",
                "content": "```\\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        self.trie = {}\\n\\n    def buildDict(self, dict):\\n        for word in dict: \\n            node = self.trie \\n            for letter in word: \\n                if letter not in node: \\n                    node[letter] = {}\\n                node = node[letter] \\n            node[None] = None \\n\\n    def search(self, word):\\n        def find(node, i, mistakeAllowed): \\n            if i == len(word):\\n                if None in node and not mistakeAllowed: \\n                    return True\\n                return False \\n            if word[i] not in node: \\n                return any(find(node[letter], i+1, False) for letter in node if letter) if mistakeAllowed else False \\n            \\n            if mistakeAllowed: \\n                return find(node[word[i]], i+1, True) or any(find(node[letter], i+1, False) for letter in node if letter and letter != word[i])\\n            return find(node[word[i]], i+1, False)\\n            \\n        return find(self.trie, 0, True)        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        self.trie = {}\\n\\n    def buildDict(self, dict):\\n        for word in dict: \\n            node = self.trie \\n            for letter in word: \\n                if letter not in node: \\n                    node[letter] = {}\\n                node = node[letter] \\n            node[None] = None \\n\\n    def search(self, word):\\n        def find(node, i, mistakeAllowed): \\n            if i == len(word):\\n                if None in node and not mistakeAllowed: \\n                    return True\\n                return False \\n            if word[i] not in node: \\n                return any(find(node[letter], i+1, False) for letter in node if letter) if mistakeAllowed else False \\n            \\n            if mistakeAllowed: \\n                return find(node[word[i]], i+1, True) or any(find(node[letter], i+1, False) for letter in node if letter and letter != word[i])\\n            return find(node[word[i]], i+1, False)\\n            \\n        return find(self.trie, 0, True)        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107507,
                "title": "easy-java-solution",
                "content": "Some thoughts:\\nIt may not be necessary to implement the trie for this problem.\\nThe time complexity and space complexity are the same.\\nAnd in some cases, trie version might be even slower? \\n\\n```\\nclass MagicDictionary {\\n\\n    HashSet<String> dictSet;\\n    \\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        dictSet = new HashSet<>();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        dictSet = new HashSet<String>();\\n        for(String word : dict)\\n            dictSet.add(word);\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        char[] chars = word.toCharArray();\\n        for(int i = 0; i < chars.length; i++){\\n            char ch = chars[i];\\n            for (char c = 'a'; c <= 'z'; c++){\\n                if (c != ch){\\n                    chars[i] = c;\\n                    if (dictSet.contains(new String(chars)))\\n                        return true;\\n                }\\n            }\\n            chars[i] = ch;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n\\n    HashSet<String> dictSet;\\n    \\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        dictSet = new HashSet<>();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        dictSet = new HashSet<String>();\\n        for(String word : dict)\\n            dictSet.add(word);\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        char[] chars = word.toCharArray();\\n        for(int i = 0; i < chars.length; i++){\\n            char ch = chars[i];\\n            for (char c = 'a'; c <= 'z'; c++){\\n                if (c != ch){\\n                    chars[i] = c;\\n                    if (dictSet.contains(new String(chars)))\\n                        return true;\\n                }\\n            }\\n            chars[i] = ch;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549172,
                "title": "python-3-trie-dfs-solution-w-explanation",
                "content": "The idea here is to use a Trie and a depth first search, similar to LeetCode 211: https://leetcode.com/problems/design-add-and-search-words-data-structure.\\n\\nWe define a TrieNode to use for this algorithm. I choose to specify that a node is explicitly a terminal node for a word with ```is_end``` but you may opt to simply add a child with \"#\". Whatever works for you.\\n\\nThe idea behind this algorithm is that we have to try the change at every possible place, even if the character matches because we could end up with the case that we never change anything and end up with the string we originally searched for, which is not allowed given the example test cases (because we MUST change 1 character). We will keep track of this with a variable called ```modifications``` which has an initial value of 1 and represents the modifications we are allowed to make.\\n\\nWe kick off our DFS at the root of the Trie. For each invocation of DFS, the algorithm proceeds as follows:\\n\\n+ 1). Check that modifications is > 0. If modifications = 1, then we haven\\'t used a modification. If modifications = 0, then we have used our one allowed modification. If modifications is less than 0, then we have used more than one modification and this path is invalid as it violates the problem statement that only allows us one character change.\\n+ 2). If our search word is empty, that means we have reached the end of the Trie and we need to check whether or not we have a valid answer here. A valid answer here is one where we have used our one allowed change AND the node we are at is the terminal node for a word.\\n+ 3). Once those checks are done, if we still have work to do, then we iterate over the characters at this level in the Trie. \\n\\t+ If the character is equal to the first character of the string we are searching, then call dfs recursively with that next node, slice the first character off the string, and keep modifications untouched as we have not made a change.\\n\\t+ If the character is not equal, then we do the same as in the previous step except this time we call the recursive DFS function with modifications - 1 as we are using our one change allowed to skip the current character.\\n\\n\\nI\\'m not 100% sure on the time complexity of this algorithm. Perhaps someone can help in the comments below.\\n\\n```\\nclass TrieNode:\\n    def __init__(self, char):\\n        self.char = char\\n        self.children = {}\\n        self.is_end = False\\n        \\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.trie = TrieNode(\"#\")\\n\\n    def add_word(self, word):\\n        root = self.trie\\n        \\n        for char in word:\\n            if char not in root.children:\\n                root.children[char] = TrieNode(char)\\n            \\n            root = root.children[char]\\n        \\n        root.is_end = True\\n        \\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.add_word(word)\\n            \\n    def search(self, searchWord: str) -> bool:\\n        return self.dfs(self.trie, searchWord, 1)\\n    \\n    def dfs(self, node, word, modifications):\\n        if modifications < 0:\\n            return False\\n        \\n        if not word:\\n            return not modifications and node.is_end\\n        \\n        for child in node.children:\\n            if child == word[0]:\\n                if self.dfs(node.children[word[0]], word[1:], modifications):\\n                    return True\\n            else:\\n                if self.dfs(node.children[child], word[1:], modifications - 1):\\n                    return True \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```is_end```\n```modifications```\n```\\nclass TrieNode:\\n    def __init__(self, char):\\n        self.char = char\\n        self.children = {}\\n        self.is_end = False\\n        \\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.trie = TrieNode(\"#\")\\n\\n    def add_word(self, word):\\n        root = self.trie\\n        \\n        for char in word:\\n            if char not in root.children:\\n                root.children[char] = TrieNode(char)\\n            \\n            root = root.children[char]\\n        \\n        root.is_end = True\\n        \\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.add_word(word)\\n            \\n    def search(self, searchWord: str) -> bool:\\n        return self.dfs(self.trie, searchWord, 1)\\n    \\n    def dfs(self, node, word, modifications):\\n        if modifications < 0:\\n            return False\\n        \\n        if not word:\\n            return not modifications and node.is_end\\n        \\n        for child in node.children:\\n            if child == word[0]:\\n                if self.dfs(node.children[word[0]], word[1:], modifications):\\n                    return True\\n            else:\\n                if self.dfs(node.children[child], word[1:], modifications - 1):\\n                    return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 107506,
                "title": "c-unordered-set",
                "content": "The solution is to use hash table to save the dictionary. For each word to search, generate all possible candidates and verify whether it is in the dictionary.\\nFor the follow-up question, we should implement a trie rather than use hash table. Trie uses less space and more efficient for a large dictionary. \\n```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for (string &s:dict) words.insert(s);\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n          for (int i = 0; i < word.size(); i++) {\\n            char c = word[i];\\n            for (int j = 0; j < 26; j++) {\\n                if (c == j+'a') continue;\\n                word[i] = j+'a';\\n                if (words.count(word)) return true;\\n            }\\n            word[i] = c;\\n        }\\n        return false;\\n    }\\nprivate:\\n    unordered_set<string> words;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for (string &s:dict) words.insert(s);\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n          for (int i = 0; i < word.size(); i++) {\\n            char c = word[i];\\n            for (int j = 0; j < 26; j++) {\\n                if (c == j+'a') continue;\\n                word[i] = j+'a';\\n                if (words.count(word)) return true;\\n            }\\n            word[i] = c;\\n        }\\n        return false;\\n    }\\nprivate:\\n    unordered_set<string> words;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184179,
                "title": "c-tries-method",
                "content": "  ```\nclass MagicDictionary {\n\n\t\tclass trienode{\n        public:\n            vector<trienode *> alphabets = vector<trienode *> (26, nullptr);\n            bool is_end=false;\n    };\n    trienode *root;\n    \n    bool search(trienode *cur,  string &word, int index, bool flag){\n        if(index == word.length()){\n            if(flag && cur->is_end) return true;\n            return false;\n        }   \n        int right = word[index]-'a'; \n        for(int i=0;i<26;i++){\n            if(cur->alphabets[i]){\n                if(right!=i && !flag){\n                    if(search(cur->alphabets[i], word, index+1,true)) return true;\n                }else{\n                    if(right==i && search(cur->alphabets[i], word, index+1,flag)) return true;\n                }\n            }\n        }\n        return false;\n        }\npublic:\n    MagicDictionary() {\n        root = new trienode();\n    }\n    \n    /** Build a dictionary through a list of words */\n    void buildDict(vector<string> dict) {\n        trienode *start;\n        for(auto word:dict){\n            start = root; \n            for(auto c:word){\n                if(start->alphabets[c - 'a']){\n                    start = start->alphabets[c - 'a'];\n                }else{\n                    start->alphabets[c - 'a'] = new trienode();\n                    start = start->alphabets[c - 'a'];\n                }\n            }\n            start-> is_end = true;\n        }\n    }\n    \n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\n    bool search(string word) {\n        return search(root, word, 0, false);\n    }\n};\n```\n\nTries data structure and backstracking search, very easy to understand.\n",
                "solutionTags": [],
                "code": "```\nclass MagicDictionary {\n\n\t\tclass trienode{\n        public:\n            vector<trienode *> alphabets = vector<trienode *> (26, nullptr);\n            bool is_end=false;\n    };\n    trienode *root;\n    \n    bool search(trienode *cur,  string &word, int index, bool flag){\n        if(index == word.length()){\n            if(flag && cur->is_end) return true;\n            return false;\n        }   \n        int right = word[index]-'a'; \n        for(int i=0;i<26;i++){\n            if(cur->alphabets[i]){\n                if(right!=i && !flag){\n                    if(search(cur->alphabets[i], word, index+1,true)) return true;\n                }else{\n                    if(right==i && search(cur->alphabets[i], word, index+1,flag)) return true;\n                }\n            }\n        }\n        return false;\n        }\npublic:\n    MagicDictionary() {\n        root = new trienode();\n    }\n    \n    /** Build a dictionary through a list of words */\n    void buildDict(vector<string> dict) {\n        trienode *start;\n        for(auto word:dict){\n            start = root; \n            for(auto c:word){\n                if(start->alphabets[c - 'a']){\n                    start = start->alphabets[c - 'a'];\n                }else{\n                    start->alphabets[c - 'a'] = new trienode();\n                    start = start->alphabets[c - 'a'];\n                }\n            }\n            start-> is_end = true;\n        }\n    }\n    \n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\n    bool search(string word) {\n        return search(root, word, 0, false);\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 956713,
                "title": "easy-understanding-c",
                "content": "```\\nclass MagicDictionary {\\npublic:\\n\\n    unordered_set<string> set;\\n\\t\\n    MagicDictionary(){\\n    }\\n    \\n    void buildDict(vector<string> dictionary){\\n        for(string str: dictionary)\\n            set.insert(str);\\n    }\\n    \\n    bool search(string searchWord){\\n        for(string s: set){\\n            if(s.size()==searchWord.size()){\\n                int cnt=0;\\n                for(int i=0;i<s.size();i++){\\n                    if(s[i]!=searchWord[i]) cnt++;\\n                }\\n                if(cnt==1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\t\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n\\n    unordered_set<string> set;\\n\\t\\n    MagicDictionary(){\\n    }\\n    \\n    void buildDict(vector<string> dictionary){\\n        for(string str: dictionary)\\n            set.insert(str);\\n    }\\n    \\n    bool search(string searchWord){\\n        for(string s: set){\\n            if(s.size()==searchWord.size()){\\n                int cnt=0;\\n                for(int i=0;i<s.size();i++){\\n                    if(s[i]!=searchWord[i]) cnt++;\\n                }\\n                if(cnt==1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075268,
                "title": "java-dfs-trie-extendable-for-modifying-n-characters",
                "content": "```\\nclass MagicDictionary {\\n    \\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isEnd = false;\\n    }\\n    \\n    public TrieNode root;\\n\\n    public MagicDictionary() {\\n        this.root = new TrieNode();    \\n    }\\n    \\n    //build a regular trie\\n    public void buildDict(String[] dictionary) {\\n        for (String s: dictionary) {\\n            TrieNode node = this.root;\\n            for (char c : s.toCharArray()) {\\n                if (!node.children.containsKey(c)) {\\n                    node.children.put(c, new TrieNode());\\n                }\\n                node = node.children.get(c);\\n            }\\n            node.isEnd = true;\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        TrieNode node = this.root;\\n        //alter exact 1 char, so put 1\\n        return magicSearch(searchWord, node, 1);\\n    }\\n    \\n    public boolean magicSearch(String searchWord, TrieNode node, int diff) {\\n        if (diff == 0) {\\n            return strictSearch(node, searchWord);\\n        }\\n        \\n        char[] searchWordArray = searchWord.toCharArray();\\n        for (int i = 0; i<searchWordArray.length; i++) {\\n            char c = searchWordArray[i];\\n            \\n            //Option 1: change the current char\\n            for (char alter : node.children.keySet()) {\\n                if (alter != c) {\\n                    if (magicSearch(searchWord.substring(i+1), node.children.get(alter), diff - 1)) {\\n                        return true;\\n                    }\\n                }    \\n            }\\n            \\n            //Option 2: do not change the current char\\n            if (!node.children.containsKey(c)) {\\n                break; // return false if we can\\'t change the current char but but the char does not belong to the node\\'s children\\n            } \\n            \\n            node = node.children.get(c);\\n        }\\n        return false;\\n    }\\n    \\n    public boolean strictSearch(TrieNode node, String word) {\\n        for (char c: word.toCharArray()) {\\n            if (!node.children.containsKey(c)) {\\n                return false;\\n            } \\n            node = node.children.get(c);\\n        }\\n        return node.isEnd;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass MagicDictionary {\\n    \\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isEnd = false;\\n    }\\n    \\n    public TrieNode root;\\n\\n    public MagicDictionary() {\\n        this.root = new TrieNode();    \\n    }\\n    \\n    //build a regular trie\\n    public void buildDict(String[] dictionary) {\\n        for (String s: dictionary) {\\n            TrieNode node = this.root;\\n            for (char c : s.toCharArray()) {\\n                if (!node.children.containsKey(c)) {\\n                    node.children.put(c, new TrieNode());\\n                }\\n                node = node.children.get(c);\\n            }\\n            node.isEnd = true;\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        TrieNode node = this.root;\\n        //alter exact 1 char, so put 1\\n        return magicSearch(searchWord, node, 1);\\n    }\\n    \\n    public boolean magicSearch(String searchWord, TrieNode node, int diff) {\\n        if (diff == 0) {\\n            return strictSearch(node, searchWord);\\n        }\\n        \\n        char[] searchWordArray = searchWord.toCharArray();\\n        for (int i = 0; i<searchWordArray.length; i++) {\\n            char c = searchWordArray[i];\\n            \\n            //Option 1: change the current char\\n            for (char alter : node.children.keySet()) {\\n                if (alter != c) {\\n                    if (magicSearch(searchWord.substring(i+1), node.children.get(alter), diff - 1)) {\\n                        return true;\\n                    }\\n                }    \\n            }\\n            \\n            //Option 2: do not change the current char\\n            if (!node.children.containsKey(c)) {\\n                break; // return false if we can\\'t change the current char but but the char does not belong to the node\\'s children\\n            } \\n            \\n            node = node.children.get(c);\\n        }\\n        return false;\\n    }\\n    \\n    public boolean strictSearch(TrieNode node, String word) {\\n        for (char c: word.toCharArray()) {\\n            if (!node.children.containsKey(c)) {\\n                return false;\\n            } \\n            node = node.children.get(c);\\n        }\\n        return node.isEnd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305277,
                "title": "java-easy-no-tries-and-hashes-beats-99",
                "content": "I am not familiar with advanced data structures, but it seems we can solve it without them:\\n```\\nclass MagicDictionary {\\n    private String[] data;\\n\\n    public void buildDict(String[] dictionary) {\\n        this.data = dictionary;\\n    }\\n\\n    public boolean search(String searchWord) {\\n        for (String element : data) {\\n            if (onlyOneCharDifferent(element, searchWord)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean onlyOneCharDifferent(String element, String searchWord) {\\n        if (element.length() != searchWord.length()) {\\n            return false;\\n        }\\n\\n        boolean onlyOneCharDifferent = false;\\n\\n        for (int i = 0; i < element.length(); i++) {\\n            boolean differentChars = element.charAt(i) != searchWord.charAt(i);\\n\\n            if (differentChars && !onlyOneCharDifferent) {\\n                onlyOneCharDifferent = true;\\n            } else if (differentChars) {\\n                onlyOneCharDifferent = false;\\n                break;\\n            }\\n        }\\n\\n        return onlyOneCharDifferent;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass MagicDictionary {\\n    private String[] data;\\n\\n    public void buildDict(String[] dictionary) {\\n        this.data = dictionary;\\n    }\\n\\n    public boolean search(String searchWord) {\\n        for (String element : data) {\\n            if (onlyOneCharDifferent(element, searchWord)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean onlyOneCharDifferent(String element, String searchWord) {\\n        if (element.length() != searchWord.length()) {\\n            return false;\\n        }\\n\\n        boolean onlyOneCharDifferent = false;\\n\\n        for (int i = 0; i < element.length(); i++) {\\n            boolean differentChars = element.charAt(i) != searchWord.charAt(i);\\n\\n            if (differentChars && !onlyOneCharDifferent) {\\n                onlyOneCharDifferent = true;\\n            } else if (differentChars) {\\n                onlyOneCharDifferent = false;\\n                break;\\n            }\\n        }\\n\\n        return onlyOneCharDifferent;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524050,
                "title": "my-java-solution-with-trie-and-backtracking-search",
                "content": "Implement magic dictionary with two operations: `buildDict` and `search`. It\\'s easy to come up with `Trie` to build a dict. The difficulty here for me is to implement the `search` operation.\\nI use the backtracking way to find if there exists one word in the dict which has only one character different from the word I search.\\n\\nHere is the code. Hope it helps you think from a different way.\\nI use a cnt to record the word\\'s change times.\\nThe key point is that if `cur.children[ch - \\'a\\']` is not null, we can search the next level without cnt + 1.\\nOtherwise, we can search all other `cur.children` except the one that `cur.children[ch - \\'a\\']`.\\nPlease point it out if anything is wrong.\\n\\n```\\nclass MagicDictionary {\\n\\n    TrieNode root;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s : dict) {\\n            TrieNode cur = root;\\n            for (char ch : s.toCharArray()) {\\n                if (cur.children[ch - \\'a\\'] == null) cur.children[ch - \\'a\\'] = new TrieNode();\\n                cur = cur.children[ch - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        return search(root, word.toCharArray(), 0, 0);\\n    }\\n    \\n    public boolean search(TrieNode cur, char[] word, int index, int cnt) {\\n        if (cur == null || cnt > 1) {\\n            return false;\\n        }\\n        if (index == word.length) {\\n            return cur.isWord && cnt == 1;\\n        }\\n\\n        for (int i = 0; i < 26; ++i) {\\n            if (search(cur.children[i], word, index + 1, (word[index] - \\'a\\' != i) ? cnt + 1 : cnt)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        boolean isWord = false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Trie"
                ],
                "code": "Implement magic dictionary with two operations: `buildDict` and `search`. It\\'s easy to come up with `Trie` to build a dict. The difficulty here for me is to implement the `search` operation.\\nI use the backtracking way to find if there exists one word in the dict which has only one character different from the word I search.\\n\\nHere is the code. Hope it helps you think from a different way.\\nI use a cnt to record the word\\'s change times.\\nThe key point is that if `cur.children[ch - \\'a\\']` is not null, we can search the next level without cnt + 1.\\nOtherwise, we can search all other `cur.children` except the one that `cur.children[ch - \\'a\\']`.\\nPlease point it out if anything is wrong.\\n\\n```\\nclass MagicDictionary {\\n\\n    TrieNode root;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s : dict) {\\n            TrieNode cur = root;\\n            for (char ch : s.toCharArray()) {\\n                if (cur.children[ch - \\'a\\'] == null) cur.children[ch - \\'a\\'] = new TrieNode();\\n                cur = cur.children[ch - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        return search(root, word.toCharArray(), 0, 0);\\n    }\\n    \\n    public boolean search(TrieNode cur, char[] word, int index, int cnt) {\\n        if (cur == null || cnt > 1) {\\n            return false;\\n        }\\n        if (index == word.length) {\\n            return cur.isWord && cnt == 1;\\n        }\\n\\n        for (int i = 0; i < 26; ++i) {\\n            if (search(cur.children[i], word, index + 1, (word[index] - \\'a\\' != i) ? cnt + 1 : cnt)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        boolean isWord = false;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 473142,
                "title": "c-0ms-solution-with-hashtable",
                "content": "\\tclass MagicDictionary {\\n\\tpublic:\\n\\t\\t/** Initialize your data structure here. */\\n\\t\\tunordered_map<int,vector<string>> m;\\n\\t\\tMagicDictionary() {\\n\\n\\t\\t}\\n\\n\\t\\t/** Build a dictionary through a list of words */\\n\\t\\tvoid buildDict(vector<string> dict) {\\n\\t\\t\\tfor(auto x:dict){\\n\\t\\t\\t\\tm[x.size()].push_back(x);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n\\t\\tbool search(string word) {\\n\\t\\t\\tint len=word.size();\\n\\t\\t\\tfor(auto v:m[len]){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tfor(int i=0;i<v.size();i++){\\n\\t\\t\\t\\t\\tif(v[i]!=word[i]){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(count>1) continue;\\n\\t\\t\\t\\t\\tif(i==v.size()-1 && count==1) return true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "\\tclass MagicDictionary {\\n\\tpublic:\\n\\t\\t/** Initialize your data structure here. */\\n\\t\\tunordered_map<int,vector<string>> m;\\n\\t\\tMagicDictionary() {\\n\\n\\t\\t}\\n\\n\\t\\t/** Build a dictionary through a list of words */\\n\\t\\tvoid buildDict(vector<string> dict) {\\n\\t\\t\\tfor(auto x:dict){\\n\\t\\t\\t\\tm[x.size()].push_back(x);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n\\t\\tbool search(string word) {\\n\\t\\t\\tint len=word.size();\\n\\t\\t\\tfor(auto v:m[len]){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tfor(int i=0;i<v.size();i++){\\n\\t\\t\\t\\t\\tif(v[i]!=word[i]){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(count>1) continue;\\n\\t\\t\\t\\t\\tif(i==v.size()-1 && count==1) return true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 107504,
                "title": "c-clean-code",
                "content": "```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for (string w : dict) {\\n            words.insert(w);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        for (int i = 0; i < word.size(); i++) {\\n            char wi = word[i];\\n            for (char ch = 'a'; ch <= 'z'; ch++) {\\n                if (ch == wi) continue;\\n                word[i] = ch;\\n                if (words.count(word)) return true;\\n            }\\n            word[i] = wi;\\n        }\\n        return false;\\n    }\\nprivate:\\n    unordered_set<string> words;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for (string w : dict) {\\n            words.insert(w);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        for (int i = 0; i < word.size(); i++) {\\n            char wi = word[i];\\n            for (char ch = 'a'; ch <= 'z'; ch++) {\\n                if (ch == wi) continue;\\n                word[i] = ch;\\n                if (words.count(word)) return true;\\n            }\\n            word[i] = wi;\\n        }\\n        return false;\\n    }\\nprivate:\\n    unordered_set<string> words;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901569,
                "title": "python-97-27-speed-hashmap-only-simple-code",
                "content": "For each word, length is the key. For each searchWord, only need to check the words with same length\\n\\n```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.myDict = defaultdict(set)\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            n = len(word)\\n            self.myDict[n].add(word)\\n\\n    def search(self, searchWord: str) -> bool:\\n        n = len(searchWord)\\n        if n not in self.myDict: return False\\n        \\n        def diff(word1, word2):\\n            count = 0\\n            for i in range(len(word1)):\\n                if word1[i] != word2[i]:\\n                    count += 1 \\n                if count > 1:\\n                    return count\\n            return count\\n                        \\n        \\n        for word in self.myDict[n]:\\n            if diff(word, searchWord) == 1:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.myDict = defaultdict(set)\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            n = len(word)\\n            self.myDict[n].add(word)\\n\\n    def search(self, searchWord: str) -> bool:\\n        n = len(searchWord)\\n        if n not in self.myDict: return False\\n        \\n        def diff(word1, word2):\\n            count = 0\\n            for i in range(len(word1)):\\n                if word1[i] != word2[i]:\\n                    count += 1 \\n                if count > 1:\\n                    return count\\n            return count\\n                        \\n        \\n        for word in self.myDict[n]:\\n            if diff(word, searchWord) == 1:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107451,
                "title": "two-c-solutions-hash-table-trie",
                "content": "**Solution 1.** Hash Table\\n```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {}\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for(auto x: dict) m[x.size()].push_back(x);\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        for(auto x: m[word.size()])\\n            if(oneEditDistance(x, word)) return true;\\n        return false;\\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<string>>m;\\n    bool oneEditDistance(string& a, string& b){\\n        int diff = 0;\\n        for(int i = 0; i < a.size() && diff <= 1; i++)\\n            if(a[i] != b[i]) diff++;\\n        return diff == 1;\\n    }\\n};\\n```\\n***\\n**Solution 2.** Trie\\n```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for(auto x: dict) buildTrie(x);\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        TrieNode* p = root;\\n        int diff = 0;\\n        for(int i = 0; i < word.size(); i++){\\n            char c = word[i];\\n            for(int j = 0; j < 26; j++){\\n                if(p->next[j] == p->next[c - 'a']) continue;\\n                if(p->next[j] && find(p->next[j], word.substr(i + 1))) return true;\\n            }\\n            if(p->next[c - 'a']) p = p->next[c - 'a'];\\n        }\\n        return false;\\n    }\\n\\nprivate:\\n    struct TrieNode{\\n        bool isWord;\\n        TrieNode* next[26];\\n        TrieNode():isWord(false){\\n            memset(next, NULL, sizeof(next));\\n        }\\n    };\\n    TrieNode* root;\\n    \\n    void buildTrie(string s){\\n        TrieNode* p = root;\\n        for(auto c: s){\\n            if(!p->next[c - 'a']) p->next[c - 'a'] = new TrieNode();\\n            p = p->next[c - 'a'];\\n        }\\n        p->isWord = true;\\n    }\\n    \\n    bool find(TrieNode* p, string s){\\n        for(auto c: s)\\n            if(p->next[c - 'a']) p = p->next[c - 'a'];\\n            else return false;\\n        return p->isWord;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {}\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for(auto x: dict) m[x.size()].push_back(x);\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        for(auto x: m[word.size()])\\n            if(oneEditDistance(x, word)) return true;\\n        return false;\\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<string>>m;\\n    bool oneEditDistance(string& a, string& b){\\n        int diff = 0;\\n        for(int i = 0; i < a.size() && diff <= 1; i++)\\n            if(a[i] != b[i]) diff++;\\n        return diff == 1;\\n    }\\n};\\n```\n```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for(auto x: dict) buildTrie(x);\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        TrieNode* p = root;\\n        int diff = 0;\\n        for(int i = 0; i < word.size(); i++){\\n            char c = word[i];\\n            for(int j = 0; j < 26; j++){\\n                if(p->next[j] == p->next[c - 'a']) continue;\\n                if(p->next[j] && find(p->next[j], word.substr(i + 1))) return true;\\n            }\\n            if(p->next[c - 'a']) p = p->next[c - 'a'];\\n        }\\n        return false;\\n    }\\n\\nprivate:\\n    struct TrieNode{\\n        bool isWord;\\n        TrieNode* next[26];\\n        TrieNode():isWord(false){\\n            memset(next, NULL, sizeof(next));\\n        }\\n    };\\n    TrieNode* root;\\n    \\n    void buildTrie(string s){\\n        TrieNode* p = root;\\n        for(auto c: s){\\n            if(!p->next[c - 'a']) p->next[c - 'a'] = new TrieNode();\\n            p = p->next[c - 'a'];\\n        }\\n        p->isWord = true;\\n    }\\n    \\n    bool find(TrieNode* p, string s){\\n        for(auto c: s)\\n            if(p->next[c - 'a']) p = p->next[c - 'a'];\\n            else return false;\\n        return p->isWord;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107465,
                "title": "efficient-trie-and-java-8-w-explanation",
                "content": "The implementation is a simple Trie, with the method relaxedSearch.\\n\\nrelaxedSearch searches for a word, with one deviation from a normal trie.\\n\\nIf there is a match with the current character, it proceeds as usual in that branch.\\nBut for all the non matched characters, it still continues searching, by incrementing the changedTimes variable, which maintains how many times a character was changed in the word search from the root.\\n\\n\\nAny search that involves changedTimes > 1, is immediately terminated by returning false as we are allowed to change only one character.\\n\\nThe solution is reached, when we find word in the trie and the changedTimes is exactly == 1.\\n```\\nclass MagicDictionary {\\n\\n        Trie trie;\\n        public MagicDictionary() {\\n            trie = new Trie(256);\\n        }\\n\\n        public void buildDict(String[] dict) {\\n            Arrays.stream(dict).forEach(s -> trie.insert(s));\\n        }\\n\\n        public boolean search(String word) {\\n            return trie.relaxedSearch(word);\\n        }\\n\\n        class Trie {\\n            private int R;\\n            private TrieNode root;\\n\\n            public Trie(int R) {\\n                this.R = R;\\n                root = new TrieNode();\\n            }\\n            \\n            public boolean relaxedSearch(String word) {\\n                return relaxedSearch(root, word, 0);\\n            }\\n\\n            private boolean relaxedSearch(TrieNode root, String word, int changedTimes) {\\n                if (root == null || (!root.isWord && word.isEmpty()) || changedTimes > 1) return false;\\n                if (root.isWord && word.isEmpty()) return changedTimes == 1;\\n                return Arrays.stream(root.next).anyMatch(nextNode -> relaxedSearch(nextNode, word.substring(1),\\n                        root.next[word.charAt(0)] == nextNode ? changedTimes : changedTimes+1));\\n            }\\n\\n            // Inserts a word into the trie.\\n            public void insert(String word) {\\n                insert(root, word);\\n            }\\n\\n            private void insert(TrieNode root, String word) {\\n                if (word.isEmpty()) { root.isWord = true; return; }\\n                if (root.next[word.charAt(0)] == null) root.next[word.charAt(0)] = new TrieNode();\\n                insert(root.next[word.charAt(0)], word.substring(1));\\n            }\\n\\n            private class TrieNode {\\n                private TrieNode[] next = new TrieNode[R];\\n                private boolean isWord;\\n            }\\n\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n\\n        Trie trie;\\n        public MagicDictionary() {\\n            trie = new Trie(256);\\n        }\\n\\n        public void buildDict(String[] dict) {\\n            Arrays.stream(dict).forEach(s -> trie.insert(s));\\n        }\\n\\n        public boolean search(String word) {\\n            return trie.relaxedSearch(word);\\n        }\\n\\n        class Trie {\\n            private int R;\\n            private TrieNode root;\\n\\n            public Trie(int R) {\\n                this.R = R;\\n                root = new TrieNode();\\n            }\\n            \\n            public boolean relaxedSearch(String word) {\\n                return relaxedSearch(root, word, 0);\\n            }\\n\\n            private boolean relaxedSearch(TrieNode root, String word, int changedTimes) {\\n                if (root == null || (!root.isWord && word.isEmpty()) || changedTimes > 1) return false;\\n                if (root.isWord && word.isEmpty()) return changedTimes == 1;\\n                return Arrays.stream(root.next).anyMatch(nextNode -> relaxedSearch(nextNode, word.substring(1),\\n                        root.next[word.charAt(0)] == nextNode ? changedTimes : changedTimes+1));\\n            }\\n\\n            // Inserts a word into the trie.\\n            public void insert(String word) {\\n                insert(root, word);\\n            }\\n\\n            private void insert(TrieNode root, String word) {\\n                if (word.isEmpty()) { root.isWord = true; return; }\\n                if (root.next[word.charAt(0)] == null) root.next[word.charAt(0)] = new TrieNode();\\n                insert(root.next[word.charAt(0)], word.substring(1));\\n            }\\n\\n            private class TrieNode {\\n                private TrieNode[] next = new TrieNode[R];\\n                private boolean isWord;\\n            }\\n\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900829,
                "title": "python-solve-this-question-in-real-interview-with-video-explanation",
                "content": "My step by step approach to solve this question like in real interview with video explanation:\\nhttps://youtu.be/zjnb7QUZMPQ\\n\\nIntuition: Hahsmap / Looping\\n\\n**Code**\\n```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.m = collections.defaultdict(list)\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.m[len(word)] += [word]\\n        \\n    def search(self, searchWord: str) -> bool:\\n        if len(searchWord) not in self.m: return False\\n        wordList = self.m[len(searchWord)]\\n        \\n        for word in wordList:\\n            cnt = 0\\n            for i in range(len(searchWord)):\\n                if searchWord[i] != word[i]: cnt += 1\\n                if cnt > 1: break\\n            if cnt == 1: return True           \\n        return False\\n```\\n\\nTime Complexity: O(m*n)\\nSpace Complexity: O(m)\\n\\nFeel free to subscribe to my channel. More LeetCoding videos coming up!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.m = collections.defaultdict(list)\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.m[len(word)] += [word]\\n        \\n    def search(self, searchWord: str) -> bool:\\n        if len(searchWord) not in self.m: return False\\n        wordList = self.m[len(searchWord)]\\n        \\n        for word in wordList:\\n            cnt = 0\\n            for i in range(len(searchWord)):\\n                if searchWord[i] != word[i]: cnt += 1\\n                if cnt > 1: break\\n            if cnt == 1: return True           \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726850,
                "title": "c-simple-easy-solution-using-trie",
                "content": "```\\nclass TrieNode {\\npublic:\\n    TrieNode *children[26];\\n    bool is_terminal;\\n    \\n    TrieNode() {\\n        for(int i=0;i<26;++i) {\\n            children[i]=NULL;\\n        }\\n        is_terminal=false;\\n    }\\n};\\n\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    TrieNode *root=new TrieNode();\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void insert(string s) {\\n        TrieNode *temp=root;\\n        for(char c: s) {\\n            int idx=c-\\'a\\';\\n            if(temp->children[idx]==NULL) {\\n                temp->children[idx]=new TrieNode();\\n            }\\n            temp=temp->children[idx];\\n        }\\n        temp->is_terminal=true;\\n    }\\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for(string s: dict) {\\n            insert(s);\\n        }\\n    }\\n    \\n    bool find(string s) {\\n        TrieNode *temp=root;\\n        for(char c: s) {\\n            int idx=c-\\'a\\';\\n            if(temp->children[idx]==NULL) {\\n                return false;\\n            }\\n            temp=temp->children[idx];\\n        }\\n        if(temp->is_terminal==true) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string s) {\\n        for(int i=0;i<s.length();++i){\\n            for(int j=0;j<26;++j) {\\n                char c=j+\\'a\\';\\n                if(c==s[i]) continue;\\n                swap(s[i],c);\\n                if(find(s)) {\\n                    return true;\\n                }\\n                swap(s[i],c);  //Backtrack\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dict);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n    TrieNode *children[26];\\n    bool is_terminal;\\n    \\n    TrieNode() {\\n        for(int i=0;i<26;++i) {\\n            children[i]=NULL;\\n        }\\n        is_terminal=false;\\n    }\\n};\\n\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    TrieNode *root=new TrieNode();\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void insert(string s) {\\n        TrieNode *temp=root;\\n        for(char c: s) {\\n            int idx=c-\\'a\\';\\n            if(temp->children[idx]==NULL) {\\n                temp->children[idx]=new TrieNode();\\n            }\\n            temp=temp->children[idx];\\n        }\\n        temp->is_terminal=true;\\n    }\\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for(string s: dict) {\\n            insert(s);\\n        }\\n    }\\n    \\n    bool find(string s) {\\n        TrieNode *temp=root;\\n        for(char c: s) {\\n            int idx=c-\\'a\\';\\n            if(temp->children[idx]==NULL) {\\n                return false;\\n            }\\n            temp=temp->children[idx];\\n        }\\n        if(temp->is_terminal==true) {\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string s) {\\n        for(int i=0;i<s.length();++i){\\n            for(int j=0;j<26;++j) {\\n                char c=j+\\'a\\';\\n                if(c==s[i]) continue;\\n                swap(s[i],c);\\n                if(find(s)) {\\n                    return true;\\n                }\\n                swap(s[i],c);  //Backtrack\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dict);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793365,
                "title": "python-3-trie-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*K)$$ with N is the number of word and K is length of each word\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*K)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TrieNode:\\n\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_end = False\\n\\n\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.trie = TrieNode()\\n        self.s = set()\\n        \\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.s.add(word)\\n            cur = self.trie\\n            for ch in word:\\n                cur = cur.children[ch]\\n            cur.is_end = True\\n        \\n\\n    def search(self, searchWord: str) -> bool:\\n        n = len(searchWord)\\n        def dfs(root: TrieNode, cnt: int, i: int) -> bool:\\n            if cnt > 1 or i == n: return cnt == 1 and root.is_end\\n            return any([dfs(root.children[c], cnt + int(c != searchWord[i]), i + 1) for c in root.children])\\n        \\n        return dfs(self.trie, 0, 0)\\n\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dictionary)\\n# param_2 = obj.search(searchWord)\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_end = False\\n\\n\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.trie = TrieNode()\\n        self.s = set()\\n        \\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.s.add(word)\\n            cur = self.trie\\n            for ch in word:\\n                cur = cur.children[ch]\\n            cur.is_end = True\\n        \\n\\n    def search(self, searchWord: str) -> bool:\\n        n = len(searchWord)\\n        def dfs(root: TrieNode, cnt: int, i: int) -> bool:\\n            if cnt > 1 or i == n: return cnt == 1 and root.is_end\\n            return any([dfs(root.children[c], cnt + int(c != searchWord[i]), i + 1) for c in root.children])\\n        \\n        return dfs(self.trie, 0, 0)\\n\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dictionary)\\n# param_2 = obj.search(searchWord)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424668,
                "title": "2-solution-beginner-friendly-set-and-simple-array-using-zip-python3",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- 1. Array and Zip \\n- 2. Set method\\n\\n# Complexity\\n\\n-  Array and Zip\\n    - Time complexity: O(n * m)\\n\\n    - Space complexity: O(n + m)\\n- Set \\n    - Time complexity: O(26M) \\n\\n    - Space complexity: O(n * m)\\n\\n# 1. Simple Array and zip method\\n```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.dict = []\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for ch in dictionary:\\n            self.dict.append((ch))\\n                \\n\\n    def search(self, searchWord: str) -> bool:\\n        for word in self.dict:\\n            if len(word) == len(searchWord) and sum(c1 != c2 for c1, c2 in zip(word, searchWord)) == 1:  return True\\n        return False\\n```\\n- explaination of if statement in Search()\\n```\\nfor word in self.dict:\\n    count = 0\\n    for c1, c2 in zip(word, searchWord): #if word is \\'hello\\' and searchWord is \\'hhllo\\', zip(word, searchWord) would produce ->\\n        if c1 != c2:                     #(\\'h\\', \\'h\\'), (\\'e\\', \\'h\\'), (\\'l\\', \\'l\\'), (\\'l\\', \\'l\\'), (\\'o\\', \\'o\\')\\n            count += 1\\n\\n    if count == 1: return True\\n    else: return False\\n\\n\\n```\\n\\n# 2 . Set method\\n```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.words = set()\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.words = set(dictionary)\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in range(len(searchWord)):\\n            for char in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                if char == searchWord[i]:\\n                    continue\\n                replaced_word = searchWord[:i] + char + searchWord[i + 1:]\\n                if replaced_word in self.words:\\n                    return True\\n        return False\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.dict = []\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for ch in dictionary:\\n            self.dict.append((ch))\\n                \\n\\n    def search(self, searchWord: str) -> bool:\\n        for word in self.dict:\\n            if len(word) == len(searchWord) and sum(c1 != c2 for c1, c2 in zip(word, searchWord)) == 1:  return True\\n        return False\\n```\n```\\nfor word in self.dict:\\n    count = 0\\n    for c1, c2 in zip(word, searchWord): #if word is \\'hello\\' and searchWord is \\'hhllo\\', zip(word, searchWord) would produce ->\\n        if c1 != c2:                     #(\\'h\\', \\'h\\'), (\\'e\\', \\'h\\'), (\\'l\\', \\'l\\'), (\\'l\\', \\'l\\'), (\\'o\\', \\'o\\')\\n            count += 1\\n\\n    if count == 1: return True\\n    else: return False\\n\\n\\n```\n```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.words = set()\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.words = set(dictionary)\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in range(len(searchWord)):\\n            for char in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                if char == searchWord[i]:\\n                    continue\\n                replaced_word = searchWord[:i] + char + searchWord[i + 1:]\\n                if replaced_word in self.words:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318784,
                "title": "676-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. __init__ method\\n    1. Create an empty dictionary to hold the words and their replacements.\\n    2. Store the dictionary in the class attribute self.dict.\\n2. buildDict method\\n    1. For each word in the dictionary argument:\\n        - For each index i in the range 0 to len(word):\\n            - Replace the character at index i with *.\\n            - Store the new string in a variable named replaced.\\n            - If replaced is already a key in the dictionary:\\n                - Append the original word to the list of words associated with the replaced key.\\n            - Otherwise, create a new key-value pair in the dictionary where the key is replaced and the value is a list containing word.\\n    2. Store the updated dictionary in the class attribute self.dict.\\n3. search method\\n1. For each index i in the range 0 to len(searchWord):\\n    1. Replace the character at index i with *.\\n    2. Store the new string in a variable named replaced.\\n    3. If replaced is a key in the dictionary:\\n        - Get the list of words associated with the replaced key.\\n        - For each word in the list:\\n            - If the word is not equal to searchWord and has the same length as searchWord:\\n                - Initialize a variable match to True.\\n                - For each index j in the range 0 to len(searchWord):\\n                    - If the characters at index j in searchWord and word are not equal and the character at index j in replaced is not *, set match to False and break out of the loop.\\n                - If match is still True after the loop, return True.\\n2. Return False if no matches were found.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MagicDictionary:\\n    def __init__(self):\\n        self.dict = {}\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            for i in range(len(word)):\\n                replaced = word[:i] + \\'*\\' + word[i+1:]\\n                if replaced in self.dict:\\n                    self.dict[replaced].append(word)\\n                else:\\n                    self.dict[replaced] = [word]\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in range(len(searchWord)):\\n            replaced = searchWord[:i] + \\'*\\' + searchWord[i+1:]\\n            if replaced in self.dict:\\n                words = self.dict[replaced]\\n                for word in words:\\n                    if word != searchWord and len(word) == len(searchWord):\\n                        match = True\\n                        for j in range(len(searchWord)):\\n                            if searchWord[j] != word[j] and replaced[j] != \\'*\\':\\n                                match = False\\n                                break\\n                        if match:\\n                            return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary:\\n    def __init__(self):\\n        self.dict = {}\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            for i in range(len(word)):\\n                replaced = word[:i] + \\'*\\' + word[i+1:]\\n                if replaced in self.dict:\\n                    self.dict[replaced].append(word)\\n                else:\\n                    self.dict[replaced] = [word]\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in range(len(searchWord)):\\n            replaced = searchWord[:i] + \\'*\\' + searchWord[i+1:]\\n            if replaced in self.dict:\\n                words = self.dict[replaced]\\n                for word in words:\\n                    if word != searchWord and len(word) == len(searchWord):\\n                        match = True\\n                        for j in range(len(searchWord)):\\n                            if searchWord[j] != word[j] and replaced[j] != \\'*\\':\\n                                match = False\\n                                break\\n                        if match:\\n                            return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694125,
                "title": "java-trie",
                "content": "```\\nclass MagicDictionary {\\n\\n    private class Node {\\n        Node[] links;\\n        boolean isEnd;\\n        Node() {\\n            links = new Node[26];\\n            isEnd = false;\\n        }\\n    }\\n    \\n    private Node root;\\n    public MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for (String str : dictionary) {\\n            insert(str);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        return searchUtil(root, searchWord, 0, false);\\n    }\\n    \\n    private void insert(String str) {\\n        Node curr = root;\\n        for (char c : str.toCharArray()) {\\n            int ascii = c - \\'a\\';\\n            if (curr.links[ascii] == null) \\n                curr.links[ascii] = new Node();\\n            curr = curr.links[ascii];\\n        }\\n        curr.isEnd = true;\\n    }\\n    \\n    private boolean searchUtil(Node curr, String str, int i, boolean flag) {\\n        if (i == str.length()) \\n            return (curr.isEnd && i == str.length() && flag);\\n        \\n        boolean ans = false;\\n        int ascii = str.charAt(i) - \\'a\\';\\n        if (!flag) {\\n            for (int ii = 0; ii < 26; ii++) {\\n                if (ii == ascii || curr.links[ii] == null)\\n                    continue;\\n                if (searchUtil(curr.links[ii], str, i + 1, true)) return true;\\n            }\\n        }\\n        if (curr.links[ascii] != null && searchUtil(curr.links[ascii], str, i + 1, flag))\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary {\\n\\n    private class Node {\\n        Node[] links;\\n        boolean isEnd;\\n        Node() {\\n            links = new Node[26];\\n            isEnd = false;\\n        }\\n    }\\n    \\n    private Node root;\\n    public MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for (String str : dictionary) {\\n            insert(str);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        return searchUtil(root, searchWord, 0, false);\\n    }\\n    \\n    private void insert(String str) {\\n        Node curr = root;\\n        for (char c : str.toCharArray()) {\\n            int ascii = c - \\'a\\';\\n            if (curr.links[ascii] == null) \\n                curr.links[ascii] = new Node();\\n            curr = curr.links[ascii];\\n        }\\n        curr.isEnd = true;\\n    }\\n    \\n    private boolean searchUtil(Node curr, String str, int i, boolean flag) {\\n        if (i == str.length()) \\n            return (curr.isEnd && i == str.length() && flag);\\n        \\n        boolean ans = false;\\n        int ascii = str.charAt(i) - \\'a\\';\\n        if (!flag) {\\n            for (int ii = 0; ii < 26; ii++) {\\n                if (ii == ascii || curr.links[ii] == null)\\n                    continue;\\n                if (searchUtil(curr.links[ii], str, i + 1, true)) return true;\\n            }\\n        }\\n        if (curr.links[ascii] != null && searchUtil(curr.links[ascii], str, i + 1, flag))\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735939,
                "title": "easiest-and-understandable-code",
                "content": "just change each word and check in trie\\nTIME COMPLEXITY(n*26*logm)\\n\\n```\\nclass MagicDictionary {\\n\\n    class Trie\\n    {\\n        boolean end;\\n        Trie node[]=new Trie[26];\\n        Trie()\\n        {\\n            end=false;\\n            for(int i=0;i<26;i++)\\n            {\\n                node[i]=null;\\n            }\\n        }\\n    }\\n   \\n   static Trie Dict;\\n    public MagicDictionary() \\n    {\\n        Dict=new Trie();\\n    }\\n    \\n    public void buildDict(String[] dictionary) \\n    {\\n        int m=dictionary.length;\\n        for(int j=0;j<m;j++)\\n        {\\n            String s=dictionary[j];\\n            Trie ap=Dict;\\n            int n=s.length();\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ap.node[s.charAt(i)-\\'a\\']==null)\\n                {\\n                    Trie newnode=new Trie();\\n                    ap.node[s.charAt(i)-\\'a\\']=newnode;\\n                }\\n                ap=ap.node[s.charAt(i)-\\'a\\'];\\n            }\\n\\n            ap.end=true;\\n        }\\n    }\\n    public static boolean check(char ch[])\\n    {\\n        Trie check1=Dict;\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(check1.node[ch[i]-\\'a\\']!=null)\\n            {\\n                check1=check1.node[ch[i]-\\'a\\'];\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if(check1.end==true)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public boolean search(String searchWord)\\n    {\\n        int n=searchWord.length();\\n        char ch[]=searchWord.toCharArray();\\n        for(int i=0;i<n;i++)\\n        {\\n         for(int j=0;j<26;j++)\\n           {\\n             if(ch[i]==(j+97))\\n             {\\n               continue;      \\n             }\\n             char op=ch[i];\\n             ch[i]=(char)(j+97);\\n             if(check(ch))\\n             {\\n                 return true;\\n             }\\n             ch[i]=op;\\n           }\\n             \\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```\\n\\n\\n**PLS UPVOTE IF U LIKE THE SOLUTION**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary {\\n\\n    class Trie\\n    {\\n        boolean end;\\n        Trie node[]=new Trie[26];\\n        Trie()\\n        {\\n            end=false;\\n            for(int i=0;i<26;i++)\\n            {\\n                node[i]=null;\\n            }\\n        }\\n    }\\n   \\n   static Trie Dict;\\n    public MagicDictionary() \\n    {\\n        Dict=new Trie();\\n    }\\n    \\n    public void buildDict(String[] dictionary) \\n    {\\n        int m=dictionary.length;\\n        for(int j=0;j<m;j++)\\n        {\\n            String s=dictionary[j];\\n            Trie ap=Dict;\\n            int n=s.length();\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ap.node[s.charAt(i)-\\'a\\']==null)\\n                {\\n                    Trie newnode=new Trie();\\n                    ap.node[s.charAt(i)-\\'a\\']=newnode;\\n                }\\n                ap=ap.node[s.charAt(i)-\\'a\\'];\\n            }\\n\\n            ap.end=true;\\n        }\\n    }\\n    public static boolean check(char ch[])\\n    {\\n        Trie check1=Dict;\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(check1.node[ch[i]-\\'a\\']!=null)\\n            {\\n                check1=check1.node[ch[i]-\\'a\\'];\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if(check1.end==true)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public boolean search(String searchWord)\\n    {\\n        int n=searchWord.length();\\n        char ch[]=searchWord.toCharArray();\\n        for(int i=0;i<n;i++)\\n        {\\n         for(int j=0;j<26;j++)\\n           {\\n             if(ch[i]==(j+97))\\n             {\\n               continue;      \\n             }\\n             char op=ch[i];\\n             ch[i]=(char)(j+97);\\n             if(check(ch))\\n             {\\n                 return true;\\n             }\\n             ch[i]=op;\\n           }\\n             \\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370321,
                "title": "c-easy-to-understand-trie-solution",
                "content": "\\tstruct node {\\n\\t\\t\\tint count;\\n\\t\\t\\tint ew;\\n\\t\\t\\tnode* ar[26];\\n\\t\\t};\\n\\t\\tnode* getNode() {\\n\\t\\t\\tnode* n=new node();\\n\\t\\t\\tn->ew=0; \\n\\t\\t\\tfor(int i=0;i<26;i++) n->ar[i]=NULL;\\n\\t\\t\\tn->count=0;\\n\\t\\t\\treturn n;\\n\\t\\t}\\n\\t\\tvoid insert(node* root,string s) {\\n\\t\\t\\tnode* temp=root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tint j=s[i]-\\'a\\';\\n\\t\\t\\t\\tif(temp->ar[j]==NULL) temp->ar[j]=getNode();\\n\\t\\t\\t\\ttemp=temp->ar[j]; temp->count++;\\n\\t\\t\\t}\\n\\t\\t\\ttemp->ew++;\\n\\t\\t}\\n\\t\\tbool find(node* root,string s) {\\n\\t\\t\\tnode* temp=root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tint j=s[i]-\\'a\\';\\n\\t\\t\\t\\tif(temp->ar[j]==NULL) return false;\\n\\t\\t\\t\\ttemp=temp->ar[j]; \\n\\t\\t\\t}\\n\\t\\t\\tif(temp->ew>=1) return true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tnode* root;\\n\\t\\tMagicDictionary() {\\n\\t\\t\\troot=getNode();\\n\\t\\t}\\n\\n\\t\\tvoid buildDict(vector<string> dictionary) {\\n\\t\\t\\tfor(auto s: dictionary) insert(root,s);\\n\\t\\t}\\n\\n\\t\\tbool search(string s) {\\n\\n\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\tfor(int j=0;j<26;j++) {\\n\\t\\t\\t\\tchar c=(char)(j+\\'a\\');\\n\\t\\t\\t\\tchar t=s[i];\\n\\t\\t\\t\\tif(s[i]==c) continue;\\n\\t\\t\\t\\ts[i]=c;\\n\\n\\t\\t\\t\\tif(find(root,s)) { return true; }\\n\\t\\t\\t\\ts[i]=t;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "\\tstruct node {\\n\\t\\t\\tint count;\\n\\t\\t\\tint ew;\\n\\t\\t\\tnode* ar[26];\\n\\t\\t};\\n\\t\\tnode* getNode() {\\n\\t\\t\\tnode* n=new node();\\n\\t\\t\\tn->ew=0; \\n\\t\\t\\tfor(int i=0;i<26;i++) n->ar[i]=NULL;\\n\\t\\t\\tn->count=0;\\n\\t\\t\\treturn n;\\n\\t\\t}\\n\\t\\tvoid insert(node* root,string s) {\\n\\t\\t\\tnode* temp=root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tint j=s[i]-\\'a\\';\\n\\t\\t\\t\\tif(temp->ar[j]==NULL) temp->ar[j]=getNode();\\n\\t\\t\\t\\ttemp=temp->ar[j]; temp->count++;\\n\\t\\t\\t}\\n\\t\\t\\ttemp->ew++;\\n\\t\\t}\\n\\t\\tbool find(node* root,string s) {\\n\\t\\t\\tnode* temp=root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tint j=s[i]-\\'a\\';\\n\\t\\t\\t\\tif(temp->ar[j]==NULL) return false;\\n\\t\\t\\t\\ttemp=temp->ar[j]; \\n\\t\\t\\t}\\n\\t\\t\\tif(temp->ew>=1) return true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tnode* root;\\n\\t\\tMagicDictionary() {\\n\\t\\t\\troot=getNode();\\n\\t\\t}\\n\\n\\t\\tvoid buildDict(vector<string> dictionary) {\\n\\t\\t\\tfor(auto s: dictionary) insert(root,s);\\n\\t\\t}\\n\\n\\t\\tbool search(string s) {\\n\\n\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\tfor(int j=0;j<26;j++) {\\n\\t\\t\\t\\tchar c=(char)(j+\\'a\\');\\n\\t\\t\\t\\tchar t=s[i];\\n\\t\\t\\t\\tif(s[i]==c) continue;\\n\\t\\t\\t\\ts[i]=c;\\n\\n\\t\\t\\t\\tif(find(root,s)) { return true; }\\n\\t\\t\\t\\ts[i]=t;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1049164,
                "title": "java-trie-builddict-o-dictionary-length-dictionary-i-length-search-o-26-word-length",
                "content": "public class Trie {\\n\\n\\tprivate class Node {\\n\\n\\t\\tchar data;\\n\\t\\tNode[] children;\\n\\t\\tboolean isTerminal;\\n\\n\\t\\tpublic Node(char data, boolean isTerminal) {\\n\\t\\t\\tthis.data = data;\\n\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\tthis.children = new Node[26];\\n\\t\\t}\\n\\n\\t}\\n\\n\\tprivate Node root;\\n\\n\\t// O(1)\\n\\tpublic Trie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\', false);\\n\\t}\\n\\n\\t// O(word.length)\\n\\tpublic void addWord(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\ttemp = new Node(ch, false);\\n\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t}\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\tcurr.isTerminal = true;\\n\\t}\\n\\n\\t// O(word.length)\\n\\tpublic boolean searchWord(String word) {\\n\\t\\treturn searchWord(root, word, 0, 0);\\n\\t}\\n\\n\\t// O(word.length)\\n\\tprivate boolean searchWord(Node root, String word, int count, int vidx) {\\n\\n\\t\\tif (count == 2)\\n\\t\\t\\treturn false;\\n\\n\\t\\tif (vidx == word.length())\\n\\t\\t\\t\\treturn (count == 1 && root.isTerminal) ? true : false;\\n            \\n\\t\\tchar ch = word.charAt(vidx);\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif (root.children[i] != null) {\\n\\t\\t\\t\\tchar temp = (char) (i + \\'a\\');\\n\\t\\t\\t\\tint ncount = (ch == temp) ? count : count + 1;\\n\\t\\t\\t\\tif (searchWord(root.children[i], word, ncount, vidx + 1))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n}\\n\\nclass MagicDictionary {\\n\\n\\tTrie trie;\\n\\n\\t// O(1)\\n\\tpublic MagicDictionary() {\\n\\t\\ttrie = new Trie();\\n\\t}\\n\\n\\t// O(dictionary.length*dictionary[i].length)\\n\\tpublic void buildDict(String[] dictionary) {\\n\\t\\tfor (String word : dictionary)\\n\\t\\t\\ttrie.addWord(word);\\n\\t}\\n\\n\\t// O(word.length)\\n\\tpublic boolean search(String searchWord) {\\n\\t\\treturn trie.searchWord(searchWord);\\n\\t}\\n}\\n",
                "solutionTags": [],
                "code": "public class Trie {\\n\\n\\tprivate class Node {\\n\\n\\t\\tchar data;\\n\\t\\tNode[] children;\\n\\t\\tboolean isTerminal;\\n\\n\\t\\tpublic Node(char data, boolean isTerminal) {\\n\\t\\t\\tthis.data = data;\\n\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\tthis.children = new Node[26];\\n\\t\\t}\\n\\n\\t}\\n\\n\\tprivate Node root;\\n\\n\\t// O(1)\\n\\tpublic Trie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\', false);\\n\\t}\\n\\n\\t// O(word.length)\\n\\tpublic void addWord(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\ttemp = new Node(ch, false);\\n\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t}\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\tcurr.isTerminal = true;\\n\\t}\\n\\n\\t// O(word.length)\\n\\tpublic boolean searchWord(String word) {\\n\\t\\treturn searchWord(root, word, 0, 0);\\n\\t}\\n\\n\\t// O(word.length)\\n\\tprivate boolean searchWord(Node root, String word, int count, int vidx) {\\n\\n\\t\\tif (count == 2)\\n\\t\\t\\treturn false;\\n\\n\\t\\tif (vidx == word.length())\\n\\t\\t\\t\\treturn (count == 1 && root.isTerminal) ? true : false;\\n            \\n\\t\\tchar ch = word.charAt(vidx);\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif (root.children[i] != null) {\\n\\t\\t\\t\\tchar temp = (char) (i + \\'a\\');\\n\\t\\t\\t\\tint ncount = (ch == temp) ? count : count + 1;\\n\\t\\t\\t\\tif (searchWord(root.children[i], word, ncount, vidx + 1))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n}\\n\\nclass MagicDictionary {\\n\\n\\tTrie trie;\\n\\n\\t// O(1)\\n\\tpublic MagicDictionary() {\\n\\t\\ttrie = new Trie();\\n\\t}\\n\\n\\t// O(dictionary.length*dictionary[i].length)\\n\\tpublic void buildDict(String[] dictionary) {\\n\\t\\tfor (String word : dictionary)\\n\\t\\t\\ttrie.addWord(word);\\n\\t}\\n\\n\\t// O(word.length)\\n\\tpublic boolean search(String searchWord) {\\n\\t\\treturn trie.searchWord(searchWord);\\n\\t}\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 922339,
                "title": "very-simple-python-solution-using-set",
                "content": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.myDict=set()\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.myDict.add(word)\\n\\n    def search(self, searchWord: str) -> bool:\\n        \\n        for word in self.myDict:\\n            if len(word)==len(searchWord) and word!=searchWord:\\n                changes=0\\n                for l1,l2 in zip(searchWord,word):\\n                    if l1!=l2:\\n                        changes+=1\\n                    if changes>1:\\n                        break\\n                if changes==1:\\n                    return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.myDict=set()\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.myDict.add(word)\\n\\n    def search(self, searchWord: str) -> bool:\\n        \\n        for word in self.myDict:\\n            if len(word)==len(searchWord) and word!=searchWord:\\n                changes=0\\n                for l1,l2 in zip(searchWord,word):\\n                    if l1!=l2:\\n                        changes+=1\\n                    if changes>1:\\n                        break\\n                if changes==1:\\n                    return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766741,
                "title": "python-trie-solution",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.isWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self,word):\\n        node = self.root\\n        for w in word:\\n            node = node.children[w]\\n        node.isWord = True\\n    \\n    def search(self,word,k,node):\\n        if not word:\\n            return k == 0 and node.isWord\\n        for r in node.children:\\n            if r == word[0]:\\n                if self.search(word[1:],k,node.children[r]):\\n                    return True\\n            elif k == 1:\\n                if self.search(word[1:],k-1,node.children[r]):\\n                    return True\\n        return False\\n        \\nclass MagicDictionary:\\n    def __init__(self):\\n        self.t = Trie()\\n\\n    def buildDict(self, dic: List[str]) -> None:\\n        for words in dic:\\n            self.t.insert(words)\\n\\n    def search(self, word: str) -> bool:\\n        node = self.t.root\\n        return self.t.search(word,1,node)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.isWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self,word):\\n        node = self.root\\n        for w in word:\\n            node = node.children[w]\\n        node.isWord = True\\n    \\n    def search(self,word,k,node):\\n        if not word:\\n            return k == 0 and node.isWord\\n        for r in node.children:\\n            if r == word[0]:\\n                if self.search(word[1:],k,node.children[r]):\\n                    return True\\n            elif k == 1:\\n                if self.search(word[1:],k-1,node.children[r]):\\n                    return True\\n        return False\\n        \\nclass MagicDictionary:\\n    def __init__(self):\\n        self.t = Trie()\\n\\n    def buildDict(self, dic: List[str]) -> None:\\n        for words in dic:\\n            self.t.insert(words)\\n\\n    def search(self, word: str) -> bool:\\n        node = self.t.root\\n        return self.t.search(word,1,node)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648169,
                "title": "java-trie",
                "content": "```\\nclass MagicDictionary {\\n    public class Node{\\n        boolean isW;\\n        Node[] nodes;\\n        public Node() {\\n            nodes = new Node[26];\\n            isW = false;\\n        }\\n    }\\n    \\n    Node root;\\n\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String w : dict) {\\n            Node curr = root;\\n            for (char c : w.toCharArray()) {\\n                if (curr.nodes[c - \\'a\\'] == null) {\\n                    curr.nodes[c - \\'a\\'] = new Node();\\n                }\\n                curr = curr.nodes[c - \\'a\\'];\\n            }\\n            curr.isW = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        char[] arr = word.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            char c = arr[i];\\n            for (int j = 0; j < 26; j++) {\\n                if (j == (c - \\'a\\')) continue;\\n                arr[i] = (char) (\\'a\\' + j);\\n                if (isW(arr)) return true;\\n            }\\n            arr[i] = c;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isW(char[] arr) {\\n        Node curr = root;\\n        for (char c : arr) {\\n            if (curr.nodes[c - \\'a\\'] == null) {\\n                return false;\\n            }\\n            curr = curr.nodes[c - \\'a\\'];\\n        }\\n        return curr.isW;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n    public class Node{\\n        boolean isW;\\n        Node[] nodes;\\n        public Node() {\\n            nodes = new Node[26];\\n            isW = false;\\n        }\\n    }\\n    \\n    Node root;\\n\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String w : dict) {\\n            Node curr = root;\\n            for (char c : w.toCharArray()) {\\n                if (curr.nodes[c - \\'a\\'] == null) {\\n                    curr.nodes[c - \\'a\\'] = new Node();\\n                }\\n                curr = curr.nodes[c - \\'a\\'];\\n            }\\n            curr.isW = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        char[] arr = word.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            char c = arr[i];\\n            for (int j = 0; j < 26; j++) {\\n                if (j == (c - \\'a\\')) continue;\\n                arr[i] = (char) (\\'a\\' + j);\\n                if (isW(arr)) return true;\\n            }\\n            arr[i] = c;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean isW(char[] arr) {\\n        Node curr = root;\\n        for (char c : arr) {\\n            if (curr.nodes[c - \\'a\\'] == null) {\\n                return false;\\n            }\\n            curr = curr.nodes[c - \\'a\\'];\\n        }\\n        return curr.isW;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356884,
                "title": "python-modified-search-in-trie-o-al-search",
                "content": "```python\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.nxts = dict()\\n        self.isword = False\\n        \\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.nxts:\\n                cur.nxts[c] = TrieNode()\\n            cur = cur.nxts[c]\\n        cur.isword = True\\n\\n    def search(self, word, i, skipn):\\n        if i == len(word):\\n            return self.isword and skipn == 1\\n    \\n        if skipn == 1:\\n            if word[i] not in self.nxts:\\n                return False\\n            return self.nxts[word[i]].search(word, i+1, skipn)\\n        \\n        for c in self.nxts:\\n            if self.nxts[c].search(word, i+1, skipn + int(c != word[i])):\\n                return True\\n        return False\\n            \\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        \\n\\n    def buildDict(self, dict):\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        :type dict: List[str]\\n        :rtype: None\\n        \"\"\"\\n        self.trie = TrieNode()\\n        for word in dict:\\n            self.trie.insert(word)\\n        \\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        return self.trie.search(word, 0, 0)\\n\\n\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dict)\\n# param_2 = obj.search(word)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.nxts = dict()\\n        self.isword = False\\n        \\n    def insert(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.nxts:\\n                cur.nxts[c] = TrieNode()\\n            cur = cur.nxts[c]\\n        cur.isword = True\\n\\n    def search(self, word, i, skipn):\\n        if i == len(word):\\n            return self.isword and skipn == 1\\n    \\n        if skipn == 1:\\n            if word[i] not in self.nxts:\\n                return False\\n            return self.nxts[word[i]].search(word, i+1, skipn)\\n        \\n        for c in self.nxts:\\n            if self.nxts[c].search(word, i+1, skipn + int(c != word[i])):\\n                return True\\n        return False\\n            \\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        \\n\\n    def buildDict(self, dict):\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        :type dict: List[str]\\n        :rtype: None\\n        \"\"\"\\n        self.trie = TrieNode()\\n        for word in dict:\\n            self.trie.insert(word)\\n        \\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        return self.trie.search(word, 0, 0)\\n\\n\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dict)\\n# param_2 = obj.search(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052241,
                "title": "my-fast-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thoughts on how to solve this problem is to create a data structure that stores all the words in the dictionary. Then, when searching for a word, I will iterate through each word in the data structure and compare it to the search word. If the two words have a difference of only one character, I will return true.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach I will take is to first create a data structure to store the dictionary words, in this case a set. Then, I will implement the search function which will iterate through each word in the data structure and compare it to the search word. If the two words have a difference of only one character, the function will return true, otherwise it will return false.\\n\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dic = set()\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.dic = set(dictionary)\\n\\n    def search(self, searchWord: str) -> bool:\\n        for word in self.dic:\\n            if len(word) == len(searchWord):\\n                diff = 0\\n                for i in range(len(word)):\\n                    if word[i] != searchWord[i]:\\n                        diff += 1\\n                if diff == 1:\\n                    return True\\n        return False\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dictionary)\\n# param_2 = obj.search(searchWord)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dic = set()\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.dic = set(dictionary)\\n\\n    def search(self, searchWord: str) -> bool:\\n        for word in self.dic:\\n            if len(word) == len(searchWord):\\n                diff = 0\\n                for i in range(len(word)):\\n                    if word[i] != searchWord[i]:\\n                        diff += 1\\n                if diff == 1:\\n                    return True\\n        return False\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dictionary)\\n# param_2 = obj.search(searchWord)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046271,
                "title": "easy-c-code-using-trie-data-structure",
                "content": "\\n\\n# Code\\n```\\nclass Trie{\\n    public:\\n    Trie* child[26];\\n    bool isEnd;\\n    Trie(){\\n        for(int i=0;i<26;i++){\\n            child[i]=NULL;\\n        }\\n        isEnd=false; \\n    }\\n};\\nclass MagicDictionary {\\npublic:\\n    Trie* root=new Trie();\\n    MagicDictionary() {\\n            \\n    }    \\n    \\n    void buildDict(vector<string> dictionary) {\\n        \\n        for(int i=0;i<dictionary.size();i++){\\n            Trie* curr=root;\\n            string temp=dictionary[i];\\n            for(int j=0;j<temp.length();j++){\\n                int idx=temp[j]-97;\\n                if(curr->child[idx]==NULL){\\n                    curr->child[idx]=new Trie();\\n                }\\n                curr=curr->child[idx];\\n            }\\n            curr->isEnd=true;\\n        }\\n        \\n    }\\n    bool check(string searchWord) {\\n        Trie* curr=root;\\n        for(int i=0;i<searchWord.length();i++){\\n            int idx=searchWord[i]-97;\\n            if(curr->child[idx]==NULL){\\n                return false;\\n            }\\n            curr=curr->child[idx];\\n            \\n        }\\n        \\n        return curr->isEnd;\\n\\n    }\\n    \\n  \\n    bool search(string sword) {\\n        int n=sword.size();\\n        string word=sword;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(\\'a\\'+j==sword[i])\\n                    continue;\\n                word[i]=\\'a\\'+j;\\n                if(check(word))\\n                    return true;\\n            }\\n            word[i]=sword[i];\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Trie{\\n    public:\\n    Trie* child[26];\\n    bool isEnd;\\n    Trie(){\\n        for(int i=0;i<26;i++){\\n            child[i]=NULL;\\n        }\\n        isEnd=false; \\n    }\\n};\\nclass MagicDictionary {\\npublic:\\n    Trie* root=new Trie();\\n    MagicDictionary() {\\n            \\n    }    \\n    \\n    void buildDict(vector<string> dictionary) {\\n        \\n        for(int i=0;i<dictionary.size();i++){\\n            Trie* curr=root;\\n            string temp=dictionary[i];\\n            for(int j=0;j<temp.length();j++){\\n                int idx=temp[j]-97;\\n                if(curr->child[idx]==NULL){\\n                    curr->child[idx]=new Trie();\\n                }\\n                curr=curr->child[idx];\\n            }\\n            curr->isEnd=true;\\n        }\\n        \\n    }\\n    bool check(string searchWord) {\\n        Trie* curr=root;\\n        for(int i=0;i<searchWord.length();i++){\\n            int idx=searchWord[i]-97;\\n            if(curr->child[idx]==NULL){\\n                return false;\\n            }\\n            curr=curr->child[idx];\\n            \\n        }\\n        \\n        return curr->isEnd;\\n\\n    }\\n    \\n  \\n    bool search(string sword) {\\n        int n=sword.size();\\n        string word=sword;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(\\'a\\'+j==sword[i])\\n                    continue;\\n                word[i]=\\'a\\'+j;\\n                if(check(word))\\n                    return true;\\n            }\\n            word[i]=sword[i];\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818128,
                "title": "c-trie-dfs-o-n-easy-to-read",
                "content": "**Explanation:**\\n\\nHow to Implement Trie ?\\n\\nCheck this problem: 208 Implement Trie (Prefix Tree)[Link](https://leetcode.com/problems/implement-trie-prefix-tree/)\\n\\n\\nContinue....\\n\\nPattern = Variation of Trie.\\n\\n- Insert is same.\\n\\n- In search, we must perform one mismatch. Same word can not return true.\\n\\n    Example.. \"hello\" -> \"hello\" return false.\\n              \"hello\" -> \"hallo\" return true.\\n\\nWe perform the Trie Traversal with DFS(for one mismatch).\\n\\nCheck the below code.\\n\\n\\n```\\n// Trie Node.\\nstruct Node {\\n\\n    Node* links[26];\\n    bool endOfWord = false;\\n\\n    void put(char ch, Node* node) {\\n        links[ch-\\'a\\'] = node;\\n    }\\n\\n    Node* get(char ch) {\\n        return links[ch-\\'a\\'];\\n    }\\n\\n    bool contains(char ch) {\\n        return links[ch-\\'a\\'] != NULL;\\n    }\\n\\n    void setEndOfWord() {\\n        endOfWord = true;\\n    }\\n\\n    bool isEndOfWord() {\\n        return endOfWord;\\n    }\\n};\\n\\n\\n\\nclass MagicDictionary {\\n\\npublic:\\n\\n    MagicDictionary() {\\n        // Initialize the root node.\\n        root = new Node();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n\\n        // Add all the words into trie.\\n        for(string word: dictionary){\\n            insert(word);\\n        }\\n    }\\n    \\n    bool searchSupport(string s, int index, Node* node, bool allowedOnce) {\\n        \\n        // Base case. Found NULL, It can not be EndOfWord.\\n        if(node == NULL)\\n            return false;\\n\\n\\n        for(int i = index; i < s.size(); i++) {\\n            \\n            // allowedOnce is set then we try all characters for current s[i].\\n            if(allowedOnce) {\\n\\n                for(char p = \\'a\\'; p <= \\'z\\'; p++) {\\n                        \\n                    // allowedOnce is depend, s[i] and p is same or not.\\n                    // If same, then allowedOnce = true else false.\\n                    if(searchSupport(s, i+1, node->get(p), s[i]==p)) {\\n                        return true;\\n                    }\\n                }\\n\\n                // Try all characters but did not find the end of word. Return false.\\n                return false;\\n            }\\n                \\n            // allowedOnce = false, then node must contains s[i].\\n            if(!node->contains(s[i]))\\n                return false;\\n\\n            // Move to next Node.\\n            node = node->get(s[i]);\\n        }\\n        \\n        // node is EndOfWord and allowedOnce == false(one mismatch) then we return true.\\n        if(node != NULL && !allowedOnce && node->isEndOfWord())\\n            return true;\\n\\n        return false;\\n    }\\n\\n\\n    bool search(string searchWord) {\\n        return searchSupport(searchWord, 0, root, true);\\n    }\\n\\nprivate:\\n\\n    Node* root;\\n\\n    void insert(string word) {\\n        Node* node = root;\\n        for(char ch: word) {\\n            if(!node->contains(ch)) {\\n                node->put(ch, new Node());\\n            }\\n            node = node->get(ch);\\n        }\\n        node->setEndOfWord();\\n    }\\n\\n};\\n\\n```\\n\\n\\n**Approach and Time Complexity:**\\n\\nN = number of words\\nL = length of word\\nk = 26\\n\\n1) Trie\\nTime: O(N*L*K) = O(N) [L and K is constant]\\nSpace: O(N*L) = O(N)\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n// Trie Node.\\nstruct Node {\\n\\n    Node* links[26];\\n    bool endOfWord = false;\\n\\n    void put(char ch, Node* node) {\\n        links[ch-\\'a\\'] = node;\\n    }\\n\\n    Node* get(char ch) {\\n        return links[ch-\\'a\\'];\\n    }\\n\\n    bool contains(char ch) {\\n        return links[ch-\\'a\\'] != NULL;\\n    }\\n\\n    void setEndOfWord() {\\n        endOfWord = true;\\n    }\\n\\n    bool isEndOfWord() {\\n        return endOfWord;\\n    }\\n};\\n\\n\\n\\nclass MagicDictionary {\\n\\npublic:\\n\\n    MagicDictionary() {\\n        // Initialize the root node.\\n        root = new Node();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n\\n        // Add all the words into trie.\\n        for(string word: dictionary){\\n            insert(word);\\n        }\\n    }\\n    \\n    bool searchSupport(string s, int index, Node* node, bool allowedOnce) {\\n        \\n        // Base case. Found NULL, It can not be EndOfWord.\\n        if(node == NULL)\\n            return false;\\n\\n\\n        for(int i = index; i < s.size(); i++) {\\n            \\n            // allowedOnce is set then we try all characters for current s[i].\\n            if(allowedOnce) {\\n\\n                for(char p = \\'a\\'; p <= \\'z\\'; p++) {\\n                        \\n                    // allowedOnce is depend, s[i] and p is same or not.\\n                    // If same, then allowedOnce = true else false.\\n                    if(searchSupport(s, i+1, node->get(p), s[i]==p)) {\\n                        return true;\\n                    }\\n                }\\n\\n                // Try all characters but did not find the end of word. Return false.\\n                return false;\\n            }\\n                \\n            // allowedOnce = false, then node must contains s[i].\\n            if(!node->contains(s[i]))\\n                return false;\\n\\n            // Move to next Node.\\n            node = node->get(s[i]);\\n        }\\n        \\n        // node is EndOfWord and allowedOnce == false(one mismatch) then we return true.\\n        if(node != NULL && !allowedOnce && node->isEndOfWord())\\n            return true;\\n\\n        return false;\\n    }\\n\\n\\n    bool search(string searchWord) {\\n        return searchSupport(searchWord, 0, root, true);\\n    }\\n\\nprivate:\\n\\n    Node* root;\\n\\n    void insert(string word) {\\n        Node* node = root;\\n        for(char ch: word) {\\n            if(!node->contains(ch)) {\\n                node->put(ch, new Node());\\n            }\\n            node = node->get(ch);\\n        }\\n        node->setEndOfWord();\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728508,
                "title": "c-trie-solution",
                "content": "```\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26];\\n    bool isEnd;\\n    \\n    TrieNode() {\\n        for(int i=0; i < 26; i++) {\\n            children[i] = NULL;\\n        }\\n        isEnd = false;\\n    }\\n};\\n\\n\\nclass MagicDictionary {\\npublic:\\n    \\n    TrieNode* head;\\n    MagicDictionary() {\\n        head = new TrieNode();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto word: dictionary) {\\n            insertWord(head, word);\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        return searchHelper(head, searchWord, 0, false);\\n    }\\n    \\n    bool searchHelper(TrieNode* head, string word, int i, bool isChanged) {\\n        if(i >= word.length()) return head->isEnd && isChanged;\\n        TrieNode* cur = head;\\n        int curInx = word[i] - \\'a\\';\\n        bool res = false;\\n        for(int j=0; j < 26; j++) {\\n            if(cur->children[j]) {\\n                if(j == curInx) {\\n                    res = searchHelper(cur->children[j], word, i+1, isChanged);\\n                } else if(!isChanged) {\\n                    res = searchHelper(cur->children[j], word, i+1, true);\\n                }\\n             }\\n            \\n            if(res) return true;\\n                \\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    void insertWord(TrieNode* head, string word) {\\n        TrieNode* cur = head;\\n        for(auto ch: word) {\\n            if(cur->children[ch - \\'a\\'] == NULL) {\\n                cur->children[ch - \\'a\\'] = new TrieNode();\\n            }\\n            cur = cur->children[ch - \\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26];\\n    bool isEnd;\\n    \\n    TrieNode() {\\n        for(int i=0; i < 26; i++) {\\n            children[i] = NULL;\\n        }\\n        isEnd = false;\\n    }\\n};\\n\\n\\nclass MagicDictionary {\\npublic:\\n    \\n    TrieNode* head;\\n    MagicDictionary() {\\n        head = new TrieNode();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto word: dictionary) {\\n            insertWord(head, word);\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        return searchHelper(head, searchWord, 0, false);\\n    }\\n    \\n    bool searchHelper(TrieNode* head, string word, int i, bool isChanged) {\\n        if(i >= word.length()) return head->isEnd && isChanged;\\n        TrieNode* cur = head;\\n        int curInx = word[i] - \\'a\\';\\n        bool res = false;\\n        for(int j=0; j < 26; j++) {\\n            if(cur->children[j]) {\\n                if(j == curInx) {\\n                    res = searchHelper(cur->children[j], word, i+1, isChanged);\\n                } else if(!isChanged) {\\n                    res = searchHelper(cur->children[j], word, i+1, true);\\n                }\\n             }\\n            \\n            if(res) return true;\\n                \\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    void insertWord(TrieNode* head, string word) {\\n        TrieNode* cur = head;\\n        for(auto ch: word) {\\n            if(cur->children[ch - \\'a\\'] == NULL) {\\n                cur->children[ch - \\'a\\'] = new TrieNode();\\n            }\\n            cur = cur->children[ch - \\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617680,
                "title": "python3-solution-with-using-trie",
                "content": "```\\nclass MagicDictionary:\\n    def __init__(self):\\n        self.trie = {}\\n        self.end = \\'end\\'\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            node = self.trie\\n            for c in word:\\n                if c not in node:\\n                    node[c] = {}\\n                \\n                node = node[c]\\n            \\n            node[self.end] = True\\n    \\n    def _search_after_change(self, suffix, node):\\n        for c in suffix:\\n            if c not in node:\\n                return False\\n            \\n            node = node[c]\\n        \\n        if self.end not in node:\\n            return False\\n        \\n        return True\\n    \\n    def search(self, searchWord: str) -> bool:\\n        node = self.trie\\n        \\n        for idx in range(len(searchWord)):\\n            for key in node:\\n                if key != self.end and key != searchWord[idx]:\\n                    suffix = searchWord[idx + 1:]\\n                    if self._search_after_change(suffix, node[key]):\\n                        return True\\n            \\n            # changing one character didn\\'t give us anything\\n            if searchWord[idx] not in node:\\n                return False\\n            \\n            node = node[searchWord[idx]]\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary:\\n    def __init__(self):\\n        self.trie = {}\\n        self.end = \\'end\\'\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            node = self.trie\\n            for c in word:\\n                if c not in node:\\n                    node[c] = {}\\n                \\n                node = node[c]\\n            \\n            node[self.end] = True\\n    \\n    def _search_after_change(self, suffix, node):\\n        for c in suffix:\\n            if c not in node:\\n                return False\\n            \\n            node = node[c]\\n        \\n        if self.end not in node:\\n            return False\\n        \\n        return True\\n    \\n    def search(self, searchWord: str) -> bool:\\n        node = self.trie\\n        \\n        for idx in range(len(searchWord)):\\n            for key in node:\\n                if key != self.end and key != searchWord[idx]:\\n                    suffix = searchWord[idx + 1:]\\n                    if self._search_after_change(suffix, node[key]):\\n                        return True\\n            \\n            # changing one character didn\\'t give us anything\\n            if searchWord[idx] not in node:\\n                return False\\n            \\n            node = node[searchWord[idx]]\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602345,
                "title": "you-guys-know-that-the-naive-solution-beats-100-here",
                "content": "Just wanted to leave it here that for this question the absolute best solution (for the test cases presented) is a naive linear search:\\n\\n1. Save the dictionary as is.\\n2. Upon `Search` iterate over the dictionary and find any string that differs with a single character.\\n\\nThis is faster than any dictionary or trie approach. I also tried sorting the dictionary on string sizes and using binary search to find the segment that contains the words of the same size. It didn\\'t help either.\\n\\nExample solution:\\n\\n```cpp\\ninline bool OneCharDiff(const string& a, const string& b) {\\n    if (a.size() != b.size()) {\\n        return false;\\n    }\\n    int diff = 0;\\n    for (int i = 0; i < a.size() && diff <= 1; ++i) {\\n        diff += a[i] != b[i];\\n    }\\n    return diff == 1;\\n}\\n\\nclass MagicDictionary {\\n    vector<string> d;\\n    \\npublic:\\n    MagicDictionary() {}\\n    \\n    void buildDict(vector<string> dictionary) {\\n        d = move(dictionary);\\n    }\\n    \\n    bool search(string searchWord) {\\n        for (const string& w : d) {\\n            if (OneCharDiff(searchWord, w)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\ninline bool OneCharDiff(const string& a, const string& b) {\\n    if (a.size() != b.size()) {\\n        return false;\\n    }\\n    int diff = 0;\\n    for (int i = 0; i < a.size() && diff <= 1; ++i) {\\n        diff += a[i] != b[i];\\n    }\\n    return diff == 1;\\n}\\n\\nclass MagicDictionary {\\n    vector<string> d;\\n    \\npublic:\\n    MagicDictionary() {}\\n    \\n    void buildDict(vector<string> dictionary) {\\n        d = move(dictionary);\\n    }\\n    \\n    bool search(string searchWord) {\\n        for (const string& w : d) {\\n            if (OneCharDiff(searchWord, w)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437403,
                "title": "python-implementation-using-dictionary",
                "content": "Simple Python implementation using dictionary\\n ```\\n class MagicDictionary:\\n    def __init__(self):\\n        self.dict = {}\\n        self.word = set()\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        # SC: O(n) # TC: O(nm)\\n        for word in dictionary:\\n            for i in range(len(word)):\\n\\t\\t\\t# building word templating to store as key, counting the number of template as value\\n                template = word[:i] + \\'*\\' + word[i+1:]\\n                self.dict[template] = 1 + self.dict.get(template,0)\\n                self.word.add(word)\\n    def search(self, searchWord: str) -> bool:\\n        # TC: O(m)  SC: O(1)\\n        for i in range(len(searchWord)):\\n            template = searchWord[:i] + \\'*\\' + searchWord[i+1:]\\n            if template in self.dict:\\n                if searchWord not in self.word:\\n                    return True\\n                else:\\n\\t\\t\\t\\t# if the given word is in the dictionary, make sure there are more than 2 counts for the template\\n                    if self.dict[template] >= 2:\\n                        return True\\n        return False\\n    \\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dictionary)\\n# param_2 = obj.search(searchWord)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Simple Python implementation using dictionary\\n ```\\n class MagicDictionary:\\n    def __init__(self):\\n        self.dict = {}\\n        self.word = set()\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        # SC: O(n) # TC: O(nm)\\n        for word in dictionary:\\n            for i in range(len(word)):\\n\\t\\t\\t# building word templating to store as key, counting the number of template as value\\n                template = word[:i] + \\'*\\' + word[i+1:]\\n                self.dict[template] = 1 + self.dict.get(template,0)\\n                self.word.add(word)\\n    def search(self, searchWord: str) -> bool:\\n        # TC: O(m)  SC: O(1)\\n        for i in range(len(searchWord)):\\n            template = searchWord[:i] + \\'*\\' + searchWord[i+1:]\\n            if template in self.dict:\\n                if searchWord not in self.word:\\n                    return True\\n                else:\\n\\t\\t\\t\\t# if the given word is in the dictionary, make sure there are more than 2 counts for the template\\n                    if self.dict[template] >= 2:\\n                        return True\\n        return False\\n    \\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dictionary)\\n# param_2 = obj.search(searchWord)",
                "codeTag": "Java"
            },
            {
                "id": 1191054,
                "title": "java-easy-solution-set-without-trie",
                "content": "```\\nclass MagicDictionary {\\n\\n    /** Initialize your data structure here. */\\n    Set<String> set;\\n    public MagicDictionary() {\\n        set=new HashSet<>();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String s:dictionary) set.add(s);\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        for(String s:set){\\n          if(canMake(s,searchWord)) return true;\\n        }\\n      return false;\\n    }\\n   public boolean canMake(String s,String sw){\\n     if(s.length()!=sw.length()) return false;\\n     int count=0;\\n     for(int i=0;i<s.length();i++){\\n       if(s.charAt(i)!=sw.charAt(i)) count++;\\n       if(count>1) return false;\\n     }\\n     return count==1;\\n   }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n\\n    /** Initialize your data structure here. */\\n    Set<String> set;\\n    public MagicDictionary() {\\n        set=new HashSet<>();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String s:dictionary) set.add(s);\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        for(String s:set){\\n          if(canMake(s,searchWord)) return true;\\n        }\\n      return false;\\n    }\\n   public boolean canMake(String s,String sw){\\n     if(s.length()!=sw.length()) return false;\\n     int count=0;\\n     for(int i=0;i<s.length();i++){\\n       if(s.charAt(i)!=sw.charAt(i)) count++;\\n       if(count>1) return false;\\n     }\\n     return count==1;\\n   }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049192,
                "title": "java-hashmap-builddict-o-dictionary-length-dictionary-i-length-search-o-word-length",
                "content": "class MagicDictionary {\\n\\n    HashMap<String, Integer> map;\\n\\n\\t// O(1)\\n\\tpublic MagicDictionary() {\\n\\t\\tmap = new HashMap<String, Integer>();\\n\\t}\\n\\n\\t\\t// O(dictionary.length * dictionary[i].length)\\n\\t\\tpublic void buildDict(String[] dictionary) {\\n\\t\\t\\tfor (String word : dictionary) {\\n\\t\\t\\t\\tchar[] str = word.toCharArray();\\n\\t\\t\\t\\tfor (int i = 0; i < str.length; i++) {\\n\\t\\t\\t\\t\\tchar temp = str[i];\\n\\t\\t\\t\\t\\tstr[i] = \\'*\\';\\n\\t\\t\\t\\t\\tString key = String.valueOf(str);\\n\\t\\t\\t\\t\\tmap.put(key, map.getOrDefault(key, 0) + 1);\\n\\t\\t\\t\\t\\tstr[i] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(word, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// O(searchWord.length)\\n\\t\\tpublic boolean search(String searchWord) {\\n\\t\\t\\tchar[] word = searchWord.toCharArray();\\n\\t\\t\\tfor (int i = 0; i < word.length; i++) {\\n\\t\\t\\t\\tchar temp = word[i];\\n\\t\\t\\t\\tword[i] = \\'*\\';\\n\\t\\t\\t\\tString key = String.valueOf(word);\\n\\t\\t\\t\\tint count = map.getOrDefault(key, 0);\\n\\t\\t\\t\\tif ((count >= 2) || (count == 1 && !map.containsKey(searchWord)))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tword[i] = temp;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n}\\n\\n",
                "solutionTags": [],
                "code": "class MagicDictionary {\\n\\n    HashMap<String, Integer> map;\\n\\n\\t// O(1)\\n\\tpublic MagicDictionary() {\\n\\t\\tmap = new HashMap<String, Integer>();\\n\\t}\\n\\n\\t\\t// O(dictionary.length * dictionary[i].length)\\n\\t\\tpublic void buildDict(String[] dictionary) {\\n\\t\\t\\tfor (String word : dictionary) {\\n\\t\\t\\t\\tchar[] str = word.toCharArray();\\n\\t\\t\\t\\tfor (int i = 0; i < str.length; i++) {\\n\\t\\t\\t\\t\\tchar temp = str[i];\\n\\t\\t\\t\\t\\tstr[i] = \\'*\\';\\n\\t\\t\\t\\t\\tString key = String.valueOf(str);\\n\\t\\t\\t\\t\\tmap.put(key, map.getOrDefault(key, 0) + 1);\\n\\t\\t\\t\\t\\tstr[i] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(word, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// O(searchWord.length)\\n\\t\\tpublic boolean search(String searchWord) {\\n\\t\\t\\tchar[] word = searchWord.toCharArray();\\n\\t\\t\\tfor (int i = 0; i < word.length; i++) {\\n\\t\\t\\t\\tchar temp = word[i];\\n\\t\\t\\t\\tword[i] = \\'*\\';\\n\\t\\t\\t\\tString key = String.valueOf(word);\\n\\t\\t\\t\\tint count = map.getOrDefault(key, 0);\\n\\t\\t\\t\\tif ((count >= 2) || (count == 1 && !map.containsKey(searchWord)))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tword[i] = temp;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1012623,
                "title": "java-trie-clean-code",
                "content": "```\\nclass MagicDictionary {\\n    class TrieNode {\\n        Map<Character, TrieNode> children;\\n        boolean endOfWord;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            endOfWord = false;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) {\\n                node = new TrieNode();\\n                curr.children.put(ch, node);\\n            }\\n            curr = node;\\n        }\\n        \\n        curr.endOfWord = true;\\n    }\\n    \\n    //Search by iteration\\n    public boolean searchHelper(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) {\\n                return false;\\n            }\\n            curr = node;\\n        }\\n        \\n        return curr.endOfWord;\\n    }\\n\\n    /** Initialize your data structure here. */\\n    public TrieNode root;\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String word: dictionary) {\\n            insert(root, word);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        TrieNode curr = root;\\n        \\n        int count = 0;\\n        char[] word = searchWord.toCharArray();\\n        for(int i = 0; i < word.length; i++) {\\n            if(curr == null) {\\n                return false;\\n            }\\n            \\n            TrieNode node = curr.children.get(word[i]);\\n            char org = word[i];\\n            for(char ch: curr.children.keySet()) {\\n                if(ch == org) continue;\\n                \\n                word[i] = ch;\\n                if(searchHelper(root, new String(word))) {\\n                    return true;\\n                }\\n            }\\n            word[i] = org;\\n            curr = node;\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary {\\n    class TrieNode {\\n        Map<Character, TrieNode> children;\\n        boolean endOfWord;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            endOfWord = false;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) {\\n                node = new TrieNode();\\n                curr.children.put(ch, node);\\n            }\\n            curr = node;\\n        }\\n        \\n        curr.endOfWord = true;\\n    }\\n    \\n    //Search by iteration\\n    public boolean searchHelper(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) {\\n                return false;\\n            }\\n            curr = node;\\n        }\\n        \\n        return curr.endOfWord;\\n    }\\n\\n    /** Initialize your data structure here. */\\n    public TrieNode root;\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String word: dictionary) {\\n            insert(root, word);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        TrieNode curr = root;\\n        \\n        int count = 0;\\n        char[] word = searchWord.toCharArray();\\n        for(int i = 0; i < word.length; i++) {\\n            if(curr == null) {\\n                return false;\\n            }\\n            \\n            TrieNode node = curr.children.get(word[i]);\\n            char org = word[i];\\n            for(char ch: curr.children.keySet()) {\\n                if(ch == org) continue;\\n                \\n                word[i] = ch;\\n                if(searchHelper(root, new String(word))) {\\n                    return true;\\n                }\\n            }\\n            word[i] = org;\\n            curr = node;\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893218,
                "title": "javascript-trie-dfs-approach",
                "content": "```\\nfunction TrieNode(){\\n    this.children = new Map()\\n    this.endOfWord = false;\\n}\\n\\nvar MagicDictionary = function() {\\n    this.root = new TrieNode()\\n};\\n\\nMagicDictionary.prototype.buildDict = function(dictionary) {\\n    for(let word of dictionary){\\n        let curr = this.root\\n        for(let letter of word){\\n            let map = curr.children\\n            if(!map.has(letter)) map.set(letter, new TrieNode())\\n            curr = map.get(letter)\\n        }\\n        curr.endOfWord = true\\n    }\\n};\\n\\nMagicDictionary.prototype.search = function(searchWord){\\n    return  dfs(this.root, searchWord, 0, 0)\\n}\\n\\nfunction dfs(root, str, i, count){\\n    if(count>1) return false\\n    if(i==str.length) return count == 1 && root.endOfWord\\n\\t\\n    for(let [char, node] of root.children){\\n        let c = 0;\\n        if(char != str[i]) c = 1\\n        if(dfs(node, str, i+1, count+c)) return true;\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nfunction TrieNode(){\\n    this.children = new Map()\\n    this.endOfWord = false;\\n}\\n\\nvar MagicDictionary = function() {\\n    this.root = new TrieNode()\\n};\\n\\nMagicDictionary.prototype.buildDict = function(dictionary) {\\n    for(let word of dictionary){\\n        let curr = this.root\\n        for(let letter of word){\\n            let map = curr.children\\n            if(!map.has(letter)) map.set(letter, new TrieNode())\\n            curr = map.get(letter)\\n        }\\n        curr.endOfWord = true\\n    }\\n};\\n\\nMagicDictionary.prototype.search = function(searchWord){\\n    return  dfs(this.root, searchWord, 0, 0)\\n}\\n\\nfunction dfs(root, str, i, count){\\n    if(count>1) return false\\n    if(i==str.length) return count == 1 && root.endOfWord\\n\\t\\n    for(let [char, node] of root.children){\\n        let c = 0;\\n        if(char != str[i]) c = 1\\n        if(dfs(node, str, i+1, count+c)) return true;\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 715587,
                "title": "java-beats-100-no-hashmap-trie-easy-to-understand",
                "content": "This solution doesn\\'t use HashMap or Trie. \\n```buildDict(String[] dict)``` complexity is O(1). \\n```search(String word)``` complexity is O(NK) where N is the total number of words in dictionary and K is the length of word to be searched.\\n\\n\\n```\\nclass MagicDictionary {\\n\\n    String[] dictionary;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        dictionary = dict;\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        for (String dictWord: dictionary) {\\n            if (dictWord.length() == word.length()) {\\n                int count = 0;\\n                for (int i=0; i< word.length(); i++) {\\n                    if (word.charAt(i) != dictWord.charAt(i)) {\\n                        count++;\\n                    }\\n                    if (count > 1) {\\n                        break;\\n                    }\\n                }\\n                if (count == 1) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```buildDict(String[] dict)```\n```search(String word)```\n```\\nclass MagicDictionary {\\n\\n    String[] dictionary;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        dictionary = dict;\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        for (String dictWord: dictionary) {\\n            if (dictWord.length() == word.length()) {\\n                int count = 0;\\n                for (int i=0; i< word.length(); i++) {\\n                    if (word.charAt(i) != dictWord.charAt(i)) {\\n                        count++;\\n                    }\\n                    if (count > 1) {\\n                        break;\\n                    }\\n                }\\n                if (count == 1) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627584,
                "title": "python3-trie-solution-implement-magic-dictionary",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Node:\\n    def __init__(self):\\n        self.child = defaultdict(Node)\\n        self.isEnd = False\\n\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.trie = Node()\\n    \\n    def buildDict(self, words: List[str]) -> None:\\n        for w in words:\\n            n = self.trie\\n            for c in w:\\n                n = n.child[c]\\n            n.isEnd = True\\n            \\n    def searchWord(self, n: \\'Node\\', word: str) -> bool:\\n        for c in word:\\n            if c not in n.child:\\n                return False\\n            n = n.child[c]\\n        return n.isEnd\\n        \\n\\n    def search(self, word: str) -> bool:\\n        n = self.trie\\n        for i, c in enumerate(word):\\n            if any(self.searchWord(n.child[k], word[i+1:]) for k in n.child if c != k):\\n                return True\\n            if c not in n.child:\\n                return False\\n            n = n.child[c]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Node:\\n    def __init__(self):\\n        self.child = defaultdict(Node)\\n        self.isEnd = False\\n\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.trie = Node()\\n    \\n    def buildDict(self, words: List[str]) -> None:\\n        for w in words:\\n            n = self.trie\\n            for c in w:\\n                n = n.child[c]\\n            n.isEnd = True\\n            \\n    def searchWord(self, n: \\'Node\\', word: str) -> bool:\\n        for c in word:\\n            if c not in n.child:\\n                return False\\n            n = n.child[c]\\n        return n.isEnd\\n        \\n\\n    def search(self, word: str) -> bool:\\n        n = self.trie\\n        for i, c in enumerate(word):\\n            if any(self.searchWord(n.child[k], word[i+1:]) for k in n.child if c != k):\\n                return True\\n            if c not in n.child:\\n                return False\\n            n = n.child[c]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356806,
                "title": "python-dfs-solution-beats-96-time-and-100-space",
                "content": "The intuition behind this approach is to create a tree with nodes that hold characters. A path from the root node to a leaf node defines a string in the dictionary. \\n\\nWe define a structure called a letterNode that holds the current node\\'s character value, the possible characters it can lead to, and whether it is a leaf node. \\n\\nOur MagicDictionary instance has one attribute, which is just the big daddy node that holds the start to all possible words. When we first build the dictionary, we iterate through all the words that are given to us, adding each string to a possible path. If the prefix of a string exists in Big Daddy\\'s chlidren, then we continue down that path until the characters no longer match up. For example, if we first add hello, we get the tree:\\n```\\nbig_daddy -> \\'h\\' -> \\'e\\' -> \\'l\\' -> \\'l\\' -> \\'o\\'\\n```\\n\\nwhere the node \\'o\\' is a leaf node. If we then have to add the words \\'heklo\\' and \\'zaddy\\', then we get the tree:\\n\\n```\\n\\t\\t    \\'h\\' -> \\'e\\' -> \\'l\\' -> \\'l\\' -> \\'o\\'\\n\\t      /          \\\\\\nbig_daddy             \\'k\\' -> \\'l\\' -> \\'o\\'\\n          \\\\\\n\\t        \\'z\\' -> \\'a\\' -> \\'d\\' -> \\'d\\' -> \\'y\\'\\n```\\n\\nWhen we search, we use a modified DFS algorithm. For each pass, we keep track of the current string, popping off the front value of the string and keep track of the number of characters modified to get to that node. For each node holding a char, we iterate through the child nodes, and if the child node and the current string have the same character in front, then we explore that node without decrementing the number of characters modified. If they don\\'t have the same character in front, then we explore that node and decrement the number of characters modified. Our accept condition is if our current string is empty, the node we are at is a leaf node, and the number of characters to modify is equal to the number we needed to modify. Otherwise, we reject this path.\\n\\n```\\nclass letterNode:\\n    def __init__(self, char):\\n        self.char = char\\n        self.children = []\\n        self.is_leaf = False\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.big_daddy = letterNode(None)\\n    \\n    def addString(self, parent, curr_str):\\n        if len(curr_str) != 0:\\n            new_path = True\\n            for child in parent.children:\\n                if child.char == curr_str[0] and not child.is_leaf:\\n                    self.addString(child, curr_str[1:])\\n                    new_path = False\\n                    break\\n            \\n            if new_path:\\n                new_node = letterNode(curr_str[0])\\n                parent.children.append(new_node)\\n                if len(curr_str) != 0:\\n                    self.addString(new_node, curr_str[1:])\\n        \\n        else:\\n            parent.not_end = False\\n    \\n    def buildDict(self, dict):\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        \"\"\"\\n        for word in dict:\\n            self.addString(self.big_daddy, word)\\n        \\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        \"\"\"\\n        \\n        def dfs(parent, curr_str, chars_left_to_modify):\\n            if len(curr_str) == 0:\\n                if chars_left_to_modify == 0:\\n                    if len(parent.children) == 0:\\n                        return True\\n                    else:\\n                        return False\\n                else:\\n                    return False\\n            \\n            for child in parent.children:\\n                if child.char == curr_str[0]:\\n                    if dfs(child, curr_str[1:], chars_left_to_modify):\\n                        return True\\n                else:\\n                    if chars_left_to_modify > 0:\\n                        if dfs(child, curr_str[1:], chars_left_to_modify-1):\\n                            return True\\n            \\n            return False\\n        \\n        return dfs(self.big_daddy, word, 1)\\n```",
                "solutionTags": [],
                "code": "```\\nbig_daddy -> \\'h\\' -> \\'e\\' -> \\'l\\' -> \\'l\\' -> \\'o\\'\\n```\n```\\n\\t\\t    \\'h\\' -> \\'e\\' -> \\'l\\' -> \\'l\\' -> \\'o\\'\\n\\t      /          \\\\\\nbig_daddy             \\'k\\' -> \\'l\\' -> \\'o\\'\\n          \\\\\\n\\t        \\'z\\' -> \\'a\\' -> \\'d\\' -> \\'d\\' -> \\'y\\'\\n```\n```\\nclass letterNode:\\n    def __init__(self, char):\\n        self.char = char\\n        self.children = []\\n        self.is_leaf = False\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.big_daddy = letterNode(None)\\n    \\n    def addString(self, parent, curr_str):\\n        if len(curr_str) != 0:\\n            new_path = True\\n            for child in parent.children:\\n                if child.char == curr_str[0] and not child.is_leaf:\\n                    self.addString(child, curr_str[1:])\\n                    new_path = False\\n                    break\\n            \\n            if new_path:\\n                new_node = letterNode(curr_str[0])\\n                parent.children.append(new_node)\\n                if len(curr_str) != 0:\\n                    self.addString(new_node, curr_str[1:])\\n        \\n        else:\\n            parent.not_end = False\\n    \\n    def buildDict(self, dict):\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        \"\"\"\\n        for word in dict:\\n            self.addString(self.big_daddy, word)\\n        \\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        \"\"\"\\n        \\n        def dfs(parent, curr_str, chars_left_to_modify):\\n            if len(curr_str) == 0:\\n                if chars_left_to_modify == 0:\\n                    if len(parent.children) == 0:\\n                        return True\\n                    else:\\n                        return False\\n                else:\\n                    return False\\n            \\n            for child in parent.children:\\n                if child.char == curr_str[0]:\\n                    if dfs(child, curr_str[1:], chars_left_to_modify):\\n                        return True\\n                else:\\n                    if chars_left_to_modify > 0:\\n                        if dfs(child, curr_str[1:], chars_left_to_modify-1):\\n                            return True\\n            \\n            return False\\n        \\n        return dfs(self.big_daddy, word, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151229,
                "title": "python-really-easy-to-understand-explanations",
                "content": "Instead of using a Trie, we can make a dictionary with the lengths of the words as the key and the list of all the words with the length as values, something like this:\\n```defaultdict(<type \\'list\\'>, {8: [u\\'leetcode\\'], 5: [u\\'hello\\', u\\'hallo\\']})```\\n\\nNow, we simply have to go through each word in the dictionary, whise length matches with the incoming word and see the number of same characters, if that is equal to the length - 1, then we get our answer. \\nNOTE: We cannot use a set here, because the order of the words matter. Hence, need to use a list only.\\nThe worst case time complexity will be O(n*|word|), but that will rarely occur, since we are negating all the words with the different lengths in a single strike.\\nThe code is as below:\\n\\n```from collections import defaultdict\\n\\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.d = defaultdict(list)\\n\\n    def buildDict(self, dict):\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        :type dict: List[str]\\n        :rtype: void\\n        \"\"\"\\n        for word in dict:\\n            length = len(word)\\n            self.d[length].append(word)\\n        print(self.d)\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        lenn = len(word)\\n        \\n        if lenn not in self.d:\\n            return False\\n        \\n        for w in self.d[lenn]:\\n            count = 0\\n            i = 0\\n            while i< lenn:\\n                if w[i] == word[i]:\\n                    count += 1\\n                i += 1\\n            if count == lenn-1:\\n                return True\\n        return False\\n```\\n",
                "solutionTags": [],
                "code": "```defaultdict(<type \\'list\\'>, {8: [u\\'leetcode\\'], 5: [u\\'hello\\', u\\'hallo\\']})```\n```from collections import defaultdict\\n\\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.d = defaultdict(list)\\n\\n    def buildDict(self, dict):\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        :type dict: List[str]\\n        :rtype: void\\n        \"\"\"\\n        for word in dict:\\n            length = len(word)\\n            self.d[length].append(word)\\n        print(self.d)\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        lenn = len(word)\\n        \\n        if lenn not in self.d:\\n            return False\\n        \\n        for w in self.d[lenn]:\\n            count = 0\\n            i = 0\\n            while i< lenn:\\n                if w[i] == word[i]:\\n                    count += 1\\n                i += 1\\n            if count == lenn-1:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112534,
                "title": "c-trie-solution-avoid-memory-leak",
                "content": "Many have posted C++/Java Trie solution, for Java, we do not need to consider possible memory leak, but for C++, a lot of people use pointers without releasing them (or not completely release them after terminates), here I post my Trie solution with *shared_ptr*, a smart pointer which guarantees completely memory recycle.\\n```\\nclass TrieNode {\\npublic:\\n    vector<shared_ptr<TrieNode>> next;\\n    bool is_word;\\n    TrieNode() {\\n        next = vector<shared_ptr<TrieNode>>(26);\\n        is_word = false;\\n    }\\n};\\nclass MagicDictionary {\\nprivate:\\n    shared_ptr<TrieNode> root;\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        root = make_shared<TrieNode>();\\n    }\\n\\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for (string& str : dict) {\\n            shared_ptr<TrieNode> cur = root;\\n            for (char& c : str) {\\n                if (cur->next[c - 'a'] == nullptr) {\\n                    cur->next[c - 'a'] = make_shared<TrieNode>();\\n                }\\n                cur = cur->next[c - 'a'];\\n            }\\n            cur->is_word = true;\\n        }\\n    }\\n\\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        for (int i = 0; i < word.size(); i++) {\\n            for (char c = 'a'; c <= 'z'; c++) {\\n                if (word[i] == c) continue;\\n                char temp = word[i];\\n                word[i] = c;\\n                if (searchTrie(word)) return true;\\n                word[i] = temp;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool searchTrie(string& word) {\\n        shared_ptr<TrieNode> cur = root;\\n        for (char& c : word) {\\n            if (cur->next[c - 'a'] == nullptr) return false;\\n            cur = cur->next[c - 'a'];\\n        }\\n        return cur->is_word;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\npublic:\\n    vector<shared_ptr<TrieNode>> next;\\n    bool is_word;\\n    TrieNode() {\\n        next = vector<shared_ptr<TrieNode>>(26);\\n        is_word = false;\\n    }\\n};\\nclass MagicDictionary {\\nprivate:\\n    shared_ptr<TrieNode> root;\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        root = make_shared<TrieNode>();\\n    }\\n\\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for (string& str : dict) {\\n            shared_ptr<TrieNode> cur = root;\\n            for (char& c : str) {\\n                if (cur->next[c - 'a'] == nullptr) {\\n                    cur->next[c - 'a'] = make_shared<TrieNode>();\\n                }\\n                cur = cur->next[c - 'a'];\\n            }\\n            cur->is_word = true;\\n        }\\n    }\\n\\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        for (int i = 0; i < word.size(); i++) {\\n            for (char c = 'a'; c <= 'z'; c++) {\\n                if (word[i] == c) continue;\\n                char temp = word[i];\\n                word[i] = c;\\n                if (searchTrie(word)) return true;\\n                word[i] = temp;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool searchTrie(string& word) {\\n        shared_ptr<TrieNode> cur = root;\\n        for (char& c : word) {\\n            if (cur->next[c - 'a'] == nullptr) return false;\\n            cur = cur->next[c - 'a'];\\n        }\\n        return cur->is_word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107455,
                "title": "simple-javascript-solution",
                "content": "```js\\n/**\\n * Initialize your data structure here.\\n */\\nvar MagicDictionary = function() {\\n    this.table = {}\\n};\\n\\n/**\\n * Build a dictionary through a list of words \\n * @param {string[]} dict\\n * @return {void}\\n */\\nMagicDictionary.prototype.buildDict = function(dict) {\\n    for (let word of dict) {\\n        this.table[word.length] = (this.table[word.length] || []).concat(word)\\n    }\\n};\\n\\n/**\\n * Returns if there is any word in the trie that equals to the given word after modifying exactly one character \\n * @param {string} word\\n * @return {boolean}\\n */\\nMagicDictionary.prototype.search = function(word) {\\n    return !!this.table[word.length] && this.table[word.length].some((w) => {\\n        let isModified = false\\n\\n        for (let i = 0; i < word.length; ++i) {\\n            if (word[i] !== w[i]) {\\n                if (isModified) {\\n                    return false\\n                } else {\\n                    isModified = true\\n                }\\n            }\\n        }\\n        return isModified\\n    })\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * Initialize your data structure here.\\n */\\nvar MagicDictionary = function() {\\n    this.table = {}\\n};\\n\\n/**\\n * Build a dictionary through a list of words \\n * @param {string[]} dict\\n * @return {void}\\n */\\nMagicDictionary.prototype.buildDict = function(dict) {\\n    for (let word of dict) {\\n        this.table[word.length] = (this.table[word.length] || []).concat(word)\\n    }\\n};\\n\\n/**\\n * Returns if there is any word in the trie that equals to the given word after modifying exactly one character \\n * @param {string} word\\n * @return {boolean}\\n */\\nMagicDictionary.prototype.search = function(word) {\\n    return !!this.table[word.length] && this.table[word.length].some((w) => {\\n        let isModified = false\\n\\n        for (let i = 0; i < word.length; ++i) {\\n            if (word[i] !== w[i]) {\\n                if (isModified) {\\n                    return false\\n                } else {\\n                    isModified = true\\n                }\\n            }\\n        }\\n        return isModified\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107457,
                "title": "java-implementation-using-trie",
                "content": "The basic idea is:\\n\\nFirst, insert the dictionary list into the Trie;\\n\\nSecond, for each given word, scan character by character. For each character, try modify it and then call the search method in Trie. If trie.search() returns true then return true. If not then see if the Trie has exactly this character, if yes then keep going, if not return false.\\n\\nFinally, if reaches the end of the word return false. This means the dictionary has exactly this word. But modifying any of the character cannot fit in the dictionary.\\n\\nHere is my Java solution using Trie:\\n```\\nclass MagicDictionary {\\n    private Trie trie;\\n    \\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        trie = new Trie();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for(String word : dict) {\\n            trie.insert(word);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        TrieNode curr = trie.root;\\n        int k = 0;\\n        while(curr != null) {\\n            if(k == word.length()) {\\n                //System.out.println(1);\\n                return false;\\n            }\\n            char c = word.charAt(k);\\n            int index = c - 'a';\\n            for(int i = 0; i < 26; i++) {\\n                if(i == index)  continue;\\n                if(curr.children[i] != null && searchHelper(word, k+1, curr.children[i])) {\\n                    return true;\\n                }\\n            }\\n            k++;\\n            curr = curr.children[index];\\n        }\\n        return false;\\n    }\\n    \\n    public boolean searchHelper(String word, int k, TrieNode node) {\\n        if(k == word.length())  return node.isWord;\\n        char c = word.charAt(k);\\n        int index = c - 'a';\\n        if(node.children[index] == null)    return false;\\n        return searchHelper(word, k + 1, node.children[index]);\\n    }\\n}\\n```\\nThe Trie implementation is here:\\n```\\nclass TrieNode {\\n    public char val;\\n    public TrieNode[] children = new TrieNode[26];\\n    public boolean isWord;\\n    public TrieNode() {};\\n    public TrieNode(char c) {\\n        this.val = c;\\n    }\\n}\\n\\nclass Trie {\\n    public TrieNode root;\\n    public Trie() {\\n        this.root = new TrieNode(' ');\\n    }\\n    public void insert(String word) {\\n        TrieNode curr = root;\\n        for(int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            int index = c - 'a';\\n            if(curr.children[index] == null) {\\n                curr.children[index] = new TrieNode(c);\\n            }\\n            curr = curr.children[index];\\n        }\\n        curr.isWord = true;\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n    private Trie trie;\\n    \\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        trie = new Trie();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for(String word : dict) {\\n            trie.insert(word);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        TrieNode curr = trie.root;\\n        int k = 0;\\n        while(curr != null) {\\n            if(k == word.length()) {\\n                //System.out.println(1);\\n                return false;\\n            }\\n            char c = word.charAt(k);\\n            int index = c - 'a';\\n            for(int i = 0; i < 26; i++) {\\n                if(i == index)  continue;\\n                if(curr.children[i] != null && searchHelper(word, k+1, curr.children[i])) {\\n                    return true;\\n                }\\n            }\\n            k++;\\n            curr = curr.children[index];\\n        }\\n        return false;\\n    }\\n    \\n    public boolean searchHelper(String word, int k, TrieNode node) {\\n        if(k == word.length())  return node.isWord;\\n        char c = word.charAt(k);\\n        int index = c - 'a';\\n        if(node.children[index] == null)    return false;\\n        return searchHelper(word, k + 1, node.children[index]);\\n    }\\n}\\n```\n```\\nclass TrieNode {\\n    public char val;\\n    public TrieNode[] children = new TrieNode[26];\\n    public boolean isWord;\\n    public TrieNode() {};\\n    public TrieNode(char c) {\\n        this.val = c;\\n    }\\n}\\n\\nclass Trie {\\n    public TrieNode root;\\n    public Trie() {\\n        this.root = new TrieNode(' ');\\n    }\\n    public void insert(String word) {\\n        TrieNode curr = root;\\n        for(int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            int index = c - 'a';\\n            if(curr.children[index] == null) {\\n                curr.children[index] = new TrieNode(c);\\n            }\\n            curr = curr.children[index];\\n        }\\n        curr.isWord = true;\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107496,
                "title": "simple-iterative-java-solution",
                "content": "In order for a string to exist in a magic dictionary one character in the string must be modified. This means we can compare the incoming string against strings in the dictionary and count how many characters do not match between the two. If only one character does not match the word exists in the magic dictionary. \\n\\nThere are some additional optimizations that we can make like only checking strings that have the same length as the input string and skipping over a word once more than one character has been found to not match.\\n\\n```\\nclass MagicDictionary {\\n        private final List<String> words = new ArrayList<>();\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s : dict) {\\n            words.add(s);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        for (String s : words) {\\n            // Only check strings that are the same length\\n            if (word.length() != s.length()) {\\n                continue;\\n            }\\n            \\n            int numWrong = 0;\\n            \\n            // Compare each letter of each word and count how many letters are off.\\n            for (int i = 0; i < word.length(); i++) {\\n                char a = word.charAt(i);\\n                char b = s.charAt(i);\\n                \\n                if (a != b) {\\n                    numWrong++;\\n                }\\n                \\n                // optimization\\n                if (numWrong > 1) {\\n                    break;\\n                }\\n            }\\n\\n            // If only one letter for each word is off, this is acceptable.\\n            if (numWrong == 1) {\\n                return true;\\n            } \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n        private final List<String> words = new ArrayList<>();\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s : dict) {\\n            words.add(s);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        for (String s : words) {\\n            // Only check strings that are the same length\\n            if (word.length() != s.length()) {\\n                continue;\\n            }\\n            \\n            int numWrong = 0;\\n            \\n            // Compare each letter of each word and count how many letters are off.\\n            for (int i = 0; i < word.length(); i++) {\\n                char a = word.charAt(i);\\n                char b = s.charAt(i);\\n                \\n                if (a != b) {\\n                    numWrong++;\\n                }\\n                \\n                // optimization\\n                if (numWrong > 1) {\\n                    break;\\n                }\\n            }\\n\\n            // If only one letter for each word is off, this is acceptable.\\n            if (numWrong == 1) {\\n                return true;\\n            } \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019003,
                "title": "easy-to-understand-c",
                "content": "C++\\n\\n# Code\\n```\\nclass MagicDictionary {\\npublic:\\n    vector<string> a;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(int i=0;i<dictionary.size();i++){\\n            a.push_back(dictionary[i]);\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        int f=0;\\n        for(int i=0;i<a.size();i++){\\n            string temp=a[i];\\n            if(a[i].size()!=searchWord.size())  continue;\\n            int curr=0;\\n            for(int j=0;j<temp.size();j++){\\n                if(temp[j]==searchWord[j])  curr++;\\n            }\\n            if(curr==temp.size()-1){\\n                f=1;\\n                break;\\n            }\\n        }\\n\\n        return f==1;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    vector<string> a;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(int i=0;i<dictionary.size();i++){\\n            a.push_back(dictionary[i]);\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        int f=0;\\n        for(int i=0;i<a.size();i++){\\n            string temp=a[i];\\n            if(a[i].size()!=searchWord.size())  continue;\\n            int curr=0;\\n            for(int j=0;j<temp.size();j++){\\n                if(temp[j]==searchWord[j])  curr++;\\n            }\\n            if(curr==temp.size()-1){\\n                f=1;\\n                break;\\n            }\\n        }\\n\\n        return f==1;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960301,
                "title": "c-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MagicDictionary {\\npublic:\\n    unordered_map<string,int>mp;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> d) {\\n        for(auto it:d){\\n            mp[it]++;\\n        }\\n    }\\n    \\n    bool search(string s) {\\n        \\n        for(auto it:mp){\\n            int count=0;\\n            string temp=it.first;\\n            if(temp.size()==s.size()){\\n                for(int i=0;i<s.size();i++){\\n                    if(s[i]!=temp[i]){\\n                        count++;\\n                    }\\n                }\\n                if(count==1){\\n                    return 1;\\n                   \\n                }\\n            }\\n           \\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    unordered_map<string,int>mp;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> d) {\\n        for(auto it:d){\\n            mp[it]++;\\n        }\\n    }\\n    \\n    bool search(string s) {\\n        \\n        for(auto it:mp){\\n            int count=0;\\n            string temp=it.first;\\n            if(temp.size()==s.size()){\\n                for(int i=0;i<s.size();i++){\\n                    if(s[i]!=temp[i]){\\n                        count++;\\n                    }\\n                }\\n                if(count==1){\\n                    return 1;\\n                   \\n                }\\n            }\\n           \\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680402,
                "title": "trie-depth-first-search-beats-50-java-easy-code",
                "content": "# Code\\n```\\nclass TrieNode {\\n    Map<Character, TrieNode> children;\\n    boolean isEnd;\\n    TrieNode() {\\n        children = new HashMap<>();\\n        isEnd = false;\\n    }\\n}\\n\\nclass Trie {\\n    private final TrieNode root = new TrieNode();\\n    Trie(){}\\n    \\n    public void insert(String str) {\\n        TrieNode current = root;\\n        for (Character c: str.toCharArray()) {\\n            TrieNode child = current.children.get(c);\\n            if(child == null) {\\n                child = new TrieNode();\\n                current.children.put(c, child);\\n            }\\n            current = child;\\n        }\\n        current.isEnd = true;\\n    }\\n    \\n    public boolean search(String str) {\\n        return dfs(root, 0, str, 0);\\n    }\\n    \\n    private  boolean dfs(TrieNode node, int index, String str, int changed) {\\n        if(index == str.length() && node.isEnd && changed == 1) return true;\\n        if(changed == 2 || index >= str.length()) return false;\\n        for (Map.Entry<Character, TrieNode> child: node.children.entrySet()) {\\n            if(dfs(child.getValue(), index+1, str, child.getKey() == str.charAt(index) ? changed : changed + 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n\\nclass MagicDictionary {\\n    private final Trie trie = new Trie();\\n    public MagicDictionary() {\\n\\n    }\\n\\n    public void buildDict(String[] dictionary) {\\n        for (String word: dictionary)\\n            trie.insert(word);\\n    }\\n\\n    public boolean search(String searchWord) {\\n        return trie.search(searchWord);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Depth-First Search",
                    "Design",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n    Map<Character, TrieNode> children;\\n    boolean isEnd;\\n    TrieNode() {\\n        children = new HashMap<>();\\n        isEnd = false;\\n    }\\n}\\n\\nclass Trie {\\n    private final TrieNode root = new TrieNode();\\n    Trie(){}\\n    \\n    public void insert(String str) {\\n        TrieNode current = root;\\n        for (Character c: str.toCharArray()) {\\n            TrieNode child = current.children.get(c);\\n            if(child == null) {\\n                child = new TrieNode();\\n                current.children.put(c, child);\\n            }\\n            current = child;\\n        }\\n        current.isEnd = true;\\n    }\\n    \\n    public boolean search(String str) {\\n        return dfs(root, 0, str, 0);\\n    }\\n    \\n    private  boolean dfs(TrieNode node, int index, String str, int changed) {\\n        if(index == str.length() && node.isEnd && changed == 1) return true;\\n        if(changed == 2 || index >= str.length()) return false;\\n        for (Map.Entry<Character, TrieNode> child: node.children.entrySet()) {\\n            if(dfs(child.getValue(), index+1, str, child.getKey() == str.charAt(index) ? changed : changed + 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n\\nclass MagicDictionary {\\n    private final Trie trie = new Trie();\\n    public MagicDictionary() {\\n\\n    }\\n\\n    public void buildDict(String[] dictionary) {\\n        for (String word: dictionary)\\n            trie.insert(word);\\n    }\\n\\n    public boolean search(String searchWord) {\\n        return trie.search(searchWord);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563940,
                "title": "java-simple-trie-solution",
                "content": "```java\\nclass MagicDictionary {\\n    private final TrieNode root;\\n\\n    public MagicDictionary() {\\n        this.root = new TrieNode();\\n    }\\n    \\n    public void buildDict(final String[] dictionary) {\\n        for(String word : dictionary)\\n            this.buildDictHelper(this.root, word);\\n    }\\n\\n    public void buildDictHelper(TrieNode root, final String word) {\\n        for(int i = 0; i < word.length(); i++) {\\n            final int index = word.charAt(i) - \\'a\\';\\n\\n            if(root.nextCharacters()[index] == null)\\n                root.nextCharacters()[index] = new TrieNode();\\n\\n            root = root.nextCharacters()[index];\\n        }\\n        root.isWord(true);\\n    }\\n    \\n    public boolean search(final String searchWord) {\\n        return this.dfs(this.root, searchWord, 0, false);\\n    }\\n\\n    public boolean dfs(final TrieNode root, final String searchWord, final int index, final boolean mismatch) {\\n        if (index == searchWord.length()) \\n            return (root.isWord() && index == searchWord.length() && mismatch);\\n        \\n        final int j = searchWord.charAt(index) - \\'a\\';\\n\\n        if (!mismatch) {\\n            for (int i = 0; i < 26; i++) {\\n                if (i == j || root.nextCharacters()[i] == null)\\n                    continue;\\n                if (dfs(root.nextCharacters()[i], searchWord, index + 1, true))\\n                    return true;\\n            }\\n        }\\n        if (root.nextCharacters()[j] != null && dfs(root.nextCharacters()[j], searchWord, index + 1, mismatch))\\n            return true;\\n        return false;\\n    }\\n\\n    private final class TrieNode {\\n        private final TrieNode[] nextCharacters;\\n        private boolean isWord;\\n\\n        public TrieNode() {\\n            this.nextCharacters = new TrieNode[26];\\n            this.isWord = false;\\n        }\\n\\n        public boolean isWord() {\\n            return this.isWord;\\n        }\\n\\n        public void isWord(final boolean isWord) {\\n            this.isWord = isWord;\\n        }\\n\\n        public TrieNode[] nextCharacters() {\\n            return this.nextCharacters;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass MagicDictionary {\\n    private final TrieNode root;\\n\\n    public MagicDictionary() {\\n        this.root = new TrieNode();\\n    }\\n    \\n    public void buildDict(final String[] dictionary) {\\n        for(String word : dictionary)\\n            this.buildDictHelper(this.root, word);\\n    }\\n\\n    public void buildDictHelper(TrieNode root, final String word) {\\n        for(int i = 0; i < word.length(); i++) {\\n            final int index = word.charAt(i) - \\'a\\';\\n\\n            if(root.nextCharacters()[index] == null)\\n                root.nextCharacters()[index] = new TrieNode();\\n\\n            root = root.nextCharacters()[index];\\n        }\\n        root.isWord(true);\\n    }\\n    \\n    public boolean search(final String searchWord) {\\n        return this.dfs(this.root, searchWord, 0, false);\\n    }\\n\\n    public boolean dfs(final TrieNode root, final String searchWord, final int index, final boolean mismatch) {\\n        if (index == searchWord.length()) \\n            return (root.isWord() && index == searchWord.length() && mismatch);\\n        \\n        final int j = searchWord.charAt(index) - \\'a\\';\\n\\n        if (!mismatch) {\\n            for (int i = 0; i < 26; i++) {\\n                if (i == j || root.nextCharacters()[i] == null)\\n                    continue;\\n                if (dfs(root.nextCharacters()[i], searchWord, index + 1, true))\\n                    return true;\\n            }\\n        }\\n        if (root.nextCharacters()[j] != null && dfs(root.nextCharacters()[j], searchWord, index + 1, mismatch))\\n            return true;\\n        return false;\\n    }\\n\\n    private final class TrieNode {\\n        private final TrieNode[] nextCharacters;\\n        private boolean isWord;\\n\\n        public TrieNode() {\\n            this.nextCharacters = new TrieNode[26];\\n            this.isWord = false;\\n        }\\n\\n        public boolean isWord() {\\n            return this.isWord;\\n        }\\n\\n        public void isWord(final boolean isWord) {\\n            this.isWord = isWord;\\n        }\\n\\n        public TrieNode[] nextCharacters() {\\n            return this.nextCharacters;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430951,
                "title": "solution",
                "content": "```C++ []\\nclass MagicDictionary {\\n public:\\n  void buildDict(vector<string> dictionary) {\\n    for (const string& word : dictionary)\\n      for (int i = 0; i < word.length(); ++i) {\\n        const string replaced = getReplaced(word, i);\\n        dict[replaced] = dict.count(replaced) ? \\'*\\' : word[i];\\n      }\\n  }\\n  bool search(string searchWord) {\\n    for (int i = 0; i < searchWord.length(); ++i) {\\n      const string replaced = getReplaced(searchWord, i);\\n      if (dict.count(replaced) && dict[replaced] != searchWord[i])\\n        return true;\\n    }\\n    return false;\\n  }\\n private:\\n  unordered_map<string, char> dict;\\n\\n  string getReplaced(const string& s, int i) {\\n    return s.substr(0, i) + \\'*\\' + s.substr(i + 1);\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.countDict = {}\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            if len(word) not in self.countDict: self.countDict[len(word)] = []\\n            self.countDict[len(word)].append(word)\\n\\n    def isOneOff(self, word, searchWord) -> bool:\\n        numDiffs = 0\\n        for i in range(len(word)):\\n            if word[i] != searchWord[i]: numDiffs += 1\\n            if numDiffs > 1: return False\\n        return numDiffs == 1\\n\\n    def search(self, searchWord: str) -> bool:\\n        if len(searchWord) not in self.countDict: return False\\n        candidates = self.countDict[len(searchWord)]\\n        for c in candidates:\\n            if self.isOneOff(c, searchWord): return True\\n        return False\\n```\\n\\n```Java []\\nclass MagicDictionary {\\n    private HashMap<Integer, ArrayList<String>> lenMap;\\n    public MagicDictionary() {\\n        lenMap = new HashMap<>();\\n    }\\n    public void buildDict(String[] dictionary) {\\n        lenMap.clear();\\n        for(String word: dictionary){\\n            if(!lenMap.containsKey(word.length())){\\n                lenMap.put(word.length(), new ArrayList<>());\\n            }\\n            lenMap.get(word.length()).add(word);\\n        }\\n    }\\n    public boolean search(String searchWord) {\\n        if(!lenMap.containsKey(searchWord.length())){\\n            return false;\\n        }\\n        ArrayList<String> arr = lenMap.get(searchWord.length());\\n        for(String word: arr){\\n            if(checkAlmostSame(searchWord, word)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean checkAlmostSame(String searchWord, String word){\\n        boolean foundDiff = false;\\n        for(int i = 0; i < word.length(); i++){\\n            if(word.charAt(i) != searchWord.charAt(i)){\\n                if(foundDiff == true){\\n                    return false;\\n                } else {\\n                    foundDiff = true;\\n                }\\n            }\\n        }\\n        return foundDiff;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass MagicDictionary {\\n public:\\n  void buildDict(vector<string> dictionary) {\\n    for (const string& word : dictionary)\\n      for (int i = 0; i < word.length(); ++i) {\\n        const string replaced = getReplaced(word, i);\\n        dict[replaced] = dict.count(replaced) ? \\'*\\' : word[i];\\n      }\\n  }\\n  bool search(string searchWord) {\\n    for (int i = 0; i < searchWord.length(); ++i) {\\n      const string replaced = getReplaced(searchWord, i);\\n      if (dict.count(replaced) && dict[replaced] != searchWord[i])\\n        return true;\\n    }\\n    return false;\\n  }\\n private:\\n  unordered_map<string, char> dict;\\n\\n  string getReplaced(const string& s, int i) {\\n    return s.substr(0, i) + \\'*\\' + s.substr(i + 1);\\n  }\\n};\\n```\n```Python3 []\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.countDict = {}\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            if len(word) not in self.countDict: self.countDict[len(word)] = []\\n            self.countDict[len(word)].append(word)\\n\\n    def isOneOff(self, word, searchWord) -> bool:\\n        numDiffs = 0\\n        for i in range(len(word)):\\n            if word[i] != searchWord[i]: numDiffs += 1\\n            if numDiffs > 1: return False\\n        return numDiffs == 1\\n\\n    def search(self, searchWord: str) -> bool:\\n        if len(searchWord) not in self.countDict: return False\\n        candidates = self.countDict[len(searchWord)]\\n        for c in candidates:\\n            if self.isOneOff(c, searchWord): return True\\n        return False\\n```\n```Java []\\nclass MagicDictionary {\\n    private HashMap<Integer, ArrayList<String>> lenMap;\\n    public MagicDictionary() {\\n        lenMap = new HashMap<>();\\n    }\\n    public void buildDict(String[] dictionary) {\\n        lenMap.clear();\\n        for(String word: dictionary){\\n            if(!lenMap.containsKey(word.length())){\\n                lenMap.put(word.length(), new ArrayList<>());\\n            }\\n            lenMap.get(word.length()).add(word);\\n        }\\n    }\\n    public boolean search(String searchWord) {\\n        if(!lenMap.containsKey(searchWord.length())){\\n            return false;\\n        }\\n        ArrayList<String> arr = lenMap.get(searchWord.length());\\n        for(String word: arr){\\n            if(checkAlmostSame(searchWord, word)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean checkAlmostSame(String searchWord, String word){\\n        boolean foundDiff = false;\\n        for(int i = 0; i < word.length(); i++){\\n            if(word.charAt(i) != searchWord.charAt(i)){\\n                if(foundDiff == true){\\n                    return false;\\n                } else {\\n                    foundDiff = true;\\n                }\\n            }\\n        }\\n        return foundDiff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937367,
                "title": "trie-simple-approach",
                "content": "# Intuition\\nTrie approach\\n\\n# Approach\\n1. Trie\\n2. Recurse to find if there is a difference of one character in the most efficient way\\n\\n\\n\\n# Code\\n```\\nclass MagicDictionary {\\n\\n   Trie trie=new Trie();\\n   static class Trie{\\n       Map<Character,Trie> trieMap=new HashMap<Character,Trie>(); \\n        boolean eow=false;\\n       public String toString(){\\n           return trieMap.toString();\\n       }\\n   }\\n\\n    public MagicDictionary() {\\n        \\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String word:dictionary){\\n            Trie tmpTrie=trie;\\n\\n            for(char c:word.toCharArray()){\\n                tmpTrie.trieMap.putIfAbsent(c,new Trie());\\n                tmpTrie=tmpTrie.trieMap.get(c);\\n            }   \\n            tmpTrie.eow=true;           \\n        }\\n\\n      \\n    }\\n    \\n    public boolean hasOneCharacDiff(String searchWord,int index,int runDiff,Trie trie){\\n            if(runDiff>1) return false;\\n           \\n            if(index>=searchWord.length()){\\n                if(runDiff==1 && trie.eow) return true;\\n                return false;\\n            }\\n\\n            char c=searchWord.charAt(index);\\n            for(char k: trie.trieMap.keySet()){\\n                int addition=k==c?0:1;\\n                if(hasOneCharacDiff(searchWord,index+1,runDiff+addition,trie.trieMap.get(k)))return true;\\n            }\\n            \\n            return false;\\n    }\\n\\n    public boolean search(String searchWord) {\\n        if(hasOneCharacDiff(searchWord,0,0,trie)) return true;\\n        return false;\\n    }\\n\\n   \\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MagicDictionary {\\n\\n   Trie trie=new Trie();\\n   static class Trie{\\n       Map<Character,Trie> trieMap=new HashMap<Character,Trie>(); \\n        boolean eow=false;\\n       public String toString(){\\n           return trieMap.toString();\\n       }\\n   }\\n\\n    public MagicDictionary() {\\n        \\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String word:dictionary){\\n            Trie tmpTrie=trie;\\n\\n            for(char c:word.toCharArray()){\\n                tmpTrie.trieMap.putIfAbsent(c,new Trie());\\n                tmpTrie=tmpTrie.trieMap.get(c);\\n            }   \\n            tmpTrie.eow=true;           \\n        }\\n\\n      \\n    }\\n    \\n    public boolean hasOneCharacDiff(String searchWord,int index,int runDiff,Trie trie){\\n            if(runDiff>1) return false;\\n           \\n            if(index>=searchWord.length()){\\n                if(runDiff==1 && trie.eow) return true;\\n                return false;\\n            }\\n\\n            char c=searchWord.charAt(index);\\n            for(char k: trie.trieMap.keySet()){\\n                int addition=k==c?0:1;\\n                if(hasOneCharacDiff(searchWord,index+1,runDiff+addition,trie.trieMap.get(k)))return true;\\n            }\\n            \\n            return false;\\n    }\\n\\n    public boolean search(String searchWord) {\\n        if(hasOneCharacDiff(searchWord,0,0,trie)) return true;\\n        return false;\\n    }\\n\\n   \\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921951,
                "title": "easy-trie-solution-c",
                "content": "# Intuition\\ninsert all the string in the trie \\nIn search operation traverse the whole seachString, \\nif trie does not contains that char then skip the curr character and check if u can find the remaining substring (implemented in helper function) return true else return false and if trie does contain that char then we have option to skip that character or not to skip that character so try by skipping this char if u find remaining substring by any other path, then return true else check further by moving to the next index\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node {\\n    Node * links[26];\\n    bool flag = false;\\n    bool isContains(char ch){       // Node has ch or not\\n        return links[ch-\\'a\\'] != NULL;\\n    }\\n    void put (char ch, Node * node){\\n        links[ch-\\'a\\'] = node;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n};\\nclass MagicDictionary {\\npublic:\\n    Node * root ;\\n    MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {             // same as insert just wrap insert all the strings in dict\\n        for(auto word : dictionary){\\n            Node * node = root;\\n            int n = word.size();\\n            for(int i = 0;i<n;i++){\\n                if(!(node ->isContains(word[i]))){   // if node doesn\\'t contain word[i]\\n                    node->put(word[i],new Node());\\n                }\\n                node = node->get(word[i]);          // move forward\\n            }\\n            node->flag = true;                  // word end\\'s here mark flag as true \\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        Node * node = root;\\n        int n = searchWord.size();\\n        for(int i = 0;i<n;i++){\\n            if(!node->isContains(searchWord[i])){       // if we don\\'t find same char then skip this char and check if we found rem substring if yes return true else false\\n                string s = searchWord.substr(i+1);\\n                for(int j = 0;j<26;j++){\\n                    Node * curr = node->get(j + \\'a\\');\\n                    if(curr){\\n                        if(SearchHelper(s,curr))\\n                            return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            else {             // if we find same char then we have option to skip and notskip so check by skpping this char and if we found rem substring return true else move to next character\\n                string s = searchWord.substr(i+1);\\n                int k = searchWord[i] - \\'a\\';\\n                for(int j = 0;j<26;j++){\\n                    if(j == k) continue;\\n                    Node * curr = node->get(j + \\'a\\');\\n                    if(curr){\\n                        if(SearchHelper(s,curr))\\n                            return true;\\n                    }\\n                }\\n                node = node->get(searchWord[i]);\\n            }\\n        }\\n        return false;\\n    }\\n    bool SearchHelper(string word, Node * node){        // normal search for same string we are callling this function after skipping a char so if we found remaining string i.e we need to change 1 char to convert a string into matching string\\n        int n = word.size();\\n        for(int i = 0;i<n;i++){\\n            if(!node ->isContains(word[i])){      // if node doesn\\'t contain word[i]\\n                return false;\\n            }\\n            node = node->get(word[i]);          // move forward\\n        }\\n        return node->flag;                  // if it contains all the char and flag is true at last it means word is here   \\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n    Node * links[26];\\n    bool flag = false;\\n    bool isContains(char ch){       // Node has ch or not\\n        return links[ch-\\'a\\'] != NULL;\\n    }\\n    void put (char ch, Node * node){\\n        links[ch-\\'a\\'] = node;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n};\\nclass MagicDictionary {\\npublic:\\n    Node * root ;\\n    MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {             // same as insert just wrap insert all the strings in dict\\n        for(auto word : dictionary){\\n            Node * node = root;\\n            int n = word.size();\\n            for(int i = 0;i<n;i++){\\n                if(!(node ->isContains(word[i]))){   // if node doesn\\'t contain word[i]\\n                    node->put(word[i],new Node());\\n                }\\n                node = node->get(word[i]);          // move forward\\n            }\\n            node->flag = true;                  // word end\\'s here mark flag as true \\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        Node * node = root;\\n        int n = searchWord.size();\\n        for(int i = 0;i<n;i++){\\n            if(!node->isContains(searchWord[i])){       // if we don\\'t find same char then skip this char and check if we found rem substring if yes return true else false\\n                string s = searchWord.substr(i+1);\\n                for(int j = 0;j<26;j++){\\n                    Node * curr = node->get(j + \\'a\\');\\n                    if(curr){\\n                        if(SearchHelper(s,curr))\\n                            return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            else {             // if we find same char then we have option to skip and notskip so check by skpping this char and if we found rem substring return true else move to next character\\n                string s = searchWord.substr(i+1);\\n                int k = searchWord[i] - \\'a\\';\\n                for(int j = 0;j<26;j++){\\n                    if(j == k) continue;\\n                    Node * curr = node->get(j + \\'a\\');\\n                    if(curr){\\n                        if(SearchHelper(s,curr))\\n                            return true;\\n                    }\\n                }\\n                node = node->get(searchWord[i]);\\n            }\\n        }\\n        return false;\\n    }\\n    bool SearchHelper(string word, Node * node){        // normal search for same string we are callling this function after skipping a char so if we found remaining string i.e we need to change 1 char to convert a string into matching string\\n        int n = word.size();\\n        for(int i = 0;i<n;i++){\\n            if(!node ->isContains(word[i])){      // if node doesn\\'t contain word[i]\\n                return false;\\n            }\\n            node = node->get(word[i]);          // move forward\\n        }\\n        return node->flag;                  // if it contains all the char and flag is true at last it means word is here   \\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651868,
                "title": "c-try-all-combinations-very-easy-to-understand",
                "content": "```\\nclass MagicDictionary {\\npublic:\\n    unordered_set<string>st;\\n    MagicDictionary() {\\n        st.clear();\\n    }\\n    \\n    void buildDict(vector<string> arr) {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n    }\\n    \\n    bool search(string s) {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            string temp=s;\\n            for(int k=0;k<26;k++)\\n            {\\n                char curr_char=char(k+\\'a\\');\\n                if(curr_char!=s[i])\\n                {\\n                    temp[i]=char(k+\\'a\\');\\n                    if(st.find(temp)!=st.end())\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    unordered_set<string>st;\\n    MagicDictionary() {\\n        st.clear();\\n    }\\n    \\n    void buildDict(vector<string> arr) {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n    }\\n    \\n    bool search(string s) {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            string temp=s;\\n            for(int k=0;k<26;k++)\\n            {\\n                char curr_char=char(k+\\'a\\');\\n                if(curr_char!=s[i])\\n                {\\n                    temp[i]=char(k+\\'a\\');\\n                    if(st.find(temp)!=st.end())\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651858,
                "title": "c-try-all-combinations-very-easy-to-understand",
                "content": "```\\nclass MagicDictionary {\\npublic:\\n   unordered_set<string>st;\\n    MagicDictionary() \\n\\t{\\n       st.clear();    \\n    }\\n    \\n    void buildDict(vector<string> dict) \\n\\t{\\n       for(int i=0;i<dict.size();i++)\\n       {\\n       \\t  st.insert(dict[i]);\\n\\t   }\\n    }\\n    \\n    bool search(string word) \\n\\t{\\n        for(int i=0;i<word.length();i++)\\n        {\\n       \\t    string temp_word = word;\\n       \\t    char temp_ch = word[i];\\n       \\t    \\n        \\tfor(int j=0;j<26;j++)\\n        \\t{\\n        \\t   char ch=char(j + \\'a\\');\\n\\t\\t\\t   if(temp_ch != ch)\\n\\t\\t\\t   {\\n\\t\\t\\t      \\ttemp_word[i] = ch;\\n\\t\\t\\t      \\t\\n\\t\\t\\t      \\tif(st.find(temp_word)!=st.end())\\n\\t\\t\\t      \\treturn true;\\n\\t\\t\\t   }\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n   unordered_set<string>st;\\n    MagicDictionary() \\n\\t{\\n       st.clear();    \\n    }\\n    \\n    void buildDict(vector<string> dict) \\n\\t{\\n       for(int i=0;i<dict.size();i++)\\n       {\\n       \\t  st.insert(dict[i]);\\n\\t   }\\n    }\\n    \\n    bool search(string word) \\n\\t{\\n        for(int i=0;i<word.length();i++)\\n        {\\n       \\t    string temp_word = word;\\n       \\t    char temp_ch = word[i];\\n       \\t    \\n        \\tfor(int j=0;j<26;j++)\\n        \\t{\\n        \\t   char ch=char(j + \\'a\\');\\n\\t\\t\\t   if(temp_ch != ch)\\n\\t\\t\\t   {\\n\\t\\t\\t      \\ttemp_word[i] = ch;\\n\\t\\t\\t      \\t\\n\\t\\t\\t      \\tif(st.find(temp_word)!=st.end())\\n\\t\\t\\t      \\treturn true;\\n\\t\\t\\t   }\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627992,
                "title": "c-trie-easy-solution",
                "content": "```\\nclass MagicDictionary {\\npublic:\\n   \\n    class Trie{\\n        public:\\n        Trie *child[26];\\n        bool isEnd;\\n        Trie()\\n        {\\n            isEnd=false;\\n            for(int i=0;i<26;i++)\\n                child[i]=NULL;\\n        }\\n    };\\n    Trie *root=new Trie();\\n    MagicDictionary() {\\n    \\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n     \\n        for(string s:dictionary)\\n        {\\n        Trie *node=root;      \\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(!node->child[s[i]-\\'a\\'])\\n                {\\n                    node->child[s[i]-\\'a\\']=new Trie();\\n                }\\n                node=node->child[s[i]-\\'a\\'];\\n            }\\n            node->isEnd=true;\\n        }\\n    }\\n    bool check(string s)\\n    {\\n        Trie *node=root;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(node->child[s[i]-\\'a\\']==NULL)\\n                return false;\\n            node=node->child[s[i]-\\'a\\'];\\n        }\\n        return node->isEnd;\\n    }\\n    bool search(string searchWord) {\\n       \\n        \\n        string s=searchWord;\\n        int n=searchWord.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(\\'a\\'+j==searchWord[i])\\n                    continue;\\n                s[i]=\\'a\\'+j;\\n                if(check(s))\\n                {\\n                    return true;\\n                }\\n            }\\n            s[i]=searchWord[i];\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n   \\n    class Trie{\\n        public:\\n        Trie *child[26];\\n        bool isEnd;\\n        Trie()\\n        {\\n            isEnd=false;\\n            for(int i=0;i<26;i++)\\n                child[i]=NULL;\\n        }\\n    };\\n    Trie *root=new Trie();\\n    MagicDictionary() {\\n    \\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n     \\n        for(string s:dictionary)\\n        {\\n        Trie *node=root;      \\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(!node->child[s[i]-\\'a\\'])\\n                {\\n                    node->child[s[i]-\\'a\\']=new Trie();\\n                }\\n                node=node->child[s[i]-\\'a\\'];\\n            }\\n            node->isEnd=true;\\n        }\\n    }\\n    bool check(string s)\\n    {\\n        Trie *node=root;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(node->child[s[i]-\\'a\\']==NULL)\\n                return false;\\n            node=node->child[s[i]-\\'a\\'];\\n        }\\n        return node->isEnd;\\n    }\\n    bool search(string searchWord) {\\n       \\n        \\n        string s=searchWord;\\n        int n=searchWord.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(\\'a\\'+j==searchWord[i])\\n                    continue;\\n                s[i]=\\'a\\'+j;\\n                if(check(s))\\n                {\\n                    return true;\\n                }\\n            }\\n            s[i]=searchWord[i];\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627734,
                "title": "c-trie-dfs-try-all-combinations",
                "content": "```\\nclass MagicDictionary {\\nprivate:\\n    struct Node{\\n        Node* arr[26];\\n        bool end = false;\\n    };\\n    Node* root;\\npublic:\\n    MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void trie_insert(string &word){\\n        Node* node = root;\\n        for(int i = 0; i < word.size(); i++){\\n            if(node->arr[word[i] - \\'a\\'] == NULL){\\n                node->arr[word[i] - \\'a\\'] = new Node();\\n            }\\n            node = node->arr[word[i] - \\'a\\'];\\n        }\\n        node->end = true;\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto w: dictionary){ \\n            trie_insert(w);\\n        }\\n    }\\n    \\n    bool trie_search(string &word, Node* cur){\\n        for(int i = 0; i < word.size(); i++){\\n            if(cur->arr[word[i] - \\'a\\'] == NULL) return false;\\n            cur = cur->arr[word[i] - \\'a\\'];\\n        }\\n        return cur->end;\\n    }\\n    \\n    bool search(string searchWord) {\\n        for(int i = 0; i < searchWord.size(); i++){\\n            string temp = searchWord;\\n            for(int j = 0; j < 26; j++){\\n                char c = temp[i];\\n                temp[i] = \\'a\\' + j;\\n                if(temp == searchWord){\\n                    temp[i] = c;\\n                    continue;\\n                }\\n                if(trie_search(temp, root)) return true;\\n                temp[i] = c;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary {\\nprivate:\\n    struct Node{\\n        Node* arr[26];\\n        bool end = false;\\n    };\\n    Node* root;\\npublic:\\n    MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void trie_insert(string &word){\\n        Node* node = root;\\n        for(int i = 0; i < word.size(); i++){\\n            if(node->arr[word[i] - \\'a\\'] == NULL){\\n                node->arr[word[i] - \\'a\\'] = new Node();\\n            }\\n            node = node->arr[word[i] - \\'a\\'];\\n        }\\n        node->end = true;\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto w: dictionary){ \\n            trie_insert(w);\\n        }\\n    }\\n    \\n    bool trie_search(string &word, Node* cur){\\n        for(int i = 0; i < word.size(); i++){\\n            if(cur->arr[word[i] - \\'a\\'] == NULL) return false;\\n            cur = cur->arr[word[i] - \\'a\\'];\\n        }\\n        return cur->end;\\n    }\\n    \\n    bool search(string searchWord) {\\n        for(int i = 0; i < searchWord.size(); i++){\\n            string temp = searchWord;\\n            for(int j = 0; j < 26; j++){\\n                char c = temp[i];\\n                temp[i] = \\'a\\' + j;\\n                if(temp == searchWord){\\n                    temp[i] = c;\\n                    continue;\\n                }\\n                if(trie_search(temp, root)) return true;\\n                temp[i] = c;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2612946,
                "title": "cpp-solution-using-trie",
                "content": "```\\nclass node{\\n  public:\\n    node* v[26];\\n    int end=0;\\n    \\n    bool ispresent(char c){\\n        return this->v[c-\\'a\\']!=NULL;\\n    }\\n    \\n    void create(char c,node* n){\\n        this->v[c-\\'a\\']=n;\\n    }\\n    \\n    void setend(){\\n        this->end=1;\\n    }\\n};\\n\\nclass trie{\\n    public:\\n    node* root=new node();\\n    \\n    void insert(string key){\\n        node* r1=root;\\n        for(auto ele:key){\\n            \\n            if(!r1->ispresent(ele)){\\n                r1->create(ele,new node());    \\n            }\\n            \\n            r1=r1->v[ele-\\'a\\'];\\n        }\\n        \\n        r1->setend();\\n    }\\n    \\n    bool func(string s,int j,node* rm){\\n              \\n        for(j;j<s.size();j++){\\n            if(!rm->ispresent(s[j]))return false;\\n            \\n            rm=rm->v[s[j]-\\'a\\'];\\n        }\\n        \\n        return rm->end;\\n    }\\n    \\n    \\n    bool search(string s){\\n        node* r1=root;\\n        int a=0;\\n        \\n        for(int j=0;j<s.size();j++){\\n            \\n             for(int i=0;i<26;i++){\\n                if(r1->ispresent(char(\\'a\\'+i)) && s[j]-\\'a\\'!=i){\\n                    if(func(s,j+1,r1->v[i]))return true;   \\n                }\\n             }   \\n            \\n            if(r1->ispresent(s[j]))r1=r1->v[s[j]-\\'a\\'];\\n            else return false;\\n        }\\n        \\n        return false;\\n    }\\n    \\n};\\n\\nclass MagicDictionary {\\npublic:\\n    trie* root;\\n    MagicDictionary() {\\n        root=new trie();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto ele:dictionary){\\n            root->insert(ele);\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        return root->search(searchWord);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass node{\\n  public:\\n    node* v[26];\\n    int end=0;\\n    \\n    bool ispresent(char c){\\n        return this->v[c-\\'a\\']!=NULL;\\n    }\\n    \\n    void create(char c,node* n){\\n        this->v[c-\\'a\\']=n;\\n    }\\n    \\n    void setend(){\\n        this->end=1;\\n    }\\n};\\n\\nclass trie{\\n    public:\\n    node* root=new node();\\n    \\n    void insert(string key){\\n        node* r1=root;\\n        for(auto ele:key){\\n            \\n            if(!r1->ispresent(ele)){\\n                r1->create(ele,new node());    \\n            }\\n            \\n            r1=r1->v[ele-\\'a\\'];\\n        }\\n        \\n        r1->setend();\\n    }\\n    \\n    bool func(string s,int j,node* rm){\\n              \\n        for(j;j<s.size();j++){\\n            if(!rm->ispresent(s[j]))return false;\\n            \\n            rm=rm->v[s[j]-\\'a\\'];\\n        }\\n        \\n        return rm->end;\\n    }\\n    \\n    \\n    bool search(string s){\\n        node* r1=root;\\n        int a=0;\\n        \\n        for(int j=0;j<s.size();j++){\\n            \\n             for(int i=0;i<26;i++){\\n                if(r1->ispresent(char(\\'a\\'+i)) && s[j]-\\'a\\'!=i){\\n                    if(func(s,j+1,r1->v[i]))return true;   \\n                }\\n             }   \\n            \\n            if(r1->ispresent(s[j]))r1=r1->v[s[j]-\\'a\\'];\\n            else return false;\\n        }\\n        \\n        return false;\\n    }\\n    \\n};\\n\\nclass MagicDictionary {\\npublic:\\n    trie* root;\\n    MagicDictionary() {\\n        root=new trie();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto ele:dictionary){\\n            root->insert(ele);\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        return root->search(searchWord);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2592410,
                "title": "c-using-trie-low-t-c",
                "content": "```\\nclass node{\\npublic:\\n    node* links[26];\\n    bool flag=false;\\n};\\n\\nclass MagicDictionary {\\n    node* root;\\npublic:\\n    MagicDictionary() {\\n        root=new node();\\n    }\\n    \\n    void addKey(string s) {\\n        node* temp=root;\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(temp->links[s[i]-\\'a\\']==NULL) temp->links[s[i]-\\'a\\']=new node();\\n            temp=temp->links[s[i]-\\'a\\'];\\n        }\\n        \\n        temp->flag=true;\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto word:dictionary) {\\n            addKey(word);\\n        }\\n    }\\n    \\n    bool util(string s, node* temp, int i=0, bool changed=false) {\\n        if(i==s.length() && temp->flag && changed) return true;\\n        if(i==s.length()) return false;\\n        \\n        if(changed) {\\n            if(!temp->links[s[i]-\\'a\\']) return false;\\n            else return util(s, temp->links[s[i]-\\'a\\'], i+1, changed);\\n        } else {\\n            for(int j=0; j<26; j++) {\\n                if(s[i]!=\\'a\\'+j && temp->links[j] && util(s, temp->links[j], i+1, !changed)) return true;\\n            }\\n            \\n            if(temp->links[s[i]-\\'a\\'] && util(s, temp->links[s[i]-\\'a\\'], i+1, changed)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(string searchWord) {\\n        return util(searchWord, root);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass node{\\npublic:\\n    node* links[26];\\n    bool flag=false;\\n};\\n\\nclass MagicDictionary {\\n    node* root;\\npublic:\\n    MagicDictionary() {\\n        root=new node();\\n    }\\n    \\n    void addKey(string s) {\\n        node* temp=root;\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(temp->links[s[i]-\\'a\\']==NULL) temp->links[s[i]-\\'a\\']=new node();\\n            temp=temp->links[s[i]-\\'a\\'];\\n        }\\n        \\n        temp->flag=true;\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto word:dictionary) {\\n            addKey(word);\\n        }\\n    }\\n    \\n    bool util(string s, node* temp, int i=0, bool changed=false) {\\n        if(i==s.length() && temp->flag && changed) return true;\\n        if(i==s.length()) return false;\\n        \\n        if(changed) {\\n            if(!temp->links[s[i]-\\'a\\']) return false;\\n            else return util(s, temp->links[s[i]-\\'a\\'], i+1, changed);\\n        } else {\\n            for(int j=0; j<26; j++) {\\n                if(s[i]!=\\'a\\'+j && temp->links[j] && util(s, temp->links[j], i+1, !changed)) return true;\\n            }\\n            \\n            if(temp->links[s[i]-\\'a\\'] && util(s, temp->links[s[i]-\\'a\\'], i+1, changed)) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(string searchWord) {\\n        return util(searchWord, root);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2370650,
                "title": "easy-to-understand-c-recursion-trie",
                "content": "struct Trie{\\n    Trie *child[26];\\n    bool isEnd;\\n};\\n\\nclass MagicDictionary {\\npublic:\\n    \\n    Trie *root;\\n    \\n    MagicDictionary() {\\n        \\n        root = new Trie();\\n        for(int i=0;i<26;i++)\\n            root->child[i] = NULL;\\n        root->isEnd = false;\\n    }\\n    \\n    void insert(string &s,Trie *root){\\n        Trie *temp = root;\\n        for(int i=0;i<s.length();i++){\\n            int index = s[i]-\\'a\\';\\n            if(!temp->child[index])\\n                temp->child[index] = new Trie();\\n            temp = temp->child[index];\\n        }\\n        \\n        temp->isEnd = true;\\n    }//insert\\n    \\n    \\n    //k=0 => all characters are find till now\\n    //k=1 => one charaxters is missing\\n    \\n    bool find(string &s,int index,Trie *root ,int k){\\n        \\n        for(int i=index;i<s.length();i++){\\n            int index = s[i]-\\'a\\';\\n            if(k==1 && root->child[index]==NULL)\\n                return 0;\\n            \\n              if(k==0){ \\n                for(int j=0;j<26;j++){\\n                    if(root->child[j] && j!=index){\\n                        if(find(s,i+1,root->child[j],1))\\n                            return 1;\\n                    }\\n                }//j\\n              }   \\n            \\n               if(root->child[index]==NULL)\\n                 return 0;\\n               else\\n                   root = root->child[index];\\n            //}//if\\n          \\n        }//i\\n        \\n        return (root!=NULL && root->isEnd && k==1);\\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        \\n        int i,j,n=dict.size();\\n        for(auto x:dict)\\n            insert(x,root);\\n    }\\n    \\n    bool search(string s) {\\n        \\n        Trie *temp = root;\\n        return find(s,0,temp,0);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "struct Trie{\\n    Trie *child[26];\\n    bool isEnd;\\n};\\n\\nclass MagicDictionary {\\npublic:\\n    \\n    Trie *root;\\n    \\n    MagicDictionary() {\\n        \\n        root = new Trie();\\n        for(int i=0;i<26;i++)\\n            root->child[i] = NULL;\\n        root->isEnd = false;\\n    }\\n    \\n    void insert(string &s,Trie *root){\\n        Trie *temp = root;\\n        for(int i=0;i<s.length();i++){\\n            int index = s[i]-\\'a\\';\\n            if(!temp->child[index])\\n                temp->child[index] = new Trie();\\n            temp = temp->child[index];\\n        }\\n        \\n        temp->isEnd = true;\\n    }//insert\\n    \\n    \\n    //k=0 => all characters are find till now\\n    //k=1 => one charaxters is missing\\n    \\n    bool find(string &s,int index,Trie *root ,int k){\\n        \\n        for(int i=index;i<s.length();i++){\\n            int index = s[i]-\\'a\\';\\n            if(k==1 && root->child[index]==NULL)\\n                return 0;\\n            \\n              if(k==0){ \\n                for(int j=0;j<26;j++){\\n                    if(root->child[j] && j!=index){\\n                        if(find(s,i+1,root->child[j],1))\\n                            return 1;\\n                    }\\n                }//j\\n              }   \\n            \\n               if(root->child[index]==NULL)\\n                 return 0;\\n               else\\n                   root = root->child[index];\\n            //}//if\\n          \\n        }//i\\n        \\n        return (root!=NULL && root->isEnd && k==1);\\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        \\n        int i,j,n=dict.size();\\n        for(auto x:dict)\\n            insert(x,root);\\n    }\\n    \\n    bool search(string s) {\\n        \\n        Trie *temp = root;\\n        return find(s,0,temp,0);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2263829,
                "title": "java-trie",
                "content": "```\\nstatic class TrieTree {\\n\\n        TrieNode root = new TrieNode(\\' \\');\\n\\n        public void insert(String s) {\\n            TrieNode current = root;\\n            for (char c : s.toCharArray()) {\\n                current = current.children.computeIfAbsent(c, k -> new TrieNode(c));\\n            }\\n            current.isWord = true;\\n            current.fullWord = s;\\n        }\\n\\n        //Allow max 1 wrong character and still return found.\\n        // E.g. Trie has hello and hollo, but would still return true for hallo because it has only 1 wrong char\\n        public boolean searchWithMax1WrongChar(String searchWord, int beginIndex, TrieTree.TrieNode root, boolean usedWildcard) {\\n            for (int i = beginIndex; i < searchWord.length(); i++) {\\n                char data = searchWord.charAt(i);\\n                //Use the boolean \"usedWildcard\" as a single-use possibility to ignore 1 char\\n                if (!usedWildcard) {\\n                    for (TrieTree.TrieNode child : root.children.values()) {\\n                        if (searchWithMax1WrongChar(searchWord, i + 1, child, true)) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                if (!root.children.containsKey(data)) {\\n                    return false;\\n                }\\n                root = root.children.get(data);\\n            }\\n            return root.isWord && !root.fullWord.equals(searchWord);\\n        }\\n\\n        public boolean searchWithMax1WrongChar(String searchWord) {\\n            return searchWithMax1WrongChar(searchWord, 0, root, false);\\n        }\\n\\n        static class TrieNode {\\n            char val;\\n            boolean isWord;\\n            String fullWord;\\n            Map<Character, TrieNode> children;\\n\\n            public TrieNode(char val) {\\n                this.val = val;\\n                this.isWord = false;\\n                this.children = new HashMap<>();\\n            }\\n        }\\n    }\\n\\n    TrieTree trie;\\n\\n    public Trie1WrongChar() {\\n\\n    }\\n\\n    public void buildDict(String[] dictionary) {\\n        this.trie = new TrieTree();\\n        for (String word : dictionary) {\\n            trie.insert(word);\\n        }\\n\\n    }\\n\\n    public boolean search(String searchWord) {\\n        return trie.searchWithMax1WrongChar(searchWord);\\n    }",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nstatic class TrieTree {\\n\\n        TrieNode root = new TrieNode(\\' \\');\\n\\n        public void insert(String s) {\\n            TrieNode current = root;\\n            for (char c : s.toCharArray()) {\\n                current = current.children.computeIfAbsent(c, k -> new TrieNode(c));\\n            }\\n            current.isWord = true;\\n            current.fullWord = s;\\n        }\\n\\n        //Allow max 1 wrong character and still return found.\\n        // E.g. Trie has hello and hollo, but would still return true for hallo because it has only 1 wrong char\\n        public boolean searchWithMax1WrongChar(String searchWord, int beginIndex, TrieTree.TrieNode root, boolean usedWildcard) {\\n            for (int i = beginIndex; i < searchWord.length(); i++) {\\n                char data = searchWord.charAt(i);\\n                //Use the boolean \"usedWildcard\" as a single-use possibility to ignore 1 char\\n                if (!usedWildcard) {\\n                    for (TrieTree.TrieNode child : root.children.values()) {\\n                        if (searchWithMax1WrongChar(searchWord, i + 1, child, true)) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                if (!root.children.containsKey(data)) {\\n                    return false;\\n                }\\n                root = root.children.get(data);\\n            }\\n            return root.isWord && !root.fullWord.equals(searchWord);\\n        }\\n\\n        public boolean searchWithMax1WrongChar(String searchWord) {\\n            return searchWithMax1WrongChar(searchWord, 0, root, false);\\n        }\\n\\n        static class TrieNode {\\n            char val;\\n            boolean isWord;\\n            String fullWord;\\n            Map<Character, TrieNode> children;\\n\\n            public TrieNode(char val) {\\n                this.val = val;\\n                this.isWord = false;\\n                this.children = new HashMap<>();\\n            }\\n        }\\n    }\\n\\n    TrieTree trie;\\n\\n    public Trie1WrongChar() {\\n\\n    }\\n\\n    public void buildDict(String[] dictionary) {\\n        this.trie = new TrieTree();\\n        for (String word : dictionary) {\\n            trie.insert(word);\\n        }\\n\\n    }\\n\\n    public boolean search(String searchWord) {\\n        return trie.searchWithMax1WrongChar(searchWord);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2193262,
                "title": "python-trie-dfs",
                "content": "The idea:\\n\\n1. Create a trie from words. O(|words| \\\\* max_word_len)\\n2. Check each combination in the trie of the search_word with 1 char skipped. O(25\\\\*max_word_len^2) \\nExclude from the search the exact search_word if it is present in the original dict\\n\\ne.g.\\n```\\nsearch_word=hello, dict: hello, hullo\\n\\n_ello -> False, because this is search_word=dict[0] and requirements is - need 1 char different\\nh_llo -> True. We need to skip h[e]llo (0 diff) combination here and find h[u]llo (1 diff from the search_word)\\nhe_lo -> False\\nhel_o -> False\\nhell_ -> False\\n```\\n\\n```\\nclass Node(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\nclass MagicDictionary:\\n    def __init__(self):\\n        self.root = Node()\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        # O(|words| * len(word))\\n        for w in dictionary:\\n            node = self.root\\n            for c in w:\\n                if c not in node.children:\\n                    node.children[c] = Node()\\n                node = node.children[c]\\n            node.is_word = True\\n\\n    def search(self, search_word: str) -> bool:\\n        def find(idx, node, skip_idx, changes):\\n            if idx == n:\\n                return node.is_word and changes == 1\\n\\n            # skip one letter in search_word\\n            if skip_idx == idx:\\n                for c in node.children:\\n                    # avoid finding the same search_word in the dict\\n                    if c != search_word[skip_idx]:\\n                        if (find(idx + 1, node.children[c], skip_idx, changes + 1)):\\n                            return True\\n            # find the next letter in search_word\\n            elif search_word[idx] in node.children:\\n                return find(idx + 1, node.children[search_word[idx]], skip_idx, changes)\\n            \\n            # search_word next letter was not found in the trie\\n            return False\\n\\n        # O(25*n^2), where n = len(search_word)\\n        n = len(search_word)\\n        for skip_idx in range(n):\\n            # O(25*n), where n = len(search_word)\\n            if find(0, self.root, skip_idx, 0):\\n                return True\\n            \\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nsearch_word=hello, dict: hello, hullo\\n\\n_ello -> False, because this is search_word=dict[0] and requirements is - need 1 char different\\nh_llo -> True. We need to skip h[e]llo (0 diff) combination here and find h[u]llo (1 diff from the search_word)\\nhe_lo -> False\\nhel_o -> False\\nhell_ -> False\\n```\n```\\nclass Node(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n\\nclass MagicDictionary:\\n    def __init__(self):\\n        self.root = Node()\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        # O(|words| * len(word))\\n        for w in dictionary:\\n            node = self.root\\n            for c in w:\\n                if c not in node.children:\\n                    node.children[c] = Node()\\n                node = node.children[c]\\n            node.is_word = True\\n\\n    def search(self, search_word: str) -> bool:\\n        def find(idx, node, skip_idx, changes):\\n            if idx == n:\\n                return node.is_word and changes == 1\\n\\n            # skip one letter in search_word\\n            if skip_idx == idx:\\n                for c in node.children:\\n                    # avoid finding the same search_word in the dict\\n                    if c != search_word[skip_idx]:\\n                        if (find(idx + 1, node.children[c], skip_idx, changes + 1)):\\n                            return True\\n            # find the next letter in search_word\\n            elif search_word[idx] in node.children:\\n                return find(idx + 1, node.children[search_word[idx]], skip_idx, changes)\\n            \\n            # search_word next letter was not found in the trie\\n            return False\\n\\n        # O(25*n^2), where n = len(search_word)\\n        n = len(search_word)\\n        for skip_idx in range(n):\\n            # O(25*n), where n = len(search_word)\\n            if find(0, self.root, skip_idx, 0):\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064601,
                "title": "accepted-solution-in-c-using-tries-data-structure-very-easy-intuitive",
                "content": "```\\nclass Node {\\n    private:\\n    Node* links[26];\\n    bool flag = false;\\n    public:\\n    bool containsKey(char ch) {\\n        return links[ch-\\'a\\'] != nullptr;\\n    }\\n    void put(char ch, Node* node) {\\n        links[ch-\\'a\\'] = node;\\n    }\\n    Node* get(char ch) {\\n        return links[ch-\\'a\\'];\\n    }\\n    bool isEnd() {\\n        return flag;\\n    }\\n    void setEnd() {\\n        flag = true;\\n    }\\n};\\n\\nclass MagicDictionary {\\nprivate:\\n    Node* root;\\npublic:\\n    MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto word : dictionary) {\\n            Node* node = root;\\n            for(int i=0; i<word.length(); i++) {\\n                if(!node->containsKey(word[i])) {\\n                    node->put(word[i], new Node());\\n                }\\n                node = node->get(word[i]);\\n            }\\n            node->setEnd();\\n        }\\n    }\\n    bool dfs(string word) {\\n        Node* node = root;\\n        for(int i=0; i<word.length(); i++) {\\n            if(!node->containsKey(word[i])) return false;\\n            node = node->get(word[i]);\\n        }\\n        return node->isEnd();\\n    }\\n    bool search(string searchWord) {\\n        for(int i=0; i<searchWord.length(); i++) {\\n            char back = searchWord[i];\\n            for(char j=\\'a\\'; j<=\\'z\\'; j++) {\\n                if(j == back) continue;\\n                searchWord[i] = j;\\n                if(dfs(searchWord)) return true;\\n            }\\n            searchWord[i] = back;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Node {\\n    private:\\n    Node* links[26];\\n    bool flag = false;\\n    public:\\n    bool containsKey(char ch) {\\n        return links[ch-\\'a\\'] != nullptr;\\n    }\\n    void put(char ch, Node* node) {\\n        links[ch-\\'a\\'] = node;\\n    }\\n    Node* get(char ch) {\\n        return links[ch-\\'a\\'];\\n    }\\n    bool isEnd() {\\n        return flag;\\n    }\\n    void setEnd() {\\n        flag = true;\\n    }\\n};\\n\\nclass MagicDictionary {\\nprivate:\\n    Node* root;\\npublic:\\n    MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto word : dictionary) {\\n            Node* node = root;\\n            for(int i=0; i<word.length(); i++) {\\n                if(!node->containsKey(word[i])) {\\n                    node->put(word[i], new Node());\\n                }\\n                node = node->get(word[i]);\\n            }\\n            node->setEnd();\\n        }\\n    }\\n    bool dfs(string word) {\\n        Node* node = root;\\n        for(int i=0; i<word.length(); i++) {\\n            if(!node->containsKey(word[i])) return false;\\n            node = node->get(word[i]);\\n        }\\n        return node->isEnd();\\n    }\\n    bool search(string searchWord) {\\n        for(int i=0; i<searchWord.length(); i++) {\\n            char back = searchWord[i];\\n            for(char j=\\'a\\'; j<=\\'z\\'; j++) {\\n                if(j == back) continue;\\n                searchWord[i] = j;\\n                if(dfs(searchWord)) return true;\\n            }\\n            searchWord[i] = back;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049608,
                "title": "trie",
                "content": "class MagicDictionary {\\npublic:\\n    struct node\\n    {\\n        char val;\\n        node*arr[26]={NULL};\\n        bool isend;\\n        node(char ch)\\n        {\\n            val=ch;\\n            isend=false;\\n        }\\n    };\\n    node*root=new node(\\'\\\\0\\');\\n    void insert(string word)\\n    {\\n        node*temp=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(temp->arr[word[i]-\\'a\\']==NULL)\\n            {\\n                temp->arr[word[i]-\\'a\\']=new node(word[i]);\\n            }\\n            temp=temp->arr[word[i]-\\'a\\'];\\n        }\\n        temp->isend=true;\\n    }\\n    \\n    \\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> words) {\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            insert(words[i]);\\n        }\\n        \\n    }\\n    \\n    bool Search(node*temp,string word,int ind,int count)\\n    {\\n        if(ind==word.size()  && count==0 && temp->isend==true)\\n        {\\n            return true;\\n        }\\n        if(temp==NULL)\\n        {\\n            return false;\\n        }\\n        if(ind==word.size() && count!=0)\\n        {\\n            return false;\\n        }\\n        if(ind>=word.size())\\n        {\\n            return false;\\n        }\\n        if(count==0 && temp->arr[word[ind]-\\'a\\']==NULL) \\n        {\\n            return false;\\n        }\\n        bool res=false;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(temp->arr[i]!=NULL && (word[ind]-\\'a\\')!=i && count==1)\\n            {\\n                bool ans=Search(temp->arr[i],word,ind+1,count-1);\\n                res|=ans;\\n            }\\n        }\\n        return res | Search(temp->arr[word[ind]-\\'a\\'],word,ind+1,count);\\n    }\\n    \\n    bool search(string word) {\\n        \\n        return Search(root,word,0,1);\\n        \\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "class MagicDictionary {\\npublic:\\n    struct node\\n    {\\n        char val;\\n        node*arr[26]={NULL};\\n        bool isend;\\n        node(char ch)\\n        {\\n            val=ch;\\n            isend=false;\\n        }\\n    };\\n    node*root=new node(\\'\\\\0\\');\\n    void insert(string word)\\n    {\\n        node*temp=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(temp->arr[word[i]-\\'a\\']==NULL)\\n            {\\n                temp->arr[word[i]-\\'a\\']=new node(word[i]);\\n            }\\n            temp=temp->arr[word[i]-\\'a\\'];\\n        }\\n        temp->isend=true;\\n    }\\n    \\n    \\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> words) {\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            insert(words[i]);\\n        }\\n        \\n    }\\n    \\n    bool Search(node*temp,string word,int ind,int count)\\n    {\\n        if(ind==word.size()  && count==0 && temp->isend==true)\\n        {\\n            return true;\\n        }\\n        if(temp==NULL)\\n        {\\n            return false;\\n        }\\n        if(ind==word.size() && count!=0)\\n        {\\n            return false;\\n        }\\n        if(ind>=word.size())\\n        {\\n            return false;\\n        }\\n        if(count==0 && temp->arr[word[ind]-\\'a\\']==NULL) \\n        {\\n            return false;\\n        }\\n        bool res=false;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(temp->arr[i]!=NULL && (word[ind]-\\'a\\')!=i && count==1)\\n            {\\n                bool ans=Search(temp->arr[i],word,ind+1,count-1);\\n                res|=ans;\\n            }\\n        }\\n        return res | Search(temp->arr[word[ind]-\\'a\\'],word,ind+1,count);\\n    }\\n    \\n    bool search(string word) {\\n        \\n        return Search(root,word,0,1);\\n        \\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2026591,
                "title": "c-trie-solution-with-complexity-analysis",
                "content": "```\\nclass MagicDictionary {\\nprivate:\\n    struct Trie {\\n    private:\\n        bool isEnd = false;\\n        Trie *children[26];\\n    public:\\n        Trie () {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = NULL;\\n            }\\n        }\\n        \\n        void insert(string &s) {\\n            Trie *curr = this;\\n            for (char &c : s) {\\n                int cVal = c - \\'a\\';\\n                if (curr->children[cVal] == NULL) {\\n                    curr->children[cVal] = new Trie();\\n                }\\n                curr = curr->children[cVal];\\n            }\\n            curr->isEnd = true;\\n        }\\n        \\n        bool magicSearch(Trie *curr, string &s, int i, int diff) {\\n            if (diff < 0) return false;\\n            if (i == s.size()) return (curr->isEnd && diff == 0);\\n            for (int j = 0; j < 26; j++) {\\n                if (curr->children[j] == NULL) continue;\\n                if (magicSearch(curr->children[j], s, i + 1, diff - (s[i] != \\'a\\' + j))) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    };\\n    Trie trie;\\n    \\npublic:\\n    MagicDictionary() {\\n        \\n    }\\n    \\n\\t// Time complexity: O(MN), M = dictionary size, N = string size\\n\\t// Space complexity: O(MN), becuase the worse case is that we have to store every character in trie\\n    void buildDict(vector<string> dictionary) {\\n        for (string &s : dictionary) {\\n            trie.insert(s);\\n        }\\n    }\\n    \\n\\t// Time complexity: O(MN), because the worse case is that we have to search each character in trie\\n\\t// Space complexity: O(N), due to recursion, in the worse case we will have a stack size poportional to the longest word\\n    bool search(string searchWord) {\\n        return trie.magicSearch(&trie, searchWord, 0, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary {\\nprivate:\\n    struct Trie {\\n    private:\\n        bool isEnd = false;\\n        Trie *children[26];\\n    public:\\n        Trie () {\\n            for (int i = 0; i < 26; i++) {\\n                children[i] = NULL;\\n            }\\n        }\\n        \\n        void insert(string &s) {\\n            Trie *curr = this;\\n            for (char &c : s) {\\n                int cVal = c - \\'a\\';\\n                if (curr->children[cVal] == NULL) {\\n                    curr->children[cVal] = new Trie();\\n                }\\n                curr = curr->children[cVal];\\n            }\\n            curr->isEnd = true;\\n        }\\n        \\n        bool magicSearch(Trie *curr, string &s, int i, int diff) {\\n            if (diff < 0) return false;\\n            if (i == s.size()) return (curr->isEnd && diff == 0);\\n            for (int j = 0; j < 26; j++) {\\n                if (curr->children[j] == NULL) continue;\\n                if (magicSearch(curr->children[j], s, i + 1, diff - (s[i] != \\'a\\' + j))) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    };\\n    Trie trie;\\n    \\npublic:\\n    MagicDictionary() {\\n        \\n    }\\n    \\n\\t// Time complexity: O(MN), M = dictionary size, N = string size\\n\\t// Space complexity: O(MN), becuase the worse case is that we have to store every character in trie\\n    void buildDict(vector<string> dictionary) {\\n        for (string &s : dictionary) {\\n            trie.insert(s);\\n        }\\n    }\\n    \\n\\t// Time complexity: O(MN), because the worse case is that we have to search each character in trie\\n\\t// Space complexity: O(N), due to recursion, in the worse case we will have a stack size poportional to the longest word\\n    bool search(string searchWord) {\\n        return trie.magicSearch(&trie, searchWord, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013927,
                "title": "python",
                "content": "\\n\\n    def __init__(self):\\n        self.dict1 = defaultdict(list)\\n\\n    def buildDict(self, dictionary):\\n        for i in dictionary:\\n            self.dict1[len(i)].append(i)\\n\\n    def search(self, searchWord):\\n        if len(searchWord) not in self.dict1:\\n            return False\\n        \\n        for i in range(len(searchWord)):\\n            newword = searchWord[:i] + searchWord[i+1:]\\n            \\n            for j in self.dict1[len(searchWord)]:\\n                if searchWord == j:\\n                    continue\\n                    \\n                newj = j[:i] + j[i+1:]\\n                \\n                if newword == newj:\\n                    return True\\n                \\n        return False",
                "solutionTags": [],
                "code": "\\n\\n    def __init__(self):\\n        self.dict1 = defaultdict(list)\\n\\n    def buildDict(self, dictionary):\\n        for i in dictionary:\\n            self.dict1[len(i)].append(i)\\n\\n    def search(self, searchWord):\\n        if len(searchWord) not in self.dict1:\\n            return False\\n        \\n        for i in range(len(searchWord)):\\n            newword = searchWord[:i] + searchWord[i+1:]\\n            \\n            for j in self.dict1[len(searchWord)]:\\n                if searchWord == j:\\n                    continue\\n                    \\n                newj = j[:i] + j[i+1:]\\n                \\n                if newword == newj:\\n                    return True\\n                \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2002032,
                "title": "python-solution-hash-with-dict-faster-than-60-time-o-nk-space-o-nk",
                "content": "\\tclass MagicDictionary:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.magic_dict = dict() \\n\\n\\t\\tdef buildDict(self, dictionary: List[str]) -> None:\\n\\t\\t\\tfor word in dictionary: \\n\\t\\t\\t\\tword_len = len(word)\\n\\t\\t\\t\\tfor i in range(word_len): \\n\\t\\t\\t\\t\\tkey = word[:i] + \\'*\\' + word[i+1:]\\n\\t\\t\\t\\t\\tif key not in self.magic_dict: \\n\\t\\t\\t\\t\\t\\tself.magic_dict[key] = set()\\n\\t\\t\\t\\t\\t\\tself.magic_dict[key].add(word[i])\\n\\t\\t\\t\\t\\telif key in self.magic_dict: \\n\\t\\t\\t\\t\\t\\tself.magic_dict[key].add(word[i])\\n\\n\\t\\tdef search(self, searchWord: str) -> bool:\\n\\t\\t\\tsearch_word_len = len(searchWord)\\n\\t\\t\\tfor i in range(search_word_len): \\n\\t\\t\\t\\tsearch_string = searchWord[:i] + \\'*\\' + searchWord[i+1:]\\n\\t\\t\\t\\tif search_string in self.magic_dict:\\n\\t\\t\\t\\t\\tif len(self.magic_dict[search_string]) == 1 and searchWord[i] not in self.magic_dict[search_string]:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\telif len(self.magic_dict[search_string]) >= 2: \\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False    \\n\\n\\t# Your MagicDictionary object will be instantiated and called as such:\\n\\t# obj = MagicDictionary()\\n\\t# obj.buildDict(dictionary)\\n\\t# param_2 = obj.search(searchWord)",
                "solutionTags": [],
                "code": "\\tclass MagicDictionary:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.magic_dict = dict() \\n\\n\\t\\tdef buildDict(self, dictionary: List[str]) -> None:\\n\\t\\t\\tfor word in dictionary: \\n\\t\\t\\t\\tword_len = len(word)\\n\\t\\t\\t\\tfor i in range(word_len): \\n\\t\\t\\t\\t\\tkey = word[:i] + \\'*\\' + word[i+1:]\\n\\t\\t\\t\\t\\tif key not in self.magic_dict: \\n\\t\\t\\t\\t\\t\\tself.magic_dict[key] = set()\\n\\t\\t\\t\\t\\t\\tself.magic_dict[key].add(word[i])\\n\\t\\t\\t\\t\\telif key in self.magic_dict: \\n\\t\\t\\t\\t\\t\\tself.magic_dict[key].add(word[i])\\n\\n\\t\\tdef search(self, searchWord: str) -> bool:\\n\\t\\t\\tsearch_word_len = len(searchWord)\\n\\t\\t\\tfor i in range(search_word_len): \\n\\t\\t\\t\\tsearch_string = searchWord[:i] + \\'*\\' + searchWord[i+1:]\\n\\t\\t\\t\\tif search_string in self.magic_dict:\\n\\t\\t\\t\\t\\tif len(self.magic_dict[search_string]) == 1 and searchWord[i] not in self.magic_dict[search_string]:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\telif len(self.magic_dict[search_string]) >= 2: \\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False    \\n\\n\\t# Your MagicDictionary object will be instantiated and called as such:\\n\\t# obj = MagicDictionary()\\n\\t# obj.buildDict(dictionary)\\n\\t# param_2 = obj.search(searchWord)",
                "codeTag": "Java"
            },
            {
                "id": 1866121,
                "title": "java-trie-recursion",
                "content": "```\\nclass MagicDictionary {\\n    TrieNode root;\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String s: dictionary){\\n            insertWord(s);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        return search(searchWord, true, root, 0);\\n    }\\n    \\n    private boolean search(String word, boolean canVary, TrieNode root, int index){\\n        TrieNode cur = root;\\n        if(index == word.length())\\n            return !canVary && root.eow;\\n        for(int i=index;i<word.length();i++){\\n            if(canVary){\\n                for(int j=0;j<26;j++){\\n                    if(cur.children[j]!=null){\\n                        if(search(word, ((word.charAt(i)-\\'a\\')==j), cur.children[j], i+1))\\n                            return true;\\n                    }\\n                }\\n                return false;\\n            } else {\\n                if(cur.children[word.charAt(i)-\\'a\\']==null)\\n                    return false;\\n                cur = cur.children[word.charAt(i)-\\'a\\'];\\n            }\\n        }\\n        return !canVary && cur.eow;\\n    }\\n    \\n    private void insertWord(String word){\\n        TrieNode cur = root;\\n        for(int i=0;i<word.length();i++){\\n            int x = word.charAt(i)-\\'a\\';\\n            if(cur.children[x]==null)\\n                cur.children[x]=new TrieNode();\\n            cur = cur.children[x];\\n        }\\n        cur.eow = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean eow;\\n    public TrieNode(){\\n        eow = false;\\n        children = new TrieNode[26];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary {\\n    TrieNode root;\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String s: dictionary){\\n            insertWord(s);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        return search(searchWord, true, root, 0);\\n    }\\n    \\n    private boolean search(String word, boolean canVary, TrieNode root, int index){\\n        TrieNode cur = root;\\n        if(index == word.length())\\n            return !canVary && root.eow;\\n        for(int i=index;i<word.length();i++){\\n            if(canVary){\\n                for(int j=0;j<26;j++){\\n                    if(cur.children[j]!=null){\\n                        if(search(word, ((word.charAt(i)-\\'a\\')==j), cur.children[j], i+1))\\n                            return true;\\n                    }\\n                }\\n                return false;\\n            } else {\\n                if(cur.children[word.charAt(i)-\\'a\\']==null)\\n                    return false;\\n                cur = cur.children[word.charAt(i)-\\'a\\'];\\n            }\\n        }\\n        return !canVary && cur.eow;\\n    }\\n    \\n    private void insertWord(String word){\\n        TrieNode cur = root;\\n        for(int i=0;i<word.length();i++){\\n            int x = word.charAt(i)-\\'a\\';\\n            if(cur.children[x]==null)\\n                cur.children[x]=new TrieNode();\\n            cur = cur.children[x];\\n        }\\n        cur.eow = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean eow;\\n    public TrieNode(){\\n        eow = false;\\n        children = new TrieNode[26];\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1823576,
                "title": "java-solution",
                "content": "```class MagicDictionary {\\n    List<String> myList;\\n\\n    public MagicDictionary() {\\n        myList = new LinkedList<String>();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(int i =0; i < dictionary.length; i++)\\n        {\\n            myList.add(dictionary[i]);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        for(int i =0; i < myList.size(); i++)\\n        {\\n            if(myList.get(i).length() == searchWord.length())\\n            {\\n                int count = 0;\\n                String s = myList.get(i);\\n                int j = 0;\\n                for(int t =0; t < s.length(); t++)\\n                {\\n                    if(s.charAt(t) != searchWord.charAt(j)){\\n                        count++;\\n                    }\\n                    j++;\\n                }\\n                if(count == 1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */",
                "solutionTags": [],
                "code": "```class MagicDictionary {\\n    List<String> myList;\\n\\n    public MagicDictionary() {\\n        myList = new LinkedList<String>();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(int i =0; i < dictionary.length; i++)\\n        {\\n            myList.add(dictionary[i]);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        for(int i =0; i < myList.size(); i++)\\n        {\\n            if(myList.get(i).length() == searchWord.length())\\n            {\\n                int count = 0;\\n                String s = myList.get(i);\\n                int j = 0;\\n                for(int t =0; t < s.length(); t++)\\n                {\\n                    if(s.charAt(t) != searchWord.charAt(j)){\\n                        count++;\\n                    }\\n                    j++;\\n                }\\n                if(count == 1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1682266,
                "title": "c-trie-backtracking-solution",
                "content": "```\\nclass Trie {\\nprivate:\\n    vector<Trie *> child;\\n    bool isEnd;\\npublic:\\n    Trie () : child(26, NULL) {\\n        isEnd = false;\\n    }\\n    \\n    void insert(string &s) {\\n        Trie *curr = this;\\n        for (char &c : s) {\\n            int cIndex = c - \\'a\\';\\n            if (curr->child[cIndex] == NULL) {\\n                curr->child[cIndex] = new Trie();\\n            }\\n            curr = curr->child[cIndex];\\n        }\\n        curr->isEnd = true;\\n    }\\n    \\n    bool helper(Trie *curr, string &s, int i, int cnt) {\\n        \\n        if (cnt > 1) return false;\\n        \\n        if (i == s.size()) {\\n            if (curr->isEnd && cnt == 1) return true;\\n            return false;\\n        }\\n        \\n        for (int k = 0; k < 26; k++) {\\n            if (curr->child[k] == NULL) continue;\\n            if (helper(curr->child[k], s, i + 1, (k == s[i] - \\'a\\' ? cnt : cnt + 1))) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool strangeSearch(string &s) {\\n        return helper(this, s, 0, 0);\\n    }\\n};\\n\\nclass MagicDictionary {\\nprivate:\\n    Trie trie;\\npublic:\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for (string &eachS : dictionary) {\\n            trie.insert(eachS);\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        return trie.strangeSearch(searchWord);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\nprivate:\\n    vector<Trie *> child;\\n    bool isEnd;\\npublic:\\n    Trie () : child(26, NULL) {\\n        isEnd = false;\\n    }\\n    \\n    void insert(string &s) {\\n        Trie *curr = this;\\n        for (char &c : s) {\\n            int cIndex = c - \\'a\\';\\n            if (curr->child[cIndex] == NULL) {\\n                curr->child[cIndex] = new Trie();\\n            }\\n            curr = curr->child[cIndex];\\n        }\\n        curr->isEnd = true;\\n    }\\n    \\n    bool helper(Trie *curr, string &s, int i, int cnt) {\\n        \\n        if (cnt > 1) return false;\\n        \\n        if (i == s.size()) {\\n            if (curr->isEnd && cnt == 1) return true;\\n            return false;\\n        }\\n        \\n        for (int k = 0; k < 26; k++) {\\n            if (curr->child[k] == NULL) continue;\\n            if (helper(curr->child[k], s, i + 1, (k == s[i] - \\'a\\' ? cnt : cnt + 1))) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool strangeSearch(string &s) {\\n        return helper(this, s, 0, 0);\\n    }\\n};\\n\\nclass MagicDictionary {\\nprivate:\\n    Trie trie;\\npublic:\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for (string &eachS : dictionary) {\\n            trie.insert(eachS);\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        return trie.strangeSearch(searchWord);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667766,
                "title": "java-3-solutions-observations-trie-hashmap",
                "content": "# Solution 1 : \\n* TC : \\n\\t*  buildDict : `O(n) `, where `n` is the number of words in the dictionary\\n\\t*  search : `O(n*k)`, where `k` is the length of word we are checking\\n    \\n* SC : `O(n)`\\n* Drawback : `Kills memory as the dictionary increases`\\n```\\nclass MagicDictionary {\\n    \\n    HashMap<Integer, HashSet<String>> map; \\n\\t// HashSet / Arraylist, doesn\\'t make a diff bcz it is given in the question -> given a list of \"different\" words\\n    public MagicDictionary() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String word : dictionary) {\\n            if(!map.containsKey(word.length())) {\\n                map.put(word.length(), new HashSet<String>());\\n            }\\n            map.get(word.length()).add(word);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        if(!map.containsKey(searchWord.length()))\\n            return false;\\n        \\n        for(String words : map.get(searchWord.length())) {\\n            int count = 0;\\n            for(int i=0;i<searchWord.length();i++) {\\n                count += words.charAt(i) == searchWord.charAt(i) ? 0 : 1;\\n            }\\n            if(count == 1) return true;\\n        }\\n        return false;\\n    }\\n}\\n ```\\n \\n # Solution 2: \\nThe given constraints is an intuition to use `Trie` data-structure.\\nCode Observations : \\n* `Search Operation` is not optimized as we are changing one char and searching for the complete word again.\\n\\nComplexity Analysis : \\n* TC : `O(n*m) + O(k*26*k)`, where `k` is the length of word we are searching\\n* SC : `O(n*m)`\\n ```\\n class Node {\\n    HashMap<Character, Node> children;\\n    boolean isEnd;\\n    Node() {\\n        this.children = new HashMap<>();\\n        this.isEnd = false;\\n    }\\n}\\nclass MagicDictionary {\\n    \\n    private Node root;\\n    private int maxLength;\\n    \\n    public MagicDictionary() {\\n        this.root = new Node();\\n        this.maxLength = 0;\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String word : dictionary) {\\n            Node curr = this.root;\\n            maxLength = Math.max(maxLength, word.length());\\n            for(char ch : word.toCharArray()) {\\n                if(curr.children.get(ch) == null) \\n                    curr.children.put(ch, new Node());\\n                curr = curr.children.get(ch);\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        if(maxLength < searchWord.length()) \\n            return false;\\n        \\n        char[] W = searchWord.toCharArray();\\n        int n = W.length;\\n        Node curr = this.root;\\n        for(int i=0;i<n;i++) {\\n            char original = W[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++) {\\n                if(ch != original) \\n                {\\n                    W[i] = ch;\\n                    // curr char changed -> search complete string\\n                    if(searchWord(W)) return true;\\n                    W[i] = original;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean searchWord(char[] W) {        \\n        Node curr = this.root;\\n        for(int i=0;i<W.length;i++) {\\n            if(curr.children.get(W[i]) == null) return false;\\n            curr = curr.children.get(W[i]);\\n        }\\n        return curr.isEnd;\\n    }\\n}\\n```\\n\\n# Solution 3 : \\nThis approach is bit more optimized in `search(searchWord)` functionality.\\n* Complexity of below solution would be better in average cases but in worst case, matches with the above solution.\\n```\\nclass Node {\\n    HashMap<Character, Node> children;\\n    boolean isEnd;\\n    Node() {\\n        this.children = new HashMap<>();\\n        this.isEnd = false;\\n    }\\n}\\nclass MagicDictionary {\\n    \\n    private Node root;\\n    private int maxLength;\\n    \\n    public MagicDictionary() {\\n        this.root = new Node();\\n        this.maxLength = 0;\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String word : dictionary) {\\n            Node curr = this.root;\\n            maxLength = Math.max(maxLength, word.length());\\n            for(char ch : word.toCharArray()) {\\n                if(curr.children.get(ch) == null) \\n                    curr.children.put(ch, new Node());\\n                curr = curr.children.get(ch);\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        if(maxLength < searchWord.length()) \\n            return false;\\n        \\n        char[] W = searchWord.toCharArray();\\n        int n = W.length;\\n        Node curr = this.root;\\n        for(int i=0;i<n;i++) {\\n            char original = W[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++) {\\n                if(curr.children.get(ch) == null) continue;\\n                if(ch != original) \\n                {\\n                    W[i] = ch;\\n                    // curr char changed -> search for string ahead\\n                    if(searchWord(curr.children.get(W[i]), W, i+1)) return true;\\n                    W[i] = original;\\n                }\\n            }\\n\\t\\t\\t// if we can not go ahead -> return false\\n            if(curr.children.get(W[i]) == null) return false;\\n            curr = curr.children.get(W[i]);\\n        }\\n        return false;\\n    }\\n    \\n    private boolean searchWord(Node curr, char[] W, int index) {        \\n        // Node curr = this.root;\\n        for(int i=index;i<W.length;i++) {\\n            if(curr.children.get(W[i]) == null) return false;\\n            curr = curr.children.get(W[i]);\\n        }\\n        return curr.isEnd;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary {\\n    \\n    HashMap<Integer, HashSet<String>> map; \\n\\t// HashSet / Arraylist, doesn\\'t make a diff bcz it is given in the question -> given a list of \"different\" words\\n    public MagicDictionary() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String word : dictionary) {\\n            if(!map.containsKey(word.length())) {\\n                map.put(word.length(), new HashSet<String>());\\n            }\\n            map.get(word.length()).add(word);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        if(!map.containsKey(searchWord.length()))\\n            return false;\\n        \\n        for(String words : map.get(searchWord.length())) {\\n            int count = 0;\\n            for(int i=0;i<searchWord.length();i++) {\\n                count += words.charAt(i) == searchWord.charAt(i) ? 0 : 1;\\n            }\\n            if(count == 1) return true;\\n        }\\n        return false;\\n    }\\n}\\n ```\n```\\n class Node {\\n    HashMap<Character, Node> children;\\n    boolean isEnd;\\n    Node() {\\n        this.children = new HashMap<>();\\n        this.isEnd = false;\\n    }\\n}\\nclass MagicDictionary {\\n    \\n    private Node root;\\n    private int maxLength;\\n    \\n    public MagicDictionary() {\\n        this.root = new Node();\\n        this.maxLength = 0;\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String word : dictionary) {\\n            Node curr = this.root;\\n            maxLength = Math.max(maxLength, word.length());\\n            for(char ch : word.toCharArray()) {\\n                if(curr.children.get(ch) == null) \\n                    curr.children.put(ch, new Node());\\n                curr = curr.children.get(ch);\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        if(maxLength < searchWord.length()) \\n            return false;\\n        \\n        char[] W = searchWord.toCharArray();\\n        int n = W.length;\\n        Node curr = this.root;\\n        for(int i=0;i<n;i++) {\\n            char original = W[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++) {\\n                if(ch != original) \\n                {\\n                    W[i] = ch;\\n                    // curr char changed -> search complete string\\n                    if(searchWord(W)) return true;\\n                    W[i] = original;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean searchWord(char[] W) {        \\n        Node curr = this.root;\\n        for(int i=0;i<W.length;i++) {\\n            if(curr.children.get(W[i]) == null) return false;\\n            curr = curr.children.get(W[i]);\\n        }\\n        return curr.isEnd;\\n    }\\n}\\n```\n```\\nclass Node {\\n    HashMap<Character, Node> children;\\n    boolean isEnd;\\n    Node() {\\n        this.children = new HashMap<>();\\n        this.isEnd = false;\\n    }\\n}\\nclass MagicDictionary {\\n    \\n    private Node root;\\n    private int maxLength;\\n    \\n    public MagicDictionary() {\\n        this.root = new Node();\\n        this.maxLength = 0;\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String word : dictionary) {\\n            Node curr = this.root;\\n            maxLength = Math.max(maxLength, word.length());\\n            for(char ch : word.toCharArray()) {\\n                if(curr.children.get(ch) == null) \\n                    curr.children.put(ch, new Node());\\n                curr = curr.children.get(ch);\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        if(maxLength < searchWord.length()) \\n            return false;\\n        \\n        char[] W = searchWord.toCharArray();\\n        int n = W.length;\\n        Node curr = this.root;\\n        for(int i=0;i<n;i++) {\\n            char original = W[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++) {\\n                if(curr.children.get(ch) == null) continue;\\n                if(ch != original) \\n                {\\n                    W[i] = ch;\\n                    // curr char changed -> search for string ahead\\n                    if(searchWord(curr.children.get(W[i]), W, i+1)) return true;\\n                    W[i] = original;\\n                }\\n            }\\n\\t\\t\\t// if we can not go ahead -> return false\\n            if(curr.children.get(W[i]) == null) return false;\\n            curr = curr.children.get(W[i]);\\n        }\\n        return false;\\n    }\\n    \\n    private boolean searchWord(Node curr, char[] W, int index) {        \\n        // Node curr = this.root;\\n        for(int i=index;i<W.length;i++) {\\n            if(curr.children.get(W[i]) == null) return false;\\n            curr = curr.children.get(W[i]);\\n        }\\n        return curr.isEnd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656090,
                "title": "golang-hashmap",
                "content": "```golang\\ntype MagicDictionary struct {\\n\\tneightbour map[string]int\\n\\torigin     map[string]int\\n}\\n\\nfunc Constructor() MagicDictionary {\\n\\tm := MagicDictionary{map[string]int{}, map[string]int{}}\\n\\treturn m\\n}\\n\\nfunc (this *MagicDictionary) BuildDict(dictionary []string) {\\n\\tfor _, word := range dictionary {\\n\\t\\tthis.origin[word]++\\n\\t\\tfor i, _ := range word {\\n\\t\\t\\tt := []byte(word)\\n\\t\\t\\tt[i] = \\'_\\'\\n\\t\\t\\tthis.neightbour[string(t)]++\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *MagicDictionary) Search(searchWord string) bool {\\n\\tcnt := this.origin[searchWord]\\n\\tfor i, _ := range searchWord {\\n\\t\\tt := []byte(searchWord)\\n\\t\\tt[i] = \\'_\\'\\n\\t\\tif cnt > 1 || this.neightbour[string(t)] > cnt {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\ntype MagicDictionary struct {\\n\\tneightbour map[string]int\\n\\torigin     map[string]int\\n}\\n\\nfunc Constructor() MagicDictionary {\\n\\tm := MagicDictionary{map[string]int{}, map[string]int{}}\\n\\treturn m\\n}\\n\\nfunc (this *MagicDictionary) BuildDict(dictionary []string) {\\n\\tfor _, word := range dictionary {\\n\\t\\tthis.origin[word]++\\n\\t\\tfor i, _ := range word {\\n\\t\\t\\tt := []byte(word)\\n\\t\\t\\tt[i] = \\'_\\'\\n\\t\\t\\tthis.neightbour[string(t)]++\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *MagicDictionary) Search(searchWord string) bool {\\n\\tcnt := this.origin[searchWord]\\n\\tfor i, _ := range searchWord {\\n\\t\\tt := []byte(searchWord)\\n\\t\\tt[i] = \\'_\\'\\n\\t\\tif cnt > 1 || this.neightbour[string(t)] > cnt {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1642843,
                "title": "java-solution-100-less-memory-use-78-64-faster",
                "content": "```\\nclass MagicDictionary {\\n     HashSet<String> hs; \\n    public MagicDictionary() {\\n        hs = new HashSet<>();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n       for(String s:dictionary){\\n           hs.add(s);\\n       }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        for(String s:hs){\\n            if(s.length()==searchWord.length()){\\n                int cnt = 0;\\n                for(int i = 0;i<searchWord.length();i++){\\n                    if(s.charAt(i)!=searchWord.charAt(i))cnt++;\\n                }\\n                if(cnt==1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MagicDictionary {\\n     HashSet<String> hs; \\n    public MagicDictionary() {\\n        hs = new HashSet<>();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n       for(String s:dictionary){\\n           hs.add(s);\\n       }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        for(String s:hs){\\n            if(s.length()==searchWord.length()){\\n                int cnt = 0;\\n                for(int i = 0;i<searchWord.length();i++){\\n                    if(s.charAt(i)!=searchWord.charAt(i))cnt++;\\n                }\\n                if(cnt==1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577539,
                "title": "python-simple-trie-dfs-recursive-solution-with-explanation",
                "content": "For the Trie implementation I am not creating another TrieNode class instead using a dictionary as node and for wordEnd I am using \"~\" == True, if \"~\" is present in dictionary then the word ends here, since dictionary only contains lower case english letters so it will not be a problem\\n```\\nclass MagicDictionary:\\n    def __init__(self):\\n        self.root = {}\\n\\n    def buildDict(self, dictionary) -> None:\\n        for word in dictionary:\\n            curr = self.root  #resetting curr to root\\n            for letter in word:\\n                if letter not in curr:\\n                    curr[letter] = {}\\n                curr = curr[letter]\\n            curr[\"~\"] = True  #to signify word end\\n\\n    def search(self, searchWord: str) -> bool:\\n        return self._search(searchWord, self.root, 0, 0)\\n\\t\\t\\n    #I got the idea for this implementation from the knapsack pattern we use in dynamic programming\\n\\t#At every iteration we have two options either we choose the letter at index i or we skip it and choose any other letter from Trie marking diff as 1\\n\\t#we will try both options and keep the best result\\n\\t#but only if diff is 0 ,if diff is already 1 that means we have already changed a letter and now we can only choose letter at current index i, since we need exactly 1 different character\\n\\t\\n    def _search(self, word, node, diff, i):\\n        if i == len(word):\\n            if \"~\" in node and diff == 1: return True  #since we need difference of exactly one character\\n            else: return False\\n        \\n        res = False\\n        if diff == 0:  \\n            for letter in node:\\n                if letter == word[i] or letter == \"~\": continue  #ignoring curr index and \"~\"\\n                res = res or self._search(word, node[letter], diff+1, i+1)\\n        \\n        if word[i] in node:\\n            res = res or self._search(word, node[word[i]], diff, i+1)  # using \"or\" so that if any of the recursive calls returns true res will be true\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary:\\n    def __init__(self):\\n        self.root = {}\\n\\n    def buildDict(self, dictionary) -> None:\\n        for word in dictionary:\\n            curr = self.root  #resetting curr to root\\n            for letter in word:\\n                if letter not in curr:\\n                    curr[letter] = {}\\n                curr = curr[letter]\\n            curr[\"~\"] = True  #to signify word end\\n\\n    def search(self, searchWord: str) -> bool:\\n        return self._search(searchWord, self.root, 0, 0)\\n\\t\\t\\n    #I got the idea for this implementation from the knapsack pattern we use in dynamic programming\\n\\t#At every iteration we have two options either we choose the letter at index i or we skip it and choose any other letter from Trie marking diff as 1\\n\\t#we will try both options and keep the best result\\n\\t#but only if diff is 0 ,if diff is already 1 that means we have already changed a letter and now we can only choose letter at current index i, since we need exactly 1 different character\\n\\t\\n    def _search(self, word, node, diff, i):\\n        if i == len(word):\\n            if \"~\" in node and diff == 1: return True  #since we need difference of exactly one character\\n            else: return False\\n        \\n        res = False\\n        if diff == 0:  \\n            for letter in node:\\n                if letter == word[i] or letter == \"~\": continue  #ignoring curr index and \"~\"\\n                res = res or self._search(word, node[letter], diff+1, i+1)\\n        \\n        if word[i] in node:\\n            res = res or self._search(word, node[word[i]], diff, i+1)  # using \"or\" so that if any of the recursive calls returns true res will be true\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548929,
                "title": "easy-java-solution-no-extra-space",
                "content": "class MagicDictionary {\\n    \\n\\tString[] magicDictionary;\\n    public MagicDictionary() {}\\n    \\n    public void buildDict(String[] dictionary) {\\n        magicDictionary = dictionary;\\n    }\\n    \\n    public boolean canMatch(String searchWord , String dictWord){\\n        if(dictWord.length() == searchWord.length() && !searchWord.equals(dictWord))\\n            for(int i = 0 ; i < dictWord.length() ; i++)\\n                if(searchWord.charAt(i) != dictWord.charAt(i)) \\n                    return searchWord.substring(i+1).equals(dictWord.substring(i+1));\\n            \\n        return false;\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        for(String dictWord : magicDictionary){\\n            if(canMatch(searchWord , dictWord)) return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class MagicDictionary {\\n    \\n\\tString[] magicDictionary;\\n    public MagicDictionary() {}\\n    \\n    public void buildDict(String[] dictionary) {\\n        magicDictionary = dictionary;\\n    }\\n    \\n    public boolean canMatch(String searchWord , String dictWord){\\n        if(dictWord.length() == searchWord.length() && !searchWord.equals(dictWord))\\n            for(int i = 0 ; i < dictWord.length() ; i++)\\n                if(searchWord.charAt(i) != dictWord.charAt(i)) \\n                    return searchWord.substring(i+1).equals(dictWord.substring(i+1));\\n            \\n        return false;\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        for(String dictWord : magicDictionary){\\n            if(canMatch(searchWord , dictWord)) return true;\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1479471,
                "title": "java-trie-150-ms",
                "content": "```\\nclass TrieNode{\\n    protected boolean isWord;\\n    protected TrieNode[] children;\\n    \\n    protected TrieNode(){\\n        this.isWord = false;\\n        this.children = new TrieNode[26];\\n    }\\n}\\n\\nclass MagicDictionary {\\n    private TrieNode root;\\n    \\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        this.root = new TrieNode();    \\n    }\\n    \\n    public void buildDict(String[] dictionary) { // insert all words in a Trie\\n        for(String word : dictionary){\\n            int i, index, n = word.length();\\n            TrieNode current = this.root;\\n            \\n            for(i = 0; i < n; i++){\\n                index = word.charAt(i) - \\'a\\';\\n                if(current.children[index] == null){\\n                    current.children[index] = new TrieNode();\\n                }\\n                \\n                current = current.children[index];\\n            }\\n            \\n            current.isWord = true;\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        char[] letters = searchWord.toCharArray();\\n        int i, n = letters.length;\\n        char ch, original;\\n        \\n        for(i = 0; i < n; i++){\\n            original = letters[i];\\n            for(ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n                if(ch != original){   // try all characters except original character - ensures exact 1 char difference\\n                    letters[i] = ch;\\n                    if(search(this.root, letters, n)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n            letters[i] = original;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean search(TrieNode node, char[] letters, int n){\\n        TrieNode current = node;\\n        \\n        for(int i = 0; i < n; i++){\\n            current = current.children[letters[i] - \\'a\\'];\\n            if(current == null){\\n                return false;\\n            }\\n        }\\n        \\n        return current.isWord;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n    protected boolean isWord;\\n    protected TrieNode[] children;\\n    \\n    protected TrieNode(){\\n        this.isWord = false;\\n        this.children = new TrieNode[26];\\n    }\\n}\\n\\nclass MagicDictionary {\\n    private TrieNode root;\\n    \\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        this.root = new TrieNode();    \\n    }\\n    \\n    public void buildDict(String[] dictionary) { // insert all words in a Trie\\n        for(String word : dictionary){\\n            int i, index, n = word.length();\\n            TrieNode current = this.root;\\n            \\n            for(i = 0; i < n; i++){\\n                index = word.charAt(i) - \\'a\\';\\n                if(current.children[index] == null){\\n                    current.children[index] = new TrieNode();\\n                }\\n                \\n                current = current.children[index];\\n            }\\n            \\n            current.isWord = true;\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        char[] letters = searchWord.toCharArray();\\n        int i, n = letters.length;\\n        char ch, original;\\n        \\n        for(i = 0; i < n; i++){\\n            original = letters[i];\\n            for(ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n                if(ch != original){   // try all characters except original character - ensures exact 1 char difference\\n                    letters[i] = ch;\\n                    if(search(this.root, letters, n)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n            letters[i] = original;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private boolean search(TrieNode node, char[] letters, int n){\\n        TrieNode current = node;\\n        \\n        for(int i = 0; i < n; i++){\\n            current = current.children[letters[i] - \\'a\\'];\\n            if(current == null){\\n                return false;\\n            }\\n        }\\n        \\n        return current.isWord;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422712,
                "title": "c-solution-using-unordered-set",
                "content": "```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    //built dictionary\\n    void buildDict(vector<string> dictionary) {\\n        for (string word:dictionary)\\n        {\\n            mp.insert(word);\\n        }\\n    }\\n    \\n    //searching word\\n    bool search(string word) {\\n        int ln=word.size();\\n        string tempword=word;\\n        for (int i=0;i<ln;i++)\\n        {\\n            tempword=word;\\n            char pres=tempword[i];\\n            //creating all 26 combinations by changing chracter at ith position\\n            for (int j=0; j<26; j++)\\n            {\\n                char temp=j+\\'a\\';\\n                if (temp==pres)\\n                {\\n                    continue;\\n                }\\n                tempword[i]=temp;\\n                if (mp.find(tempword)!=mp.end())\\n                {\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    unordered_set<string> mp;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    //built dictionary\\n    void buildDict(vector<string> dictionary) {\\n        for (string word:dictionary)\\n        {\\n            mp.insert(word);\\n        }\\n    }\\n    \\n    //searching word\\n    bool search(string word) {\\n        int ln=word.size();\\n        string tempword=word;\\n        for (int i=0;i<ln;i++)\\n        {\\n            tempword=word;\\n            char pres=tempword[i];\\n            //creating all 26 combinations by changing chracter at ith position\\n            for (int j=0; j<26; j++)\\n            {\\n                char temp=j+\\'a\\';\\n                if (temp==pres)\\n                {\\n                    continue;\\n                }\\n                tempword[i]=temp;\\n                if (mp.find(tempword)!=mp.end())\\n                {\\n                    return true;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    unordered_set<string> mp;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410335,
                "title": "javascript-easy-to-understand-solution-100-59",
                "content": "Runtime: 84 ms, faster than 100.00% of JavaScript online submissions for Implement Magic Dictionary.\\nMemory Usage: 46.3 MB, less than 59.26% of JavaScript online submissions for Implement Magic Dictionary.\\n```\\nvar MagicDictionary = function() {\\n    this.book = new Map();\\n};\\n\\nMagicDictionary.prototype.buildDict = function(dictionary) {\\n    for(let word of dictionary){\\n        if(this.book.get(word.length)) this.book.get(word.length).push(word);\\n        else this.book.set(word.length, [word]);\\n    }\\n};\\n\\nMagicDictionary.prototype.search = function(searchWord) {\\n    if(!this.book.get(searchWord.length)) return false;\\n    let set = [...this.book.get(searchWord.length)];\\n    let w = 0;\\n    while(w<searchWord.length){\\n        for(let i = 0; i < set.length; i++){\\n            if(searchWord[w]!==set[i][w]){\\n                if(searchWord.slice(w+1)===set[i].slice(w+1)) return true;\\n                set.splice(i,1), i--;\\n            }}\\n        w++;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar MagicDictionary = function() {\\n    this.book = new Map();\\n};\\n\\nMagicDictionary.prototype.buildDict = function(dictionary) {\\n    for(let word of dictionary){\\n        if(this.book.get(word.length)) this.book.get(word.length).push(word);\\n        else this.book.set(word.length, [word]);\\n    }\\n};\\n\\nMagicDictionary.prototype.search = function(searchWord) {\\n    if(!this.book.get(searchWord.length)) return false;\\n    let set = [...this.book.get(searchWord.length)];\\n    let w = 0;\\n    while(w<searchWord.length){\\n        for(let i = 0; i < set.length; i++){\\n            if(searchWord[w]!==set[i][w]){\\n                if(searchWord.slice(w+1)===set[i].slice(w+1)) return true;\\n                set.splice(i,1), i--;\\n            }}\\n        w++;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1409362,
                "title": "go-trie",
                "content": "```\\ntype MagicDictionary struct {\\n\\troot *trie\\n}\\n\\nfunc Constructor() MagicDictionary {\\n\\treturn MagicDictionary{root: &trie{}}\\n}\\n\\nfunc (this *MagicDictionary) BuildDict(dictionary []string) {\\n\\tfor _, word := range dictionary {\\n\\t\\tthis.root.insert(word)\\n\\t}\\n}\\n\\nfunc (this *MagicDictionary) Search(word string) bool {\\n\\tcur := this.root\\n\\tfor i, c := range word {\\n\\t\\tj := c - \\'a\\'\\n\\t\\tfor k, child := range cur.children {\\n\\t\\t\\tif child != nil && k != int(j) && child.search(word[i+1:]) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif cur.children[j] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[j]\\n\\t}\\n\\treturn false\\n}\\n\\ntype trie struct {\\n\\tchildren [26]*trie\\n\\tisEnd    bool\\n}\\n\\nfunc (t *trie) insert(word string) {\\n\\tcur := t\\n\\tfor _, c := range word {\\n\\t\\ti := c - \\'a\\'\\n\\t\\tif cur.children[i] == nil {\\n\\t\\t\\tcur.children[i] = &trie{}\\n\\t\\t}\\n\\t\\tcur = cur.children[i]\\n\\t}\\n\\tcur.isEnd = true\\n}\\n\\nfunc (t *trie) search(word string) bool {\\n\\tcur := t\\n\\tfor _, c := range word {\\n\\t\\ti := c - \\'a\\'\\n\\t\\tif cur.children[i] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[i]\\n\\t}\\n\\treturn cur.isEnd\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype MagicDictionary struct {\\n\\troot *trie\\n}\\n\\nfunc Constructor() MagicDictionary {\\n\\treturn MagicDictionary{root: &trie{}}\\n}\\n\\nfunc (this *MagicDictionary) BuildDict(dictionary []string) {\\n\\tfor _, word := range dictionary {\\n\\t\\tthis.root.insert(word)\\n\\t}\\n}\\n\\nfunc (this *MagicDictionary) Search(word string) bool {\\n\\tcur := this.root\\n\\tfor i, c := range word {\\n\\t\\tj := c - \\'a\\'\\n\\t\\tfor k, child := range cur.children {\\n\\t\\t\\tif child != nil && k != int(j) && child.search(word[i+1:]) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif cur.children[j] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[j]\\n\\t}\\n\\treturn false\\n}\\n\\ntype trie struct {\\n\\tchildren [26]*trie\\n\\tisEnd    bool\\n}\\n\\nfunc (t *trie) insert(word string) {\\n\\tcur := t\\n\\tfor _, c := range word {\\n\\t\\ti := c - \\'a\\'\\n\\t\\tif cur.children[i] == nil {\\n\\t\\t\\tcur.children[i] = &trie{}\\n\\t\\t}\\n\\t\\tcur = cur.children[i]\\n\\t}\\n\\tcur.isEnd = true\\n}\\n\\nfunc (t *trie) search(word string) bool {\\n\\tcur := t\\n\\tfor _, c := range word {\\n\\t\\ti := c - \\'a\\'\\n\\t\\tif cur.children[i] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[i]\\n\\t}\\n\\treturn cur.isEnd\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400434,
                "title": "java-hashmap-solution",
                "content": "```\\nclass MagicDictionary {\\n\\n    Map<Integer, List<String>> map;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String s : dictionary){\\n            if(!map.containsKey(s.length())){\\n                List<String> list = new LinkedList<>();\\n                list.add(s);\\n                map.put(s.length(),list);\\n            }else{\\n                map.get(s.length()).add(s);\\n            }\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        int l = searchWord.length();\\n        if(map.containsKey(l)){\\n            List<String> list = map.get(l);\\n            for(String s : list){\\n                int diff = 0;\\n                for(int i = 0; i < l; i++){\\n                    if(s.charAt(i) != searchWord.charAt(i)){\\n                        diff++;\\n                    }\\n                }\\n                if(diff == 1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n\\n    Map<Integer, List<String>> map;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String s : dictionary){\\n            if(!map.containsKey(s.length())){\\n                List<String> list = new LinkedList<>();\\n                list.add(s);\\n                map.put(s.length(),list);\\n            }else{\\n                map.get(s.length()).add(s);\\n            }\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        int l = searchWord.length();\\n        if(map.containsKey(l)){\\n            List<String> list = map.get(l);\\n            for(String s : list){\\n                int diff = 0;\\n                for(int i = 0; i < l; i++){\\n                    if(s.charAt(i) != searchWord.charAt(i)){\\n                        diff++;\\n                    }\\n                }\\n                if(diff == 1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1350173,
                "title": "python-beats-100-using-simple-dictionary",
                "content": "\\n```python\\nfrom collections import defaultdict\\n\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.dict_ = defaultdict(list)\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.dict_[len(word)].append(word)\\n\\n    def search(self, search_word: str) -> bool:\\n        for possible_word in self.dict_[len(search_word)]:\\n            if self.offByOne(search_word, possible_word):\\n                return True\\n        return False\\n    \\n    def offByOne(self, first_word: str, second_word: str):\\n        seen_one_diff = False\\n        for i, char in enumerate(first_word):\\n            if char != second_word[i]:\\n                if seen_one_diff:\\n                    return False\\n                seen_one_diff = True\\n        return seen_one_diff\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict\\n\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.dict_ = defaultdict(list)\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.dict_[len(word)].append(word)\\n\\n    def search(self, search_word: str) -> bool:\\n        for possible_word in self.dict_[len(search_word)]:\\n            if self.offByOne(search_word, possible_word):\\n                return True\\n        return False\\n    \\n    def offByOne(self, first_word: str, second_word: str):\\n        seen_one_diff = False\\n        for i, char in enumerate(first_word):\\n            if char != second_word[i]:\\n                if seen_one_diff:\\n                    return False\\n                seen_one_diff = True\\n        return seen_one_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324942,
                "title": "c-2-solutions-hashing-and-trie",
                "content": "**Solution 1: Using maps**\\nHashing with length of words as key \\n```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,vector<string>> mp; \\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        for(string s : dict){\\n            mp[s.length()].push_back(s);\\n        }\\n    }\\n    \\n    bool search(string word) {\\n        int key = word.length();\\n        if(mp[key].size()==0)\\n            return 0;\\n        for(string s : mp[key]){\\n            int count = 0 ,i=0;           \\n                for(i=0;i<s.length();i++){\\n                    if(s[i]!=word[i]) \\n                        count++;            \\n                    if(count >1 )\\n                        break;\\n                }\\n                if(count == 1 && i==word.length())\\n                    return 1;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```\\n\\n**Solution 2:**\\nUsing Trie data structure: \\n```\\nclass TrieNode{\\n  public:\\n    vector<TrieNode*> dict;\\n    bool isEnd;\\n    TrieNode(){\\n        dict.resize(26,NULL);\\n        isEnd = false;\\n    }\\n};\\n\\nclass Trie{\\n  public :\\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    void insert(string s){\\n        TrieNode* curr = root;\\n        for(char c : s){\\n            if(curr->dict[c-\\'a\\'] ==NULL){\\n                curr->dict[c-\\'a\\'] = new TrieNode();                \\n            }\\n            curr = curr->dict[c-\\'a\\'];\\n        }\\n        curr->isEnd = true;\\n    }\\n    \\n    bool helper(string s,int index,int count, TrieNode* curr){\\n        if(curr==NULL)\\n            curr = root;\\n        if(index == s.length()) return curr->isEnd && count ==1 ;\\n        TrieNode* next = curr->dict[s[index]-\\'a\\'];\\n        if(count == 1){\\n            if(!next)\\n                return false; //only a part of the word is present \\n            return helper(s,index+1,1,next);\\n        }\\n        else {\\n            if(next && helper(s,index+1,0,next))\\n                return 1;\\n            else{\\n                for(int i=0;i<26;i++){\\n                    if(s[index]==\\'a\\'+i) continue;\\n                    if(curr->dict[i] && helper(s,index+1,1,curr->dict[i]))\\n                        return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    bool searchWord(string s){\\n        return helper(s,0,0,NULL);\\n    }\\n    \\n};\\n\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    Trie* trie;\\n    MagicDictionary() {\\n        trie = new Trie();        \\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        for(string s: dict){\\n            trie->insert(s);\\n        }\\n    }\\n    \\n    bool search(string word) {\\n        return trie->searchWord(word);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,vector<string>> mp; \\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        for(string s : dict){\\n            mp[s.length()].push_back(s);\\n        }\\n    }\\n    \\n    bool search(string word) {\\n        int key = word.length();\\n        if(mp[key].size()==0)\\n            return 0;\\n        for(string s : mp[key]){\\n            int count = 0 ,i=0;           \\n                for(i=0;i<s.length();i++){\\n                    if(s[i]!=word[i]) \\n                        count++;            \\n                    if(count >1 )\\n                        break;\\n                }\\n                if(count == 1 && i==word.length())\\n                    return 1;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```\n```\\nclass TrieNode{\\n  public:\\n    vector<TrieNode*> dict;\\n    bool isEnd;\\n    TrieNode(){\\n        dict.resize(26,NULL);\\n        isEnd = false;\\n    }\\n};\\n\\nclass Trie{\\n  public :\\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    void insert(string s){\\n        TrieNode* curr = root;\\n        for(char c : s){\\n            if(curr->dict[c-\\'a\\'] ==NULL){\\n                curr->dict[c-\\'a\\'] = new TrieNode();                \\n            }\\n            curr = curr->dict[c-\\'a\\'];\\n        }\\n        curr->isEnd = true;\\n    }\\n    \\n    bool helper(string s,int index,int count, TrieNode* curr){\\n        if(curr==NULL)\\n            curr = root;\\n        if(index == s.length()) return curr->isEnd && count ==1 ;\\n        TrieNode* next = curr->dict[s[index]-\\'a\\'];\\n        if(count == 1){\\n            if(!next)\\n                return false; //only a part of the word is present \\n            return helper(s,index+1,1,next);\\n        }\\n        else {\\n            if(next && helper(s,index+1,0,next))\\n                return 1;\\n            else{\\n                for(int i=0;i<26;i++){\\n                    if(s[index]==\\'a\\'+i) continue;\\n                    if(curr->dict[i] && helper(s,index+1,1,curr->dict[i]))\\n                        return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    bool searchWord(string s){\\n        return helper(s,0,0,NULL);\\n    }\\n    \\n};\\n\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    Trie* trie;\\n    MagicDictionary() {\\n        trie = new Trie();        \\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        for(string s: dict){\\n            trie->insert(s);\\n        }\\n    }\\n    \\n    bool search(string word) {\\n        return trie->searchWord(word);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259785,
                "title": "don-t-use-trie-brute-force-will-be-efficient-in-this-go",
                "content": "```\\ntype MagicDictionary struct {\\n    mp map[int][]string\\n    \\n}\\n\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MagicDictionary {\\n    var mp map[int][]string=make(map[int][]string)\\n    return MagicDictionary{mp}\\n    \\n}\\n\\n\\nfunc (this *MagicDictionary) BuildDict(dictionary []string)  {\\n    for _,word:=range dictionary{\\n        this.mp[len(word)]=append(this.mp[len(word)],word);\\n    }\\n    \\n}\\n\\n\\nfunc (this *MagicDictionary) Search(searchWord string) bool {\\n    \\n    var length int=len(searchWord)\\n    \\n    if (this.mp[length]==nil){\\n        return false\\n    }\\n    for _,word:=range this.mp[length]{\\n        var count int\\n        \\n        for i:=0;i<length;i++{\\n            \\n            if (count>1){\\n                break\\n            }\\n            if (word[i]!=searchWord[i]){\\n                count++\\n            }\\n        }\\n        if (count==1){\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.BuildDict(dictionary);\\n * param_2 := obj.Search(searchWord);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\ntype MagicDictionary struct {\\n    mp map[int][]string\\n    \\n}\\n\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() MagicDictionary {\\n    var mp map[int][]string=make(map[int][]string)\\n    return MagicDictionary{mp}\\n    \\n}\\n\\n\\nfunc (this *MagicDictionary) BuildDict(dictionary []string)  {\\n    for _,word:=range dictionary{\\n        this.mp[len(word)]=append(this.mp[len(word)],word);\\n    }\\n    \\n}\\n\\n\\nfunc (this *MagicDictionary) Search(searchWord string) bool {\\n    \\n    var length int=len(searchWord)\\n    \\n    if (this.mp[length]==nil){\\n        return false\\n    }\\n    for _,word:=range this.mp[length]{\\n        var count int\\n        \\n        for i:=0;i<length;i++{\\n            \\n            if (count>1){\\n                break\\n            }\\n            if (word[i]!=searchWord[i]){\\n                count++\\n            }\\n        }\\n        if (count==1){\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.BuildDict(dictionary);\\n * param_2 := obj.Search(searchWord);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203043,
                "title": "simple-python-soln",
                "content": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.arr=[]\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        \\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.arr=dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        A=self.arr\\n        for w in A:\\n            if len(w)!=len(searchWord) or w==searchWord:\\n                continue\\n            c=0\\n            for i in range(len(w)):#loop is required to check the ordering of element in both words\\n                if w[i]!=searchWord[i]:\\n                    c+=1\\n                    if c>=2:\\n                        break\\n            if c==1:#If only one element  differs\\n                return True\\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.arr=[]\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        \\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.arr=dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        A=self.arr\\n        for w in A:\\n            if len(w)!=len(searchWord) or w==searchWord:\\n                continue\\n            c=0\\n            for i in range(len(w)):#loop is required to check the ordering of element in both words\\n                if w[i]!=searchWord[i]:\\n                    c+=1\\n                    if c>=2:\\n                        break\\n            if c==1:#If only one element  differs\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157172,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MagicDictionary = function() {\\n    this.set = new Set();\\n};\\n\\n/** \\n * @param {string[]} dictionary\\n * @return {void}\\n */\\nMagicDictionary.prototype.buildDict = function(dictionary) {\\n    for (const word of dictionary) {\\n        this.set.add(word);\\n    }\\n};\\n\\n\\n/** \\n * @param {string} searchWord\\n * @return {boolean}\\n */\\nMagicDictionary.prototype.search = function(searchWord) {\\n    \\n    for (const compareWord of this.set) {\\n        if (compareWord.length != searchWord.length) continue;\\n        \\n        let count = 0;\\n        \\n        for (let i = 0; i < searchWord.length; i++) {\\n            const searchChar = searchWord.charAt(i);\\n            const compareChar = compareWord.charAt(i);\\n\\n            if (searchChar != compareChar) count++;\\n            if (count > 1) continue;\\n        }\\n    \\n        if (count === 1) return true;\\n    }\\n   \\n    return false;\\n};\\n\\n/** \\n * Your MagicDictionary object will be instantiated and called as such:\\n * var obj = new MagicDictionary()\\n * obj.buildDict(dictionary)\\n * var param_2 = obj.search(searchWord)\\n */\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MagicDictionary = function() {\\n    this.set = new Set();\\n};\\n\\n/** \\n * @param {string[]} dictionary\\n * @return {void}\\n */\\nMagicDictionary.prototype.buildDict = function(dictionary) {\\n    for (const word of dictionary) {\\n        this.set.add(word);\\n    }\\n};\\n\\n\\n/** \\n * @param {string} searchWord\\n * @return {boolean}\\n */\\nMagicDictionary.prototype.search = function(searchWord) {\\n    \\n    for (const compareWord of this.set) {\\n        if (compareWord.length != searchWord.length) continue;\\n        \\n        let count = 0;\\n        \\n        for (let i = 0; i < searchWord.length; i++) {\\n            const searchChar = searchWord.charAt(i);\\n            const compareChar = compareWord.charAt(i);\\n\\n            if (searchChar != compareChar) count++;\\n            if (count > 1) continue;\\n        }\\n    \\n        if (count === 1) return true;\\n    }\\n   \\n    return false;\\n};\\n\\n/** \\n * Your MagicDictionary object will be instantiated and called as such:\\n * var obj = new MagicDictionary()\\n * obj.buildDict(dictionary)\\n * var param_2 = obj.search(searchWord)\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1148549,
                "title": "swift-array-trie-solution",
                "content": "There is no different between set and array approach in this problem.\\nIterate every words in dictionary. \\nIf there is a word have same length with the searchWord length. Then count the different.\\n\\n```swift\\nclass MagicDictionary { //O(dictionary) space O(dictionary)\\n    var arr = [String]()\\n    func buildDict(_ dictionary: [String]) {\\n        arr = dictionary\\n    }\\n    \\n    func search(_ searchWord: String) -> Bool { //O(words * searchWord.length)\\n        let sArr = Array(searchWord)\\n        for word in arr {\\n            if word.count == sArr.endIndex {\\n                let wArr = Array(word)\\n                var i = 0\\n                var diff = 0\\n                for i in 0..<wArr.endIndex {\\n                    if wArr[i] != sArr[i] {diff += 1}\\n                }\\n                if diff == 1 {\\n                    return true\\n                }\\n            }\\n        }\\n        return false\\n    }\\n}\\n```\\nTrie\\n```swift\\nclass MagicDictionary {\\n    class Trie {\\n        var dict = [Character:Trie]()\\n        var isEnd = false\\n    }\\n    let root = Trie()\\n    func buildDict(_ dictionary: [String]) {\\n        for word in dictionary {\\n            var curr = root\\n            let wArr = Array(word)\\n            for char in wArr {\\n                if curr.dict[char] == nil {\\n                    curr.dict[char] = Trie()\\n                }\\n                curr = curr.dict[char]!\\n            }\\n            curr.isEnd = true\\n        }    \\n    }\\n    \\n    func search(_ node: Trie, _ word: String) -> Bool {\\n        var curr = node\\n        let wArr = Array(word)\\n        for char in wArr {\\n            if curr.dict[char] == nil {\\n                return false\\n            }\\n            curr = curr.dict[char]!\\n        }\\n        return curr.isEnd\\n    }\\n\\n    func search(_ searchWord: String) -> Bool {\\n        var curr = root\\n        let wArr = Array(searchWord)\\n        for (i, char) in wArr.enumerated() {\\n            for (key,node) in curr.dict where key != char {\\n                if search(node, String(wArr[i+1..<wArr.endIndex])) {\\n                    return true\\n                }\\n            }\\n            if curr.dict[char] == nil {\\n                return false\\n            }\\n            curr = curr.dict[char]!\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass MagicDictionary { //O(dictionary) space O(dictionary)\\n    var arr = [String]()\\n    func buildDict(_ dictionary: [String]) {\\n        arr = dictionary\\n    }\\n    \\n    func search(_ searchWord: String) -> Bool { //O(words * searchWord.length)\\n        let sArr = Array(searchWord)\\n        for word in arr {\\n            if word.count == sArr.endIndex {\\n                let wArr = Array(word)\\n                var i = 0\\n                var diff = 0\\n                for i in 0..<wArr.endIndex {\\n                    if wArr[i] != sArr[i] {diff += 1}\\n                }\\n                if diff == 1 {\\n                    return true\\n                }\\n            }\\n        }\\n        return false\\n    }\\n}\\n```\n```swift\\nclass MagicDictionary {\\n    class Trie {\\n        var dict = [Character:Trie]()\\n        var isEnd = false\\n    }\\n    let root = Trie()\\n    func buildDict(_ dictionary: [String]) {\\n        for word in dictionary {\\n            var curr = root\\n            let wArr = Array(word)\\n            for char in wArr {\\n                if curr.dict[char] == nil {\\n                    curr.dict[char] = Trie()\\n                }\\n                curr = curr.dict[char]!\\n            }\\n            curr.isEnd = true\\n        }    \\n    }\\n    \\n    func search(_ node: Trie, _ word: String) -> Bool {\\n        var curr = node\\n        let wArr = Array(word)\\n        for char in wArr {\\n            if curr.dict[char] == nil {\\n                return false\\n            }\\n            curr = curr.dict[char]!\\n        }\\n        return curr.isEnd\\n    }\\n\\n    func search(_ searchWord: String) -> Bool {\\n        var curr = root\\n        let wArr = Array(searchWord)\\n        for (i, char) in wArr.enumerated() {\\n            for (key,node) in curr.dict where key != char {\\n                if search(node, String(wArr[i+1..<wArr.endIndex])) {\\n                    return true\\n                }\\n            }\\n            if curr.dict[char] == nil {\\n                return false\\n            }\\n            curr = curr.dict[char]!\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144672,
                "title": "javascript-hashset-direct-check-104ms",
                "content": "```\\nfunction MagicDictionary() {\\n    let se = new Set();\\n    return {\\n        buildDict,\\n        search\\n    }\\n\\n    function buildDict(dict) {\\n        for (const e of dict) se.add(e);\\n    }\\n\\n    function search(word) {\\n        for (const e of se) {\\n            if (ok(word, e)) return 1;\\n        }\\n        return 0;\\n    }\\n\\n    function ok(s, t) {\\n        if (s == t) return 0;\\n        let n = s.length;\\n        if (n != t.length) return 0;\\n        let diff = 0;\\n        for (let i = 0; i < n; i++) {\\n            if (s[i] != t[i]) diff++;\\n            if (diff > 1) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nfunction MagicDictionary() {\\n    let se = new Set();\\n    return {\\n        buildDict,\\n        search\\n    }\\n\\n    function buildDict(dict) {\\n        for (const e of dict) se.add(e);\\n    }\\n\\n    function search(word) {\\n        for (const e of se) {\\n            if (ok(word, e)) return 1;\\n        }\\n        return 0;\\n    }\\n\\n    function ok(s, t) {\\n        if (s == t) return 0;\\n        let n = s.length;\\n        if (n != t.length) return 0;\\n        let diff = 0;\\n        for (let i = 0; i < n; i++) {\\n            if (s[i] != t[i]) diff++;\\n            if (diff > 1) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1091835,
                "title": "simple-python-solution-without-trie-similar-approach-to-127-word-ladder",
                "content": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.graph = defaultdict(list)\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            for i in range(len(word)):\\n                self.graph[word[:i] + \\'*\\' + word[i + 1 : ]].append(word)\\n        \\n    def search(self, word: str) -> bool:\\n        for i in range(len(word)):\\n            curr = word[:i] + \\'*\\' + word[i + 1 : ]\\n            if curr in self.graph:\\n                if len(self.graph[curr]) > 1 or self.graph[curr][0] != word:\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.graph = defaultdict(list)\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            for i in range(len(word)):\\n                self.graph[word[:i] + \\'*\\' + word[i + 1 : ]].append(word)\\n        \\n    def search(self, word: str) -> bool:\\n        for i in range(len(word)):\\n            curr = word[:i] + \\'*\\' + word[i + 1 : ]\\n            if curr in self.graph:\\n                if len(self.graph[curr]) > 1 or self.graph[curr][0] != word:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046071,
                "title": "swift-two-approaches-using-trie-using-set",
                "content": "Approach - 1 Using Trie\\n\\n```\\nclass MagicDictionary {\\n    \\n    class TrieNode {\\n        var char: Character?\\n        var children: [Character: TrieNode] = [:]\\n        var wordEnds = false\\n        \\n        init(_ char: Character?) {\\n            self.char = char\\n        }\\n    }\\n    \\n    private(set) var root = TrieNode(nil)\\n\\n    func buildDict(_ dictionary: [String]) {\\n        for word in dictionary {\\n            insert(word)\\n        }\\n    }\\n    \\n    private func insert(_ word: String) {\\n        var curr = root\\n        for char in word {\\n            if let found = curr.children[char] {\\n                curr = found\\n            } else {\\n                curr.children[char] = TrieNode(char)\\n                curr = curr.children[char]!\\n            }\\n        }\\n        curr.wordEnds = true\\n    }\\n    \\n    func search(_ searchWord: String) -> Bool {\\n        var searchWord = Array(searchWord)\\n        var curr = root\\n        var missedOne = false\\n        for i in 0..<searchWord.count {\\n            let skippingChar = searchWord[i]\\n            \\n            for key in curr.children.keys where key != skippingChar {\\n                let childNode = curr.children[key]!\\n                if search(childNode, searchWord, i+1) {\\n                    return true\\n                }\\n            }\\n            \\n            if let found = curr.children[skippingChar] {\\n                curr = found\\n            } else {\\n               return false\\n            }\\n        }\\n        return false\\n    }\\n    \\n    \\n    func search(_ node: TrieNode, _ word: [Character], _ startIndex: Int) -> Bool {\\n        var curr = node\\n        for i in startIndex..<word.count {\\n            let char = word[i]\\n            if let found = curr.children[char] {\\n                curr = found\\n            } else {\\n                return false\\n            }\\n        }\\n        return curr.wordEnds\\n    }\\n\\n}\\n```\\n\\nApproach- 2 Using Set\\n```\\n\\n\\tvar set = Set<String>()\\n    \\n    func buildDict(_ dictionary: [String]) {\\n        for word in dictionary {\\n            set.insert(word)\\n        }\\n    }\\n    func search(_ searchWord: String) -> Bool {\\n        for magicWord in set {\\n            if isMatch(Array(magicWord), Array(searchWord)) {\\n                return true\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    func isMatch(_ word1: [Character], _ word2: [Character]) -> Bool {\\n        var charSkipped = false\\n        if word1.count != word2.count {\\n            return false\\n        }\\n        for i in 0..<word1.count {\\n            if word1[i] != word2[i] {\\n                if charSkipped {\\n                    return false\\n                }\\n                charSkipped = true\\n            }\\n        }\\n        return charSkipped\\n    }\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass MagicDictionary {\\n    \\n    class TrieNode {\\n        var char: Character?\\n        var children: [Character: TrieNode] = [:]\\n        var wordEnds = false\\n        \\n        init(_ char: Character?) {\\n            self.char = char\\n        }\\n    }\\n    \\n    private(set) var root = TrieNode(nil)\\n\\n    func buildDict(_ dictionary: [String]) {\\n        for word in dictionary {\\n            insert(word)\\n        }\\n    }\\n    \\n    private func insert(_ word: String) {\\n        var curr = root\\n        for char in word {\\n            if let found = curr.children[char] {\\n                curr = found\\n            } else {\\n                curr.children[char] = TrieNode(char)\\n                curr = curr.children[char]!\\n            }\\n        }\\n        curr.wordEnds = true\\n    }\\n    \\n    func search(_ searchWord: String) -> Bool {\\n        var searchWord = Array(searchWord)\\n        var curr = root\\n        var missedOne = false\\n        for i in 0..<searchWord.count {\\n            let skippingChar = searchWord[i]\\n            \\n            for key in curr.children.keys where key != skippingChar {\\n                let childNode = curr.children[key]!\\n                if search(childNode, searchWord, i+1) {\\n                    return true\\n                }\\n            }\\n            \\n            if let found = curr.children[skippingChar] {\\n                curr = found\\n            } else {\\n               return false\\n            }\\n        }\\n        return false\\n    }\\n    \\n    \\n    func search(_ node: TrieNode, _ word: [Character], _ startIndex: Int) -> Bool {\\n        var curr = node\\n        for i in startIndex..<word.count {\\n            let char = word[i]\\n            if let found = curr.children[char] {\\n                curr = found\\n            } else {\\n                return false\\n            }\\n        }\\n        return curr.wordEnds\\n    }\\n\\n}\\n```\n```\\n\\n\\tvar set = Set<String>()\\n    \\n    func buildDict(_ dictionary: [String]) {\\n        for word in dictionary {\\n            set.insert(word)\\n        }\\n    }\\n    func search(_ searchWord: String) -> Bool {\\n        for magicWord in set {\\n            if isMatch(Array(magicWord), Array(searchWord)) {\\n                return true\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    func isMatch(_ word1: [Character], _ word2: [Character]) -> Bool {\\n        var charSkipped = false\\n        if word1.count != word2.count {\\n            return false\\n        }\\n        for i in 0..<word1.count {\\n            if word1[i] != word2[i] {\\n                if charSkipped {\\n                    return false\\n                }\\n                charSkipped = true\\n            }\\n        }\\n        return charSkipped\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040420,
                "title": "fast-and-simple-c-44ms",
                "content": "```\\nclass MagicDictionary {\\npublic:\\n    unordered_map<int,vector<string>> map;\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(int i=0;i<dictionary.size();i++)\\n        {\\n            int len=dictionary[i].length();\\n            map[len].push_back(dictionary[i]);\\n        }\\n    }\\n    \\n    bool search(string word) {\\n        int len=word.length();\\n        if(map.find(len)==map.end())\\n            return false;\\n        vector<string> v=map[len];\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<len;j++)\\n            {\\n                if(v[i][j]!=word[j])\\n                    count++;\\n            }\\n            if(count==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    unordered_map<int,vector<string>> map;\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(int i=0;i<dictionary.size();i++)\\n        {\\n            int len=dictionary[i].length();\\n            map[len].push_back(dictionary[i]);\\n        }\\n    }\\n    \\n    bool search(string word) {\\n        int len=word.length();\\n        if(map.find(len)==map.end())\\n            return false;\\n        vector<string> v=map[len];\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<len;j++)\\n            {\\n                if(v[i][j]!=word[j])\\n                    count++;\\n            }\\n            if(count==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965374,
                "title": "python-map-length-of-words-beat-97",
                "content": "Since we need to change exactly one letter, if we have length mismatched then it must be false.\\nSo the idea is we create a map which takes the length of word as key, and maps to a list of words. \\nThen we can access the possible candidates of word by this map, and while iterate through each candidate, we break from the loop when we reach 2 mismatched character, return True if we finish iterating one word AND has exactly 1 mismatched.\\n```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.lengthToWords = collections.defaultdict(lambda:[])\\n        \\n        \\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.lengthToWords[len(word)].append(word)\\n        \\n\\n    def search(self, searchWord: str) -> bool:\\n        n = len(searchWord)\\n        words = self.lengthToWords.get(n)\\n        if not words: return False\\n        for w in words:\\n            i, count = 0,0\\n            while i<n and count !=2:\\n                if searchWord[i]!=w[i]:\\n                    count +=1\\n                i+=1\\n            if count==1:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.lengthToWords = collections.defaultdict(lambda:[])\\n        \\n        \\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.lengthToWords[len(word)].append(word)\\n        \\n\\n    def search(self, searchWord: str) -> bool:\\n        n = len(searchWord)\\n        words = self.lengthToWords.get(n)\\n        if not words: return False\\n        for w in words:\\n            i, count = 0,0\\n            while i<n and count !=2:\\n                if searchWord[i]!=w[i]:\\n                    count +=1\\n                i+=1\\n            if count==1:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965135,
                "title": "c-92",
                "content": "```\\nclass MagicDictionary {\\npublic:\\n    MagicDictionary() {}\\n    \\n    void buildDict(const vector<string>& dictionary) {\\n        for(const auto& word:dictionary)\\n            dict[word.size()].push_back(word);\\n    }\\n    \\n    bool search(const string& searchWord) {\\n        \\n        if(!dict.count(searchWord.size())) return false;\\n        \\n        for(const auto& word:dict[searchWord.size()]) {\\n            int diff=0;\\n            for(int i=0; i<searchWord.size(); ++i)\\n                if(word[i]!=searchWord[i]) ++diff;\\n            if(diff==1) return true;\\n        }\\n        return false;\\n    }\\nprivate:\\n    unordered_map<int,vector<string>> dict;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    MagicDictionary() {}\\n    \\n    void buildDict(const vector<string>& dictionary) {\\n        for(const auto& word:dictionary)\\n            dict[word.size()].push_back(word);\\n    }\\n    \\n    bool search(const string& searchWord) {\\n        \\n        if(!dict.count(searchWord.size())) return false;\\n        \\n        for(const auto& word:dict[searchWord.size()]) {\\n            int diff=0;\\n            for(int i=0; i<searchWord.size(); ++i)\\n                if(word[i]!=searchWord[i]) ++diff;\\n            if(diff==1) return true;\\n        }\\n        return false;\\n    }\\nprivate:\\n    unordered_map<int,vector<string>> dict;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956627,
                "title": "java-trie-dfs",
                "content": "```\\nclass MagicDictionary {\\n    \\n    private static class Trie {\\n        boolean complete;\\n        HashMap<Character, Trie> kids = new HashMap<>();\\n    }\\n    \\n    private Trie root;\\n    \\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new Trie();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        \\n        for(String word : dictionary) {\\n            \\n            Trie current = root;\\n            \\n            for(char letter : word.toCharArray()) {\\n                \\n                if(!current.kids.containsKey(letter)) {\\n                    current.kids.put(letter, new Trie());           \\n                }\\n                \\n                current = current.kids.get(letter);\\n            }\\n            \\n            current.complete = true;\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        return search(searchWord, 0, root, 0);\\n    }\\n    \\n    private boolean search(String word, int index, Trie trie, int mismatches) {\\n        if(mismatches > 1) return false;\\n        \\n        if(index == word.length()) return trie.complete && mismatches == 1;\\n     \\n        for(Map.Entry<Character, Trie> kid : trie.kids.entrySet()) { \\n            \\n            if(search(word, index+1, kid.getValue(), \\n                      kid.getKey() == word.charAt(index) ? mismatches :  mismatches + 1)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n    \\n    private static class Trie {\\n        boolean complete;\\n        HashMap<Character, Trie> kids = new HashMap<>();\\n    }\\n    \\n    private Trie root;\\n    \\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new Trie();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        \\n        for(String word : dictionary) {\\n            \\n            Trie current = root;\\n            \\n            for(char letter : word.toCharArray()) {\\n                \\n                if(!current.kids.containsKey(letter)) {\\n                    current.kids.put(letter, new Trie());           \\n                }\\n                \\n                current = current.kids.get(letter);\\n            }\\n            \\n            current.complete = true;\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        return search(searchWord, 0, root, 0);\\n    }\\n    \\n    private boolean search(String word, int index, Trie trie, int mismatches) {\\n        if(mismatches > 1) return false;\\n        \\n        if(index == word.length()) return trie.complete && mismatches == 1;\\n     \\n        for(Map.Entry<Character, Trie> kid : trie.kids.entrySet()) { \\n            \\n            if(search(word, index+1, kid.getValue(), \\n                      kid.getKey() == word.charAt(index) ? mismatches :  mismatches + 1)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940024,
                "title": "java-o-lengthofstring-hashmap",
                "content": "```\\nprivate Map<String,List<String>> allPossibleWords;\\n\\n    public MagicDictionary() {\\n        allPossibleWords = new HashMap<>();\\n    }\\n\\n    public void buildDict(String[] dictionary) {\\n        for (String word : dictionary) {\\n            int n = word.length();\\n            for (int i = 0; i < n; i++) {\\n                StringBuilder sb = new StringBuilder(word);\\n                sb.setCharAt(i, \\'_\\');\\n                String wordWithWildCard = sb.toString();\\n                List<String> matchingWords = new ArrayList<>();\\n                if(allPossibleWords.containsKey(wordWithWildCard)){\\n                     matchingWords = allPossibleWords.get(wordWithWildCard);\\n                }\\n                matchingWords.add(word);\\n                allPossibleWords.put(wordWithWildCard, matchingWords);\\n            }\\n        }\\n    }\\n\\n    public boolean search(String searchWord) {\\n        int n = searchWord.length();\\n        boolean matches = false;\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder sb = new StringBuilder(searchWord);\\n            sb.setCharAt(i, \\'_\\');\\n            String wordWithWildCard = sb.toString();\\n            if(allPossibleWords.containsKey(wordWithWildCard)){\\n                List<String> actualWords = allPossibleWords.get(wordWithWildCard);\\n                for(String actual:actualWords){\\n                    matches = matches || !actual.equals(searchWord);    \\n                }\\n                \\n            }\\n        }\\n        return matches;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate Map<String,List<String>> allPossibleWords;\\n\\n    public MagicDictionary() {\\n        allPossibleWords = new HashMap<>();\\n    }\\n\\n    public void buildDict(String[] dictionary) {\\n        for (String word : dictionary) {\\n            int n = word.length();\\n            for (int i = 0; i < n; i++) {\\n                StringBuilder sb = new StringBuilder(word);\\n                sb.setCharAt(i, \\'_\\');\\n                String wordWithWildCard = sb.toString();\\n                List<String> matchingWords = new ArrayList<>();\\n                if(allPossibleWords.containsKey(wordWithWildCard)){\\n                     matchingWords = allPossibleWords.get(wordWithWildCard);\\n                }\\n                matchingWords.add(word);\\n                allPossibleWords.put(wordWithWildCard, matchingWords);\\n            }\\n        }\\n    }\\n\\n    public boolean search(String searchWord) {\\n        int n = searchWord.length();\\n        boolean matches = false;\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder sb = new StringBuilder(searchWord);\\n            sb.setCharAt(i, \\'_\\');\\n            String wordWithWildCard = sb.toString();\\n            if(allPossibleWords.containsKey(wordWithWildCard)){\\n                List<String> actualWords = allPossibleWords.get(wordWithWildCard);\\n                for(String actual:actualWords){\\n                    matches = matches || !actual.equals(searchWord);    \\n                }\\n                \\n            }\\n        }\\n        return matches;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 896442,
                "title": "python3-trie",
                "content": "\\n```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.root = {} # root of trie \\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary: \\n            node = self.root\\n            for c in word: node = node.setdefault(c, {})\\n            node[\"#\"] = word # sentinel \\n\\n    def search(self, searchWord: str) -> bool:\\n        \\n        def fn(node, i, chg=False): \\n            \"\"\"Return True if it is possible to change one character.\"\"\"\\n            if not node: return False \\n            if i == len(searchWord): return node.get(\"#\") and chg\\n            return fn(node.get(searchWord[i]), i+1, True) if chg else any(fn(node[c], i+1, c != searchWord[i]) for c in node if c != \"#\")  \\n        \\n        return fn(self.root, 0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.root = {} # root of trie \\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary: \\n            node = self.root\\n            for c in word: node = node.setdefault(c, {})\\n            node[\"#\"] = word # sentinel \\n\\n    def search(self, searchWord: str) -> bool:\\n        \\n        def fn(node, i, chg=False): \\n            \"\"\"Return True if it is possible to change one character.\"\"\"\\n            if not node: return False \\n            if i == len(searchWord): return node.get(\"#\") and chg\\n            return fn(node.get(searchWord[i]), i+1, True) if chg else any(fn(node[c], i+1, c != searchWord[i]) for c in node if c != \"#\")  \\n        \\n        return fn(self.root, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703080,
                "title": "java-100-simple-array",
                "content": "```\\nclass MagicDictionary {\\n\\n    String[] dict;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        this.dict = dict;\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        for(int i=0;i<dict.length;i++)\\n            if(is1step(dict[i],word))\\n                return true;\\n        return false;\\n    }\\n    \\n    private boolean is1step(String a, String b)\\n    {\\n        int ct = 0;\\n        if(a.length()!=b.length())\\n            return false;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a.charAt(i)!=b.charAt(i))\\n                ct++;\\n            if(ct>1)\\n                return false;\\n        }\\n        return ct==1;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dict);\\n * boolean param_2 = obj.search(word);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n\\n    String[] dict;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        this.dict = dict;\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        for(int i=0;i<dict.length;i++)\\n            if(is1step(dict[i],word))\\n                return true;\\n        return false;\\n    }\\n    \\n    private boolean is1step(String a, String b)\\n    {\\n        int ct = 0;\\n        if(a.length()!=b.length())\\n            return false;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a.charAt(i)!=b.charAt(i))\\n                ct++;\\n            if(ct>1)\\n                return false;\\n        }\\n        return ct==1;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dict);\\n * boolean param_2 = obj.search(word);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 696327,
                "title": "c-trie-solution-faster-than-85",
                "content": "```\\nclass MagicDictionary {\\n    MagicDictionary *child[26] = {};\\n    bool isend = false;\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() { }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        MagicDictionary *node = this;\\n        for(string s : dict)\\n        {\\n            MagicDictionary *root = node;\\n        \\n            for(char c : s)\\n            {\\n                int ind = c-\\'a\\';\\n                if(!root->child[ind])\\n                    root->child[ind] = new MagicDictionary();\\n                root = root->child[ind];\\n            }\\n            root->isend = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        MagicDictionary *root = this;\\n        MagicDictionary *node = root; int flag= 0; bool done_false = false;\\n        for(char c: word) //Seraching the exact word  \\n        {\\n            int ind = c-\\'a\\';\\n            if(!node->child[ind])\\n            {\\n                flag=1;break;\\n            }\\n            node = node->child[ind];\\n        }\\n        if(flag==0 && node->isend) // if we get the given string we make it\\'s end as false\\n        {   \\n            node->isend = false;  done_false = true;\\n        }\\n        int ans = search_util(word,root); // now call the function where we traverse all the possible child\\n        if(done_false) // if we had changed the given string as false ; we will make it again true\\n            node->isend = true;\\n        if(ans>1)return false;\\n        return true;\\n    }\\n    \\n    int search_util(string word, MagicDictionary *root)\\n    {\\n        if(!root)return 999;\\n        if(word.size()==0)\\n        {\\n            if(root->isend == true){return 0;}\\n            else return 999;\\n        }\\n        int ans = 999;\\n        MagicDictionary *node;\\n        for(int i=0;i<26;i++)\\n        {\\n            node = root->child[i];\\n            if(node)\\n            {\\n               if(i == word[0]-\\'a\\')\\n                  ans = min(ans,search_util(word.substr(1),node));\\n               else\\n                  ans = min(ans,1+search_util(word.substr(1),node));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dict);\\n * bool param_2 = obj->search(word);\\n */",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n    MagicDictionary *child[26] = {};\\n    bool isend = false;\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() { }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        MagicDictionary *node = this;\\n        for(string s : dict)\\n        {\\n            MagicDictionary *root = node;\\n        \\n            for(char c : s)\\n            {\\n                int ind = c-\\'a\\';\\n                if(!root->child[ind])\\n                    root->child[ind] = new MagicDictionary();\\n                root = root->child[ind];\\n            }\\n            root->isend = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        MagicDictionary *root = this;\\n        MagicDictionary *node = root; int flag= 0; bool done_false = false;\\n        for(char c: word) //Seraching the exact word  \\n        {\\n            int ind = c-\\'a\\';\\n            if(!node->child[ind])\\n            {\\n                flag=1;break;\\n            }\\n            node = node->child[ind];\\n        }\\n        if(flag==0 && node->isend) // if we get the given string we make it\\'s end as false\\n        {   \\n            node->isend = false;  done_false = true;\\n        }\\n        int ans = search_util(word,root); // now call the function where we traverse all the possible child\\n        if(done_false) // if we had changed the given string as false ; we will make it again true\\n            node->isend = true;\\n        if(ans>1)return false;\\n        return true;\\n    }\\n    \\n    int search_util(string word, MagicDictionary *root)\\n    {\\n        if(!root)return 999;\\n        if(word.size()==0)\\n        {\\n            if(root->isend == true){return 0;}\\n            else return 999;\\n        }\\n        int ans = 999;\\n        MagicDictionary *node;\\n        for(int i=0;i<26;i++)\\n        {\\n            node = root->child[i];\\n            if(node)\\n            {\\n               if(i == word[0]-\\'a\\')\\n                  ans = min(ans,search_util(word.substr(1),node));\\n               else\\n                  ans = min(ans,1+search_util(word.substr(1),node));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dict);\\n * bool param_2 = obj->search(word);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 685965,
                "title": "java-trie-easy-solution",
                "content": "The idea is simple - we go through the Trie. we also have variable diff o track how many replaces there were as soon as diff >1, we finish. \\n\\n```\\nclass MagicDictionary {\\n    Trie root;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() \\n    {\\n        root = new Trie(\\'.\\', false);\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) \\n    {\\n        for (String word:dict)\\n        {\\n            addWord(word.toCharArray(), 0, root);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) \\n    {\\n        return searchWord(word.toCharArray(), 0, root, 0);\\n    }\\n    \\n    public void addWord(char[] word, int i, Trie root){\\n        if (i<word.length){\\n            if (root.children.get(word[i])==null) root.children.put(word[i], new Trie(word[i], i==word.length-1));\\n            addWord(word, i+1, root.children.get(word[i]));\\n        }\\n    }\\n    \\n    public boolean searchWord(char[]word, int i, Trie root, int diff)\\n    {\\n        if (diff<=1)\\n        {\\n            if (i==word.length) return root.finish && diff==1;\\n            else if (i<word.length)\\n            {\\n                for (char x:root.children.keySet())\\n                {\\n                    if (searchWord(word, i+1, root.children.get(x), diff + ((x==word[i]?0:1)))) return true;\\n                }\\n                return false;\\n            } \\n            else return false;\\n        }\\n        else return false;\\n    }\\n}\\n\\n\\nclass Trie {\\n    char c;\\n    Map<Character, Trie>children;\\n    boolean finish;\\n    public Trie(char c, boolean finish)\\n    {\\n        this.c = c;\\n        this.children = new HashMap<>();\\n        this.finish = finish;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n    Trie root;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() \\n    {\\n        root = new Trie(\\'.\\', false);\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) \\n    {\\n        for (String word:dict)\\n        {\\n            addWord(word.toCharArray(), 0, root);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) \\n    {\\n        return searchWord(word.toCharArray(), 0, root, 0);\\n    }\\n    \\n    public void addWord(char[] word, int i, Trie root){\\n        if (i<word.length){\\n            if (root.children.get(word[i])==null) root.children.put(word[i], new Trie(word[i], i==word.length-1));\\n            addWord(word, i+1, root.children.get(word[i]));\\n        }\\n    }\\n    \\n    public boolean searchWord(char[]word, int i, Trie root, int diff)\\n    {\\n        if (diff<=1)\\n        {\\n            if (i==word.length) return root.finish && diff==1;\\n            else if (i<word.length)\\n            {\\n                for (char x:root.children.keySet())\\n                {\\n                    if (searchWord(word, i+1, root.children.get(x), diff + ((x==word[i]?0:1)))) return true;\\n                }\\n                return false;\\n            } \\n            else return false;\\n        }\\n        else return false;\\n    }\\n}\\n\\n\\nclass Trie {\\n    char c;\\n    Map<Character, Trie>children;\\n    boolean finish;\\n    public Trie(char c, boolean finish)\\n    {\\n        this.c = c;\\n        this.children = new HashMap<>();\\n        this.finish = finish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678252,
                "title": "simple-c-hash-table-beats-100-faster",
                "content": "```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, bool> vmap;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for (int i = 0; i < dict.size(); i++) vmap[dict[i]] = true;\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        string s = word;\\n        for (int i = 0; i < word.length(); i++) {\\n        \\n            for (int j = 0; j < 26; j++) {\\n                s[i] = \\'a\\' + j;\\n                if (s[i] != word[i] && vmap.find(s) != vmap.end()) {\\n                    return true;\\n                }\\n            }\\n            s[i] = word[i];\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dict);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<string, bool> vmap;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for (int i = 0; i < dict.size(); i++) vmap[dict[i]] = true;\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        string s = word;\\n        for (int i = 0; i < word.length(); i++) {\\n        \\n            for (int j = 0; j < 26; j++) {\\n                s[i] = \\'a\\' + j;\\n                if (s[i] != word[i] && vmap.find(s) != vmap.end()) {\\n                    return true;\\n                }\\n            }\\n            s[i] = word[i];\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dict);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673805,
                "title": "java-trie-clean-oop-solution",
                "content": "```\\nclass TrieNode {\\n    Map<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    public TrieNode(boolean isWord) {\\n        this.children = new HashMap<>();;\\n        this.isWord = isWord;\\n    }\\n}\\n\\nclass Trie {\\n    private TrieNode root;\\n    \\n    public Trie() {\\n        this.root = new TrieNode(false);\\n    }\\n    \\n    public void insert(String word) {\\n        Map<Character, TrieNode> children = root.children;\\n        for (int i=0; i<word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (children.containsKey(c)) {\\n                TrieNode node = children.get(c);\\n                if (i == word.length()-1) node.isWord = true;\\n                children = node.children;\\n            } else {\\n                TrieNode node = new TrieNode(false);\\n                if (i == word.length()-1) node.isWord = true;\\n                children.put(c, node);\\n                children = node.children;\\n            }\\n        }\\n    }\\n    \\n    public boolean find(String word) {\\n        Map<Character, TrieNode> children = root.children;\\n        for (int i=0; i<word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (children.containsKey(c)) {\\n                TrieNode node = children.get(c);\\n                if (i == word.length()-1 && node.isWord) {\\n                    return true;\\n                }\\n                children = children.get(c).children;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\nclass MagicDictionary {\\n    private Trie trie;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        trie = new Trie();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s : dict) trie.insert(s);\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        for (int i=0; i<word.length(); i++) {\\n            for (char c=\\'a\\'; c<=\\'z\\'; c++) {\\n                if (word.charAt(i) != c) {\\n                    String candidateWord = word.substring(0, i) + c + word.substring(i+1);\\n\\t\\t\\t\\t\\tif (trie.find(candidateWord)) return true;   \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dict);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    Map<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    public TrieNode(boolean isWord) {\\n        this.children = new HashMap<>();;\\n        this.isWord = isWord;\\n    }\\n}\\n\\nclass Trie {\\n    private TrieNode root;\\n    \\n    public Trie() {\\n        this.root = new TrieNode(false);\\n    }\\n    \\n    public void insert(String word) {\\n        Map<Character, TrieNode> children = root.children;\\n        for (int i=0; i<word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (children.containsKey(c)) {\\n                TrieNode node = children.get(c);\\n                if (i == word.length()-1) node.isWord = true;\\n                children = node.children;\\n            } else {\\n                TrieNode node = new TrieNode(false);\\n                if (i == word.length()-1) node.isWord = true;\\n                children.put(c, node);\\n                children = node.children;\\n            }\\n        }\\n    }\\n    \\n    public boolean find(String word) {\\n        Map<Character, TrieNode> children = root.children;\\n        for (int i=0; i<word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (children.containsKey(c)) {\\n                TrieNode node = children.get(c);\\n                if (i == word.length()-1 && node.isWord) {\\n                    return true;\\n                }\\n                children = children.get(c).children;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\nclass MagicDictionary {\\n    private Trie trie;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        trie = new Trie();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s : dict) trie.insert(s);\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        for (int i=0; i<word.length(); i++) {\\n            for (char c=\\'a\\'; c<=\\'z\\'; c++) {\\n                if (word.charAt(i) != c) {\\n                    String candidateWord = word.substring(0, i) + c + word.substring(i+1);\\n\\t\\t\\t\\t\\tif (trie.find(candidateWord)) return true;   \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dict);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646439,
                "title": "python-trie-plus-dfs",
                "content": "I believe Trie + DFS based approach is more intuitive. \\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.children = {}\\n        \\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n        \\n    def add_word(self, word):\\n        r = self.root\\n        for c in word:\\n            if c not in r.children:\\n                r.children[c] = TrieNode()\\n            r = r.children[c]\\n            \\n        r.isWord = True\\n\\n    def buildDict(self, words: List[str]) -> None:\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        \"\"\"\\n        r = self.root\\n        self.words = set(words)\\n        for word in words:\\n            self.add_word(word)\\n            \\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        \"\"\"\\n\\n        return self.dfs(word, 0, self.root)\\n\\n    def dfs(self, word, count, r):\\n        if count > 1:\\n            return False\\n        if not word:\\n            return count == 1 and r.isWord\\n\\n        for c in r.children:\\n            if self.dfs(word[1:], count + (word[0]!=c), r.children[c]):\\n                return True\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.children = {}\\n        \\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n        \\n    def add_word(self, word):\\n        r = self.root\\n        for c in word:\\n            if c not in r.children:\\n                r.children[c] = TrieNode()\\n            r = r.children[c]\\n            \\n        r.isWord = True\\n\\n    def buildDict(self, words: List[str]) -> None:\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        \"\"\"\\n        r = self.root\\n        self.words = set(words)\\n        for word in words:\\n            self.add_word(word)\\n            \\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        \"\"\"\\n\\n        return self.dfs(word, 0, self.root)\\n\\n    def dfs(self, word, count, r):\\n        if count > 1:\\n            return False\\n        if not word:\\n            return count == 1 and r.isWord\\n\\n        for c in r.children:\\n            if self.dfs(word[1:], count + (word[0]!=c), r.children[c]):\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640909,
                "title": "recursive-trie-truly-straightforward",
                "content": "```\\nimport collections\\ntrie = lambda: collections.defaultdict(trie)\\nclass Trie:\\n    def __init__(self):\\n        self.trie = trie()\\n        \\n    def insert(self, word):\\n        reduce(dict.__getitem__, word, self.trie)[\\'$\\'] = trie()\\n\\n    def find_neighbor(self, node, word, remain):\\n        if not word:\\n            return True if \\'$\\' in node and remain == 0 else False\\n        for key in node.keys():\\n            if key == word[0]:\\n                if self.find_neighbor(node[key], word[1:], remain):\\n                    return True\\n            elif remain == 1:\\n                if self.find_neighbor(node[key], word[1:], 0)\\n                    return True\\n        return False              \\n        \\n\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.trie = Trie()\\n        self.buckets = collections.defaultdict(list)      \\n\\n    def buildDict(self, dict):\\n        for word in dict:\\n            self.trie.insert(word)\\n        \\n    def search(self, word):\\n        return self.trie.find_neighbor(self.trie.trie, word, 1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nimport collections\\ntrie = lambda: collections.defaultdict(trie)\\nclass Trie:\\n    def __init__(self):\\n        self.trie = trie()\\n        \\n    def insert(self, word):\\n        reduce(dict.__getitem__, word, self.trie)[\\'$\\'] = trie()\\n\\n    def find_neighbor(self, node, word, remain):\\n        if not word:\\n            return True if \\'$\\' in node and remain == 0 else False\\n        for key in node.keys():\\n            if key == word[0]:\\n                if self.find_neighbor(node[key], word[1:], remain):\\n                    return True\\n            elif remain == 1:\\n                if self.find_neighbor(node[key], word[1:], 0)\\n                    return True\\n        return False              \\n        \\n\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.trie = Trie()\\n        self.buckets = collections.defaultdict(list)      \\n\\n    def buildDict(self, dict):\\n        for word in dict:\\n            self.trie.insert(word)\\n        \\n    def search(self, word):\\n        return self.trie.find_neighbor(self.trie.trie, word, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632842,
                "title": "javascript-100-space-and-speed",
                "content": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MagicDictionary = function() {\\n    this.buckets = {};\\n};\\n\\n/**\\n * Build a dictionary through a list of words \\n * @param {string[]} dict\\n * @return {void}\\n */\\nMagicDictionary.prototype.buildDict = function(dict) {\\n    for (let word of dict) {\\n        let list = [];\\n        if (!this.buckets[word.length])\\n            this.buckets[word.length] = list;\\n        else\\n            list = this.buckets[word.length];\\n        list.push(word);\\n    }\\n};\\n\\n/**\\n * Returns if there is any word in the trie that equals to the given word after modifying exactly one character \\n * @param {string} word\\n * @return {boolean}\\n */\\nMagicDictionary.prototype.search = function(word) {\\n    if (typeof this.buckets[word.length] === \\'undefined\\') {\\n        return false;\\n    }\\n    for (let candidate of this.buckets[word.length]) {\\n        let mismatch = 0;\\n        for (let i = 0; i < word.length; i++) {\\n            if (word[i] != candidate[i]) {\\n                if (mismatch++ > 1) break;\\n            }\\n        }\\n        if (mismatch == 1)\\n            return true;\\n    }\\n    return false;\\n};\\n\\n/** \\n * Your MagicDictionary object will be instantiated and called as such:\\n * var obj = new MagicDictionary()\\n * obj.buildDict(dict)\\n * var param_2 = obj.search(word)\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MagicDictionary = function() {\\n    this.buckets = {};\\n};\\n\\n/**\\n * Build a dictionary through a list of words \\n * @param {string[]} dict\\n * @return {void}\\n */\\nMagicDictionary.prototype.buildDict = function(dict) {\\n    for (let word of dict) {\\n        let list = [];\\n        if (!this.buckets[word.length])\\n            this.buckets[word.length] = list;\\n        else\\n            list = this.buckets[word.length];\\n        list.push(word);\\n    }\\n};\\n\\n/**\\n * Returns if there is any word in the trie that equals to the given word after modifying exactly one character \\n * @param {string} word\\n * @return {boolean}\\n */\\nMagicDictionary.prototype.search = function(word) {\\n    if (typeof this.buckets[word.length] === \\'undefined\\') {\\n        return false;\\n    }\\n    for (let candidate of this.buckets[word.length]) {\\n        let mismatch = 0;\\n        for (let i = 0; i < word.length; i++) {\\n            if (word[i] != candidate[i]) {\\n                if (mismatch++ > 1) break;\\n            }\\n        }\\n        if (mismatch == 1)\\n            return true;\\n    }\\n    return false;\\n};\\n\\n/** \\n * Your MagicDictionary object will be instantiated and called as such:\\n * var obj = new MagicDictionary()\\n * obj.buildDict(dict)\\n * var param_2 = obj.search(word)\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 611909,
                "title": "c-trietree",
                "content": "```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    struct TreeNode{\\n        bool isEnd;\\n        vector<TreeNode*> next;\\n        TreeNode()\\n        {\\n            isEnd = false;\\n            next = vector<TreeNode*>(26, NULL);\\n        }\\n    };\\n    TreeNode* root;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        root = new TreeNode();\\n        for(string word : dict)\\n        {\\n            TreeNode* node = root;\\n            for(char ch : word)\\n            {\\n                if(node->next[ch-\\'a\\']==NULL)\\n                    node->next[ch-\\'a\\'] = new TreeNode();\\n                node = node->next[ch-\\'a\\'];\\n            }\\n            node->isEnd = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool dfs(TreeNode* node, string word, int num)\\n    {\\n        if(num>1)\\n            return false;\\n        if(word==\"\")\\n        {\\n            if(num==1&&node->isEnd)\\n                return true;\\n            return false;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(node->next[i]!=NULL)\\n            {\\n                if(word[0]==char(i+\\'a\\'))\\n                {\\n                    if(dfs(node->next[i], word.substr(1), num))\\n                        return true;\\n                }\\n                else\\n                    if(dfs(node->next[i], word.substr(1), num+1))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool search(string word) {\\n        return dfs(root, word, 0);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dict);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    struct TreeNode{\\n        bool isEnd;\\n        vector<TreeNode*> next;\\n        TreeNode()\\n        {\\n            isEnd = false;\\n            next = vector<TreeNode*>(26, NULL);\\n        }\\n    };\\n    TreeNode* root;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        root = new TreeNode();\\n        for(string word : dict)\\n        {\\n            TreeNode* node = root;\\n            for(char ch : word)\\n            {\\n                if(node->next[ch-\\'a\\']==NULL)\\n                    node->next[ch-\\'a\\'] = new TreeNode();\\n                node = node->next[ch-\\'a\\'];\\n            }\\n            node->isEnd = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool dfs(TreeNode* node, string word, int num)\\n    {\\n        if(num>1)\\n            return false;\\n        if(word==\"\")\\n        {\\n            if(num==1&&node->isEnd)\\n                return true;\\n            return false;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(node->next[i]!=NULL)\\n            {\\n                if(word[0]==char(i+\\'a\\'))\\n                {\\n                    if(dfs(node->next[i], word.substr(1), num))\\n                        return true;\\n                }\\n                else\\n                    if(dfs(node->next[i], word.substr(1), num+1))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool search(string word) {\\n        return dfs(root, word, 0);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dict);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565335,
                "title": "java-and-hashmap-trie-based-solution",
                "content": "```\\nclass MagicDictionary {\\n    \\n    private Map<Integer, List<String>> dictionary;\\n\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        dictionary = new HashMap<>();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        \\n        for(int i=0; i<dict.length; i++) {\\n\\t\\t\\tint wordLength = dict[i].length();\\n\\t\\t\\tList<String> list;\\n\\t\\t\\tif(!dictionary.containsKey(wordLength)) {\\n\\t\\t\\t\\tlist = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(dict[i]);\\n\\t\\t\\t\\tdictionary.put(wordLength,list);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tlist = dictionary.get(wordLength);\\n\\t\\t\\t\\tlist.add(dict[i]);\\n\\t\\t\\t\\tdictionary.put(wordLength, list);\\n\\t\\t\\t}\\n\\t\\t}\\n    \\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        \\n        if(word.isEmpty() || dictionary.isEmpty()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint wordLength = word.length();\\n\\t\\tif(!dictionary.containsKey(wordLength)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tList<String> list = dictionary.get(wordLength);\\n\\t\\t\\tif(list.isEmpty()) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i<list.size(); i++) {\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int j=0; j<list.get(i).length(); j++) {\\n\\t\\t\\t\\t\\tif(word.charAt(j) != list.get(i).charAt(j)) {\\n\\t\\t\\t\\t\\t\\tcount++;\\n                    }\\n\\t\\t\\t\\t}\\n                if(count == 1) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass MagicDictionary {\\n    \\n    private Map<Integer, List<String>> dictionary;\\n\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        dictionary = new HashMap<>();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        \\n        for(int i=0; i<dict.length; i++) {\\n\\t\\t\\tint wordLength = dict[i].length();\\n\\t\\t\\tList<String> list;\\n\\t\\t\\tif(!dictionary.containsKey(wordLength)) {\\n\\t\\t\\t\\tlist = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(dict[i]);\\n\\t\\t\\t\\tdictionary.put(wordLength,list);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tlist = dictionary.get(wordLength);\\n\\t\\t\\t\\tlist.add(dict[i]);\\n\\t\\t\\t\\tdictionary.put(wordLength, list);\\n\\t\\t\\t}\\n\\t\\t}\\n    \\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        \\n        if(word.isEmpty() || dictionary.isEmpty()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint wordLength = word.length();\\n\\t\\tif(!dictionary.containsKey(wordLength)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tList<String> list = dictionary.get(wordLength);\\n\\t\\t\\tif(list.isEmpty()) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i<list.size(); i++) {\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int j=0; j<list.get(i).length(); j++) {\\n\\t\\t\\t\\t\\tif(word.charAt(j) != list.get(i).charAt(j)) {\\n\\t\\t\\t\\t\\t\\tcount++;\\n                    }\\n\\t\\t\\t\\t}\\n                if(count == 1) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 557095,
                "title": "java-trie-backtracking",
                "content": "```java\\nclass MagicDictionary {\\n    \\n    class TrieNode {\\n        TrieNode[] children;\\n        boolean isEnd;\\n        public TrieNode() {\\n            children = new TrieNode[26];\\n        }\\n    }\\n    \\n    TrieNode root;\\n    \\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        \\n        // build trie\\n        for(String s : dict) {\\n            TrieNode cur = root;\\n            for (char c : s.toCharArray()) {\\n                if (cur.children[c-\\'a\\'] == null) {\\n                    cur.children[c-\\'a\\'] = new TrieNode();\\n                }        \\n                \\n                cur = cur.children[c-\\'a\\'];\\n            }\\n            \\n            cur.isEnd = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        return backtrack(word, 0, false, root);\\n    }\\n    \\n    private boolean backtrack(String word, int index, boolean changed, TrieNode root) {\\n        \\n        if (root == null) return false;\\n        if (index == word.length() && root.isEnd && changed) return true;\\n        if (index == word.length()) return false;\\n        \\n        char c = word.charAt(index);\\n        \\n        boolean res = false;\\n        \\n        // case 1. we are able to find the same character, we move on to next trie node\\n        if (root.children[c-\\'a\\'] != null) {\\n            res |= backtrack(word, index+1, changed, root.children[c-\\'a\\']);\\n        }\\n        \\n        // case 2. we decide to modify this character\\n        // we need to check all possible children at the level of trie node\\n        if (changed == false) {\\n            for (int i = 0; i < 25; ++i) {\\n                if (root.children[c-\\'a\\'] != null && (c-\\'a\\') == i) continue;\\n                \\n                res |= backtrack(word, index+1, true, root.children[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dict);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "solutionTags": [],
                "code": "```java\\nclass MagicDictionary {\\n    \\n    class TrieNode {\\n        TrieNode[] children;\\n        boolean isEnd;\\n        public TrieNode() {\\n            children = new TrieNode[26];\\n        }\\n    }\\n    \\n    TrieNode root;\\n    \\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        \\n        // build trie\\n        for(String s : dict) {\\n            TrieNode cur = root;\\n            for (char c : s.toCharArray()) {\\n                if (cur.children[c-\\'a\\'] == null) {\\n                    cur.children[c-\\'a\\'] = new TrieNode();\\n                }        \\n                \\n                cur = cur.children[c-\\'a\\'];\\n            }\\n            \\n            cur.isEnd = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        return backtrack(word, 0, false, root);\\n    }\\n    \\n    private boolean backtrack(String word, int index, boolean changed, TrieNode root) {\\n        \\n        if (root == null) return false;\\n        if (index == word.length() && root.isEnd && changed) return true;\\n        if (index == word.length()) return false;\\n        \\n        char c = word.charAt(index);\\n        \\n        boolean res = false;\\n        \\n        // case 1. we are able to find the same character, we move on to next trie node\\n        if (root.children[c-\\'a\\'] != null) {\\n            res |= backtrack(word, index+1, changed, root.children[c-\\'a\\']);\\n        }\\n        \\n        // case 2. we decide to modify this character\\n        // we need to check all possible children at the level of trie node\\n        if (changed == false) {\\n            for (int i = 0; i < 25; ++i) {\\n                if (root.children[c-\\'a\\'] != null && (c-\\'a\\') == i) continue;\\n                \\n                res |= backtrack(word, index+1, true, root.children[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dict);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453898,
                "title": "java-a-more-general-solution-by-dfs-in-trie",
                "content": "```\\nclass MagicDictionary {\\n    class Node{\\n        Node[] next= new Node[26];\\n        boolean isWord;\\n    }\\n    Node root= new Node();\\n\\n    public MagicDictionary() {\\n\\n    }\\n\\n    public void buildDict(String[] dict) {\\n        for (String s: dict){\\n            Node cur= root;\\n            for (char c: s.toCharArray()){\\n                if (cur.next[c-\\'a\\']==null) cur.next[c-\\'a\\']=new Node();\\n                cur=cur.next[c-\\'a\\'];\\n            }\\n            cur.isWord=true;\\n        }\\n    }\\n\\n    public boolean search(String word) {\\n        // If the character of the target string is changed n times, you can set step = n;\\n        // In this problem step is 1;\\n        return dfs(root, word, 0, 1);\\n    }\\n    // the step is the Number of character modifications\\n    public boolean dfs(Node cur, String word, int idx, int step){\\n        if(cur == null || step < 0) return false;\\n        if (idx==word.length()) return cur.isWord && step == 0;\\n        char c= word.charAt(idx);\\n        for (int i=0; i<26; i++){\\n            if( c - \\'a\\' != i){\\n                if (dfs(cur.next[i], word, idx+1, step - 1))\\n                    return true;\\n            }else{\\n                if (dfs(cur.next[i], word, idx+1, step))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n    class Node{\\n        Node[] next= new Node[26];\\n        boolean isWord;\\n    }\\n    Node root= new Node();\\n\\n    public MagicDictionary() {\\n\\n    }\\n\\n    public void buildDict(String[] dict) {\\n        for (String s: dict){\\n            Node cur= root;\\n            for (char c: s.toCharArray()){\\n                if (cur.next[c-\\'a\\']==null) cur.next[c-\\'a\\']=new Node();\\n                cur=cur.next[c-\\'a\\'];\\n            }\\n            cur.isWord=true;\\n        }\\n    }\\n\\n    public boolean search(String word) {\\n        // If the character of the target string is changed n times, you can set step = n;\\n        // In this problem step is 1;\\n        return dfs(root, word, 0, 1);\\n    }\\n    // the step is the Number of character modifications\\n    public boolean dfs(Node cur, String word, int idx, int step){\\n        if(cur == null || step < 0) return false;\\n        if (idx==word.length()) return cur.isWord && step == 0;\\n        char c= word.charAt(idx);\\n        for (int i=0; i<26; i++){\\n            if( c - \\'a\\' != i){\\n                if (dfs(cur.next[i], word, idx+1, step - 1))\\n                    return true;\\n            }else{\\n                if (dfs(cur.next[i], word, idx+1, step))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436391,
                "title": "python-trie",
                "content": "time O(len(word) * len(dictionary), \\nspace O(num of unique prefix) for trie\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = collections.defaultdict(TrieNode)\\n        self.isword = False\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def buildDict(self, dict: List[str]) -> None:\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        \"\"\"        \\n        for word in dict:\\n            cur = self.root\\n            for letter in word:\\n                cur = cur.child[letter]\\n            cur.isword = True\\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        \"\"\"\\n\\n        cur = self.root\\n        n = len(word)\\n        \\n        for index in range(n):\\n            letter = word[index]\\n            # if any replacement result in good result return True\\n            for i in cur.child:\\n                if i == letter:\\n                    continue\\n                if self.validafter(cur.child[i], index + 1, word, n):\\n                    return True\\n                \\n            # then have to continue\\n            if letter in cur.child:\\n                cur = cur.child[letter]\\n                continue\\n            # if can\\'t continue return false\\n            return False\\n        return False\\n    \\n    # search in the trie with starting point as argument worst case time O(len(word) * len(dictionary))\\n    def validafter(self, cur, index, word, n):\\n        for i in range(index, n):\\n            if word[i] not in cur.child:\\n                return False\\n            cur = cur.child[word[i]]\\n        return cur.isword\\n        \\n\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dict)\\n# param_2 = obj.search(word)",
                "solutionTags": [],
                "code": "time O(len(word) * len(dictionary), \\nspace O(num of unique prefix) for trie\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = collections.defaultdict(TrieNode)\\n        self.isword = False\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def buildDict(self, dict: List[str]) -> None:\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        \"\"\"        \\n        for word in dict:\\n            cur = self.root\\n            for letter in word:\\n                cur = cur.child[letter]\\n            cur.isword = True\\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        \"\"\"\\n\\n        cur = self.root\\n        n = len(word)\\n        \\n        for index in range(n):\\n            letter = word[index]\\n            # if any replacement result in good result return True\\n            for i in cur.child:\\n                if i == letter:\\n                    continue\\n                if self.validafter(cur.child[i], index + 1, word, n):\\n                    return True\\n                \\n            # then have to continue\\n            if letter in cur.child:\\n                cur = cur.child[letter]\\n                continue\\n            # if can\\'t continue return false\\n            return False\\n        return False\\n    \\n    # search in the trie with starting point as argument worst case time O(len(word) * len(dictionary))\\n    def validafter(self, cur, index, word, n):\\n        for i in range(index, n):\\n            if word[i] not in cur.child:\\n                return False\\n            cur = cur.child[word[i]]\\n        return cur.isword\\n        \\n\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dict)\\n# param_2 = obj.search(word)",
                "codeTag": "Java"
            },
            {
                "id": 427017,
                "title": "simple-java-solution-using-trie-for-slow-learners-like-myself-9ms",
                "content": "```\\nclass MagicDictionary {\\n\\n    private static final class Node {\\n        private final Node[] nodes = new Node[26];\\n        private boolean isWord;\\n    }\\n    \\n    private final Node root;\\n\\n    public MagicDictionary() {\\n        this.root = new Node();\\n    }\\n\\n    public void buildDict(String[] dict) {\\n        for (String word : dict)\\n            insert(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        return find(root, word, 0, false);    \\n    }\\n    \\n    private boolean find(Node root, String word, int pos, boolean isMutated) {\\n        if (root == null)\\n            return false;\\n        \\n        if (pos == word.length()) //success iff we reach the end of the string and we have mutated one character\\n            return root.isWord && isMutated;\\n        \\n        char c = word.charAt(pos++);\\n        if (isMutated) \\n            return find(root.nodes[c - \\'a\\'], word, pos, isMutated);\\n        \\n        //not mutated yet\\n        for (char a = \\'a\\'; a <= \\'z\\'; a++) {\\n            if (find(root.nodes[a - \\'a\\'], word, pos, a != c)) //if a == c, it means we haven\\'t mutated any char\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void insert(String word) {\\n        Node cur = root;\\n        for (char c : word.toCharArray()) {\\n            Node next = cur.nodes[c - \\'a\\'] == null ? new Node() : cur.nodes[c - \\'a\\'];\\n            cur.nodes[c - \\'a\\'] = next;\\n            cur = next;\\n        }\\n        cur.isWord = true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n\\n    private static final class Node {\\n        private final Node[] nodes = new Node[26];\\n        private boolean isWord;\\n    }\\n    \\n    private final Node root;\\n\\n    public MagicDictionary() {\\n        this.root = new Node();\\n    }\\n\\n    public void buildDict(String[] dict) {\\n        for (String word : dict)\\n            insert(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        return find(root, word, 0, false);    \\n    }\\n    \\n    private boolean find(Node root, String word, int pos, boolean isMutated) {\\n        if (root == null)\\n            return false;\\n        \\n        if (pos == word.length()) //success iff we reach the end of the string and we have mutated one character\\n            return root.isWord && isMutated;\\n        \\n        char c = word.charAt(pos++);\\n        if (isMutated) \\n            return find(root.nodes[c - \\'a\\'], word, pos, isMutated);\\n        \\n        //not mutated yet\\n        for (char a = \\'a\\'; a <= \\'z\\'; a++) {\\n            if (find(root.nodes[a - \\'a\\'], word, pos, a != c)) //if a == c, it means we haven\\'t mutated any char\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void insert(String word) {\\n        Node cur = root;\\n        for (char c : word.toCharArray()) {\\n            Node next = cur.nodes[c - \\'a\\'] == null ? new Node() : cur.nodes[c - \\'a\\'];\\n            cur.nodes[c - \\'a\\'] = next;\\n            cur = next;\\n        }\\n        cur.isWord = true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378695,
                "title": "javascript-simple-solution-98-55-faster-runtime-100-less-memory",
                "content": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MagicDictionary = function() {\\n    this.words = [];\\n};\\n\\n/**\\n * Build a dictionary through a list of words \\n * @param {string[]} dict\\n * @return {void}\\n */\\nMagicDictionary.prototype.buildDict = function(dict) {\\n    this.words = dict;\\n};\\n\\n/**\\n * Returns if there is any word in the trie that equals to the given word after modifying exactly one character \\n * @param {string} word\\n * @return {boolean}\\n */\\nMagicDictionary.prototype.search = function(subject) {\\n    const matches = this.words.filter(word => {\\n        if (word.length !== subject.length) return false;\\n        let swapped = false;\\n        for (let i = 0; i < word.length; i++) {\\n            if (word[i] !== subject[i]) {\\n                if (swapped) return false;\\n                swapped = true;\\n            }\\n        }\\n        return swapped;\\n    });\\n    return Boolean(matches.length);\\n};\\n\\n/** \\n * Your MagicDictionary object will be instantiated and called as such:\\n * var obj = new MagicDictionary()\\n * obj.buildDict(dict)\\n * var param_2 = obj.search(word)\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar MagicDictionary = function() {\\n    this.words = [];\\n};\\n\\n/**\\n * Build a dictionary through a list of words \\n * @param {string[]} dict\\n * @return {void}\\n */\\nMagicDictionary.prototype.buildDict = function(dict) {\\n    this.words = dict;\\n};\\n\\n/**\\n * Returns if there is any word in the trie that equals to the given word after modifying exactly one character \\n * @param {string} word\\n * @return {boolean}\\n */\\nMagicDictionary.prototype.search = function(subject) {\\n    const matches = this.words.filter(word => {\\n        if (word.length !== subject.length) return false;\\n        let swapped = false;\\n        for (let i = 0; i < word.length; i++) {\\n            if (word[i] !== subject[i]) {\\n                if (swapped) return false;\\n                swapped = true;\\n            }\\n        }\\n        return swapped;\\n    });\\n    return Boolean(matches.length);\\n};\\n\\n/** \\n * Your MagicDictionary object will be instantiated and called as such:\\n * var obj = new MagicDictionary()\\n * obj.buildDict(dict)\\n * var param_2 = obj.search(word)\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 363565,
                "title": "my-c-trie-solution",
                "content": "```\\nstruct Trie\\n{\\n\\tchar ch;\\n\\tbool bWord = false;\\n\\tunordered_map<char, Trie*> childs;\\n\\tTrie() { }\\n\\tTrie(char c) : ch(c) { }\\n};\\nclass MagicDictionary {\\npublic:\\t\\n\\tTrie* root;\\n\\t/** Initialize your data structure here. */\\n\\tMagicDictionary() {\\n\\t\\t\\n\\t}\\n\\n\\t/** Build a dictionary through a list of words */\\n\\tvoid buildDict(vector<string> dict) {\\n\\t\\troot = new Trie();\\n\\t\\tTrie* cur = root;\\n\\t\\tfor (int i = 0; i < dict.size(); i++)\\n\\t\\t{\\n\\t\\t\\tcur = root;\\n\\t\\t\\tfor (int j = 0; j < dict[i].size(); j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (cur->childs.find(dict[i][j]) == cur->childs.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcur->childs[dict[i][j]] = new Trie(dict[i][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcur = cur->childs[dict[i][j]];\\n\\t\\t\\t\\tif (j == dict[i].size() - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcur->bWord = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n\\tbool search(string word) {\\n\\t\\treturn search(word, root, false);\\n\\t}\\n\\n\\tbool search(const string& word, Trie* cur, bool bUse)\\n\\t{\\n\\t\\tfor (int i = 0; i < word.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif (cur->childs.find(word[i]) == cur->childs.end())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (bUse)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (auto it = cur->childs.begin(); it != cur->childs.end(); it++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (search(word.substr(i + 1), it->second, true))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (!bUse)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (auto it = cur->childs.begin(); it != cur->childs.end(); it++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (it->first != word[i])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (search(word.substr(i + 1), it->second, true))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur->childs[word[i]];\\n\\t\\t}\\n\\t\\treturn bUse && cur->bWord;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Trie\\n{\\n\\tchar ch;\\n\\tbool bWord = false;\\n\\tunordered_map<char, Trie*> childs;\\n\\tTrie() { }\\n\\tTrie(char c) : ch(c) { }\\n};\\nclass MagicDictionary {\\npublic:\\t\\n\\tTrie* root;\\n\\t/** Initialize your data structure here. */\\n\\tMagicDictionary() {\\n\\t\\t\\n\\t}\\n\\n\\t/** Build a dictionary through a list of words */\\n\\tvoid buildDict(vector<string> dict) {\\n\\t\\troot = new Trie();\\n\\t\\tTrie* cur = root;\\n\\t\\tfor (int i = 0; i < dict.size(); i++)\\n\\t\\t{\\n\\t\\t\\tcur = root;\\n\\t\\t\\tfor (int j = 0; j < dict[i].size(); j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (cur->childs.find(dict[i][j]) == cur->childs.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcur->childs[dict[i][j]] = new Trie(dict[i][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcur = cur->childs[dict[i][j]];\\n\\t\\t\\t\\tif (j == dict[i].size() - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcur->bWord = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n\\tbool search(string word) {\\n\\t\\treturn search(word, root, false);\\n\\t}\\n\\n\\tbool search(const string& word, Trie* cur, bool bUse)\\n\\t{\\n\\t\\tfor (int i = 0; i < word.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif (cur->childs.find(word[i]) == cur->childs.end())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (bUse)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (auto it = cur->childs.begin(); it != cur->childs.end(); it++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (search(word.substr(i + 1), it->second, true))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (!bUse)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (auto it = cur->childs.begin(); it != cur->childs.end(); it++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (it->first != word[i])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (search(word.substr(i + 1), it->second, true))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur->childs[word[i]];\\n\\t\\t}\\n\\t\\treturn bUse && cur->bWord;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349121,
                "title": "python-easy-to-understand-using-dictionary-of-length",
                "content": "\\n```\\n    def __init__(self):\\n\\t\\tself.map = collections.defaultdict(list)\\n        \\n    def buildDict(self, dict):\\n\\t\\tfor word in dict:\\n            self.map[len(word)].append(word)  \\n\\n    def search(self, word):\\n\\t\\tfor value in self.map[len(word)]:\\n            difference = 0\\n            for i in xrange(len(word)):\\n                if ord(value[i]) - ord(word[i]) != 0:\\n                    difference += 1\\n            if difference == 1:\\n                return True\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n    def __init__(self):\\n\\t\\tself.map = collections.defaultdict(list)\\n        \\n    def buildDict(self, dict):\\n\\t\\tfor word in dict:\\n            self.map[len(word)].append(word)  \\n\\n    def search(self, word):\\n\\t\\tfor value in self.map[len(word)]:\\n            difference = 0\\n            for i in xrange(len(word)):\\n                if ord(value[i]) - ord(word[i]) != 0:\\n                    difference += 1\\n            if difference == 1:\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 311149,
                "title": "java-solution-with-trie-beats-94",
                "content": "\\n```\\npublic class MagicDictionary {\\n\\n    class TrieNode {\\n        char c;\\n        TrieNode[] child;\\n        boolean isWord;\\n\\n        public TrieNode(char v) {\\n            c = v;\\n            child = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n\\n    TrieNode root;\\n\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new TrieNode(\\' \\');\\n    }\\n\\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String word : dict) {\\n            TrieNode cur = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                if (cur.child[word.charAt(i) - \\'a\\'] == null) {\\n                    cur.child[word.charAt(i) - \\'a\\'] = new TrieNode(word.charAt(i));\\n                }\\n                cur = cur.child[word.charAt(i) - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n        }\\n    }\\n\\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n\\n        return dfs(word, 0, 0, root);\\n    }\\n\\n    private boolean dfs(String word, int cur, int dff, TrieNode node) {\\n        if (cur == word.length()) {\\n            return dff == 1 && node.isWord;\\n        }\\n\\n\\n        if (dff > 1) {\\n            return false;\\n        }\\n\\n\\n        char c = word.charAt(cur);\\n\\n        \\n\\n\\n        for (int i = 0; i < 26; i++) {\\n            if (node.child[i] != null &&\\n                dfs(word, cur+1, word.charAt(cur) - \\'a\\' == i? dff : dff+1, node.child[i])){\\n                return true;\\n            }\\n        }\\n        \\n        \\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MagicDictionary {\\n\\n    class TrieNode {\\n        char c;\\n        TrieNode[] child;\\n        boolean isWord;\\n\\n        public TrieNode(char v) {\\n            c = v;\\n            child = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n\\n    TrieNode root;\\n\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        root = new TrieNode(\\' \\');\\n    }\\n\\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String word : dict) {\\n            TrieNode cur = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                if (cur.child[word.charAt(i) - \\'a\\'] == null) {\\n                    cur.child[word.charAt(i) - \\'a\\'] = new TrieNode(word.charAt(i));\\n                }\\n                cur = cur.child[word.charAt(i) - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n        }\\n    }\\n\\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n\\n        return dfs(word, 0, 0, root);\\n    }\\n\\n    private boolean dfs(String word, int cur, int dff, TrieNode node) {\\n        if (cur == word.length()) {\\n            return dff == 1 && node.isWord;\\n        }\\n\\n\\n        if (dff > 1) {\\n            return false;\\n        }\\n\\n\\n        char c = word.charAt(cur);\\n\\n        \\n\\n\\n        for (int i = 0; i < 26; i++) {\\n            if (node.child[i] != null &&\\n                dfs(word, cur+1, word.charAt(cur) - \\'a\\' == i? dff : dff+1, node.child[i])){\\n                return true;\\n            }\\n        }\\n        \\n        \\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275229,
                "title": "javascript-56ms-34mb",
                "content": "```\\nvar MagicDictionary = function() {\\n    this.root = {};\\n};\\n\\n/**\\n * Build a dictionary through a list of words \\n * @param {string[]} dict\\n * @return {void}\\n */\\nMagicDictionary.prototype.buildDict = function(dict) {\\n    dict.forEach(word => {\\n        if(!this.root[word.length]) this.root[word.length] = [];\\n        this.root[word.length].push(word);\\n    })\\n};\\n\\n/**\\n * Returns if there is any word in the trie that equals to the given word after modifying exactly one character \\n * @param {string} word\\n * @return {boolean}\\n */\\nMagicDictionary.prototype.search = function(word) {\\n    if(!this.root[word.length]) return false;\\n    return this.root[word.length].some(target => {\\n        let count = 0;\\n        for(let i=0; i<word.length; i++){\\n            if(word[i] !== target[i]) count++;\\n        }\\n        return count === 1\\n    });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar MagicDictionary = function() {\\n    this.root = {};\\n};\\n\\n/**\\n * Build a dictionary through a list of words \\n * @param {string[]} dict\\n * @return {void}\\n */\\nMagicDictionary.prototype.buildDict = function(dict) {\\n    dict.forEach(word => {\\n        if(!this.root[word.length]) this.root[word.length] = [];\\n        this.root[word.length].push(word);\\n    })\\n};\\n\\n/**\\n * Returns if there is any word in the trie that equals to the given word after modifying exactly one character \\n * @param {string} word\\n * @return {boolean}\\n */\\nMagicDictionary.prototype.search = function(word) {\\n    if(!this.root[word.length]) return false;\\n    return this.root[word.length].some(target => {\\n        let count = 0;\\n        for(let i=0; i<word.length; i++){\\n            if(word[i] !== target[i]) count++;\\n        }\\n        return count === 1\\n    });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267953,
                "title": "python-trie-using-just-map-hash-table",
                "content": "```\\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        self.m = {}\\n        self.l = {}\\n\\n    def buildDict(self, dict):\\n        for w in dict:\\n            self.l[len(w)] = 0\\n            mp = self.m\\n            for c in w:\\n                if not c in mp:\\n                    mp[c] = {}\\n                mp = mp[c]\\n            mp[None] = None #marking end of string\\n                \\n    def s(self, i, word, wl, mp, x):\\n        if mp == None:\\n            return False\\n        if i == wl:\\n            return x == 1 and None in mp\\n        if x:\\n            if word[i] in mp:\\n                return self.s(i + 1, word, wl, mp[word[i]], 1)\\n            else:\\n                return False\\n        else:\\n            return any([self.s(i + 1, word, wl, mp[c], 0 if c == word[i] else 1) for c in mp])\\n\\n    def search(self, word):\\n        if not len(word) in self.l:\\n            return False\\n        return self.s(0, word, len(word), self.m, 0)\\n```\\n\\n24ms, 11.9MB",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        self.m = {}\\n        self.l = {}\\n\\n    def buildDict(self, dict):\\n        for w in dict:\\n            self.l[len(w)] = 0\\n            mp = self.m\\n            for c in w:\\n                if not c in mp:\\n                    mp[c] = {}\\n                mp = mp[c]\\n            mp[None] = None #marking end of string\\n                \\n    def s(self, i, word, wl, mp, x):\\n        if mp == None:\\n            return False\\n        if i == wl:\\n            return x == 1 and None in mp\\n        if x:\\n            if word[i] in mp:\\n                return self.s(i + 1, word, wl, mp[word[i]], 1)\\n            else:\\n                return False\\n        else:\\n            return any([self.s(i + 1, word, wl, mp[c], 0 if c == word[i] else 1) for c in mp])\\n\\n    def search(self, word):\\n        if not len(word) in self.l:\\n            return False\\n        return self.s(0, word, len(word), self.m, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264587,
                "title": "java-simple-brute-force-beats-99-54",
                "content": "This doesn\\'t use any fancy data structures or do anything tricky, just count letter mismatches.\\n```\\nclass MagicDictionary {\\n    private String[] words;\\n    public MagicDictionary() {}\\n    public void buildDict(String[] dict) { words=dict; }\\n    \\n    public boolean search(String word) {\\n        for( String D : words ) {\\n            if( word.length()!=D.length() ) continue;\\n            int i=0, n=0;\\n            for(char[] d=D.toCharArray(),w=word.toCharArray(); i<d.length && n<2; i++) if(d[i]!=w[i]) n++;\\n            if( n==1 ) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\nAnd yet this beats 99.54%!  I guess problem statemen wasn\\'t lying when it explicitly said, \"the test data is rather small\".  :-)",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n    private String[] words;\\n    public MagicDictionary() {}\\n    public void buildDict(String[] dict) { words=dict; }\\n    \\n    public boolean search(String word) {\\n        for( String D : words ) {\\n            if( word.length()!=D.length() ) continue;\\n            int i=0, n=0;\\n            for(char[] d=D.toCharArray(),w=word.toCharArray(); i<d.length && n<2; i++) if(d[i]!=w[i]) n++;\\n            if( n==1 ) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250395,
                "title": "trie-recursive-solution-for-python-96-faster",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\n    def __str__(self):\\n        return \"TrieNode is = {}\\\\nTrieNode isEnd = {}\".format(self.children.keys(), self.isEnd)\\n\\nclass MagicDictionary(object):\\n\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.TrieRoot = TrieNode()\\n        \\n\\n    def buildDict(self, dict):\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        :type dict: List[str]\\n        :rtype: None\\n        \"\"\"\\n        for word in dict:\\n            root = self.TrieRoot\\n            for letter in word:\\n                if letter not in root.children:\\n                    root.children[letter] = TrieNode()\\n                root = root.children[letter]\\n            root.isEnd = True\\n        \\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        #print(\"searching word = \" + word)\\n        return self.recurseSearch(word, 0, 0, self.TrieRoot)\\n    \\n    def recurseSearch(self,word, index, mismatch, root):\\n       \\n        \\n        if mismatch == 1 and index == len(word) and root.isEnd:\\n            return True\\n        \\n        if mismatch > 1 or index == len(word):\\n            return False\\n        \\n        #recursively search in the trie for all possible values\\n        ret_value = False\\n        for letter,node in root.children.items():\\n            if word[index] == letter:\\n                ret_value = self.recurseSearch(word, index+1, mismatch, root.children[word[index]])\\n            else:\\n                ret_value = self.recurseSearch(word, index+1, mismatch+1, node)\\n            if ret_value:\\n                return True\\n        return ret_value\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\n    def __str__(self):\\n        return \"TrieNode is = {}\\\\nTrieNode isEnd = {}\".format(self.children.keys(), self.isEnd)\\n\\nclass MagicDictionary(object):\\n\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.TrieRoot = TrieNode()\\n        \\n\\n    def buildDict(self, dict):\\n        \"\"\"\\n        Build a dictionary through a list of words\\n        :type dict: List[str]\\n        :rtype: None\\n        \"\"\"\\n        for word in dict:\\n            root = self.TrieRoot\\n            for letter in word:\\n                if letter not in root.children:\\n                    root.children[letter] = TrieNode()\\n                root = root.children[letter]\\n            root.isEnd = True\\n        \\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if there is any word in the trie that equals to the given word after modifying exactly one character\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        #print(\"searching word = \" + word)\\n        return self.recurseSearch(word, 0, 0, self.TrieRoot)\\n    \\n    def recurseSearch(self,word, index, mismatch, root):\\n       \\n        \\n        if mismatch == 1 and index == len(word) and root.isEnd:\\n            return True\\n        \\n        if mismatch > 1 or index == len(word):\\n            return False\\n        \\n        #recursively search in the trie for all possible values\\n        ret_value = False\\n        for letter,node in root.children.items():\\n            if word[index] == letter:\\n                ret_value = self.recurseSearch(word, index+1, mismatch, root.children[word[index]])\\n            else:\\n                ret_value = self.recurseSearch(word, index+1, mismatch+1, node)\\n            if ret_value:\\n                return True\\n        return ret_value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244199,
                "title": "java-set-solution-beats-100",
                "content": "```\\nclass MagicDictionary {\\n\\n    Set<String> set;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        set = new HashSet();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String word : dict) {\\n            StringBuilder sb = new StringBuilder(word);\\n            for (int i = 0; i < word.length(); ++i) {\\n                char ch = word.charAt(i);\\n                for (char x = \\'a\\'; x <= \\'z\\'; ++x) {\\n                    if (x != ch) {\\n                        sb.setCharAt(i, x);\\n                        set.add(sb.toString());\\n                    }\\n                }\\n                sb.setCharAt(i, ch);\\n            }\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        return set.contains(word);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n\\n    Set<String> set;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        set = new HashSet();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String word : dict) {\\n            StringBuilder sb = new StringBuilder(word);\\n            for (int i = 0; i < word.length(); ++i) {\\n                char ch = word.charAt(i);\\n                for (char x = \\'a\\'; x <= \\'z\\'; ++x) {\\n                    if (x != ch) {\\n                        sb.setCharAt(i, x);\\n                        set.add(sb.toString());\\n                    }\\n                }\\n                sb.setCharAt(i, ch);\\n            }\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        return set.contains(word);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235852,
                "title": "python-efficient-trie-iterative-dfs-beats-100",
                "content": "Trie.search method below solves more general problem: given change_budget, is it possible to change exactly change_budget characters in w, so modified w can be found in dictionary.\\n```\\nclass MagicDictionary:\\n    def __init__(self):\\n        self.trie = self.Trie()\\n\\n    def buildDict(self, words):\\n        for w in words: self.trie.insert(w)\\n\\n    def search(self, w):\\n        if not w: return False\\n        return self.trie.search(w, 1)\\n    \\n    class Trie:\\n        def __init__(self):\\n            self.root = {}\\n            self.END = ()\\n            \\n        def insert(self, w):\\n            p = self.root\\n            \\n            for c in w:\\n                if not c in p:\\n                    p[c] = {}\\n                    \\n                p = p[c]\\n                    \\n            p[self.END] = True # last letter of the word marker\\n            \\n        # change_budget is maximum number of chars that are allowed to be changed\\n        def search(self, w, change_budget): \\n            st = [(self.root, 0, change_budget)]\\n            \\n            while st:\\n                r, i, bgt = st.pop()\\n                if i == len(w):\\n                    if bgt == 0 and self.END in r: return True\\n                    else: continue\\n                \\n                if w[i] in r: st.append((r[w[i]], i + 1, bgt))\\n                if bgt == 0: continue\\n                for c, r2 in r.items():\\n\\t\\t\\t\\t\\t# we can only replace with different letter\\n                    if c == self.END or c == w[i]: continue \\n                    st.append((r2, i + 1, bgt - 1))\\n            \\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary:\\n    def __init__(self):\\n        self.trie = self.Trie()\\n\\n    def buildDict(self, words):\\n        for w in words: self.trie.insert(w)\\n\\n    def search(self, w):\\n        if not w: return False\\n        return self.trie.search(w, 1)\\n    \\n    class Trie:\\n        def __init__(self):\\n            self.root = {}\\n            self.END = ()\\n            \\n        def insert(self, w):\\n            p = self.root\\n            \\n            for c in w:\\n                if not c in p:\\n                    p[c] = {}\\n                    \\n                p = p[c]\\n                    \\n            p[self.END] = True # last letter of the word marker\\n            \\n        # change_budget is maximum number of chars that are allowed to be changed\\n        def search(self, w, change_budget): \\n            st = [(self.root, 0, change_budget)]\\n            \\n            while st:\\n                r, i, bgt = st.pop()\\n                if i == len(w):\\n                    if bgt == 0 and self.END in r: return True\\n                    else: continue\\n                \\n                if w[i] in r: st.append((r[w[i]], i + 1, bgt))\\n                if bgt == 0: continue\\n                for c, r2 in r.items():\\n\\t\\t\\t\\t\\t# we can only replace with different letter\\n                    if c == self.END or c == w[i]: continue \\n                    st.append((r2, i + 1, bgt - 1))\\n            \\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210815,
                "title": "c-trie-dfs-0ms",
                "content": "```\\nstruct trienode {\\n    bool        isword;\\n    unordered_map<char,trienode*> child;\\n    trienode() : isword(false), child(1) {}\\n};\\n\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        root = new trienode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for (auto& s : dict) insert(s);\\n    }\\n    \\n    void insert(string& s) {\\n        trienode* p = root;\\n        for (auto c : s) {\\n            if (!p->child[c]) p->child[c] = new trienode();\\n            p =  p->child[c];\\n        }\\n        p->isword = true;\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        return dfs(0, 0, root, word);\\n    }\\n    \\n    bool dfs(int k, int diff, trienode* p, string& s) {\\n        if (k == s.size()) return p->isword && diff == 1;\\n        \\n        for (auto& v : p->child) {\\n            int val = diff + (v.first==s[k] ? 0 : 1);\\n            if (val > 1)                    continue;\\n            if (dfs(k+1, val, v.second, s)) return true;\\n        }      \\n\\n        return false;\\n    } \\n\\nprivate:\\n    trienode* root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct trienode {\\n    bool        isword;\\n    unordered_map<char,trienode*> child;\\n    trienode() : isword(false), child(1) {}\\n};\\n\\nclass MagicDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    MagicDictionary() {\\n        root = new trienode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    void buildDict(vector<string> dict) {\\n        for (auto& s : dict) insert(s);\\n    }\\n    \\n    void insert(string& s) {\\n        trienode* p = root;\\n        for (auto c : s) {\\n            if (!p->child[c]) p->child[c] = new trienode();\\n            p =  p->child[c];\\n        }\\n        p->isword = true;\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    bool search(string word) {\\n        return dfs(0, 0, root, word);\\n    }\\n    \\n    bool dfs(int k, int diff, trienode* p, string& s) {\\n        if (k == s.size()) return p->isword && diff == 1;\\n        \\n        for (auto& v : p->child) {\\n            int val = diff + (v.first==s[k] ? 0 : 1);\\n            if (val > 1)                    continue;\\n            if (dfs(k+1, val, v.second, s)) return true;\\n        }      \\n\\n        return false;\\n    } \\n\\nprivate:\\n    trienode* root;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159869,
                "title": "efficient-trie-solution-java",
                "content": "```\\nclass MagicDictionary {\\n\\n    /** Initialize your data structure here. */\\n    TrieNode root;\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String word : dict) {\\n            TrieNode temp = root;\\n            int len = word.length();\\n            for (int i = 0; i < len; i++) {\\n                char c = word.charAt(i);\\n                if (temp.children[c-\\'a\\'] == null) temp.children[c-\\'a\\'] = new TrieNode();\\n                temp = temp.children[c-\\'a\\'];\\n            }\\n            temp.isWord = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        TrieNode temp = root;\\n        int len = word.length();\\n        for (int i = 0; i < len; i++) {\\n            char c = word.charAt(i);\\n            for (int j = 0; j < 26; j++) {\\n                if ((char)(j+\\'a\\') == c || temp.children[j] == null) continue;\\n                if (helper(temp.children[j],word,i+1)) return true;\\n            }\\n            if(temp.children[c-\\'a\\'] == null) return false;\\n            temp = temp.children[c-\\'a\\'];\\n        }\\n        return false;\\n    } \\n    \\n    public boolean helper(TrieNode temp, String word, int index) {\\n        int len = word.length();\\n        for (int i = index; i < len; i++) {\\n            char c = word.charAt(i);\\n            if (temp.children[c-\\'a\\'] == null) return false;\\n            temp = temp.children[c-\\'a\\'];\\n        }\\n        return temp.isWord;\\n    }\\n}\\n\\nclass TrieNode {\\n    boolean isWord;\\n    TrieNode[] children;\\n    public TrieNode(){\\n        isWord = false;\\n        children = new TrieNode[26];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n\\n    /** Initialize your data structure here. */\\n    TrieNode root;\\n    public MagicDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String word : dict) {\\n            TrieNode temp = root;\\n            int len = word.length();\\n            for (int i = 0; i < len; i++) {\\n                char c = word.charAt(i);\\n                if (temp.children[c-\\'a\\'] == null) temp.children[c-\\'a\\'] = new TrieNode();\\n                temp = temp.children[c-\\'a\\'];\\n            }\\n            temp.isWord = true;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        TrieNode temp = root;\\n        int len = word.length();\\n        for (int i = 0; i < len; i++) {\\n            char c = word.charAt(i);\\n            for (int j = 0; j < 26; j++) {\\n                if ((char)(j+\\'a\\') == c || temp.children[j] == null) continue;\\n                if (helper(temp.children[j],word,i+1)) return true;\\n            }\\n            if(temp.children[c-\\'a\\'] == null) return false;\\n            temp = temp.children[c-\\'a\\'];\\n        }\\n        return false;\\n    } \\n    \\n    public boolean helper(TrieNode temp, String word, int index) {\\n        int len = word.length();\\n        for (int i = index; i < len; i++) {\\n            char c = word.charAt(i);\\n            if (temp.children[c-\\'a\\'] == null) return false;\\n            temp = temp.children[c-\\'a\\'];\\n        }\\n        return temp.isWord;\\n    }\\n}\\n\\nclass TrieNode {\\n    boolean isWord;\\n    TrieNode[] children;\\n    public TrieNode(){\\n        isWord = false;\\n        children = new TrieNode[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151111,
                "title": "very-easy-java-solution-beats-95-9",
                "content": "```\\nclass MagicDictionary {\\n\\n    /** Initialize your data structure here. */\\n    Map<Integer, List<String>> map;\\n    public MagicDictionary() {\\n        map = new HashMap<>();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String word: dict) {\\n            int len = word.length();\\n            List<String> wordList = new ArrayList<>();\\n            if (map.containsKey(len)) {\\n                wordList = map.get(len);\\n            }\\n            wordList.add(word);\\n            map.put(len, wordList);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        int len = word.length();\\n        List<String> simWords = map.get(len);\\n        if (simWords == null) return false;\\n        for (String w: simWords) {\\n            if (differByOne(w, word)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean differByOne(String s1, String s2) {\\n        int idx = 0;\\n        boolean found = false;\\n        while (idx < s1.length()) {\\n            if (s1.charAt(idx) != s2.charAt(idx)) {\\n                if (found) return false;\\n                found = true;\\n            }\\n            idx++;\\n        }\\n        return found;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dict);\\n * boolean param_2 = obj.search(word);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n\\n    /** Initialize your data structure here. */\\n    Map<Integer, List<String>> map;\\n    public MagicDictionary() {\\n        map = new HashMap<>();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String word: dict) {\\n            int len = word.length();\\n            List<String> wordList = new ArrayList<>();\\n            if (map.containsKey(len)) {\\n                wordList = map.get(len);\\n            }\\n            wordList.add(word);\\n            map.put(len, wordList);\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        int len = word.length();\\n        List<String> simWords = map.get(len);\\n        if (simWords == null) return false;\\n        for (String w: simWords) {\\n            if (differByOne(w, word)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean differByOne(String s1, String s2) {\\n        int idx = 0;\\n        boolean found = false;\\n        while (idx < s1.length()) {\\n            if (s1.charAt(idx) != s2.charAt(idx)) {\\n                if (found) return false;\\n                found = true;\\n            }\\n            idx++;\\n        }\\n        return found;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dict);\\n * boolean param_2 = obj.search(word);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 128507,
                "title": "java-solution-using-trie",
                "content": "Put all words in dictionary into a Trie structure, then store the suffix of each word in every level. Every time you search for a word, just to find all the possible characters with the prefix of the word which have the suffix of the word.\\n```\\nclass MagicDictionary {\\n\\n    /** Initialize your data structure here. */\\n    Trie root;\\n    \\n    public MagicDictionary() {\\n        root = new Trie();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        Trie node = root;\\n        for(String d: dict) {\\n            for(int i = 0;i < d.length();i++) {\\n                char c = d.charAt(i);\\n                if(node.nodes[c - \\'a\\'] == null) node.nodes[c - \\'a\\'] = new Trie();\\n                node = node.nodes[c - \\'a\\'];\\n                node.suffix.add(d.substring(i+1));\\n            }\\n            node.isEnd = true;\\n            node = root;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        Trie node = root;\\n        System.out.println(word + \":\");\\n        for(int i = 0;i < word.length();i++) {\\n            if(node == null) break;\\n            char c = word.charAt(i);\\n            String su = word.substring(i+1);\\n            for(int j = 0;j < 26;j++) {\\n                if(c != (char)(j + \\'a\\') && node.nodes[j] != null) {\\n                    if(node.nodes[j].suffix.contains(su)) return true;\\n                }\\n            }\\n            node = node.nodes[c - \\'a\\'];\\n        }\\n        return false;\\n    }\\n    \\n    class Trie {\\n        Trie[] nodes;\\n        boolean isEnd;\\n        Set<String> suffix;\\n        Trie() {\\n            nodes = new Trie[26];\\n            isEnd = false;\\n            suffix = new HashSet<>();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary {\\n\\n    /** Initialize your data structure here. */\\n    Trie root;\\n    \\n    public MagicDictionary() {\\n        root = new Trie();\\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        Trie node = root;\\n        for(String d: dict) {\\n            for(int i = 0;i < d.length();i++) {\\n                char c = d.charAt(i);\\n                if(node.nodes[c - \\'a\\'] == null) node.nodes[c - \\'a\\'] = new Trie();\\n                node = node.nodes[c - \\'a\\'];\\n                node.suffix.add(d.substring(i+1));\\n            }\\n            node.isEnd = true;\\n            node = root;\\n        }\\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        Trie node = root;\\n        System.out.println(word + \":\");\\n        for(int i = 0;i < word.length();i++) {\\n            if(node == null) break;\\n            char c = word.charAt(i);\\n            String su = word.substring(i+1);\\n            for(int j = 0;j < 26;j++) {\\n                if(c != (char)(j + \\'a\\') && node.nodes[j] != null) {\\n                    if(node.nodes[j].suffix.contains(su)) return true;\\n                }\\n            }\\n            node = node.nodes[c - \\'a\\'];\\n        }\\n        return false;\\n    }\\n    \\n    class Trie {\\n        Trie[] nodes;\\n        boolean isEnd;\\n        Set<String> suffix;\\n        Trie() {\\n            nodes = new Trie[26];\\n            isEnd = false;\\n            suffix = new HashSet<>();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107501,
                "title": "java-hashset-solution-store-all-the-possibilities-while-building-the-dict",
                "content": "\\n    Set<String> memo;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        memo = new HashSet<String>();    \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s: dict) {\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 0; i < s.length(); i++) {\\n                char origin = s.charAt(i);\\n                for (int j = 0; j < 26; j++) {\\n                    if ((char)('a' + j) == origin) continue;\\n                    sb.setCharAt(i, (char)('a' + j));\\n                    memo.add(sb.toString());\\n                }\\n                sb.setCharAt(i, origin);\\n            }\\n        }    \\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        return memo.contains(word);\\n    }",
                "solutionTags": [],
                "code": "\\n    Set<String> memo;\\n    /** Initialize your data structure here. */\\n    public MagicDictionary() {\\n        memo = new HashSet<String>();    \\n    }\\n    \\n    /** Build a dictionary through a list of words */\\n    public void buildDict(String[] dict) {\\n        for (String s: dict) {\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 0; i < s.length(); i++) {\\n                char origin = s.charAt(i);\\n                for (int j = 0; j < 26; j++) {\\n                    if ((char)('a' + j) == origin) continue;\\n                    sb.setCharAt(i, (char)('a' + j));\\n                    memo.add(sb.toString());\\n                }\\n                sb.setCharAt(i, origin);\\n            }\\n        }    \\n    }\\n    \\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\\n    public boolean search(String word) {\\n        return memo.contains(word);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 107468,
                "title": "python-simple-solution",
                "content": "Since the input set is small and the character set is finite, it is acceptable to enumerate through all possible combinations and see if the new word exists in the dictionary and the time complexity for search is O(k^2) where k is the length of the word.\\n\\nFunnily enough, the comment in the skeleton for the `search` method already hints at using a \"trie\" but it's not needed to pass the contest.\\n\\n*- Yangshun*\\n\\n```\\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        self.words = None\\n\\n    def buildDict(self, dict):\\n        self.words = set(dict)\\n\\n    def search(self, word):\\n        chars = set(word)\\n        for index, char in enumerate(word):\\n            for i in range(26):\\n                sub = chr(ord('a') + i)\\n                if sub == char:\\n                    continue\\n                new_word = word[:index] + sub + word[index + 1:]\\n                if new_word in self.words:\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass MagicDictionary(object):\\n\\n    def __init__(self):\\n        self.words = None\\n\\n    def buildDict(self, dict):\\n        self.words = set(dict)\\n\\n    def search(self, word):\\n        chars = set(word)\\n        for index, char in enumerate(word):\\n            for i in range(26):\\n                sub = chr(ord('a') + i)\\n                if sub == char:\\n                    continue\\n                new_word = word[:index] + sub + word[index + 1:]\\n                if new_word in self.words:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101524,
                "title": "java-solution-using-simple-hashmap",
                "content": "# Intuition\\nStore Each word in hashmap and during the search word keep changing the character of each position and keep on checking in map if it exist return true else false \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(length of word X 26 ) as we are changing and iterating for each character of string \\n\\n- Space complexity:\\nO(Dictionary size) or O(N)\\n\\n# Code\\n```\\nclass MagicDictionary {\\n    Map<String,Integer>hm;\\n    public MagicDictionary() {\\n       hm = new HashMap<>(); \\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String st:dictionary){\\n            hm.put(st,1);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        for(int i = 0 ; i < searchWord.length() ; i++ ){\\n            for(int j = 0 ; j < 26 ; j++ ){\\n                if(searchWord.charAt(i)!=(char)(j+(int)\\'a\\')){\\n                    String find = searchWord.substring(0,i)+(char)(j+(int)\\'a\\')+searchWord.substring(i+1);\\n              if(hm.containsKey(find)){\\n                  return true;\\n              }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass MagicDictionary {\\n    Map<String,Integer>hm;\\n    public MagicDictionary() {\\n       hm = new HashMap<>(); \\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for(String st:dictionary){\\n            hm.put(st,1);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        for(int i = 0 ; i < searchWord.length() ; i++ ){\\n            for(int j = 0 ; j < 26 ; j++ ){\\n                if(searchWord.charAt(i)!=(char)(j+(int)\\'a\\')){\\n                    String find = searchWord.substring(0,i)+(char)(j+(int)\\'a\\')+searchWord.substring(i+1);\\n              if(hm.containsKey(find)){\\n                  return true;\\n              }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062230,
                "title": "c-unordered-set",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(t*26*n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(len(dictionary))$$\\n# Code\\n```\\nclass MagicDictionary {\\npublic:\\n    unordered_set<string> s;\\n\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for (string& w : dictionary) s.insert(w);\\n    }\\n    \\n    bool search(string searchWord) {\\n        for (char& c : searchWord) {\\n            for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++ c1) {\\n                if (c == c1) continue;\\n                char tmp = c;\\n                c = c1;\\n                if (s.find(searchWord) != s.end()) return true;\\n                c = tmp;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    unordered_set<string> s;\\n\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for (string& w : dictionary) s.insert(w);\\n    }\\n    \\n    bool search(string searchWord) {\\n        for (char& c : searchWord) {\\n            for (char c1 = \\'a\\'; c1 <= \\'z\\'; ++ c1) {\\n                if (c == c1) continue;\\n                char tmp = c;\\n                c = c1;\\n                if (s.find(searchWord) != s.end()) return true;\\n                c = tmp;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056756,
                "title": "trie-dfs",
                "content": "\\n\\n# Code\\n```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.dic = dict()\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for w in dictionary:\\n            cur = self.dic\\n            for ch in w:\\n                if ch not in cur:\\n                    cur[ch] = {}\\n                cur = cur[ch]\\n            cur[\\'*\\'] = \\'\\'\\n    \\n    def recsearch(self, word, dic, c):\\n        \\n        if len(word) == 0:\\n            return c == 0 and \\'*\\' in dic\\n\\n        if c == 0 and word[0] not in dic:\\n            return False\\n        \\n        cur = dic\\n        for ch in cur:\\n            if ch == word[0]:\\n                ret = self.recsearch(word[1:], cur[ch], c)\\n            else:\\n                ret = self.recsearch(word[1:], cur[ch], c-1)\\n            if ret:\\n                return True\\n        return False\\n\\n\\n    def search(self, searchWord: str) -> bool:\\n        return self.recsearch(searchWord, self.dic, 1)\\n\\n            \\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dictionary)\\n# param_2 = obj.search(searchWord)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.dic = dict()\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for w in dictionary:\\n            cur = self.dic\\n            for ch in w:\\n                if ch not in cur:\\n                    cur[ch] = {}\\n                cur = cur[ch]\\n            cur[\\'*\\'] = \\'\\'\\n    \\n    def recsearch(self, word, dic, c):\\n        \\n        if len(word) == 0:\\n            return c == 0 and \\'*\\' in dic\\n\\n        if c == 0 and word[0] not in dic:\\n            return False\\n        \\n        cur = dic\\n        for ch in cur:\\n            if ch == word[0]:\\n                ret = self.recsearch(word[1:], cur[ch], c)\\n            else:\\n                ret = self.recsearch(word[1:], cur[ch], c-1)\\n            if ret:\\n                return True\\n        return False\\n\\n\\n    def search(self, searchWord: str) -> bool:\\n        return self.recsearch(searchWord, self.dic, 1)\\n\\n            \\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dictionary)\\n# param_2 = obj.search(searchWord)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044817,
                "title": "simple-iteration-65-ms-beats-100",
                "content": "# Approach\\n1. Delete **\\\\_\\\\_init__** function as we don\\'t pass any arguments initializes the object \\n2. Check length of words to avoid unnecessary iterations\\n3. Use **enumerate()** fucntion as it\\'s quicker than **range(len())**\\n4. Track boolean **c** to be sure we change **exactly one character**\\n\\n# Please upvote if you find it usefull\\n\\n```\\nclass MagicDictionary:\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.magic = dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        n = len(searchWord)\\n        for word in self.magic:\\n            if len(word) == n:\\n                c = False\\n                for i, letter in enumerate(word):\\n                    if letter != searchWord[i]:\\n                        if c:\\n                            break\\n                        else:\\n                            c = True\\n                else:\\n                    if c: return True\\n        return False\\n\\n            \\n\\n\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dictionary)\\n# param_2 = obj.search(searchWord)\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass MagicDictionary:\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.magic = dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        n = len(searchWord)\\n        for word in self.magic:\\n            if len(word) == n:\\n                c = False\\n                for i, letter in enumerate(word):\\n                    if letter != searchWord[i]:\\n                        if c:\\n                            break\\n                        else:\\n                            c = True\\n                else:\\n                    if c: return True\\n        return False\\n\\n            \\n\\n\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dictionary)\\n# param_2 = obj.search(searchWord)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016109,
                "title": "c-trie",
                "content": "# Intuition\\nWe need to traverse multiple strings so I thought about creating Trie structue with dictionary strings and traverse them into search method. \\n\\n# Code\\n```\\nstruct Trie{\\n    bool isWordEnd=false;\\n    char val;\\n    unordered_map<char,Trie*> m;\\n    Trie(char v):val{v}{}\\n\\n    void addWordInTrie(int i, string word){\\n        if (i==word.size()) {isWordEnd=true; return;}\\n        if (m.find(word[i])==m.end()){\\n            m[word[i]] = new Trie(word[i]);\\n        }\\n        m[word[i]]->addWordInTrie(i+1,word);\\n    }\\n    bool traverse(int i, string word,int numberOfReplacement){\\n        if (i==word.size() && numberOfReplacement==1 && isWordEnd) return true;\\n        else if (i==word.size() && (numberOfReplacement!=1 || !isWordEnd)) return false;\\n\\n        if (m.find(word[i])!=m.end()) if( m[word[i]]->traverse(i+1,word,numberOfReplacement)) return true;\\n        if (numberOfReplacement==1) return false;\\n        for (auto &entry: m){\\n            if (word[i] != entry.first && entry.second->traverse(i+1,word,1)) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass MagicDictionary {\\n    Trie* root;\\npublic:\\n    MagicDictionary() {\\n        root = new Trie(\\'R\\');\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto& d: dictionary){\\n            root->addWordInTrie(0,d);\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        return root->traverse(0,searchWord,0);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Trie{\\n    bool isWordEnd=false;\\n    char val;\\n    unordered_map<char,Trie*> m;\\n    Trie(char v):val{v}{}\\n\\n    void addWordInTrie(int i, string word){\\n        if (i==word.size()) {isWordEnd=true; return;}\\n        if (m.find(word[i])==m.end()){\\n            m[word[i]] = new Trie(word[i]);\\n        }\\n        m[word[i]]->addWordInTrie(i+1,word);\\n    }\\n    bool traverse(int i, string word,int numberOfReplacement){\\n        if (i==word.size() && numberOfReplacement==1 && isWordEnd) return true;\\n        else if (i==word.size() && (numberOfReplacement!=1 || !isWordEnd)) return false;\\n\\n        if (m.find(word[i])!=m.end()) if( m[word[i]]->traverse(i+1,word,numberOfReplacement)) return true;\\n        if (numberOfReplacement==1) return false;\\n        for (auto &entry: m){\\n            if (word[i] != entry.first && entry.second->traverse(i+1,word,1)) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass MagicDictionary {\\n    Trie* root;\\npublic:\\n    MagicDictionary() {\\n        root = new Trie(\\'R\\');\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto& d: dictionary){\\n            root->addWordInTrie(0,d);\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        return root->traverse(0,searchWord,0);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007234,
                "title": "c-beginner-friendly-easy-set-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MagicDictionary {\\npublic:\\n  set<string>words;\\n    MagicDictionary() {\\n        words.clear();\\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        for(auto it:dict)\\n        words.insert(it);\\n    }\\n    \\n    bool search(string searchWord) {\\n        for(auto it:words)\\n          {\\n            for(int i=0;i<it.size();i++)\\n              {\\n                if(it[i]==searchWord[i])\\n                   continue;\\n               else{\\n                 //not equal\\n                   it[i]=searchWord[i];\\n                   if(it==searchWord)\\n                     return true;\\n                     break;\\n               }    \\n              }\\n          }\\n          return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Simulation"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n  set<string>words;\\n    MagicDictionary() {\\n        words.clear();\\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        for(auto it:dict)\\n        words.insert(it);\\n    }\\n    \\n    bool search(string searchWord) {\\n        for(auto it:words)\\n          {\\n            for(int i=0;i<it.size();i++)\\n              {\\n                if(it[i]==searchWord[i])\\n                   continue;\\n               else{\\n                 //not equal\\n                   it[i]=searchWord[i];\\n                   if(it==searchWord)\\n                     return true;\\n                     break;\\n               }    \\n              }\\n          }\\n          return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007136,
                "title": "java-21ms-99-and-clean-code",
                "content": "# Approach\\n1. Use a List<char[]>[] to store the char arrays for each string on its own size bucket. It\\'s faster to search through char[] than string\\n2. Based on each word dictionary length, add its char[] to the correct bucket\\n3. For the given searchWord, look inside the bucket. If it\\'s empty, return false immediately.\\n4. Else, for each char[] in the bucket try to compare each char at a time against the search word. If one doesn\\'t match, ignore it. If two don\\'t match, break and swap to next word in the bucket.\\n\\n# Complexity\\n- Time complexity:$$O(n*l)$$(l - length of each word with length = searchWord)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$(store each char[] of each dictionary word)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MagicDictionary {\\n    private final List<char[]>[] words;\\n    public MagicDictionary() {\\n        words = new List[101];\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for (String word : dictionary) {\\n            if (words[word.length()] == null) {\\n                words[word.length()] = new ArrayList<>();\\n            }\\n            words[word.length()].add(word.toCharArray());\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        List<char[]> possibleWords = words[searchWord.length()];\\n        if (possibleWords == null) {\\n            return false;\\n        }\\n        char[] chars = searchWord.toCharArray();\\n        boolean swapUsed;\\n        for (char[] word : possibleWords) {\\n            swapUsed = false;\\n            for (int i = 0; i < chars.length; i++) {\\n                if (word[i] != chars[i]) {\\n                    swapUsed = !swapUsed;\\n                    if (!swapUsed) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (swapUsed) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MagicDictionary {\\n    private final List<char[]>[] words;\\n    public MagicDictionary() {\\n        words = new List[101];\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for (String word : dictionary) {\\n            if (words[word.length()] == null) {\\n                words[word.length()] = new ArrayList<>();\\n            }\\n            words[word.length()].add(word.toCharArray());\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        List<char[]> possibleWords = words[searchWord.length()];\\n        if (possibleWords == null) {\\n            return false;\\n        }\\n        char[] chars = searchWord.toCharArray();\\n        boolean swapUsed;\\n        for (char[] word : possibleWords) {\\n            swapUsed = false;\\n            for (int i = 0; i < chars.length; i++) {\\n                if (word[i] != chars[i]) {\\n                    swapUsed = !swapUsed;\\n                    if (!swapUsed) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (swapUsed) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006964,
                "title": "no-trie-dfs-just-map-store-list-of-strings-with-length-key-83-faster-71-memory-effecient",
                "content": "# Intuition\\nLength of String should be same always with chars diff exactly 1\\n\\n# Approach\\n1. create a map with length keys and list<string> values\\n2. for buildDict just add the word into existing/new list<string> for given length\\n3. for search word, just compare each word with all present words of same length in map\\n\\n\\n# Code\\n```\\nclass MagicDictionary {\\npublic:\\n    unordered_map<int,vector<string>> dict;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto d: dictionary){\\n            if(dict.find(d.size())!=dict.end()){\\n                vector<string> v1 = dict[d.size()];\\n                v1.push_back(d);\\n                dict[d.size()]=v1;\\n            }\\n            else{\\n                vector<string> v2;\\n                v2.push_back(d);\\n                dict[d.size()]=v2;\\n            }\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        int n = searchWord.size();\\n        vector<string> sameLength = dict[n];\\n        for(auto s: sameLength){\\n            int diff=0;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]!=searchWord[i]){\\n                    diff++;\\n                }\\n            }\\n            if(diff ==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\n    unordered_map<int,vector<string>> dict;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto d: dictionary){\\n            if(dict.find(d.size())!=dict.end()){\\n                vector<string> v1 = dict[d.size()];\\n                v1.push_back(d);\\n                dict[d.size()]=v1;\\n            }\\n            else{\\n                vector<string> v2;\\n                v2.push_back(d);\\n                dict[d.size()]=v2;\\n            }\\n        }\\n    }\\n    \\n    bool search(string searchWord) {\\n        int n = searchWord.size();\\n        vector<string> sameLength = dict[n];\\n        for(auto s: sameLength){\\n            int diff=0;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]!=searchWord[i]){\\n                    diff++;\\n                }\\n            }\\n            if(diff ==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003814,
                "title": "c-cinch-solution-with-easy-explanations-considering-all-the-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n//simple trie implemenation nothing else,but ek bool varible aur lliye ,jo ye batayega ki ek bar replace kara ya ek se jada bar\\n// suppose trie dict= hello ,str=hello \\n// h matched,e matched l matched l macthed o matched now index==str.size()\\n// so we return isEnd && isReplaceable,or kkuki is reaplceabla=false,kuki koi character reaplace ni huha to false return ho jaga\\n\\n// suppse trie dict= hello ,str=hell size=4\\n// to l tak sab matching ho jagi ,lakin last l kai bad index>=4 but isEnd=false,kuki \\n// dictionary mai hello hai na hell taki after o we get isEnd=true not after l so we simply return false\\n\\n// suppose trie dict =hello ,str=hhllo size=5\\n// h matched ,now e!=h to yaha isReplaceable ko true karo aur baki string match karo,i.e(llo) vo sab match kar jange\\n// now index>=5 and isEnd=true,isRepalce=true so we simply return true\\n\\n// suppse trie dict =heello,str=hhmllo size=5 \\n// h matched ,now e!=h to yaha isReplaceable ko true karo aur baki string match karo,\\n// now l!=m but isReplaceble =true,to hum baki kis aur mai checking karenge,since to hum check karte rahnge loop ki madath se m hai kya hello mai kkahi to nahi mila if else vali condition chlne ki ni in the end,for loop end ho jaga and we simply return res, i.e false\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TrieNode{\\n      public:\\n          TrieNode* children[26];\\n          bool isEnd;\\n\\n          TrieNode(){\\n              memset(children, NULL, sizeof(children));\\n              isEnd = false;\\n          }\\n};\\nclass MagicDictionary {\\npublic:\\n   TrieNode* root;\\n    \\n    MagicDictionary() {\\n        root=new TrieNode();    \\n    }\\n    void insert(string word){\\n        TrieNode* node=root;\\n        for(auto c:word){\\n            if(node->children[c-\\'a\\']==NULL)\\n            node->children[c-\\'a\\']=new TrieNode();\\n\\n            node=node->children[c-\\'a\\'];\\n        }\\n        node->isEnd=true;\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto word:dictionary){\\n            insert(word);\\n        }\\n    }\\n\\n\\n\\n\\n    bool helper(string str,TrieNode* node,int index,bool isReplaceable){\\n        if(index>=str.size())return node->isEnd && isReplaceable;\\n        TrieNode* cur=node;\\n        bool res=false;\\n        int curIndex=str[index]-\\'a\\';\\n        for(int i=0;i<26;i++){\\n            if(cur->children[i]){\\n                if(curIndex==i){\\n                    res=helper(str,cur->children[i],index+1,isReplaceable);\\n                }else if(isReplaceable==false){\\n                    res=helper(str,cur->children[i],index+1,true); //true means humne ek character replace kar diua aur ab baki string match kar rai,ab koi replace ni ho sakta ,kuki sirf ek character replace kar sakte hai\\n                }\\n            }\\n            if(res)return true;\\n        }\\n        return res;\\n    }\\n    bool search(string  str) {\\n        return helper(str,root,0,false);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TrieNode{\\n      public:\\n          TrieNode* children[26];\\n          bool isEnd;\\n\\n          TrieNode(){\\n              memset(children, NULL, sizeof(children));\\n              isEnd = false;\\n          }\\n};\\nclass MagicDictionary {\\npublic:\\n   TrieNode* root;\\n    \\n    MagicDictionary() {\\n        root=new TrieNode();    \\n    }\\n    void insert(string word){\\n        TrieNode* node=root;\\n        for(auto c:word){\\n            if(node->children[c-\\'a\\']==NULL)\\n            node->children[c-\\'a\\']=new TrieNode();\\n\\n            node=node->children[c-\\'a\\'];\\n        }\\n        node->isEnd=true;\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(auto word:dictionary){\\n            insert(word);\\n        }\\n    }\\n\\n\\n\\n\\n    bool helper(string str,TrieNode* node,int index,bool isReplaceable){\\n        if(index>=str.size())return node->isEnd && isReplaceable;\\n        TrieNode* cur=node;\\n        bool res=false;\\n        int curIndex=str[index]-\\'a\\';\\n        for(int i=0;i<26;i++){\\n            if(cur->children[i]){\\n                if(curIndex==i){\\n                    res=helper(str,cur->children[i],index+1,isReplaceable);\\n                }else if(isReplaceable==false){\\n                    res=helper(str,cur->children[i],index+1,true); //true means humne ek character replace kar diua aur ab baki string match kar rai,ab koi replace ni ho sakta ,kuki sirf ek character replace kar sakte hai\\n                }\\n            }\\n            if(res)return true;\\n        }\\n        return res;\\n    }\\n    bool search(string  str) {\\n        return helper(str,root,0,false);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988903,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass MagicDictionary {\\n\\n    String[] dict;\\n    \\n    public MagicDictionary() {\\n\\n    }\\n\\n    public void buildDict(String[] dictionary) {\\n        dict = dictionary;\\n    }\\n\\n    public boolean search(String searchWord) {\\n        boolean exists = true;\\n        for (String s : dict) {\\n            if (s.length() != searchWord.length() || s.equals(searchWord)) {\\n                continue;\\n            }\\n            int ind = 0;\\n            int count = 0;\\n            for (char c : s.toCharArray()) {\\n                if (c != searchWord.charAt(ind++)) {\\n                    count++;\\n                }\\n                if (count > 1) {\\n                    continue;\\n                }\\n            }\\n            if (count == 1) {\\n                return exists;\\n            }            \\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass MagicDictionary {\\n\\n    String[] dict;\\n    \\n    public MagicDictionary() {\\n\\n    }\\n\\n    public void buildDict(String[] dictionary) {\\n        dict = dictionary;\\n    }\\n\\n    public boolean search(String searchWord) {\\n        boolean exists = true;\\n        for (String s : dict) {\\n            if (s.length() != searchWord.length() || s.equals(searchWord)) {\\n                continue;\\n            }\\n            int ind = 0;\\n            int count = 0;\\n            for (char c : s.toCharArray()) {\\n                if (c != searchWord.charAt(ind++)) {\\n                    count++;\\n                }\\n                if (count > 1) {\\n                    continue;\\n                }\\n            }\\n            if (count == 1) {\\n                return exists;\\n            }            \\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962697,
                "title": "easy-c-tries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass node{\\n    public:\\n    vector<node*>child=vector<node*>(26,nullptr);\\n    bool end=false;\\n};\\nclass MagicDictionary {\\npublic:\\n    node* root;\\n    MagicDictionary() {\\n        root=new node();\\n    }\\n    \\n    void buildDict(vector<string> v) {\\n        for(int j=0;j<v.size();j++){\\n            string word=v[j];\\n            node* curr=root;\\n            for(int i=0;i<word.size();i++){\\n                if(!curr->child[word[i]-\\'a\\']){\\n                    curr->child[word[i]-\\'a\\']=new node();\\n                }\\n                curr=curr->child[word[i]-\\'a\\'];\\n            }\\n            curr->end=true;\\n        }\\n    }\\n    // bool solve(string s,int index,node* curr,bool p){\\n    //     if(index==s.size() and curr->end and p) return true;\\n    //     if(index==s.size()) return false;\\n    //     int k=false;\\n    //     for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n    //         if(curr and curr->child[ch-\\'a\\']){\\n    //             if(ch==s[index]) k=(solve(s,index+1,curr->child[ch-\\'a\\'],p) or k);\\n    //             if(!p) k=(solve(s,index+1,curr->child[ch-\\'a\\'],true) or k);\\n    //         }\\n    //     }\\n    //     return k;\\n    // }\\n    bool solve(string s, int index, node* curr, bool p) {\\n        if (index == s.size()) {\\n            return curr && curr->end && p;\\n        }\\n        \\n        char ch = s[index];\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            if (curr && curr->child[c - \\'a\\']) {\\n                if (c == ch) {\\n                    if (solve(s, index + 1, curr->child[c - \\'a\\'], p)) {\\n                        return true;\\n                    }\\n                } else if (!p) {\\n                    if (solve(s, index + 1, curr->child[c - \\'a\\'], true)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool search(string s) {\\n        node* curr=root;\\n        int p=false;\\n        return solve(s,0,curr,p);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass node{\\n    public:\\n    vector<node*>child=vector<node*>(26,nullptr);\\n    bool end=false;\\n};\\nclass MagicDictionary {\\npublic:\\n    node* root;\\n    MagicDictionary() {\\n        root=new node();\\n    }\\n    \\n    void buildDict(vector<string> v) {\\n        for(int j=0;j<v.size();j++){\\n            string word=v[j];\\n            node* curr=root;\\n            for(int i=0;i<word.size();i++){\\n                if(!curr->child[word[i]-\\'a\\']){\\n                    curr->child[word[i]-\\'a\\']=new node();\\n                }\\n                curr=curr->child[word[i]-\\'a\\'];\\n            }\\n            curr->end=true;\\n        }\\n    }\\n    // bool solve(string s,int index,node* curr,bool p){\\n    //     if(index==s.size() and curr->end and p) return true;\\n    //     if(index==s.size()) return false;\\n    //     int k=false;\\n    //     for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n    //         if(curr and curr->child[ch-\\'a\\']){\\n    //             if(ch==s[index]) k=(solve(s,index+1,curr->child[ch-\\'a\\'],p) or k);\\n    //             if(!p) k=(solve(s,index+1,curr->child[ch-\\'a\\'],true) or k);\\n    //         }\\n    //     }\\n    //     return k;\\n    // }\\n    bool solve(string s, int index, node* curr, bool p) {\\n        if (index == s.size()) {\\n            return curr && curr->end && p;\\n        }\\n        \\n        char ch = s[index];\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            if (curr && curr->child[c - \\'a\\']) {\\n                if (c == ch) {\\n                    if (solve(s, index + 1, curr->child[c - \\'a\\'], p)) {\\n                        return true;\\n                    }\\n                } else if (!p) {\\n                    if (solve(s, index + 1, curr->child[c - \\'a\\'], true)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool search(string s) {\\n        node* curr=root;\\n        int p=false;\\n        return solve(s,0,curr,p);\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949503,
                "title": "c-intuitive-simple-beginner-friendly-trie-solution",
                "content": "Intuitive Trie Solution, the insert operation is same as the basic trie insert operation. For searching just replace each character of `searchWord` one-by-one and check whether we are not relacing the original character (since we need to change 1 character).\\n\\n# Time Complexity\\n- Building the Trie: `O(n * m)`, where n is the number of words in the dictionary and m is the average length of words.\\n- Searching for Possible Matches: `O(m * 26) ~ O(m)`, where m is the length of the search word.\\n\\n# Space Complexity\\n- Trie Data Structure: `O(n * m)`, where n is the number of words in the dictionary and m is the average length of words.\\n- Recursive Calls (Call Stack): `O(m)`, where m is the length of the search word.\\n\\n\\n```\\nstruct Node{\\n    Node* links[26];\\n    bool flag=false;\\n\\n    bool containsKey(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    void put(char ch, Node* node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n    bool isEnd(){\\n        return flag;\\n    }\\n};\\n\\nclass MagicDictionary {\\nprivate: \\n    Node* root;\\n\\n    void insert(string word){\\n        Node* node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node->containsKey(word[i])){\\n                node->put(word[i], new Node());\\n            }\\n            node=node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n\\n    bool searchUtil(string word){\\n        Node* node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node->containsKey(word[i])){\\n                return false;\\n            }\\n            node=node->get(word[i]);\\n        }\\n        return node->isEnd();\\n    }\\n\\npublic:\\n    MagicDictionary() {\\n        root=new Node();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(string s:dictionary){\\n            insert(s);\\n        }\\n    }\\n    \\n    bool search(string word) {\\n        int n=word.length();\\n        for(int i=0;i<n;i++){\\n            char original=word[i];\\n            for(int j=0;j<26;j++){\\n                char replacement = \\'a\\' + j;\\n                if(replacement != original){\\n                    word[i] = replacement;\\n                    if(searchUtil(word)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            word[i]=original;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Design",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[26];\\n    bool flag=false;\\n\\n    bool containsKey(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    void put(char ch, Node* node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n    bool isEnd(){\\n        return flag;\\n    }\\n};\\n\\nclass MagicDictionary {\\nprivate: \\n    Node* root;\\n\\n    void insert(string word){\\n        Node* node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node->containsKey(word[i])){\\n                node->put(word[i], new Node());\\n            }\\n            node=node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n\\n    bool searchUtil(string word){\\n        Node* node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node->containsKey(word[i])){\\n                return false;\\n            }\\n            node=node->get(word[i]);\\n        }\\n        return node->isEnd();\\n    }\\n\\npublic:\\n    MagicDictionary() {\\n        root=new Node();\\n    }\\n    \\n    void buildDict(vector<string> dictionary) {\\n        for(string s:dictionary){\\n            insert(s);\\n        }\\n    }\\n    \\n    bool search(string word) {\\n        int n=word.length();\\n        for(int i=0;i<n;i++){\\n            char original=word[i];\\n            for(int j=0;j<26;j++){\\n                char replacement = \\'a\\' + j;\\n                if(replacement != original){\\n                    word[i] = replacement;\\n                    if(searchUtil(word)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            word[i]=original;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929789,
                "title": "c-unordered-set-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MagicDictionary {\\npublic:\\nunordered_set<string> mp;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        for(auto it: dict){\\n            if(!(mp.count(it))){\\n                mp.insert(it);\\n            }\\n        }\\n    }\\n    \\n    bool search(string s) {\\n        for(auto it: mp){\\n            string str=it;\\n            if(str.size()==s.size()){\\n                // cout<<\"STR: \"<<str<<\" s:\"<<s<<endl;\\n                int cnt=0;\\n                int i=0,j=0;\\n                while(i<s.size()){\\n                    // cout<<\"cnt: \"<<cnt<<endl;\\n                    if(str[i]!=s[j]){\\n                        cnt++;\\n                    }\\n                    if(cnt>=2){\\n                        break;\\n                    }\\n                    i++;\\n                    j++;\\n                }\\n                if(cnt==1){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MagicDictionary {\\npublic:\\nunordered_set<string> mp;\\n    MagicDictionary() {\\n        \\n    }\\n    \\n    void buildDict(vector<string> dict) {\\n        for(auto it: dict){\\n            if(!(mp.count(it))){\\n                mp.insert(it);\\n            }\\n        }\\n    }\\n    \\n    bool search(string s) {\\n        for(auto it: mp){\\n            string str=it;\\n            if(str.size()==s.size()){\\n                // cout<<\"STR: \"<<str<<\" s:\"<<s<<endl;\\n                int cnt=0;\\n                int i=0,j=0;\\n                while(i<s.size()){\\n                    // cout<<\"cnt: \"<<cnt<<endl;\\n                    if(str[i]!=s[j]){\\n                        cnt++;\\n                    }\\n                    if(cnt>=2){\\n                        break;\\n                    }\\n                    i++;\\n                    j++;\\n                }\\n                if(cnt==1){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3915900,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass MagicDictionary {\\n\\n    private class Node {\\n        Node[] links;\\n        boolean isEnd;\\n        Node() {\\n            links = new Node[26];\\n            isEnd = false;\\n        }\\n    }\\n    \\n    private Node root;\\n    public MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for (String str : dictionary) {\\n            insert(str);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        return searchUtil(root, searchWord, 0, false);\\n    }\\n    \\n    private void insert(String str) {\\n        Node curr = root;\\n        for (char c : str.toCharArray()) {\\n            int ascii = c - \\'a\\';\\n            if (curr.links[ascii] == null) \\n                curr.links[ascii] = new Node();\\n            curr = curr.links[ascii];\\n        }\\n        curr.isEnd = true;\\n    }\\n    \\n    private boolean searchUtil(Node curr, String str, int i, boolean flag) {\\n        if (i == str.length()) \\n            return (curr.isEnd && i == str.length() && flag);\\n        \\n        boolean ans = false;\\n        int ascii = str.charAt(i) - \\'a\\';\\n        if (!flag) {\\n            for (int ii = 0; ii < 26; ii++) {\\n                if (ii == ascii || curr.links[ii] == null)\\n                    continue;\\n                if (searchUtil(curr.links[ii], str, i + 1, true)) return true;\\n            }\\n        }\\n        if (curr.links[ascii] != null && searchUtil(curr.links[ascii], str, i + 1, flag))\\n            return true;\\n        return false;\\n    }\\n}\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```\\n\\n```c++ []\\nclass Trie{\\n    public:\\n    Trie* child[26];\\n    bool isEnd;\\n    Trie(){\\n        for(int i=0;i<26;i++){\\n            child[i]=NULL;\\n        }\\n        isEnd=false; \\n    }\\n};\\nclass MagicDictionary {\\npublic:\\n    Trie* root=new Trie();\\n    MagicDictionary() {\\n            \\n    }    \\n    \\n    void buildDict(vector<string> dictionary) {\\n        \\n        for(int i=0;i<dictionary.size();i++){\\n            Trie* curr=root;\\n            string temp=dictionary[i];\\n            for(int j=0;j<temp.length();j++){\\n                int idx=temp[j]-97;\\n                if(curr->child[idx]==NULL){\\n                    curr->child[idx]=new Trie();\\n                }\\n                curr=curr->child[idx];\\n            }\\n            curr->isEnd=true;\\n        }\\n        \\n    }\\n    bool check(string searchWord) {\\n        Trie* curr=root;\\n        for(int i=0;i<searchWord.length();i++){\\n            int idx=searchWord[i]-97;\\n            if(curr->child[idx]==NULL){\\n                return false;\\n            }\\n            curr=curr->child[idx];\\n            \\n        }\\n        \\n        return curr->isEnd;\\n\\n    }\\n    \\n  \\n    bool search(string sword) {\\n        int n=sword.size();\\n        string word=sword;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(\\'a\\'+j==sword[i])\\n                    continue;\\n                word[i]=\\'a\\'+j;\\n                if(check(word))\\n                    return true;\\n            }\\n            word[i]=sword[i];\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass MagicDictionary {\\n\\n    private class Node {\\n        Node[] links;\\n        boolean isEnd;\\n        Node() {\\n            links = new Node[26];\\n            isEnd = false;\\n        }\\n    }\\n    \\n    private Node root;\\n    public MagicDictionary() {\\n        root = new Node();\\n    }\\n    \\n    public void buildDict(String[] dictionary) {\\n        for (String str : dictionary) {\\n            insert(str);\\n        }\\n    }\\n    \\n    public boolean search(String searchWord) {\\n        return searchUtil(root, searchWord, 0, false);\\n    }\\n    \\n    private void insert(String str) {\\n        Node curr = root;\\n        for (char c : str.toCharArray()) {\\n            int ascii = c - \\'a\\';\\n            if (curr.links[ascii] == null) \\n                curr.links[ascii] = new Node();\\n            curr = curr.links[ascii];\\n        }\\n        curr.isEnd = true;\\n    }\\n    \\n    private boolean searchUtil(Node curr, String str, int i, boolean flag) {\\n        if (i == str.length()) \\n            return (curr.isEnd && i == str.length() && flag);\\n        \\n        boolean ans = false;\\n        int ascii = str.charAt(i) - \\'a\\';\\n        if (!flag) {\\n            for (int ii = 0; ii < 26; ii++) {\\n                if (ii == ascii || curr.links[ii] == null)\\n                    continue;\\n                if (searchUtil(curr.links[ii], str, i + 1, true)) return true;\\n            }\\n        }\\n        if (curr.links[ascii] != null && searchUtil(curr.links[ascii], str, i + 1, flag))\\n            return true;\\n        return false;\\n    }\\n}\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```\n```c++ []\\nclass Trie{\\n    public:\\n    Trie* child[26];\\n    bool isEnd;\\n    Trie(){\\n        for(int i=0;i<26;i++){\\n            child[i]=NULL;\\n        }\\n        isEnd=false; \\n    }\\n};\\nclass MagicDictionary {\\npublic:\\n    Trie* root=new Trie();\\n    MagicDictionary() {\\n            \\n    }    \\n    \\n    void buildDict(vector<string> dictionary) {\\n        \\n        for(int i=0;i<dictionary.size();i++){\\n            Trie* curr=root;\\n            string temp=dictionary[i];\\n            for(int j=0;j<temp.length();j++){\\n                int idx=temp[j]-97;\\n                if(curr->child[idx]==NULL){\\n                    curr->child[idx]=new Trie();\\n                }\\n                curr=curr->child[idx];\\n            }\\n            curr->isEnd=true;\\n        }\\n        \\n    }\\n    bool check(string searchWord) {\\n        Trie* curr=root;\\n        for(int i=0;i<searchWord.length();i++){\\n            int idx=searchWord[i]-97;\\n            if(curr->child[idx]==NULL){\\n                return false;\\n            }\\n            curr=curr->child[idx];\\n            \\n        }\\n        \\n        return curr->isEnd;\\n\\n    }\\n    \\n  \\n    bool search(string sword) {\\n        int n=sword.size();\\n        string word=sword;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(\\'a\\'+j==sword[i])\\n                    continue;\\n                word[i]=\\'a\\'+j;\\n                if(check(word))\\n                    return true;\\n            }\\n            word[i]=sword[i];\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary* obj = new MagicDictionary();\\n * obj->buildDict(dictionary);\\n * bool param_2 = obj->search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876061,
                "title": "trie-with-slightly-modified-search-algotithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MagicDictionary {\\n\\n    public MagicDictionary() {\\n        \\n    }\\n    \\n     Trie trie;\\n\\n    public void buildDict(String[] dictionary) {\\n        trie = new Trie();\\n        for (int i = 0; i < dictionary.length; i++) {\\n            trie.insert(dictionary[i]);\\n        }\\n    }\\n\\n    public boolean search(String searchWord) {\\n        return trie.search(searchWord);\\n    }\\n\\n    public class Trie {\\n        private Node rootNode = new Node(\\'#\\');\\n\\n        private class Node {\\n            public static final int ALPHABET_SIZE = \\'z\\' - \\'a\\' + 1;\\n            final char c;\\n            Node[] children = new Node[ALPHABET_SIZE];\\n            boolean endOfWord;\\n\\n            private Node(char c) {\\n                this.c = c;\\n            }\\n\\n            public void setEndOfWord(boolean endOfWord) {\\n                this.endOfWord = this.endOfWord || endOfWord;\\n            }\\n\\n            Node findOrInsert(char c, boolean endOfWord) {\\n                Node found = children[c - \\'a\\'];\\n                if (found == null) {\\n                    found = new Node(c);\\n                    children[c - \\'a\\'] = found;\\n                }\\n                found.setEndOfWord(endOfWord);\\n                return found;\\n            }\\n\\n            Node find(char c) {\\n                return children[c - \\'a\\'];\\n            }\\n\\n        }\\n\\n        public void insert(String word) {\\n            Node parent = rootNode;\\n            for (int i = 0; i < word.length(); i++) {\\n                parent = parent.findOrInsert(word.charAt(i), i == word.length() - 1);\\n            }\\n        }\\n\\n        public boolean search(String word) {\\n            return find(word, rootNode, 0, false);\\n        }\\n\\n        boolean find(String search, Node parent, int pos, boolean letterChanged) {\\n            if (pos == search.length()) {\\n                if (!parent.endOfWord) {\\n                    return false;\\n                } else {\\n                    return letterChanged;\\n                }\\n            }\\n            char c = search.charAt(pos);\\n            pos++;\\n            if (!letterChanged) {\\n                for (int i = 0; i < parent.children.length; i++) {\\n                    if (parent.children[i] != null && parent.children[i].c != c) {\\n                        if (find(search, parent.children[i], pos, true)) return true;\\n                    }\\n                }\\n            }\\n            Node child = parent.find(c);\\n            if (child == null) return false;\\n            else return find(search, child, pos, letterChanged);\\n        }\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MagicDictionary {\\n\\n    public MagicDictionary() {\\n        \\n    }\\n    \\n     Trie trie;\\n\\n    public void buildDict(String[] dictionary) {\\n        trie = new Trie();\\n        for (int i = 0; i < dictionary.length; i++) {\\n            trie.insert(dictionary[i]);\\n        }\\n    }\\n\\n    public boolean search(String searchWord) {\\n        return trie.search(searchWord);\\n    }\\n\\n    public class Trie {\\n        private Node rootNode = new Node(\\'#\\');\\n\\n        private class Node {\\n            public static final int ALPHABET_SIZE = \\'z\\' - \\'a\\' + 1;\\n            final char c;\\n            Node[] children = new Node[ALPHABET_SIZE];\\n            boolean endOfWord;\\n\\n            private Node(char c) {\\n                this.c = c;\\n            }\\n\\n            public void setEndOfWord(boolean endOfWord) {\\n                this.endOfWord = this.endOfWord || endOfWord;\\n            }\\n\\n            Node findOrInsert(char c, boolean endOfWord) {\\n                Node found = children[c - \\'a\\'];\\n                if (found == null) {\\n                    found = new Node(c);\\n                    children[c - \\'a\\'] = found;\\n                }\\n                found.setEndOfWord(endOfWord);\\n                return found;\\n            }\\n\\n            Node find(char c) {\\n                return children[c - \\'a\\'];\\n            }\\n\\n        }\\n\\n        public void insert(String word) {\\n            Node parent = rootNode;\\n            for (int i = 0; i < word.length(); i++) {\\n                parent = parent.findOrInsert(word.charAt(i), i == word.length() - 1);\\n            }\\n        }\\n\\n        public boolean search(String word) {\\n            return find(word, rootNode, 0, false);\\n        }\\n\\n        boolean find(String search, Node parent, int pos, boolean letterChanged) {\\n            if (pos == search.length()) {\\n                if (!parent.endOfWord) {\\n                    return false;\\n                } else {\\n                    return letterChanged;\\n                }\\n            }\\n            char c = search.charAt(pos);\\n            pos++;\\n            if (!letterChanged) {\\n                for (int i = 0; i < parent.children.length; i++) {\\n                    if (parent.children[i] != null && parent.children[i].c != c) {\\n                        if (find(search, parent.children[i], pos, true)) return true;\\n                    }\\n                }\\n            }\\n            Node child = parent.find(c);\\n            if (child == null) return false;\\n            else return find(search, child, pos, letterChanged);\\n        }\\n    }\\n}\\n\\n/**\\n * Your MagicDictionary object will be instantiated and called as such:\\n * MagicDictionary obj = new MagicDictionary();\\n * obj.buildDict(dictionary);\\n * boolean param_2 = obj.search(searchWord);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567576,
                "content": [
                    {
                        "username": "vanshaj2000",
                        "content": "Input\\n[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nOutput\\n[null, null, false, true, false, false]"
                    },
                    {
                        "username": "Sammers21",
                        "content": "![0_1517165670012_4daef125-3f53-431c-aa7f-d4868feb315e-image.png](/assets/uploads/files/1517165670759-4daef125-3f53-431c-aa7f-d4868feb315e-image-resized.png) \\n\\nIt seems that test system is not right? I think that \"Expected\" field should not be like that. Because when we have hello in the dictionary we search call with \"hello\" as an argument should return false, not true."
                    },
                    {
                        "username": "thachdo90",
                        "content": "hello can be changed into hallo by changing the \\'e\\' to \\'a\\'\\nif hallo weren\\'t in the dictionary, then I think it would return false"
                    },
                    {
                        "username": "xqcow",
                        "content": "why is everyone using Tries? with 2 arrays the runtime beats 85.39%\\nand space Beats\\n61.32%...  am i oversimplifying this question too much?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You\\'re not oversimplifying. Bruteforce is fine for this problem. Tries will be much better when the size of the dictionary is very large as we can search for words in Tries very efficiently. In an interview it\\'s better to use Tries and state the reason to do so"
                    },
                    {
                        "username": "SomeOneElse123",
                        "content": "We have\\n\\nInput: buildDict([\"hello\", \"leetcode\"]), Output: Null\\nInput: search(\"hhllo\"), Output: True\\nas an example which I can\\'t understand. The rule to change a word is \"modify exactly one character into another character in this word\" as there is no \\'e\\' in hhllo, we can\\'t transform it into \\'hello\\' or \\'leetcode\\', so why should search return True?"
                    },
                    {
                        "username": "doniyorbek7376",
                        "content": "word = \\'hhllo\\'\\nmodify second character (\\'h\\') to \\'e\\' and you get \\'hello\\'"
                    },
                    {
                        "username": "cl0ud_runner",
                        "content": "Please add the Swift support for the question @administrators"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Based on the given set of input (100 words, 100 length) it\\'s faster to use brute force with char[] for each String, bucketed by each dictionary word length.\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[[], [[\"hello\",\"hallo\",\"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nneeds some backtrack  \\'\\' hello\\'\\' & \\'hallo\\' \\'\\'\\n"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class MagicDictionary:\\n\\n    def __init__(self):\\n        self.data = []\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.data = dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in self.data:\\n            if len(i) != len(searchWord):\\n                continue\\n            sanoq = 0\\n            for j in range(len(i)):\\n                if i[j] != searchWord[j]:\\n                    sanoq +=1\\n            if sanoq == 1:\\n                return True\\n        return False\\n\\n"
                    }
                ]
            },
            {
                "id": 1569174,
                "content": [
                    {
                        "username": "vanshaj2000",
                        "content": "Input\\n[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nOutput\\n[null, null, false, true, false, false]"
                    },
                    {
                        "username": "Sammers21",
                        "content": "![0_1517165670012_4daef125-3f53-431c-aa7f-d4868feb315e-image.png](/assets/uploads/files/1517165670759-4daef125-3f53-431c-aa7f-d4868feb315e-image-resized.png) \\n\\nIt seems that test system is not right? I think that \"Expected\" field should not be like that. Because when we have hello in the dictionary we search call with \"hello\" as an argument should return false, not true."
                    },
                    {
                        "username": "thachdo90",
                        "content": "hello can be changed into hallo by changing the \\'e\\' to \\'a\\'\\nif hallo weren\\'t in the dictionary, then I think it would return false"
                    },
                    {
                        "username": "xqcow",
                        "content": "why is everyone using Tries? with 2 arrays the runtime beats 85.39%\\nand space Beats\\n61.32%...  am i oversimplifying this question too much?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You\\'re not oversimplifying. Bruteforce is fine for this problem. Tries will be much better when the size of the dictionary is very large as we can search for words in Tries very efficiently. In an interview it\\'s better to use Tries and state the reason to do so"
                    },
                    {
                        "username": "SomeOneElse123",
                        "content": "We have\\n\\nInput: buildDict([\"hello\", \"leetcode\"]), Output: Null\\nInput: search(\"hhllo\"), Output: True\\nas an example which I can\\'t understand. The rule to change a word is \"modify exactly one character into another character in this word\" as there is no \\'e\\' in hhllo, we can\\'t transform it into \\'hello\\' or \\'leetcode\\', so why should search return True?"
                    },
                    {
                        "username": "doniyorbek7376",
                        "content": "word = \\'hhllo\\'\\nmodify second character (\\'h\\') to \\'e\\' and you get \\'hello\\'"
                    },
                    {
                        "username": "cl0ud_runner",
                        "content": "Please add the Swift support for the question @administrators"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Based on the given set of input (100 words, 100 length) it\\'s faster to use brute force with char[] for each String, bucketed by each dictionary word length.\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[[], [[\"hello\",\"hallo\",\"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nneeds some backtrack  \\'\\' hello\\'\\' & \\'hallo\\' \\'\\'\\n"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class MagicDictionary:\\n\\n    def __init__(self):\\n        self.data = []\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.data = dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in self.data:\\n            if len(i) != len(searchWord):\\n                continue\\n            sanoq = 0\\n            for j in range(len(i)):\\n                if i[j] != searchWord[j]:\\n                    sanoq +=1\\n            if sanoq == 1:\\n                return True\\n        return False\\n\\n"
                    }
                ]
            },
            {
                "id": 1714996,
                "content": [
                    {
                        "username": "vanshaj2000",
                        "content": "Input\\n[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nOutput\\n[null, null, false, true, false, false]"
                    },
                    {
                        "username": "Sammers21",
                        "content": "![0_1517165670012_4daef125-3f53-431c-aa7f-d4868feb315e-image.png](/assets/uploads/files/1517165670759-4daef125-3f53-431c-aa7f-d4868feb315e-image-resized.png) \\n\\nIt seems that test system is not right? I think that \"Expected\" field should not be like that. Because when we have hello in the dictionary we search call with \"hello\" as an argument should return false, not true."
                    },
                    {
                        "username": "thachdo90",
                        "content": "hello can be changed into hallo by changing the \\'e\\' to \\'a\\'\\nif hallo weren\\'t in the dictionary, then I think it would return false"
                    },
                    {
                        "username": "xqcow",
                        "content": "why is everyone using Tries? with 2 arrays the runtime beats 85.39%\\nand space Beats\\n61.32%...  am i oversimplifying this question too much?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You\\'re not oversimplifying. Bruteforce is fine for this problem. Tries will be much better when the size of the dictionary is very large as we can search for words in Tries very efficiently. In an interview it\\'s better to use Tries and state the reason to do so"
                    },
                    {
                        "username": "SomeOneElse123",
                        "content": "We have\\n\\nInput: buildDict([\"hello\", \"leetcode\"]), Output: Null\\nInput: search(\"hhllo\"), Output: True\\nas an example which I can\\'t understand. The rule to change a word is \"modify exactly one character into another character in this word\" as there is no \\'e\\' in hhllo, we can\\'t transform it into \\'hello\\' or \\'leetcode\\', so why should search return True?"
                    },
                    {
                        "username": "doniyorbek7376",
                        "content": "word = \\'hhllo\\'\\nmodify second character (\\'h\\') to \\'e\\' and you get \\'hello\\'"
                    },
                    {
                        "username": "cl0ud_runner",
                        "content": "Please add the Swift support for the question @administrators"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Based on the given set of input (100 words, 100 length) it\\'s faster to use brute force with char[] for each String, bucketed by each dictionary word length.\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[[], [[\"hello\",\"hallo\",\"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nneeds some backtrack  \\'\\' hello\\'\\' & \\'hallo\\' \\'\\'\\n"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class MagicDictionary:\\n\\n    def __init__(self):\\n        self.data = []\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.data = dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in self.data:\\n            if len(i) != len(searchWord):\\n                continue\\n            sanoq = 0\\n            for j in range(len(i)):\\n                if i[j] != searchWord[j]:\\n                    sanoq +=1\\n            if sanoq == 1:\\n                return True\\n        return False\\n\\n"
                    }
                ]
            },
            {
                "id": 1569232,
                "content": [
                    {
                        "username": "vanshaj2000",
                        "content": "Input\\n[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nOutput\\n[null, null, false, true, false, false]"
                    },
                    {
                        "username": "Sammers21",
                        "content": "![0_1517165670012_4daef125-3f53-431c-aa7f-d4868feb315e-image.png](/assets/uploads/files/1517165670759-4daef125-3f53-431c-aa7f-d4868feb315e-image-resized.png) \\n\\nIt seems that test system is not right? I think that \"Expected\" field should not be like that. Because when we have hello in the dictionary we search call with \"hello\" as an argument should return false, not true."
                    },
                    {
                        "username": "thachdo90",
                        "content": "hello can be changed into hallo by changing the \\'e\\' to \\'a\\'\\nif hallo weren\\'t in the dictionary, then I think it would return false"
                    },
                    {
                        "username": "xqcow",
                        "content": "why is everyone using Tries? with 2 arrays the runtime beats 85.39%\\nand space Beats\\n61.32%...  am i oversimplifying this question too much?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You\\'re not oversimplifying. Bruteforce is fine for this problem. Tries will be much better when the size of the dictionary is very large as we can search for words in Tries very efficiently. In an interview it\\'s better to use Tries and state the reason to do so"
                    },
                    {
                        "username": "SomeOneElse123",
                        "content": "We have\\n\\nInput: buildDict([\"hello\", \"leetcode\"]), Output: Null\\nInput: search(\"hhllo\"), Output: True\\nas an example which I can\\'t understand. The rule to change a word is \"modify exactly one character into another character in this word\" as there is no \\'e\\' in hhllo, we can\\'t transform it into \\'hello\\' or \\'leetcode\\', so why should search return True?"
                    },
                    {
                        "username": "doniyorbek7376",
                        "content": "word = \\'hhllo\\'\\nmodify second character (\\'h\\') to \\'e\\' and you get \\'hello\\'"
                    },
                    {
                        "username": "cl0ud_runner",
                        "content": "Please add the Swift support for the question @administrators"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Based on the given set of input (100 words, 100 length) it\\'s faster to use brute force with char[] for each String, bucketed by each dictionary word length.\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[[], [[\"hello\",\"hallo\",\"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nneeds some backtrack  \\'\\' hello\\'\\' & \\'hallo\\' \\'\\'\\n"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class MagicDictionary:\\n\\n    def __init__(self):\\n        self.data = []\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.data = dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in self.data:\\n            if len(i) != len(searchWord):\\n                continue\\n            sanoq = 0\\n            for j in range(len(i)):\\n                if i[j] != searchWord[j]:\\n                    sanoq +=1\\n            if sanoq == 1:\\n                return True\\n        return False\\n\\n"
                    }
                ]
            },
            {
                "id": 1571803,
                "content": [
                    {
                        "username": "vanshaj2000",
                        "content": "Input\\n[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nOutput\\n[null, null, false, true, false, false]"
                    },
                    {
                        "username": "Sammers21",
                        "content": "![0_1517165670012_4daef125-3f53-431c-aa7f-d4868feb315e-image.png](/assets/uploads/files/1517165670759-4daef125-3f53-431c-aa7f-d4868feb315e-image-resized.png) \\n\\nIt seems that test system is not right? I think that \"Expected\" field should not be like that. Because when we have hello in the dictionary we search call with \"hello\" as an argument should return false, not true."
                    },
                    {
                        "username": "thachdo90",
                        "content": "hello can be changed into hallo by changing the \\'e\\' to \\'a\\'\\nif hallo weren\\'t in the dictionary, then I think it would return false"
                    },
                    {
                        "username": "xqcow",
                        "content": "why is everyone using Tries? with 2 arrays the runtime beats 85.39%\\nand space Beats\\n61.32%...  am i oversimplifying this question too much?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You\\'re not oversimplifying. Bruteforce is fine for this problem. Tries will be much better when the size of the dictionary is very large as we can search for words in Tries very efficiently. In an interview it\\'s better to use Tries and state the reason to do so"
                    },
                    {
                        "username": "SomeOneElse123",
                        "content": "We have\\n\\nInput: buildDict([\"hello\", \"leetcode\"]), Output: Null\\nInput: search(\"hhllo\"), Output: True\\nas an example which I can\\'t understand. The rule to change a word is \"modify exactly one character into another character in this word\" as there is no \\'e\\' in hhllo, we can\\'t transform it into \\'hello\\' or \\'leetcode\\', so why should search return True?"
                    },
                    {
                        "username": "doniyorbek7376",
                        "content": "word = \\'hhllo\\'\\nmodify second character (\\'h\\') to \\'e\\' and you get \\'hello\\'"
                    },
                    {
                        "username": "cl0ud_runner",
                        "content": "Please add the Swift support for the question @administrators"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Based on the given set of input (100 words, 100 length) it\\'s faster to use brute force with char[] for each String, bucketed by each dictionary word length.\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[[], [[\"hello\",\"hallo\",\"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nneeds some backtrack  \\'\\' hello\\'\\' & \\'hallo\\' \\'\\'\\n"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class MagicDictionary:\\n\\n    def __init__(self):\\n        self.data = []\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.data = dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in self.data:\\n            if len(i) != len(searchWord):\\n                continue\\n            sanoq = 0\\n            for j in range(len(i)):\\n                if i[j] != searchWord[j]:\\n                    sanoq +=1\\n            if sanoq == 1:\\n                return True\\n        return False\\n\\n"
                    }
                ]
            },
            {
                "id": 2045639,
                "content": [
                    {
                        "username": "vanshaj2000",
                        "content": "Input\\n[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nOutput\\n[null, null, false, true, false, false]"
                    },
                    {
                        "username": "Sammers21",
                        "content": "![0_1517165670012_4daef125-3f53-431c-aa7f-d4868feb315e-image.png](/assets/uploads/files/1517165670759-4daef125-3f53-431c-aa7f-d4868feb315e-image-resized.png) \\n\\nIt seems that test system is not right? I think that \"Expected\" field should not be like that. Because when we have hello in the dictionary we search call with \"hello\" as an argument should return false, not true."
                    },
                    {
                        "username": "thachdo90",
                        "content": "hello can be changed into hallo by changing the \\'e\\' to \\'a\\'\\nif hallo weren\\'t in the dictionary, then I think it would return false"
                    },
                    {
                        "username": "xqcow",
                        "content": "why is everyone using Tries? with 2 arrays the runtime beats 85.39%\\nand space Beats\\n61.32%...  am i oversimplifying this question too much?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You\\'re not oversimplifying. Bruteforce is fine for this problem. Tries will be much better when the size of the dictionary is very large as we can search for words in Tries very efficiently. In an interview it\\'s better to use Tries and state the reason to do so"
                    },
                    {
                        "username": "SomeOneElse123",
                        "content": "We have\\n\\nInput: buildDict([\"hello\", \"leetcode\"]), Output: Null\\nInput: search(\"hhllo\"), Output: True\\nas an example which I can\\'t understand. The rule to change a word is \"modify exactly one character into another character in this word\" as there is no \\'e\\' in hhllo, we can\\'t transform it into \\'hello\\' or \\'leetcode\\', so why should search return True?"
                    },
                    {
                        "username": "doniyorbek7376",
                        "content": "word = \\'hhllo\\'\\nmodify second character (\\'h\\') to \\'e\\' and you get \\'hello\\'"
                    },
                    {
                        "username": "cl0ud_runner",
                        "content": "Please add the Swift support for the question @administrators"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Based on the given set of input (100 words, 100 length) it\\'s faster to use brute force with char[] for each String, bucketed by each dictionary word length.\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[[], [[\"hello\",\"hallo\",\"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nneeds some backtrack  \\'\\' hello\\'\\' & \\'hallo\\' \\'\\'\\n"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class MagicDictionary:\\n\\n    def __init__(self):\\n        self.data = []\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.data = dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in self.data:\\n            if len(i) != len(searchWord):\\n                continue\\n            sanoq = 0\\n            for j in range(len(i)):\\n                if i[j] != searchWord[j]:\\n                    sanoq +=1\\n            if sanoq == 1:\\n                return True\\n        return False\\n\\n"
                    }
                ]
            },
            {
                "id": 2029919,
                "content": [
                    {
                        "username": "vanshaj2000",
                        "content": "Input\\n[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nOutput\\n[null, null, false, true, false, false]"
                    },
                    {
                        "username": "Sammers21",
                        "content": "![0_1517165670012_4daef125-3f53-431c-aa7f-d4868feb315e-image.png](/assets/uploads/files/1517165670759-4daef125-3f53-431c-aa7f-d4868feb315e-image-resized.png) \\n\\nIt seems that test system is not right? I think that \"Expected\" field should not be like that. Because when we have hello in the dictionary we search call with \"hello\" as an argument should return false, not true."
                    },
                    {
                        "username": "thachdo90",
                        "content": "hello can be changed into hallo by changing the \\'e\\' to \\'a\\'\\nif hallo weren\\'t in the dictionary, then I think it would return false"
                    },
                    {
                        "username": "xqcow",
                        "content": "why is everyone using Tries? with 2 arrays the runtime beats 85.39%\\nand space Beats\\n61.32%...  am i oversimplifying this question too much?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You\\'re not oversimplifying. Bruteforce is fine for this problem. Tries will be much better when the size of the dictionary is very large as we can search for words in Tries very efficiently. In an interview it\\'s better to use Tries and state the reason to do so"
                    },
                    {
                        "username": "SomeOneElse123",
                        "content": "We have\\n\\nInput: buildDict([\"hello\", \"leetcode\"]), Output: Null\\nInput: search(\"hhllo\"), Output: True\\nas an example which I can\\'t understand. The rule to change a word is \"modify exactly one character into another character in this word\" as there is no \\'e\\' in hhllo, we can\\'t transform it into \\'hello\\' or \\'leetcode\\', so why should search return True?"
                    },
                    {
                        "username": "doniyorbek7376",
                        "content": "word = \\'hhllo\\'\\nmodify second character (\\'h\\') to \\'e\\' and you get \\'hello\\'"
                    },
                    {
                        "username": "cl0ud_runner",
                        "content": "Please add the Swift support for the question @administrators"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Based on the given set of input (100 words, 100 length) it\\'s faster to use brute force with char[] for each String, bucketed by each dictionary word length.\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[[], [[\"hello\",\"hallo\",\"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nneeds some backtrack  \\'\\' hello\\'\\' & \\'hallo\\' \\'\\'\\n"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class MagicDictionary:\\n\\n    def __init__(self):\\n        self.data = []\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.data = dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in self.data:\\n            if len(i) != len(searchWord):\\n                continue\\n            sanoq = 0\\n            for j in range(len(i)):\\n                if i[j] != searchWord[j]:\\n                    sanoq +=1\\n            if sanoq == 1:\\n                return True\\n        return False\\n\\n"
                    }
                ]
            },
            {
                "id": 1794231,
                "content": [
                    {
                        "username": "vanshaj2000",
                        "content": "Input\\n[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nOutput\\n[null, null, false, true, false, false]"
                    },
                    {
                        "username": "Sammers21",
                        "content": "![0_1517165670012_4daef125-3f53-431c-aa7f-d4868feb315e-image.png](/assets/uploads/files/1517165670759-4daef125-3f53-431c-aa7f-d4868feb315e-image-resized.png) \\n\\nIt seems that test system is not right? I think that \"Expected\" field should not be like that. Because when we have hello in the dictionary we search call with \"hello\" as an argument should return false, not true."
                    },
                    {
                        "username": "thachdo90",
                        "content": "hello can be changed into hallo by changing the \\'e\\' to \\'a\\'\\nif hallo weren\\'t in the dictionary, then I think it would return false"
                    },
                    {
                        "username": "xqcow",
                        "content": "why is everyone using Tries? with 2 arrays the runtime beats 85.39%\\nand space Beats\\n61.32%...  am i oversimplifying this question too much?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You\\'re not oversimplifying. Bruteforce is fine for this problem. Tries will be much better when the size of the dictionary is very large as we can search for words in Tries very efficiently. In an interview it\\'s better to use Tries and state the reason to do so"
                    },
                    {
                        "username": "SomeOneElse123",
                        "content": "We have\\n\\nInput: buildDict([\"hello\", \"leetcode\"]), Output: Null\\nInput: search(\"hhllo\"), Output: True\\nas an example which I can\\'t understand. The rule to change a word is \"modify exactly one character into another character in this word\" as there is no \\'e\\' in hhllo, we can\\'t transform it into \\'hello\\' or \\'leetcode\\', so why should search return True?"
                    },
                    {
                        "username": "doniyorbek7376",
                        "content": "word = \\'hhllo\\'\\nmodify second character (\\'h\\') to \\'e\\' and you get \\'hello\\'"
                    },
                    {
                        "username": "cl0ud_runner",
                        "content": "Please add the Swift support for the question @administrators"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Based on the given set of input (100 words, 100 length) it\\'s faster to use brute force with char[] for each String, bucketed by each dictionary word length.\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[[], [[\"hello\",\"hallo\",\"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\\nneeds some backtrack  \\'\\' hello\\'\\' & \\'hallo\\' \\'\\'\\n"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class MagicDictionary:\\n\\n    def __init__(self):\\n        self.data = []\\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        self.data = dictionary\\n\\n    def search(self, searchWord: str) -> bool:\\n        for i in self.data:\\n            if len(i) != len(searchWord):\\n                continue\\n            sanoq = 0\\n            for j in range(len(i)):\\n                if i[j] != searchWord[j]:\\n                    sanoq +=1\\n            if sanoq == 1:\\n                return True\\n        return False\\n\\n"
                    }
                ]
            }
        ]
    }
]