[
    {
        "title": "Find the Score of All Prefixes of an Array",
        "question_content": "We define the conversion array conver of an array arr as follows:\n\n\tconver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.\n\nWe also define the score of an array arr as the sum of the values of the conversion array of arr.\nGiven a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,7,5,10]\nOutput: [4,10,24,36,56]\nExplanation: \nFor the prefix [2], the conversion array is [4] hence the score is 4\nFor the prefix [2, 3], the conversion array is [4, 6] hence the score is 10\nFor the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24\nFor the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36\nFor the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56\n\nExample 2:\n\nInput: nums = [1,1,2,4,8,16]\nOutput: [2,4,8,16,32,64]\nExplanation: \nFor the prefix [1], the conversion array is [2] hence the score is 2\nFor the prefix [1, 1], the conversion array is [2, 2] hence the score is 4\nFor the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8\nFor the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16\nFor the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32\nFor the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 3420109,
                "title": "c-python3-prefix-sum",
                "content": "\\n# Intuition\\nFirst find `conver` array and then find its prefix sum\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python3**:\\n```\\ndef findPrefixScore(self, nums: List[int]) -> List[int]:\\n    m, conver = 0, []\\n    for x in nums:\\n        m = max(m, x)\\n        conver.append(x + m)\\n    return accumulate(conver)\\n```\\n1 liner credits [@SunnyvaleCA](https://leetcode.com/SunnyvaleCA/):\\n```\\ndef findPrefixScore(self, A):\\n    return accumulate(n+maxN for n,maxN in zip(A, accumulate(A,max)))\\n\\n```\\n\\n**C++**:\\n```\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n      vector<long long> pre;\\n      long long m = 0, s = 0;\\n      for(int x : nums) {\\n          m = max(m, (long long)x);\\n          s += x + m;\\n          pre.push_back(s);\\n      }\\n      return pre;\\n  }",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\ndef findPrefixScore(self, nums: List[int]) -> List[int]:\\n    m, conver = 0, []\\n    for x in nums:\\n        m = max(m, x)\\n        conver.append(x + m)\\n    return accumulate(conver)\\n```\n```\\ndef findPrefixScore(self, A):\\n    return accumulate(n+maxN for n,maxN in zip(A, accumulate(A,max)))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420907,
                "title": "c-easiest-approach-easy-to-understand-simple-logic-with-comments",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nO(n)\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nO(n)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\r\\n        vector<long long> b;  \\r\\n        vector<long long> ans;\\r\\n        int n = nums.size();\\r\\n        int mm= INT_MIN;\\r\\n        long long aa = 0;\\r\\n        for(int  i = 0 ; i < n; i++){        //0, 1...\\r\\n            long long a  = 0;\\r\\n            mm = max(mm, nums[i]);        // 2 , 3...\\r\\n            a = nums[i] + mm;             //2+2 = 4, 3+3  = 6, ..\\r\\n            b.push_back(a);               // b=[4,6,]...\\r\\n            aa += b[i];                   //0+4 = 4, 4+6 = 10,...  \\r\\n            ans.push_back(aa);            //ans = [4,10,...]\\r\\n        }\\r\\n        return ans;                      \\r\\n    }\\r\\n};\\r\\n\\r\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\r\\npublic:\\r\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\r\\n        vector<long long> b;  \\r\\n        vector<long long> ans;\\r\\n        int n = nums.size();\\r\\n        int mm= INT_MIN;\\r\\n        long long aa = 0;\\r\\n        for(int  i = 0 ; i < n; i++){        //0, 1...\\r\\n            long long a  = 0;\\r\\n            mm = max(mm, nums[i]);        // 2 , 3...\\r\\n            a = nums[i] + mm;             //2+2 = 4, 3+3  = 6, ..\\r\\n            b.push_back(a);               // b=[4,6,]...\\r\\n            aa += b[i];                   //0+4 = 4, 4+6 = 10,...  \\r\\n            ans.push_back(aa);            //ans = [4,10,...]\\r\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3420302,
                "title": "prefix-sum-very-simple-easy-to-understand-solution",
                "content": "<b> Please Up Vote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum = 0, mx = 0;\\n        for(auto n: nums){\\n            if(mx < n) mx = n;\\n            sum += n + mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum = 0, mx = 0;\\n        for(auto n: nums){\\n            if(mx < n) mx = n;\\n            sum += n + mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420254,
                "title": "c-prefix-sum-easy-to-understand-superfast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use the prefix sum approach to make a `conver` vector and then `ans` vector by applying prefix sum approach on `conver` message.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Store `2*nums[0]` in `conver[0]`.\\n- Then run a loop and assign `conver[i] = nums[i] +0ll+ mx`, where `mx` is variable having the maximum running number.\\n- Then, at last simply make a prefix sum array `ans` of `conver` vector and return it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        vector<long long> conver(n);\\n        conver[0] = 2*nums[0];\\n        int mx = nums[0];\\n        for(int i=1; i<n; i++){\\n            mx = max(mx, nums[i]);\\n            conver[i] = nums[i] +0ll+ mx;\\n        }\\n        ans[0]=conver[0];\\n        for(int i=1; i<n; i++){\\n            ans[i] = ans[i-1] + 0ll+conver[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n//  PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        vector<long long> conver(n);\\n        conver[0] = 2*nums[0];\\n        int mx = nums[0];\\n        for(int i=1; i<n; i++){\\n            mx = max(mx, nums[i]);\\n            conver[i] = nums[i] +0ll+ mx;\\n        }\\n        ans[0]=conver[0];\\n        for(int i=1; i<n; i++){\\n            ans[i] = ans[i-1] + 0ll+conver[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n//  PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420062,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420024,
                "title": "java-python-3-1-pass-codes",
                "content": "\\n\\n```java\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] score = new long[n + 1];\\n        for (int i = 0, max = 0; i < n; ++i) {\\n            max = Math.max(max, nums[i]);\\n            score[i + 1] += score[i] + max + nums[i];\\n        }\\n        return Arrays.copyOfRange(score, 1, n + 1);        \\n    }\\n```\\n```python\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        score, mx = [0], 0\\n        for num in nums:\\n            mx = max(mx, num)\\n            score.append(score[-1] + num + mx)\\n        return score[1 :]\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] score = new long[n + 1];\\n        for (int i = 0, max = 0; i < n; ++i) {\\n            max = Math.max(max, nums[i]);\\n            score[i + 1] += score[i] + max + nums[i];\\n        }\\n        return Arrays.copyOfRange(score, 1, n + 1);        \\n    }\\n```\n```python\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        score, mx = [0], 0\\n        for num in nums:\\n            mx = max(mx, num)\\n            score.append(score[-1] + num + mx)\\n        return score[1 :]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3419972,
                "title": "c-java-python-intuition-with-explanation-simple-prefix-sum-time-o-n",
                "content": "# Intuition\\n$conver[i] = nums[i] + \\\\displaystyle\\\\max_{0 \\\\le j \\\\le i} (nums[j])$\\n$score(nums) = \\\\sum conver(nums)$\\n\\n$ans[i] = score(nums[0...i])$\\n$ans[i] = \\\\sum conver(nums[0...i])$\\n\\n$ans[i]$ is the the prefix sum of $conver[i]$\\n\\n$ans[i] = \\\\left(\\\\displaystyle\\\\sum conver(nums[0...i-1])\\\\right) + conver[i]$\\n$ans[i] = ans[i - 1] + conver[i]$\\n$ans[i] = ans[i - 1] + nums[i] + \\\\displaystyle\\\\max_{0 \\\\le j \\\\le i} (nums[j])$\\n\\n# Approach\\nMaintain $maximum$ value till current index.\\n$ans[i] = ans[i - 1] + nums[i] + maximum$\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(), maximum = nums[0];\\n        vector<long long> result(n);\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, maximum = nums[0];\\n        long[] result = new long[n];\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = Math.max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        result = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            result.append(result[i - 1] + nums[i] + maximum)\\n        return result\\n```\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(), maximum = nums[0];\\n        vector<long long> result(n);\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, maximum = nums[0];\\n        long[] result = new long[n];\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = Math.max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        result = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            result.append(result[i - 1] + nums[i] + maximum)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420214,
                "title": "explained-simple-and-clear-python-code",
                "content": "# Intuition\\nTo calculate the score of each prefix of the input array nums, we need to calculate the conversion array conver for each prefix, and then sum up the elements of the conversion array to get the prefix score. To calculate the conver array for each prefix, we need to find the maximum value of the input array up to that index, and then add it to each element of the prefix.\\n\\n\\n# Approach\\n1. Initialize an array ans of length n with all elements initialized to 0.\\n2. Initialize a variable max_val to negative infinity.\\n3. Loop through the input array nums:\\na. Update the max_val variable to the maximum value seen so far.\\nb. Calculate the conversion value conver for the current index by adding the current element of the input array to the max_val.\\nc. Update the corresponding element of the ans array with the conver value.\\n4. Initialize an array res of length n with all elements initialized to 0.\\n5. Initialize a variable s to 0.\\n6. Loop through the ans array:\\na. Add the current element to the s variable.\\nb. Update the corresponding element of the res array with the current value of s.\\n7. Return the res array.\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input array nums. We need to loop through the array twice, once to calculate the ans array and once to calculate the res array, both of which take O(n) time.\\n- Space complexity:\\nO(n), we need to use two arrays of length n, ans and res, which take O(n) space in total. Additionally, we use a few constant variables, which take O(1) space.\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420127,
                "title": "clean-and-simple-solution-using-heap-100-faster",
                "content": "```class Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        heap = [-nums[0]]\\n        result = []\\n        runningSum = 0\\n        for num in nums:\\n            maxSum = max(num, -1 * heapq.heappop(heap))\\n            result.append(runningSum + num + maxSum)\\n            runningSum += maxSum+num\\n            heappush(heap,- maxSum)\\n        return result\\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        heap = [-nums[0]]\\n        result = []\\n        runningSum = 0\\n        for num in nums:\\n            maxSum = max(num, -1 * heapq.heappop(heap))\\n            result.append(runningSum + num + maxSum)\\n            runningSum += maxSum+num\\n            heappush(heap,- maxSum)\\n        return result\\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3420054,
                "title": "short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            max = Math.max(max,nums[i]);\\n            res[i] = nums[i] + max + (i==0 ? 0 : res[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            max = Math.max(max,nums[i]);\\n            res[i] = nums[i] + max + (i==0 ? 0 : res[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420279,
                "title": "c-o-n-prefix-sum-clean-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n,-1);\\n        long long l=nums[0];\\n        //calculating the conver[i]\\n        for(int i=0;i<n;++i){\\n            if(l<nums[i])l = nums[i];\\n            ans[i]=nums[i]+l;\\n        }\\n        //taking the prefix sum\\n        for(int i=1;i<n;++i)ans[i]+=ans[i-1];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n,-1);\\n        long long l=nums[0];\\n        //calculating the conver[i]\\n        for(int i=0;i<n;++i){\\n            if(l<nums[i])l = nums[i];\\n            ans[i]=nums[i]+l;\\n        }\\n        //taking the prefix sum\\n        for(int i=1;i<n;++i)ans[i]+=ans[i-1];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420129,
                "title": "cpp-prefix-sum",
                "content": "```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        vector<ll> ans;\\n        ll mx = 0LL, s = 0LL;\\n        for(int x : v) {\\n            mx = max(mx,(ll)x);\\n            s += (x + mx);\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        vector<ll> ans;\\n        ll mx = 0LL, s = 0LL;\\n        for(int x : v) {\\n            mx = max(mx,(ll)x);\\n            s += (x + mx);\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421148,
                "title": "c-easy-prefix-sum",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& a) {\\n        vector<long long>v;\\n        v.push_back(a[0]+a[0]);\\n        long long mx=a[0];\\n        for(int i=1;i<a.size();i++){\\n            long long an=a[i];\\n            if(mx<a[i])mx=a[i];\\n            an+=mx;\\n            long long h=v[i-1]+an;\\n            v.push_back(h);\\n        }\\n        return v;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/fcf80d18-7665-46c4-a0fb-5038ce657498_1681589962.770271.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& a) {\\n        vector<long long>v;\\n        v.push_back(a[0]+a[0]);\\n        long long mx=a[0];\\n        for(int i=1;i<a.size();i++){\\n            long long an=a[i];\\n            if(mx<a[i])mx=a[i];\\n            an+=mx;\\n            long long h=v[i-1]+an;\\n            v.push_back(h);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420130,
                "title": "simple-prefix-sum",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        max_, sum_ = 0, 0\\n        res = []\\n        for num in nums:\\n            max_ = max(max_, num)\\n            res.append(num + max_)\\n        last = 0\\n        for i, val in enumerate(res):\\n            res[i] += last\\n            last += val\\n        return res\\n```\\nUpVote, if you like it **:)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        max_, sum_ = 0, 0\\n        res = []\\n        for num in nums:\\n            max_ = max(max_, num)\\n            res.append(num + max_)\\n        last = 0\\n        for i, val in enumerate(res):\\n            res[i] += last\\n            last += val\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554506,
                "title": "c-time-o-n-space-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> v(n,0);\\n        v[0] += nums[0]*2;\\n        long long mx = nums[0];\\n        for(int i = 1; i < n; i++){\\n            mx = max(nums[i]*1LL,mx);\\n            v[i] = mx+nums[i];\\n            v[i] += v[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> v(n,0);\\n        v[0] += nums[0]*2;\\n        long long mx = nums[0];\\n        for(int i = 1; i < n; i++){\\n            mx = max(nums[i]*1LL,mx);\\n            v[i] = mx+nums[i];\\n            v[i] += v[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438048,
                "title": "short-and-crisp-beginner-friendly-one-pass-o-n-time-complexity",
                "content": "\\n\\n# Approach\\nJust keep track of maximum element before i+1 index and to take on prefix array to store values at same time.\\n\\n# Complexity\\n- Time complexity:\\no(n);\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n =  nums.size();\\n        vector<long long > ans(n,0);//prefix Array to return\\n        int maxi =  nums[0];\\n        ans[0] = 2*nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            maxi = max(maxi,nums[i]); //track of maxi before i+1 index\\n            nums[i]+=maxi; \\n            ans[i]+=ans[i-1]+nums[i];//Making prefix array to return\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n =  nums.size();\\n        vector<long long > ans(n,0);//prefix Array to return\\n        int maxi =  nums[0];\\n        ans[0] = 2*nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            maxi = max(maxi,nums[i]); //track of maxi before i+1 index\\n            nums[i]+=maxi; \\n            ans[i]+=ans[i-1]+nums[i];//Making prefix array to return\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423547,
                "title": "c-easiest-approach-prefix-sum-beginner-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use Prefix-Sum method here to find maximum element till every i\\'th index.\\nThen we will add out prefix_max at i\\'th position to our original vector at i\\'th position.\\nAt last we will take sum upto every i\\'th index and push it into our answer vector.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        \\n        vector<long long> prefix_max;\\n        int max_current=nums[0];\\n        prefix_max.push_back(max_current);\\n        for(int i=1;i<n;i++)\\n        {\\n            max_current=max(max_current,nums[i]);\\n            prefix_max.push_back(max_current);\\n        }\\n        \\n        vector<long long> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]+=prefix_max[i];\\n        }\\n        \\n        long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n![2ddedd60-39d6-4167-9b77-88e10400f044_1673586388.8794823.jpeg](https://assets.leetcode.com/users/images/ca1f0d37-8838-454f-b4e8-dc22323e3ed3_1681647899.5235333.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        \\n        vector<long long> prefix_max;\\n        int max_current=nums[0];\\n        prefix_max.push_back(max_current);\\n        for(int i=1;i<n;i++)\\n        {\\n            max_current=max(max_current,nums[i]);\\n            prefix_max.push_back(max_current);\\n        }\\n        \\n        vector<long long> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]+=prefix_max[i];\\n        }\\n        \\n        long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421177,
                "title": "one-liner",
                "content": "**Python3**\\n```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420325,
                "title": "c-o-n-solution",
                "content": "\\n# Approach: Prefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the answer array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long maxy = 0, conver = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            maxy = nums[i] > maxy ? nums[i] : maxy;\\n            conver = maxy + nums[i];\\n            sum += conver;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long maxy = 0, conver = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            maxy = nums[i] > maxy ? nums[i] : maxy;\\n            conver = maxy + nums[i];\\n            sum += conver;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420219,
                "title": "simple-o-n",
                "content": "# Intuition\\nUse memoization\\n\\n# Approach\\nIterate the initial array. Store both max so far and score of i-1. For ith element max(i) = max(max(i-1), nums(i)), score(i) = score(i-1) + max(i) + nums(i).\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let sum = 0\\n    let max = nums[0]\\n    \\n    let res = []\\n    for(let i = 0; i < nums.length; i++){\\n        max = Math.max(nums[i], max);\\n        sum += (max + nums[i])\\n        res.push(sum);\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let sum = 0\\n    let max = nums[0]\\n    \\n    let res = []\\n    for(let i = 0; i < nums.length; i++){\\n        max = Math.max(nums[i], max);\\n        sum += (max + nums[i])\\n        res.push(sum);\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3419995,
                "title": "python-1-liner-solution",
                "content": "# **Explanation**\\nGet the accumulate max array of  `pre_max`\\nAnd return the accumulate sum of `A + max_acc`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n\\n**Python**\\n```py\\n    def findPrefixScore(self, A: List[int]) -> List[int]:\\n        acc_max = accumulate(A, max)\\n        return list(accumulate(map(sum, zip(A, acc_max))))\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def findPrefixScore(self, A: List[int]) -> List[int]:\\n        acc_max = accumulate(A, max)\\n        return list(accumulate(map(sum, zip(A, acc_max))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3443265,
                "title": "c-o-n-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHello guys, Here you just have to simply iterate the array and keep a max count  till  ith index.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Here I am explaining my approach :\\n1.) Simply iterate the array from 1st index to last.\\n2.) Keep a max to keep account of maximum till the ith index. \\n3.) Simply add this max to current index to get the value.\\n4.) Now you have sum the elements of this ans array to get final result.\\n5.) Taken a cur pointer and with the help of it added them , this cur contains sum till (i-1)th index.\\n6.)Keep in mind to take long long variable otherwise you will get TLE\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N+N) \\ni.e. O(2*N) ~ O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2*N) [for sum and ans array]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        vector<long long > ans,sum;\\n        int n = nums.size();\\n\\n        long long max = nums[0];\\n        sum.push_back(2*nums[0]);\\n        ans.push_back(2*nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>max) max = nums[i];\\n\\n            sum.push_back(nums[i]+max);\\n        }\\n        \\n        long long cur = sum[0];\\n        \\n        for(int i=1;i<n;i++){\\n            long long summ =0;\\n            summ = sum[i]+cur;\\n            ans.push_back(summ);\\n            cur = summ;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        vector<long long > ans,sum;\\n        int n = nums.size();\\n\\n        long long max = nums[0];\\n        sum.push_back(2*nums[0]);\\n        ans.push_back(2*nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>max) max = nums[i];\\n\\n            sum.push_back(nums[i]+max);\\n        }\\n        \\n        long long cur = sum[0];\\n        \\n        for(int i=1;i<n;i++){\\n            long long summ =0;\\n            summ = sum[i]+cur;\\n            ans.push_back(summ);\\n            cur = summ;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420212,
                "title": "simple-c-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long > temp(n);\\n        int maxval=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n             maxval=max(maxval,nums[i]);\\n             temp[i]=nums[i]+maxval;\\n            if(i>0)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n           \\n            \\n        }\\n \\n        \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long > temp(n);\\n        int maxval=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n             maxval=max(maxval,nums[i]);\\n             temp[i]=nums[i]+maxval;\\n            if(i>0)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n           \\n            \\n        }\\n \\n        \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420118,
                "title": "c-prefix-sum-short-sweet-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        vector<long long int> mx(n),dp(n);\\n        dp[0] = 2*nums[0],mx[0] = nums[0];\\n        for(i = 1; i < n; i++){\\n            mx[i] = max(mx[i-1],nums[i]*1LL);\\n        }\\n        for(i = 1; i < n; i++){\\n            dp[i] = nums[i]+dp[i-1]+mx[i];\\n        }\\n        return dp;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        vector<long long int> mx(n),dp(n);\\n        dp[0] = 2*nums[0],mx[0] = nums[0];\\n        for(i = 1; i < n; i++){\\n            mx[i] = max(mx[i-1],nums[i]*1LL);\\n        }\\n        for(i = 1; i < n; i++){\\n            dp[i] = nums[i]+dp[i-1]+mx[i];\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420032,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<ll> ans;\\n        int n = nums.size();\\n        ll sum = 0,maxVal=0,val;\\n        for(int i=0;i<n;i++){\\n            maxVal = max(maxVal, (ll)nums[i]);\\n            val = nums[i] + maxVal;\\n            sum += val;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<ll> ans;\\n        int n = nums.size();\\n        ll sum = 0,maxVal=0,val;\\n        for(int i=0;i<n;i++){\\n            maxVal = max(maxVal, (ll)nums[i]);\\n            val = nums[i] + maxVal;\\n            sum += val;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966852,
                "title": "fastest-efficient-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        long long  prevMax = -1 ;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            prevMax = max(prevMax, (long long)nums[i]) ;\\n            if(i == 0){\\n                conver.push_back(prevMax + nums[i]) ;\\n            }else{\\n                conver.push_back(prevMax + nums[i] + conver.back()) ;\\n            }\\n        }\\n        return conver ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        long long  prevMax = -1 ;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            prevMax = max(prevMax, (long long)nums[i]) ;\\n            if(i == 0){\\n                conver.push_back(prevMax + nums[i]) ;\\n            }else{\\n                conver.push_back(prevMax + nums[i] + conver.back()) ;\\n            }\\n        }\\n        return conver ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920265,
                "title": "o-n-approach",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\nFor storing the answer\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> conver(n);\\n        vector<long long> score(n);\\n        \\n        \\n        \\n        long long prefixMax = nums[0];\\n        conver[0] = nums[0] + prefixMax;\\n        score[0] = conver[0];\\n        long long prefixSum = conver[0];\\n        \\n        for(int i=1;i<n;i++) {\\n            prefixMax = max(static_cast<long long>(nums[i]), prefixMax);  // Use long long here\\n            conver[i] = static_cast<long long>(nums[i]) + prefixMax;      // Use long long here\\n            \\n            \\n            prefixSum += conver[i];\\n            \\n            score[i] = prefixSum;\\n            \\n            \\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> conver(n);\\n        vector<long long> score(n);\\n        \\n        \\n        \\n        long long prefixMax = nums[0];\\n        conver[0] = nums[0] + prefixMax;\\n        score[0] = conver[0];\\n        long long prefixSum = conver[0];\\n        \\n        for(int i=1;i<n;i++) {\\n            prefixMax = max(static_cast<long long>(nums[i]), prefixMax);  // Use long long here\\n            conver[i] = static_cast<long long>(nums[i]) + prefixMax;      // Use long long here\\n            \\n            \\n            prefixSum += conver[i];\\n            \\n            score[i] = prefixSum;\\n            \\n            \\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849823,
                "title": "simple-code-with-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe simply iterate over array keeping track of maximum value and also storing the total sum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif the array is is less than or eqaul maxi then simply add the maxi to that element and store it ,if not add the same maxi twice and push\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        int maxi=nums[0];\\n        long long tot=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=maxi){\\n                tot+=nums[i]+maxi;\\n                ans.push_back(tot);\\n            }\\n            else{\\n                 maxi=nums[i];\\n                 tot+=2*maxi;\\n                 ans.push_back(tot);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        int maxi=nums[0];\\n        long long tot=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=maxi){\\n                tot+=nums[i]+maxi;\\n                ans.push_back(tot);\\n            }\\n            else{\\n                 maxi=nums[i];\\n                 tot+=2*maxi;\\n                 ans.push_back(tot);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849219,
                "title": "beats-99-80-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n         int n=nums.size();\\n        vector<long long>ans(n);\\n        ans[0]=2*nums[0];\\n       long long maxi=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            maxi=nums[i];\\n            ans[i]=ans[i-1]+nums[i]+maxi;\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n         int n=nums.size();\\n        vector<long long>ans(n);\\n        ans[0]=2*nums[0];\\n       long long maxi=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            maxi=nums[i];\\n            ans[i]=ans[i-1]+nums[i]+maxi;\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590130,
                "title": "simple-solution-o-n-time-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr= new long[nums.length];\\n        long max=nums[0];\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            max=max<=nums[i]?nums[i]:max;\\n            sum=sum+nums[i]+max;\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr= new long[nums.length];\\n        long max=nums[0];\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            max=max<=nums[i]?nums[i]:max;\\n            sum=sum+nums[i]+max;\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519543,
                "title": "easy-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply traverse the array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep track of max and sum as you go ahead\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nIf you find it helpful then please upvote (thanks)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n = nums.size();\\n       vector<long long> score;\\n       long long max = INT_MIN;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]>max)max = nums[i];\\n           sum += max+nums[i];\\n           score.push_back(sum);\\n       }\\n       return score; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n = nums.size();\\n       vector<long long> score;\\n       long long max = INT_MIN;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]>max)max = nums[i];\\n           sum += max+nums[i];\\n           score.push_back(sum);\\n       }\\n       return score; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444609,
                "title": "java-fastest-runtime-easy-and-elegant-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n     long a = 0;\\n        long max = nums[0];\\n        long[] k = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            k[i] = a + nums[i] + max;\\n            a = k[i];\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n     long a = 0;\\n        long max = nums[0];\\n        long[] k = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            k[i] = a + nums[i] + max;\\n            a = k[i];\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425978,
                "title": "max-val-in-prefix-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        //we will do some precomputation to find the max in the range\\n        vector<int>prefix(nums.size(),-1);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int ele = max(prefix[i-1],nums[i]);\\n            prefix[i] = ele;\\n        }\\n        //we are going to make the ans vector\\n        vector<long long>ans;\\n\\n        //now making ans for the every index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            long long ele = nums[i];\\n            long long tillmax = prefix[i];\\n\\n            if(ans.size() == 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax));\\n                ans.push_back(result);\\n            }\\n            else if(ans.size() > 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax)) + (0LL + ans.back());\\n                ans.push_back(result);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        //we will do some precomputation to find the max in the range\\n        vector<int>prefix(nums.size(),-1);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int ele = max(prefix[i-1],nums[i]);\\n            prefix[i] = ele;\\n        }\\n        //we are going to make the ans vector\\n        vector<long long>ans;\\n\\n        //now making ans for the every index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            long long ele = nums[i];\\n            long long tillmax = prefix[i];\\n\\n            if(ans.size() == 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax));\\n                ans.push_back(result);\\n            }\\n            else if(ans.size() > 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax)) + (0LL + ans.back());\\n                ans.push_back(result);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424772,
                "title": "easy-c-solution-prefix-array",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<long long> conver,score(n,0);\\n        int maxi= INT_MIN;\\n        for (int i=0; i<n; i++){\\n            maxi= max(maxi,nums[i]);\\n            conver.push_back((long long)(nums[i])+maxi);\\n            \\n        }\\n        score[0]= conver[0];\\n        for (int i=1; i<n; i++){\\n            score[i]= score[i-1]+conver[i];\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<long long> conver,score(n,0);\\n        int maxi= INT_MIN;\\n        for (int i=0; i<n; i++){\\n            maxi= max(maxi,nums[i]);\\n            conver.push_back((long long)(nums[i])+maxi);\\n            \\n        }\\n        score[0]= conver[0];\\n        for (int i=1; i<n; i++){\\n            score[i]= score[i-1]+conver[i];\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424575,
                "title": "do-exactly-what-the-question-has-asked",
                "content": "# Solution:\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        // fill the conversion array\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n        }\\n        // define the scores in the same array (prefix sum)\\n        for (int i = 1; i < n; i++) {\\n            c[i] += c[i - 1];\\n        }\\n        return c;\\n    }\\n}\\n```\\n---\\n## Single loop:\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n            if (i > 0) {\\n                c[i] += c[i - 1];\\n            }\\n        }        \\n        return c;\\n    }\\n}\\n```\\n---\\n### Time complexity: $$O(n)$$\\n### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        // fill the conversion array\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n        }\\n        // define the scores in the same array (prefix sum)\\n        for (int i = 1; i < n; i++) {\\n            c[i] += c[i - 1];\\n        }\\n        return c;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n            if (i > 0) {\\n                c[i] += c[i - 1];\\n            }\\n        }        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424010,
                "title": "c-easy-solution-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main catch here is if you are using *max_element() for finding out the max element then the code will give TLE, as *max_element() function takes $$O(n)$$ and the overall complexity turns out to be O(n<sup>2</sup>).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long max1 = nums[0];\\n        ans.push_back(2*nums[0]);\\n        long long sum1 = 2*nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>=max1){\\n                max1 = nums[i];\\n                sum1 = sum1+(2*nums[i]);\\n                ans.push_back(sum1);\\n            }else{\\n                sum1 = sum1+(nums[i]+max1);\\n                ans.push_back(sum1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote_cat.jpeg](https://assets.leetcode.com/users/images/f87692e8-d2b3-42f0-89a2-44e236bc72d7_1681659029.549422.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long max1 = nums[0];\\n        ans.push_back(2*nums[0]);\\n        long long sum1 = 2*nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>=max1){\\n                max1 = nums[i];\\n                sum1 = sum1+(2*nums[i]);\\n                ans.push_back(sum1);\\n            }else{\\n                sum1 = sum1+(nums[i]+max1);\\n                ans.push_back(sum1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423148,
                "title": "c-easy-4-lines-only-o-n-faster-96",
                "content": "```c++\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n    vector<long long> res;\\n    long long max_so_far = 0, prev = 0;\\n    for (auto num: nums) {\\n        max_so_far = max(max_so_far, 1LL * num);\\n        res.push_back(0LL + num + max_so_far + prev);\\n        prev = res.back();\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```c++\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n    vector<long long> res;\\n    long long max_so_far = 0, prev = 0;\\n    for (auto num: nums) {\\n        max_so_far = max(max_so_far, 1LL * num);\\n        res.push_back(0LL + num + max_so_far + prev);\\n        prev = res.back();\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422816,
                "title": "c-very-very-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        ans.push_back(nums[0]+nums[0]);\\n        int maxi=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            ans.push_back(nums[i]+maxi);\\n        }\\n        \\n        for(int i=1;i<ans.size();i++){\\n            ans[i]=ans[i-1]+ans[i]; \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        ans.push_back(nums[0]+nums[0]);\\n        int maxi=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            ans.push_back(nums[i]+maxi);\\n        }\\n        \\n        for(int i=1;i<ans.size();i++){\\n            ans[i]=ans[i-1]+ans[i]; \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422758,
                "title": "easy-to-undersatnd-cpp-solution",
                "content": "![UPvote.jpg](https://assets.leetcode.com/users/images/f5aa6015-14a7-4eb6-b0d6-1c39cb83a85c_1681631343.6630116.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> res;\\n        long long sum = 0;\\n        int n = nums.size();\\n        int max_elem = nums[0];\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > max_elem) max_elem = nums[i];\\n            sum += max_elem + nums[i];\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> res;\\n        long long sum = 0;\\n        int n = nums.size();\\n        int max_elem = nums[0];\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > max_elem) max_elem = nums[i];\\n            sum += max_elem + nums[i];\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422289,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long[] ans=new long[n];\\n        long max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            max=Math.max(max>nums[i]?max:nums[i],max);\\n            ans[i]=nums[i]+max;\\n        }\\n        \\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            ans[i]=sum;\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n//         int n=nums.length;\\n//         long conver[]=new long[n];\\n        \\n//         for(int i=0;i<nums.length;i++){\\n//             conver[i] = nums[i];\\n//             long max=0;\\n//             for(int j=0;j<=i;j++){\\n//                 if(nums[j]>max){\\n//                     max=nums[j];\\n//                 }\\n                \\n//             }\\n//             conver[i]=conver[i]+max;\\n//         }\\n        \\n//         for(int i=1;i<n;i++){\\n//             conver[i]=conver[i]+conver[i-1];\\n//         }\\n//         return conver;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long[] ans=new long[n];\\n        long max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            max=Math.max(max>nums[i]?max:nums[i],max);\\n            ans[i]=nums[i]+max;\\n        }\\n        \\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            ans[i]=sum;\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n//         int n=nums.length;\\n//         long conver[]=new long[n];\\n        \\n//         for(int i=0;i<nums.length;i++){\\n//             conver[i] = nums[i];\\n//             long max=0;\\n//             for(int j=0;j<=i;j++){\\n//                 if(nums[j]>max){\\n//                     max=nums[j];\\n//                 }\\n                \\n//             }\\n//             conver[i]=conver[i]+max;\\n//         }\\n        \\n//         for(int i=1;i<n;i++){\\n//             conver[i]=conver[i]+conver[i-1];\\n//         }\\n//         return conver;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422073,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422068,
                "title": "c-brute-force",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422067,
                "title": "c-brute-force",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421994,
                "title": "optimized-java-solution-easy-structured-with-comments-and-approach",
                "content": "# Approach\\nThe key to solving the problem is literally by writing the arrays on a paper and figuring out where to add what. The given formula is `conver[i] = arr[i] + max(arr[0..i]) `.\\n\\nNow, with this we can understand that conversion array will contain sum of element at i and maximum element till i. Hence, we need to keep track of maximum element till i and check for it first when we iterate. \\n\\nNext, we do not want to return the conversion array!  We are asked to return array of sums from 0 to i of conversion array. Hence, we\\'ll keep track of sum and store that in the array to return it.\\n\\nIn the given solution, conversion array is not stored as it will just take extra space. But for understanding purposes, you can get to conversion array first and then iterate another loop to get sum/ans array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        // array of sums till i\\n        long ans[]=new long[nums.length];\\n        long sum=0;\\n        int max=nums[0];\\n        for (int i=0;i<nums.length;i++){\\n            // updating max\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            // conversion array value = nums[i]+max\\n            // ans array = sum of all till i\\n            sum = sum + nums[i] + max;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        // array of sums till i\\n        long ans[]=new long[nums.length];\\n        long sum=0;\\n        int max=nums[0];\\n        for (int i=0;i<nums.length;i++){\\n            // updating max\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            // conversion array value = nums[i]+max\\n            // ans array = sum of all till i\\n            sum = sum + nums[i] + max;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420828,
                "title": "python-greedy-6-lines-100-beats",
                "content": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        s, m, a = 0, 0, []\\n\\n        for n in nums:\\n            m = max(m, n)\\n            s += n + m\\n            a.append(s)\\n\\n        return a\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        s, m, a = 0, 0, []\\n\\n        for n in nums:\\n            m = max(m, n)\\n            s += n + m\\n            a.append(s)\\n\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420591,
                "title": "explained-with-code-c-easy-to-understand-and-implement",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need a maxium from the 0th index to current index so we can just get it using\\n`max_i = max(max_i,nums[i])`\\nit will the the latest maximum number\\n`ans[1] = nums[1] + max_i + ans[0]`(which is a prefix sum until now)\\n\\n# Complexity\\n## - Time complexity: O(n)\\n\\n## - Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        ans[0] = nums[0] + nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            ans[i] = nums[i] + max_i + ans[i-1];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        ans[0] = nums[0] + nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            ans[i] = nums[i] + max_i + ans[i-1];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420382,
                "title": "c-well-explained-8-line-code-prefix-sum-o-n-time",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        for(auto it : nums) ans.push_back(it);\\n        long long maxi = 0;\\n        for(int i=0; i<ans.size(); i++) {\\n            maxi = max(maxi, ans[i]);\\n            ans[i] += maxi;\\n        }\\n        for(int i=1; i<ans.size(); i++) ans[i] += ans[i-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        for(auto it : nums) ans.push_back(it);\\n        long long maxi = 0;\\n        for(int i=0; i<ans.size(); i++) {\\n            maxi = max(maxi, ans[i]);\\n            ans[i] += maxi;\\n        }\\n        for(int i=1; i<ans.size(); i++) ans[i] += ans[i-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420243,
                "title": "c-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        int max = 0;\\n        for(int i=0;i<nums.size();i++){\\nif(nums[i] > max) {\\n    max = nums[i];\\n}\\n            ans.push_back(max+nums[i]);\\n}\\n    long sum = ans[0];\\n        for(int i = 1; i < nums.size(); i++) {\\nsum += ans[i];\\n            ans[i] = sum;\\n            \\n}\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        int max = 0;\\n        for(int i=0;i<nums.size();i++){\\nif(nums[i] > max) {\\n    max = nums[i];\\n}\\n            ans.push_back(max+nums[i]);\\n}\\n    long sum = ans[0];\\n        for(int i = 1; i < nums.size(); i++) {\\nsum += ans[i];\\n            ans[i] = sum;\\n            \\n}\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420238,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            \\n            arr[i] = nums[i] + max;\\n        }\\n        \\n        long sum = arr[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            sum += arr[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            \\n            arr[i] = nums[i] + max;\\n        }\\n        \\n        long sum = arr[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            sum += arr[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420211,
                "title": "easy-c",
                "content": "# Intuition\\nIf you see pattern here then it is like \\nfor example [2,3,7,5,10]\\nanswer is \\nans[0] = 2 + max(2) + 0\\nans[1] = 3 + max(2,3) + ans[0];\\nans[2] = 7 + max(2,3,7) + ans[1];\\nans[3] = 5 + max(2,3,7,5) + ans[2];\\nans[4] = 10 + max(2,3,7,5,10) + ans[3];\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans(nums.size(),0);\\n        \\n        long long sum = nums[0];\\n        long long maxi = nums[0];\\n        \\n        ans[0] = sum+maxi;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            maxi = max((long long) nums[i],maxi);\\n            ans[i] = maxi + (long long)nums[i] + ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans(nums.size(),0);\\n        \\n        long long sum = nums[0];\\n        long long maxi = nums[0];\\n        \\n        ans[0] = sum+maxi;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            maxi = max((long long) nums[i],maxi);\\n            ans[i] = maxi + (long long)nums[i] + ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420190,
                "title": "c-simple-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use a loop to iterate over the elements of the array and update the maximum element seen so far. Then, calculate the prefix score for the current element by adding it to the maximum element seen so far. Finally, store the prefix score for each element in a vector and returns the vector as the result. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long>ans(n);\\n        int max_till=0;\\n        for(int i=0;i<n;++i){\\n            max_till=max(arr[i],max_till);\\n            long long curr=arr[i]+max_till;\\n            if(i==0){\\n                ans[i]=curr;\\n            }\\n            else ans[i]=ans[i-1]+curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long>ans(n);\\n        int max_till=0;\\n        for(int i=0;i<n;++i){\\n            max_till=max(arr[i],max_till);\\n            long long curr=arr[i]+max_till;\\n            if(i==0){\\n                ans[i]=curr;\\n            }\\n            else ans[i]=ans[i-1]+curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420156,
                "title": "c-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n = size(nums);\\n        \\n        vector<long long> prefix;\\n        \\n        long long mx = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mx = max(mx,0LL+nums[i]);\\n            if(prefix.empty())prefix.push_back(nums[i]+mx);\\n            else prefix.push_back(0ll+prefix.back()+nums[i]+mx);\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n = size(nums);\\n        \\n        vector<long long> prefix;\\n        \\n        long long mx = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mx = max(mx,0LL+nums[i]);\\n            if(prefix.empty())prefix.push_back(nums[i]+mx);\\n            else prefix.push_back(0ll+prefix.back()+nums[i]+mx);\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420152,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        acc_max=accumulate(nums,max)\\n        return list(accumulate(map(sum,zip(nums,acc_max))))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        acc_max=accumulate(nums,max)\\n        return list(accumulate(map(sum,zip(nums,acc_max))))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420115,
                "title": "java-prefix-sum-easiest-o-n-self-explanatory",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, max = -1;\\n        long[] conv = new long[n];\\n        \\n        for(int i=0;i<n;i++){\\n          max = Math.max(max, nums[i]);\\n          conv[i] = nums[i] + max;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            conv[i] = conv[i-1] + conv[i];\\n        }\\n        \\n        return conv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, max = -1;\\n        long[] conv = new long[n];\\n        \\n        for(int i=0;i<n;i++){\\n          max = Math.max(max, nums[i]);\\n          conv[i] = nums[i] + max;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            conv[i] = conv[i-1] + conv[i];\\n        }\\n        \\n        return conv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420089,
                "title": "c-2-lines-easy-solution-o-n",
                "content": "# Approach\\nThe prefix score of an element at index i is the sum of the maximum element from index 0 to i and the element at index i itself. This prefix score is calculated for all elements in the input vector and returned in the output vector.\\n\\n# Complexity\\n- Time complexity:\\nThe function iterates through the input vector once, so the time complexity is O(n), where n is the size of the input vector.\\n\\n- Space complexity:\\nThe function creates a new vector to store the prefix scores, so the space complexity is also O(n), where n is the size of the input vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        int maks=nums[0];\\n        long long hence=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maks = max(maks,nums[i]);\\n            hence+=maks+nums[i];\\n            conver.push_back(hence);\\n        }\\n       \\n        return conver;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        int maks=nums[0];\\n        long long hence=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maks = max(maks,nums[i]);\\n            hence+=maks+nums[i];\\n            conver.push_back(hence);\\n        }\\n       \\n        return conver;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420067,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    const ans = [];\\n    let max = 0, sum = 0;\\n    for (const n of nums) {\\n        max = Math.max(max, n);\\n        sum += n + max;\\n        ans.push(sum);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    const ans = [];\\n    let max = 0, sum = 0;\\n    for (const n of nums) {\\n        max = Math.max(max, n);\\n        sum += n + max;\\n        ans.push(sum);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420037,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long sum = 0;\\n        long max = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n            sum += nums[i] + max;\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long sum = 0;\\n        long max = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n            sum += nums[i] + max;\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420028,
                "title": "1-loop-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int t = 0, n = nums.size(); \\n        vector<long long> ans(n, 0);\\n        \\n        for(int i=0; i<n; i++){\\n            t = max(t, nums[i]); \\n            ans[i] = nums[i] + t; \\n            if(i>0) ans[i] += ans[i-1];\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int t = 0, n = nums.size(); \\n        vector<long long> ans(n, 0);\\n        \\n        for(int i=0; i<n; i++){\\n            t = max(t, nums[i]); \\n            ans[i] = nums[i] + t; \\n            if(i>0) ans[i] += ans[i-1];\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420027,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution{\\n    typedef long long ll;\\npublic:\\n    vector<ll> findPrefixScore(const vector<int>&v){\\n        ll n=v.size();\\n        vector<ll>ans(n), pref(n); // Convers\\n        pref[0]=ans[0]=2*v[0];\\n        for(ll i=1, mx=v[0]; i<n; ++i){\\n            mx=max(mx, ll(v[i])); // max so far\\n            pref[i]=v[i]+mx;\\n            ans[i]=ans[i-1]+pref[i]; // sum of Convers, i.e., the cur score\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution{\\n    typedef long long ll;\\npublic:\\n    vector<ll> findPrefixScore(const vector<int>&v){\\n        ll n=v.size();\\n        vector<ll>ans(n), pref(n); // Convers\\n        pref[0]=ans[0]=2*v[0];\\n        for(ll i=1, mx=v[0]; i<n; ++i){\\n            mx=max(mx, ll(v[i])); // max so far\\n            pref[i]=v[i]+mx;\\n            ans[i]=ans[i-1]+pref[i]; // sum of Convers, i.e., the cur score\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419998,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long x = nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(x<nums[i]) x = nums[i];\\n            nums[i] += x;\\n        }\\n        vector<long long> ans(nums.size());\\n        ans[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans[i] += (nums[i]+ans[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long x = nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(x<nums[i]) x = nums[i];\\n            nums[i] += x;\\n        }\\n        vector<long long> ans(nums.size());\\n        ans[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans[i] += (nums[i]+ans[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419983,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = nums[0];\\n       \\n        for(int i =0 ;i < nums.length;i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n             System.out.println(max);\\n            long sum = max + nums[i];\\n            arr[i] = sum;\\n        }\\n        for(int i =1 ;i<arr.length;i++){\\n            arr[i] = arr[i] + arr[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = nums[0];\\n       \\n        for(int i =0 ;i < nums.length;i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n             System.out.println(max);\\n            long sum = max + nums[i];\\n            arr[i] = sum;\\n        }\\n        for(int i =1 ;i<arr.length;i++){\\n            arr[i] = arr[i] + arr[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101062,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long arr[] = new long[nums.length];\\n        long max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long arr[] = new long[nums.length];\\n        long max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088059,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        res = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            res.append(res[i - 1] + nums[i] + maximum)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        res = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            res.append(res[i - 1] + nums[i] + maximum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081077,
                "title": "easy-to-understand-c-o-n-beats-94-59",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> v;\\n        int m = 0;\\n        long long sum = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n            m = max(m, nums[i]);\\n            nums[i] = nums[i] + m;\\n            sum += nums[i];\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> v;\\n        int m = 0;\\n        long long sum = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n            m = max(m, nums[i]);\\n            nums[i] = nums[i] + m;\\n            sum += nums[i];\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072916,
                "title": "java-solution-100-faster-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int[] conver = new int[nums.length];\\n        int max = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            conver[i] = nums[i]+max;\\n        }\\n\\n        long[] ans = new long[nums.length];\\n\\n        ans[0] = conver[0];\\n\\n        for(int i = 1; i < nums.length; i++)\\n            ans[i] = ans[i-1]+conver[i];\\n\\n        return ans;   \\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int[] conver = new int[nums.length];\\n        int max = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            conver[i] = nums[i]+max;\\n        }\\n\\n        long[] ans = new long[nums.length];\\n\\n        ans[0] = conver[0];\\n\\n        for(int i = 1; i < nums.length; i++)\\n            ans[i] = ans[i-1]+conver[i];\\n\\n        return ans;   \\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069449,
                "title": "very-easy-using-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069443,
                "title": "very-easy-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066305,
                "title": "c-really-easy-and-clean-solution",
                "content": "\\'\\'\\'\\n\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int N=nums.size();\\n        vector<long long> res(N);\\n        vector<long long> conv(N);\\n        long long score=0, maxVal=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            maxVal = max(maxVal, (long long)nums[i]);\\n            conv[i] = nums[i] + maxVal;\\n            score += conv[i];\\n            res[i] = score;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int N=nums.size();\\n        vector<long long> res(N);\\n        vector<long long> conv(N);\\n        long long score=0, maxVal=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            maxVal = max(maxVal, (long long)nums[i]);\\n            conv[i] = nums[i] + maxVal;\\n            score += conv[i];\\n            res[i] = score;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 4063799,
                "title": "python-elegant-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the `accumulate(nums, max)` to keep track of the running maximum, \\n`map(add, nums, accumulate(nums, max))` to add the running maxima to the elements of the input list, and finally `accumulate` all that to get the desired result.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - we bascially do what amounts to a single iteration over the source list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ - it\\'s all iterators inside, no temporary lists are ever allocated.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051688,
                "title": "simple-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int max=INT_MIN;\\n        vector<long long> ans;\\n        long long score =0;\\n        int idx=0;\\n\\n        while(idx<nums.size())\\n        {\\n            if (max <nums[idx])\\n            {\\n                max = nums[idx];\\n            }\\n            score = score + nums[idx] + max;\\n            ans.push_back(score);\\n            idx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int max=INT_MIN;\\n        vector<long long> ans;\\n        long long score =0;\\n        int idx=0;\\n\\n        while(idx<nums.size())\\n        {\\n            if (max <nums[idx])\\n            {\\n                max = nums[idx];\\n            }\\n            score = score + nums[idx] + max;\\n            ans.push_back(score);\\n            idx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043158,
                "title": "beats-99-68-runtime-most-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        vector<long long>conver;\\n        int ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ma=max(ma,nums[i]);\\n            conver.push_back(nums[i]+ma);\\n        }\\n        vector<long long>ans;\\n        long long res=0;\\n        for(int i=0;i<conver.size();i++)\\n        {\\n            res+=conver[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        vector<long long>conver;\\n        int ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ma=max(ma,nums[i]);\\n            conver.push_back(nums[i]+ma);\\n        }\\n        vector<long long>ans;\\n        long long res=0;\\n        for(int i=0;i<conver.size();i++)\\n        {\\n            res+=conver[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040810,
                "title": "prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int ax=1;\\n        long long p=0;\\n        vector<long long>ans;\\n        for(int i=0;i<size(nums);i++){\\n            ax=max(ax,nums[i]);\\n            p+=ax+nums[i];\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int ax=1;\\n        long long p=0;\\n        vector<long long>ans;\\n        for(int i=0;i<size(nums);i++){\\n            ax=max(ax,nums[i]);\\n            p+=ax+nums[i];\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038388,
                "title": "easy-o-n-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefix = new long[nums.length];\\n        long[] res = new long[nums.length];\\n        int prev = nums[0];\\n        res[0] = prev + nums[0];\\n        for (int i = 1; i < prefix.length; i++) {\\n            prev = Math.max(prev, nums[i]);\\n            long curr = prev + nums[i];\\n            res[i] = curr + res[i - 1];\\n        }\\n        return res;\\n    }\\n}\\n/**\\n2, 2 -> 4\\n\\n2 3 -> 4 6 -> 10\\n\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefix = new long[nums.length];\\n        long[] res = new long[nums.length];\\n        int prev = nums[0];\\n        res[0] = prev + nums[0];\\n        for (int i = 1; i < prefix.length; i++) {\\n            prev = Math.max(prev, nums[i]);\\n            long curr = prev + nums[i];\\n            res[i] = curr + res[i - 1];\\n        }\\n        return res;\\n    }\\n}\\n/**\\n2, 2 -> 4\\n\\n2 3 -> 4 6 -> 10\\n\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037276,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> findPrefixScore(List<int> nums) {\\n      final List<int> res = [0];\\n      var prevMax = 0;\\n      for (int i = 0; i < nums.length; i++) {\\n          prevMax = max(prevMax, nums[i]);\\n          final totalAtIndex = prevMax + nums[i];\\n          final total = totalAtIndex + res.last;\\n          res.add(total);\\n      }\\n\\n      return res.sublist(1);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> findPrefixScore(List<int> nums) {\\n      final List<int> res = [0];\\n      var prevMax = 0;\\n      for (int i = 0; i < nums.length; i++) {\\n          prevMax = max(prevMax, nums[i]);\\n          final totalAtIndex = prevMax + nums[i];\\n          final total = totalAtIndex + res.last;\\n          res.add(total);\\n      }\\n\\n      return res.sublist(1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035243,
                "title": "step-by-step-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] ans = new long[nums.length];\\n\\n        //This maxArray will store the max value till ith position\\n        int [] maxArray = new int[nums.length];\\n        int[] conversion =  new int[nums.length];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i<nums.length;i++){\\n            max = Math.max(max,nums[i]);\\n            maxArray[i] = max;\\n        }\\n        for(int i = 0 ; i<nums.length;i++){\\n            conversion[i] = nums[i] + maxArray[i];\\n            System.out.println(conversion[i]);\\n        }\\n        ans[0] = conversion[0];\\n        for(int i = 1; i<nums.length;i++){\\n            ans[i] = (long)(conversion[i] + ans[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] ans = new long[nums.length];\\n\\n        //This maxArray will store the max value till ith position\\n        int [] maxArray = new int[nums.length];\\n        int[] conversion =  new int[nums.length];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i<nums.length;i++){\\n            max = Math.max(max,nums[i]);\\n            maxArray[i] = max;\\n        }\\n        for(int i = 0 ; i<nums.length;i++){\\n            conversion[i] = nums[i] + maxArray[i];\\n            System.out.println(conversion[i]);\\n        }\\n        ans[0] = conversion[0];\\n        for(int i = 1; i<nums.length;i++){\\n            ans[i] = (long)(conversion[i] + ans[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020332,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] r = new long[nums.length];\\n        int max = nums[0];\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            int conv = nums[i] + max;\\n            if (i == 0) {\\n                r[i] = conv;\\n            }\\n            else {\\n                r[i] = conv + r[i - 1];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] r = new long[nums.length];\\n        int max = nums[0];\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            int conv = nums[i] + max;\\n            if (i == 0) {\\n                r[i] = conv;\\n            }\\n            else {\\n                r[i] = conv + r[i - 1];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017769,
                "title": "easiest-solution-in-single-traversal-95-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum=0;\\n        int maxi=0;\\n        for(auto i:nums){\\n            maxi=max(maxi,i);\\n            sum=sum+i+maxi;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum=0;\\n        int maxi=0;\\n        for(auto i:nums){\\n            maxi=max(maxi,i);\\n            sum=sum+i+maxi;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016660,
                "title": "short-code-easiest-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>&n){\\n        vector<long long>ans;\\n        long long mx=0 , sum=0;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]>mx){\\n                mx=n[i];\\n            }\\n            sum+=n[i]+mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>&n){\\n        vector<long long>ans;\\n        long long mx=0 , sum=0;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]>mx){\\n                mx=n[i];\\n            }\\n            sum+=n[i]+mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999361,
                "title": "java-straightforward",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int  maxd =  nums[0] ;\\n        long res[] = new long[nums.length];\\n        res[0] = maxd*2 ;\\n        for(int i = 1; i< nums.length ; i++){\\n            \\n            maxd = Math.max(nums[i] , maxd);\\n            res[i] = maxd + nums[i] + res[i-1]; \\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int  maxd =  nums[0] ;\\n        long res[] = new long[nums.length];\\n        res[0] = maxd*2 ;\\n        for(int i = 1; i< nums.length ; i++){\\n            \\n            maxd = Math.max(nums[i] , maxd);\\n            res[i] = maxd + nums[i] + res[i-1]; \\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996249,
                "title": "c-easy-and-understandable",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long >ans;\\n        vector<int>v;\\n        int mx=nums[0];\\n        v.push_back(mx+nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            mx=max(nums[i],mx);\\n            v.push_back(nums[i]+mx);\\n        }\\n        long long  k=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans.push_back(1LL*(k+v[i]));\\n            k=ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long >ans;\\n        vector<int>v;\\n        int mx=nums[0];\\n        v.push_back(mx+nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            mx=max(nums[i],mx);\\n            v.push_back(nums[i]+mx);\\n        }\\n        long long  k=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans.push_back(1LL*(k+v[i]));\\n            k=ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994065,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] arr = new long[n];\\n        long prefix =0,max=0;\\n\\n        for(int i=0;i<n;i++){\\n           max =  Math.max(max,nums[i]);\\n           arr[i] = nums[i] + max + prefix;\\n           prefix = arr[i];\\n     }\\n       return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] arr = new long[n];\\n        long prefix =0,max=0;\\n\\n        for(int i=0;i<n;i++){\\n           max =  Math.max(max,nums[i]);\\n           arr[i] = nums[i] + max + prefix;\\n           prefix = arr[i];\\n     }\\n       return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992531,
                "title": "how-can-this-question-be-of-medium-level-difficulty-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvector<long long> findPrefixScore(vector<int>& nums) \\n{\\n        vector<long long> ans;\\n        long long curr=0;\\n        int mx=-100;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mx=max(mx,nums[i]); // max number till current index\\n            curr+= (mx+nums[i]); // addition of currnumber with max number till curr index and storing the sum\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<long long> findPrefixScore(vector<int>& nums) \\n{\\n        vector<long long> ans;\\n        long long curr=0;\\n        int mx=-100;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mx=max(mx,nums[i]); // max number till current index\\n            curr+= (mx+nums[i]); // addition of currnumber with max number till curr index and storing the sum\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989319,
                "title": "find-the-score-of-all-prefixes-of-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        arr[0] = nums[0]+max;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            arr[i] = nums[i]+arr[i-1]+max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        arr[0] = nums[0]+max;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            arr[i] = nums[i]+arr[i-1]+max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988324,
                "title": "python-simple-python-solution-prefix-sum-98-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 409 ms, faster than 98.17% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n# Memory Usage: 38.9 MB, less than 81.41% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n![image](https://assets.leetcode.com/users/images/b2a7499e-0801-4f5b-943e-b4e4fa283cc2_1693569893.2199633.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tcurrent_max = nums[0]\\n\\n\\t\\t\\tresult.append(nums[0] * 2)\\n\\n\\t\\t\\tfor num in nums[1:]:\\n\\n\\t\\t\\t\\tcurrent_max = max(current_max , num)\\n\\n\\t\\t\\t\\tresult.append(result[-1] + num + current_max)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 409 ms, faster than 98.17% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n# Memory Usage: 38.9 MB, less than 81.41% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n![image](https://assets.leetcode.com/users/images/b2a7499e-0801-4f5b-943e-b4e4fa283cc2_1693569893.2199633.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tcurrent_max = nums[0]\\n\\n\\t\\t\\tresult.append(nums[0] * 2)\\n\\n\\t\\t\\tfor num in nums[1:]:\\n\\n\\t\\t\\t\\tcurrent_max = max(current_max , num)\\n\\n\\t\\t\\t\\tresult.append(result[-1] + num + current_max)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3986671,
                "title": "very-easy-approach-using-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n\\n        vector<long long> output;\\n\\n        long long sum = 0;\\n        long int temp;\\n        output.push_back(nums[0]*2);\\n        sum = nums[0]*2;\\n        long int maxele = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n\\n            // if(nums[i-1] > nums[i]){\\n            //     temp = nums[i-1]+nums[i];\\n            // }else{\\n            //     temp = nums[i]*2;\\n            // }\\n\\n            if(maxele <= nums[i]){\\n                maxele = nums[i];\\n            }\\n            temp=maxele + nums[i];\\n\\n            sum+=temp;\\n\\n            output.push_back(sum);\\n\\n            \\n        }\\n        return output;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n\\n        vector<long long> output;\\n\\n        long long sum = 0;\\n        long int temp;\\n        output.push_back(nums[0]*2);\\n        sum = nums[0]*2;\\n        long int maxele = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n\\n            // if(nums[i-1] > nums[i]){\\n            //     temp = nums[i-1]+nums[i];\\n            // }else{\\n            //     temp = nums[i]*2;\\n            // }\\n\\n            if(maxele <= nums[i]){\\n                maxele = nums[i];\\n            }\\n            temp=maxele + nums[i];\\n\\n            sum+=temp;\\n\\n            output.push_back(sum);\\n\\n            \\n        }\\n        return output;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980151,
                "title": "prefixsum-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefixSum Java Easy Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefixSum Java Easy Solution\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefixSum = new long[nums.length];\\n\\n        prefixSum[0] = nums[0] + nums[0];\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n            prefixSum[i] = prefixSum[i-1] + nums[i] + max;\\n        }\\n\\n        return prefixSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefixSum = new long[nums.length];\\n\\n        prefixSum[0] = nums[0] + nums[0];\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n            prefixSum[i] = prefixSum[i-1] + nums[i] + max;\\n        }\\n\\n        return prefixSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975237,
                "title": "beats-98-23-o-n-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) -> since we need to return vector.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       vector<long long> pre(nums.size());\\n       int maxi=nums[0];\\n       pre[0]=maxi+nums[0];\\n       for(int i=1; i<nums.size(); i++) {\\n           maxi=max(maxi, nums[i]);\\n           pre[i]=nums[i]+pre[i-1]+maxi;\\n       }\\n       return pre;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       vector<long long> pre(nums.size());\\n       int maxi=nums[0];\\n       pre[0]=maxi+nums[0];\\n       for(int i=1; i<nums.size(); i++) {\\n           maxi=max(maxi, nums[i]);\\n           pre[i]=nums[i]+pre[i-1]+maxi;\\n       }\\n       return pre;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966494,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        int maxi=0;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            long long val=maxi+nums[i];\\n            sum=sum+val;;\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        int maxi=0;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            long long val=maxi+nums[i];\\n            sum=sum+val;;\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963370,
                "title": "swift-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findPrefixScore(_ nums: [Int]) -> [Int] {\\n    var maxVal = 0\\n    var result = [Int]()\\n    \\n    for num in nums {\\n        maxVal = max(maxVal, num)\\n        result.append(num + maxVal)\\n    }\\n    var arr = [Int]()\\n    var cur = 0\\n    for i in result {\\n        cur += i\\n        arr.append(cur)\\n    }\\n    return arr\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findPrefixScore(_ nums: [Int]) -> [Int] {\\n    var maxVal = 0\\n    var result = [Int]()\\n    \\n    for num in nums {\\n        maxVal = max(maxVal, num)\\n        result.append(num + maxVal)\\n    }\\n    var arr = [Int]()\\n    var cur = 0\\n    for i in result {\\n        cur += i\\n        arr.append(cur)\\n    }\\n    return arr\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962597,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957803,
                "title": "easy-and-well-explained",
                "content": "\\n\\n# Approach\\nmaintain a maxi variable to store the maximum till the current element.\\nInitialise a pre variable to store the score of previous elements.\\nUpdate the pre variable every time .\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=-1;\\n        long long pre=0;\\n        long long curr;\\n        vector<long long>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            maxi=max(maxi,nums[i]);\\n\\n             curr=maxi+nums[i];\\n\\n            ans.push_back(curr+pre);\\n            pre=curr+pre;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=-1;\\n        long long pre=0;\\n        long long curr;\\n        vector<long long>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            maxi=max(maxi,nums[i]);\\n\\n             curr=maxi+nums[i];\\n\\n            ans.push_back(curr+pre);\\n            pre=curr+pre;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951346,
                "title": "c-prefix-sum-simple-code",
                "content": "\\n\\n# Code\\n```\\n// #define int long long\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        long long max = v[0];\\n        vector<long long> ans;\\n        ans.push_back(v[0]*2);\\n        for(int i = 1; i<v.size(); i++){\\n            if(v[i]>max) max=v[i];\\n            long long x = v[i] + max;\\n            ans.push_back(ans[i-1]+x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// #define int long long\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        long long max = v[0];\\n        vector<long long> ans;\\n        ans.push_back(v[0]*2);\\n        for(int i = 1; i<v.size(); i++){\\n            if(v[i]>max) max=v[i];\\n            long long x = v[i] + max;\\n            ans.push_back(ans[i-1]+x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944076,
                "title": "elegant-solution-java-beats-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int max= Integer.MIN_VALUE;\\n        long [] conArr = new long[nums.length];\\n        long [] conArrAns = new long[nums.length];\\n\\n        for(int i=0;i<nums.length;i++)\\n        {   \\n            int j=0;\\n            if(nums[i]>max)\\n            max=nums[i];\\n            conArr[i] = nums[i]+max;     \\n        }\\n        long sum=0;\\n        for(int i=0;i<conArr.length;i++)\\n        {\\n            sum =sum +conArr[i];\\n            conArrAns[i]=sum;\\n        }\\n        return conArrAns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int max= Integer.MIN_VALUE;\\n        long [] conArr = new long[nums.length];\\n        long [] conArrAns = new long[nums.length];\\n\\n        for(int i=0;i<nums.length;i++)\\n        {   \\n            int j=0;\\n            if(nums[i]>max)\\n            max=nums[i];\\n            conArr[i] = nums[i]+max;     \\n        }\\n        long sum=0;\\n        for(int i=0;i<conArr.length;i++)\\n        {\\n            sum =sum +conArr[i];\\n            conArrAns[i]=sum;\\n        }\\n        return conArrAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943782,
                "title": "soooooooooooooo-much-easyyyyyyyyyyyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        maxi=nums[0]\\n        count=0\\n        for i in nums:\\n            if i>=maxi:\\n                count = count +(i+i)\\n                maxi=i\\n            else:\\n                count=count+(i+maxi)\\n            ans.append(count)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        maxi=nums[0]\\n        count=0\\n        for i in nums:\\n            if i>=maxi:\\n                count = count +(i+i)\\n                maxi=i\\n            else:\\n                count=count+(i+maxi)\\n            ans.append(count)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931863,
                "title": "elixir-solution-use-enum-reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 285ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 85MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec find_prefix_score(nums :: [integer]) :: [integer]\\n  def find_prefix_score(nums) do\\n    Enum.reduce(nums, {0, [0]}, fn num, {t_max, ans} ->\\n      t_max = max(t_max, num)\\n      {t_max, [num + t_max + (ans |> hd) | ans]}\\n    end) |> elem(1) |> Enum.reverse() |> tl\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_prefix_score(nums :: [integer]) :: [integer]\\n  def find_prefix_score(nums) do\\n    Enum.reduce(nums, {0, [0]}, fn num, {t_max, ans} ->\\n      t_max = max(t_max, num)\\n      {t_max, [num + t_max + (ans |> hd) | ans]}\\n    end) |> elem(1) |> Enum.reverse() |> tl\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3926316,
                "title": "python-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maxx=nums[0]\\n        nums[0]=nums[0]*2\\n        \\n        sum=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]>maxx:\\n                maxx=nums[i]\\n            nums[i]+=maxx\\n            sum+=nums[i]\\n            nums[i]=sum\\n            \\n        return nums\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maxx=nums[0]\\n        nums[0]=nums[0]*2\\n        \\n        sum=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]>maxx:\\n                maxx=nums[i]\\n            nums[i]+=maxx\\n            sum+=nums[i]\\n            nums[i]=sum\\n            \\n        return nums\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926266,
                "title": "c-code-beats-100-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int max = 0;\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (max < nums[i])\\n                {\\n                    max = nums[i];\\n                }\\n\\n                nums[i] += max;\\n            }\\n\\n            long[] answer = new long[nums.Length];\\n            answer[0] = nums[0];\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                answer[i] = answer[i - 1] + nums[i];\\n            }\\n            return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int max = 0;\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (max < nums[i])\\n                {\\n                    max = nums[i];\\n                }\\n\\n                nums[i] += max;\\n            }\\n\\n            long[] answer = new long[nums.Length];\\n            answer[0] = nums[0];\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                answer[i] = answer[i - 1] + nums[i];\\n            }\\n            return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913564,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        maxx=-1\\n        cnt=0\\n        for i in range(len(nums)):\\n            if maxx<nums[i]:\\n                maxx=nums[i]\\n            cnt+=nums[i]+maxx\\n            res.append(cnt)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        maxx=-1\\n        cnt=0\\n        for i in range(len(nums)):\\n            if maxx<nums[i]:\\n                maxx=nums[i]\\n            cnt+=nums[i]+maxx\\n            res.append(cnt)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910941,
                "title": "python-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = []\\n        sum = 0\\n        max = nums[0]\\n        for i in range(0,len(nums)):\\n            if nums[i]>max:\\n                max = nums[i]\\n            sum = sum + max + nums[i]\\n            a.append(sum)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = []\\n        sum = 0\\n        max = nums[0]\\n        for i in range(0,len(nums)):\\n            if nums[i]>max:\\n                max = nums[i]\\n            sum = sum + max + nums[i]\\n            a.append(sum)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904134,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] result=new long[nums.length];\\n        int max=nums[0];\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            max=Math.max(max,nums[j]);\\n            nums[j]=max+nums[j];\\n        }\\n\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            result[i]=sum;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] result=new long[nums.length];\\n        int max=nums[0];\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            max=Math.max(max,nums[j]);\\n            nums[j]=max+nums[j];\\n        }\\n\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            result[i]=sum;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903415,
                "title": "straight-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        current_max = nums[0]\\n        conver = [0]*len(nums)\\n        conver[0] = 2*current_max\\n\\n        for i in range(1, len(nums)):\\n            current_max = max(current_max, nums[i])\\n            conver[i] = conver[i-1] + nums[i] + current_max\\n        return conver\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        current_max = nums[0]\\n        conver = [0]*len(nums)\\n        conver[0] = 2*current_max\\n\\n        for i in range(1, len(nums)):\\n            current_max = max(current_max, nums[i])\\n            conver[i] = conver[i-1] + nums[i] + current_max\\n        return conver\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902615,
                "title": "java-straight-forward-easy-to-understand-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n = nums.length;\\n        long[] scores = new long[n];\\n\\n        long score = 0;\\n\\n        long maxVal = nums[0];\\n\\n        int index = 0;\\n\\n        for(int val : nums){\\n            maxVal = Math.max(maxVal, val);\\n            score += val + maxVal;\\n            scores[index++] = score;\\n        }\\n        return scores;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n = nums.length;\\n        long[] scores = new long[n];\\n\\n        long score = 0;\\n\\n        long maxVal = nums[0];\\n\\n        int index = 0;\\n\\n        for(int val : nums){\\n            maxVal = Math.max(maxVal, val);\\n            score += val + maxVal;\\n            scores[index++] = score;\\n        }\\n        return scores;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901008,
                "title": "java-easy-prefix-sum-100-beats",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long conver[]=new long[nums.length];\\n        long arr[]=new long[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           max=Math.max(max,nums[i]);\\n           conver[i]=nums[i]+max;\\n        }\\n\\n        arr[0]=conver[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            arr[i]=arr[i-1]+conver[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long conver[]=new long[nums.length];\\n        long arr[]=new long[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           max=Math.max(max,nums[i]);\\n           conver[i]=nums[i]+max;\\n        }\\n\\n        arr[0]=conver[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            arr[i]=arr[i-1]+conver[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892092,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### Use for loop to go through the nums array.\\n##### Keep a variable max to keep track of the maximum element till i\\n##### Add max to the current nums[i] now you got the conversion array value\\n##### After finding the value we have to add to final_temp which gives score at index i of our solution array.\\n\\n# Complexity\\n## - Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n##### O(n) where n is length of nums array.\\n\\n## - Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n##### O(n) as we are storing the result in an array res of length n.\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long res[]=new long[n];\\n        long max=0;\\n        long final_temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<nums[i])\\n                max=nums[i];\\n            long temp=nums[i]+max;\\n            final_temp+=temp;\\n            res[i]=final_temp;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long res[]=new long[n];\\n        long max=0;\\n        long final_temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<nums[i])\\n                max=nums[i];\\n            long temp=nums[i]+max;\\n            final_temp+=temp;\\n            res[i]=final_temp;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887877,
                "title": "golang-o-n-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc findPrefixScore(nums []int) []int64 {\\n\\tprevMax := nums[0]\\n\\tans := make([]int64, len(nums))\\n\\tans[0]=int64(nums[0]*2)\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tprevMax = max(nums[i], prevMax)\\n\\t\\tans[i] = int64(nums[i] + prevMax)+ans[i-1]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findPrefixScore(nums []int) []int64 {\\n\\tprevMax := nums[0]\\n\\tans := make([]int64, len(nums))\\n\\tans[0]=int64(nums[0]*2)\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tprevMax = max(nums[i], prevMax)\\n\\t\\tans[i] = int64(nums[i] + prevMax)+ans[i-1]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878745,
                "title": "efficient-solution-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        lenNum=len(nums)\\n        ans=[]\\n        sum=0\\n        maxnum=-9999\\n        for i in range(lenNum):\\n            if maxnum < nums[i]:\\n                maxnum=nums[i]\\n            sum +=maxnum+nums[i]\\n            ans.append(sum)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        lenNum=len(nums)\\n        ans=[]\\n        sum=0\\n        maxnum=-9999\\n        for i in range(lenNum):\\n            if maxnum < nums[i]:\\n                maxnum=nums[i]\\n            sum +=maxnum+nums[i]\\n            ans.append(sum)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874890,
                "title": "c-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Keep track of max and previous score when iterating\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int maxValue = 0;\\n        long prevScore = 0;\\n        long[] ret = new long[nums.Length];\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] > maxValue)\\n                maxValue = nums[i];\\n\\n            ret[i] = prevScore + nums[i] + maxValue;\\n\\n            prevScore = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int maxValue = 0;\\n        long prevScore = 0;\\n        long[] ret = new long[nums.Length];\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] > maxValue)\\n                maxValue = nums[i];\\n\\n            ret[i] = prevScore + nums[i] + maxValue;\\n\\n            prevScore = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862678,
                "title": "c-o-n-time-space-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find prefix max of all elements in array\\nThen find arr[i]+prefixMax[i] its conversion array\\nNow find prefix sum of conversion array\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>maxPrefix(nums.size());\\n        //Step:1 finding prefix max of array\\n        maxPrefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=max((long long)nums[i],maxPrefix[i-1]);\\n        }\\n        //ZStep-2 converting maxPrefix array to conversion array\\n        for(int i=0;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+nums[i];\\n        }\\n        //Step:3 now calculating prefix sum of conversion array\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+maxPrefix[i-1];\\n        }\\n        return maxPrefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>maxPrefix(nums.size());\\n        //Step:1 finding prefix max of array\\n        maxPrefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=max((long long)nums[i],maxPrefix[i-1]);\\n        }\\n        //ZStep-2 converting maxPrefix array to conversion array\\n        for(int i=0;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+nums[i];\\n        }\\n        //Step:3 now calculating prefix sum of conversion array\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+maxPrefix[i-1];\\n        }\\n        return maxPrefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859012,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nimplementation\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        long long temp=0;\\n        int mx=0;\\n        for(auto i:nums){\\n            mx=max(mx,i);\\n            ans.push_back(temp+mx+i);\\n            temp+=mx+i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        long long temp=0;\\n        int mx=0;\\n        for(auto i:nums){\\n            mx=max(mx,i);\\n            ans.push_back(temp+mx+i);\\n            temp+=mx+i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852180,
                "title": "c-shortest-o-n-space-time",
                "content": "# Approach\\n\\nSince vector elements are always default-initialized but we wouldn\\'t care about its default values here, let\\'s put it at least to some use and pass as \"default value\" the one that should be in the first element, i.e. `largest \\xD7 2`. This would allow us to 1) skip first cycle 2) get rid of `i` boundary check in the cycle.\\n\\nOther than that, the code is straigtforward: we go through `nums` vector and compute each element according to the task description.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```C++\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(const vector<int>& nums) {\\n        int largest = nums[0];\\n        vector<long long> answer(nums.size(), largest * 2);\\n        for (size_t i = 1; i < nums.size(); ++i) {\\n            largest = max(largest, nums[i]);\\n            answer[i] = largest + nums[i] +  answer[i-1];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(const vector<int>& nums) {\\n        int largest = nums[0];\\n        vector<long long> answer(nums.size(), largest * 2);\\n        for (size_t i = 1; i < nums.size(); ++i) {\\n            largest = max(largest, nums[i]);\\n            answer[i] = largest + nums[i] +  answer[i-1];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841137,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        long long maxi=nums[0];\\n        vector<long long>ans(n);\\n        ans[0]=maxi+nums[0];\\n        for (int i=1;i<n;i++)\\n        {\\n           if (nums[i]>maxi) maxi=nums[i];\\n            ans[i]=1LL*nums[i]+maxi+ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        long long maxi=nums[0];\\n        vector<long long>ans(n);\\n        ans[0]=maxi+nums[0];\\n        for (int i=1;i<n;i++)\\n        {\\n           if (nums[i]>maxi) maxi=nums[i];\\n            ans[i]=1LL*nums[i]+maxi+ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838349,
                "title": "javascript-you-got-it-mate",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let conv = []\\n    let max = 0\\n    let sum = 0\\n    for(let i=0;i<nums.length;i++){\\n        max = Math.max(max,nums[i])\\n        conv[i] = max + nums[i]\\n        sum += conv[i]\\n        nums[i] = sum\\n    }\\n\\n    return nums\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let conv = []\\n    let max = 0\\n    let sum = 0\\n    for(let i=0;i<nums.length;i++){\\n        max = Math.max(max,nums[i])\\n        conv[i] = max + nums[i]\\n        sum += conv[i]\\n        nums[i] = sum\\n    }\\n\\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3834572,
                "title": "linear-python",
                "content": "# Intuition\\nSince the formula for converting each element only relies on the maximum among prior elements, and the formula for score only relies on summing prior sub-arrays, we can probably do this in linear time with a single pass while keeping track of maximum and score.\\n\\n# Approach\\nLoop through the array calculating conversion value and score along the way.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ ; we only traverse the array once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ ; we allocate one extra array to hold the answer which is the same length as the input\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        score = 0\\n        scores = [None] * len(nums)\\n        for idx, i in enumerate(nums):\\n            if i > m:\\n                m = i\\n            score += (i + m)\\n            scores[idx] = score\\n        return scores\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        score = 0\\n        scores = [None] * len(nums)\\n        for idx, i in enumerate(nums):\\n            if i > m:\\n                m = i\\n            score += (i + m)\\n            scores[idx] = score\\n        return scores\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832694,
                "title": "c-beats-100-users-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n, 0);\\n        int maxi = nums[0];\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            ans[i] = nums[i]+maxi;\\n        }\\n        vector<long long> res(n, 0);\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n, 0);\\n        int maxi = nums[0];\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            ans[i] = nums[i]+maxi;\\n        }\\n        vector<long long> res(n, 0);\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823424,
                "title": "javascript-100-runtime",
                "content": "```javascript\\nconst findPrefixScore = (nums) => {\\n  let prefix = 0;\\n  let max = 0;\\n  return nums.map((num) => {\\n    max = Math.max(max, num);\\n    prefix += num + max;\\n    return prefix;\\n  });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst findPrefixScore = (nums) => {\\n  let prefix = 0;\\n  let max = 0;\\n  return nums.map((num) => {\\n    max = Math.max(max, num);\\n    prefix += num + max;\\n    return prefix;\\n  });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3803091,
                "title": "python3-3-lines-o-n-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse the accumulate() and map() functions to create intermediary lists efficiently.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        a = list(itertools.accumulate(nums, max))\\n        a = list(map(add, nums, a))\\n        return list(itertools.accumulate(a))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        a = list(itertools.accumulate(nums, max))\\n        a = list(map(add, nums, a))\\n        return list(itertools.accumulate(a))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799998,
                "title": "python3-one-pass-beats-99-52",
                "content": "\\tclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        mx=nums[0]\\n        cumsum=0\\n        ls=[]\\n        for i in nums:\\n            if i>mx:\\n                mx=i\\n            conver=i+mx\\n            cumsum+=conver\\n            ls.append(cumsum)\\n        \\n        return ls\\n![image](https://assets.leetcode.com/users/images/158e8585-19fb-4f54-bd3c-6af9944dc537_1690014678.3895664.png)\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        mx=nums[0]\\n        cumsum=0\\n        ls=[]\\n        for i in nums:\\n            if i>mx:\\n                mx=i\\n            conver=i+mx\\n            cumsum+=conver\\n            ls.append(cumsum)\\n        \\n        return ls\\n![image](https://assets.leetcode.com/users/images/158e8585-19fb-4f54-bd3c-6af9944dc537_1690014678.3895664.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3779535,
                "title": "simple-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- cv is vector storing the max element upto i th element\\n- mx is vector storing the sum , the convert array \\n ( mx[i] = nums[i] + max(nums[0....i]) ) upto i th element\\n- the loop iterates over nums and with each itertion cv stores the max element upto i\\n- mx stores the sum of num arrays with max element making the conversion array making the resultant array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![leet.jpeg](https://assets.leetcode.com/users/images/efc6a9a0-bdef-4071-80c9-79274758646e_1689612916.0885437.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> cv(nums.size(),0);  //stores max element\\n        vector<long long> mx(nums.size(),0);    //stores sum upto i th element making the convert array\\n        cv[0]=nums[0];\\n        mx[0]=nums[0]+cv[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            cv[i]=max(nums[i],cv[i-1]);\\n            mx[i]=nums[i]+cv[i]+mx[i-1];\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> cv(nums.size(),0);  //stores max element\\n        vector<long long> mx(nums.size(),0);    //stores sum upto i th element making the convert array\\n        cv[0]=nums[0];\\n        mx[0]=nums[0]+cv[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            cv[i]=max(nums[i],cv[i-1]);\\n            mx[i]=nums[i]+cv[i]+mx[i-1];\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760113,
                "title": "o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Observation. `ans` store cummulative sum of elements of `conver` of whole `nums`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRather than calculating `conver` for whole `nums`, As we want to store cummulative sum as we iterate through `conver` in `ans`.\\n`conver[i] = nums[i] + maxi`, so rather than storing `conver`,\\ntake a variable `sum` we stores cummulative sum of elements of `conver` on each iteration, and store the value in the corresponding `ans[i]`.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n);\\n        int maxi = -1e9;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            sum += nums[i] + maxi;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n);\\n        int maxi = -1e9;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            sum += nums[i] + maxi;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743854,
                "title": "c-easy-to-understand-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        vector<int> store;\\n        int a=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>a)\\n                a=nums[i];\\n            int push=a+nums[i];\\n            store.push_back(push);\\n        }\\n        long long sum=0;\\n        for(int i=0;i<store.size();i++){\\n            sum+=(long long)store[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        vector<int> store;\\n        int a=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>a)\\n                a=nums[i];\\n            int push=a+nums[i];\\n            store.push_back(push);\\n        }\\n        long long sum=0;\\n        for(int i=0;i<store.size();i++){\\n            sum+=(long long)store[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741585,
                "title": "typescript-solution-beats-speed-100-memory-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nfunction findPrefixScore(nums: number[]): number[] {\\n    \\n    const n: number = nums.length;\\n    let result: number[] = [...Array(n+1)].fill(0);\\n    let maxResult: number = 0;\\n    for(let i=0; i<nums.length; i++) {\\n       maxResult = Math.max(nums[i], maxResult);\\n       result[i+1] = result[i] + maxResult + nums[i];\\n    }\\n    result = result.slice(1);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findPrefixScore(nums: number[]): number[] {\\n    \\n    const n: number = nums.length;\\n    let result: number[] = [...Array(n+1)].fill(0);\\n    let maxResult: number = 0;\\n    for(let i=0; i<nums.length; i++) {\\n       maxResult = Math.max(nums[i], maxResult);\\n       result[i+1] = result[i] + maxResult + nums[i];\\n    }\\n    result = result.slice(1);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3717471,
                "title": "optimal-solution-o-n-time",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        currMax = 0\\n        ans = []\\n\\n        for n in nums:\\n            currMax = max(currMax, n)\\n            if not ans:\\n                ans.append(currMax + n)\\n            else:\\n                ans.append(currMax + n + ans[-1])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        currMax = 0\\n        ans = []\\n\\n        for n in nums:\\n            currMax = max(currMax, n)\\n            if not ans:\\n                ans.append(currMax + n)\\n            else:\\n                ans.append(currMax + n + ans[-1])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708003,
                "title": "easily-understandable-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> v(n);\\n        long long sum=0;\\n        v[0]=2*nums[0];\\n        int m=nums[0];\\n        sum+=v[0];\\n        for(int i=1;i<n;i++){\\n            m=max(m,nums[i]);\\n            long long p=nums[i]+m;\\n            sum+=p;\\n            v[i]=sum;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> v(n);\\n        long long sum=0;\\n        v[0]=2*nums[0];\\n        int m=nums[0];\\n        sum+=v[0];\\n        for(int i=1;i<n;i++){\\n            m=max(m,nums[i]);\\n            long long p=nums[i]+m;\\n            sum+=p;\\n            v[i]=sum;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701913,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefix sum\\n\\n# Approach\\nCreate an empty array ( or an array having an filler value). Create a  ```max_till_now``` variable to store the max value of the the array at that instant while traversing the loop. Add the value of max_till-now to the the iterator and append the value to the ```ans``` array.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans = [0]\\n        max_till_now = nums[0]\\n\\n        # ans = []\\n        for num in nums:\\n            max_till_now = max(max_till_now, num)\\n            n = num + max_till_now\\n            ans.append(ans[-1] + n )\\n\\n            # print(ans)  \\n        return ans[1:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```max_till_now```\n```ans```\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans = [0]\\n        max_till_now = nums[0]\\n\\n        # ans = []\\n        for num in nums:\\n            max_till_now = max(max_till_now, num)\\n            n = num + max_till_now\\n            ans.append(ans[-1] + n )\\n\\n            # print(ans)  \\n        return ans[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698236,
                "title": "python-prefix-sum",
                "content": "```\\nclass Solution:\\n    def findPrefixScore(self, nums):\\n        maxPrefix = [nums[0]]\\n        for i in range(1, len(nums)):\\n            maxPrefix.append(max(maxPrefix[-1], nums[i]))\\n        ans = [maxPrefix[0] + nums[0]]\\n        for i in range(1, len(maxPrefix)):\\n            ans.append(ans[-1] + maxPrefix[i] + nums[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums):\\n        maxPrefix = [nums[0]]\\n        for i in range(1, len(nums)):\\n            maxPrefix.append(max(maxPrefix[-1], nums[i]))\\n        ans = [maxPrefix[0] + nums[0]]\\n        for i in range(1, len(maxPrefix)):\\n            ans.append(ans[-1] + maxPrefix[i] + nums[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697048,
                "title": "prefix-sum-one-pass-simple-java-solution-o-n-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n    long ans[]=new long[nums.length];\\n    long max=Long.MIN_VALUE;\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        max=Math.max(max,nums[i]);\\n        ans[i]=nums[i]+max;\\n        if(i!=0)\\n            ans[i]+=ans[i-1];\\n    }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n    long ans[]=new long[nums.length];\\n    long max=Long.MIN_VALUE;\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        max=Math.max(max,nums[i]);\\n        ans[i]=nums[i]+max;\\n        if(i!=0)\\n            ans[i]+=ans[i-1];\\n    }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696796,
                "title": "c-clean-code-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> v=nums;\\n        vector<long long int> a;\\n        int m=v[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m=max(m,v[i]);\\n            v[i]=m;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        a.push_back(v[i]+nums[i]);\\n        long long int c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            c+=a[i];\\n            a[i]=c;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> v=nums;\\n        vector<long long int> a;\\n        int m=v[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m=max(m,v[i]);\\n            v[i]=m;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        a.push_back(v[i]+nums[i]);\\n        long long int c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            c+=a[i];\\n            a[i]=c;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688982,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long int res=0, mx = 0;\\n        vector<long long int> ans;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mx = max(mx, (long long)nums[i]);\\n            res += mx + (long long)nums[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long int res=0, mx = 0;\\n        vector<long long int> ans;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mx = max(mx, (long long)nums[i]);\\n            res += mx + (long long)nums[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688538,
                "title": "explaination-in-hindi-and-easy-to-understand-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n        // is problem me hamko current element aur 0 to i range tk k maximum value find krna hai.\\n// aur current element aur largest value(0-i range) k sum find krna hai \\n// aur us sum ko ek  new array me dalna hai.\\n// uske bad prefix sum find krna hai \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\n\\n\\n\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n       // long data type use karege kyoki return type long diya hua hai \\n        int n  = nums.length;\\n        long prefix1[] = new long[n];\\n        long prefix2[] = new long[n];\\n        int largest = Integer.MIN_VALUE;\\n        for(int i =0; i<n ;i++)\\n        {\\n    // largest number find kr rhe hai yha pr 0 to i range tk \\n            if(nums[i]>largest)\\n            {\\n                largest = nums[i];\\n            }\\n // new prefix Array me ham current element aur largest element k sum dalege \\n            prefix1[i] = nums[i]+largest;\\n        }\\n        long  m = prefix1.length;\\n   // simple yha pr jaise PREFIX SUM find krte hai wo find krna hai \\n        prefix2[0] = prefix1[0];\\n        for(int i=1;i<m;i++)\\n        {\\n            prefix2[i] = prefix2[i-1]+prefix1[i];\\n        }\\n // last me ham prefix2 array ko  return kr dege\\n        return prefix2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n       // long data type use karege kyoki return type long diya hua hai \\n        int n  = nums.length;\\n        long prefix1[] = new long[n];\\n        long prefix2[] = new long[n];\\n        int largest = Integer.MIN_VALUE;\\n        for(int i =0; i<n ;i++)\\n        {\\n    // largest number find kr rhe hai yha pr 0 to i range tk \\n            if(nums[i]>largest)\\n            {\\n                largest = nums[i];\\n            }\\n // new prefix Array me ham current element aur largest element k sum dalege \\n            prefix1[i] = nums[i]+largest;\\n        }\\n        long  m = prefix1.length;\\n   // simple yha pr jaise PREFIX SUM find krte hai wo find krna hai \\n        prefix2[0] = prefix1[0];\\n        for(int i=1;i<m;i++)\\n        {\\n            prefix2[i] = prefix2[i-1]+prefix1[i];\\n        }\\n // last me ham prefix2 array ko  return kr dege\\n        return prefix2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683940,
                "title": "using-stack-and-logic-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore max value in a variable rather than to find max value for each iteration\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse nums and find converse use stack to find score\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        stack=[0]\\n\\n        m=nums[0]\\n\\n        for i in range(0,len(nums)):\\n            if nums[i]>m:\\n                m=nums[i]\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n            else:\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n        \\n        stack.remove(stack[0])\\n        return stack\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        stack=[0]\\n\\n        m=nums[0]\\n\\n        for i in range(0,len(nums)):\\n            if nums[i]>m:\\n                m=nums[i]\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n            else:\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n        \\n        stack.remove(stack[0])\\n        return stack\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671148,
                "title": "python3-solution-with-using-prefix-sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        conver = [0] * len(nums)\\n\\n        cur_max = 0\\n        for idx in range(len(nums)):\\n            cur_max = max(cur_max, nums[idx])\\n            conver[idx] = cur_max + nums[idx]\\n\\n        for idx in range(1, len(conver)):\\n            conver[idx] += conver[idx - 1]\\n        \\n        return conver\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        conver = [0] * len(nums)\\n\\n        cur_max = 0\\n        for idx in range(len(nums)):\\n            cur_max = max(cur_max, nums[idx])\\n            conver[idx] = cur_max + nums[idx]\\n\\n        for idx in range(1, len(conver)):\\n            conver[idx] += conver[idx - 1]\\n        \\n        return conver\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669194,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        mx=0\\n        for num in nums:\\n            mx=max(num,mx)\\n            if len(ans)>0:\\n                ans.append(mx+num+ans[-1])\\n            else:\\n                ans.append(mx+num)\\n\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        mx=0\\n        for num in nums:\\n            mx=max(num,mx)\\n            if len(ans)>0:\\n                ans.append(mx+num+ans[-1])\\n            else:\\n                ans.append(mx+num)\\n\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667211,
                "title": "one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            nums[i] += m\\n            if i >0:\\n                nums[i]+=nums[i-1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            nums[i] += m\\n            if i >0:\\n                nums[i]+=nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665090,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int m = 0;\\n        int[] max = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            max[i] = Math.max(m, nums[i]);\\n            m = max[i];\\n        }\\n\\n        long n = 0;\\n        long[] result = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            result[i] = nums[i] + max[i] + n;\\n            n = result[i];\\n        }\\n        return result;   \\n    }\\n}\\n```\\nIf you made it this far please upvote.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int m = 0;\\n        int[] max = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            max[i] = Math.max(m, nums[i]);\\n            m = max[i];\\n        }\\n\\n        long n = 0;\\n        long[] result = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            result[i] = nums[i] + max[i] + n;\\n            n = result[i];\\n        }\\n        return result;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664357,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] score = new long[nums.length];\\n        int max  = Integer.MIN_VALUE;\\n        long conver = 0; long i_score =0;\\n        for(int i =0;i <nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            conver = nums[i]+max;\\n            i_score += conver;\\n            score[i] = i_score;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] score = new long[nums.length];\\n        int max  = Integer.MIN_VALUE;\\n        long conver = 0; long i_score =0;\\n        for(int i =0;i <nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            conver = nums[i]+max;\\n            i_score += conver;\\n            score[i] = i_score;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659176,
                "title": "c-solution-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> arr;\\n        int max = nums[0];\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr.push_back(sum);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> arr;\\n        int max = nums[0];\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr.push_back(sum);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659174,
                "title": "java-solution-o-n-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        long sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        long sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657727,
                "title": "easy-solution-straight-forward-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>res(nums.size());\\n    \\n        int maxi=nums[0],x;\\n        for(int i=0;i<nums.size();i++){\\n              if(nums[i]>maxi){\\n                  maxi=nums[i];\\n              }\\n              x=nums[i]+maxi;\\n              if(i==0){\\n                res[i]=x;\\n              }else{\\n                 res[i]=res[i-1]+x;\\n              }\\n        }\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>res(nums.size());\\n    \\n        int maxi=nums[0],x;\\n        for(int i=0;i<nums.size();i++){\\n              if(nums[i]>maxi){\\n                  maxi=nums[i];\\n              }\\n              x=nums[i]+maxi;\\n              if(i==0){\\n                res[i]=x;\\n              }else{\\n                 res[i]=res[i-1]+x;\\n              }\\n        }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652788,
                "title": "2-ms-runtime-beats-100-simple-observation-java",
                "content": "# Intuition\\nNotice from example 1 the differences between each array of the answer. The first difference is 6 which is the sum of the current max, 3, and the current element 3. Notice the third difference 12, which is the sum of the current max, 7, and the current element 5. \\n\\n# Approach\\nIf we calculate these differences and add them to the previous element, we can get the next element in our output array. Gang!\\n# Complexity\\nThe time complexity is O(N) - we traverse the array just once. \\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = nums[0];\\n        long[] out = new long[nums.length];\\n        out[0] = nums[0] + max;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            out[i] = nums[i] + out[i-1] + max;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = nums[0];\\n        long[] out = new long[nums.length];\\n        out[0] = nums[0] + max;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            out[i] = nums[i] + out[i-1] + max;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652005,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        int[] t=new int[n];\\n        int max=Integer.MIN_VALUE;\\n        long[] res=new long[n];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,nums[i]);\\n            t[i]=max;\\n        }\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            res[i]=nums[i]+t[i]+sum;\\n            sum=res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        int[] t=new int[n];\\n        int max=Integer.MIN_VALUE;\\n        long[] res=new long[n];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,nums[i]);\\n            t[i]=max;\\n        }\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            res[i]=nums[i]+t[i]+sum;\\n            sum=res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642587,
                "title": "98-11-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nauto _ = []()\\n{\\n    std::cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>a;\\n        a.push_back(nums[0]);\\n        for(int i = 1 ; i<nums.size();i++){\\n            if(nums[i]>a[a.size()-1]){\\n                a.push_back(nums[i]);\\n            }\\n            else{\\n                a.push_back(a[a.size()-1]);\\n            }\\n        }\\n        for(int i = 0 ; i<nums.size();i++){\\n            a[i] = a[i] + nums[i];\\n        }\\n        for(int i = 1 ; i<a.size() ; i++){\\n            a[i] = a[i-1] + a[i];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nauto _ = []()\\n{\\n    std::cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>a;\\n        a.push_back(nums[0]);\\n        for(int i = 1 ; i<nums.size();i++){\\n            if(nums[i]>a[a.size()-1]){\\n                a.push_back(nums[i]);\\n            }\\n            else{\\n                a.push_back(a[a.size()-1]);\\n            }\\n        }\\n        for(int i = 0 ; i<nums.size();i++){\\n            a[i] = a[i] + nums[i];\\n        }\\n        for(int i = 1 ; i<a.size() ; i++){\\n            a[i] = a[i-1] + a[i];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637272,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep record of sum of convertion array till each element\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore max and sum of convertion array for each element and add converted array element for that index \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        s=0\\n        m=0\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            s=s+nums[i]+m\\n            l.append(s)\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        s=0\\n        m=0\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            s=s+nums[i]+m\\n            l.append(s)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618344,
                "title": "beginner-freindly-approach-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long>mx(n);\\n        mx[0] = nums[0];\\n        int mxe = nums[0];\\n        for(int i=1; i<n; i++){\\n            mxe = max(mxe, nums[i]);\\n            mx[i]=mxe;\\n\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            mx[i] = mx[i]+nums[i];\\n        }\\n        for(int i=1; i<n; i++){\\n            mx[i] = mx[i]+mx[i-1];\\n        }\\n        return mx;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long>mx(n);\\n        mx[0] = nums[0];\\n        int mxe = nums[0];\\n        for(int i=1; i<n; i++){\\n            mxe = max(mxe, nums[i]);\\n            mx[i]=mxe;\\n\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            mx[i] = mx[i]+nums[i];\\n        }\\n        for(int i=1; i<n; i++){\\n            mx[i] = mx[i]+mx[i-1];\\n        }\\n        return mx;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586372,
                "title": "beat-100-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int max = 0;\\n        long[] result = new long[nums.length];\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            if(i == 0){\\n                result[i] = nums[i] + max;\\n            }\\n            else{\\n            result[i] = result[i-1]+nums[i] + max;\\n        \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int max = 0;\\n        long[] result = new long[nums.length];\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            if(i == 0){\\n                result[i] = nums[i] + max;\\n            }\\n            else{\\n            result[i] = result[i-1]+nums[i] + max;\\n        \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582084,
                "title": "java-easy-solution",
                "content": "# Intuition\\nMaximum is fixed and direct implementation of given formula\\n\\n# Approach\\nDynamic programming\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] conver = new long[nums.length];\\n        conver[0] = nums[0]*2;\\n        int maxi = nums[0];\\n        for(int i = 1;nums.length>i;i++){\\n            maxi = Math.max(maxi,nums[i]);\\n            conver[i] = maxi+nums[i]+conver[i-1];\\n        }\\n        return conver;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] conver = new long[nums.length];\\n        conver[0] = nums[0]*2;\\n        int maxi = nums[0];\\n        for(int i = 1;nums.length>i;i++){\\n            maxi = Math.max(maxi,nums[i]);\\n            conver[i] = maxi+nums[i]+conver[i-1];\\n        }\\n        return conver;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581187,
                "title": "java-simple-solution-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = 0;\\n        long sum = 0;\\n        long[] ans = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            sum += nums[i] + max;\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = 0;\\n        long sum = 0;\\n        long[] ans = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            sum += nums[i] + max;\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571029,
                "title": "simple-solution-in-a-single-loop-prefix-sum",
                "content": "# Intuition\\n<a href=\"https://ibb.co/mDwk4pt\"><img src=\"https://i.ibb.co/BzxbBkj/null-1.png\" alt=\"null-1\" border=\"0\"></a><br />\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int len = nums.size();\\n        vector<long long int> prefix(len,0);\\n        int mx(0);\\n\\n        for(int i  = 0; i < len; i++){\\n            mx = max(mx,nums[i]);\\n\\n            prefix[i] = (nums[i] + mx);\\n\\n            if(i > 0){\\n                prefix[i] += prefix[i - 1];\\n            }\\n        }\\n\\n        return prefix;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int len = nums.size();\\n        vector<long long int> prefix(len,0);\\n        int mx(0);\\n\\n        for(int i  = 0; i < len; i++){\\n            mx = max(mx,nums[i]);\\n\\n            prefix[i] = (nums[i] + mx);\\n\\n            if(i > 0){\\n                prefix[i] += prefix[i - 1];\\n            }\\n        }\\n\\n        return prefix;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567821,
                "title": "simple-java-solution-using-array-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO( N )<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO( N )<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n=nums.length;\\n        long[] ans=new long[n]; //for final ans\\n        long[] max=new long[n]; //for calculating sum of element and max\\n                                // before it\\n\\n        max[0]=2*nums[0];\\n        long temp=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>temp){\\n                max[i]=2*nums[i];\\n                temp=nums[i]; //Here we have calculted the max value before\\n                             //it and sum of that element.\\n            }\\n            else max[i]=temp+nums[i];\\n        }\\n        \\n        ans[0]=max[0];\\n\\n        for(int i=1;i<n;i++){\\n            ans[i]=ans[i-1]+max[i]; //we calculated the prefix sum using\\n                                    // max array.\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n=nums.length;\\n        long[] ans=new long[n]; //for final ans\\n        long[] max=new long[n]; //for calculating sum of element and max\\n                                // before it\\n\\n        max[0]=2*nums[0];\\n        long temp=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>temp){\\n                max[i]=2*nums[i];\\n                temp=nums[i]; //Here we have calculted the max value before\\n                             //it and sum of that element.\\n            }\\n            else max[i]=temp+nums[i];\\n        }\\n        \\n        ans[0]=max[0];\\n\\n        for(int i=1;i<n;i++){\\n            ans[i]=ans[i-1]+max[i]; //we calculated the prefix sum using\\n                                    // max array.\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567125,
                "title": "using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nfirst calculating the prefix sum then calculating the score. for calculating prefix sum used priority queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n), where n is size of nums.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>pref,ans; \\n        priority_queue<long long>pq;  \\n       // pq.push(nums[0]);\\n        for(int i=0;i<nums.size();i++) \\n        { \\n             pq.push(nums[i]);\\n           pref.push_back(nums[i]+pq.top()); \\n          \\n        } \\n        ans.push_back(pref[0]); \\n        for(int i=1;i<pref.size();i++) \\n        {\\n            ans.push_back(ans[i-1]+pref[i]);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>pref,ans; \\n        priority_queue<long long>pq;  \\n       // pq.push(nums[0]);\\n        for(int i=0;i<nums.size();i++) \\n        { \\n             pq.push(nums[i]);\\n           pref.push_back(nums[i]+pq.top()); \\n          \\n        } \\n        ans.push_back(pref[0]); \\n        for(int i=1;i<pref.size();i++) \\n        {\\n            ans.push_back(ans[i-1]+pref[i]);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566507,
                "title": "c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvector<long long> Get_converted(vector<int> &nums)\\n{\\n    vector<long long> ans = {};\\n    long long maximum = nums[0];\\n    for(int i = 0; i<nums.size(); i++)\\n    {\\n        maximum = max((long long)nums[i], maximum);\\n        int x = nums[i] + maximum;\\n        ans.push_back(x);\\n    }\\n    return ans;\\n}\\nvoid Get_added(vector<long long> &ans)\\n{\\n    long long sum = 0;\\n    for(int i = 0; i<ans.size(); i++)\\n    {\\n        sum = sum + ans[i];\\n        ans[i] = sum;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        // Cancel as answer differs after sorting -> sort(nums.begin(), nums.end());\\n        // We got the conversion array\\n        vector<long long> ans = Get_converted(nums);\\n        Get_added(ans);\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<long long> Get_converted(vector<int> &nums)\\n{\\n    vector<long long> ans = {};\\n    long long maximum = nums[0];\\n    for(int i = 0; i<nums.size(); i++)\\n    {\\n        maximum = max((long long)nums[i], maximum);\\n        int x = nums[i] + maximum;\\n        ans.push_back(x);\\n    }\\n    return ans;\\n}\\nvoid Get_added(vector<long long> &ans)\\n{\\n    long long sum = 0;\\n    for(int i = 0; i<ans.size(); i++)\\n    {\\n        sum = sum + ans[i];\\n        ans[i] = sum;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        // Cancel as answer differs after sorting -> sort(nums.begin(), nums.end());\\n        // We got the conversion array\\n        vector<long long> ans = Get_converted(nums);\\n        Get_added(ans);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1864501,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1880976,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1868316,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864344,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1974599,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1938215,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1876746,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1865483,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864439,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864351,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864501,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1880976,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1868316,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864344,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1974599,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1938215,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1876746,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1865483,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864439,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864351,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            }
        ]
    },
    {
        "title": "Design Cancellable Function",
        "question_content": "<p>Sometimes you have a long running task, and you may wish to cancel it before it completes. To help with this goal, write a function&nbsp;<code>cancellable</code> that accepts a generator object and returns an array of two values: a <strong>cancel function</strong> and a <strong>promise</strong>.</p>\n\n<p>You may assume the generator function will only&nbsp;yield promises. It is your function&#39;s responsibility to pass the values resolved by the promise back to the generator. If the promise rejects, your function should throw that&nbsp;error back to the generator.</p>\n\n<p>If the cancel callback is called before the generator is done, your function should throw an error back to the generator. That error should be the string&nbsp;<code>&quot;Cancelled&quot;</code>&nbsp;(Not an <code>Error</code>&nbsp;object). If the error was caught, the returned&nbsp;promise should resolve with the next value that was yielded or returned. Otherwise, the promise should reject with the thrown error. No more code should be executed.</p>\n\n<p>When the generator is done, the promise your function returned should resolve the value the generator returned. If, however, the generator throws an error, the returned promise should reject with the error.</p>\n\n<p>An example of how your code would be used:</p>\n\n<pre>\nfunction* tasks() {\n  const val = yield new Promise(resolve =&gt; resolve(2 + 2));\n  yield new Promise(resolve =&gt; setTimeout(resolve, 100));\n  return val + 1; // calculation shouldn&#39;t be done.\n}\nconst [cancel, promise] = cancellable(tasks());\nsetTimeout(cancel, 50);\npromise.catch(console.log); // logs &quot;Cancelled&quot; at t=50ms\n</pre>\n\n<p>If&nbsp;instead&nbsp;<code>cancel()</code> was not called or was called after <code>t=100ms</code>, the promise would&nbsp;have resolved&nbsp;<code>5</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; return 42; \n}\ncancelledAt = 100\n<strong>Output:</strong> {&quot;resolved&quot;: 42}\n<strong>Explanation:</strong>\nconst generator = generatorFunction();\nconst [cancel, promise] = cancellable(generator);\nsetTimeout(cancel, 100);\npromise.then(console.log); // resolves 42 at t=0ms\n\nThe generator immediately yields 42 and finishes. Because of that, the returned promise immediately resolves 42. Note that cancelling a finished generator does nothing.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong>\ngeneratorFunction = function*() { \n&nbsp; const msg = yield new Promise(res =&gt; res(&quot;Hello&quot;)); \n&nbsp; throw `Error: ${msg}`; \n}\ncancelledAt = null\n<strong>Output:</strong> {&quot;rejected&quot;: &quot;Error: Hello&quot;}\n<strong>Explanation:</strong>\nA promise is yielded. The function handles this by waiting for it to resolve and then passes the resolved value back to the generator. Then an error is thrown which has the effect of causing the promise to reject with the same thrown error.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 200)); \n&nbsp; return &quot;Success&quot;; \n}\ncancelledAt = 100\n<strong>Output:</strong> {&quot;rejected&quot;: &quot;Cancelled&quot;}\n<strong>Explanation:</strong>\nWhile the function is waiting for the yielded promise to resolve, cancel() is called. This causes an error message to be sent back to the generator. Since this error is uncaught, the returned promise rejected with this error.\n</pre>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong>\ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100));\n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; return result;\n}\ncancelledAt = null\n<strong>Output:</strong> {&quot;resolved&quot;: 2}\n<strong>Explanation:</strong>\n4 promises are yielded. Two of those promises have their values added to the result. After 200ms, the generator finishes with a value of 2, and that value is resolved by the returned promise.\n</pre>\n\n<p><strong class=\"example\">Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; try { \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp; } catch(e) { \n&nbsp;   return result; \n&nbsp; } \n&nbsp; return result; \n}\ncancelledAt = 150\n<strong>Output:</strong> {&quot;resolved&quot;: 1}\n<strong>Explanation:</strong>\nThe first two yielded promises resolve and cause the result to increment. However, at t=150ms, the generator is cancelled. The error sent to the generator is caught and the result is returned and finally resolved by the returned promise.\n</pre>\n\n<p><strong class=\"example\">Example 6:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; try { \n&nbsp;   yield new Promise((resolve, reject) =&gt; reject(&quot;Promise Rejected&quot;)); \n&nbsp; } catch(e) { \n&nbsp;   let a = yield new Promise(resolve =&gt; resolve(2));\n    let b = yield new Promise(resolve =&gt; resolve(2)); \n&nbsp;   return a + b; \n&nbsp; }; \n}\ncancelledAt = null\n<strong>Output:</strong> {&quot;resolved&quot;: 4}\n<strong>Explanation:</strong>\nThe first yielded promise immediately rejects. This error is caught. Because the generator hasn&#39;t been cancelled, execution continues as usual. It ends up resolving 2 + 2 = 4.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>cancelledAt == null or 0 &lt;= cancelledAt &lt;= 1000</code></li>\n\t<li><code>generatorFunction</code> returns a generator object</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3440923,
                "title": "simple-solution-with-async-and-promise-race",
                "content": "# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    var cancel;\\n    const cancelPromise = new Promise((_, reject) => { cancel = () => reject(\"Cancelled\"); });\\n    // Every Promise rejection has to be caught.\\n    cancelPromise.catch(()=>{});\\n\\n    const promise = (async () => {\\n        let next = generator.next();\\n        while (!next.done) {\\n            try {\\n                next = generator.next(await Promise.race([next.value, cancelPromise]));\\n            } catch (e) {\\n                next = generator.throw(e);\\n            }\\n        }\\n        return next.value;\\n    })();\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    var cancel;\\n    const cancelPromise = new Promise((_, reject) => { cancel = () => reject(\"Cancelled\"); });\\n    // Every Promise rejection has to be caught.\\n    cancelPromise.catch(()=>{});\\n\\n    const promise = (async () => {\\n        let next = generator.next();\\n        while (!next.done) {\\n            try {\\n                next = generator.next(await Promise.race([next.value, cancelPromise]));\\n            } catch (e) {\\n                next = generator.throw(e);\\n            }\\n        }\\n        return next.value;\\n    })();\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443563,
                "title": "javascript-typescript-simple-solution-with-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nBased on the given code snippet, the `cancellable` function seems to wrap a generator function in a way that allows it to be cancelled using a returned function. The generator function is executed asynchronously using promises and `await`, and the cancellation is implemented by rejecting a cancellation promise that is created inside the `cancellable` function.\\n\\nTo solve this problem, one could start by understanding how generators work in JavaScript/TypeScript and how to use the `Generator` type. Then, one could analyze the given code snippet and try to understand how it works, and what are the roles of the `cancel` function and the `cancelPromise`. Finally, one could try to replicate the same functionality in a different way or extend the existing code to fit a specific use case.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngeneral approach that one use to solve a problem:\\n\\n1. Understand the problem: Read and analyze the problem statement, requirements, and constraints. Ensure that you understand the problem\\'s scope, expected output, and any input constraints.\\n\\n2. Research: Look for relevant information, algorithms, libraries, and tools that could help solve the problem. Check for any existing solutions, and learn from their approaches.\\n\\n3. Plan and design: Based on your understanding of the problem and the available resources, plan your approach and design your solution. Break down the problem into smaller sub-problems and identify the key components and functions that you need.\\n\\n4. Implement: Start implementing your solution in code. Follow best practices, write clean, modular, and maintainable code. Test your code frequently and make adjustments as needed.\\n\\n5. Test and validate: Test your code thoroughly, both manually and using automated tests. Validate your code\\'s output against the problem requirements and ensure that it meets the expected results.\\n\\n6. Optimize and improve: Once you have a working solution, look for ways to optimize and improve it. Consider factors such as performance, scalability, security, and usability.\\n\\n7. Document and share: Document your code, including its purpose, usage, and any dependencies. Share your code with others, and contribute to the community by sharing your insights, solutions, and experiences.\\n# Complexity\\nThe time and space complexity of the `cancellable` function depend on the implementation details and the behavior of the generator function passed as a parameter. However, we can analyze the time and space complexity of the `cancellable` function itself:\\n- Time complexity: The `cancellable` function creates a new promise and uses the `Promise.race` method to race between the generator\\'s next value and the cancellation promise. The `Promise.race` method has a time complexity of O(n), where n is the number of promises passed as arguments. The generator function is executed synchronously until it reaches the first `yield` statement, so its time complexity depends on its implementation. Therefore, the time complexity of the `cancellable` function is at least O(1) and at most O(n), where n is the number of promises involved in the race.\\n\\n- Space complexity: The `cancellable` function creates two promises: the cancellation promise and the promise returned by the async function. It also creates a `cancel` function and a `next` variable used to iterate over the generator function. The space complexity of the `cancellable` function is therefore O(1), as the amount of memory used by the function does not depend on the input size. However, the space complexity of the generator function may be higher, depending on its implementation and the amount of data it processes.\\n\\n```javascript []\\nconst cancellable = (generator) => {\\n  let cancel;\\n  const cancelPromise = new Promise((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async () => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n```\\n```TypeScript []\\nconst cancellable = <T>(generator: Generator): [() => void, Promise<T>] => {\\n  let cancel: () => void;\\n  const cancelPromise = new Promise<never>((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async (): Promise<T> => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\nconst cancellable = (generator) => {\\n  let cancel;\\n  const cancelPromise = new Promise((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async () => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564498,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let resolve;\\n  let reject;\\n  let isCancelled = false;\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const cancel = () => {\\n    isCancelled = true;\\n    try {\\n      const obj = generator.throw(\"Cancelled\");\\n      resolve(obj.value);\\n    } catch (e) {\\n      reject(e);\\n    }\\n  };\\n\\n  function helper(val, err) {\\n    if (isCancelled) return;\\n    try {\\n      const obj = err ? generator.throw(err) : generator.next(val);\\n      if (obj.done) {\\n        resolve(obj.value);\\n      } else {\\n        Promise.resolve(obj.value)\\n          .then((result) => helper(result))\\n          .catch((e) => helper(undefined, e));\\n      }\\n    } catch (e) {\\n      reject(e);\\n    }\\n  }\\n  helper();\\n\\n  return [cancel, promise]; \\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let resolve;\\n  let reject;\\n  let isCancelled = false;\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const cancel = () => {\\n    isCancelled = true;\\n    try {\\n      const obj = generator.throw(\"Cancelled\");\\n      resolve(obj.value);\\n    } catch (e) {\\n      reject(e);\\n    }\\n  };\\n\\n  function helper(val, err) {\\n    if (isCancelled) return;\\n    try {\\n      const obj = err ? generator.throw(err) : generator.next(val);\\n      if (obj.done) {\\n        resolve(obj.value);\\n      } else {\\n        Promise.resolve(obj.value)\\n          .then((result) => helper(result))\\n          .catch((e) => helper(undefined, e));\\n      }\\n    } catch (e) {\\n      reject(e);\\n    }\\n  }\\n  helper();\\n\\n  return [cancel, promise]; \\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608553,
                "title": "design-cancellable-function-compact-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let canceled = false;\\n\\n    return [\\n        () => canceled = true,\\n        (async () => {\\n            let next = generator.next();\\n\\n            while(!next.done){\\n                try {\\n                    let nextValue = await next.value;\\n                    next = canceled ? generator.throw(\"Cancelled\") : generator.next(nextValue);\\n                } catch (e) {\\n                    next = generator.throw(e);\\n                }\\n            }\\n\\n            return next.value;\\n        })()\\n    ]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let canceled = false;\\n\\n    return [\\n        () => canceled = true,\\n        (async () => {\\n            let next = generator.next();\\n\\n            while(!next.done){\\n                try {\\n                    let nextValue = await next.value;\\n                    next = canceled ? generator.throw(\"Cancelled\") : generator.next(nextValue);\\n                } catch (e) {\\n                    next = generator.throw(e);\\n                }\\n            }\\n\\n            return next.value;\\n        })()\\n    ]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442426,
                "title": "easy-to-understand",
                "content": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let resolve;\\n    let reject;\\n    let isCancelled = false;\\n    \\n    const promise = new Promise((res, rej) => {\\n        resolve = res;\\n        reject = rej;\\n    });\\n    \\n    const cancel = () => {\\n        isCancelled = true;\\n        try {\\n        \\tconst obj = generator.throw(\"Cancelled\");\\n            resolve(obj.value)\\n        } catch (e) {\\n            reject(e);\\n        }\\n    }\\n    \\n    function helper(val, err) {\\n        if (isCancelled) return;\\n        try {\\n            const obj = err ? generator.throw(err) : generator.next(val);\\n            if (obj.done) {\\n                resolve(obj.value)\\n            } else {\\n                obj.value.then(helper).catch(e => helper(undefined, e))\\n            }\\n        } catch (e) {\\n            reject(e)\\n        }\\n    }\\n    helper();\\n\\n    return [cancel, promise];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let resolve;\\n    let reject;\\n    let isCancelled = false;\\n    \\n    const promise = new Promise((res, rej) => {\\n        resolve = res;\\n        reject = rej;\\n    });\\n    \\n    const cancel = () => {\\n        isCancelled = true;\\n        try {\\n        \\tconst obj = generator.throw(\"Cancelled\");\\n            resolve(obj.value)\\n        } catch (e) {\\n            reject(e);\\n        }\\n    }\\n    \\n    function helper(val, err) {\\n        if (isCancelled) return;\\n        try {\\n            const obj = err ? generator.throw(err) : generator.next(val);\\n            if (obj.done) {\\n                resolve(obj.value)\\n            } else {\\n                obj.value.then(helper).catch(e => helper(undefined, e))\\n            }\\n        } catch (e) {\\n            reject(e)\\n        }\\n    }\\n    helper();\\n\\n    return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445591,
                "title": "a-support-request-to-leetcode",
                "content": "# To Leetcode team\\n\\nHi, so I have a solution that has a bug which manages to pass all the given testcases in the description. However, when I submit it as a solution, it fails and the evaluator says 0 testcases passed. This is not true because if I add logs I can see that most testcases are passing. There seems to be some error in figuring out which testcases are failing for this kind of question. If you have someone available can you look at why that happens with this submission:\\n\\nThing to check:\\n1. Paste this submission\\n2. Run button says all 7 testcases passed\\n3. Submit and the evaluator will say 0 testcases passed\\n\\nNote that I know where the bug is and how to fix it. I have already submitted another solution which fixes the problem. However, I was troubled by the evaluator reporting 0 cases passing. Note also that yo can return the function that is getting assigned to `cancellable` from inside an IIFE to ensure even more isolation but the problem stays.\\n\\n```\\nvar cancellable = function(generator) {\\n    let isCancelled = false;\\n    let cancelledWithValue = false;\\n    let postCancellationValue;\\n    \\n    async function processGen(lastValue) {\\n        if (isCancelled) {\\n            return new Promise((res, rej) => { debugger; rej(\"Cancelled\") });\\n        } \\n        else if (cancelledWithValue) {\\n            return new Promise((res, rej) => { debugger; res(postCancellationValue) });\\n        }\\n        else \\n        {\\n            try {\\n                debugger\\n                const genyield = generator.next(lastValue);\\n                debugger\\n                if (!genyield.done) {\\n                    const promise = new Promise((res, rej) => {\\n                        genyield.value\\n                            .then((result) => {debugger; res(processGen(result))})\\n                            .catch(err => {\\n                                // console.log(err); \\n                                debugger\\n                                const genyield = generator.throw(err);\\n                                if (genyield.done) {\\n                                    genyield.value.then(res).catch(res);\\n                                } else {\\n                                    res(genyield.value.then(result => processGen(result)));\\n                                }\\n                            });\\n                    });\\n                    return promise;\\n                } else {\\n                    return genyield.value;\\n                }\\n            } catch (err) {\\n                // console.log(\"Catch cancel error\", err);\\n                return new Promise((res, rej) => { debugger; rej(err) })\\n            }\\n        }\\n    }\\n\\n    return [\\n        () => { \\n            try {\\n                const genyield = generator.throw(new Error(\"Cancellinig\"));\\n                cancelledWithValue = true;\\n                postCancellationValue = genyield.value;\\n                debugger\\n                console.log(genyield);\\n            } catch (err) {\\n                isCancelled = true;\\n                // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n            }\\n        }, \\n        processGen()\\n    ];\\n}\\n```\\n\\n# Actual solution that works\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let isCancelled = false;\\n  let cancelledWithValue = false;\\n  let postCancellationValue;\\n\\n  async function processGen(lastPromise) {\\n    if (isCancelled) {\\n      return new Promise((res, rej) => { rej(\"Cancelled\") });\\n    } \\n    else if (cancelledWithValue) {\\n      return new Promise((res, rej) => { res(postCancellationValue) });\\n    }\\n    else \\n    {\\n      let lastValue;\\n      let genyield;\\n      try {\\n        lastValue = await lastPromise;\\n        genyield = generator.next(lastValue);\\n      } catch (err) {\\n        lastValue = err;\\n        genyield = generator.throw(lastValue);\\n        console.log(\"Last promise did not resolve!\");\\n      }\\n\\n      try {\\n        if (!genyield.done && !isCancelled && !cancelledWithValue) {\\n            return processGen(genyield.value);\\n        } else if (isCancelled) {\\n            return Promise.reject(\"Cancelled\");\\n        } else if (cancelledWithValue) {\\n            return Promise.resolve(postCancellationValue);\\n        } else {\\n          return genyield.value;\\n        }\\n      } catch (err) {\\n        // console.log(\"Catch cancel error\", err);\\n        return new Promise((res, rej) => { rej(err) })\\n      }\\n    }\\n  }\\n\\n  return [\\n    () => { \\n      try {\\n        const genyield = generator.throw(\"Cancelled\");\\n        cancelledWithValue = true;\\n        postCancellationValue = genyield.value;\\n        console.log(genyield);\\n      } catch (err) {\\n        isCancelled = true;\\n        // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n      }\\n    }, \\n    processGen()\\n  ];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(generator) {\\n    let isCancelled = false;\\n    let cancelledWithValue = false;\\n    let postCancellationValue;\\n    \\n    async function processGen(lastValue) {\\n        if (isCancelled) {\\n            return new Promise((res, rej) => { debugger; rej(\"Cancelled\") });\\n        } \\n        else if (cancelledWithValue) {\\n            return new Promise((res, rej) => { debugger; res(postCancellationValue) });\\n        }\\n        else \\n        {\\n            try {\\n                debugger\\n                const genyield = generator.next(lastValue);\\n                debugger\\n                if (!genyield.done) {\\n                    const promise = new Promise((res, rej) => {\\n                        genyield.value\\n                            .then((result) => {debugger; res(processGen(result))})\\n                            .catch(err => {\\n                                // console.log(err); \\n                                debugger\\n                                const genyield = generator.throw(err);\\n                                if (genyield.done) {\\n                                    genyield.value.then(res).catch(res);\\n                                } else {\\n                                    res(genyield.value.then(result => processGen(result)));\\n                                }\\n                            });\\n                    });\\n                    return promise;\\n                } else {\\n                    return genyield.value;\\n                }\\n            } catch (err) {\\n                // console.log(\"Catch cancel error\", err);\\n                return new Promise((res, rej) => { debugger; rej(err) })\\n            }\\n        }\\n    }\\n\\n    return [\\n        () => { \\n            try {\\n                const genyield = generator.throw(new Error(\"Cancellinig\"));\\n                cancelledWithValue = true;\\n                postCancellationValue = genyield.value;\\n                debugger\\n                console.log(genyield);\\n            } catch (err) {\\n                isCancelled = true;\\n                // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n            }\\n        }, \\n        processGen()\\n    ];\\n}\\n```\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let isCancelled = false;\\n  let cancelledWithValue = false;\\n  let postCancellationValue;\\n\\n  async function processGen(lastPromise) {\\n    if (isCancelled) {\\n      return new Promise((res, rej) => { rej(\"Cancelled\") });\\n    } \\n    else if (cancelledWithValue) {\\n      return new Promise((res, rej) => { res(postCancellationValue) });\\n    }\\n    else \\n    {\\n      let lastValue;\\n      let genyield;\\n      try {\\n        lastValue = await lastPromise;\\n        genyield = generator.next(lastValue);\\n      } catch (err) {\\n        lastValue = err;\\n        genyield = generator.throw(lastValue);\\n        console.log(\"Last promise did not resolve!\");\\n      }\\n\\n      try {\\n        if (!genyield.done && !isCancelled && !cancelledWithValue) {\\n            return processGen(genyield.value);\\n        } else if (isCancelled) {\\n            return Promise.reject(\"Cancelled\");\\n        } else if (cancelledWithValue) {\\n            return Promise.resolve(postCancellationValue);\\n        } else {\\n          return genyield.value;\\n        }\\n      } catch (err) {\\n        // console.log(\"Catch cancel error\", err);\\n        return new Promise((res, rej) => { rej(err) })\\n      }\\n    }\\n  }\\n\\n  return [\\n    () => { \\n      try {\\n        const genyield = generator.throw(\"Cancelled\");\\n        cancelledWithValue = true;\\n        postCancellationValue = genyield.value;\\n        console.log(genyield);\\n      } catch (err) {\\n        isCancelled = true;\\n        // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n      }\\n    }, \\n    processGen()\\n  ];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440819,
                "title": "design-cancellable-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let reject = null, resolve = null;\\n\\n    let n, value;\\n    let promise = new Promise<T>(async (res,rej) => {\\n        reject = rej;\\n        resolve = res;\\n        try {\\n            for (n = generator.next(); !n.done; n = generator.next(value)) {\\n                value = await n.value;\\n            }\\n\\n            res(n.value);\\n\\n        } catch(err) {\\n            await handleError(err);\\n        }\\n    });\\n\\n    async function handleError(err) {\\n        try {\\n            console.log(\\'in handle err\\');\\n\\n            try {\\n                n = generator.throw(err);\\n            } catch(e) {\\n                reject(err);\\n                return;\\n            }\\n\\n            value = await n.value;\\n\\n            while(!n.done) {\\n                n = generator.next(value);\\n                value = await n.value;\\n                console.log(value, n.done);\\n            }\\n            value != void 0 ? resolve(value) : reject(err);\\n        } catch(e) {\\n            console.log(e, value);\\n\\n            await handleError(err)\\n        }\\n    }\\n\\n    const cancel = async () => {\\n        try {\\n            n = generator.throw(value);\\n            value = await n.value;\\n            resolve(value != void 0 ? value : \"Cancelled\");\\n        } catch(err) {\\n            reject(\"Cancelled\");\\n        }\\n\\n    }\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let reject = null, resolve = null;\\n\\n    let n, value;\\n    let promise = new Promise<T>(async (res,rej) => {\\n        reject = rej;\\n        resolve = res;\\n        try {\\n            for (n = generator.next(); !n.done; n = generator.next(value)) {\\n                value = await n.value;\\n            }\\n\\n            res(n.value);\\n\\n        } catch(err) {\\n            await handleError(err);\\n        }\\n    });\\n\\n    async function handleError(err) {\\n        try {\\n            console.log(\\'in handle err\\');\\n\\n            try {\\n                n = generator.throw(err);\\n            } catch(e) {\\n                reject(err);\\n                return;\\n            }\\n\\n            value = await n.value;\\n\\n            while(!n.done) {\\n                n = generator.next(value);\\n                value = await n.value;\\n                console.log(value, n.done);\\n            }\\n            value != void 0 ? resolve(value) : reject(err);\\n        } catch(e) {\\n            console.log(e, value);\\n\\n            await handleError(err)\\n        }\\n    }\\n\\n    const cancel = async () => {\\n        try {\\n            n = generator.throw(value);\\n            value = await n.value;\\n            resolve(value != void 0 ? value : \"Cancelled\");\\n        } catch(err) {\\n            reject(\"Cancelled\");\\n        }\\n\\n    }\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025306,
                "title": "recursive-solution-and-easy-to-understand",
                "content": "# Intuition\\n1. Ready the doc of Generator before you start to read or write the code:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw\\n2. Fully underatand how Promise works is the required skill\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let reject = null\\n    let accept = null\\n    let promise = new Promise((r, j) => {\\n        reject = j\\n        accept = r\\n        \\n        // A recursion to process generator.next()\\n        function process(value, done) {\\n          const g = generator.next(value)\\n          const valuePromise = Promise.resolve(g.value)\\n          if (g.done) {\\n            valuePromise.then(done).catch(reject)\\n            return\\n          }\\n\\n          // A recursion to process nested try catch in the generator function\\n          function processCatch(value) {\\n            try {\\n                const result = generator.throw(new Error(\\'Cancelled\\'))\\n                if (result.done) {\\n                  Promise.resolve(value).then(accept)\\n                } else {\\n                  Promise.resolve(result.value).then((v) => {\\n                    process(v, done)\\n                  }).catch((v) => {\\n                    processCatch(v)\\n                  })\\n                }\\n            } catch (err) {\\n              reject(value)\\n            }\\n          }\\n          valuePromise.then((value) => {\\n            process(value, done)\\n          }).catch(processCatch)\\n        }\\n        process(null, accept)\\n    })\\n    return [function() {\\n      try {\\n        const result = generator.throw(\\'Cancelled\\')\\n         if (result.done) {\\n            accept(result.value)\\n        } else {\\n            reject(\\'Cancelled\\')\\n        }\\n      } catch (err) {\\n        reject(err)\\n        return\\n      }\\n     \\n    }, promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let reject = null\\n    let accept = null\\n    let promise = new Promise((r, j) => {\\n        reject = j\\n        accept = r\\n        \\n        // A recursion to process generator.next()\\n        function process(value, done) {\\n          const g = generator.next(value)\\n          const valuePromise = Promise.resolve(g.value)\\n          if (g.done) {\\n            valuePromise.then(done).catch(reject)\\n            return\\n          }\\n\\n          // A recursion to process nested try catch in the generator function\\n          function processCatch(value) {\\n            try {\\n                const result = generator.throw(new Error(\\'Cancelled\\'))\\n                if (result.done) {\\n                  Promise.resolve(value).then(accept)\\n                } else {\\n                  Promise.resolve(result.value).then((v) => {\\n                    process(v, done)\\n                  }).catch((v) => {\\n                    processCatch(v)\\n                  })\\n                }\\n            } catch (err) {\\n              reject(value)\\n            }\\n          }\\n          valuePromise.then((value) => {\\n            process(value, done)\\n          }).catch(processCatch)\\n        }\\n        process(null, accept)\\n    })\\n    return [function() {\\n      try {\\n        const result = generator.throw(\\'Cancelled\\')\\n         if (result.done) {\\n            accept(result.value)\\n        } else {\\n            reject(\\'Cancelled\\')\\n        }\\n      } catch (err) {\\n        reject(err)\\n        return\\n      }\\n     \\n    }, promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951692,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Code\\n```\\nconst cancellable = (generator) => {\\n  let resolve = () => {};\\n  let reject = () => {};\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const handleError = (e, shouldResolve) => {\\n    try {\\n      if (!shouldResolve) return generator.throw(e);\\n      resolve(generator.throw(e).value);\\n    } catch (err) {\\n      reject(err);\\n    }\\n  };\\n\\n  const handleLoop = (cur) => {\\n    if (!cur) return;\\n    if (cur.done) return resolve(cur.value);\\n    cur.value\\n      .then((val) => handleLoop(generator.next(val)))\\n      .catch((err) => handleLoop(handleError(err, false)));\\n  };\\n\\n  handleLoop({\\n    value: Promise.resolve(),\\n    done: false,\\n  });\\n\\n  return [() => handleError(\"Cancelled\", true), promise];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = (generator) => {\\n  let resolve = () => {};\\n  let reject = () => {};\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const handleError = (e, shouldResolve) => {\\n    try {\\n      if (!shouldResolve) return generator.throw(e);\\n      resolve(generator.throw(e).value);\\n    } catch (err) {\\n      reject(err);\\n    }\\n  };\\n\\n  const handleLoop = (cur) => {\\n    if (!cur) return;\\n    if (cur.done) return resolve(cur.value);\\n    cur.value\\n      .then((val) => handleLoop(generator.next(val)))\\n      .catch((err) => handleLoop(handleError(err, false)));\\n  };\\n\\n  handleLoop({\\n    value: Promise.resolve(),\\n    done: false,\\n  });\\n\\n  return [() => handleError(\"Cancelled\", true), promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847351,
                "title": "posted-my-first-solution-on-leetcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    let isCancelled = false\\n    \\n    function cancelFunction() {\\n        isCancelled = true\\n    }\\n    \\n    const promise = new Promise(async (resolve, reject) => {\\n        let resolvedValue\\n        try {\\n let { done, value: pr } = generator.next()\\n        if(done) {\\n            resolvedValue = pr\\n            resolve(resolvedValue)\\n        }\\n            while(done === false) {\\n                try {\\n                const value = await pr\\n                let d, v\\n                if(isCancelled) {\\n                    const { done: d1, value: v1 } = generator.throw(\\'Cancelled\\')\\n                    d = d1\\n                    v = v1\\n                }\\n                else {\\n                    const { done: d2, value: v2 } = generator.next(value)\\n                    d = d2\\n                    v = v2\\n                }\\n                resolvedValue = v\\n                done = d\\n                pr = v\\n                if(done) {\\n                    resolvedValue = pr\\n                    resolve(resolvedValue)\\n                }\\n            }\\n            catch(err) {\\n                try {\\n                    const { done: d1, value: v1 } = generator.throw(err)\\n                    if(d1) {\\n                        done = true\\n                        resolve(err)\\n                    }\\n                    else {\\n                        done = d1\\n                        pr = v1\\n                    }\\n                }\\n                catch (err) {\\n                    done = true\\n                    reject(err)\\n                }\\n            }\\n        }\\n        }\\n\\n        catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancelFunction, promise]\\n    \\n}\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    let isCancelled = false\\n    \\n    function cancelFunction() {\\n        isCancelled = true\\n    }\\n    \\n    const promise = new Promise(async (resolve, reject) => {\\n        let resolvedValue\\n        try {\\n let { done, value: pr } = generator.next()\\n        if(done) {\\n            resolvedValue = pr\\n            resolve(resolvedValue)\\n        }\\n            while(done === false) {\\n                try {\\n                const value = await pr\\n                let d, v\\n                if(isCancelled) {\\n                    const { done: d1, value: v1 } = generator.throw(\\'Cancelled\\')\\n                    d = d1\\n                    v = v1\\n                }\\n                else {\\n                    const { done: d2, value: v2 } = generator.next(value)\\n                    d = d2\\n                    v = v2\\n                }\\n                resolvedValue = v\\n                done = d\\n                pr = v\\n                if(done) {\\n                    resolvedValue = pr\\n                    resolve(resolvedValue)\\n                }\\n            }\\n            catch(err) {\\n                try {\\n                    const { done: d1, value: v1 } = generator.throw(err)\\n                    if(d1) {\\n                        done = true\\n                        resolve(err)\\n                    }\\n                    else {\\n                        done = d1\\n                        pr = v1\\n                    }\\n                }\\n                catch (err) {\\n                    done = true\\n                    reject(err)\\n                }\\n            }\\n        }\\n        }\\n\\n        catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancelFunction, promise]\\n    \\n}\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742714,
                "title": "recursive-solution-without-using-async-await",
                "content": "# Approach\\nI solved this problem without using async/await. Recursive `iterator` sets and reads a closure variable `rejected` and routes the value back to the iterator.\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function (generator) {\\n    // this is a boilerplate to get a cancel function that rejects a `Promise` captured in the function closure.\\n    let cancelFn;\\n    const cancelPromise = new Promise((_, reject) => {\\n        cancelFn = () => reject(\"Cancelled\");\\n    });\\n    cancelPromise.catch(() => { });\\n\\n    let rejected = false\\n\\n    // helper functions used in promise chaining \\n    function reject(val) {\\n        rejected = true\\n        return val\\n    }\\n    function accept(val) {\\n        rejected = false\\n        return val\\n    }\\n\\n\\n    // recursive iterator\\n    function iterator(lastVal) {\\n        let res\\n        if (rejected) {\\n            res = generator.throw(lastVal)\\n        } else {\\n            try {\\n                res = generator.next(lastVal)\\n            } catch (e) {\\n                return Promise.reject(e)\\n            }\\n        }\\n        // once iterator is done just resolve it\\'s value\\n        if (res.done) {\\n            return Promise.resolve(res.value)\\n        }\\n        \\n        return Promise\\n            .race([Promise.resolve(res.value), cancelPromise]) // while iterator is not done, race it with cancel function\\n            .then(accept, reject) // set rejected true of false\\n            .then(iterator, iterator) // recursive call for resolved and rejected promise\\n    }\\n\\n    return [cancelFn, iterator()]\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Approach\\nI solved this problem without using async/await. Recursive `iterator` sets and reads a closure variable `rejected` and routes the value back to the iterator.\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function (generator) {\\n    // this is a boilerplate to get a cancel function that rejects a `Promise` captured in the function closure.\\n    let cancelFn;\\n    const cancelPromise = new Promise((_, reject) => {\\n        cancelFn = () => reject(\"Cancelled\");\\n    });\\n    cancelPromise.catch(() => { });\\n\\n    let rejected = false\\n\\n    // helper functions used in promise chaining \\n    function reject(val) {\\n        rejected = true\\n        return val\\n    }\\n    function accept(val) {\\n        rejected = false\\n        return val\\n    }\\n\\n\\n    // recursive iterator\\n    function iterator(lastVal) {\\n        let res\\n        if (rejected) {\\n            res = generator.throw(lastVal)\\n        } else {\\n            try {\\n                res = generator.next(lastVal)\\n            } catch (e) {\\n                return Promise.reject(e)\\n            }\\n        }\\n        // once iterator is done just resolve it\\'s value\\n        if (res.done) {\\n            return Promise.resolve(res.value)\\n        }\\n        \\n        return Promise\\n            .race([Promise.resolve(res.value), cancelPromise]) // while iterator is not done, race it with cancel function\\n            .then(accept, reject) // set rejected true of false\\n            .then(iterator, iterator) // recursive call for resolved and rejected promise\\n    }\\n\\n    return [cancelFn, iterator()]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3672778,
                "title": "faster-and-easier-solution-to-undestand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAnother quick and simple solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let isCancelled = false\\n    function cancel() {\\n        isCancelled = true\\n    }\\n\\n    const promise = new Promise<T>(async (resolve, reject) => {\\n        try {\\n            let lastYielded = generator.next()\\n            while (!lastYielded.done) {\\n                try {\\n                    const res = await lastYielded.value\\n                    lastYielded = isCancelled ? generator.throw(\"Cancelled\") : generator.next(res)\\n                } catch(err) {\\n                    lastYielded = generator.throw(err)\\n                }\\n            }\\n            resolve(lastYielded.value)\\n        } catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancel, promise]\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let isCancelled = false\\n    function cancel() {\\n        isCancelled = true\\n    }\\n\\n    const promise = new Promise<T>(async (resolve, reject) => {\\n        try {\\n            let lastYielded = generator.next()\\n            while (!lastYielded.done) {\\n                try {\\n                    const res = await lastYielded.value\\n                    lastYielded = isCancelled ? generator.throw(\"Cancelled\") : generator.next(res)\\n                } catch(err) {\\n                    lastYielded = generator.throw(err)\\n                }\\n            }\\n            resolve(lastYielded.value)\\n        } catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancel, promise]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3632981,
                "title": "brief-explanation-in-typescript-using-try-catch-syntax",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`genCall` is a function which calls the next yielding element and if it is not done yielding it keeps calling itself in turns to the point of resolution.\\nSame functionality is needed when we throw something to generator which is handled by explicitThrow param which is by default false.\\nwhile cancelling we simply call `genCall( \"Cancelled\",true);` that handles the rest for us.\\n\\nNote within `genCall` there are two try catch blocks, first one simply rejects as, if there is some error that is now handled and happens during generator function execution it should be rejected. While in the second one we are seeking if there is some error thrown from the promise that is returned in that case we simply chain that value to next call. \\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let res,rej,done=false;  \\n    let promise: Promise<T> = new Promise(async (rs,rj)=>{\\n        rej=rj;\\n        res=rs\\n    })\\n    async function genCall(val?:any,explicitThrow:boolean=false){\\n     let genData;\\n     try{\\n     genData = explicitThrow?generator.throw(val): generator.next(val);\\n    }catch(err){\\n        rej(err);\\n        return;\\n    }\\n     try{\\n        if(genData.done){\\n            let result= await genData.value\\n            done=true;\\n            res(result);\\n            return;\\n        }\\n        else{\\n              let result= await genData.value\\n              genCall(result);\\n        }\\n     }\\n     catch(err){\\n                  genCall( err,true);\\n     }\\n\\n    }\\n    genCall();\\n    return [()=>{    \\n                try {\\n                    genCall( \"Cancelled\",true);\\n                } \\n                catch (e) {\\n                    rej(e);\\n                }\\n    },promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let res,rej,done=false;  \\n    let promise: Promise<T> = new Promise(async (rs,rj)=>{\\n        rej=rj;\\n        res=rs\\n    })\\n    async function genCall(val?:any,explicitThrow:boolean=false){\\n     let genData;\\n     try{\\n     genData = explicitThrow?generator.throw(val): generator.next(val);\\n    }catch(err){\\n        rej(err);\\n        return;\\n    }\\n     try{\\n        if(genData.done){\\n            let result= await genData.value\\n            done=true;\\n            res(result);\\n            return;\\n        }\\n        else{\\n              let result= await genData.value\\n              genCall(result);\\n        }\\n     }\\n     catch(err){\\n                  genCall( err,true);\\n     }\\n\\n    }\\n    genCall();\\n    return [()=>{    \\n                try {\\n                    genCall( \"Cancelled\",true);\\n                } \\n                catch (e) {\\n                    rej(e);\\n                }\\n    },promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3622155,
                "title": "using-recursion",
                "content": "# Intuition\\nSolution using recursion\\n\\n\\n# Code\\n```\\n// A RECURSIVE VERSION\\n\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    var promiseResolve;\\n    var promiseReject\\n\\n    var handleNextPromise = function({ value, done}) {\\n        if(done) promiseResolve(value);\\n        else value\\n        .then( resolved => handleNextPromise(generator.next(resolved)))\\n        .catch(err => {\\n            try { handleNextPromise(generator.throw(err)) }\\n            catch {promiseReject(err)}\\n        });\\n    }\\n\\n    var promise = new Promise(\\n        (resolve, reject) => {\\n            promiseResolve = resolve;\\n            promiseReject = reject;\\n            handleNextPromise(generator.next(undefined));\\n        }\\n    );\\n\\n    var cancel = () => {\\n        try {\\n            var {value: lastValue, done: lastDone} = generator.throw(\"Cancelled\");\\n            promiseResolve(lastValue)\\n        } catch(generatorError) {\\n            promiseReject(generatorError);\\n        }\\n    }\\n\\n    return [cancel, promise];\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// A RECURSIVE VERSION\\n\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    var promiseResolve;\\n    var promiseReject\\n\\n    var handleNextPromise = function({ value, done}) {\\n        if(done) promiseResolve(value);\\n        else value\\n        .then( resolved => handleNextPromise(generator.next(resolved)))\\n        .catch(err => {\\n            try { handleNextPromise(generator.throw(err)) }\\n            catch {promiseReject(err)}\\n        });\\n    }\\n\\n    var promise = new Promise(\\n        (resolve, reject) => {\\n            promiseResolve = resolve;\\n            promiseReject = reject;\\n            handleNextPromise(generator.next(undefined));\\n        }\\n    );\\n\\n    var cancel = () => {\\n        try {\\n            var {value: lastValue, done: lastDone} = generator.throw(\"Cancelled\");\\n            promiseResolve(lastValue)\\n        } catch(generatorError) {\\n            promiseReject(generatorError);\\n        }\\n    }\\n\\n    return [cancel, promise];\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3606837,
                "title": "efficient-cancellable-promises-in-typescript-achieving-control-and-flexibility-in-asynchronous",
                "content": "# Intuition\\nThe code is implementing a cancellable promise in JavaScript. It makes use of generators and promises to achieve this. The `cancellable` function takes a generator as an argument. This generator is expected to yield promises. The `cancellable` function returns a pair consisting of a cancel function and a promise. When the cancel function is called, the promise gets rejected with the reason \\'Cancelled\\'.\\n\\n# Approach\\nThe `cancellable` function starts by initializing some variables. It then creates a promise which will be returned and used for the computation. This promise is handled by an `async` function which is immediately invoked. This function calls `next` on the generator and enters a loop. Inside the loop, it waits for the promise yielded by the generator to be fulfilled or for the cancel promise to be fulfilled, whichever happens first. If the cancel promise is fulfilled, an error is thrown which is caught and rethrown to the generator. The loop continues until the generator is done.\\n\\nIf the cancel function is called, it rejects the cancel promise, which causes the promise race to resolve with an error. This error is then propagated through the generator, causing the computation to be cancelled.\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n), where n is the number of promises yielded by the generator. This is because we\\'re going through each yielded promise one by one.\\n- Space complexity: The space complexity is O(1), as we\\'re only using a constant amount of space. No matter the number of promises yielded by the generator, we\\'re only storing a constant amount of variables.\\n\\n# Code\\n\\n```typescript\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let cancelRequested = false;\\n    let resolveFunc: (value: T | PromiseLike<T>) => void;\\n    let rejectFunc: (reason?: any) => void;\\n    let cancelFunc: () => void;\\n\\n    const promise = new Promise<T>((resolve, reject) => {\\n        resolveFunc = resolve;\\n        rejectFunc = reject;\\n\\n        const cancelPromise = new Promise((_, reject) => {\\n            cancelFunc = () => reject(\\'Cancelled\\');\\n        });\\n\\n        const run = async () => {\\n            try {\\n                let result = generator.next();\\n                while (true) {\\n                    if (result.done) {\\n                        resolveFunc(result.value);\\n                        return;\\n                    }\\n                    try {\\n                        const value = await Promise.race([result.value, cancelPromise]);\\n                        result = generator.next(value);\\n                    } catch (err) {\\n                        result = generator.throw(err);\\n                    }\\n                }\\n            } catch (err) {\\n                rejectFunc(err);\\n            }\\n        };\\n\\n        run();\\n    });\\n\\n    const cancel = () => {\\n        cancelRequested = true;\\n        cancelFunc();\\n    };\\n\\n    return [cancel, promise];\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let cancelRequested = false;\\n    let resolveFunc: (value: T | PromiseLike<T>) => void;\\n    let rejectFunc: (reason?: any) => void;\\n    let cancelFunc: () => void;\\n\\n    const promise = new Promise<T>((resolve, reject) => {\\n        resolveFunc = resolve;\\n        rejectFunc = reject;\\n\\n        const cancelPromise = new Promise((_, reject) => {\\n            cancelFunc = () => reject(\\'Cancelled\\');\\n        });\\n\\n        const run = async () => {\\n            try {\\n                let result = generator.next();\\n                while (true) {\\n                    if (result.done) {\\n                        resolveFunc(result.value);\\n                        return;\\n                    }\\n                    try {\\n                        const value = await Promise.race([result.value, cancelPromise]);\\n                        result = generator.next(value);\\n                    } catch (err) {\\n                        result = generator.throw(err);\\n                    }\\n                }\\n            } catch (err) {\\n                rejectFunc(err);\\n            }\\n        };\\n\\n        run();\\n    });\\n\\n    const cancel = () => {\\n        cancelRequested = true;\\n        cancelFunc();\\n    };\\n\\n    return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1877960,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            },
            {
                "id": 1886735,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            },
            {
                "id": 1941911,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Counter II",
        "question_content": "<p>Write a function&nbsp;<code>createCounter</code>. It should accept an initial integer&nbsp;<code>init</code>. It should return an object with three functions.</p>\n\n<p>The three functions are:</p>\n\n<ul>\n\t<li><code>increment()</code>&nbsp;increases&nbsp;the current value by 1 and then returns it.</li>\n\t<li><code>decrement()</code>&nbsp;reduces the current value by 1 and then returns it.</li>\n\t<li><code>reset()</code>&nbsp;sets the current value to&nbsp;<code>init</code>&nbsp;and then returns it.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> init = 5, calls = [&quot;increment&quot;,&quot;reset&quot;,&quot;decrement&quot;]\n<strong>Output:</strong> [6,5,4]\n<strong>Explanation:</strong>\nconst counter = createCounter(5);\ncounter.increment(); // 6\ncounter.reset(); // 5\ncounter.decrement(); // 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> init = 0, calls = [&quot;increment&quot;,&quot;increment&quot;,&quot;decrement&quot;,&quot;reset&quot;,&quot;reset&quot;]\n<strong>Output:</strong> [1,2,1,0,0]\n<strong>Explanation:</strong>\nconst counter = createCounter(0);\ncounter.increment(); // 1\ncounter.increment(); // 2\ncounter.decrement(); // 1\ncounter.reset(); // 0\ncounter.reset(); // 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-1000 &lt;= init &lt;= 1000</code></li>\n\t<li><code>0 &lt;= calls.length &lt;= 1000</code></li>\n\t<li><code>calls[i]</code> is one of &quot;increment&quot;, &quot;decrement&quot; and&nbsp;&quot;reset&quot;</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3494650,
                "title": "day3-o-1-solving-it-in-3-different-ways-and-which-one-is-the-best-way",
                "content": "From the question we can decipher that we need to have three functions `increment(), decrement() and reset()`. Now let\\'s think which one will be appropriate method to solve this question.\\n***\\n## 1. Using Traditional Function\\n* A **traditional function** is defined using the `function` keyword. It can be a **named function** or an **anonymous function** assigned to a variable. \\n* In the following code we have created three functions  `increment()`, `decrement()` and `reset()` using the `function` keyword. Inside this function we need to do the appropriate operation that was instructed in the question i.e. for `increment()` we need to return the `currentvalue+1`, similarly in `decrement()` we need to return the `currentvalue-1` and in `reset()` we need to assign `originalvalue` to the `currentvalue`.\\n```\\nvar createCounter = function(init) {\\n  let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n```\\n**Time and Space: O(1)**\\n***\\n## 2. Using Arrow Function\\n* An **arrow function** is a shorter syntax for defining functions, introduced in ES6. \\n* It uses the **=> syntax** instead of the function keyword, and has some differences in behavior compared to traditional functions, such as **inheriting** the `this` value from the **surrounding context**\\n* For better understanding please read this posts : **Arrow function**(6min read) by **[@Jatin](https://leetcode.com/problems/create-hello-world-function/discuss/3486895/DAY(O(1))-Why-you-should-prefer-arrow-function-syntax!)** and **Closure on Counter-1**(8min read) problem by **[@Jatin](https://leetcode.com/problems/counter/discuss/3491300/Day2O(1)greaterUnderstanding-Closure-in-easy-way-and-its-practical-uses!!)**\\n\\n```\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n```\\n**Time and Space: O(1)**\\n***\\n## 3. Using Class\\n* A **class** is a template for creating objects with a set of properties and methods.\\n* In `ES6`, `classes` were introduced as syntactic sugar over the prototype-based inheritance model but shortly after that It **provided a way to support inheritance and can have static methods and properties, getters and setters, and more**. Thus they provided a way to write object-oriented code in a more concise and organized way.\\n\\n* In the following example the `Couter` is the name of the class.\\n\\t*  The constructor method is a special method that is called when an **object is created based on the class**.\\n\\t*  It initializes the object with properties `init` and `presentCount`. The `increment()`, `decrement()`and `reset()` method are regular methods that can be **called on an instance** of the `Counter` class to get the output\\n\\t* To create an object based on a class we use the `new` operator i.e. we create an object called `createCounter` based on the `Counter` class, passing in the `init` value as **arguments to the constructor**.\\n\\n```\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.presentCount = init;\\n  }\\n\\n  increment() {\\n    this.presentCount += 1;\\n    return this.presentCount;\\n  }\\n\\n  decrement() {\\n    this.presentCount -= 1;\\n    return this.presentCount;\\n  }\\n\\n  reset() {\\n    this.presentCount = this.init;\\n    return this.presentCount;\\n  }\\n}\\n\\nvar createCounter = function(init) {\\n  return new Counter(init);\\n};\\n```\\n**Time and Space: O(1)**\\n***\\n## In conclusion which one is the better way??\\n* **Classes** are useful for creating objects with shared behavior.\\n*  **Traditional functions** are useful for reusable chunks of code\\n*   **Arrow functions** are useful for short, concise functions or when preserving the value of `this` is important.\\n* Thus, I believe that classes are the best way to implement this types of problems in real life as they give flexibility of scaling with the shared behaviour properties. \\n***\\nYou can support this article by upvoitng \\u2B06\\u2B06!!\\n***\\nHere\\'s my [github link](https://github.com/Jatin-Shihora) where I keep my solutions.\\n***",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n  let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n```\n```\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n```\n```\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.presentCount = init;\\n  }\\n\\n  increment() {\\n    this.presentCount += 1;\\n    return this.presentCount;\\n  }\\n\\n  decrement() {\\n    this.presentCount -= 1;\\n    return this.presentCount;\\n  }\\n\\n  reset() {\\n    this.presentCount = this.init;\\n    return this.presentCount;\\n  }\\n}\\n\\nvar createCounter = function(init) {\\n  return new Counter(init);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495319,
                "title": "2665-counter-ii-level-up-your-javascript-skills-with-these-intuitive-implementations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>The `createCounter` function creates a counter object that can be used to keep track of a count and perform operations on it. The returned object has three methods: `increment`, `decrement`, and `reset`, which respectively increase the count by 1, decrease the count by 1, and reset the count to its initial value.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>The `createCounter` function uses a closure to create a private `count` variable that is initialized to either the provided `init` value or 0 if no value is provided. It then defines three inner functions (`increment`, `decrement`, and `reset`) that operate on this count variable and return its new value. Finally, it returns an object containing these three functions as properties, providing a public interface for manipulating the count.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>The `createCounter` function has a space complexity of O(1) as it creates a fixed number of variables (count, increment, decrement, reset) that are not dependent on the size of the input\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>Each instance of the counter object created by `createCounter` has a space complexity of O(1) as well, as it only contains three function properties and the count variable, which are all fixed-size.\\n\\n\\n# Code\\n```Javascript []\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let count = init || 0; // initialize count to 0 or given value\\n\\n  const increment = function() {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = function() {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = function() {\\n    count = init || 0;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n``` typescript []\\ninterface Counter {\\n  increment(): number;\\n  decrement(): number;\\n  reset(): number;\\n}\\n\\nconst createCounter = (init: number = 0): Counter => {\\n  let count: number = init;\\n\\n  const increment = (): number => {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = (): number => {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = (): number => {\\n    count = init;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\nconst counter: Counter = createCounter(5);\\n\\nconsole.log(counter.increment()); // 6\\nconsole.log(counter.reset()); // 5\\nconsole.log(counter.decrement()); // 4\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n> ##### There are several ways to implement a counter object with increment, decrement, and reset functionality in JavaScript. Here are a few alternative approaches:\\n\\n1. Using an ES6 class\\n```\\nclass Counter {\\n  constructor(init = 0) {\\n    this.count = init;\\n  }\\n\\n  increment() {\\n    return ++this.count;\\n  }\\n\\n  decrement() {\\n    return --this.count;\\n  }\\n\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n}\\n```\\n>Here, we define a `Counter` class with a constructor that takes an optional `init` parameter (defaulting to 0). We also define three methods (`increment`, `decrement`, and `reset`) that modify the `count` property and return its new value.\\n\\n\\n2. Using an object literal\\n```\\nconst counter = {\\n  count: 0,\\n  increment() {\\n    return ++this.count;\\n  },\\n  decrement() {\\n    return --this.count;\\n  },\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n};\\n\\n```\\n>Here, we define an object literal with a `count` property and three methods (`increment`, `decrement`, and `reset`) that modify the `count` property and return its new value.\\n3. Using a factory function\\n```\\nfunction createCounter(init = 0) {\\n  let count = init;\\n\\n  return {\\n    increment() {\\n      return ++count;\\n    },\\n    decrement() {\\n      return --count;\\n    },\\n    reset() {\\n      count = 0;\\n      return count;\\n    }\\n  };\\n}\\n```\\n>Here, we define a `createCounter` factory function that returns an object with three methods (`increment`, `decrement`, and `reset`) that modify a private `count` variable and return its new value.\\n\\n# Important topic to Learn\\n```\\n1. Closures: A closure is a function that has access to variables in\\n its outer lexical environment. The original implementation of the \\n`createCounter` function uses a closure to create a private `count`\\n variable that is shared by the `increment`, `decrement`, and `reset`\\n functions. Understanding closures is essential for writing clean \\nand efficient JavaScript code.\\n\\n2. Object-oriented programming (OOP): OOP is a programming paradigm \\nthat uses objects and classes to encapsulate data and behavior. The \\nES6 class-based implementation of the counter object demonstrates\\nhow to define a class with properties and methods, while the object \\nliteral and factory function approaches use object-based programming \\nto define a set of related methods.\\n\\n3. JavaScript syntax: Understanding basic JavaScript syntax is \\nessential for writing clean and readable code. The original \\nimplementation and alternative approaches use different syntax \\nelements, such as arrow functions, default parameter values, and \\nobject destructuring, that are common in modern JavaScript code.\\n\\n4. DOM manipulation: If you\\'re interested in front-end web \\ndevelopment, you\\'ll need to learn how to manipulate the Document \\nObject Model (DOM) using JavaScript. You can use a counter object to \\nupdate the text content or attributes of a HTML element in response \\nto user events, such as button clicks or key presses.\\n\\n```\\n\\n\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```Javascript []\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let count = init || 0; // initialize count to 0 or given value\\n\\n  const increment = function() {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = function() {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = function() {\\n    count = init || 0;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\n``` typescript []\\ninterface Counter {\\n  increment(): number;\\n  decrement(): number;\\n  reset(): number;\\n}\\n\\nconst createCounter = (init: number = 0): Counter => {\\n  let count: number = init;\\n\\n  const increment = (): number => {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = (): number => {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = (): number => {\\n    count = init;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\nconst counter: Counter = createCounter(5);\\n\\nconsole.log(counter.increment()); // 6\\nconsole.log(counter.reset()); // 5\\nconsole.log(counter.decrement()); // 4\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```\\nclass Counter {\\n  constructor(init = 0) {\\n    this.count = init;\\n  }\\n\\n  increment() {\\n    return ++this.count;\\n  }\\n\\n  decrement() {\\n    return --this.count;\\n  }\\n\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n}\\n```\n```\\nconst counter = {\\n  count: 0,\\n  increment() {\\n    return ++this.count;\\n  },\\n  decrement() {\\n    return --this.count;\\n  },\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n};\\n\\n```\n```\\nfunction createCounter(init = 0) {\\n  let count = init;\\n\\n  return {\\n    increment() {\\n      return ++count;\\n    },\\n    decrement() {\\n      return --count;\\n    },\\n    reset() {\\n      count = 0;\\n      return count;\\n    }\\n  };\\n}\\n```\n```\\n1. Closures: A closure is a function that has access to variables in\\n its outer lexical environment. The original implementation of the \\n`createCounter` function uses a closure to create a private `count`\\n variable that is shared by the `increment`, `decrement`, and `reset`\\n functions. Understanding closures is essential for writing clean \\nand efficient JavaScript code.\\n\\n2. Object-oriented programming (OOP): OOP is a programming paradigm \\nthat uses objects and classes to encapsulate data and behavior. The \\nES6 class-based implementation of the counter object demonstrates\\nhow to define a class with properties and methods, while the object \\nliteral and factory function approaches use object-based programming \\nto define a set of related methods.\\n\\n3. JavaScript syntax: Understanding basic JavaScript syntax is \\nessential for writing clean and readable code. The original \\nimplementation and alternative approaches use different syntax \\nelements, such as arrow functions, default parameter values, and \\nobject destructuring, that are common in modern JavaScript code.\\n\\n4. DOM manipulation: If you\\'re interested in front-end web \\ndevelopment, you\\'ll need to learn how to manipulate the Document \\nObject Model (DOM) using JavaScript. You can use a counter object to \\nupdate the text content or attributes of a HTML element in response \\nto user events, such as button clicks or key presses.\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494506,
                "title": "solutions-in-javascript-and-typescript",
                "content": "# Approach\\n- You can use Prefix Increment/Decrement syntax to replace += 1 and -= 1. This syntax allows you to increment or decrement a number and return it at the same time.\\n- To combine the initialization of currentCount and its return, you can assign its initial value in the same line that you return it. In JavaScript, when you assign a value to a variable, it returns that value automatically. \\n- To make the code more concise, you can switch from function syntax to arrow syntax when defining the functions.\\n# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/RbpZLA8F/shared\" frameBorder=\"0\" width=\"700\" height=\"300\"></iframe>",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# Approach\\n- You can use Prefix Increment/Decrement syntax to replace += 1 and -= 1. This syntax allows you to increment or decrement a number and return it at the same time.\\n- To combine the initialization of currentCount and its return, you can assign its initial value in the same line that you return it. In JavaScript, when you assign a value to a variable, it returns that value automatically. \\n- To make the code more concise, you can switch from function syntax to arrow syntax when defining the functions.\\n# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/RbpZLA8F/shared\" frameBorder=\"0\" width=\"700\" height=\"300\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3485377,
                "title": "closure-3-lines",
                "content": "# Approach\\n```\\nfunction createCounter(init) {\\n    let value = init;\\n\\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init,\\n    }\\n};\\n```\\n\\n**NOTE #1:** Using the prefix increment/decrement updates `value` befure returing it.\\n\\n**NOTE #2:** When assigmnent used as return value, assignment is performed first, then the value of the variable to the left is returned.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ on each call\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction createCounter(init) {\\n    let value = init;\\n\\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484246,
                "title": "straight-forward-o-1",
                "content": "# Intuition\\nJust do it.\\n\\n# Approach\\nJust do it.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    c = i = init\\n\\n    function increment() {\\n        return ++c\\n    }\\n\\n    function decrement() {\\n        return --c\\n    }\\n\\n    function reset() {\\n        return c = i\\n    }\\n    return {increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    c = i = init\\n\\n    function increment() {\\n        return ++c\\n    }\\n\\n    function decrement() {\\n        return --c\\n    }\\n\\n    function reset() {\\n        return c = i\\n    }\\n    return {increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494507,
                "title": "closure-counter-object-in-javascript",
                "content": "The `createCounter` function returns an object with three methods: `increment`, `decrement`, and `reset`.\\n\\nWhen `createCounter` is called with an initial value init, it creates a closure over a local variable count, which is initialized to init.\\n\\nThe increment method increases the value of count by `1`, and then returns the new value of count. The decrement method decreases the value of count by `1`, and then returns the new value of `count`. The `reset` method sets the value of count back to the initial value init, and then returns the new value of count.\\n\\nBecause each method is defined within the same closure, they all have access to the same `count` variable, and can modify it as needed.\\n\\nThis implementation allows you to create multiple independent counters, each with their own initial value and independent count variable.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n  let count = init;\\n\\n  return {\\n    increment: () => {\\n      count++;\\n      return count;\\n    },\\n\\n    decrement: () => {\\n      count--;\\n      return count;\\n    },\\n\\n    reset: () => {\\n      count = init;\\n      return count;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n  let count = init;\\n\\n  return {\\n    increment: () => {\\n      count++;\\n      return count;\\n    },\\n\\n    decrement: () => {\\n      count--;\\n      return count;\\n    },\\n\\n    reset: () => {\\n      count = init;\\n      return count;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494783,
                "title": "o-1-easy-solution-98-commented-with-examples",
                "content": "This code defines a function createCounter that takes an initial value init as a parameter and returns an object that contains three methods: **increment**, **decrement**, and **reset**.\\n\\nThe ans variable is initialized with the value of init. This variable is defined inside the **createCounter** function, so it is only accessible within the scope of the returned object.\\n\\n\\n* The  **increment**  method is an arrow function that **increments** the ans variable and returns its new value. The decrement method is also an arrow function that decrements the ans variable and returns its new value. Both these methods use the increment and decrement operators ++ and --, respectively.\\n\\n* The **reset** method is an arrow function that assigns the ans variable the value of init, effectively resetting the counter to its original value.\\n\\n* The **returned** object contains these three methods, and these methods can be used to manipulate the ans variable in different ways. For example, you can use the **increment** and **decrement** methods to increase or ***decrease*** the value of the counter, respectively, while the reset method can be used to reset the counter to its initial value.\\n\\nYou can create multiple counter objects with different initial values by calling the **createCounter** function with different init values.\\n\\n***Here is an example of it*** \\n```\\n// create a counter object starting from 5\\nconst counter = createCounter(5);\\n\\n// increment the counter by 1\\nconsole.log(counter.increment()); // output: 6\\n\\n// decrement the counter by 2\\nconsole.log(counter.decrement()); // output: 5\\nconsole.log(counter.decrement()); // output: 4\\n\\n// reset the counter to its initial value\\ncounter.reset();\\nconsole.log(counter.increment()); // output: 5\\n\\n```\\nIn this example, we create a counter object starting from the value 5 using the ***createCounter function***. We then use the increment method to increase the counter by 1 and print the result to the console, which outputs 6. We then use the ***decrement*** method twice to decrease the counter by 2 and print the results to the console, which outputs 5 and 4, respectively. Finally, we use the reset method to reset the counter to its initial value and then use the ***increment method*** to increase the counter by 1 and print the result to the console, which outputs 5.\\n\\n```\\n\\nvar createCounter = function(init) {\\n    var ans = init;\\n\\n    return {\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init,\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// create a counter object starting from 5\\nconst counter = createCounter(5);\\n\\n// increment the counter by 1\\nconsole.log(counter.increment()); // output: 6\\n\\n// decrement the counter by 2\\nconsole.log(counter.decrement()); // output: 5\\nconsole.log(counter.decrement()); // output: 4\\n\\n// reset the counter to its initial value\\ncounter.reset();\\nconsole.log(counter.increment()); // output: 5\\n\\n```\n```\\n\\nvar createCounter = function(init) {\\n    var ans = init;\\n\\n    return {\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init,\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493336,
                "title": "my-createcounter",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const counter = {\\n    c: init,\\n    t: init,\\n    increment() {\\n      return ++this.c;\\n    },\\n    reset() {\\n      this.c = this.t;\\n      return this.c;\\n    },\\n    decrement() {\\n      return --this.c;\\n    }\\n  };\\n  \\n  return counter;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const counter = {\\n    c: init,\\n    t: init,\\n    increment() {\\n      return ++this.c;\\n    },\\n    reset() {\\n      this.c = this.t;\\n      return this.c;\\n    },\\n    decrement() {\\n      return --this.c;\\n    }\\n  };\\n  \\n  return counter;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495296,
                "title": "easy-to-understand-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return{\\n        increment:function(){\\n            c++;\\n          return c;\\n        },\\n       decrement:function(){\\n           c--;\\n           return c;\\n       },\\n       reset:function(){\\n           c=init;\\n           return c;\\n       }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return{\\n        increment:function(){\\n            c++;\\n          return c;\\n        },\\n       decrement:function(){\\n           c--;\\n           return c;\\n       },\\n       reset:function(){\\n           c=init;\\n           return c;\\n       }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495271,
                "title": "javascript-day-3-of-30-days-challange",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    let resetVal = init;\\n\\n    let obj = {\\n        increment : () => ++counter,\\n        decrement : () => --counter,\\n        reset : () => counter = resetVal\\n    }\\n\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    let resetVal = init;\\n\\n    let obj = {\\n        increment : () => ++counter,\\n        decrement : () => --counter,\\n        reset : () => counter = resetVal\\n    }\\n\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596195,
                "title": "easiest-full-explanation",
                "content": "# Intuition\\nYou\\'re probbably thinking , damn that\\'s an easy problem. I just have to return 3 objects in a function. Well , not really .\\n\\nThe following leetcode problem is a practice on whats called\\n# Factory Method ( FM ) Design Pattern .\\nKeep reading I\\'ll explain in Depth and provide a solution\\n\\n# Approach\\nLet\\'s Solve this Problem using FM.\\n\\n# **Definition : What\\'s with the Factory Method ?**\\n1. It\\'s a creational Design Pattern : It allows us to create and return different objects\\n2. It provides a way to encapsulate the object creation process within a function.\\n# Use Cases : Why do we need it and what\\'s its advantages ?\\n\\n- To Organize our Code\\n- To provide Flexibility\\n- Saves time and the effort of duplication\\n\\n# STILL CONFUSED ? LET\\'S BREAK IT DOWN EVEN MORE AND LOOK AT OUR EXAMPLE IN THIS LEETCODE PROBLEM\\n\\nIn our code snippet , the \\'createCounter\\' function is a factory method . This factory method creates a counter object , let\\'s explore what\\'s happening :\\n\\n- When we call createCounter and pass an initial value, it returns an object.\\n- The returned object allows us to perform operations on the counter, such as incrementing, decrementing, and resetting its value.\\n- This way, we can create multiple independent counters by invoking the createCounter function with different initial values.\\n# NOW IT\\'S TIME FOR A RECAP\\n\\nThe factory method is like a special function that creates and gives you objects. Instead of directly creating objects yourself, you use this function, which knows how to create the objects you need.\\nThe factory function knows how to create the objects and returns them to you.\\n\\n# To create and use the Factory Method Design pattern we :\\n- Define a factory function\\n- Create a new instance of the desired object inside our function\\n- Return the created object\\n\\n\\nNow that\\'s it , hope you liked my explanation . Remmember to always look deep behind the problem itself and understand the entire Concept Hope I helped , Kindly upvote If I did : )\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497509,
                "title": "javascript-object-simplest-solution",
                "content": "```\\nvar createCounter = function(init) {\\n  var count = init;\\n  return {\\n    increment: () => {return ++count}, \\n    decrement: () => {return --count}, \\n    reset: () => {return count = init}\\n  };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n  var count = init;\\n  return {\\n    increment: () => {return ++count}, \\n    decrement: () => {return --count}, \\n    reset: () => {return count = init}\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494911,
                "title": "sort-easy-and-conscise-solution-using-closure-property-of-javascript",
                "content": "# Code\\n```\\nvar createCounter = function(init) {\\n    let curr = init;\\n    return { increment:()=>++curr, reset:()=>curr=init, decrement:()=>--curr};\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    let curr = init;\\n    return { increment:()=>++curr, reset:()=>curr=init, decrement:()=>--curr};\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494625,
                "title": "easily-explained-in-3-step-javascript",
                "content": "# Intuition\\nIncrese and Decrese the value by `+1` and `-1`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) In increment function use pre-increment function to increment the value at that step.\\n2) In decrement function use pre-decrement function to decrement the value ar that step.\\n3) Reset function is very important -> You should save your `init` value in a `variable`. When calling reset function make sure you first reset your `init` and then return.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` JavaSript []\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JavaSript []\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494525,
                "title": "direct-solution-beats-96",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return{\\n        increment :()=>++count,\\n        decrement :()=> --count,\\n        reset : ()=>count = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return{\\n        increment :()=>++count,\\n        decrement :()=> --count,\\n        reset : ()=>count = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497875,
                "title": "day-3-30-days-js-challenge-best-editorial-everything-explained-easy-to-understand",
                "content": "# Intuition\\nThe intuition behind this code is to create a counter object that allows you to perform three actions: $$increment$$ the counter by $$1$$, $$decrement$$ the counter by $$1$$, and $$reset$$ the counter to its initial value.\\n\\n# Approach\\nThe approach used in the code is to create a closure. The variable $$ans$$ is declared within the $$createCounter()$$ function and is assigned the initial value $$init$$. The returned object contains three functions that have access to this $$ans$$ variable through closure.\\n\\nHere\\'s an explanation of each function:\\n\\n1.$$increment()$$: This function increments the $$ans$$ variable by $$1$$ using the pre-increment operator $$(++)$$. It returns the incremented value of $$ans$$.\\n2.$$decrement()$$: This function decrements the $$ans$$ variable by $$1$$ using the pre-decrement operator $$(--)$$. It returns the decremented value of $$ans$$.\\n3.$$reset()$$: This function assigns the $$init$$ value to the $$ans$$ variable, effectively resetting it to its initial value. It does not return any value.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the $$increment()$$ and $$decrement()$$ functions is $$O(1)$$ because they only involve a single arithmetic operation. The $$reset()$$ function also has a time complexity of $$O(1)$$ as it simply assigns a value to a variable.\\n\\n- Space complexity:\\nThe space complexity of the code is $$O(1)$$ because it does not use any additional data structures that grow with the input. The $$ans$$ variable and the returned object are the only variables created, and they occupy constant space regardless of the input value.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    //creating ans variable\\n    var ans = init;\\n    //returning object to a function\\n    return{\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n$$Please \\\\space Upvote \\\\space the \\\\space Solution \\\\space if \\\\space you \\\\space liked \\\\space it...$$\\n![abc.png](https://assets.leetcode.com/users/images/8a68ea47-48e3-4005-965a-37385eb8b506_1683488530.294573.png)\\n\\n$$Thank \\\\space you \\\\space so \\\\space much...$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    //creating ans variable\\n    var ans = init;\\n    //returning object to a function\\n    return{\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497177,
                "title": "js-simplest-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param { number } init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let state = init\\n    return {\\n        increment: () => ++state,\\n        decrement: () => --state,\\n        reset: () => state = init,\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param { number } init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let state = init\\n    return {\\n        increment: () => ++state,\\n        decrement: () => --state,\\n        reset: () => state = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495324,
                "title": "beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let count = init;\\n\\n  return {\\n    increment() {\\n      count += 1;\\n      return count;\\n    },\\n    decrement() {\\n      count -= 1;\\n      return count;\\n    },\\n    reset() {\\n      count = init;\\n      return count;\\n    }\\n  };  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let count = init;\\n\\n  return {\\n    increment() {\\n      count += 1;\\n      return count;\\n    },\\n    decrement() {\\n      count -= 1;\\n      return count;\\n    },\\n    reset() {\\n      count = init;\\n      return count;\\n    }\\n  };  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494774,
                "title": "java-script-solution-for-counter-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe createCounter function initializes and returns a new Counter object with an initial value passed as a parameter.\\n\\nThe Counter class has the following methods:\\n\\nincrement(): Increases the current count by 1 and returns the updated count.\\ndecrement(): Decreases the current count by 1 and returns the updated count.\\nreset(): Resets the current count to the initial value and returns the new count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The createCounter function takes an initial value as a parameter and returns a new instance of the Counter class, initializing it with the initial value.\\n- The Counter class maintains two properties: init, which stores the initial value passed to the constructor, and currentCount, which stores the current count.\\n- The increment method increases the currentCount by 1 and returns the updated count.\\n- The decrement method decreases the currentCount by 1 and returns the updated count.\\n- The reset method resets the currentCount to the init value and returns the new count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of each method (increment, decrement, reset) is O(1) since the operations involve simple arithmetic and assignment, which take constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because the counter object stores a constant number of variables (init and currentCount), regardless of the number of operations performed.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.currentCount = init;\\n  }\\n\\n  increment() {\\n    this.currentCount += 1;\\n    return this.currentCount;\\n  }\\n\\n  decrement() {\\n    this.currentCount -= 1;\\n    return this.currentCount;\\n  }\\n\\n  reset() {\\n    this.currentCount = this.init;\\n    return this.currentCount;\\n  }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.currentCount = init;\\n  }\\n\\n  increment() {\\n    this.currentCount += 1;\\n    return this.currentCount;\\n  }\\n\\n  decrement() {\\n    this.currentCount -= 1;\\n    return this.currentCount;\\n  }\\n\\n  reset() {\\n    this.currentCount = this.init;\\n    return this.currentCount;\\n  }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494538,
                "title": "simple-solution-create-functions-and-return-object-of-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n// let val= init;\\nvar createCounter = function(init) {\\n    i=init;\\n    function increment(){\\n        i++;\\n        return i;\\n    }\\n    function decrement(){\\n        i--;\\n        return i;\\n    }\\n    function reset(){\\n        i=init;\\n        return i;\\n    }\\n    let obj={\\n        increment,\\n        decrement,\\n        reset\\n    };\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n// let val= init;\\nvar createCounter = function(init) {\\n    i=init;\\n    function increment(){\\n        i++;\\n        return i;\\n    }\\n    function decrement(){\\n        i--;\\n        return i;\\n    }\\n    function reset(){\\n        i=init;\\n        return i;\\n    }\\n    let obj={\\n        increment,\\n        decrement,\\n        reset\\n    };\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3886292,
                "title": "short-and-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835122,
                "title": "easy-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init;\\n    \\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init;\\n    \\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823102,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3640241,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const value=init;\\n    return {\\n        increment: ()=> {\\n            return ++init\\n        },\\n        decrement: ()=>{\\n           return --init\\n        },\\n        reset: ()=> {\\n            init=value\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const value=init;\\n    return {\\n        increment: ()=> {\\n            return ++init\\n        },\\n        decrement: ()=>{\\n           return --init\\n        },\\n        reset: ()=> {\\n            init=value\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567010,
                "title": "day-3-of-js-challenge-beats-92-04-easy-solution-using-arrow-functions",
                "content": "# Intuition\\nWe use arrow function inorder to print the output according to the different functions given.\\nIncrement - we add 1 to the value\\nDecrement - we subtract 1 from the value\\nreset - we print the original value\\n\\n# Approach\\nwe have declared 3 arrow functions that perform the necessary action and return the value.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    return{\\n    increment: () => { current+=1; return current;},\\n    decrement: () => { current-=1; return current;},\\n    reset: () => { current=init; return current},\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\nKindly upvote if you found it helpful! Happy learning!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    return{\\n    increment: () => { current+=1; return current;},\\n    decrement: () => { current-=1; return current;},\\n    reset: () => { current=init; return current},\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504421,
                "title": "typescript-very-fast-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Beats 90%. -->\\n\\n# Approach\\n<!-- Beats 90%. -->\\n\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let _init = init;\\n    return {\\n        increment: () => ++_init,\\n        decrement: () => --_init,\\n        reset: () => _init = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let _init = init;\\n    return {\\n        increment: () => ++_init,\\n        decrement: () => --_init,\\n        reset: () => _init = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501381,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n let current = init;\\n\\n  function increment() {\\n    return ++current;\\n  }\\n\\n  function decrement() {\\n    return --current;\\n  }\\n\\n  function reset() {\\n    current = init;\\n    return current;\\n  }\\n\\n  return { increment, decrement, reset };    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n let current = init;\\n\\n  function increment() {\\n    return ++current;\\n  }\\n\\n  function decrement() {\\n    return --current;\\n  }\\n\\n  function reset() {\\n    current = init;\\n    return current;\\n  }\\n\\n  return { increment, decrement, reset };    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496974,
                "title": "easy-javascript-solution",
                "content": "# Approach\\nThe createCounter function returns an object with three functions: increment, decrement, and reset. These functions have access to a count variable that is initialized to the value of init. Each function modifies the count variable and returns the new value.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment: function(){\\n            count++;\\n            return count;\\n        },\\n        decrement: function(){\\n            count--;\\n            return count;\\n        },\\n        reset: function(){\\n            count = init;\\n            return count;\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment: function(){\\n            count++;\\n            return count;\\n        },\\n        decrement: function(){\\n            count--;\\n            return count;\\n        },\\n        reset: function(){\\n            count = init;\\n            return count;\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496313,
                "title": "javascript-beats-81-4-if-you-believe-leetcode",
                "content": "# Intuition\\n\\nIt is based on LeetCode hint. LeetCode Hint tells you directly that you need to return the JavaScript object. Based on this knowledge I have decided to try to return JSON that will have an arrow functions depending on the keywords. \\n\\nAnd that was the solution! :)\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n\\n\\n    return {\\n        increment: () => {\\n            num++;\\n            return num;\\n        },\\n        reset: () => {\\n            num = init;\\n            return num;\\n        },\\n        decrement: () => {\\n            num--;\\n            return num;\\n        }\\n    }    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n\\n\\n    return {\\n        increment: () => {\\n            num++;\\n            return num;\\n        },\\n        reset: () => {\\n            num = init;\\n            return num;\\n        },\\n        decrement: () => {\\n            num--;\\n            return num;\\n        }\\n    }    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496058,
                "title": "closure-3-lines-in-javascript-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        \\n        let count = init\\n        return{increment: () => ++count,\\n        decrement: () => --count,\\n        reset: () => count = init,\\n        }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        \\n        let count = init\\n        return{increment: () => ++count,\\n        decrement: () => --count,\\n        reset: () => count = init,\\n        }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495786,
                "title": "easy-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var n=init\\n    return{\\n        increment:()=>++n,\\n        decrement:()=>--n,\\n        reset:()=>n=init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var n=init\\n    return{\\n        increment:()=>++n,\\n        decrement:()=>--n,\\n        reset:()=>n=init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495385,
                "title": "js-o-o",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init\\n    return {\\n        increment: function() {\\n            currentCount += 1;\\n            return currentCount;\\n        },\\n        decrement: function() {\\n            currentCount -= 1;\\n            return currentCount;\\n        },\\n        reset: function() {\\n            currentCount = init;\\n            return currentCount;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init\\n    return {\\n        increment: function() {\\n            currentCount += 1;\\n            return currentCount;\\n        },\\n        decrement: function() {\\n            currentCount -= 1;\\n            return currentCount;\\n        },\\n        reset: function() {\\n            currentCount = init;\\n            return currentCount;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495368,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIncrement, increases the value and return it,\\nDecrement, decreases the value and return it,\\nReset, return the actual value\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495310,
                "title": "easy-simple-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter = init;\\n    return {\\n        increment : ()=>{\\n            counter++;\\n            return counter;\\n        },\\n        decrement : ()=>{\\n            counter--;\\n            return counter;\\n        },\\n        reset : ()=> {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter = init;\\n    return {\\n        increment : ()=>{\\n            counter++;\\n            return counter;\\n        },\\n        decrement : ()=>{\\n            counter--;\\n            return counter;\\n        },\\n        reset : ()=> {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494785,
                "title": "day-3-happy-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n//  * @param {integer} init\\n//  * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    function increment(){\\n        count++;\\n        return count;\\n    }\\n    function decrement(){\\n        count--;\\n        return count;\\n    }\\n    function reset(){\\n        count = init;\\n        return count;\\n    }\\n    return { increment, decrement, reset };\\n};\\n    \\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n//  * @param {integer} init\\n//  * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    function increment(){\\n        count++;\\n        return count;\\n    }\\n    function decrement(){\\n        count--;\\n        return count;\\n    }\\n    function reset(){\\n        count = init;\\n        return count;\\n    }\\n    return { increment, decrement, reset };\\n};\\n    \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494767,
                "title": "how-to-approach-this-problem-three-line-typescript-code-o-1-closure",
                "content": "# Intuition\\nFor solving thing problem we are going to use closure concept. As we go through the problem, two thing is sure ->\\n\\nWe need to store starting init value in variable because when we implement reset function we need them that value.\\n\\nAnd also store current value, which will change when we call increment or decrement or reset function.\\n\\n# Approach\\n1. We are going to create two variable which will store init value and current value.\\n2. After that we will create three function increment, decrement, rest.\\n3. return these function.\\n\\n# Complexity\\n- Time complexity:\\nWe are not performing any special type of operation which depend on user input. Then we can say Time Complexity is $$O(1)$$\\n\\n- Space complexity:\\nWe are just creating two variable and it\\'s not depend user how many time call this function. Then we can Space Complexity is $$O(1)$$\\n\\n# Code\\nJavascript\\n```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    let value = init;\\n    const increment = () => ++value;\\n    const decrement = () => --value;\\n    const reset = () => (value = resetValue);\\n    return {increment,decrement,reset};\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\nTypescript\\n```typescript\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const resetValue = init;\\n    let currentValue = init;\\n    return {\\n        increment: (): number => ++currentValue,\\n        decrement: (): number => --currentValue,\\n        reset: (): number => currentValue = resetValue,\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    let value = init;\\n    const increment = () => ++value;\\n    const decrement = () => --value;\\n    const reset = () => (value = resetValue);\\n    return {increment,decrement,reset};\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\n```typescript\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const resetValue = init;\\n    let currentValue = init;\\n    return {\\n        increment: (): number => ++currentValue,\\n        decrement: (): number => --currentValue,\\n        reset: (): number => currentValue = resetValue,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494668,
                "title": "simple-easy-solution-with-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou can take a temp variable, assign it to the value of init. Then write 3 function as increment() which will increment the value by 1, reset() the will reset the value back to original, and decrement() which will decrement the value by 1. And then finaly return the temp variable; \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n      let temp=init;\\n    return {\\n        increment(){\\n            return ++temp;\\n        },\\n        decrement(){\\n            return --temp;\\n        },\\n        reset(){\\n            temp=init;\\n            return temp;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n      let temp=init;\\n    return {\\n        increment(){\\n            return ++temp;\\n        },\\n        decrement(){\\n            return --temp;\\n        },\\n        reset(){\\n            temp=init;\\n            return temp;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494562,
                "title": "easy-js-solution-with-explain-closure",
                "content": "# Intuition\\nThe goal of the problem is to create a constructor function that returns an object with methods for incrementing, decrementing, and resetting a counter value. Closures allow maintaining state between function calls.\\n\\n# Approach\\n1. Create a createCounter function with an init argument, which will initialize the starting value of the counter.\\n2. Inside the createCounter function, create a counter variable and set its value equal to init.\\n3. Return an object with increment, decrement, and reset methods, which modify the counter value accordingly and return it.\\n4. Use closure to retain the counter value between function calls.\\n\\n# Complexity\\n- Time and space complexity:\\n- O(1) - bcs it\\'s just simple math\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function () {\\n            return ++counter;\\n        },\\n        decrement: function () {\\n            return --counter;\\n        },\\n        reset: function () {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function () {\\n            return ++counter;\\n        },\\n        decrement: function () {\\n            return --counter;\\n        },\\n        reset: function () {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494501,
                "title": "closure-easy-to-understand-implementation",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {increment, decrement, reset};\\n\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {increment, decrement, reset};\\n\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3488461,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return {\\n        increment(){\\n            return ++count;\\n        },\\n        decrement(){\\n            return --count;\\n        },\\n        reset(){\\n            count=init;\\n            return count;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return {\\n        increment(){\\n            return ++count;\\n        },\\n        decrement(){\\n            return --count;\\n        },\\n        reset(){\\n            count=init;\\n            return count;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486119,
                "title": "class-based-implementation",
                "content": "\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n class Counter {\\n     constructor(init){\\n         this.initVal = init;\\n         this.val = this.initVal;\\n     }\\n\\n     increment(){\\n         return this.val+=1;\\n     }\\n\\n     decrement(){\\n         return this.val-=1;\\n     }\\n\\n     reset(){\\n         return this.val = this.initVal;\\n     }\\n }\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n class Counter {\\n     constructor(init){\\n         this.initVal = init;\\n         this.val = this.initVal;\\n     }\\n\\n     increment(){\\n         return this.val+=1;\\n     }\\n\\n     decrement(){\\n         return this.val-=1;\\n     }\\n\\n     reset(){\\n         return this.val = this.initVal;\\n     }\\n }\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484840,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const original = init\\n  const increment = () => ++init\\n  const decrement = () => --init\\n  const reset = () => init = original\\n\\n  return { increment, decrement, reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const original = init\\n  const increment = () => ++init\\n  const decrement = () => --init\\n  const reset = () => init = original\\n\\n  return { increment, decrement, reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098752,
                "title": "clean-and-easy-approach-step-wise-explanation",
                "content": "# Intuition\\nStep 1 : First read the question.\\nStep 2 : It says return an object so we use \"return {}\", curly braces are symbol of object literals.\\nStep 3 : Now an object consists of key-value pairs so, our \\'key\\' will be the \\'function name\\' and value will be the function implementation.\\nStep 4 : For the code of function implementation just follow what question demands like increment, decrement or reset.\\n\\n# Code\\n```\\nvar createCounter = function(init) {\\n    var temp = init;\\n    return {\\n        increment : function(){\\n            return ++temp;\\n        },\\n        decrement : function(){\\n            return --temp;\\n        },\\n        reset : function(){\\n            temp = init;\\n            return temp;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    var temp = init;\\n    return {\\n        increment : function(){\\n            return ++temp;\\n        },\\n        decrement : function(){\\n            return --temp;\\n        },\\n        reset : function(){\\n            temp = init;\\n            return temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097956,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var x=init;\\n    var calls={\\n         reset:function(){\\n             init=x;\\n            return init;\\n        },\\n        increment:function(){\\n    init++;\\n          return init;\\n        },\\n        decrement:function(){\\n           init--;\\n            return init;\\n        },\\n    }\\n    return calls;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var x=init;\\n    var calls={\\n         reset:function(){\\n             init=x;\\n            return init;\\n        },\\n        increment:function(){\\n    init++;\\n          return init;\\n        },\\n        decrement:function(){\\n           init--;\\n            return init;\\n        },\\n    }\\n    return calls;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096443,
                "title": "counter-ii-javascript-solution-by-bharadwaj",
                "content": "# Approach\\nFunctional\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095973,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const initialValue = init;\\n    let currentValue = init;\\n    const increment = ()  => {\\n      currentValue += 1;\\n      return currentValue;\\n    }\\n    const decrement = ()  => {\\n      currentValue -= 1;\\n      return currentValue;\\n    }\\n    const reset = ()  => {\\n      currentValue = initialValue;\\n      return currentValue;\\n    }\\n\\n    return {increment,decrement,reset};\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const initialValue = init;\\n    let currentValue = init;\\n    const increment = ()  => {\\n      currentValue += 1;\\n      return currentValue;\\n    }\\n    const decrement = ()  => {\\n      currentValue -= 1;\\n      return currentValue;\\n    }\\n    const reset = ()  => {\\n      currentValue = initialValue;\\n      return currentValue;\\n    }\\n\\n    return {increment,decrement,reset};\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094618,
                "title": "operation-counter-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const currentNum = init\\n   return {\\n    increment: ()=>{\\n        return init+=1\\n    },\\n    decrement: ()=>{\\n        return init-=1\\n    },\\n    reset: ()=>{\\n        return init = currentNum\\n    }\\n   }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const currentNum = init\\n   return {\\n    increment: ()=>{\\n        return init+=1\\n    },\\n    decrement: ()=>{\\n        return init-=1\\n    },\\n    reset: ()=>{\\n        return init = currentNum\\n    }\\n   }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094075,
                "title": "simple-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- understanding sub functions much better\\n- had to use temp: function() {} instead of temp: () => {}\\n- maybe it has something to do with arrow functions not taking in this.x?\\n\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = (init) => {\\n    return {\\n        x : init,\\n        increment: function() {\\n            this.x++;\\n            return this.x;\\n        },\\n        decrement: function()  {\\n            this.x--;\\n            return this.x;\\n        },\\n        reset: function() {\\n            this.x = init;\\n            return init;\\n        }\\n\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = (init) => {\\n    return {\\n        x : init,\\n        increment: function() {\\n            this.x++;\\n            return this.x;\\n        },\\n        decrement: function()  {\\n            this.x--;\\n            return this.x;\\n        },\\n        reset: function() {\\n            this.x = init;\\n            return init;\\n        }\\n\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091297,
                "title": "counter-ii",
                "content": "# Intuition\\nhere is a JavaScript function to create a counter object with three functions: increment(), decrement(), and reset():\\n# Approach\\nTo use the createCounter() function, simply pass in the initial value of the counter as an argument. The function will return a counter object with three functions: increment(), decrement(), and reset().\\n\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n  class Counter {\\n    constructor(init) {\\n      this.value = init;\\n    }\\n\\n    increment() {\\n      this.value += 1;\\n      return this.value;\\n    }\\n\\n    decrement() {\\n      this.value -= 1;\\n      return this.value;\\n    }\\n\\n    reset() {\\n      this.value = init;\\n      return this.value;\\n    }\\n  }\\n\\n  return new Counter(init);\\n}\\n\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n\\nFor example, the following code creates a counter object with an initial value of 5:\\n\\n```\\n const counter = createCounter(5)\\n```\\nYou can then use the increment(), decrement(), and reset() functions to modify the value of the counter:\\n\\n```\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n  class Counter {\\n    constructor(init) {\\n      this.value = init;\\n    }\\n\\n    increment() {\\n      this.value += 1;\\n      return this.value;\\n    }\\n\\n    decrement() {\\n      this.value -= 1;\\n      return this.value;\\n    }\\n\\n    reset() {\\n      this.value = init;\\n      return this.value;\\n    }\\n  }\\n\\n  return new Counter(init);\\n}\\n\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\n```\\n const counter = createCounter(5)\\n```\n```\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090026,
                "title": "short-and-easy-approach",
                "content": "\\n```\\nvar createCounter = function(init) {\\n    var initialVal = init;\\n    var currVal = init;\\n    return {\\n        increment : function(){\\n            return ++currVal;\\n        },\\n        decrement : function(){\\n            return --currVal;\\n        },\\n        reset : function(){\\n            currVal = initialVal;\\n            return currVal;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    var initialVal = init;\\n    var currVal = init;\\n    return {\\n        increment : function(){\\n            return ++currVal;\\n        },\\n        decrement : function(){\\n            return --currVal;\\n        },\\n        reset : function(){\\n            currVal = initialVal;\\n            return currVal;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088922,
                "title": "counter2-with-constraints",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088908,
                "title": "counter-with-constraints",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let count= init\\n        if (-1000 <= init <= 1000){\\n             return {\\n                 increment:()=> ++count,\\n                 reset:()=> count=init,\\n                 decrement:()=>--count\\n             }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let count= init\\n        if (-1000 <= init <= 1000){\\n             return {\\n                 increment:()=> ++count,\\n                 reset:()=> count=init,\\n                 decrement:()=>--count\\n             }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088021,
                "title": "easy-and-the-shortest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function (init) {\\n  // Creating variable\\n  let currentCount = init;\\n  // return an object\\n  return {\\n    // increment\\n    increment: () => (currentCount += 1),\\n    // decrement\\n    decrement: () => (currentCount -= 1),\\n    // reset\\n    reset: () => (currentCount = init),\\n  };\\n};\\n\\nconst counter = createCounter(5);\\nconsole.log(\\n  counter.increment(), // 6\\n  counter.reset(), // 5\\n  counter.decrement()\\n); // 4;\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function (init) {\\n  // Creating variable\\n  let currentCount = init;\\n  // return an object\\n  return {\\n    // increment\\n    increment: () => (currentCount += 1),\\n    // decrement\\n    decrement: () => (currentCount -= 1),\\n    // reset\\n    reset: () => (currentCount = init),\\n  };\\n};\\n\\nconst counter = createCounter(5);\\nconsole.log(\\n  counter.increment(), // 6\\n  counter.reset(), // 5\\n  counter.decrement()\\n); // 4;\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087506,
                "title": "neercode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084932,
                "title": "my-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let val = init;\\n    return {\\n      increment: () => ++val,\\n       decrement: () => --val,\\n       reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let val = init;\\n    return {\\n      increment: () => ++val,\\n       decrement: () => --val,\\n       reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083797,
                "title": "counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment(){\\n        return ++count;\\n    }\\n\\n    function decrement(){\\n        return --count;\\n    }\\n\\n    function reset() {\\n        count = init;\\n        return count;\\n    }\\n\\n    return{\\n        increment : increment,\\n        decrement : decrement,\\n        reset : reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment(){\\n        return ++count;\\n    }\\n\\n    function decrement(){\\n        return --count;\\n    }\\n\\n    function reset() {\\n        count = init;\\n        return count;\\n    }\\n\\n    return{\\n        increment : increment,\\n        decrement : decrement,\\n        reset : reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077733,
                "title": "counter2-simple-solution",
                "content": "# Intuition\\nThe goal of this problem is to create a counter object that has three functions: increment(), decrement(), and reset(). These functions should manipulate and return the current value of the counter based on an initial value provided when creating the counter object.\\n\\n# Approach\\nThe approach involves creating a counter object using a JavaScript function. This function takes an initial value init as a parameter and returns an object with three methods:\\n\\n-increment(): This method increases the current value of the counter by 1 and then returns the updated value.\\n\\n-decrement(): This method decreases the current value of the counter by 1 and then returns the updated value.\\n\\n-reset(): This method resets the current value of the counter to its initial value provided during object creation and returns the initial value.\\n\\nTo achieve this, we store the initial value in a separate variable (initial) inside the closure of the returned object, and the other methods (increment, decrement, and reset) manipulate and access this init value.\\n\\n# Complexity\\nThe time complexity of the increment() and decrement() methods is O(1) since they only involve simple arithmetic operations.\\n\\nThe reset() method is also O(1) because it involves a single assignment operation.\\n\\n# Space complexity:\\nThe space complexity is O(1) as we\\'re only storing a constant number of variables (init and initial) regardless of the input size.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var initial = init;\\n  return {\\n    increment: function() {\\n      init++;\\n      return init;\\n    },\\n\\n    decrement: function() {\\n      init--;\\n      return init;\\n    },\\n\\n    reset: function() {\\n      init = initial\\n      return init;\\n    }\\n  };\\n};\\n \\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var initial = init;\\n  return {\\n    increment: function() {\\n      init++;\\n      return init;\\n    },\\n\\n    decrement: function() {\\n      init--;\\n      return init;\\n    },\\n\\n    reset: function() {\\n      init = initial\\n      return init;\\n    }\\n  };\\n};\\n \\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077426,
                "title": "i-love-this-tests",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init;\\n    \\n    function increment(){\\n         count++;\\n         return count;\\n    }\\n\\n     function decrement(){\\n          count--;\\n         return  count;\\n    }\\n\\n    function reset(){\\n         count= init;\\n     return count\\n    }\\n\\nreturn {\\n    increment,\\n    decrement,\\n    reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init;\\n    \\n    function increment(){\\n         count++;\\n         return count;\\n    }\\n\\n     function decrement(){\\n          count--;\\n         return  count;\\n    }\\n\\n    function reset(){\\n         count= init;\\n     return count\\n    }\\n\\nreturn {\\n    increment,\\n    decrement,\\n    reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074243,
                "title": "it-is-solve-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072862,
                "title": "counter-problem-in-java-script-use-method-channing",
                "content": "# Intuition\\nIn this proble we have to make the three method \\n\\n# Approach\\nhere we return and object of method which have properties of function \\n\\n# Complexity\\n- Time complexity:  O(1)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return {\\n        no: init,\\n        increment : function(){\\n            this.no +=1;\\n            return this.no\\n        },\\n        decrement : function(){\\n            this.no -=1;\\n            return this.no\\n        },\\nreset : function(){\\n    this.no = init\\n     return this.no\\n        }\\n    }\\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return {\\n        no: init,\\n        increment : function(){\\n            this.no +=1;\\n            return this.no\\n        },\\n        decrement : function(){\\n            this.no -=1;\\n            return this.no\\n        },\\nreset : function(){\\n    this.no = init\\n     return this.no\\n        }\\n    }\\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072359,
                "title": "2665-counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar createCounter = function(init) {\\n    const resetVal = init;\\n    return {\\n        increment : () => ++init,\\n        decrement: () => --init,\\n        reset: () => init = resetVal,\\n    }\\n};\\nconst counter = createCounter(5)\\n console.log(counter.increment()); // 6\\n console.log(counter.reset()); // 5\\n console.log(counter.decrement()); // 4\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    const resetVal = init;\\n    return {\\n        increment : () => ++init,\\n        decrement: () => --init,\\n        reset: () => init = resetVal,\\n    }\\n};\\nconst counter = createCounter(5)\\n console.log(counter.increment()); // 6\\n console.log(counter.reset()); // 5\\n console.log(counter.decrement()); // 4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069493,
                "title": "2665-counter-ii-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var currentVal = init;\\n    const objThree = {\\n      increment: (() => {\\n        return init = init + 1\\n      }),\\n      decrement: (() => {\\n        return init = init - 1\\n      }),\\n      reset: (() => {\\n        return init = currentVal\\n      }), \\n    }\\n    \\n    return objThree;\\n};\\n\\n\\n\\nconst counter = createCounter(5)\\ncounter.increment(); // 6\\ncounter.reset(); // 5\\ncounter.decrement(); // 4\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var currentVal = init;\\n    const objThree = {\\n      increment: (() => {\\n        return init = init + 1\\n      }),\\n      decrement: (() => {\\n        return init = init - 1\\n      }),\\n      reset: (() => {\\n        return init = currentVal\\n      }), \\n    }\\n    \\n    return objThree;\\n};\\n\\n\\n\\nconst counter = createCounter(5)\\ncounter.increment(); // 6\\ncounter.reset(); // 5\\ncounter.decrement(); // 4\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069044,
                "title": "counter-ii-js-solution",
                "content": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    function increment(){\\n        num += 1\\n        return num\\n    }\\n    function reset(){\\n        num = init\\n        return num\\n    }\\n    function decrement(){\\n        num -= 1\\n        return num\\n    }\\n    return { increment, reset, decrement }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    function increment(){\\n        num += 1\\n        return num\\n    }\\n    function reset(){\\n        num = init\\n        return num\\n    }\\n    function decrement(){\\n        num -= 1\\n        return num\\n    }\\n    return { increment, reset, decrement }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 4068200,
                "title": "2-easy-ways",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   \\n    let count = init;\\n\\n    // const increment = () => ++count\\n    // const decrement = () => --count\\n    // const reset = () => {\\n    //   count = init\\n    //   return init\\n    // }\\n    // return { increment, decrement, reset}\\n\\n    \\n    //*****OR**** */\\n\\n    return {\\n      increment: () => ++count,\\n      decrement: () => --count,\\n      reset: () => count = init\\n      }\\n\\n  }\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   \\n    let count = init;\\n\\n    // const increment = () => ++count\\n    // const decrement = () => --count\\n    // const reset = () => {\\n    //   count = init\\n    //   return init\\n    // }\\n    // return { increment, decrement, reset}\\n\\n    \\n    //*****OR**** */\\n\\n    return {\\n      increment: () => ++count,\\n      decrement: () => --count,\\n      reset: () => count = init\\n      }\\n\\n  }\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067001,
                "title": "beginner-friendly-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let value = init;\\n        return {\\n        increment: () => {\\n            return ++value;\\n        },\\n        decrement: () => {\\n            return --value;\\n        },\\n        reset: () => {\\n            value = init;\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let value = init;\\n        return {\\n        increment: () => {\\n            return ++value;\\n        },\\n        decrement: () => {\\n            return --value;\\n        },\\n        reset: () => {\\n            value = init;\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062017,
                "title": "counter-ii-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init\\n    return {\\n            reset : () =>{\\n            return x = init;\\n        },\\n        increment : () =>{\\n            return ++x ;\\n        },\\n        decrement : () =>{\\n            return --x ;\\n        }, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init\\n    return {\\n            reset : () =>{\\n            return x = init;\\n        },\\n        increment : () =>{\\n            return ++x ;\\n        },\\n        decrement : () =>{\\n            return --x ;\\n        }, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060644,
                "title": "arrow-function-to-createcounter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init;\\n    return {\\n        increment: () => currentCount += 1,\\n        decrement: () => currentCount -= 1,\\n        reset: () => currentCount = init\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init;\\n    return {\\n        increment: () => currentCount += 1,\\n        decrement: () => currentCount -= 1,\\n        reset: () => currentCount = init\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060321,
                "title": "74-beats",
                "content": "# Intuition\\n74% beats\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let numbers = init;\\n    return{\\n        increment: ()=>{\\n            // numbers++;\\n            return ++numbers;\\n        },\\n        decrement: ()=>{\\n            // numbers--;\\n            return --numbers;\\n        },\\n        reset: ()=>{\\n            // numbers = init;\\n            return (numbers = init);\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let numbers = init;\\n    return{\\n        increment: ()=>{\\n            // numbers++;\\n            return ++numbers;\\n        },\\n        decrement: ()=>{\\n            // numbers--;\\n            return --numbers;\\n        },\\n        reset: ()=>{\\n            // numbers = init;\\n            return (numbers = init);\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057660,
                "title": "good-to-remember-the-difference-between-pre-post-increment-decrement",
                "content": "# Code\\n```\\nconst createCounter = (init) => {\\n  let CurrentInit = init;\\n  return {\\n    increment: () => ++CurrentInit,\\n    decrement: () => --CurrentInit,\\n    reset: () => CurrentInit = init,\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst createCounter = (init) => {\\n  let CurrentInit = init;\\n  return {\\n    increment: () => ++CurrentInit,\\n    decrement: () => --CurrentInit,\\n    reset: () => CurrentInit = init,\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055906,
                "title": "solution-with-easy-peasy-explanation",
                "content": "# Intuition\\nFor the very basic steps, you know that you need to increment init, decrement init and then have it stored in another variable so you can reset it.\\n\\n# Approach\\n2 concepts are useful here. First is closure, which means that when a function is called from inside another function, the variables of the outer functions are retained in further calls, in simpler terms, it will remember. So here, you can be carefree about accessing init variable. \\n\\nNext is Pass by Value, by default in JS, primitive data types are passed by value, so you can easily create a new variable called \"og\" (stand for original) in this case and use that to reset init. There you go, easy peasy now that you know the concepts. Happy Coding!\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nlet createCounter = function(init) {\\n    const og = init\\n    return {\\n        increment : function(){\\n            init++\\n            return init\\n        },\\n        decrement : ()=>{\\n             init--\\n             return init\\n            \\n        },\\n        reset : ()=>{\\n            init = og\\n            return init\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nlet createCounter = function(init) {\\n    const og = init\\n    return {\\n        increment : function(){\\n            init++\\n            return init\\n        },\\n        decrement : ()=>{\\n             init--\\n             return init\\n            \\n        },\\n        reset : ()=>{\\n            init = og\\n            return init\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055875,
                "title": "2665-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let curent = init;\\n    return{\\n        increment:() => ++init,\\n        decrement:() => --init,\\n        reset:() =>  init = curent\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let curent = init;\\n    return{\\n        increment:() => ++init,\\n        decrement:() => --init,\\n        reset:() =>  init = curent\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055237,
                "title": "counter-object-implementation-with-javascript",
                "content": "# Intuition\\nThe problem is to create a counter object that can be initialized with an initial value and provides methods to increment, decrement, and reset the counter.\\n\\n# Approach\\nI have implemented a closure-based approach to create the counter object. The `createCounter` function takes an initial value (`init`) and returns an object with three methods: `increment`, `decrement`, and `reset`. These methods allow manipulating the counter value as per the requirements.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity for each of the methods (`increment`, `decrement`, and `reset`) is O(1) because they involve simple arithmetic operations and assignment, which take constant time.\\n\\n\\n- Space complexity:\\nThe space complexity of the counter object created by `createCounter` is O(1). It only stores the current counter value and a few functions, which do not depend on the size of the input.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n\\n  return {\\n    increment: () => ++current,\\n    decrement: () => --current,\\n    reset: () => {\\n      current = init;\\n      return current;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n\\n  return {\\n    increment: () => ++current,\\n    decrement: () => --current,\\n    reset: () => {\\n      current = init;\\n      return current;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054209,
                "title": "easy-approch",
                "content": "# Intuition\\nThe problem is asking us to create a counter object that can increment, decrement, and reset a value. The initial value of the counter is provided as an argument when creating the counter object.\\n\\n# Approach\\nWe can approach this problem by creating a closure in JavaScript. We initialize a variable `num` with the provided initial value (`init`) and return an object with three functions: `increment`, `decrement`, and `reset`. These functions modify and return the `num` variable accordingly.\\n\\n- `increment` function: This function increments the `num` variable by 1 and returns the new value.\\n- `decrement` function: This function decrements the `num` variable by 1 and returns the new value.\\n- `reset` function: This function sets the `num` variable back to its initial value (`init`) and returns that value.\\n\\n# Complexity\\n- Time complexity: All three operations (increment, decrement, reset) have a time complexity of O(1) because they involve simple arithmetic operations on a single variable.\\n- Space complexity: The space complexity is O(1) as we only use a single variable `num` and a few function references.\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: function() {\\n            return ++num;\\n        },\\n        decrement: function() {\\n            return --num;\\n        },\\n        reset: function() {\\n            num = init;\\n            return num;\\n        }\\n    }\\n};\\n\\n/**\\n * Example usage:\\n * const counter = createCounter(5);\\n * console.log(counter.increment()); // Output: 6\\n * console.log(counter.reset());     // Output: 5\\n * console.log(counter.decrement()); // Output: 4\\n */\\n```\\n\\nYou can create a counter object with an initial value, use the `increment`, `decrement`, and `reset` functions as shown in the example usage, and observe how the counter behaves.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: function() {\\n            return ++num;\\n        },\\n        decrement: function() {\\n            return --num;\\n        },\\n        reset: function() {\\n            num = init;\\n            return num;\\n        }\\n    }\\n};\\n\\n/**\\n * Example usage:\\n * const counter = createCounter(5);\\n * console.log(counter.increment()); // Output: 6\\n * console.log(counter.reset());     // Output: 5\\n * console.log(counter.decrement()); // Output: 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047863,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init\\n    return {\\n        increment:() => {\\n            count++\\n            return count\\n        },\\n        decrement:() => {\\n            count--\\n            return count\\n        },\\n        reset:() => {\\n            count = init\\n            return count\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init\\n    return {\\n        increment:() => {\\n            count++\\n            return count\\n        },\\n        decrement:() => {\\n            count--\\n            return count\\n        },\\n        reset:() => {\\n            count = init\\n            return count\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046850,
                "title": "creating-a-counter-object-in-javascript-with-pre-increment-pre-decrement-and-reset-functions",
                "content": "# Intuition\\n<!-- Provide a brief description of your initial thoughts and strategies for solving this problem. -->\\n\\nThe goal of this problem is to create a counter object that can be incremented, decremented, and reset to its initial value. To achieve this, we can use a closure in JavaScript to encapsulate the current value of the counter.\\n\\n# Approach\\n<!-- Describe the approach you took to solve the problem. -->\\n\\nI used a closure to create a `createCounter` function that takes an initial value and returns an object with three methods:\\n1. `increment`: Increments the counter by 1 using pre-increment.\\n2. `decrement`: Decrements the counter by 1 using pre-decrement.\\n3. `reset`: Resets the counter to its initial value and returns the reset value.\\n\\nUsing pre-increment and pre-decrement ensures that the counter is updated before returning the new value, providing the desired behavior.\\n\\nAdditionally, I chose to reset the counter to its initial value first and then return the reset value in the `reset` method. This design choice simplifies the usage of the `reset` function. By resetting first, you can immediately access the reset value without the need for additional steps. This aligns with the principle of making functions as straightforward and predictable as possible.\\n\\n# Complexity\\n- Time complexity: O(1)\\n  - The time complexity of each method (increment, decrement, and reset) is O(1) because they involve simple arithmetic operations that take a constant amount of time.\\n\\n- Space complexity: O(1)\\n  - The space complexity of the `createCounter` function is O(1) because it only creates a single object with three methods and a single variable (`currentValue`) regardless of the input.\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init - The initial value of the counter.\\n * @return {Object} - An object with increment, decrement, and reset methods.\\n */\\nvar createCounter = function (init) {\\n    let currentValue = init; // Initialize the currentValue with the provided initial value.\\n    return {\\n        increment: () => ++currentValue, // Increment the currentValue and return the new value using pre-increment.\\n        decrement: () => --currentValue, // Decrement the currentValue and return the new value using pre-decrement.\\n        reset: () => {\\n            currentValue = init; // Reset the currentValue to the initial value first.\\n            return currentValue; // Return the reset value.\\n        }\\n    }\\n};\\n\\n// Example usage:\\nconst counter = createCounter(5);\\nconsole.log(counter.increment()); // Output: 6\\nconsole.log(counter.reset()); // Output: 5\\nconsole.log(counter.decrement()); // Output: 4\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\n<!-- Provide a brief description of your initial thoughts and strategies for solving this problem. -->\\n\\nThe goal of this problem is to create a counter object that can be incremented, decremented, and reset to its initial value. To achieve this, we can use a closure in JavaScript to encapsulate the current value of the counter.\\n\\n# Approach\\n<!-- Describe the approach you took to solve the problem. -->\\n\\nI used a closure to create a `createCounter` function that takes an initial value and returns an object with three methods:\\n1. `increment`: Increments the counter by 1 using pre-increment.\\n2. `decrement`: Decrements the counter by 1 using pre-decrement.\\n3. `reset`: Resets the counter to its initial value and returns the reset value.\\n\\nUsing pre-increment and pre-decrement ensures that the counter is updated before returning the new value, providing the desired behavior.\\n\\nAdditionally, I chose to reset the counter to its initial value first and then return the reset value in the `reset` method. This design choice simplifies the usage of the `reset` function. By resetting first, you can immediately access the reset value without the need for additional steps. This aligns with the principle of making functions as straightforward and predictable as possible.\\n\\n# Complexity\\n- Time complexity: O(1)\\n  - The time complexity of each method (increment, decrement, and reset) is O(1) because they involve simple arithmetic operations that take a constant amount of time.\\n\\n- Space complexity: O(1)\\n  - The space complexity of the `createCounter` function is O(1) because it only creates a single object with three methods and a single variable (`currentValue`) regardless of the input.\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init - The initial value of the counter.\\n * @return {Object} - An object with increment, decrement, and reset methods.\\n */\\nvar createCounter = function (init) {\\n    let currentValue = init; // Initialize the currentValue with the provided initial value.\\n    return {\\n        increment: () => ++currentValue, // Increment the currentValue and return the new value using pre-increment.\\n        decrement: () => --currentValue, // Decrement the currentValue and return the new value using pre-decrement.\\n        reset: () => {\\n            currentValue = init; // Reset the currentValue to the initial value first.\\n            return currentValue; // Return the reset value.\\n        }\\n    }\\n};\\n\\n// Example usage:\\nconst counter = createCounter(5);\\nconsole.log(counter.increment()); // Output: 6\\nconsole.log(counter.reset()); // Output: 5\\nconsole.log(counter.decrement()); // Output: 4\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4044929,
                "title": "counter-ii-using-pre-increment",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Take an object as return statement\\n2. Have three **Key:Value** pairs, having names increment, decrement, reset\\n3. Use **Pre increment to first execute the operation and then return value** rather than preincrement\\n\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentVal = init\\n    return {\\n        increment: () => ++presentVal,\\n        decrement: () => --presentVal,\\n        reset: () => presentVal = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentVal = init\\n    return {\\n        increment: () => ++presentVal,\\n        decrement: () => --presentVal,\\n        reset: () => presentVal = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041750,
                "title": "easy-approach",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init\\n    \\n    return {\\n        reset: () => value = init,\\n        increment: () => ++value,\\n        decrement: () => --value\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init\\n    \\n    return {\\n        reset: () => value = init,\\n        increment: () => ++value,\\n        decrement: () => --value\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040316,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentVal = init;\\n    return {\\n        increment: () => {\\n            return ++currentVal;\\n        },\\n        decrement: () => {\\n            return --currentVal;\\n        },\\n        reset: () => {\\n            currentVal = init;\\n            return currentVal;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentVal = init;\\n    return {\\n        increment: () => {\\n            return ++currentVal;\\n        },\\n        decrement: () => {\\n            return --currentVal;\\n        },\\n        reset: () => {\\n            currentVal = init;\\n            return currentVal;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039671,
                "title": "counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n   var createCounter = function(init) {\\n       let i = init;\\n  return {\\n      increment() {\\n          return ++i;\\n      },\\ndecrement() {\\n          return --i;\\n      },\\n       reset(){\\n            i = init;\\n            return i;\\n        }\\n\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n   var createCounter = function(init) {\\n       let i = init;\\n  return {\\n      increment() {\\n          return ++i;\\n      },\\ndecrement() {\\n          return --i;\\n      },\\n       reset(){\\n            i = init;\\n            return i;\\n        }\\n\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038154,
                "title": "simple-and-easy-to-understand",
                "content": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  let n = init;\\n  return {\\n    increment: () => {\\n      return ++n;\\n    },\\n    decrement: () => {\\n      return --n;\\n    },\\n    reset: () => {\\n      n = init;\\n      return n;\\n    }\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  let n = init;\\n  return {\\n    increment: () => {\\n      return ++n;\\n    },\\n    decrement: () => {\\n      return --n;\\n    },\\n    reset: () => {\\n      n = init;\\n      return n;\\n    }\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037426,
                "title": "javascript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original = init\\n    return {\\n        increment() {\\n            init++\\n            return init\\n        },\\n        reset() {\\n            init = original\\n            return init\\n        },\\n        decrement() {\\n            init--\\n            return init\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original = init\\n    return {\\n        increment() {\\n            init++\\n            return init\\n        },\\n        reset() {\\n            init = original\\n            return init\\n        },\\n        decrement() {\\n            init--\\n            return init\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037329,
                "title": "easy-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init;\\n    function increment() {\\n        x = x+1;\\n        return x\\n    };\\n    function decrement() {\\n        x = x-1;\\n        return x\\n    };\\n\\n    function reset(){\\n        x = init;\\n        return x\\n    };\\n\\n    return { increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init;\\n    function increment() {\\n        x = x+1;\\n        return x\\n    };\\n    function decrement() {\\n        x = x-1;\\n        return x\\n    };\\n\\n    function reset(){\\n        x = init;\\n        return x\\n    };\\n\\n    return { increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035108,
                "title": "simple-js-solution",
                "content": "```\\nvar createCounter = function(init) {\\n    var val = init;\\n    return {\\n        increment: () => {\\n            return ++val;\\n        },\\n        decrement: () => {\\n            return --val;\\n        },\\n        reset: () => {\\n            val = init;\\n            return val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    var val = init;\\n    return {\\n        increment: () => {\\n            return ++val;\\n        },\\n        decrement: () => {\\n            return --val;\\n        },\\n        reset: () => {\\n            val = init;\\n            return val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034990,
                "title": "much-easiest-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a=init;\\n    function increment(){\\n        return ++a\\n    }\\n    function decrement(){\\n        return --a\\n    }\\n    function reset(){\\n        return a=init\\n    }\\n    return{increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a=init;\\n    function increment(){\\n        return ++a\\n    }\\n    function decrement(){\\n        return --a\\n    }\\n    function reset(){\\n        return a=init\\n    }\\n    return{increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034374,
                "title": "js-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n    let startNumber = init;\\n\\n    return {\\n        increment: () => startNumber += 1,\\n        decrement: () => startNumber -= 1,\\n        reset: () => startNumber = init,\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n    let startNumber = init;\\n\\n    return {\\n        increment: () => startNumber += 1,\\n        decrement: () => startNumber -= 1,\\n        reset: () => startNumber = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034021,
                "title": "js-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    const x = init;\\n    return {\\n        increment: function() {\\n            return ++init;\\n        },\\n        decrement: function() {\\n            return --init;\\n        },\\n        reset: function() {\\n            init = x;\\n            return init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    const x = init;\\n    return {\\n        increment: function() {\\n            return ++init;\\n        },\\n        decrement: function() {\\n            return --init;\\n        },\\n        reset: function() {\\n            init = x;\\n            return init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033889,
                "title": "counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original=init\\n    let value=init\\n    return {\\n        increment:()=>{\\n            value+=1\\n            return value\\n        },\\n        reset:()=>{\\n            value=original\\n            return value\\n        },\\n        decrement:()=>{\\n            value-=1\\n            return value\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original=init\\n    let value=init\\n    return {\\n        increment:()=>{\\n            value+=1\\n            return value\\n        },\\n        reset:()=>{\\n            value=original\\n            return value\\n        },\\n        decrement:()=>{\\n            value-=1\\n            return value\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029317,
                "title": "outplay-99-69-memory",
                "content": "# Approach\\n`inc` increased and returned init\\n`dec` decreased and returned init\\n`reset` converted init to the og value\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return {\\n        increment:()=> ++init,\\n        decrement:()=>--init,\\n        reset:()=>init=c\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return {\\n        increment:()=> ++init,\\n        decrement:()=>--init,\\n        reset:()=>init=c\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027377,
                "title": "best-js-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let num = init;\\n    return {\\n        \"increment\": () => ++num,\\n        \"decrement\": () => --num,\\n        \"reset\": () => {num = init; return init}\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let num = init;\\n    return {\\n        \"increment\": () => ++num,\\n        \"decrement\": () => --num,\\n        \"reset\": () => {num = init; return init}\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025475,
                "title": "counter",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let currVal = init;\\n    return {\\n        increment: () => {\\n            currVal++;\\n            return currVal;\\n        },\\n        reset: () => {\\n            currVal = init;\\n            return currVal;\\n        },\\n        decrement: () => {\\n            currVal--;\\n            return currVal;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let currVal = init;\\n    return {\\n        increment: () => {\\n            currVal++;\\n            return currVal;\\n        },\\n        reset: () => {\\n            currVal = init;\\n            return currVal;\\n        },\\n        decrement: () => {\\n            currVal--;\\n            return currVal;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022641,
                "title": "counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021430,
                "title": "simple-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return {\\n        increment: () => {\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: () => {\\n            currentValue = currentValue - 1;\\n            return currentValue;\\n        },\\n        reset: () => {\\n            currentValue = init;\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return {\\n        increment: () => {\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: () => {\\n            currentValue = currentValue - 1;\\n            return currentValue;\\n        },\\n        reset: () => {\\n            currentValue = init;\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021108,
                "title": "best-way-for-reset-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a= init;\\n    return{\\n        increment : function(){\\n            return ++a;\\n        },\\n        reset : function(){\\n            a= init;\\n            return a;\\n        },\\n        decrement : function(){\\n            return --a;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a= init;\\n    return{\\n        increment : function(){\\n            return ++a;\\n        },\\n        reset : function(){\\n            a= init;\\n            return a;\\n        },\\n        decrement : function(){\\n            return --a;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020985,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    class Count {\\n            constructor() {\\n                this.init = init;\\n            }\\n\\n            increment() {\\n                this.init++;\\n                return this.init;\\n            }\\n\\n            decrement() {\\n                this.init--;\\n                return this.init;\\n            }\\n\\n            reset() {\\n                this.init = init;\\n                return this.init;\\n            }\\n        }\\n\\n    return new Count;\\n};\\n\\nconst counter = new createCounter(10);\\nconsole.log(counter.increment());\\nconsole.log(counter.reset());\\nconsole.log(counter.decrement());\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    class Count {\\n            constructor() {\\n                this.init = init;\\n            }\\n\\n            increment() {\\n                this.init++;\\n                return this.init;\\n            }\\n\\n            decrement() {\\n                this.init--;\\n                return this.init;\\n            }\\n\\n            reset() {\\n                this.init = init;\\n                return this.init;\\n            }\\n        }\\n\\n    return new Count;\\n};\\n\\nconst counter = new createCounter(10);\\nconsole.log(counter.increment());\\nconsole.log(counter.reset());\\nconsole.log(counter.decrement());\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020606,
                "title": "solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter=init;\\n    return{\\n        increment:function(){\\n            return ++counter;\\n        },\\n        reset:function(){\\n            counter=init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            return --counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter=init;\\n    return{\\n        increment:function(){\\n            return ++counter;\\n        },\\n        reset:function(){\\n            counter=init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            return --counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020054,
                "title": "counter-using-ts-and-js-fully-explained",
                "content": "# Approach\\n1- capture init (integer) and store it in a new variable\\n2- storing in new variable helps you reset the state to orignal else you will end up in getting the wring answer.\\n3- then on each function return the expected result \\n4- for information newVal+=1 === newVal++\\n5- REad the commented code also\\n6- there you see how we are storing simple integer in array\\n7- thats it...\\n\\n# TYPESCRIPT\\n\\n# Code\\n```ts\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let newVal = init;\\n    function increment (){\\n        return newVal +=1\\n    }\\n    function decrement (){\\n        return newVal -=1\\n    }\\n    function reset (){\\n        newVal = init;\\n        return newVal\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n```\\n\\n# JAVASCRIPT\\n\\n# Code\\n```js\\nconst createCounter = (init) => {\\n  let newVal  = init\\n  function increase() {    \\n    return newVal+=1;\\n  }\\n  function decrease() {\\n    return newVal-=1;\\n  }\\n  function reset() {    \\n    newVal= init\\n    return init;\\n  }\\n\\n  return {\\n    increase,\\n    decrease,\\n    reset,\\n  };\\n};\\n/*\\nconst init = 0;\\nconst counter = createCounter(init);\\nconst result = [];\\nresult.push(counter.increase());\\nresult.push(counter.increase());\\nresult.push(counter.decrease());\\nresult.push(counter.reset());\\nresult.push(counter.reset());\\nconsole.log(\"\\uD83D\\uDE80 ~ file: app.js:26 ~ result:\", result) -->\\n*/\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let newVal = init;\\n    function increment (){\\n        return newVal +=1\\n    }\\n    function decrement (){\\n        return newVal -=1\\n    }\\n    function reset (){\\n        newVal = init;\\n        return newVal\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n```\n```js\\nconst createCounter = (init) => {\\n  let newVal  = init\\n  function increase() {    \\n    return newVal+=1;\\n  }\\n  function decrease() {\\n    return newVal-=1;\\n  }\\n  function reset() {    \\n    newVal= init\\n    return init;\\n  }\\n\\n  return {\\n    increase,\\n    decrease,\\n    reset,\\n  };\\n};\\n/*\\nconst init = 0;\\nconst counter = createCounter(init);\\nconst result = [];\\nresult.push(counter.increase());\\nresult.push(counter.increase());\\nresult.push(counter.decrease());\\nresult.push(counter.reset());\\nresult.push(counter.reset());\\nconsole.log(\"\\uD83D\\uDE80 ~ file: app.js:26 ~ result:\", result) -->\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016831,
                "title": "simplest-code",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    \\n    function reset () {\\n        counter = init\\n        return counter\\n    }\\n\\n    return {\\n        increment: ()=> ++counter,\\n        decrement: ()=> --counter,\\n        reset: ()=> reset()\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    \\n    function reset () {\\n        counter = init\\n        return counter\\n    }\\n\\n    return {\\n        increment: ()=> ++counter,\\n        decrement: ()=> --counter,\\n        reset: ()=> reset()\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014396,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {\\n       increment,\\n       decrement,\\n       reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {\\n       increment,\\n       decrement,\\n       reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013390,
                "title": "javascript-detailed-explaination-easy-to-understand",
                "content": "# Intuition\\nThe `createCounter` function is designed to create a counter object with an initial value `init`. This counter object has three methods: `increment`, `decrement`, and `reset`, which respectively increase the value by 1, decrease the value by 1, and reset the value to the initial `init`.\\n\\n# Approach\\nWe have implemented the `createCounter` function that returns an object with three methods:\\n1. `increment()`: This method increments the `value` property of the counter object by 1 and then returns the updated value.\\n\\n2. `decrement()`: This method decrements the `value` property of the counter object by 1 and then returns the updated value.\\n\\n3. `reset()`: This method sets the `value` property of the counter object back to the initial `init` value and then returns the updated value.\\n\\nWe\\'ve used the `this` keyword to access the `value` property within each method.\\n\\n# Complexity\\n- Time complexity: All three methods, `increment`, `decrement`, and `reset`, have constant time complexity, i.e., O(1), as they perform simple value updates.\\n\\n- Space complexity: The `createCounter` function returns an object with three methods, but their memory usage is negligible. Therefore, the space complexity is also O(1).\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init\\n * @return {Object}\\n */\\nvar createCounter = function(init) {\\n    return {\\n        value: init,\\n        increment() {\\n            return ++this.value;\\n        },\\n        decrement() {\\n            return --this.value;\\n        },\\n        reset() {\\n            this.value = init;\\n            return this.value;\\n        }\\n    };\\n};\\n\\n// Example usages:\\nconst counter1 = createCounter(5);\\nconsole.log(counter1.increment()); // 6\\nconsole.log(counter1.reset()); // 5\\nconsole.log(counter1.decrement()); // 4\\n\\nconst counter2 = createCounter(0);\\nconsole.log(counter2.increment()); // 1\\nconsole.log(counter2.increment()); // 2\\nconsole.log(counter2.decrement()); // 1\\nconsole.log(counter2.reset()); // 0\\nconsole.log(counter2.reset()); // 0\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {integer} init\\n * @return {Object}\\n */\\nvar createCounter = function(init) {\\n    return {\\n        value: init,\\n        increment() {\\n            return ++this.value;\\n        },\\n        decrement() {\\n            return --this.value;\\n        },\\n        reset() {\\n            this.value = init;\\n            return this.value;\\n        }\\n    };\\n};\\n\\n// Example usages:\\nconst counter1 = createCounter(5);\\nconsole.log(counter1.increment()); // 6\\nconsole.log(counter1.reset()); // 5\\nconsole.log(counter1.decrement()); // 4\\n\\nconst counter2 = createCounter(0);\\nconsole.log(counter2.increment()); // 1\\nconsole.log(counter2.increment()); // 2\\nconsole.log(counter2.decrement()); // 1\\nconsole.log(counter2.reset()); // 0\\nconsole.log(counter2.reset()); // 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012651,
                "title": "counter-ii-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let rs = init, curr = init;\\n    var op = {\\n        \"increment\": function() {\\n            return ++curr;\\n        },\\n        \"decrement\": function() {\\n            return --curr;\\n        },\\n        \"reset\": function() {\\n            curr = rs;\\n            return curr;\\n        }\\n    };\\n    return op;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let rs = init, curr = init;\\n    var op = {\\n        \"increment\": function() {\\n            return ++curr;\\n        },\\n        \"decrement\": function() {\\n            return --curr;\\n        },\\n        \"reset\": function() {\\n            curr = rs;\\n            return curr;\\n        }\\n    };\\n    return op;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010139,
                "title": "object-return",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let restore=init;\\n    return {\\n        increment:()=>{\\n        return restore+=1;\\n        },\\n        decrement:()=>{\\n         return restore-=1;\\n        },\\n        reset:()=>{\\n         return restore=init;\\n\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let restore=init;\\n    return {\\n        increment:()=>{\\n        return restore+=1;\\n        },\\n        decrement:()=>{\\n         return restore-=1;\\n        },\\n        reset:()=>{\\n         return restore=init;\\n\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009954,
                "title": "simple-solution-with-explanation",
                "content": "# Explanation\\n\\nBy Looking at the example, we know createCounter should return an object that has three attributes i.e. `increment`, `decrement`, and `reset`. Since `reset` has to reset the value to the initial value passed, we should create a reference to the initial value before we increase or decrease.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let initVal = init;\\n\\n  return {\\n    increment: () => {\\n      return ++initVal;\\n    },\\n    reset: () => {\\n      initVal = init;\\n      return initVal;\\n    },\\n    decrement: () => {\\n      return --initVal;\\n    },\\n  };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let initVal = init;\\n\\n  return {\\n    increment: () => {\\n      return ++initVal;\\n    },\\n    reset: () => {\\n      initVal = init;\\n      return initVal;\\n    },\\n    decrement: () => {\\n      return --initVal;\\n    },\\n  };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006921,
                "title": "easy-must-check-this",
                "content": "# Intuition\\nWe need function that  returns an object with three methods: increment, decrement, and reset. When you call these methods, they perform the respective operations and return the updated current value.\\n\\n# Approach\\nThis function returns an object with three methods: increment, decrement, and reset. When you call these methods, they perform the respective operations and return the updated current value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let currentValue = init;\\n return {\\n    increment: function () {\\n      currentValue++;\\n      return currentValue;\\n    },\\n    decrement: function () {\\n      currentValue--;\\n      return currentValue;\\n    },\\n    reset: function () {\\n      currentValue = init;\\n      return currentValue;\\n    },\\n\\n   } \\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n![killlakill-upvote.gif](https://assets.leetcode.com/users/images/ef409f66-3cf5-4d30-a804-afa8f9af9870_1693939067.415885.gif)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let currentValue = init;\\n return {\\n    increment: function () {\\n      currentValue++;\\n      return currentValue;\\n    },\\n    decrement: function () {\\n      currentValue--;\\n      return currentValue;\\n    },\\n    reset: function () {\\n      currentValue = init;\\n      return currentValue;\\n    },\\n\\n   } \\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006827,
                "title": "2-simple-and-easy-javascript-solution",
                "content": "# Code\\n1st approach -->\\n```\\n// Runtime 59ms Beats 67.12% of users\\n// Memory 44.28MB Beats 81.87% of users\\nvar createCounter = function(init) {\\n    let num = init;\\n    let obj = {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n    \\n    return obj;\\n};\\n\\n```\\n2nd approach -->\\n```\\n// Runtime 50ms Beats 94.63% of users\\n// Memory 44.10MB Beats 91.99% of users\\nlet createCounter = function(init) {\\n    let i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Runtime 59ms Beats 67.12% of users\\n// Memory 44.28MB Beats 81.87% of users\\nvar createCounter = function(init) {\\n    let num = init;\\n    let obj = {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n    \\n    return obj;\\n};\\n\\n```\n```\\n// Runtime 50ms Beats 94.63% of users\\n// Memory 44.10MB Beats 91.99% of users\\nlet createCounter = function(init) {\\n    let i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005439,
                "title": "this-is-simple-here-we-are-setting-a-value-and-then-increment-and-decrement-using-arrow-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let i=0;\\n     return{\\n          increment:()=>init + ++i,\\n          decrement:()=>init + --i,\\n          reset:()=> {i=0;\\n          return init ;\\n          }\\n          \\n     }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let i=0;\\n     return{\\n          increment:()=>init + ++i,\\n          decrement:()=>init + --i,\\n          reset:()=> {i=0;\\n          return init ;\\n          }\\n          \\n     }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004243,
                "title": "counter-using-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    //store the initial value on another value in case of reset function\\n\\n    let initval = init\\n\\n    //the required functions \\n\\n    return {\\n        increment: ()=> ++init,\\n        decrement : () => --init,\\n        reset: ()=> init = initval\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    //store the initial value on another value in case of reset function\\n\\n    let initval = init\\n\\n    //the required functions \\n\\n    return {\\n        increment: ()=> ++init,\\n        decrement : () => --init,\\n        reset: ()=> init = initval\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000896,
                "title": "javascript-method-chaining",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->can Do using method chaining approach.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let newInt = init;\\n    return {\\n        increment: ()=> {\\nnewInt+=1;\\n            return newInt;\\n        },\\n        reset:()=>{\\n           newInt=init;\\n            return newInt;\\n        },\\n        decrement: ()=>{\\n            newInt-=1;\\n            return newInt;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let newInt = init;\\n    return {\\n        increment: ()=> {\\nnewInt+=1;\\n            return newInt;\\n        },\\n        reset:()=>{\\n           newInt=init;\\n            return newInt;\\n        },\\n        decrement: ()=>{\\n            newInt-=1;\\n            return newInt;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999105,
                "title": "normal-day-in-developers-life",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let cnt = init ;\\n    return {\\n        increment(){\\n            return ++cnt\\n        },\\n        decrement(){\\n            return --cnt\\n        },\\n        reset(){\\n            return cnt = init\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let cnt = init ;\\n    return {\\n        increment(){\\n            return ++cnt\\n        },\\n        decrement(){\\n            return --cnt\\n        },\\n        reset(){\\n            return cnt = init\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998338,
                "title": "3-lines-javascript-code-for-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let temp = init;\\n    return{\\n        increment: () => init+=1,\\n        decrement:() => init-=1,\\n        reset: () => init = temp\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let temp = init;\\n    return{\\n        increment: () => init+=1,\\n        decrement:() => init-=1,\\n        reset: () => init = temp\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998099,
                "title": "to-the-point-and-straight-to-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n=init; \\n    let count={increment : function inc(){\\n       return ++n;\\n    },decrement : function dec(){\\n     return --n;\\n\\n    },\\n    reset : function reset(){\\n        return (n=init);\\n    }}\\n    return count;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n=init; \\n    let count={increment : function inc(){\\n       return ++n;\\n    },decrement : function dec(){\\n     return --n;\\n\\n    },\\n    reset : function reset(){\\n        return (n=init);\\n    }}\\n    return count;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997967,
                "title": "counter-ii-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current_count =init;\\n    return {\\n        increment:function(){\\n            return ++current_count;\\n        },\\n        decrement:function(){\\n            return --current_count;\\n        },\\n        reset:function(){\\n            return (current_count =init);\\n        }\\n\\n    }\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current_count =init;\\n    return {\\n        increment:function(){\\n            return ++current_count;\\n        },\\n        decrement:function(){\\n            return --current_count;\\n        },\\n        reset:function(){\\n            return (current_count =init);\\n        }\\n\\n    }\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996340,
                "title": "ok",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    \\n    let counter= init;\\n    const object = {\\n        \\n        increment:function(){\\n            counter++;\\n            return counter;\\n        },\\n        reset:function(){\\n            counter= init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            counter--;\\n            return counter;\\n        }\\n    \\n    }\\n        \\n      return object;  \\n    \\n};\\n\\ntry{\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n counter.reset(); // 5\\n  counter.decrement(); // 4\\n}catch(e){\\n    console.log(e.message)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    \\n    let counter= init;\\n    const object = {\\n        \\n        increment:function(){\\n            counter++;\\n            return counter;\\n        },\\n        reset:function(){\\n            counter= init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            counter--;\\n            return counter;\\n        }\\n    \\n    }\\n        \\n      return object;  \\n    \\n};\\n\\ntry{\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n counter.reset(); // 5\\n  counter.decrement(); // 4\\n}catch(e){\\n    console.log(e.message)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996231,
                "title": "javascript-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let initialValue = init;\\n    return {\\n        increment: ()=>{\\n            init = init+1\\n            return init \\n        },\\n        decrement: ()=> {\\n            init = init-1\\n            return init \\n        },\\n        reset: ()=> {\\n            init = initialValue\\n            return init \\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let initialValue = init;\\n    return {\\n        increment: ()=>{\\n            init = init+1\\n            return init \\n        },\\n        decrement: ()=> {\\n            init = init-1\\n            return init \\n        },\\n        reset: ()=> {\\n            init = initialValue\\n            return init \\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990723,
                "title": "easy-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num+1,\\n        reset: () => num = init,\\n        decrement: () => num = num-1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num+1,\\n        reset: () => num = init,\\n        decrement: () => num = num-1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985409,
                "title": "ans-2665",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment () {\\n        return ++count\\n\\n    }\\n    function decrement() {\\n         return --count\\n\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }   \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment () {\\n        return ++count\\n\\n    }\\n    function decrement() {\\n         return --count\\n\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }   \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985110,
                "title": "counter-ii",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let current = init\\n    return {\\n        increment: function () {\\n            current += 1;\\n            return current;\\n        },\\n        decrement: function () {\\n            current -= 1;\\n            return current;\\n        },\\n        reset: function () {\\n            current = init;\\n            return current;\\n        }\\n    }\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math"
                ],
                "code": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let current = init\\n    return {\\n        increment: function () {\\n            current += 1;\\n            return current;\\n        },\\n        decrement: function () {\\n            current -= 1;\\n            return current;\\n        },\\n        reset: function () {\\n            current = init;\\n            return current;\\n        }\\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3982547,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have to keep the `init` value for `reset`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, I stored the `init` value in `n`. And I implement three functions. In particular, I include initialization process in `reset()`.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    let n = init;\\n\\n    return {\\n        increment(){\\n            return ++n;\\n        },\\n        decrement(){\\n            return --n;\\n        },\\n        reset(){\\n            return n = init;\\n        }\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    let n = init;\\n\\n    return {\\n        increment(){\\n            return ++n;\\n        },\\n        decrement(){\\n            return --n;\\n        },\\n        reset(){\\n            return n = init;\\n        }\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982004,
                "title": "use-the-some-variable-for-the-storing-the-value-before-the-return-statement",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    general=init\\n    return {\\n        increment: () => {\\n            general++\\n            return general;\\n        }, reset : ()=>{\\n            general=init;\\n            return general;\\n        },\\n        decrement: () => {\\n              general--\\n             \\n             return general\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    general=init\\n    return {\\n        increment: () => {\\n            general++\\n            return general;\\n        }, reset : ()=>{\\n            general=init;\\n            return general;\\n        },\\n        decrement: () => {\\n              general--\\n             \\n             return general\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981724,
                "title": "js-beats-78-of-coders-simplest-easiest-optimal-solution-using-arrow-function",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let pre = init;\\n    return {\\n        increment: () => ++pre,\\n        decrement: () => --pre,\\n        reset: () => pre = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let pre = init;\\n    return {\\n        increment: () => ++pre,\\n        decrement: () => --pre,\\n        reset: () => pre = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979308,
                "title": "johnny",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    let totalCalls = 0;\\n    const initFix = init;\\n    if(-1000 <= init || init <= 1000){\\n        if(++totalCalls > 1000){ return \"total calls not to exceed 1000\"; }\\n        return {\\n            increment: function(){\\n                return ++current;\\n            }, \\n            decrement: function(){\\n                return --current;\\n            }, \\n            reset: function (){\\n                current = initFix;\\n                return current;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    let totalCalls = 0;\\n    const initFix = init;\\n    if(-1000 <= init || init <= 1000){\\n        if(++totalCalls > 1000){ return \"total calls not to exceed 1000\"; }\\n        return {\\n            increment: function(){\\n                return ++current;\\n            }, \\n            decrement: function(){\\n                return --current;\\n            }, \\n            reset: function (){\\n                current = initFix;\\n                return current;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978873,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let r=init;\\n    return {\\n        increment:function(){\\n            return ++r;\\n        },\\n        reset:function(){\\n            r=init;\\n            return r;\\n        },\\n        decrement:function(){\\n            return --r;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let r=init;\\n    return {\\n        increment:function(){\\n            return ++r;\\n        },\\n        reset:function(){\\n            r=init;\\n            return r;\\n        },\\n        decrement:function(){\\n            return --r;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978183,
                "title": "nice",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nlet i = init\\n    return {\\n    increment: ()=>{\\n   return ++i\\n    },\\n    decrement: ()=>{\\n    return --i\\n    },\\n    reset: ()=>{\\n    return i = init\\n    }}};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nlet i = init\\n    return {\\n    increment: ()=>{\\n   return ++i\\n    },\\n    decrement: ()=>{\\n    return --i\\n    },\\n    reset: ()=>{\\n    return i = init\\n    }}};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977579,
                "title": "counter-ii-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977571,
                "title": "counter-ii-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973195,
                "title": "concept-of-closures-and-objects-in-js",
                "content": "# Intuition\\nremember:\\nIn closures we have the referece to the parent variables.\\nwithin the object in three methods one by one, we are not copying the value and making the change,instead the change is made to the original value, as we are pointing to the same varibale.\\n\\nNeed to make two variables to keep track of the values, one for the reset value, at any  point of time, we can reset the current value to reset value.\\n```\\nlet resetVal = init;\\nlet value = resetVal;\\n// manipulate the value , increment it, decrement, whatever logic you perform, once there is a need to reset it to its initial ,\\nsimply // do this\\nvalue = resetVal;\\n```\\n# Approach\\ndefine three methods:\\n```\\nfunction increment (){...}\\nfunction decrement (){...}\\nfunction reset (){...}\\n```\\nand just return the object with these three methods:\\n```\\nreturn {\\nincrement: increment,\\ndecrement: decrement,\\nreset: reset\\n};\\n```\\ndo not be confuse here, because we are just passing the reference to the methods in the object.\\n\\nHope it helps, if yes, please upvote.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let resetVal = init; \\n    let value = resetVal; \\n\\n    function increment(){\\n        return ++value;    \\n    }\\n    function reset(){\\n        value = resetVal; \\n        return value; \\n    }\\n    function decrement(){\\n        return --value; \\n    }\\n    return {\\n        increment: increment,\\n        decrement: decrement,\\n        reset: reset\\n    };\\n};\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet resetVal = init;\\nlet value = resetVal;\\n// manipulate the value , increment it, decrement, whatever logic you perform, once there is a need to reset it to its initial ,\\nsimply // do this\\nvalue = resetVal;\\n```\n```\\nfunction increment (){...}\\nfunction decrement (){...}\\nfunction reset (){...}\\n```\n```\\nreturn {\\nincrement: increment,\\ndecrement: decrement,\\nreset: reset\\n};\\n```\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let resetVal = init; \\n    let value = resetVal; \\n\\n    function increment(){\\n        return ++value;    \\n    }\\n    function reset(){\\n        value = resetVal; \\n        return value; \\n    }\\n    function decrement(){\\n        return --value; \\n    }\\n    return {\\n        increment: increment,\\n        decrement: decrement,\\n        reset: reset\\n    };\\n};\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972407,
                "title": "clean-easy-solution",
                "content": "# Approach\\nStore the original variable separately which will be called upon reset.\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    let val = init\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    let val = init\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972132,
                "title": "solution-using-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n\\treturn {\\n\\t\\tinit: init,\\n\\t\\tincrement: function () {\\n\\t\\t\\treturn (this.init = this.init + 1)\\n\\t\\t},\\n\\t\\treset: function () {\\n\\t\\t\\treturn (this.init = init)\\n\\t\\t},\\n\\t\\tdecrement: function () {\\n\\t\\t\\treturn (this.init = this.init - 1)\\n\\t\\t},\\n\\t}\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n\\treturn {\\n\\t\\tinit: init,\\n\\t\\tincrement: function () {\\n\\t\\t\\treturn (this.init = this.init + 1)\\n\\t\\t},\\n\\t\\treset: function () {\\n\\t\\t\\treturn (this.init = init)\\n\\t\\t},\\n\\t\\tdecrement: function () {\\n\\t\\t\\treturn (this.init = this.init - 1)\\n\\t\\t},\\n\\t}\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968582,
                "title": "js-solution-with-prefix-increment-and-decrement",
                "content": "\\n# Code\\n```\\nvar createCounter = function(init) {\\n    let result = init;\\n    return {\\n        increment: function() {\\n            return ++result;\\n        },\\n        decrement: function() {\\n            return --result;\\n        },\\n        reset: function() {\\n            result = init;\\n            return result;   \\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    let result = init;\\n    return {\\n        increment: function() {\\n            return ++result;\\n        },\\n        decrement: function() {\\n            return --result;\\n        },\\n        reset: function() {\\n            result = init;\\n            return result;   \\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966413,
                "title": "concise-and-modern-code",
                "content": "# Intuition\\nThe Thought was simple to use as minimum statements as possible.\\n\\n# Approach\\nUsed the modern arrow function syntax with increment operators.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = resetValue;\\n            return init;\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = resetValue;\\n            return init;\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964317,
                "title": "counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    return {\\n   increment: () => num = num + 1,\\n    reset: () => num = init,\\n    decrement: () => num = num - 1\\n}\\n};\\n\\n\\n const counter = createCounter(5)\\n counter.increment(); // 6\\n counter.reset(); // 5\\n counter.decrement(); // 4\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    return {\\n   increment: () => num = num + 1,\\n    reset: () => num = init,\\n    decrement: () => num = num - 1\\n}\\n};\\n\\n\\n const counter = createCounter(5)\\n counter.increment(); // 6\\n counter.reset(); // 5\\n counter.decrement(); // 4\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963953,
                "title": "simple-ts",
                "content": "# Code\\n```\\ninterface ReturnObj {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    const initCopy = init\\n\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = initCopy\\n            return init\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ninterface ReturnObj {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    const initCopy = init\\n\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = initCopy\\n            return init\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963436,
                "title": "solution",
                "content": "# Intuition\\nmy first leetcode code that actually worked lol, i am sorry if its not upto the mark\\n# Code\\n\\nvar createCounter = function(init,cur) {\\n    cur=init\\n    return{\\n        increment: ()=>{\\n            return init=init+1;\\n        },\\n        decrement: ()=>{\\n            return init=init-1;\\n        },\\n        reset: ()=>{\\n            return init= cur;\\n        }\\n\\n    }\\n    \\n};\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\nmy first leetcode code that actually worked lol, i am sorry if its not upto the mark\\n# Code\\n\\nvar createCounter = function(init,cur) {\\n    cur=init\\n    return{\\n        increment: ()=>{\\n            return init=init+1;\\n        },\\n        decrement: ()=>{\\n            return init=init-1;\\n        },\\n        reset: ()=>{\\n            return init= cur;\\n        }\\n\\n    }\\n    \\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3959373,
                "title": "simple-solution-to-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val = init;\\n    return {\\n        increment : () => {\\n            return ++val;\\n        },\\n        decrement : () => {\\n            return --val;\\n        },\\n        reset : () => {\\n            return val = init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val = init;\\n    return {\\n        increment : () => {\\n            return ++val;\\n        },\\n        decrement : () => {\\n            return --val;\\n        },\\n        reset : () => {\\n            return val = init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957960,
                "title": "counter-ii-solution",
                "content": "# Intuition\\nincrement(): Increase the current value by 1 and then return it.\\ndecrement(): Decrease the current value by 1 and then return it.\\nreset(): Set the current value to the initial value (init) and then return it.\\nKeeping these actions in mind, it\\'s important to note that the initial value of init needs to be preserved for the reset() operation. To achieve this, we can initialize a separate variable, count, with the initial value. This variable will be used to maintain the current value during the increment and decrement operations.\\n\\nBefore seeing the solution keep in mind the this Intution part and try again you can do it. it\\'s easy \\n\\n\\n# Approach\\nTo approach this problem, it\\'s helpful to read the provided instructions carefully and translate them into a step-by-step process for each of the required methods: increment(), decrement(), and reset().\\n\\n\\n# Complexity\\nTime complexity: O(1) - Each method performs a constant number of operations regardless of the input value.\\n\\nSpace complexity: O(1) - The additional space used is independent of the input and remains constant.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\nlet createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment(){\\n            return ++count;\\n\\n        },\\n        decrement(){\\n            return --count;\\n\\n        },\\n        reset(){\\n          count = init;\\n          return count;\\n         \\n        },\\n    }\\n\\n    \\n     \\n };\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\nlet createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment(){\\n            return ++count;\\n\\n        },\\n        decrement(){\\n            return --count;\\n\\n        },\\n        reset(){\\n          count = init;\\n          return count;\\n         \\n        },\\n    }\\n\\n    \\n     \\n };\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949017,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947272,
                "title": "solution-using-es6-style",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter=init\\n    const increment=()=>{\\n        counter+=1;\\n    return counter\\n    }\\n    const decrement=()=>{\\n        counter-=1;\\n        return counter}\\n    const reset=()=>{counter=init\\n    return counter}\\n    return {increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter=init\\n    const increment=()=>{\\n        counter+=1;\\n    return counter\\n    }\\n    const decrement=()=>{\\n        counter-=1;\\n        return counter}\\n    const reset=()=>{counter=init\\n    return counter}\\n    return {increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945454,
                "title": "easy-approach",
                "content": "# Intuition\\n If you know chaining it would be child play really\\n# Approach\\nApproach see down what its actually asking then accordingly you do the task\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const originalValue = init;\\n    return{\\n        increment: ()=>{\\n            return ++init;\\n        },\\n        reset: ()=>{\\n            return init = originalValue; \\n        },\\n        decrement: ()=>{\\n            return --init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const originalValue = init;\\n    return{\\n        increment: ()=>{\\n            return ++init;\\n        },\\n        reset: ()=>{\\n            return init = originalValue; \\n        },\\n        decrement: ()=>{\\n            return --init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944911,
                "title": "counter-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let totalcount = init;\\n    increment = () => {\\n        totalcount++;\\n        return totalcount;\\n    }\\n    decrement = () => {\\n        totalcount--;\\n        return totalcount;\\n    }\\n     \\n    reset =() => {\\n        totalcount = init;\\n        return totalcount;\\n    }\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let totalcount = init;\\n    increment = () => {\\n        totalcount++;\\n        return totalcount;\\n    }\\n    decrement = () => {\\n        totalcount--;\\n        return totalcount;\\n    }\\n     \\n    reset =() => {\\n        totalcount = init;\\n        return totalcount;\\n    }\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944645,
                "title": "test",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const start = init;\\n    return {\\n        increment: () => {\\n            init += 1\\n            return init\\n        },\\n        decrement: () => {\\n            return init -= 1\\n        },\\n        reset: () => {\\n            init = start\\n             return init\\n        }\\n    }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const start = init;\\n    return {\\n        increment: () => {\\n            init += 1\\n            return init\\n        },\\n        decrement: () => {\\n            return init -= 1\\n        },\\n        reset: () => {\\n            init = start\\n             return init\\n        }\\n    }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944435,
                "title": "30-days-of-javascript-counter-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var curr = init;\\n    return{\\n        increment: function(){\\n            curr = curr + 1;\\n            return curr;\\n        },\\n        decrement: function(){\\n            curr--;\\n            return curr;\\n        },\\n        reset: function(){\\n            curr = init;\\n            return curr;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n**PLEASE UpVOTE**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var curr = init;\\n    return{\\n        increment: function(){\\n            curr = curr + 1;\\n            return curr;\\n        },\\n        decrement: function(){\\n            curr--;\\n            return curr;\\n        },\\n        reset: function(){\\n            curr = init;\\n            return curr;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943389,
                "title": "easy-to-understand-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let i = init;\\n  reset=()=>{\\n    i = init\\n    return i;\\n  }\\n  \\n  increment = () => ++i;\\n  decrement = () => --i;\\n  \\n  return {increment,decrement,reset};  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let i = init;\\n  reset=()=>{\\n    i = init\\n    return i;\\n  }\\n  \\n  increment = () => ++i;\\n  decrement = () => --i;\\n  \\n  return {increment,decrement,reset};  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942062,
                "title": "simplest-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const original = init;\\n    let value = init;\\n\\n    return {\\n        increment: function() {\\n            return ++value;\\n        },\\n        decrement: function() {\\n            return --value;\\n        },\\n        reset: function() {\\n            value = original;\\n            return original;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const original = init;\\n    let value = init;\\n\\n    return {\\n        increment: function() {\\n            return ++value;\\n        },\\n        decrement: function() {\\n            return --value;\\n        },\\n        reset: function() {\\n            value = original;\\n            return original;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940454,
                "title": "clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let current = Number(init);\\n\\n    const increment = () => ++current;\\n\\n    const decrement = () => --current;\\n\\n    const reset = () => {\\n        current = Number(init);\\n        return init;\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let current = Number(init);\\n\\n    const increment = () => ++current;\\n\\n    const decrement = () => --current;\\n\\n    const reset = () => {\\n        current = Number(init);\\n        return init;\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937735,
                "title": "2665-javascript-solution-for-counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val=init;\\n    function increment(){\\n        val++;\\n        return val\\n    }\\n    function decrement(){\\n        val--;\\n        return val\\n    }\\n    function reset(){\\n        val=init;\\n        return val\\n    }\\n    return{\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val=init;\\n    function increment(){\\n        val++;\\n        return val\\n    }\\n    function decrement(){\\n        val--;\\n        return val\\n    }\\n    function reset(){\\n        val=init;\\n        return val\\n    }\\n    return{\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936285,
                "title": "30-days-of-javascript-counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore a copy of initial value into a variable and update according to the functions requirments.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) First Make a Variable named currentValue to store initial value\\n2) in functions return block, create three function increment, decrement and reset.\\n3) Now Follow The Problem requirment and update and return currentValue in functions.\\n4) In reset, Reset the currentValue to it\\'s initial value\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return{\\n        increment: function(){\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: function(){\\n            currentValue--;\\n            return currentValue;\\n        },\\n        reset: function(){\\n            currentValue = init\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return{\\n        increment: function(){\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: function(){\\n            currentValue--;\\n            return currentValue;\\n        },\\n        reset: function(){\\n            currentValue = init\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924517,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init                                \\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    // let val = init\\n    // let count = 0\\n    // console.log(count++)\\n    let val = init\\n   return{\\n       increment:()=>{\\n           return ++init\\n       },\\n       decrement:()=>{\\n           return --init\\n       },\\n       reset:()=>{\\n           return init = val\\n       }\\n   }\\n\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init                                \\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    // let val = init\\n    // let count = 0\\n    // console.log(count++)\\n    let val = init\\n   return{\\n       increment:()=>{\\n           return ++init\\n       },\\n       decrement:()=>{\\n           return --init\\n       },\\n       reset:()=>{\\n           return init = val\\n       }\\n   }\\n\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923237,
                "title": "typescript-minimalistic-code",
                "content": "# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let val = init;\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let val = init;\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3920972,
                "title": "beginner-friendly-approach",
                "content": "# Intuition\\nuse a const to store value of init for reset function. we can directly increment or decrement the value of init and reset the value using the const we declared.\\n# Complexity\\nbeats 80% in both time complexity and space complexity.\\n# Code\\n```\\n\\nvar createCounter = function(init) {\\n    const a=init;\\n    return{\\n        increment: ()=> ++init,\\n        reset: ()=> init=a,\\n        decrement: ()=>--init\\n        }\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\nuse a const to store value of init for reset function. we can directly increment or decrement the value of init and reset the value using the const we declared.\\n# Complexity\\nbeats 80% in both time complexity and space complexity.\\n# Code\\n```\\n\\nvar createCounter = function(init) {\\n    const a=init;\\n    return{\\n        increment: ()=> ++init,\\n        reset: ()=> init=a,\\n        decrement: ()=>--init\\n        }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3916749,
                "title": "shortest-and-easiest-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar createCounter = function(init) {\\n let num = init;\\n   return {\\n       increment: ()=>{\\n           return ++num ;\\n       },\\n       reset: ()=>{\\n           return num = init;\\n       },\\n         decrement: ()=>{\\n           return --num;\\n       },\\n         \\n   } \\n};\\n\\n\\n  const counter = createCounter(5)\\n counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar createCounter = function(init) {\\n let num = init;\\n   return {\\n       increment: ()=>{\\n           return ++num ;\\n       },\\n       reset: ()=>{\\n           return num = init;\\n       },\\n         decrement: ()=>{\\n           return --num;\\n       },\\n         \\n   } \\n};\\n\\n\\n  const counter = createCounter(5)\\n counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916350,
                "title": "easy-javascript-solution",
                "content": "> If you like vote up\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let i=init;\\n    function increment(){\\n        i++\\n        return i;\\n    }\\n    function reset(){\\n        i=init\\n        return init\\n    }\\n    function decrement(){\\n        i--\\n        return i\\n    }\\n    return {\"increment\":increment,\"reset\":reset,\"decrement\":decrement}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let i=init;\\n    function increment(){\\n        i++\\n        return i;\\n    }\\n    function reset(){\\n        i=init\\n        return init\\n    }\\n    function decrement(){\\n        i--\\n        return i\\n    }\\n    return {\"increment\":increment,\"reset\":reset,\"decrement\":decrement}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1882561,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885855,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886327,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2037503,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886326,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886103,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885727,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2069468,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2024731,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2003921,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1882561,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885855,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886327,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2037503,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886326,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886103,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885727,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2069468,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2024731,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2003921,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1989045,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1984897,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1976245,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1966499,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1936923,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1915150,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1912508,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1886460,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1886012,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1885922,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            }
        ]
    },
    {
        "title": "Array of Objects to Matrix",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1902848,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903293,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903150,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1891351,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902985,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903197,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903309,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902757,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902979,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1905253,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902848,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903293,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903150,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1891351,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902985,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903197,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903309,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902757,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902979,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1905253,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count the Number of Complete Components",
        "question_content": "<p>You are given an integer <code>n</code>. There is an <strong>undirected</strong> graph with <code>n</code> vertices, numbered from <code>0</code> to <code>n - 1</code>. You are given a 2D integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> denotes that there exists an <strong>undirected</strong> edge connecting vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>\n\n<p>Return <em>the number of <strong>complete connected components</strong> of the graph</em>.</p>\n\n<p>A <strong>connected component</strong> is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.</p>\n\n<p>A connected component is said to be <b>complete</b> if there exists an edge between every pair of its vertices.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong class=\"example\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-31-23.png\" style=\"width: 671px; height: 270px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> From the picture above, one can see that all of the components of this graph are complete.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong class=\"example\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-32-00.png\" style=\"width: 671px; height: 270px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>There are no repeated edges.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3521922,
                "title": "dfs-to-count-the-number-of-nodes-and-edges",
                "content": "# Intuition\\nDFS\\n\\n# Approach\\nDFS\\n\\n# Complexity\\n- Time complexity:\\nO(n + m)\\n\\n- Space complexity:\\nO(n + m)\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int x, const vector<vector<int>> &con, vector<bool> &mark, int &a, int &b) {\\n        if (mark[x]) {\\n            return;\\n        }\\n        mark[x] = true;\\n        ++a;\\n        b += con[x].size();\\n        for (int y : con[x]) {\\n            dfs(y, con, mark, a, b);\\n        }\\n    }\\n    \\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> con(n);\\n        for (const auto& e : edges) {\\n            con[e[0]].push_back(e[1]);\\n            con[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> mark(n);\\n        int r = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (!mark[i]) {\\n                int x = 0, y = 0;\\n                dfs(i, con, mark, x, y);\\n                r += x * (x - 1) == y;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int x, const vector<vector<int>> &con, vector<bool> &mark, int &a, int &b) {\\n        if (mark[x]) {\\n            return;\\n        }\\n        mark[x] = true;\\n        ++a;\\n        b += con[x].size();\\n        for (int y : con[x]) {\\n            dfs(y, con, mark, a, b);\\n        }\\n    }\\n    \\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> con(n);\\n        for (const auto& e : edges) {\\n            con[e[0]].push_back(e[1]);\\n            con[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> mark(n);\\n        int r = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (!mark[i]) {\\n                int x = 0, y = 0;\\n                dfs(i, con, mark, x, y);\\n                r += x * (x - 1) == y;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521887,
                "title": "explained-dsu-very-simple-easy-to-understand",
                "content": "<b>Up vote if you like the solution</b>\\n\\n# Approach \\n1. Using DSU find the connected component \\n2. While finding the connected component, keep tracking the number of edges &\\n    number of nodes associated with the connected component\\n3. At the end check if the a connected component with N node has N*(N-1)/2 number of \\n    edges, then increament ans.\\n    \\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> par, edgeCount, nodeCount;\\n    int find(int i){\\n        if(par[i] == -1) return i;\\n        return find(par[i]);\\n    }\\n    \\n    void unionPair(int a, int b ){\\n        int pa = find(a), pb = find(b);\\n        edgeCount[pa] += 1;\\n        if(pa != pb){\\n            par[pb] = pa;\\n            edgeCount[pa] += edgeCount[pb];\\n            nodeCount[pa] += nodeCount[pb];\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        par.resize(n, -1);   edgeCount.resize(n, 0);    nodeCount.resize(n, 1);\\n        for(auto e: edges) unionPair(e[0], e[1]);\\n        for(int i = 0; i < n; ++i){\\n            if(nodeCount[i] && par[i] == -1  && ( nodeCount[i] * (nodeCount[i] - 1)/2 == edgeCount[i] ) ) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> par, edgeCount, nodeCount;\\n    int find(int i){\\n        if(par[i] == -1) return i;\\n        return find(par[i]);\\n    }\\n    \\n    void unionPair(int a, int b ){\\n        int pa = find(a), pb = find(b);\\n        edgeCount[pa] += 1;\\n        if(pa != pb){\\n            par[pb] = pa;\\n            edgeCount[pa] += edgeCount[pb];\\n            nodeCount[pa] += nodeCount[pb];\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        par.resize(n, -1);   edgeCount.resize(n, 0);    nodeCount.resize(n, 1);\\n        for(auto e: edges) unionPair(e[0], e[1]);\\n        for(int i = 0; i < n; ++i){\\n            if(nodeCount[i] && par[i] == -1  && ( nodeCount[i] * (nodeCount[i] - 1)/2 == edgeCount[i] ) ) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521885,
                "title": "cpp-dfs",
                "content": "### Intuition\\nCount number of connected nodes and connecting edges and use `nodes*(nodes - 1) == connectingEdges`\\n\\n### TIme Complexity : `O(n)`\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int currNode,vector<bool> &vis,int &nodeCount,int &edgeCount) {\\n        vis[currNode] = true;\\n        nodeCount += 1;\\n        edgeCount += graph[currNode].size();\\n        for(int nextNode : graph[currNode]) {\\n            if(!vis[nextNode]) {\\n                dfs(graph,nextNode,vis,nodeCount,edgeCount);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for(vector<int> &edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int ans = 0;\\n        vector<bool> vis(n);\\n        for(int i = 0; i < n; i += 1) {\\n            int nodeCount = 0,edgeCount = 0;\\n            if(!vis[i]) {\\n                dfs(graph,i,vis,nodeCount,edgeCount);\\n                if(nodeCount*(nodeCount - 1) == edgeCount) ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &graph,int currNode,vector<bool> &vis,int &nodeCount,int &edgeCount) {\\n        vis[currNode] = true;\\n        nodeCount += 1;\\n        edgeCount += graph[currNode].size();\\n        for(int nextNode : graph[currNode]) {\\n            if(!vis[nextNode]) {\\n                dfs(graph,nextNode,vis,nodeCount,edgeCount);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for(vector<int> &edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int ans = 0;\\n        vector<bool> vis(n);\\n        for(int i = 0; i < n; i += 1) {\\n            int nodeCount = 0,edgeCount = 0;\\n            if(!vis[i]) {\\n                dfs(graph,i,vis,nodeCount,edgeCount);\\n                if(nodeCount*(nodeCount - 1) == edgeCount) ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521878,
                "title": "c-java-python3-union-find-with-count",
                "content": "\\n# Intuition\\nUsing union find we can find all components. If the size of the component that `x` is a part of is not equal to number of edges connected to `x` + 1, the component is not complete. \\n\\n# Approach\\n* Use union find to find all the components first\\n* In the `DSU` class we add a method called `size_of_group_that_x_is_a_part_of`. This will return the size of the groupd that x is part of. The number of edges connected to x must be one less than this.\\n* Use a counter to count edges connected to each node\\n* Use a set `groups` to find the number of unique groups/components in the graph. \\n* Then just find the `size_of_group_that_x_is_a_part_of` and make sure that the number of edges connected to `x` is one less than this. If it is not the group/component x is a part of is not complete.\\n\\n# Complexity\\n- Time complexity: O(max(n, len(edges)))\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python3**:\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n))\\n        self.rank = [0] * n\\n        self.count = [1] * n\\n    def find(self, x):\\n        if x != self.p[x]:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    def union(self, x, y):\\n        xx, yy = self.find(x), self.find(y)\\n        if xx == yy: return\\n        self.count[xx] = self.count[yy] = self.count[xx] + self.count[yy]\\n        if self.rank[xx] < self.rank[yy]: self.p[xx] = yy\\n        else: self.p[yy] = xx\\n        if self.rank[xx] == self.rank[yy]: self.rank[xx] += 1\\n    def size_of_group_that_x_is_a_part_of(self, x):\\n        return self.count[self.find(x)]\\n\\nclass Solution:\\n    def countCompleteComponents(self, n, edges):\\n        uf, counter = DSU(n), Counter()\\n        for x, y in edges: \\n            uf.union(x, y)\\n            counter[x] += 1\\n            counter[y] += 1\\n\\n        groups = set(uf.find(i) for i in range(n))\\n\\n        for i in range(n):\\n            if uf.size_of_group_that_x_is_a_part_of(i) != counter[i] + 1:\\n                groups.discard(uf.find(i))\\n\\n        return len(groups)\\n```\\n\\n**C++**:\\n```\\nclass DSU {\\nprivate:\\n    vector<int> p, rank, count;\\npublic:\\n    DSU(int n) {\\n        p.resize(n), rank.resize(n), count.resize(n, 1);\\n        for (int i = 0; i < n; ++i) p[i] = i;\\n    }\\n    int find(int x) {\\n        if (x != p[x]) p[x] = find(p[x]);\\n        return p[x];\\n    }\\n    void union_set(int x, int y) {\\n        int xx = find(x), yy = find(y);\\n        if (xx == yy) return;\\n        count[xx] = count[yy] = count[xx] + count[yy];\\n        if (rank[xx] < rank[yy]) p[xx] = yy;\\n        else p[yy] = xx;\\n        if (rank[xx] == rank[yy]) ++rank[xx];\\n    }\\n    int sizeOfGroupThatXIsAPartOf(int x) {\\n        return count[find(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU uf(n);\\n        set<int> groups;\\n        vector<int> counter(n, 0);\\n        for (auto& e : edges) {\\n            uf.union_set(e[0], e[1]);\\n            ++counter[e[0]], ++counter[e[1]];\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n            groups.insert(uf.find(i));\\n\\n        for (int i = 0; i < n; ++i)\\n            if (uf.sizeOfGroupThatXIsAPartOf(i) != counter[i] + 1) \\n                groups.erase(uf.find(i));\\n\\n        return groups.size();\\n    }\\n};\\n\\n```\\n\\n**Java**:\\n```\\npublic class DSU {\\n    private int[] p, rank, count;\\n\\n    public DSU(int n) {\\n        p = new int[n];\\n        rank = new int[n];\\n        count = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            p[i] = i;\\n            count[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (x != p[x])\\n            p[x] = find(p[x]);\\n        return p[x];\\n    }\\n\\n    public void unionSet(int x, int y) {\\n        int xx = find(x), yy = find(y);\\n        if (xx == yy) return;\\n        count[xx] = count[yy] = count[xx] + count[yy];\\n        if (rank[xx] < rank[yy]) p[xx] = yy;\\n        else p[yy] = xx;\\n        if (rank[xx] == rank[yy]) rank[xx]++;\\n    }\\n\\n    public int sizeOfGroupThatXIsAPartOf(int x) {\\n        return count[find(x)];\\n    }\\n}\\n\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        DSU uf = new DSU(n);\\n        Set<Integer> groups = new HashSet<>();\\n        int[] counter = new int[n];\\n        for (int[] e : edges) {\\n            uf.unionSet(e[0], e[1]);\\n            counter[e[0]]++; counter[e[1]]++;\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n            groups.add(uf.find(i));\\n\\n        for (int i = 0; i < n; i++)\\n            if (uf.sizeOfGroupThatXIsAPartOf(i) != counter[i] + 1)\\n                groups.remove(uf.find(i));\\n\\n        return groups.size();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n))\\n        self.rank = [0] * n\\n        self.count = [1] * n\\n    def find(self, x):\\n        if x != self.p[x]:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    def union(self, x, y):\\n        xx, yy = self.find(x), self.find(y)\\n        if xx == yy: return\\n        self.count[xx] = self.count[yy] = self.count[xx] + self.count[yy]\\n        if self.rank[xx] < self.rank[yy]: self.p[xx] = yy\\n        else: self.p[yy] = xx\\n        if self.rank[xx] == self.rank[yy]: self.rank[xx] += 1\\n    def size_of_group_that_x_is_a_part_of(self, x):\\n        return self.count[self.find(x)]\\n\\nclass Solution:\\n    def countCompleteComponents(self, n, edges):\\n        uf, counter = DSU(n), Counter()\\n        for x, y in edges: \\n            uf.union(x, y)\\n            counter[x] += 1\\n            counter[y] += 1\\n\\n        groups = set(uf.find(i) for i in range(n))\\n\\n        for i in range(n):\\n            if uf.size_of_group_that_x_is_a_part_of(i) != counter[i] + 1:\\n                groups.discard(uf.find(i))\\n\\n        return len(groups)\\n```\n```\\nclass DSU {\\nprivate:\\n    vector<int> p, rank, count;\\npublic:\\n    DSU(int n) {\\n        p.resize(n), rank.resize(n), count.resize(n, 1);\\n        for (int i = 0; i < n; ++i) p[i] = i;\\n    }\\n    int find(int x) {\\n        if (x != p[x]) p[x] = find(p[x]);\\n        return p[x];\\n    }\\n    void union_set(int x, int y) {\\n        int xx = find(x), yy = find(y);\\n        if (xx == yy) return;\\n        count[xx] = count[yy] = count[xx] + count[yy];\\n        if (rank[xx] < rank[yy]) p[xx] = yy;\\n        else p[yy] = xx;\\n        if (rank[xx] == rank[yy]) ++rank[xx];\\n    }\\n    int sizeOfGroupThatXIsAPartOf(int x) {\\n        return count[find(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU uf(n);\\n        set<int> groups;\\n        vector<int> counter(n, 0);\\n        for (auto& e : edges) {\\n            uf.union_set(e[0], e[1]);\\n            ++counter[e[0]], ++counter[e[1]];\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n            groups.insert(uf.find(i));\\n\\n        for (int i = 0; i < n; ++i)\\n            if (uf.sizeOfGroupThatXIsAPartOf(i) != counter[i] + 1) \\n                groups.erase(uf.find(i));\\n\\n        return groups.size();\\n    }\\n};\\n\\n```\n```\\npublic class DSU {\\n    private int[] p, rank, count;\\n\\n    public DSU(int n) {\\n        p = new int[n];\\n        rank = new int[n];\\n        count = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            p[i] = i;\\n            count[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (x != p[x])\\n            p[x] = find(p[x]);\\n        return p[x];\\n    }\\n\\n    public void unionSet(int x, int y) {\\n        int xx = find(x), yy = find(y);\\n        if (xx == yy) return;\\n        count[xx] = count[yy] = count[xx] + count[yy];\\n        if (rank[xx] < rank[yy]) p[xx] = yy;\\n        else p[yy] = xx;\\n        if (rank[xx] == rank[yy]) rank[xx]++;\\n    }\\n\\n    public int sizeOfGroupThatXIsAPartOf(int x) {\\n        return count[find(x)];\\n    }\\n}\\n\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        DSU uf = new DSU(n);\\n        Set<Integer> groups = new HashSet<>();\\n        int[] counter = new int[n];\\n        for (int[] e : edges) {\\n            uf.unionSet(e[0], e[1]);\\n            counter[e[0]]++; counter[e[1]]++;\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n            groups.add(uf.find(i));\\n\\n        for (int i = 0; i < n; i++)\\n            if (uf.sizeOfGroupThatXIsAPartOf(i) != counter[i] + 1)\\n                groups.remove(uf.find(i));\\n\\n        return groups.size();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522091,
                "title": "python-bfs-solution",
                "content": "# **Explanation**\\nBFS node `i` and find out all it\\'s connected nodes.\\nCheck the number of edgesd for each connnected nodes.\\n<br>\\n\\n# **Complexity**\\nTime `O(edges)`\\nSpace `O(edges)`\\n<br>\\n\\n**Python**\\n```py\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        G = [[] for i in range(n)]\\n        for i,j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        seen = [0] * n\\n\\n        res = 0\\n        for i in range(n):\\n            if seen[i]: continue\\n            bfs = [i]\\n            seen[i] = 1\\n            for j in bfs:\\n                for k in G[j]:\\n                    if seen[k] == 0:\\n                        bfs.append(k)\\n                        seen[k] = 1\\n            if all(len(G[j]) == len(bfs) - 1 for j in bfs):\\n                res += 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        G = [[] for i in range(n)]\\n        for i,j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        seen = [0] * n\\n\\n        res = 0\\n        for i in range(n):\\n            if seen[i]: continue\\n            bfs = [i]\\n            seen[i] = 1\\n            for j in bfs:\\n                for k in G[j]:\\n                    if seen[k] == 0:\\n                        bfs.append(k)\\n                        seen[k] = 1\\n            if all(len(G[j]) == len(bfs) - 1 for j in bfs):\\n                res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3522591,
                "title": "using-dsu-java-solution",
                "content": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int parent[]=new int[n];\\n        int size[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            size[i]=1;\\n           \\n        }\\n        for(int p[]:edges){\\n            int u=p[0];\\n            int v=p[1];\\n            int u1=findPar(u,parent);\\n            int v1=findPar(v,parent);\\n            if(u1!=v1)union(u1,v1,size,parent);\\n        }\\n        int z=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i){\\n              int z1=size[i];\\n                //checking for complete graph\\n                if(bfs(i,edges,parent)==(z1*(z1-1)/2)){\\n                    z++;\\n                }\\n            }\\n        }\\n        return z;\\n    }\\n    //finding ultimate parent\\n    public int findPar(int node,int parent[]){\\n        if(node==parent[node])return node;\\n        return parent[node]=findPar(parent[node],parent);\\n    }\\n    //union by size\\n    public void union(int u,int v,int size[],int parent[]){\\n        if(size[u]<size[v]){\\n            parent[u]=v;\\n            size[v]+=size[u];\\n        }\\n        else{\\n            parent[v]=u;\\n            size[u]+=size[v];\\n        }\\n    }\\n    //counting no of edges in a connected component\\n    public int bfs(int n,int edges[][],int parent[]){\\n        int c1=0;\\n        for(int p[]:edges){\\n            int u=p[0];\\n            int v=p[1];\\n            if(findPar(u,parent)==findPar(v,parent) && findPar(u,parent)==n)c1++;\\n        }\\n        return c1;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int parent[]=new int[n];\\n        int size[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            size[i]=1;\\n           \\n        }\\n        for(int p[]:edges){\\n            int u=p[0];\\n            int v=p[1];\\n            int u1=findPar(u,parent);\\n            int v1=findPar(v,parent);\\n            if(u1!=v1)union(u1,v1,size,parent);\\n        }\\n        int z=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i){\\n              int z1=size[i];\\n                //checking for complete graph\\n                if(bfs(i,edges,parent)==(z1*(z1-1)/2)){\\n                    z++;\\n                }\\n            }\\n        }\\n        return z;\\n    }\\n    //finding ultimate parent\\n    public int findPar(int node,int parent[]){\\n        if(node==parent[node])return node;\\n        return parent[node]=findPar(parent[node],parent);\\n    }\\n    //union by size\\n    public void union(int u,int v,int size[],int parent[]){\\n        if(size[u]<size[v]){\\n            parent[u]=v;\\n            size[v]+=size[u];\\n        }\\n        else{\\n            parent[v]=u;\\n            size[u]+=size[v];\\n        }\\n    }\\n    //counting no of edges in a connected component\\n    public int bfs(int n,int edges[][],int parent[]){\\n        int c1=0;\\n        for(int p[]:edges){\\n            int u=p[0];\\n            int v=p[1];\\n            if(findPar(u,parent)==findPar(v,parent) && findPar(u,parent)==n)c1++;\\n        }\\n        return c1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522369,
                "title": "python3-clean-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        \\n        \\n        adj=defaultdict(list)\\n        \\n        for a,b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        \\n        \\n        def dfs(i):\\n            \\n            component.add(i)\\n            for child in adj[i]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    dfs(child)\\n        \\n        \\n        ans=0\\n        visited=set()\\n        \\n        for i in range(n):\\n            if i not in visited:\\n                component=set()\\n                visited.add(i)\\n                dfs(i)\\n                if all(len(adj[node]) == len(component)-1 for node in component):\\n                    ans+=1\\n                    \\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        \\n        \\n        adj=defaultdict(list)\\n        \\n        for a,b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        \\n        \\n        def dfs(i):\\n            \\n            component.add(i)\\n            for child in adj[i]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    dfs(child)\\n        \\n        \\n        ans=0\\n        visited=set()\\n        \\n        for i in range(n):\\n            if i not in visited:\\n                component=set()\\n                visited.add(i)\\n                dfs(i)\\n                if all(len(adj[node]) == len(component)-1 for node in component):\\n                    ans+=1\\n                    \\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522744,
                "title": "no-union-find-no-dfs-no-bfs-just-simple-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor Complete Components, each node has an edge to all its adjancent node, e.g., if we regard the node itself as an \"adjancent node\", all those node has the same adjancent node list.\\n\\nFor example, for node 0,1,2,3. If it is an complete component, we have adjancency matrix as:\\n0 -> 0,1,2,3\\n1 -> 0,1,2,3\\n2 -> 0,1,2,3\\n3 -> 0,1,2,3\\n\\nWe could first find the adjancency matrix, then count the values. If the occurance of a value is the same as the length of the adjancency list, it is a complete component.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        adj2 = {}\\n        for e1, e2 in edges:\\n            adj[e1].append(e2)\\n            adj[e2].append(e1)\\n        for i in range(n):\\n            # add the node itself\\n            adj[i].append(i)\\n            adj[i].sort()\\n            adj2[i] = tuple(adj[i])\\n        \\n        res = 0\\n        for k, v in Counter(adj2.values()).items():\\n            res += 1 if len(k) == v else 0\\n        \\n        return res\\n        \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        adj2 = {}\\n        for e1, e2 in edges:\\n            adj[e1].append(e2)\\n            adj[e2].append(e1)\\n        for i in range(n):\\n            # add the node itself\\n            adj[i].append(i)\\n            adj[i].sort()\\n            adj2[i] = tuple(adj[i])\\n        \\n        res = 0\\n        for k, v in Counter(adj2.values()).items():\\n            res += 1 if len(k) == v else 0\\n        \\n        return res\\n        \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522363,
                "title": "dfs",
                "content": "For some reason, this problem was easier for me than all other problems in the contest.\\n\\nI initially got excited because I though it\\'s the famous clique problem. Clique is a fully-connected subgraph, not an isolated component.\\n\\n> The limit `n <= 50` is confusing as it implies that the expected solution is harder than quadratic. \\n\\nWe run DFS to identify all connected nodes in a subgraph.\\n\\nIf we have a subgraph with `m` nodes, it is connected if all `m` nodes have `m - 1` edges.\\n\\n**C++**\\n```cpp\\nvoid dfs(int i, vector<vector<int>> &al, unordered_set<int> &s) {\\n    if (s.insert(i).second)\\n        for (int j : al[i])\\n            dfs(j, al, s);\\n}\\nint countCompleteComponents(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(n);\\n    int res = 0;\\n    for (const auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    unordered_set<int> ms;\\n    for (int i = 0; i < n; ++i) {\\n        if (ms.count(i) == 0) {\\n            unordered_set<int> s;\\n            dfs(i, al, s);\\n            res += all_of(begin(s), end(s), [&](int i){ return al[i].size() == s.size() - 1; });\\n            ms.insert(begin(s), end(s));\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvoid dfs(int i, vector<vector<int>> &al, unordered_set<int> &s) {\\n    if (s.insert(i).second)\\n        for (int j : al[i])\\n            dfs(j, al, s);\\n}\\nint countCompleteComponents(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(n);\\n    int res = 0;\\n    for (const auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    unordered_set<int> ms;\\n    for (int i = 0; i < n; ++i) {\\n        if (ms.count(i) == 0) {\\n            unordered_set<int> s;\\n            dfs(i, al, s);\\n            res += all_of(begin(s), end(s), [&](int i){ return al[i].size() == s.size() - 1; });\\n            ms.insert(begin(s), end(s));\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526270,
                "title": "c-dfs-clean-codes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid dfs(int node, vector<int> &vis, vector<int> adj[], int &nodes, int &edges){\\n    vis[node]=1;\\n    nodes++;\\n    edges+=adj[node].size();\\n    for(auto x:adj[node]){\\n        if(!vis[x]){\\n            dfs(x,vis,adj,nodes,edges);\\n        } \\n    }\\n}\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        if(edges.size()==0) return n;\\n        int components=0;\\n        vector<int> vis(n,0);\\n        vector<int> adj[n];\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int errors=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                components++;\\n                int nodes=0;\\n                int edges=0;\\n                dfs(i,vis,adj,nodes,edges);\\n                if(edges!=(nodes*(nodes-1))) errors++;\\n            }\\n        }\\n        return components-errors;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid dfs(int node, vector<int> &vis, vector<int> adj[], int &nodes, int &edges){\\n    vis[node]=1;\\n    nodes++;\\n    edges+=adj[node].size();\\n    for(auto x:adj[node]){\\n        if(!vis[x]){\\n            dfs(x,vis,adj,nodes,edges);\\n        } \\n    }\\n}\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        if(edges.size()==0) return n;\\n        int components=0;\\n        vector<int> vis(n,0);\\n        vector<int> adj[n];\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int errors=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                components++;\\n                int nodes=0;\\n                int edges=0;\\n                dfs(i,vis,adj,nodes,edges);\\n                if(edges!=(nodes*(nodes-1))) errors++;\\n            }\\n        }\\n        return components-errors;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538690,
                "title": "python-3-6-lines-counter-t-m-91-97",
                "content": "Here\\'s the intuition:\\n\\n*Fig 1* shows a connected component with four nodes. It should be clear that each node has edges to all the other three nodes if and only if this connected component is complete.\\n![Untitled 5.jpg](https://assets.leetcode.com/users/images/7035cecd-26bc-4ded-9fd1-101e7841c838_1684424734.1980107.jpeg)\\n\\nIt should also be clear that if we add \"self-edges\" (*Fig 2*), then each node has the edge list [0,1,2,3] if and only if this connected component is complete.\\n\\nHere\\'s the plan:\\n\\n1. We initialize the graph dict`g`with the self-edges.\\n2. We build the graph.\\n2. We sort the lists, convert to tuples (to be hashable), and build a`Counter` with the tuples of edges as keys.\\n3. It follows directly from above that for each`edgeList`for which `len(edgeList) == vals[edgeList]` is true, there exists a complete connected component, so we count those occurrences and return that count as the answer. \\n\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        g = {i:[i] for i in range(n)}               # <-- 1)\\n        ans, conv = 0, lambda x: tuple(sorted(x))\\n\\n        for a, b in edges:                          # <-- 2)\\n            g[a].append(b) ; g[b].append(a)         #\\n\\n        vals = Counter(map(conv, g.values()))       # <-- 3)\\n        \\n        return sum(len(edgeList) == vals[edgeList]  # <-- 4)\\n                            for edgeList in vals)   #\\n```\\n[https://leetcode.com/problems/count-the-number-of-complete-components/submissions/952760551/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*+*E*) and space complexity is *O*(*N*), in which *N* ~ count of nodes and *E* ~ count of edges.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        g = {i:[i] for i in range(n)}               # <-- 1)\\n        ans, conv = 0, lambda x: tuple(sorted(x))\\n\\n        for a, b in edges:                          # <-- 2)\\n            g[a].append(b) ; g[b].append(a)         #\\n\\n        vals = Counter(map(conv, g.values()))       # <-- 3)\\n        \\n        return sum(len(edgeList) == vals[edgeList]  # <-- 4)\\n                            for edgeList in vals)   #\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522019,
                "title": "java-dfs-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + edges.length)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<Integer>[] adj;\\n  boolean[] seen;\\n  int cnt = -1;\\n  int nodes = 0;\\n  \\n  private boolean helper(int i) {\\n    seen[i] = true;\\n    nodes++;\\n    var edges = 0;\\n    var ret = true;\\n    \\n    for (var neighbor : adj[i]) {\\n      edges++;\\n      \\n      if (!seen[neighbor])\\n        ret &= helper(neighbor);\\n    }\\n    if (cnt == -1) cnt = edges;\\n    return cnt == edges && ret;\\n  }\\n  \\n  public int countCompleteComponents(int n, int[][] edges) {\\n    adj = new ArrayList[n];\\n    \\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n    \\n    for (var e : edges) {\\n      adj[e[0]].add(e[1]);\\n      adj[e[1]].add(e[0]);\\n    }\\n    seen = new boolean[n];\\n    var ans = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (!seen[i]) {\\n        cnt = -1;\\n        nodes = 0;\\n        \\n        if (helper(i) && cnt == nodes-1) ans++;\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n  List<Integer>[] adj;\\n  boolean[] seen;\\n  int cnt = -1;\\n  int nodes = 0;\\n  \\n  private boolean helper(int i) {\\n    seen[i] = true;\\n    nodes++;\\n    var edges = 0;\\n    var ret = true;\\n    \\n    for (var neighbor : adj[i]) {\\n      edges++;\\n      \\n      if (!seen[neighbor])\\n        ret &= helper(neighbor);\\n    }\\n    if (cnt == -1) cnt = edges;\\n    return cnt == edges && ret;\\n  }\\n  \\n  public int countCompleteComponents(int n, int[][] edges) {\\n    adj = new ArrayList[n];\\n    \\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n    \\n    for (var e : edges) {\\n      adj[e[0]].add(e[1]);\\n      adj[e[1]].add(e[0]);\\n    }\\n    seen = new boolean[n];\\n    var ans = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (!seen[i]) {\\n        cnt = -1;\\n        nodes = 0;\\n        \\n        if (helper(i) && cnt == nodes-1) ans++;\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521967,
                "title": "connected-components-with-hashset",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n        for(int[] edge : edges)\\n        {\\n            int x = edge[0], y = edge[1];\\n            graph[x].add(y);\\n            graph[y].add(x);\\n        }\\n        \\n        boolean[] vis = new boolean[n];\\n        int ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                HashSet<Integer> set = new HashSet<>();\\n                int count = dfs(i, vis, graph, set);\\n                if(set.size() == 1 && set.contains(count - 1))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int dfs(int src, boolean[] vis, ArrayList<Integer>[] graph, HashSet<Integer> set)\\n    {\\n        vis[src] = true;\\n        set.add(graph[src].size());\\n        int ans = 1;\\n        for(int nbr : graph[src])\\n        {\\n            if(!vis[nbr])\\n            {\\n                ans+= dfs(nbr, vis, graph, set);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n        for(int[] edge : edges)\\n        {\\n            int x = edge[0], y = edge[1];\\n            graph[x].add(y);\\n            graph[y].add(x);\\n        }\\n        \\n        boolean[] vis = new boolean[n];\\n        int ans = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                HashSet<Integer> set = new HashSet<>();\\n                int count = dfs(i, vis, graph, set);\\n                if(set.size() == 1 && set.contains(count - 1))\\n                    ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int dfs(int src, boolean[] vis, ArrayList<Integer>[] graph, HashSet<Integer> set)\\n    {\\n        vis[src] = true;\\n        set.add(graph[src].size());\\n        int ans = 1;\\n        for(int nbr : graph[src])\\n        {\\n            if(!vis[nbr])\\n            {\\n                ans+= dfs(nbr, vis, graph, set);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522514,
                "title": "java-simple-bfs-then-count-neighs-of-each-node",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1, build graph to store all neighbors of each node, by loop the edge.\\n2, Do BFS and check for each islands, res++ if complete.\\n3, Check if complete is simple, iff each node\\'s cnt of neighbors are CntOfNodesInIsland - 1;\\n# Code\\n```\\nclass Solution {\\n    Set<Integer> vis = new HashSet<>();\\n    Map<Integer, Set<Integer>> nodes;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //build graph to store all neighbors of each node, by loop the edge.\\n        nodes = buidGraph(edges);\\n        //Do BFS and check for each islands, res++ if complete.\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (vis.contains(i)) continue;\\n            if (bfs(i)) result++;\\n        }\\n        return result;\\n    }\\n\\n    private Map<Integer, Set<Integer>> buidGraph(int[][] edges) {\\n        Map<Integer, Set<Integer>> nodes = new HashMap<>();\\n        for (int[] e : edges) {\\n            nodes.putIfAbsent(e[0], new HashSet<>());\\n            nodes.putIfAbsent(e[1], new HashSet<>());\\n            nodes.get(e[0]).add(e[1]);\\n            nodes.get(e[1]).add(e[0]);\\n        }\\n        return nodes;\\n    }\\n\\n    private boolean bfs(int i) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(i);\\n        vis.add(i);\\n        int cntOfNeighs = nodes.getOrDefault(i, new HashSet<>()).size(), numOfNodes = 0;\\n        boolean result = true;\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();\\n            numOfNodes++;\\n            if (nodes.getOrDefault(curr, new HashSet<>()).size() != cntOfNeighs) result = false;\\n            for (int neig : nodes.getOrDefault(curr, new HashSet<>())) {\\n                if (vis.contains(neig)) continue;\\n                vis.add(neig);\\n                q.offer(neig);\\n            }\\n        }\\n        return result && cntOfNeighs == numOfNodes - 1;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Set<Integer> vis = new HashSet<>();\\n    Map<Integer, Set<Integer>> nodes;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //build graph to store all neighbors of each node, by loop the edge.\\n        nodes = buidGraph(edges);\\n        //Do BFS and check for each islands, res++ if complete.\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (vis.contains(i)) continue;\\n            if (bfs(i)) result++;\\n        }\\n        return result;\\n    }\\n\\n    private Map<Integer, Set<Integer>> buidGraph(int[][] edges) {\\n        Map<Integer, Set<Integer>> nodes = new HashMap<>();\\n        for (int[] e : edges) {\\n            nodes.putIfAbsent(e[0], new HashSet<>());\\n            nodes.putIfAbsent(e[1], new HashSet<>());\\n            nodes.get(e[0]).add(e[1]);\\n            nodes.get(e[1]).add(e[0]);\\n        }\\n        return nodes;\\n    }\\n\\n    private boolean bfs(int i) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(i);\\n        vis.add(i);\\n        int cntOfNeighs = nodes.getOrDefault(i, new HashSet<>()).size(), numOfNodes = 0;\\n        boolean result = true;\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();\\n            numOfNodes++;\\n            if (nodes.getOrDefault(curr, new HashSet<>()).size() != cntOfNeighs) result = false;\\n            for (int neig : nodes.getOrDefault(curr, new HashSet<>())) {\\n                if (vis.contains(neig)) continue;\\n                vis.add(neig);\\n                q.offer(neig);\\n            }\\n        }\\n        return result && cntOfNeighs == numOfNodes - 1;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522172,
                "title": "python-3-simple-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf a Group of N vertices are connected, it will be a complete connected if number of edges is equal: $$1 + 2 + ... + N - 1 = (N - 1) * N / 2$$. Thus we have to find connected components - Union Find. Find find whether the edges in this connected component equal to $$(N - 1) * N / 2$$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n    \\n    def __init__(self, n: int):\\n        self.root = list(range(n))\\n        self.rank = [1 for _ in range(n)]\\n        self.edges = [0 for _ in range(n)]\\n        self.group = [1 for _ in range(n)]\\n        \\n    def find(self, x: int) -> int:\\n        if x != self.root[x]: self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x == root_y:\\n            self.edges[root_x] += 1\\n            return\\n        if self.rank[root_x] > self.rank[root_y]:\\n            self.root[root_y] = root_x\\n            self.edges[root_x] += self.edges[root_y] + 1\\n            self.group[root_x] += self.group[root_y]\\n        elif self.rank[root_x] < self.rank[root_y]:\\n            self.root[root_x] = root_y\\n            self.edges[root_y] += self.edges[root_x] + 1\\n            self.group[root_y] += self.group[root_x]\\n        else:\\n            self.root[root_y] = root_x\\n            self.rank[root_x] += 1\\n            self.edges[root_x] += self.edges[root_y] + 1\\n            self.group[root_x] += self.group[root_y]\\n    \\n    def are_connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n            \\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        uf = UnionFind(n)\\n        g = collections.defaultdict(set)\\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)\\n            uf.union(u, v)\\n        for i in range(n):\\n            uf.find(i)\\n        \\n        s = set(uf.root)\\n        res = 0\\n        for x in s:\\n            v = uf.group[x]\\n            if uf.edges[x] == (v - 1) * v // 2: res += 1\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass UnionFind:\\n    \\n    def __init__(self, n: int):\\n        self.root = list(range(n))\\n        self.rank = [1 for _ in range(n)]\\n        self.edges = [0 for _ in range(n)]\\n        self.group = [1 for _ in range(n)]\\n        \\n    def find(self, x: int) -> int:\\n        if x != self.root[x]: self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x == root_y:\\n            self.edges[root_x] += 1\\n            return\\n        if self.rank[root_x] > self.rank[root_y]:\\n            self.root[root_y] = root_x\\n            self.edges[root_x] += self.edges[root_y] + 1\\n            self.group[root_x] += self.group[root_y]\\n        elif self.rank[root_x] < self.rank[root_y]:\\n            self.root[root_x] = root_y\\n            self.edges[root_y] += self.edges[root_x] + 1\\n            self.group[root_y] += self.group[root_x]\\n        else:\\n            self.root[root_y] = root_x\\n            self.rank[root_x] += 1\\n            self.edges[root_x] += self.edges[root_y] + 1\\n            self.group[root_x] += self.group[root_y]\\n    \\n    def are_connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n            \\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        uf = UnionFind(n)\\n        g = collections.defaultdict(set)\\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)\\n            uf.union(u, v)\\n        for i in range(n):\\n            uf.find(i)\\n        \\n        s = set(uf.root)\\n        res = 0\\n        for x in s:\\n            v = uf.group[x]\\n            if uf.edges[x] == (v - 1) * v // 2: res += 1\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521888,
                "title": "n-n-1-2",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int e=0,v=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for (int[] edge: edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                dfs(visited, i, adj);\\n                e/=2;\\n                if(e==(v*(v-1))/2)count++;\\n            }\\n            e=v=0;\\n        }\\n        return count;\\n    }\\n    \\n     private void dfs(boolean[] visited, int from, List<List<Integer>> adj) {\\n        visited[from] = true;\\n        v++;\\n        for (int to : adj.get(from)) {\\n            e++;\\n            if (!visited[to]) {\\n                dfs(visited, to, adj);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int e=0,v=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for (int[] edge: edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                dfs(visited, i, adj);\\n                e/=2;\\n                if(e==(v*(v-1))/2)count++;\\n            }\\n            e=v=0;\\n        }\\n        return count;\\n    }\\n    \\n     private void dfs(boolean[] visited, int from, List<List<Integer>> adj) {\\n        visited[from] = true;\\n        v++;\\n        for (int to : adj.get(from)) {\\n            e++;\\n            if (!visited[to]) {\\n                dfs(visited, to, adj);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760467,
                "title": "bfs-complete-graph-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is completely similar to **\"Calculating connected components of an undirected graph\".** But the difference is that here we will **counting only fully connected components**.\\n\\n**Completely Connected Components:-** A connected component is said to be complete if there exists an edge between every pair of its vertices.\\n\\n**Note:-**\\n**Mathematical term for complete graph:-**\\nIf number of nodes in the graph = **n** and number of edges = **m**\\n               **`m = n*(n-1)/2`**\\n**If the above condition is true then the graph is complete.**\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void BFS(vector<int> adj[],vector<int> &vis,int n,int src)\\n    {\\n        queue<int> q;\\n        q.push(src);\\n        vis[src] = 1;\\n        int nodecount = 0,edgecount = 0;\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            nodecount++;\\n            for(auto x : adj[node])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    q.push(x);\\n                    vis[x] = 1;\\n                }\\n                edgecount++;\\n            }\\n        }\\n        if(nodecount*(nodecount-1)==edgecount) ans++;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n        for(int i = 0;i<e.size();i++)\\n        {\\n        adj[e[i][0]].push_back(e[i][1]);\\n        adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        for(int i = 0;i<n;i++)\\n        if(vis[i]==0) BFS(adj,vis,n,i);\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/57f59c18-a89a-4316-8da9-5915b5f352f1_1689269226.963718.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void BFS(vector<int> adj[],vector<int> &vis,int n,int src)\\n    {\\n        queue<int> q;\\n        q.push(src);\\n        vis[src] = 1;\\n        int nodecount = 0,edgecount = 0;\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            nodecount++;\\n            for(auto x : adj[node])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    q.push(x);\\n                    vis[x] = 1;\\n                }\\n                edgecount++;\\n            }\\n        }\\n        if(nodecount*(nodecount-1)==edgecount) ans++;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n        for(int i = 0;i<e.size();i++)\\n        {\\n        adj[e[i][0]].push_back(e[i][1]);\\n        adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        for(int i = 0;i<n;i++)\\n        if(vis[i]==0) BFS(adj,vis,n,i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531447,
                "title": "easy-to-understand-approach-connected-components",
                "content": "\\n\\n# Approach\\nTraverse each connected component and check whether every node has N-1 vertices in it\\'s adjacency list. If yes, then it is a complete connected component. Else, ignore it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(vector<int> &edge:edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int> vis(n,0);\\n        int cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            if(!vis[i]) {\\n                vector<int> nodes;\\n                dfs(i,adj,vis,nodes);\\n                bool isComplete = true;\\n                for(int &u:nodes) {\\n                    if(adj[u].size() != nodes.size()-1) {\\n                        isComplete = false;\\n                        break;\\n                    }\\n                }\\n                if(isComplete) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(int u, vector<vector<int>> &adj, vector<int> &vis, vector<int> &nodes) {\\n        nodes.push_back(u);\\n        vis[u] = 1;\\n\\n        for(int &v:adj[u]) {\\n            if(!vis[v]) {\\n                dfs(v,adj,vis,nodes);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(vector<int> &edge:edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int> vis(n,0);\\n        int cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            if(!vis[i]) {\\n                vector<int> nodes;\\n                dfs(i,adj,vis,nodes);\\n                bool isComplete = true;\\n                for(int &u:nodes) {\\n                    if(adj[u].size() != nodes.size()-1) {\\n                        isComplete = false;\\n                        break;\\n                    }\\n                }\\n                if(isComplete) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(int u, vector<vector<int>> &adj, vector<int> &vis, vector<int> &nodes) {\\n        nodes.push_back(u);\\n        vis[u] = 1;\\n\\n        for(int &v:adj[u]) {\\n            if(!vis[v]) {\\n                dfs(v,adj,vis,nodes);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526051,
                "title": "dfs-solution-easy-understanding-java",
                "content": "\\n# Approach\\nCount number of components and for every component count the number of edges and nodes.\\nif edges == (node)*(node-1)/2 then we can say that the it is a complete component.\\n\\n# Complexity\\n- Time complexity: O(E+N)\\n    where E=number of edges\\n          N=number of nodes\\n\\n\\n- Space complexity: O(N+E)\\n\\n# Code\\n```\\nclass Solution {\\n    int edge=0,ncount=0;\\n\\n    public boolean isComplete(int e,int nc){\\n        int ans=nc*(nc-1)/2;\\n        if(ans==e)\\n            return true;\\n        return false;\\n    }\\n    public void dfs(int node,ArrayList<ArrayList<Integer>> adj , int[] vis){\\n\\n        vis[node]=1;\\n        edge+=adj.get(node).size();\\n\\n        for(int i=0;i<adj.get(node).size();i++)\\n        {\\n            if(vis[adj.get(node).get(i)] == 0)\\n            {\\n                dfs(adj.get(node).get(i),adj,vis);\\n            }\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        int[] vis=new int[n];\\n        \\n        int count=0;\\n        int prev=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            if(vis[i] == 0)\\n            {\\n                //edge=adj.get(i).size();\\n                dfs(i,adj,vis);\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(vis[j]==1)\\n                        c+=1;\\n                }\\n                ncount=c-prev;\\n                prev=c;\\n                //System.out.println(edge/2 +\" \"+ncount);\\n                if(isComplete(edge/2,ncount))\\n                    count+=1;\\n                edge=0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int edge=0,ncount=0;\\n\\n    public boolean isComplete(int e,int nc){\\n        int ans=nc*(nc-1)/2;\\n        if(ans==e)\\n            return true;\\n        return false;\\n    }\\n    public void dfs(int node,ArrayList<ArrayList<Integer>> adj , int[] vis){\\n\\n        vis[node]=1;\\n        edge+=adj.get(node).size();\\n\\n        for(int i=0;i<adj.get(node).size();i++)\\n        {\\n            if(vis[adj.get(node).get(i)] == 0)\\n            {\\n                dfs(adj.get(node).get(i),adj,vis);\\n            }\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        int[] vis=new int[n];\\n        \\n        int count=0;\\n        int prev=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            if(vis[i] == 0)\\n            {\\n                //edge=adj.get(i).size();\\n                dfs(i,adj,vis);\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(vis[j]==1)\\n                        c+=1;\\n                }\\n                ncount=c-prev;\\n                prev=c;\\n                //System.out.println(edge/2 +\" \"+ncount);\\n                if(isComplete(edge/2,ncount))\\n                    count+=1;\\n                edge=0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523739,
                "title": "easy-bfs-based-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\n\\t\\tbool bfs(vector<vector<int>> &adj, int node, vector<int> &vis)\\n\\t\\t{\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tq.push(node);\\n\\t\\t\\tint vertices = 0;\\n\\t\\t\\tset<string> st;\\n\\t\\t\\tvis[node] = 1;\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint t = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tvertices++;\\n\\n\\n\\t\\t\\t\\tfor(int i = 0; i < adj[t].size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(vis[adj[t][i]] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tq.push(adj[t][i]);\\n\\t\\t\\t\\t\\t\\tvis[adj[t][i]] = 1;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstring str = to_string(t) + \" - \" + to_string(adj[t][i]);\\n\\t\\t\\t\\t\\tst.insert(str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint count = st.size()/2;\\n\\t\\t\\tint req = (vertices * (vertices-1)) / 2;\\n\\n\\t\\t\\tif(req == count)\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\n\\t\\tint countCompleteComponents(int n, vector<vector<int>>& edges) \\n\\t\\t{\\n\\t\\t\\tvector<vector<int> > adj(n);\\n\\n\\t\\t\\tfor(int i = 0; i < edges.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint u = edges[i][0];\\n\\t\\t\\t\\tint v = edges[i][1];\\n\\n\\t\\t\\t\\tadj[u].push_back(v);\\n\\t\\t\\t\\tadj[v].push_back(u);\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tvector<int> vis(n, 0);\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vis[i] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(bfs(adj, i, vis))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\n\\t\\tbool bfs(vector<vector<int>> &adj, int node, vector<int> &vis)\\n\\t\\t{\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tq.push(node);\\n\\t\\t\\tint vertices = 0;\\n\\t\\t\\tset<string> st;\\n\\t\\t\\tvis[node] = 1;\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint t = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tvertices++;\\n\\n\\n\\t\\t\\t\\tfor(int i = 0; i < adj[t].size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(vis[adj[t][i]] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tq.push(adj[t][i]);\\n\\t\\t\\t\\t\\t\\tvis[adj[t][i]] = 1;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3522698,
                "title": "optimised-dfs-c-easy-to-understnad",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void get(int s,vector<vector<int>> &g,int &y,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        y++;\\n        for(auto &i: g[s]){\\n            get(i,g,y,v);\\n        }\\n    }\\n    void solve(int s,vector<vector<int>> &g,int &x,int &y,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            if(g[i].size() != y)x = 0;\\n            solve(i,g,x,y,v);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        vector<bool> v1(n,false),v2(n,false);\\n        for(auto &i: edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        int y = 0,x=0,ans=0;\\n        for(int i = 0; i < n; i++){\\n            if(!v1[i]){\\n                y = -1;\\n                get(i,g,y,v1);\\n                x = 1;\\n                solve(i,g,x,y,v2);\\n                ans += x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void get(int s,vector<vector<int>> &g,int &y,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        y++;\\n        for(auto &i: g[s]){\\n            get(i,g,y,v);\\n        }\\n    }\\n    void solve(int s,vector<vector<int>> &g,int &x,int &y,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            if(g[i].size() != y)x = 0;\\n            solve(i,g,x,y,v);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        vector<bool> v1(n,false),v2(n,false);\\n        for(auto &i: edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        int y = 0,x=0,ans=0;\\n        for(int i = 0; i < n; i++){\\n            if(!v1[i]){\\n                y = -1;\\n                get(i,g,y,v1);\\n                x = 1;\\n                solve(i,g,x,y,v2);\\n                ans += x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522438,
                "title": "easy-dfs-c-solution",
                "content": "# Approach\\nIn complete connected components e = nodes*(nodes-1)/2;\\ne = no. of edges in the component\\nnodes = no. of nodes in the component\\n\\nUsing dfs we can find e and nodes in each components.\\n\\nIn the dfs function every edge will be counted twice.\\nSo the final condition will be\\ne/2 == nodes*(nodes-1)/2\\ne == nodes*(nodes-1)\\n\\n# Complexity\\n- Time complexity: $$O(E + N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {    \\n    void dfs(vector<vector<int>>& adj, vector<bool>& vis, int i, int& nodes, int& e)\\n    {\\n        nodes++;\\n        vis[i] = true;\\n        for(auto j: adj[i])\\n        {\\n            e++;\\n            if(!vis[j]) dfs(adj, vis, j, nodes, e);\\n        }\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n        for(auto e: edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                int nodes = 0, e = 0;\\n                dfs(adj, vis, i, nodes, e);\\n                // cout << nodes << \" \" << e << endl;\\n                if(e == (nodes*(nodes-1))) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {    \\n    void dfs(vector<vector<int>>& adj, vector<bool>& vis, int i, int& nodes, int& e)\\n    {\\n        nodes++;\\n        vis[i] = true;\\n        for(auto j: adj[i])\\n        {\\n            e++;\\n            if(!vis[j]) dfs(adj, vis, j, nodes, e);\\n        }\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n        for(auto e: edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                int nodes = 0, e = 0;\\n                dfs(adj, vis, i, nodes, e);\\n                // cout << nodes << \" \" << e << endl;\\n                if(e == (nodes*(nodes-1))) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3521959,
                "title": "c-dfs-easy",
                "content": "\\n```\\nclass Solution {\\n    void dfs(int src, vector<vector<int>>& g, vector<int>& nodes, vector<int>& vis) {\\n        if(vis[src])return;\\n        vis[src] = 1;\\n        \\n        nodes.push_back(src);\\n        \\n        for(auto &x: g[src])dfs(x,g,nodes,vis);\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> g(n);\\n        \\n        for(auto &x: edges) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        \\n        vector<int> vis(n);\\n        int res = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(vis[i] == 0) {\\n                vector<int> path;\\n                dfs(i,g,path,vis);\\n                \\n                int count = 0;\\n                \\n                for(int j = 0; j < path.size(); j++) {\\n                    if(g[path[j]].size() >= path.size()-1)count++;\\n                }\\n                \\n                if(count == path.size())res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int src, vector<vector<int>>& g, vector<int>& nodes, vector<int>& vis) {\\n        if(vis[src])return;\\n        vis[src] = 1;\\n        \\n        nodes.push_back(src);\\n        \\n        for(auto &x: g[src])dfs(x,g,nodes,vis);\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> g(n);\\n        \\n        for(auto &x: edges) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        \\n        vector<int> vis(n);\\n        int res = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(vis[i] == 0) {\\n                vector<int> path;\\n                dfs(i,g,path,vis);\\n                \\n                int count = 0;\\n                \\n                for(int j = 0; j < path.size(); j++) {\\n                    if(g[path[j]].size() >= path.size()-1)count++;\\n                }\\n                \\n                if(count == path.size())res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534855,
                "title": "c-finding-connected-component-with-slight-change",
                "content": "# Intuition\\nAnswer is possible when nodecount*nodecount-1 == edgecount in a connected component.\\n\\nTo visualise this you can easily take a complete graph of nodesize 3 and 4 and varify it manually.\\n\\n# Approach\\n\\nsimple finding connected component with finding nodecount and edgecount. then verify and increase the answer\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n\\n    void dfs(int node, vector<int> adj[], int &nodeCount, int &edgeCount,vector<int> &visit){\\n\\n        visit[node]=1;\\n        nodeCount++;\\n        edgeCount+=adj[node].size();\\n\\n        for(auto i:adj[node]){\\n            if(!visit[i]) dfs(i,adj,nodeCount,edgeCount,visit);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        int ans=0;\\n        vector<int> visit(n,0);\\n        for(int i=0;i<n;++i){\\n            if(visit[i]) continue;\\n            \\n            int nodeCount=0,edgeCount=0;\\n            dfs(i,adj,nodeCount,edgeCount,visit);\\n            if(nodeCount * (nodeCount-1) == edgeCount) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    void dfs(int node, vector<int> adj[], int &nodeCount, int &edgeCount,vector<int> &visit){\\n\\n        visit[node]=1;\\n        nodeCount++;\\n        edgeCount+=adj[node].size();\\n\\n        for(auto i:adj[node]){\\n            if(!visit[i]) dfs(i,adj,nodeCount,edgeCount,visit);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        int ans=0;\\n        vector<int> visit(n,0);\\n        for(int i=0;i<n;++i){\\n            if(visit[i]) continue;\\n            \\n            int nodeCount=0,edgeCount=0;\\n            dfs(i,adj,nodeCount,edgeCount,visit);\\n            if(nodeCount * (nodeCount-1) == edgeCount) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531156,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(v + e)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        # init graph\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        \\n        # dfs check connected component\\n        def dfs(i):\\n            connected.add(i)\\n            for adj in g[i]:\\n                if adj not in visited:\\n                    visited.add(adj)\\n                    dfs(adj)\\n        \\n        # count numbers of connected components\\n        res, visited = 0, set()\\n        for i in range(n):\\n            if i not in visited:\\n                connected = set()\\n                visited.add(i)\\n                dfs(i)\\n                if all(len(g[node]) == len(connected) - 1 for node in connected):\\n                    res += 1\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        # init graph\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        \\n        # dfs check connected component\\n        def dfs(i):\\n            connected.add(i)\\n            for adj in g[i]:\\n                if adj not in visited:\\n                    visited.add(adj)\\n                    dfs(adj)\\n        \\n        # count numbers of connected components\\n        res, visited = 0, set()\\n        for i in range(n):\\n            if i not in visited:\\n                connected = set()\\n                visited.add(i)\\n                dfs(i)\\n                if all(len(g[node]) == len(connected) - 1 for node in connected):\\n                    res += 1\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524551,
                "title": "easy-and-intuitive-solution-connected-components-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn a connected graph or sub-graph(component), $$|E| = v*(v-1) / 2$$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse DFS in a the same way as to find connected components. Additionally, during each DFS pass for a component check if in that component sum of all the edges taken twice is equal to n*(n-1) or not i.e, \\n\\n$$|E|*2 == v*(v-1)$$\\n# Complexity\\n- Time complexity:$$O(n+E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n+E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &G, int i, vector<int> &visited, int &v, int&ce) {\\n        \\n        visited[i] = 1;\\n\\n        //Keeping count of vertices and edges in a component\\n        v++, ce += G[i].size();\\n\\n        for (auto nbr : G[i]){\\n            if(!(visited[nbr])) dfs(G, nbr, visited, v, ce);\\n        }  \\n    }\\n    \\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> G(n, vector<int>());\\n        \\n        for (auto edge : edges){\\n            int u = edge[0], v = edge[1];\\n            G[u].push_back(v);\\n            G[v].push_back(u);\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        \\n        int ccc =0;\\n        for (int i=0; i<n; i++) {\\n            if (!(visited[i])) {\\n                int v = 0, ce = 0;\\n                dfs(G, i, visited, v, ce);\\n                \\n                if (ce == v * (v-1)) ccc++;      \\n            }\\n        }\\n        \\n        return ccc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &G, int i, vector<int> &visited, int &v, int&ce) {\\n        \\n        visited[i] = 1;\\n\\n        //Keeping count of vertices and edges in a component\\n        v++, ce += G[i].size();\\n\\n        for (auto nbr : G[i]){\\n            if(!(visited[nbr])) dfs(G, nbr, visited, v, ce);\\n        }  \\n    }\\n    \\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> G(n, vector<int>());\\n        \\n        for (auto edge : edges){\\n            int u = edge[0], v = edge[1];\\n            G[u].push_back(v);\\n            G[v].push_back(u);\\n        }\\n        \\n        vector<int> visited(n, 0);\\n        \\n        int ccc =0;\\n        for (int i=0; i<n; i++) {\\n            if (!(visited[i])) {\\n                int v = 0, ce = 0;\\n                dfs(G, i, visited, v, ce);\\n                \\n                if (ce == v * (v-1)) ccc++;      \\n            }\\n        }\\n        \\n        return ccc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522140,
                "title": "c-dfs-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], vector<int>& vis, int i, vector<int>& vect){\\n        vect.push_back(i);\\n        vis[i]=1;\\n        for (auto val: adj[i]){\\n            if (!vis[val])dfs(adj,vis,val,vect);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for (auto val: edges){\\n            adj[val[0]].push_back(val[1]);\\n            adj[val[1]].push_back(val[0]);\\n        }\\n        int cnt=0;\\n        vector<int> vis(n,0);\\n        for (int i=0; i<n; i++){\\n            if (!vis[i]){\\n                bool flag=1;\\n                vector<int> vect;\\n                dfs(adj,vis,i,vect);\\n                int m= vect.size()-1;\\n                for (auto el: vect){\\n                    if (adj[el].size()!= m){\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                cnt+= flag;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], vector<int>& vis, int i, vector<int>& vect){\\n        vect.push_back(i);\\n        vis[i]=1;\\n        for (auto val: adj[i]){\\n            if (!vis[val])dfs(adj,vis,val,vect);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for (auto val: edges){\\n            adj[val[0]].push_back(val[1]);\\n            adj[val[1]].push_back(val[0]);\\n        }\\n        int cnt=0;\\n        vector<int> vis(n,0);\\n        for (int i=0; i<n; i++){\\n            if (!vis[i]){\\n                bool flag=1;\\n                vector<int> vect;\\n                dfs(adj,vis,i,vect);\\n                int m= vect.size()-1;\\n                for (auto el: vect){\\n                    if (adj[el].size()!= m){\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                cnt+= flag;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521993,
                "title": "dfs-c",
                "content": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<int> &nodes) {\\n        vis[node] = 1;\\n        nodes.push_back(node);\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, nodes);\\n        }\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> vis(n);\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) {\\n                vector<int> nodes;\\n                dfs(i, adj, vis, nodes);\\n                int f = 1;\\n                \\n                for(int i : nodes) {\\n                    unordered_set<int> s(adj[i].begin(), adj[i].end());\\n                    for(int j : nodes) {\\n                        if(i == j) continue;\\n                        if(s.find(j) == s.end()) {\\n                            f = 0;\\n                            break;\\n                        }\\n                    }\\n                }  \\n                ans += f;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<int> &nodes) {\\n        vis[node] = 1;\\n        nodes.push_back(node);\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, nodes);\\n        }\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> vis(n);\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) {\\n                vector<int> nodes;\\n                dfs(i, adj, vis, nodes);\\n                int f = 1;\\n                \\n                for(int i : nodes) {\\n                    unordered_set<int> s(adj[i].begin(), adj[i].end());\\n                    for(int j : nodes) {\\n                        if(i == j) continue;\\n                        if(s.find(j) == s.end()) {\\n                            f = 0;\\n                            break;\\n                        }\\n                    }\\n                }  \\n                ans += f;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521924,
                "title": "dfs-bfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector <int> ar[1000];\\n    int vis[1000];\\n    void dfs(int node, vector <int>&v) {\\n        vis[node] = 1;\\n        v.push_back(node);\\n        for (auto child : ar[node]) {\\n            if (!vis[child]) dfs(child, v);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& a) \\n    {\\n        for (auto i : a) {\\n            ar[i[0]].push_back(i[1]);\\n            ar[i[1]].push_back(i[0]);\\n        }\\n        int c = 0;\\n        for (int i = 0; i < n; i++) \\n        {\\n            if (!vis[i]) \\n            {\\n                vector <int> v;\\n                dfs(i, v);\\n                if (v.size() <= 2) c++;\\n                else \\n                {\\n                    bool f = true;\\n                    for (int j = 0; j < v.size(); j++)\\n                    {\\n                        int sz = ar[v[j]].size();\\n                        if (sz != v.size()-1) f = false;\\n                    }\\n                    if (f == true) c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> ar[1000];\\n    int vis[1000];\\n    void dfs(int node, vector <int>&v) {\\n        vis[node] = 1;\\n        v.push_back(node);\\n        for (auto child : ar[node]) {\\n            if (!vis[child]) dfs(child, v);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& a) \\n    {\\n        for (auto i : a) {\\n            ar[i[0]].push_back(i[1]);\\n            ar[i[1]].push_back(i[0]);\\n        }\\n        int c = 0;\\n        for (int i = 0; i < n; i++) \\n        {\\n            if (!vis[i]) \\n            {\\n                vector <int> v;\\n                dfs(i, v);\\n                if (v.size() <= 2) c++;\\n                else \\n                {\\n                    bool f = true;\\n                    for (int j = 0; j < v.size(); j++)\\n                    {\\n                        int sz = ar[v[j]].size();\\n                        if (sz != v.size()-1) f = false;\\n                    }\\n                    if (f == true) c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957403,
                "title": "python-solution-using-disjoint-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. \\n-->\\nA graph is said to be complete if it has $$(n * (n - 1)) / 2$$ edges where n is the number of nodes. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a Disjoint Set, the edges will be added one by one to the graph and while adding the edges to the graph, we will keep a count of edges and number of nodes for each graph.\\n\\nLastly, when checking the parent of the each graph, we will get the count of nodes and the number of edges and it must satisfy the property mentioned in the Intuition Section. if it satisfies then we increase the count by 1 for the complete graph. At the end, we will return the total count from the method.\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/254f0d29-0c66-4c4e-ba3d-6e756a2fd77e_1692946563.711879.png)\\n\\n\\n# Code\\n```\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1 for i in range(n)]\\n        self.edges = [0 for i in range(n)]\\n    \\n    def GetParent(self, node):\\n        if node == self.parent[node]:\\n            return node\\n\\n        self.parent[node] = self.GetParent(self.parent[node])\\n        return self.parent[node]\\n    \\n    def UnionBySize(self, u, v):\\n        ulp_u = self.GetParent(u)\\n        ulp_v = self.GetParent(v)\\n\\n        if ulp_u == ulp_v:\\n            self.edges[ulp_u] += 1\\n            return\\n\\n        if self.size[ulp_u] < self.size[ulp_v]:\\n            self.parent[ulp_u] = ulp_v\\n            self.size[ulp_v] += self.size[ulp_u]\\n            self.edges[ulp_v] += 1 + self.edges[ulp_u]\\n        else:\\n            self.parent[ulp_v] = ulp_u\\n            self.size[ulp_u] += self.size[ulp_v]\\n            self.edges[ulp_u] += 1 + self.edges[ulp_v]\\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        ds = DisjointSet(n)\\n        count = 0\\n\\n        for edge in edges:\\n            u = edge[0]\\n            v = edge[1]\\n\\n            ds.UnionBySize(u, v)\\n                \\n        for i in range(n):\\n            if i == ds.parent[i]:\\n                n = ds.size[i]\\n                no_of_edges = (n * (n - 1)) // 2\\n\\n                if no_of_edges == ds.edges[i]:\\n                    count += 1\\n\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1 for i in range(n)]\\n        self.edges = [0 for i in range(n)]\\n    \\n    def GetParent(self, node):\\n        if node == self.parent[node]:\\n            return node\\n\\n        self.parent[node] = self.GetParent(self.parent[node])\\n        return self.parent[node]\\n    \\n    def UnionBySize(self, u, v):\\n        ulp_u = self.GetParent(u)\\n        ulp_v = self.GetParent(v)\\n\\n        if ulp_u == ulp_v:\\n            self.edges[ulp_u] += 1\\n            return\\n\\n        if self.size[ulp_u] < self.size[ulp_v]:\\n            self.parent[ulp_u] = ulp_v\\n            self.size[ulp_v] += self.size[ulp_u]\\n            self.edges[ulp_v] += 1 + self.edges[ulp_u]\\n        else:\\n            self.parent[ulp_v] = ulp_u\\n            self.size[ulp_u] += self.size[ulp_v]\\n            self.edges[ulp_u] += 1 + self.edges[ulp_v]\\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        ds = DisjointSet(n)\\n        count = 0\\n\\n        for edge in edges:\\n            u = edge[0]\\n            v = edge[1]\\n\\n            ds.UnionBySize(u, v)\\n                \\n        for i in range(n):\\n            if i == ds.parent[i]:\\n                n = ds.size[i]\\n                no_of_edges = (n * (n - 1)) // 2\\n\\n                if no_of_edges == ds.edges[i]:\\n                    count += 1\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938891,
                "title": "java-solution-using-dfs",
                "content": "# Intuition\\nConnected components can be found using simple DFS/BFS.\\nWe only need to count number of `complete connected` components.\\n`Complete connected` components are those where every node is connected to every other nodes.\\nSo for given numner of nodes in a component (say `n`), numnber of edges would be = n * (n - 1) / 2\\n\\n**How?**\\n(n : nodes) - connected with (n-1 : other nodes) -> total edes = n * (n-1)\\nEach edge have been counted twice since this is an undirected graph.\\nSo effective total edges = n * (n-1) / 2\\n\\nEg of complete conected component with n = 4\\n\\n```\\n1 --- 2\\n|  X  |\\n4 --- 3\\n```\\nHere each node is connected with every other nodes.\\n\\n# Approach\\n* Follow the DFS traversal.\\n* For each of the connected component, check if that component is complete connected using above formulae \\n* increment the counter if above is true\\n\\n# Complexity\\n- Time complexity: `O(V+E)`\\n\\n- Space complexity: For Adjacency list: `O(V+2*E)`\\n\\n# Code\\n```java\\nclass Solution {\\n    private void dfs(List<List<Integer>> adj, boolean[] visited, int u, Set<Integer> vertices) {\\n      visited[u] = true;\\n      vertices.add(u);\\n\\n      for (int v: adj.get(u)) {\\n        if (!visited[v]) {\\n          dfs(adj, visited, v, vertices);\\n          }\\n      }\\n    }\\n\\n    private boolean isSubGraphComplete(List<List<Integer>> adj, Set<Integer> vertices) {\\n      int n = vertices.size();\\n      int countEdges = 0;\\n      for (int v : vertices) {\\n        countEdges += adj.get(v).size();\\n      }\\n\\n      int edges = countEdges/2;\\n      return (edges == n * (n-1) / 2);\\n    }\\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n      // Create adj list\\n      List<List<Integer>> adj = new ArrayList<>();\\n      for (int i=0; i<n; ++i) {\\n        adj.add(new ArrayList<Integer>());\\n      }\\n      \\n      for (int[] edge: edges) {\\n        adj.get(edge[0]).add(edge[1]);\\n        adj.get(edge[1]).add(edge[0]);\\n      }\\n      \\n      // Count number of connected components using dfs/bfs (dfs in this case)\\n      boolean[] visited = new boolean[n];\\n      int count = 0;\\n      for (int i=0; i<n; ++i) {\\n        Set<Integer> verticesList = new HashSet<>();\\n        if (!visited[i]) {\\n          dfs(adj, visited, i, verticesList);\\n\\n          // increase the component count only if this component is complete\\n          if (isSubGraphComplete(adj, verticesList)) {\\n            count++;\\n          }\\n        }\\n      }\\n      \\n      return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n1 --- 2\\n|  X  |\\n4 --- 3\\n```\n```java\\nclass Solution {\\n    private void dfs(List<List<Integer>> adj, boolean[] visited, int u, Set<Integer> vertices) {\\n      visited[u] = true;\\n      vertices.add(u);\\n\\n      for (int v: adj.get(u)) {\\n        if (!visited[v]) {\\n          dfs(adj, visited, v, vertices);\\n          }\\n      }\\n    }\\n\\n    private boolean isSubGraphComplete(List<List<Integer>> adj, Set<Integer> vertices) {\\n      int n = vertices.size();\\n      int countEdges = 0;\\n      for (int v : vertices) {\\n        countEdges += adj.get(v).size();\\n      }\\n\\n      int edges = countEdges/2;\\n      return (edges == n * (n-1) / 2);\\n    }\\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n      // Create adj list\\n      List<List<Integer>> adj = new ArrayList<>();\\n      for (int i=0; i<n; ++i) {\\n        adj.add(new ArrayList<Integer>());\\n      }\\n      \\n      for (int[] edge: edges) {\\n        adj.get(edge[0]).add(edge[1]);\\n        adj.get(edge[1]).add(edge[0]);\\n      }\\n      \\n      // Count number of connected components using dfs/bfs (dfs in this case)\\n      boolean[] visited = new boolean[n];\\n      int count = 0;\\n      for (int i=0; i<n; ++i) {\\n        Set<Integer> verticesList = new HashSet<>();\\n        if (!visited[i]) {\\n          dfs(adj, visited, i, verticesList);\\n\\n          // increase the component count only if this component is complete\\n          if (isSubGraphComplete(adj, verticesList)) {\\n            count++;\\n          }\\n        }\\n      }\\n      \\n      return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794041,
                "title": "easy-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair<T,U>{\\n        T first;\\n        U second;\\n        Pair()\\n        {\\n\\n        }\\n        Pair(T a, U b)\\n        {\\n            first = a;\\n            second = b;\\n        }\\n    }\\n\\n    Pair<Integer, Integer> dfs(int node, List<List<Integer>> adj, boolean[] vis){\\n        vis[node] = true;\\n        int vertices = 1;\\n        int edges= adj.get(node).size();\\n        for(Integer a: adj.get(node))\\n        {\\n            if(!vis[a])\\n            {\\n             Pair<Integer, Integer> temp = dfs(a,adj,vis);\\n            vertices+=temp.first;\\n            edges+=temp.second;\\n            }\\n        }\\n        return new Pair<>(vertices,edges);\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int res = 0;\\n        boolean[] vis = new boolean[n];\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i =0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i =0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        for(int i =0;i<adj.size();i++)\\n        {\\n            if(!vis[i])\\n            {\\n                Pair<Integer, Integer> temp = dfs(i,adj,vis);\\n                if(temp.first*(temp.first-1)==temp.second)\\n            {\\n                res++;\\n            }\\n            }\\n\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair<T,U>{\\n        T first;\\n        U second;\\n        Pair()\\n        {\\n\\n        }\\n        Pair(T a, U b)\\n        {\\n            first = a;\\n            second = b;\\n        }\\n    }\\n\\n    Pair<Integer, Integer> dfs(int node, List<List<Integer>> adj, boolean[] vis){\\n        vis[node] = true;\\n        int vertices = 1;\\n        int edges= adj.get(node).size();\\n        for(Integer a: adj.get(node))\\n        {\\n            if(!vis[a])\\n            {\\n             Pair<Integer, Integer> temp = dfs(a,adj,vis);\\n            vertices+=temp.first;\\n            edges+=temp.second;\\n            }\\n        }\\n        return new Pair<>(vertices,edges);\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int res = 0;\\n        boolean[] vis = new boolean[n];\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i =0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i =0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        for(int i =0;i<adj.size();i++)\\n        {\\n            if(!vis[i])\\n            {\\n                Pair<Integer, Integer> temp = dfs(i,adj,vis);\\n                if(temp.first*(temp.first-1)==temp.second)\\n            {\\n                res++;\\n            }\\n            }\\n\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786214,
                "title": "bfs-solution",
                "content": "\\nA Graph is said to be connected if \\n--->  NumberOfEdge=(node*(node-1))\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int result=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n\\n        //first store the graph\\n        List<List<Integer>>li=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            li.add(new ArrayList<>());\\n        }\\n        for(int []edge:edges)\\n        {\\n            int first=edge[0];\\n            int second=edge[1];\\n            li.get(first).add(second);\\n            li.get(second).add(first);\\n\\n        }\\n\\n      boolean visited[]=new boolean[n];\\n      Queue<Integer>q=new LinkedList<>();\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n          if(!visited[i])\\n          {\\n              bfs(li,visited,i,q);\\n          }\\n      }\\n       return result;\\n        \\n    }\\n    public void bfs(List<List<Integer>>li,boolean visited[],int s,Queue<Integer>q)\\n    {\\n        int countEdge=0;\\n        int countNode=0;\\n        q.add(s);\\n        visited[s]=true;\\n        while(!q.isEmpty())\\n        {\\n            int u=q.poll();\\n            countNode++;\\n            for(int v:li.get(u))\\n            {\\n               countEdge++;\\n                if(!visited[v])\\n                {\\n                    visited[v]=true;\\n                    q.add(v);\\n                    \\n                }\\n            }\\n        }\\n//since it is undirected graph hence countEdge should be divide by 2\\n        if(countEdge/2==(countNode*(countNode-1))/2){\\n            result++;\\n        }\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int result=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n\\n        //first store the graph\\n        List<List<Integer>>li=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            li.add(new ArrayList<>());\\n        }\\n        for(int []edge:edges)\\n        {\\n            int first=edge[0];\\n            int second=edge[1];\\n            li.get(first).add(second);\\n            li.get(second).add(first);\\n\\n        }\\n\\n      boolean visited[]=new boolean[n];\\n      Queue<Integer>q=new LinkedList<>();\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n          if(!visited[i])\\n          {\\n              bfs(li,visited,i,q);\\n          }\\n      }\\n       return result;\\n        \\n    }\\n    public void bfs(List<List<Integer>>li,boolean visited[],int s,Queue<Integer>q)\\n    {\\n        int countEdge=0;\\n        int countNode=0;\\n        q.add(s);\\n        visited[s]=true;\\n        while(!q.isEmpty())\\n        {\\n            int u=q.poll();\\n            countNode++;\\n            for(int v:li.get(u))\\n            {\\n               countEdge++;\\n                if(!visited[v])\\n                {\\n                    visited[v]=true;\\n                    q.add(v);\\n                    \\n                }\\n            }\\n        }\\n//since it is undirected graph hence countEdge should be divide by 2\\n        if(countEdge/2==(countNode*(countNode-1))/2){\\n            result++;\\n        }\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784438,
                "title": "easy-c-dfs-calculate-node-and-edges",
                "content": "# Approach:\\n \\nWe use a depth-first search (DFS) traversal to visit all the nodes in the graph and count the number of complete connected components. To check if a connected component is complete, we compare the count of nodes (nodeCount) with the count of edges (edgeCount) within that component. If the component is complete (i.e., nodeCount * (nodeCount - 1) equals edgeCount), we increment the answer.\\n\\n# Time complexity: \\nO(n + m), where n is the number of vertices and m is the number of edges. We traverse each node and edge exactly once during the DFS traversal.\\n\\n# Space complexity: \\nO(n), where n is the number of vertices. We use additional space to store the visited array of size n and the adjacency list representation of the graph.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(int node, vector<vector<int>>& adj, vector<bool>& visited) {\\n        visited[node] = true;\\n        pair<int, int> counts = {1, adj[node].size()};\\n\\n        for (int neighbor : adj[node]) {\\n            if (!visited[neighbor]) {\\n                pair<int, int> subCounts = dfs(neighbor, adj, visited);\\n                counts.first += subCounts.first;\\n                counts.second += subCounts.second;\\n            }\\n        }\\n\\n        return counts;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for (const auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        vector<bool> visited(n, false);\\n        int completeComponents = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i]) {\\n                pair<int, int> counts = dfs(i, adj, visited);\\n                if (counts.first * (counts.first - 1) == counts.second) {\\n                    completeComponents++;\\n                }\\n            }\\n        }\\n\\n        return completeComponents;\\n    }\\n};\\n\\n```\\n\\nPlease Upvote if you liked it!",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(int node, vector<vector<int>>& adj, vector<bool>& visited) {\\n        visited[node] = true;\\n        pair<int, int> counts = {1, adj[node].size()};\\n\\n        for (int neighbor : adj[node]) {\\n            if (!visited[neighbor]) {\\n                pair<int, int> subCounts = dfs(neighbor, adj, visited);\\n                counts.first += subCounts.first;\\n                counts.second += subCounts.second;\\n            }\\n        }\\n\\n        return counts;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for (const auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        vector<bool> visited(n, false);\\n        int completeComponents = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i]) {\\n                pair<int, int> counts = dfs(i, adj, visited);\\n                if (counts.first * (counts.first - 1) == counts.second) {\\n                    completeComponents++;\\n                }\\n            }\\n        }\\n\\n        return completeComponents;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773777,
                "title": "simple-dfs-and-count",
                "content": "Simply traverse graph and count vertices and edges and check for complete graph formulae: \\n(nodes)\\\\*(nodes-1) = 2*(edges)\\n\\nChek out this [link](https://math.stackexchange.com/questions/17747/why-a-complete-graph-has-fracnn-12-edges) for simple explanation.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,unordered_map<int,vector<int>> adj,unordered_map<int,bool>& visited,int& edgesCount,int& verticesCount){\\n        visited[node]=true;\\n        verticesCount++;\\n        for(int adjNode : adj[node]){\\n            edgesCount++;\\n            if(!visited[adjNode]){\\n                dfs(adjNode,adj,visited,edgesCount,verticesCount);\\n            }   \\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        unordered_map<int,vector<int>> adj;\\n        unordered_map<int,bool> visited;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int edgesCount=0;\\n            int verticesCount=0;\\n            if(!visited[i]) {\\n                dfs(i,adj,visited,edgesCount,verticesCount);\\n                if(verticesCount*(verticesCount-1)==edgesCount) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,unordered_map<int,vector<int>> adj,unordered_map<int,bool>& visited,int& edgesCount,int& verticesCount){\\n        visited[node]=true;\\n        verticesCount++;\\n        for(int adjNode : adj[node]){\\n            edgesCount++;\\n            if(!visited[adjNode]){\\n                dfs(adjNode,adj,visited,edgesCount,verticesCount);\\n            }   \\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        unordered_map<int,vector<int>> adj;\\n        unordered_map<int,bool> visited;\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int edgesCount=0;\\n            int verticesCount=0;\\n            if(!visited[i]) {\\n                dfs(i,adj,visited,edgesCount,verticesCount);\\n                if(verticesCount*(verticesCount-1)==edgesCount) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721656,
                "title": "java-optimized-solution-dfs-easy-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that a component is complete only if it contains (n-1)+f(n-1) number of edges where n= number of nodes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. call the dfs and get nodes count and total edges count of each component.\\n2. if it satisfies the condition of the complete component, increse the count by 1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ncount=0;int ecount=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList());\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int c=0;\\n        boolean vis[]=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==false){\\n                dfs(i, vis, adj);\\n                if(ecount/2==numEdges(ncount))\\n                    c++;\\n                ecount=0;\\n                ncount=0;\\n            }\\n        }\\n        return c;\\n    }\\n    //ecount-> total edges in a component\\n    //ncount-> total nodes in a component\\n    public void dfs(int node, boolean vis[], List<List<Integer>> adj){\\n        vis[node]=true;\\n        ncount++;\\n        ecount= ecount+adj.get(node).size();\\n        for(int i=0;i<adj.get(node).size();i++){\\n            if(vis[adj.get(node).get(i)]==false){\\n                dfs(adj.get(node).get(i) , vis , adj);\\n            }\\n        }\\n    }\\n    //a component is complete only if it contains (n-1)+f(n-1) number of edges where n= number of nodes\\n    public int numEdges(int n){\\n        if(n==1)\\n            return 0;\\n        if(n==2)\\n            return 1;\\n        if(n==3)\\n            return 3;\\n        return (n-1)+numEdges(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int ncount=0;int ecount=0;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList());\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int c=0;\\n        boolean vis[]=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==false){\\n                dfs(i, vis, adj);\\n                if(ecount/2==numEdges(ncount))\\n                    c++;\\n                ecount=0;\\n                ncount=0;\\n            }\\n        }\\n        return c;\\n    }\\n    //ecount-> total edges in a component\\n    //ncount-> total nodes in a component\\n    public void dfs(int node, boolean vis[], List<List<Integer>> adj){\\n        vis[node]=true;\\n        ncount++;\\n        ecount= ecount+adj.get(node).size();\\n        for(int i=0;i<adj.get(node).size();i++){\\n            if(vis[adj.get(node).get(i)]==false){\\n                dfs(adj.get(node).get(i) , vis , adj);\\n            }\\n        }\\n    }\\n    //a component is complete only if it contains (n-1)+f(n-1) number of edges where n= number of nodes\\n    public int numEdges(int n){\\n        if(n==1)\\n            return 0;\\n        if(n==2)\\n            return 1;\\n        if(n==3)\\n            return 3;\\n        return (n-1)+numEdges(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638515,
                "title": "unique-solution-using-the-d-f-s-dfs",
                "content": "# Intuition\\nThe provided code counts the number of complete components in a graph using depth-first search (DFS). It maintains a vector of visited nodes to keep track of which nodes have been visited during the DFS traversal. The `dfs` function recursively visits the nodes and adds them to the corresponding component vector.\\n\\nThe main logic is as follows:\\n\\n1. Create an adjacency list representation of the graph using the given edges.\\n2. Initialize a vector `vis` of size `n` to keep track of visited nodes. Initially, all nodes are marked as unvisited (0).\\n3. Initialize an empty vector of vectors `comp` to store the components.\\n4. Iterate through each node in the graph. If the node has not been visited yet, create a new component vector and perform a DFS from that node, adding all visited nodes to the component vector.\\n5. Increment the component count `c` after each DFS.\\n6. After completing the DFS traversal and collecting all components, iterate through each component. Check if the number of edges for each node in the component is equal to the size of the component minus one. If not, decrement the component count `c` by 1.\\n7. Finally, return the component count `c`.\\n\\nThe code looks correct and follows the intuition of counting complete components in a graph. However, it would be helpful to provide a specific input or example to test the code and validate its correctness.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve the problem of counting complete components in a graph, we can follow the following approach:\\n\\n1. Create an adjacency list representation of the graph using the given edges. This can be done using a vector of vectors or any other suitable data structure.\\n\\n2. Initialize a vector `vis` of size `n` to keep track of visited nodes. Initially, all nodes are marked as unvisited (0).\\n\\n3. Initialize an empty vector of vectors `comp` to store the components. Each component will be represented by a separate vector.\\n\\n4. Implement a DFS (Depth-First Search) function `dfs` that takes a starting node, the adjacency list, the `vis` vector, the `comp` vector, and the component index `c` as parameters.\\n\\n5. Inside the `dfs` function, mark the current node as visited by setting `vis[node]` to 1. Add the current node to the component vector `comp[c]`.\\n\\n6. Iterate through the adjacent nodes of the current node using the adjacency list. For each adjacent node, check if it has not been visited (`vis[it] == 0`). If it is unvisited, recursively call the `dfs` function with the adjacent node, updating the `vis`, `comp`, and `c` parameters.\\n\\n7. In the main function `countCompleteComponents`, initialize a variable `c` to keep track of the component count, starting at 0.\\n\\n8. Iterate through each node in the graph. If the node has not been visited (`vis[i] == 0`), create a new component vector `comp[c]` and perform a DFS from that node using the `dfs` function. After the DFS, increment the component count `c` by 1.\\n\\n9. After completing the DFS traversal and collecting all components, iterate through each component in the `comp` vector. For each component, iterate through its nodes. Check if the number of edges for each node in the component is equal to the size of the component minus one. If the condition is not satisfied, decrement the component count `c` by 1.\\n\\n10. Finally, return the component count `c`, which represents the number of complete components in the graph.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(V + E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(V + E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(int node,vector<int>adj[],vector<int>&vis, vector<vector<int>>&comp,int c){\\n    \\n       vis[node]=1;\\n       int ans=true;\\n       comp[c].push_back(node);\\n       for(auto it:adj[node]){\\n           if(!vis[it]){\\n               dfs(it,adj,vis,comp,c);\\n           }\\n       }\\n    \\n   }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int c=0;\\n        vector<int>vis(n,0);\\n         vector<vector<int>>comp;\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                comp.push_back(vector<int>());\\n              dfs(i,adj,vis,comp,c);\\n              c++;\\n            }\\n        }\\n        for (int i = 0; i < comp.size(); i++) {\\n            for (int j = 0; j < comp[i].size(); j++) {\\n                if (adj[comp[i][j]].size() != comp[i].size() - 1) {\\n                    c--;\\n                    break;\\n                }\\n            }\\n            \\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(int node,vector<int>adj[],vector<int>&vis, vector<vector<int>>&comp,int c){\\n    \\n       vis[node]=1;\\n       int ans=true;\\n       comp[c].push_back(node);\\n       for(auto it:adj[node]){\\n           if(!vis[it]){\\n               dfs(it,adj,vis,comp,c);\\n           }\\n       }\\n    \\n   }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int c=0;\\n        vector<int>vis(n,0);\\n         vector<vector<int>>comp;\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                comp.push_back(vector<int>());\\n              dfs(i,adj,vis,comp,c);\\n              c++;\\n            }\\n        }\\n        for (int i = 0; i < comp.size(); i++) {\\n            for (int j = 0; j < comp[i].size(); j++) {\\n                if (adj[comp[i][j]].size() != comp[i].size() - 1) {\\n                    c--;\\n                    break;\\n                }\\n            }\\n            \\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591836,
                "title": "2685-count-the-number-of-complete-components",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n        main idea is that we are counting number of nodes in each component,\\n        and according to that , suppose if there n nodes in a component, for that \\n        component to be completely connected, n * (n-1) / 2 edges must be there.\\n        So now if we can count the number of edges each of the vertices have \\n        in a particular component then that sum / 2 should be equal \\n        to n * (n-1) / 2 for it to be a completely connected component.\\n        So, the bfs function here starts with a vertex, and visits all the\\n        vertices in that component and returns a vector of those vertices.\\n        Then on returning, we calculate the number of adjacents each vertex\\n        in this vector has, this sum divided by 2 will give actual number of edges,\\n        so if this equals (n * (n-1)) / 2, where n is the size of that vector,\\n        that is, number of elements in this particular component, then this\\n        component should be counted.\\n    */\\n\\n\\n    vector<int> bfs(int s, vector<int>& vis, vector<int> adj[]){\\n\\n        vector<int> nodes;\\n\\n        nodes.push_back(s);\\n        vis[s] = 1;\\n\\n        queue<int> q;\\n        q.push(s);\\n\\n\\n        while(!q.empty()){\\n\\n            int node = q.front(); q.pop();\\n\\n            for(auto it : adj[node]){\\n\\n                if(vis[it] == 0){\\n\\n                    q.push(it);\\n                    vis[it] = 1;\\n                    nodes.push_back(it);\\n                }\\n\\n            }\\n\\n        }\\n\\n\\n        return nodes;\\n\\n    }\\n\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n\\n        vector<int> adj[n];\\n\\n        for(auto& it : edges){\\n\\n            int u = it[0];\\n            int v = it[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        vector<int> vis (n, 0);\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < n; i++){\\n\\n            if(vis[i] == 0){\\n\\n                vector<int> nodes = bfs(i, vis, adj);\\n\\n                int nodeCount = nodes.size();\\n\\n                int edgeCount = 0;\\n\\n                for(int& node : nodes){\\n\\n                    edgeCount += adj[node].size();\\n\\n                }\\n\\n                int requiredEdges = (nodeCount) * (nodeCount - 1) / 2;\\n\\n                if(requiredEdges == (edgeCount / 2))\\n                    count++;\\n                \\n\\n            }\\n\\n        }\\n\\n\\n        return count;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        main idea is that we are counting number of nodes in each component,\\n        and according to that , suppose if there n nodes in a component, for that \\n        component to be completely connected, n * (n-1) / 2 edges must be there.\\n        So now if we can count the number of edges each of the vertices have \\n        in a particular component then that sum / 2 should be equal \\n        to n * (n-1) / 2 for it to be a completely connected component.\\n        So, the bfs function here starts with a vertex, and visits all the\\n        vertices in that component and returns a vector of those vertices.\\n        Then on returning, we calculate the number of adjacents each vertex\\n        in this vector has, this sum divided by 2 will give actual number of edges,\\n        so if this equals (n * (n-1)) / 2, where n is the size of that vector,\\n        that is, number of elements in this particular component, then this\\n        component should be counted.\\n    */\\n\\n\\n    vector<int> bfs(int s, vector<int>& vis, vector<int> adj[]){\\n\\n        vector<int> nodes;\\n\\n        nodes.push_back(s);\\n        vis[s] = 1;\\n\\n        queue<int> q;\\n        q.push(s);\\n\\n\\n        while(!q.empty()){\\n\\n            int node = q.front(); q.pop();\\n\\n            for(auto it : adj[node]){\\n\\n                if(vis[it] == 0){\\n\\n                    q.push(it);\\n                    vis[it] = 1;\\n                    nodes.push_back(it);\\n                }\\n\\n            }\\n\\n        }\\n\\n\\n        return nodes;\\n\\n    }\\n\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n\\n        vector<int> adj[n];\\n\\n        for(auto& it : edges){\\n\\n            int u = it[0];\\n            int v = it[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        vector<int> vis (n, 0);\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < n; i++){\\n\\n            if(vis[i] == 0){\\n\\n                vector<int> nodes = bfs(i, vis, adj);\\n\\n                int nodeCount = nodes.size();\\n\\n                int edgeCount = 0;\\n\\n                for(int& node : nodes){\\n\\n                    edgeCount += adj[node].size();\\n\\n                }\\n\\n                int requiredEdges = (nodeCount) * (nodeCount - 1) / 2;\\n\\n                if(requiredEdges == (edgeCount / 2))\\n                    count++;\\n                \\n\\n            }\\n\\n        }\\n\\n\\n        return count;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567167,
                "title": "c-solution-with-comments",
                "content": "# Complexity\\n- Time complexity:\\n    0(V+E)\\n\\n- Space complexity:\\n    0(V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum; // to store no of edges in graph\\n    int c; // to store no of nodes in graph\\n    void dfs(int node , vector<int>adj[],vector<int> &vis){\\n        vis[node] = 1;\\n        c++;\\n        sum+=adj[node].size();\\n\\n        for(auto it : adj[node]){\\n            if(vis[it] == 0){\\n                dfs(it,adj,vis);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        //create graph from input\\n        for(auto it : edges){\\n            int u =it[0];\\n            int v =it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int ans=0;\\n        int res=0;\\n        vector<int>vis(n,0);\\n    //now u need to know little bit about graph theory before moving on\\n    // if no of nodes in connected graph =n then no of edges = n*(n-1)/2\\n    //no how to find no of edges ? by handshaking lemma we can say that no of edges = sum of all indegrees \\n\\n    //we are using the same logic \\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                c=0,sum=0; //initialising with zero so that we get our count start from zero when we count for every component\\n                dfs(i,adj,vis);\\n                cout<<c<<\" \"<<sum<<endl;\\n                int edges = sum/2;\\n                if(c*(c-1)/2 == edges)\\n                    res++;\\n    }\\n}\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum; // to store no of edges in graph\\n    int c; // to store no of nodes in graph\\n    void dfs(int node , vector<int>adj[],vector<int> &vis){\\n        vis[node] = 1;\\n        c++;\\n        sum+=adj[node].size();\\n\\n        for(auto it : adj[node]){\\n            if(vis[it] == 0){\\n                dfs(it,adj,vis);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        //create graph from input\\n        for(auto it : edges){\\n            int u =it[0];\\n            int v =it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        int ans=0;\\n        int res=0;\\n        vector<int>vis(n,0);\\n    //now u need to know little bit about graph theory before moving on\\n    // if no of nodes in connected graph =n then no of edges = n*(n-1)/2\\n    //no how to find no of edges ? by handshaking lemma we can say that no of edges = sum of all indegrees \\n\\n    //we are using the same logic \\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                c=0,sum=0; //initialising with zero so that we get our count start from zero when we count for every component\\n                dfs(i,adj,vis);\\n                cout<<c<<\" \"<<sum<<endl;\\n                int edges = sum/2;\\n                if(c*(c-1)/2 == edges)\\n                    res++;\\n    }\\n}\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3560054,
                "title": "python-dfs",
                "content": "Approch:\\n\\t- basically question is saying `Find some` \\n* \\t **component(connected nodes)** `that are` **complete graphs** \\n\\n\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        def dfs(i): \\n            component.add(i)\\n            \\n            for neighbour in graph[i]:\\n                if neighbour not in visited:\\n                    visited.add(neighbour)\\n                    dfs(neighbour)\\n\\t\\t\\t\\t\\t\\n        visited = set() \\n        res = 0 \\n        for i in range(n):\\n            if i not in visited:\\n                component = set() #this set will carry our connected components after the `dfs(i)`\\n                visited.add(i)\\n                dfs(i)\\n                # this is the part that we check if the length of the components\\n\\t\\t\\t\\t# are equal with the number of current number neghibhours in the graph\\n                if all(len(graph[node]) == len(component)-1 for node in component):\\n                       res += 1 \\n        return res\\n        \\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        def dfs(i): \\n            component.add(i)\\n            \\n            for neighbour in graph[i]:\\n                if neighbour not in visited:\\n                    visited.add(neighbour)\\n                    dfs(neighbour)\\n\\t\\t\\t\\t\\t\\n        visited = set() \\n        res = 0 \\n        for i in range(n):\\n            if i not in visited:\\n                component = set() #this set will carry our connected components after the `dfs(i)`\\n                visited.add(i)\\n                dfs(i)\\n                # this is the part that we check if the length of the components\\n\\t\\t\\t\\t# are equal with the number of current number neghibhours in the graph\\n                if all(len(graph[node]) == len(component)-1 for node in component):\\n                       res += 1 \\n        return res\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558119,
                "title": "c-basic-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>> &adj,vector<int> &vis,int &vertices,int &noofedges){\\n        if(vis[node]) return;\\n        vis[node]=1;\\n        vertices++;\\n        noofedges+=adj[node].size();\\n        for(auto it:adj[node]){\\n            dfs(it,adj,vis,vertices,noofedges);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n);\\n        int ccompo=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int x=0,y=0;\\n                dfs(i,adj,vis,x,y);\\n                if(x*(x-1)==y) ccompo++;\\n            }\\n        }\\n        return ccompo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<vector<int>> &adj,vector<int> &vis,int &vertices,int &noofedges){\\n        if(vis[node]) return;\\n        vis[node]=1;\\n        vertices++;\\n        noofedges+=adj[node].size();\\n        for(auto it:adj[node]){\\n            dfs(it,adj,vis,vertices,noofedges);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n);\\n        int ccompo=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int x=0,y=0;\\n                dfs(i,adj,vis,x,y);\\n                if(x*(x-1)==y) ccompo++;\\n            }\\n        }\\n        return ccompo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546074,
                "title": "easy-c-sol-dfs-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\npair<int,int>dfs(int src,vector<int>adj[],vector<int>&vis){\\n        vis[src]=1;\\n        int vertices=1;\\n        int edges=adj[src].size();\\n        \\n        for(auto i:adj[src] ){\\n            if(!vis[i]){\\n               pair<int,int>temp= dfs(i,adj,vis);\\n               vertices+=temp.first;\\n                edges+=temp.second;\\n        }\\n}\\n        return {vertices,edges};\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n                vector<int>adj[n];\\n        \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n             pair<int,int>temp= dfs(i,adj,vis);\\n             int ver=temp.first;\\n                int edges=temp.second;\\n             if(ver*(ver-1)==edges)ans++;\\n            \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\npair<int,int>dfs(int src,vector<int>adj[],vector<int>&vis){\\n        vis[src]=1;\\n        int vertices=1;\\n        int edges=adj[src].size();\\n        \\n        for(auto i:adj[src] ){\\n            if(!vis[i]){\\n               pair<int,int>temp= dfs(i,adj,vis);\\n               vertices+=temp.first;\\n                edges+=temp.second;\\n        }\\n}\\n        return {vertices,edges};\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n                vector<int>adj[n];\\n        \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n             pair<int,int>temp= dfs(i,adj,vis);\\n             int ver=temp.first;\\n                int edges=temp.second;\\n             if(ver*(ver-1)==edges)ans++;\\n            \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538285,
                "title": "c-bfs-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat is needed to be doein the task in simple words?\\n* we have graph\\n* we need to find amount of the components (component is a set of nodes that are connected by edges)\\n* all of the nodes in such component also should be connected with the rest of it (like if we have graph `{0, 1, 2}` => there should be edges `{{0, 2}, {0, 3}, {1, 2}}`). This means that the number of edges of this node should be `component.size() - 1`.\\n\\nYou can use different approaches for it, but my fav is BFS .\\n*Yeah, maybe the best match here is DSU, but I don\\'t like it XD*\\n\\nPlease, study BFS on your own, I don\\'t want to take you time here to explain it.\\n\\nBut why BFS? What thoughts led me to this?\\nThe answer is simple - in this problem (as I hope you can see) was asked to traverse the graph, so you have several options here and I like to do BFS. That\\'s it =)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are going to make BFS for each node in `[0, ..., n - 1]`, mark what we have visit already, to note iterate one more time.\\n\\nBut to count the components that we are looking for we need to track which nodes are in this component. For this I gonna use `std::unordered_set` - it\\'s simple to use use and fast enough.\\n\\nSo, how we will find the component:\\n1. Run BFS for some node.\\n2. Save nodes of this component to set.\\n3. Iterate over set and check if this node has `set.size() - 1` edges.\\n\\nFor more about algo, please see the code\\n\\n> Please upvote if you like it!\\n\\n# Complexity\\n- Time complexity: $$ O(n^{(n + E)}) $$. This is because we have one main `for` ($$O(n)$$), than inside we have two additional loops:\\n    1. First for BFS with $$O(E)$$, where `E` is amount of edges in component.\\n    2. Second for iterating of the nodes in component with $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + E)$$. This is because `graph` is the biggest memory structure.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        // convert to something more usable\\n        std::vector<std::vector<int>> graph(n);\\n        for(const auto& edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // to mark each node that was visited\\n        std::vector<bool> visited(n);\\n        int result = 0;\\n\\n        for(int i = 0; i < n; ++i) {\\n            // no need to iterate one more time\\n            if(visited[i]) {\\n                continue;\\n            }\\n\\n            // to store one component\\n            std::unordered_set<int> localGraph;\\n\\n            // BFS start\\n            std::queue<int> q;\\n            q.push(i);\\n            visited[i] = true;\\n            localGraph.insert(i);\\n\\n            while(!q.empty()) {\\n                auto current = q.front();\\n                q.pop();\\n\\n                for(auto next: graph[current]) {\\n                    if(!visited[next]) {\\n                        visited[next] = true;\\n                        localGraph.insert(next);\\n                        q.push(next);\\n                    }\\n                }\\n            }\\n\\n            // to check if each node of component meets the requirements\\n            bool isComplete = true;\\n            for(const auto node: localGraph) {\\n                if(graph[node].size() != localGraph.size() - 1) {\\n                    isComplete = false;\\n                    break;\\n                }\\n            }\\n\\n            // if yes, that is component we are looking for\\n            if(isComplete) {\\n                ++result;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        // convert to something more usable\\n        std::vector<std::vector<int>> graph(n);\\n        for(const auto& edge: edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // to mark each node that was visited\\n        std::vector<bool> visited(n);\\n        int result = 0;\\n\\n        for(int i = 0; i < n; ++i) {\\n            // no need to iterate one more time\\n            if(visited[i]) {\\n                continue;\\n            }\\n\\n            // to store one component\\n            std::unordered_set<int> localGraph;\\n\\n            // BFS start\\n            std::queue<int> q;\\n            q.push(i);\\n            visited[i] = true;\\n            localGraph.insert(i);\\n\\n            while(!q.empty()) {\\n                auto current = q.front();\\n                q.pop();\\n\\n                for(auto next: graph[current]) {\\n                    if(!visited[next]) {\\n                        visited[next] = true;\\n                        localGraph.insert(next);\\n                        q.push(next);\\n                    }\\n                }\\n            }\\n\\n            // to check if each node of component meets the requirements\\n            bool isComplete = true;\\n            for(const auto node: localGraph) {\\n                if(graph[node].size() != localGraph.size() - 1) {\\n                    isComplete = false;\\n                    break;\\n                }\\n            }\\n\\n            // if yes, that is component we are looking for\\n            if(isComplete) {\\n                ++result;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530665,
                "title": "simple-dsu-is-required-naive-solution-gets-98-efficiency-both-in-time-and-space",
                "content": "# Basic DSU\\nJust count the number of edges in each set and compare it with (edgeCount*(edgeCount-1))/2 if its true then increment else go on.\\n```\\nclass Solution {\\npublic:\\n    vector<int> par;\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        par.resize(n,-1);\\n        vector<int> cnt(n,0);\\n        for(vector<int>& x:e){\\n            int u=x[0],v=x[1];\\n            Union(u,v);\\n            int t=find(u);\\n            cnt[t]+=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int x=-1*par[i];\\n            if((par[i]<0 && cnt[i]==(x*(x-1))/2) || par[i]==-1) ans++;\\n        }\\n        return ans;\\n    }\\n    int find(int a){\\n        if(par[a]<0) return a;\\n        return par[a] = find(par[a]);\\n    }\\n    void Union(int a,int b){\\n        int x=find(a);\\n        int y=find(b);\\n        \\n        if(x==y) return;\\n        if(par[x]<par[y]){\\n            par[x] += par[y];\\n            par[y] = x;\\n        }\\n        else{\\n            par[y] += par[x];\\n            par[x] = y;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> par;\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        par.resize(n,-1);\\n        vector<int> cnt(n,0);\\n        for(vector<int>& x:e){\\n            int u=x[0],v=x[1];\\n            Union(u,v);\\n            int t=find(u);\\n            cnt[t]+=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int x=-1*par[i];\\n            if((par[i]<0 && cnt[i]==(x*(x-1))/2) || par[i]==-1) ans++;\\n        }\\n        return ans;\\n    }\\n    int find(int a){\\n        if(par[a]<0) return a;\\n        return par[a] = find(par[a]);\\n    }\\n    void Union(int a,int b){\\n        int x=find(a);\\n        int y=find(b);\\n        \\n        if(x==y) return;\\n        if(par[x]<par[y]){\\n            par[x] += par[y];\\n            par[y] = x;\\n        }\\n        else{\\n            par[y] += par[x];\\n            par[x] = y;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524728,
                "title": "best-c-solution-simple-bfs-very-basic-and-understandable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(map<int,vector<int>> mp, vector<bool> &vis, int i){\\n        \\n        vis[i] = 1;\\n        // map<int,vector<int>> store;\\n        \\n        // vis[0] = 1; \\n        queue<int> q; \\n        \\n        q.push(i); \\n        set<int> bfs; \\n        \\n        while(!q.empty()) {\\n            \\n            int node = q.front(); \\n            q.pop(); \\n            bfs.insert(node); \\n             \\n            for(auto it : mp[node]) {\\n                 \\n                if(!vis[it]) {\\n                    vis[it] = 1; \\n                    q.push(it); \\n                }\\n            }\\n        }\\n        \\n        int size = bfs.size();\\n        for(auto it: bfs){\\n            if(mp[it].size() != size-1) return false;\\n        }\\n        return true; \\n        \\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        map<int,vector<int>> mp;\\n        for(int i=0;i<edges.size();i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            mp[a].push_back(b);\\n            mp[b].push_back(a);\\n        }\\n        // adj list ban gyi\\n        \\n        vector<bool> vis(n,0);\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                // naya component hai\\n                // check karo complete hai ya nahi\\n                int val = solve(mp,vis,i);\\n                ans += val;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(map<int,vector<int>> mp, vector<bool> &vis, int i){\\n        \\n        vis[i] = 1;\\n        // map<int,vector<int>> store;\\n        \\n        // vis[0] = 1; \\n        queue<int> q; \\n        \\n        q.push(i); \\n        set<int> bfs; \\n        \\n        while(!q.empty()) {\\n            \\n            int node = q.front(); \\n            q.pop(); \\n            bfs.insert(node); \\n             \\n            for(auto it : mp[node]) {\\n                 \\n                if(!vis[it]) {\\n                    vis[it] = 1; \\n                    q.push(it); \\n                }\\n            }\\n        }\\n        \\n        int size = bfs.size();\\n        for(auto it: bfs){\\n            if(mp[it].size() != size-1) return false;\\n        }\\n        return true; \\n        \\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        map<int,vector<int>> mp;\\n        for(int i=0;i<edges.size();i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            mp[a].push_back(b);\\n            mp[b].push_back(a);\\n        }\\n        // adj list ban gyi\\n        \\n        vector<bool> vis(n,0);\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                // naya component hai\\n                // check karo complete hai ya nahi\\n                int val = solve(mp,vis,i);\\n                ans += val;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523979,
                "title": "c-using-dsu-compression-by-size-and-using-the-degree-of-node-for-counting-edges-for-each-node",
                "content": "# Approach\\nFor a component to be completely connected, each node of the component must be having an edge to each other node of that component, means if the size of the component is n then the no of edges in that component must be n-1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findparent(int i, vector<int>&parent){\\n        if(parent[i]==i)return i;\\n        return parent[i] = findparent(parent[i],parent);\\n    }\\n\\n    void unionthem(int i, int j, vector<int>&parent, vector<int>&size){\\n        i = findparent(i,parent);\\n        j = findparent(j, parent);\\n        if(i == j)return;\\n        if(size[i]>size[j]){\\n            parent[j] = i;\\n            size[i]+=size[j];\\n        }\\n\\n        else{\\n            parent[i] = j;\\n            size[j]+=size[i];\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>parent(n);\\n        iota(parent.begin(),parent.end(),0);\\n\\n        vector<int>size(n,1);\\n\\n        vector<int>degree(n);\\n        for(auto x: edges){\\n            int u = x[0];\\n            int v = x[1];\\n            unionthem(u,v,parent,size);\\n            degree[x[0]]++;\\n            degree[x[1]]++;\\n        }\\n\\n        unordered_set<int>mp;\\n        unordered_set<int>us;\\n\\n        for(int i = 0; i<n; i++){\\n            int currpar = findparent(i,parent);\\n            us.insert(currpar);\\n            if(degree[i]!=size[currpar]-1){\\n                mp.insert(currpar);\\n            }\\n        }\\n\\n        return us.size()-mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findparent(int i, vector<int>&parent){\\n        if(parent[i]==i)return i;\\n        return parent[i] = findparent(parent[i],parent);\\n    }\\n\\n    void unionthem(int i, int j, vector<int>&parent, vector<int>&size){\\n        i = findparent(i,parent);\\n        j = findparent(j, parent);\\n        if(i == j)return;\\n        if(size[i]>size[j]){\\n            parent[j] = i;\\n            size[i]+=size[j];\\n        }\\n\\n        else{\\n            parent[i] = j;\\n            size[j]+=size[i];\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>parent(n);\\n        iota(parent.begin(),parent.end(),0);\\n\\n        vector<int>size(n,1);\\n\\n        vector<int>degree(n);\\n        for(auto x: edges){\\n            int u = x[0];\\n            int v = x[1];\\n            unionthem(u,v,parent,size);\\n            degree[x[0]]++;\\n            degree[x[1]]++;\\n        }\\n\\n        unordered_set<int>mp;\\n        unordered_set<int>us;\\n\\n        for(int i = 0; i<n; i++){\\n            int currpar = findparent(i,parent);\\n            us.insert(currpar);\\n            if(degree[i]!=size[currpar]-1){\\n                mp.insert(currpar);\\n            }\\n        }\\n\\n        return us.size()-mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523038,
                "title": "bfs-variation-of-number-of-islands",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>comp;\\n    void bfs(int i,vector<int>&vis, vector<vector<int>>&graph)\\n    {\\n        queue<int>q;\\n        q.push(i);\\n        vector<int>v;\\n        v.push_back(i);\\n        vis[i]=1;\\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            for(auto ele:graph[x])\\n            {\\n                if(!vis[ele])\\n                {\\n                    v.push_back(ele);\\n                    vis[ele]=1;\\n                    q.push(ele);\\n                }\\n            }\\n        }\\n        comp.push_back(v);\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>vis(n,0);\\n        vector<vector<int>>graph(n);\\n        map<pair<int,int>,int>m;\\n        \\n        for(auto ele:edges)\\n        {\\n            m[{ele[0],ele[1]}]=1;\\n            graph[ele[0]].push_back(ele[1]);\\n            graph[ele[1]].push_back(ele[0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i]) bfs(i,vis,graph);\\n        }\\n        int cnt=0;\\n        \\n        \\n        for(auto ele:comp)\\n        {\\n            int flag=1;\\n            for(int i=0;i<ele.size();i++)\\n            {\\n                for(int j=i+1;j<ele.size();j++)\\n                {\\n                    if(m[{ele[i],ele[j]}]==0 && m[{ele[j],ele[i]}]==0)\\n                    {\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                if(flag==0)\\n                    break;\\n            }\\n            if(flag) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>comp;\\n    void bfs(int i,vector<int>&vis, vector<vector<int>>&graph)\\n    {\\n        queue<int>q;\\n        q.push(i);\\n        vector<int>v;\\n        v.push_back(i);\\n        vis[i]=1;\\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            for(auto ele:graph[x])\\n            {\\n                if(!vis[ele])\\n                {\\n                    v.push_back(ele);\\n                    vis[ele]=1;\\n                    q.push(ele);\\n                }\\n            }\\n        }\\n        comp.push_back(v);\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>vis(n,0);\\n        vector<vector<int>>graph(n);\\n        map<pair<int,int>,int>m;\\n        \\n        for(auto ele:edges)\\n        {\\n            m[{ele[0],ele[1]}]=1;\\n            graph[ele[0]].push_back(ele[1]);\\n            graph[ele[1]].push_back(ele[0]);\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i]) bfs(i,vis,graph);\\n        }\\n        int cnt=0;\\n        \\n        \\n        for(auto ele:comp)\\n        {\\n            int flag=1;\\n            for(int i=0;i<ele.size();i++)\\n            {\\n                for(int j=i+1;j<ele.size();j++)\\n                {\\n                    if(m[{ele[i],ele[j]}]==0 && m[{ele[j],ele[i]}]==0)\\n                    {\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                if(flag==0)\\n                    break;\\n            }\\n            if(flag) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522904,
                "title": "bfs-adjacency-list-union-find",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<int[]>> al = new ArrayList<>();\\n        Set<Integer> globalSet = new HashSet<>();\\n\\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int i = 0; i < n; i++) adjList.put(i, new ArrayList<>());\\n\\n        for (int[] edge : edges) {\\n            globalSet.add(edge[0]);\\n            globalSet.add(edge[1]);\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n\\n        for (int vertex : adjList.keySet()) {\\n            if (!adjList.get(vertex).isEmpty()) {\\n                al.add(bfs(adjList, vertex));\\n            }\\n        }\\n        int count = 0;\\n\\n        for (List<int[]> l : al) {\\n            if (isCompleteConnectedComponent(l)) count++;\\n        }\\n        for (int i = 0; i < n; i++) if (!globalSet.contains(i)) count++;\\n        return count;\\n    }\\n\\n    private boolean isCompleteConnectedComponent(List<int[]> edges) {\\n        // Create a set of all vertices in the component\\n        Set<Integer> vertices = new HashSet<>();\\n        for (int[] edge : edges) {\\n            vertices.add(edge[0]);\\n            vertices.add(edge[1]);\\n        }\\n\\n        // Check if all pairs of vertices are connected by an edge\\n        for (int u : vertices) {\\n            for (int v : vertices) {\\n                if (u != v && !hasEdge(edges, u, v)) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private boolean hasEdge(List<int[]> edges, int u, int v) {\\n        for (int[] edge : edges) {\\n            if ((edge[0] == u && edge[1] == v) || (edge[0] == v && edge[1] == u)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private List<int[]> bfs(Map<Integer, List<Integer>> adjList, int start) {\\n        List<int[]> ans = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(start);\\n        while (!q.isEmpty()) {\\n            int u = q.poll();\\n            for (int v : adjList.get(u)) {\\n                ans.add(new int[]{u, v});\\n                q.offer(v);\\n                adjList.get(v).remove(Integer.valueOf(u));\\n            }\\n            adjList.get(u).clear();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<int[]>> al = new ArrayList<>();\\n        Set<Integer> globalSet = new HashSet<>();\\n\\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int i = 0; i < n; i++) adjList.put(i, new ArrayList<>());\\n\\n        for (int[] edge : edges) {\\n            globalSet.add(edge[0]);\\n            globalSet.add(edge[1]);\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n\\n        for (int vertex : adjList.keySet()) {\\n            if (!adjList.get(vertex).isEmpty()) {\\n                al.add(bfs(adjList, vertex));\\n            }\\n        }\\n        int count = 0;\\n\\n        for (List<int[]> l : al) {\\n            if (isCompleteConnectedComponent(l)) count++;\\n        }\\n        for (int i = 0; i < n; i++) if (!globalSet.contains(i)) count++;\\n        return count;\\n    }\\n\\n    private boolean isCompleteConnectedComponent(List<int[]> edges) {\\n        // Create a set of all vertices in the component\\n        Set<Integer> vertices = new HashSet<>();\\n        for (int[] edge : edges) {\\n            vertices.add(edge[0]);\\n            vertices.add(edge[1]);\\n        }\\n\\n        // Check if all pairs of vertices are connected by an edge\\n        for (int u : vertices) {\\n            for (int v : vertices) {\\n                if (u != v && !hasEdge(edges, u, v)) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private boolean hasEdge(List<int[]> edges, int u, int v) {\\n        for (int[] edge : edges) {\\n            if ((edge[0] == u && edge[1] == v) || (edge[0] == v && edge[1] == u)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private List<int[]> bfs(Map<Integer, List<Integer>> adjList, int start) {\\n        List<int[]> ans = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(start);\\n        while (!q.isEmpty()) {\\n            int u = q.poll();\\n            for (int v : adjList.get(u)) {\\n                ans.add(new int[]{u, v});\\n                q.offer(v);\\n                adjList.get(v).remove(Integer.valueOf(u));\\n            }\\n            adjList.get(u).clear();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522861,
                "title": "beginner-friendly-dfs-solution-and-union-find-solution-with-comments-python",
                "content": "**Idea**: Find connected components, and check completeness.\\n\\nFor `finding connected components`, typically two types of methods: 1. `traversal`; 2. `Union-Find`.\\n\\nThis is a TRAVERSAL solution. \\n\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        # 1. build graph\\n        graph = {i: set() for i in range(n)}\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        \\n        # 2. util fn to find connected componnet\\n        def dfs(src):\\n            visited = set()\\n            s = [src]\\n            while s:\\n                node = s.pop()\\n                if node not in visited:\\n                    visited.add(node)\\n                    for nb in graph[node]:\\n                        if nb not in visited:\\n                            s.append(nb)\\n            return visited\\n        \\n        # 3. call dfs to get the connected components\\n        visited = set()\\n        \\n        clusters = []\\n        for i in range(n):\\n            if i not in visited:\\n                c = dfs(i)\\n                clusters.append(c)\\n                visited |= c\\n        \\n        \\n        # 4. util fn to check completeness\\n        def complete(c):\\n            for i in c:\\n                for j in c:\\n                    if j == i:\\n                        continue\\n                    if j not in graph[i]:\\n                        return 0\\n            return 1\\n        \\n        # 5. return\\n        return sum(complete(c) for c in clusters)\\n```\\n\\nThis is a `Union-Find` solution:\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        # 1. union-find \\n        \\n        root = {i:i for i in range(n)}\\n        rank = {i:1 for i in range(n)}\\n        \\n        def find(i):\\n            res = i\\n            while res != root[res]:\\n                root[res] = root[root[res]]\\n                res = root[res]\\n            return res\\n        \\n        def union(i, j):\\n            root_i, root_j = find(i), find(j)\\n            if root_i != root_j:\\n                if rank[root_i] >= rank[root_j]:\\n                    root[root_j] = root_i\\n                    rank[root_i] += rank[root_j]\\n                else:\\n                    root[root_i] = root_j\\n                    rank[root_j] += rank[root_i]\\n                    \\n        def get_clusters():\\n            d = {}\\n            for node, p in root.items():\\n                r = find(p)\\n                if r not in d:\\n                    d[r] = {node}\\n                else:\\n                    d[r].add(node)\\n            return d\\n        \\n        # 2. problem logic\\n        for u, v in edges:\\n            union(u, v)\\n        clusters = get_clusters().values()\\n                    \\n                \\n        \\n        # 3. util fn to check completeness\\n        graph_edges = {tuple(edge) for edge in edges}\\n        def complete(c):\\n            for i in c:\\n                for j in c:\\n                    if j == i:\\n                        continue\\n                    if ((i, j) not in graph_edges) and ((j, i) not in graph_edges):\\n                        return 0\\n            return 1\\n        \\n        # 4. return\\n        return sum(complete(c) for c in clusters)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        # 1. build graph\\n        graph = {i: set() for i in range(n)}\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        \\n        # 2. util fn to find connected componnet\\n        def dfs(src):\\n            visited = set()\\n            s = [src]\\n            while s:\\n                node = s.pop()\\n                if node not in visited:\\n                    visited.add(node)\\n                    for nb in graph[node]:\\n                        if nb not in visited:\\n                            s.append(nb)\\n            return visited\\n        \\n        # 3. call dfs to get the connected components\\n        visited = set()\\n        \\n        clusters = []\\n        for i in range(n):\\n            if i not in visited:\\n                c = dfs(i)\\n                clusters.append(c)\\n                visited |= c\\n        \\n        \\n        # 4. util fn to check completeness\\n        def complete(c):\\n            for i in c:\\n                for j in c:\\n                    if j == i:\\n                        continue\\n                    if j not in graph[i]:\\n                        return 0\\n            return 1\\n        \\n        # 5. return\\n        return sum(complete(c) for c in clusters)\\n```\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        # 1. union-find \\n        \\n        root = {i:i for i in range(n)}\\n        rank = {i:1 for i in range(n)}\\n        \\n        def find(i):\\n            res = i\\n            while res != root[res]:\\n                root[res] = root[root[res]]\\n                res = root[res]\\n            return res\\n        \\n        def union(i, j):\\n            root_i, root_j = find(i), find(j)\\n            if root_i != root_j:\\n                if rank[root_i] >= rank[root_j]:\\n                    root[root_j] = root_i\\n                    rank[root_i] += rank[root_j]\\n                else:\\n                    root[root_i] = root_j\\n                    rank[root_j] += rank[root_i]\\n                    \\n        def get_clusters():\\n            d = {}\\n            for node, p in root.items():\\n                r = find(p)\\n                if r not in d:\\n                    d[r] = {node}\\n                else:\\n                    d[r].add(node)\\n            return d\\n        \\n        # 2. problem logic\\n        for u, v in edges:\\n            union(u, v)\\n        clusters = get_clusters().values()\\n                    \\n                \\n        \\n        # 3. util fn to check completeness\\n        graph_edges = {tuple(edge) for edge in edges}\\n        def complete(c):\\n            for i in c:\\n                for j in c:\\n                    if j == i:\\n                        continue\\n                    if ((i, j) not in graph_edges) and ((j, i) not in graph_edges):\\n                        return 0\\n            return 1\\n        \\n        # 4. return\\n        return sum(complete(c) for c in clusters)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522700,
                "title": "c-dfs",
                "content": "```\\nvoid dfs(int node, vector<int> adjLs[], vector<int> &vis, vector<int> &nodes)\\n    {\\n        vis[node] = 1;\\n        nodes.push_back(node);\\n        for(auto a : adjLs[node])\\n        {\\n            if(!vis[a]) dfs(a, adjLs, vis, nodes);\\n        }\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int> vis(n, 0);\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                vector<int> nodes;\\n                dfs(i, adj, vis, nodes);\\n                int f=0;\\n                for(int j=0;j<nodes.size();j++)\\n                {\\n                    if(adj[nodes[j]].size() != nodes.size()-1)\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(f==0) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid dfs(int node, vector<int> adjLs[], vector<int> &vis, vector<int> &nodes)\\n    {\\n        vis[node] = 1;\\n        nodes.push_back(node);\\n        for(auto a : adjLs[node])\\n        {\\n            if(!vis[a]) dfs(a, adjLs, vis, nodes);\\n        }\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int> vis(n, 0);\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                vector<int> nodes;\\n                dfs(i, adj, vis, nodes);\\n                int f=0;\\n                for(int j=0;j<nodes.size();j++)\\n                {\\n                    if(adj[nodes[j]].size() != nodes.size()-1)\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(f==0) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522633,
                "title": "go-union-find-o-n-logn-blazingly-fast",
                "content": "# Intuition\\n\\n### Union Find\\n\\n# Approach\\n1. Add all edges to union find struct\\n2. On union increase the edge count & rank count on parent node, notice that **rank count == number on nodes in the given subgraph** while  **edge count == number of edges in subgraph**\\n3. Check all parent nodes and verify that this component is complete by the formula **edge count == (rank count * (rank count -1) / 2)**, if the result is true, means that this subgraph is complete.\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(n * logn)**\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\ntype UnionFind struct {\\n    n int // nodes count\\n    p []int // parent arary\\n    r []int // number of nodes in subgraph\\n    e []int // number of edges in subgraph\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n    p := make([]int, n)\\n    r := make([]int, n)\\n    e := make([]int, n)\\n    for i := 0; i < n; i++ { \\n        p[i] = i\\n        r[i] = 1\\n    }\\n    return &UnionFind{n: n, p: p, r: r, e: e}\\n}\\n\\nfunc (uf *UnionFind) Find(x int) int {\\n    if uf.p[x] == x {\\n        return x\\n    }\\n    return uf.Find(uf.p[x])\\n}\\n\\nfunc (uf *UnionFind) Union(i, j int) {\\n    i = uf.Find(i)\\n    j = uf.Find(j)\\n    \\n    if i != j {\\n        if uf.r[i] > uf.r[j] {\\n            uf.p[j] = i\\n            uf.r[i] += uf.r[j]\\n            uf.e[i] += uf.e[j] + 1\\n        } else {\\n            uf.p[i] = j\\n            uf.r[j] += uf.r[i]\\n            uf.e[j] += uf.e[i] + 1\\n        }\\n    } else {\\n        uf.e[i]++\\n    }\\n}\\n\\nfunc (uf *UnionFind) CountComponents() int {\\n    var x int\\n    for i := 0; i < uf.n; i++ {\\n        if uf.p[i] == i { // parent node\\n            if uf.e[i] == (uf.r[i] * (uf.r[i]-1) / 2) { // n * (n-1) / 2\\n                x++\\n            }\\n        }\\n    }\\n    return x\\n}\\n\\nfunc countCompleteComponents(n int, edges [][]int) int {\\n    uf := NewUnionFind(n)\\n    for _, e := range edges {\\n        uf.Union(e[0], e[1])\\n    }\\n    return uf.CountComponents()\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\ntype UnionFind struct {\\n    n int // nodes count\\n    p []int // parent arary\\n    r []int // number of nodes in subgraph\\n    e []int // number of edges in subgraph\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n    p := make([]int, n)\\n    r := make([]int, n)\\n    e := make([]int, n)\\n    for i := 0; i < n; i++ { \\n        p[i] = i\\n        r[i] = 1\\n    }\\n    return &UnionFind{n: n, p: p, r: r, e: e}\\n}\\n\\nfunc (uf *UnionFind) Find(x int) int {\\n    if uf.p[x] == x {\\n        return x\\n    }\\n    return uf.Find(uf.p[x])\\n}\\n\\nfunc (uf *UnionFind) Union(i, j int) {\\n    i = uf.Find(i)\\n    j = uf.Find(j)\\n    \\n    if i != j {\\n        if uf.r[i] > uf.r[j] {\\n            uf.p[j] = i\\n            uf.r[i] += uf.r[j]\\n            uf.e[i] += uf.e[j] + 1\\n        } else {\\n            uf.p[i] = j\\n            uf.r[j] += uf.r[i]\\n            uf.e[j] += uf.e[i] + 1\\n        }\\n    } else {\\n        uf.e[i]++\\n    }\\n}\\n\\nfunc (uf *UnionFind) CountComponents() int {\\n    var x int\\n    for i := 0; i < uf.n; i++ {\\n        if uf.p[i] == i { // parent node\\n            if uf.e[i] == (uf.r[i] * (uf.r[i]-1) / 2) { // n * (n-1) / 2\\n                x++\\n            }\\n        }\\n    }\\n    return x\\n}\\n\\nfunc countCompleteComponents(n int, edges [][]int) int {\\n    uf := NewUnionFind(n)\\n    for _, e := range edges {\\n        uf.Union(e[0], e[1])\\n    }\\n    return uf.CountComponents()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522631,
                "title": "just-3-main-steps-dfs-connected-graph-check-adjlist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Get the number of connected graphs.\\n2. For each connected graph, each element should be present in other\\'s adjacency list. \\n3. If the 2nd step becomes correct, increment count by 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.  Make the adjacency list using map.\\n2.  dfs approach to get the list of connected nodes.\\n3.  Check whether each node has edges to other in the connected graph.\\n -->take the adjency list and add itself to its adjency list.\\n -->If adjency list == connectedNode list (for each node in the connected graph), count it.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    List<Integer> dfs(List<Integer>list,Map<Integer,List<Integer>>map,int key,int[] vis){\\n        //visted again means traversal completed for a given connected chunk of nodes\\n        if(vis[key]==1)return list;\\n        //mark node as visted\\n        vis[key]=1;\\n        //store list in new list\\n        List<Integer>li=new ArrayList<>(list);\\n        li.add(key);\\n        for(int i=0;i<map.get(key).size();i++){\\n            //dfs call for each not visited adjacent node\\n            int adjNode=map.get(key).get(i);\\n            if(vis[adjNode]==0)li=dfs(li,map,adjNode,vis);\\n        }\\n        return li;\\n    }\\n    int conn(List<Integer>list,Map<Integer,List<Integer>>adjList){\\n        int cnt=0;\\n         for(Integer i:list){\\n             //if a node can visit to all other node\\n             //means adj list just lack itself\\n             //if we add it to its own adjacency list, \\n             //adj will be equal to list.\\n             List<Integer>adj=new ArrayList<>(adjList.get(i));\\n             adj.add(i);\\n             Collections.sort(adj);\\n             if(list.equals(adj))cnt++;\\n         }\\n        return cnt==list.size()?1:0;\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //make adjacency list using map\\n        Map<Integer,List<Integer>>map=new HashMap<>();\\n        for(int i=0;i<edges.length;i++){\\n            //undirected graph so, store both nodes in each other \\n            map.putIfAbsent(edges[i][0],new ArrayList<>());\\n            map.get(edges[i][0]).add(edges[i][1]);\\n            map.putIfAbsent(edges[i][1],new ArrayList<>());\\n            map.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            //empty adjacency list for single nodes\\n            map.putIfAbsent(i,new ArrayList<>());\\n        }\\n        int[] vis=new int[map.size()];\\n        int sum=0;\\n        for(Map.Entry<Integer,List<Integer>>m:map.entrySet()){\\n            if(vis[m.getKey()]==0){\\n                List<Integer>list=new ArrayList<>();\\n                //get the list of connected nodes\\n                list=dfs(list,map,m.getKey(),vis);\\n                \\n                if(list.size()==1)sum++;\\n                else{\\n                    //sort it to match with the adjacency list of particular nodes.\\n                    Collections.sort(list);\\n                    sum+=conn(list,map);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n**If you find anything to add here, feel free to share. Happy coding :)**\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> dfs(List<Integer>list,Map<Integer,List<Integer>>map,int key,int[] vis){\\n        //visted again means traversal completed for a given connected chunk of nodes\\n        if(vis[key]==1)return list;\\n        //mark node as visted\\n        vis[key]=1;\\n        //store list in new list\\n        List<Integer>li=new ArrayList<>(list);\\n        li.add(key);\\n        for(int i=0;i<map.get(key).size();i++){\\n            //dfs call for each not visited adjacent node\\n            int adjNode=map.get(key).get(i);\\n            if(vis[adjNode]==0)li=dfs(li,map,adjNode,vis);\\n        }\\n        return li;\\n    }\\n    int conn(List<Integer>list,Map<Integer,List<Integer>>adjList){\\n        int cnt=0;\\n         for(Integer i:list){\\n             //if a node can visit to all other node\\n             //means adj list just lack itself\\n             //if we add it to its own adjacency list, \\n             //adj will be equal to list.\\n             List<Integer>adj=new ArrayList<>(adjList.get(i));\\n             adj.add(i);\\n             Collections.sort(adj);\\n             if(list.equals(adj))cnt++;\\n         }\\n        return cnt==list.size()?1:0;\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //make adjacency list using map\\n        Map<Integer,List<Integer>>map=new HashMap<>();\\n        for(int i=0;i<edges.length;i++){\\n            //undirected graph so, store both nodes in each other \\n            map.putIfAbsent(edges[i][0],new ArrayList<>());\\n            map.get(edges[i][0]).add(edges[i][1]);\\n            map.putIfAbsent(edges[i][1],new ArrayList<>());\\n            map.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            //empty adjacency list for single nodes\\n            map.putIfAbsent(i,new ArrayList<>());\\n        }\\n        int[] vis=new int[map.size()];\\n        int sum=0;\\n        for(Map.Entry<Integer,List<Integer>>m:map.entrySet()){\\n            if(vis[m.getKey()]==0){\\n                List<Integer>list=new ArrayList<>();\\n                //get the list of connected nodes\\n                list=dfs(list,map,m.getKey(),vis);\\n                \\n                if(list.size()==1)sum++;\\n                else{\\n                    //sort it to match with the adjacency list of particular nodes.\\n                    Collections.sort(list);\\n                    sum+=conn(list,map);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522523,
                "title": "c-bfs-indegree-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>v(n, 0);\\n        vector<int>adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans=0;\\n        vector<int>indeg(n, 0);\\n        for(int i=0; i<n; i++){\\n            for(auto it: adj[i]){\\n                indeg[it]++;\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            if(!v[i]){\\n                v[i]=1;\\n                vector<int>vec;\\n                queue<int>q;\\n                q.push(i);\\n                while(!q.empty()){\\n                    int x=q.front();\\n                    //cout<<x<<\" hi\"<<endl;\\n                    vec.push_back(x);\\n                    q.pop();\\n                    for(auto it: adj[x]){\\n                        //cout<<it<<\" hi\"<<endl;\\n                        if(!v[it]){\\n                            //cout<<it<<\" chk\"<<endl;\\n                            v[it]=1;\\n                            q.push(it);\\n                        }\\n                    }\\n                }\\n                int chk=1;\\n                for(int j=0; j<vec.size(); j++){\\n                    //cout<<vec[j]<<\" \"<<indeg[vec[j]]<<endl;\\n                    if(indeg[vec[j]]!=vec.size()-1){\\n                        chk=-1; break;\\n                    }\\n                }\\n                //cout<<endl;\\n                if(chk==1){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>v(n, 0);\\n        vector<int>adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans=0;\\n        vector<int>indeg(n, 0);\\n        for(int i=0; i<n; i++){\\n            for(auto it: adj[i]){\\n                indeg[it]++;\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            if(!v[i]){\\n                v[i]=1;\\n                vector<int>vec;\\n                queue<int>q;\\n                q.push(i);\\n                while(!q.empty()){\\n                    int x=q.front();\\n                    //cout<<x<<\" hi\"<<endl;\\n                    vec.push_back(x);\\n                    q.pop();\\n                    for(auto it: adj[x]){\\n                        //cout<<it<<\" hi\"<<endl;\\n                        if(!v[it]){\\n                            //cout<<it<<\" chk\"<<endl;\\n                            v[it]=1;\\n                            q.push(it);\\n                        }\\n                    }\\n                }\\n                int chk=1;\\n                for(int j=0; j<vec.size(); j++){\\n                    //cout<<vec[j]<<\" \"<<indeg[vec[j]]<<endl;\\n                    if(indeg[vec[j]]!=vec.size()-1){\\n                        chk=-1; break;\\n                    }\\n                }\\n                //cout<<endl;\\n                if(chk==1){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3522504,
                "title": "c-dsu-union-find",
                "content": "# Intuition\\nA component of graph can be imagined as all the nodes in the sub graph having same representive.\\nFor this subgrah to be fully connected, the number of edges in the sub graph should be n*(n-1)/2 where n is the number of nodes in the graph (All the edges are unique).\\n\\nThe representatives, number of edges and members in graph can be easily maintained in DSU.\\n# Approach\\n1.) For all edges, take union of vertices of an edge, as they would be in same subgraph\\n2.) Now vertices are represented by their representatives in the subgraph, number of edges of each sub graph can be counted.\\n3.) Take any vertice of an edge and add 1 to count of edges of the family.\\n4.) Now for each representative check if edges = (vertices * (vertices-1))/2, if it is, add 1 to ans.\\n5.) Return ans.\\n\\n# Complexity\\ne is the number of edges and n is the number of nodes in the whole graph\\n- Time complexity:\\n    Union operation is $O(1)$ and it is done e number of times ,i.e,\\n    $O(e)$ , then adding edges is also $O(1)$ done e times, i.e. $O(e)$. Then the families function iterates over all nodes in graph and checks for valid number of edges, $O(n)$\\n\\n    Total\\n    $O(e + e+n)$\\n    ==> $O(e+n)$\\n- Space complexity: 4 arrays of size n is maintained.\\n- $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class DSU{\\n        public:\\n        vector<int> P;\\n        vector<int> rank;\\n        vector<int> cnt_edge;\\n        vector<int> cnt_members;\\n        int n;\\n        \\n        DSU(int N){\\n            n = N;\\n            rank = vector<int>(n,0);\\n            cnt_edge = vector<int>(n,0);\\n            cnt_members = vector<int>(n,1);\\n            for(int i=0;i<n;i++){\\n                P.push_back(i);\\n            }\\n        }\\n        \\n        int Find(int x){\\n            if(P[x]!=x) return P[x] = Find(P[x]);\\n            return x;\\n        }\\n        \\n        void Union(int a, int b){\\n            int x = Find(a);\\n            int y = Find(b);\\n            if(x!=y){\\n                if(rank[x]>rank[y]){\\n                    P[y] = x;\\n                    cnt_members[x]+=cnt_members[y];\\n                }\\n                else if(rank[y]>rank[x]){\\n                    P[x] = y;\\n                    cnt_members[y]+=cnt_members[x];\\n                }\\n                else{\\n                    rank[y]++;\\n                    P[x] = y;\\n                    cnt_members[y]+=cnt_members[x];\\n                }\\n            }\\n        }\\n        void addEdges(int u){\\n            cnt_edge[Find(u)]++;\\n        }\\n        int Families(){\\n            int ans = 0;\\n            for(int i=0;i<n;i++){\\n                if(P[i]==i){\\n                    int e = cnt_edge[i];\\n                    int v = cnt_members[i];\\n                    if(e == v*(v-1)/2) ans++;\\n                }\\n            }\\n            return ans;\\n        }\\n    };\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU dsu(n);\\n        for(auto&edge:edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            dsu.Union(u,v);\\n        }\\n        for(auto&edge:edges){\\n            int u = edge[0];\\n            dsu.addEdges(u);\\n        }\\n        \\n        return dsu.Families();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class DSU{\\n        public:\\n        vector<int> P;\\n        vector<int> rank;\\n        vector<int> cnt_edge;\\n        vector<int> cnt_members;\\n        int n;\\n        \\n        DSU(int N){\\n            n = N;\\n            rank = vector<int>(n,0);\\n            cnt_edge = vector<int>(n,0);\\n            cnt_members = vector<int>(n,1);\\n            for(int i=0;i<n;i++){\\n                P.push_back(i);\\n            }\\n        }\\n        \\n        int Find(int x){\\n            if(P[x]!=x) return P[x] = Find(P[x]);\\n            return x;\\n        }\\n        \\n        void Union(int a, int b){\\n            int x = Find(a);\\n            int y = Find(b);\\n            if(x!=y){\\n                if(rank[x]>rank[y]){\\n                    P[y] = x;\\n                    cnt_members[x]+=cnt_members[y];\\n                }\\n                else if(rank[y]>rank[x]){\\n                    P[x] = y;\\n                    cnt_members[y]+=cnt_members[x];\\n                }\\n                else{\\n                    rank[y]++;\\n                    P[x] = y;\\n                    cnt_members[y]+=cnt_members[x];\\n                }\\n            }\\n        }\\n        void addEdges(int u){\\n            cnt_edge[Find(u)]++;\\n        }\\n        int Families(){\\n            int ans = 0;\\n            for(int i=0;i<n;i++){\\n                if(P[i]==i){\\n                    int e = cnt_edge[i];\\n                    int v = cnt_members[i];\\n                    if(e == v*(v-1)/2) ans++;\\n                }\\n            }\\n            return ans;\\n        }\\n    };\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU dsu(n);\\n        for(auto&edge:edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            dsu.Union(u,v);\\n        }\\n        for(auto&edge:edges){\\n            int u = edge[0];\\n            dsu.addEdges(u);\\n        }\\n        \\n        return dsu.Families();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522467,
                "title": "easy-c-solution-disjoint-set-union-dsu-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Store the number of edges for each node.\\n- Find the number of disjoint components using DSU, it will be the max possible ans\\n- Find parent of every node and store all the child nodes of each parent in a hashmap `map<int,vector<int>>`\\n- Update the `DsuSize[i]` size of every node to make it equal to the size of `DsuSize[parent]`, so that `DsuSize[node]` of every node denotes the size of the component that node is a part of.\\n- Now iterate the hashmap and check if `DsuSize[node]-1` is equal to `m[node]` (edges connected to that node), if not then subtract one from `ans` (number of disjoint components) to remove that component from the answer\\n- Check this for the every component.\\n\\n# Complexity\\n- Time complexity: O(N * logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nconst int N=1e6;\\nint DsuParent[N];\\nint DsuSize[N];\\n\\nvoid make(int v)\\n{\\n    DsuParent[v] = v;\\n    DsuSize[v] = 1;\\n}\\n\\nint parentFind(int v)\\n{\\n    if (DsuParent[v] == v)\\n        return v;\\n    return DsuParent[v] = parentFind(DsuParent[v]);\\n}\\n\\nvoid Union(int a, int b)\\n{\\n    a = parentFind(a);\\n    b = parentFind(b);\\n\\n    if (a != b)\\n    {\\n        if (DsuSize[a] < DsuSize[b])\\n            swap(a, b);\\n        DsuParent[b] = a;\\n        DsuSize[a] += DsuSize[b];\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int si = edges.size();\\n//Intialize DSU array\\n        for(int i=0;i<n;++i){\\n\\t\\t\\tmake(i);\\n\\t\\t}\\n        \\n\\t\\tmap<int,int>m;\\n// Count connected edges for each node\\n// Union the connected nodes\\n\\t\\tfor(int i=0;i<si;++i){\\n\\t\\t\\tm[edges[i][0]]++;\\n\\t\\t\\tm[edges[i][1]]++;\\n            Union(edges[i][0],edges[i][1]);\\n\\t\\t}\\n\\n        set<int>s;\\n\\t\\tmap<int,vector<int>>p;\\n\\t\\tfor(int i=0;i<n;++i){\\n\\t\\t\\tint x = parentFind(i);\\n// Store all nodes connected to the parent node\\n\\t\\t\\tp[x].push_back(i); \\n            s.insert(x);\\n\\t\\t}\\n\\n\\t\\tint ans=s.size();\\n\\n//Update the size of component for every node\\n        for (auto it:p){\\n\\t\\t\\tint x=DsuSize[it.first];\\n\\t\\t\\tfor(auto i:it.second){\\n\\t\\t\\t\\tDsuSize[i]=x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n// Check if number of edges and size of components are note equal then remove those components from the ans\\n\\t\\tfor(auto it:p){\\n\\t\\t\\tfor(auto i:it.second){\\n\\t\\t\\t\\tif(DsuSize[i]-1 != m[i]){\\n\\t\\t\\t\\t\\tans--;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N=1e6;\\nint DsuParent[N];\\nint DsuSize[N];\\n\\nvoid make(int v)\\n{\\n    DsuParent[v] = v;\\n    DsuSize[v] = 1;\\n}\\n\\nint parentFind(int v)\\n{\\n    if (DsuParent[v] == v)\\n        return v;\\n    return DsuParent[v] = parentFind(DsuParent[v]);\\n}\\n\\nvoid Union(int a, int b)\\n{\\n    a = parentFind(a);\\n    b = parentFind(b);\\n\\n    if (a != b)\\n    {\\n        if (DsuSize[a] < DsuSize[b])\\n            swap(a, b);\\n        DsuParent[b] = a;\\n        DsuSize[a] += DsuSize[b];\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int si = edges.size();\\n//Intialize DSU array\\n        for(int i=0;i<n;++i){\\n\\t\\t\\tmake(i);\\n\\t\\t}\\n        \\n\\t\\tmap<int,int>m;\\n// Count connected edges for each node\\n// Union the connected nodes\\n\\t\\tfor(int i=0;i<si;++i){\\n\\t\\t\\tm[edges[i][0]]++;\\n\\t\\t\\tm[edges[i][1]]++;\\n            Union(edges[i][0],edges[i][1]);\\n\\t\\t}\\n\\n        set<int>s;\\n\\t\\tmap<int,vector<int>>p;\\n\\t\\tfor(int i=0;i<n;++i){\\n\\t\\t\\tint x = parentFind(i);\\n// Store all nodes connected to the parent node\\n\\t\\t\\tp[x].push_back(i); \\n            s.insert(x);\\n\\t\\t}\\n\\n\\t\\tint ans=s.size();\\n\\n//Update the size of component for every node\\n        for (auto it:p){\\n\\t\\t\\tint x=DsuSize[it.first];\\n\\t\\t\\tfor(auto i:it.second){\\n\\t\\t\\t\\tDsuSize[i]=x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n// Check if number of edges and size of components are note equal then remove those components from the ans\\n\\t\\tfor(auto it:p){\\n\\t\\t\\tfor(auto i:it.second){\\n\\t\\t\\t\\tif(DsuSize[i]-1 != m[i]){\\n\\t\\t\\t\\t\\tans--;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522315,
                "title": "easy-to-understand-c-solution-using-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n  void dfs(unordered_map<int, list<int>> &adj, vector<bool> &vis, int node, int &edge, int &c) {\\n        vis[node] = true;\\n        c++;\\n        edge += adj[node].size();\\n        for(auto nbr: adj[node]) {\\n            if(!vis[nbr]) {\\n                dfs(adj, vis, nbr, edge, c);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        unordered_map<int, list<int>> adj;\\n        vector<bool> vis(n, false);\\n        for(auto edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(vis[i] == false) {\\n                int count = 0;\\n                int edge = 0;\\n                dfs(adj, vis, i,  edge, count);\\n                if(edge == count * (count-1)) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void dfs(unordered_map<int, list<int>> &adj, vector<bool> &vis, int node, int &edge, int &c) {\\n        vis[node] = true;\\n        c++;\\n        edge += adj[node].size();\\n        for(auto nbr: adj[node]) {\\n            if(!vis[nbr]) {\\n                dfs(adj, vis, nbr, edge, c);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        unordered_map<int, list<int>> adj;\\n        vector<bool> vis(n, false);\\n        for(auto edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(vis[i] == false) {\\n                int count = 0;\\n                int edge = 0;\\n                dfs(adj, vis, i,  edge, count);\\n                if(edge == count * (count-1)) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522311,
                "title": "c-best-solution-dfs-easy-to-understand",
                "content": "\\n# Code\\n```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    void dfs(int n, int x, vvi& adjMat, vi& vis, vi& comp)  {\\n        vis[x] = 1;\\n        comp.pb(x);\\n        \\n        for(int i=0; i<n; i++)  \\n            if(!vis[i] && adjMat[i][x]) dfs(n, i, adjMat, vis, comp);\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vvi adjMat(n, vi(n, 0));\\n        for(auto it : edges)    {\\n            adjMat[it[0]][it[1]] = 1;\\n            adjMat[it[1]][it[0]] = 1;\\n        }\\n        vi vis(n, 0);\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++)  {\\n            if(!vis[i]) {\\n                vi comp;\\n                dfs(n, i, adjMat, vis, comp);\\n                int flag = 1;\\n                for(int j=0; j<comp.size(); j++)    {\\n                    for(int k=j+1; k<comp.size(); k++)  {\\n                        if( !adjMat[comp[j]][comp[k]])   flag = 0;\\n                    }\\n                }\\n                if(flag)    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    void dfs(int n, int x, vvi& adjMat, vi& vis, vi& comp)  {\\n        vis[x] = 1;\\n        comp.pb(x);\\n        \\n        for(int i=0; i<n; i++)  \\n            if(!vis[i] && adjMat[i][x]) dfs(n, i, adjMat, vis, comp);\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vvi adjMat(n, vi(n, 0));\\n        for(auto it : edges)    {\\n            adjMat[it[0]][it[1]] = 1;\\n            adjMat[it[1]][it[0]] = 1;\\n        }\\n        vi vis(n, 0);\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++)  {\\n            if(!vis[i]) {\\n                vi comp;\\n                dfs(n, i, adjMat, vis, comp);\\n                int flag = 1;\\n                for(int j=0; j<comp.size(); j++)    {\\n                    for(int k=j+1; k<comp.size(); k++)  {\\n                        if( !adjMat[comp[j]][comp[k]])   flag = 0;\\n                    }\\n                }\\n                if(flag)    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522107,
                "title": "java-union-find-solution",
                "content": "```\\nclass Solution {\\n    int[] count;\\n    int len;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        if(edges.length==0) return n;\\n        len = n;\\n        count = new int[n];\\n        DisjointUnionSets set = new DisjointUnionSets(n);\\n        for(int[] x:edges){\\n            int u = x[0];\\n            int v = x[1];\\n            count[u]++;\\n            count[v]++;\\n            set.union(u,v);\\n        }\\n        return set.connected();\\n    }\\n    class DisjointUnionSets {\\n    int[] rank, parent;\\n    int n;\\n  \\n    public DisjointUnionSets(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        this.n = n;\\n        makeSet();\\n    }\\n  \\n    void makeSet()\\n    {\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n  \\n    int find(int x)\\n    {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);\\n        }\\n  \\n        return parent[x];\\n    }\\n  \\n    void union(int x, int y)\\n    {\\n        // Find representatives of two sets\\n        int xRoot = find(x), yRoot = find(y);\\n  \\n        if (xRoot == yRoot)\\n            return;\\n  \\n        if (rank[xRoot] < rank[yRoot])\\n            parent[xRoot] = yRoot;\\n  \\n        else if (rank[yRoot] < rank[xRoot])\\n  \\n            parent[yRoot] = xRoot;\\n  \\n        else \\n        {\\n             parent[yRoot] = xRoot;\\n            rank[xRoot] = rank[xRoot] + 1;\\n        }\\n    }\\n        \\n    //customised function to get required answer\\n    int connected(){\\n        int out = 0;\\n        //for each parent\\n        for(int i=0; i<n; i++){\\n            HashSet<Integer> set = new HashSet<>();\\n            //select nodes belonging to the parent\\n            for(int j=0; j<n; j++){\\n                if(find(j)==i) set.add(j);\\n            }\\n            int total = 0;\\n            //count total edges for the set\\n            for(int x:set){\\n                total+=count[x];\\n            }\\n            int size = set.size();\\n            //add if equation  matches i.e no of edges == n*(n-1)\\n            if(size>0 && total==size*(size-1))\\n                out++;\\n            //size 1 is always connected\\n            else if(size==1) out++;\\n        }\\n        return out;\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] count;\\n    int len;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        if(edges.length==0) return n;\\n        len = n;\\n        count = new int[n];\\n        DisjointUnionSets set = new DisjointUnionSets(n);\\n        for(int[] x:edges){\\n            int u = x[0];\\n            int v = x[1];\\n            count[u]++;\\n            count[v]++;\\n            set.union(u,v);\\n        }\\n        return set.connected();\\n    }\\n    class DisjointUnionSets {\\n    int[] rank, parent;\\n    int n;\\n  \\n    public DisjointUnionSets(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        this.n = n;\\n        makeSet();\\n    }\\n  \\n    void makeSet()\\n    {\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n  \\n    int find(int x)\\n    {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);\\n        }\\n  \\n        return parent[x];\\n    }\\n  \\n    void union(int x, int y)\\n    {\\n        // Find representatives of two sets\\n        int xRoot = find(x), yRoot = find(y);\\n  \\n        if (xRoot == yRoot)\\n            return;\\n  \\n        if (rank[xRoot] < rank[yRoot])\\n            parent[xRoot] = yRoot;\\n  \\n        else if (rank[yRoot] < rank[xRoot])\\n  \\n            parent[yRoot] = xRoot;\\n  \\n        else \\n        {\\n             parent[yRoot] = xRoot;\\n            rank[xRoot] = rank[xRoot] + 1;\\n        }\\n    }\\n        \\n    //customised function to get required answer\\n    int connected(){\\n        int out = 0;\\n        //for each parent\\n        for(int i=0; i<n; i++){\\n            HashSet<Integer> set = new HashSet<>();\\n            //select nodes belonging to the parent\\n            for(int j=0; j<n; j++){\\n                if(find(j)==i) set.add(j);\\n            }\\n            int total = 0;\\n            //count total edges for the set\\n            for(int x:set){\\n                total+=count[x];\\n            }\\n            int size = set.size();\\n            //add if equation  matches i.e no of edges == n*(n-1)\\n            if(size>0 && total==size*(size-1))\\n                out++;\\n            //size 1 is always connected\\n            else if(size==1) out++;\\n        }\\n        return out;\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522046,
                "title": "easy-dfs-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& temp, vector<bool>& vis, vector<vector<bool>>& adj){\\n        vis[i] = 1;\\n        temp.push_back(i);\\n        for (int j = 0; j < adj[i].size(); j++){\\n            if(adj[i][j] && !vis[j]){\\n                solve(j, temp, vis, adj);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<vector<bool>> adj(n, vector<bool>(n, 0));\\n        for (int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]][edges[i][1]] = 1;\\n            adj[edges[i][1]][edges[i][0]] = 1;\\n        }\\n        vector<int> temp;\\n        for (int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                solve(i, temp, vis, adj);\\n                bool f = 1;\\n                for (int i = 0; i < temp.size(); i++){\\n                    for (int j = i + 1; j < temp.size(); j++){\\n                        if(!adj[temp[i]][temp[j]]){\\n                            f = 0;\\n                            break;\\n                        }\\n                    }\\n                    if(!f){\\n                        break;\\n                    }\\n                }\\n                if(f){\\n                    count++;\\n                }\\n                temp.clear();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& temp, vector<bool>& vis, vector<vector<bool>>& adj){\\n        vis[i] = 1;\\n        temp.push_back(i);\\n        for (int j = 0; j < adj[i].size(); j++){\\n            if(adj[i][j] && !vis[j]){\\n                solve(j, temp, vis, adj);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<vector<bool>> adj(n, vector<bool>(n, 0));\\n        for (int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]][edges[i][1]] = 1;\\n            adj[edges[i][1]][edges[i][0]] = 1;\\n        }\\n        vector<int> temp;\\n        for (int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                solve(i, temp, vis, adj);\\n                bool f = 1;\\n                for (int i = 0; i < temp.size(); i++){\\n                    for (int j = i + 1; j < temp.size(); j++){\\n                        if(!adj[temp[i]][temp[j]]){\\n                            f = 0;\\n                            break;\\n                        }\\n                    }\\n                    if(!f){\\n                        break;\\n                    }\\n                }\\n                if(f){\\n                    count++;\\n                }\\n                temp.clear();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521994,
                "title": "java-ez-2-understand",
                "content": "first write a simple dfs to get the number of vertices in a particular component. \\nNow for complete graph the number of neighbor vertices = number of vertices in that component-1\\n\\n\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        for(int edge[]:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        boolean[] visited = new boolean[n];\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited[i]) {\\n                count++;\\n                int c=dfs(i, visited, adj);\\n                if(!chk(i,adj,new boolean[n],c))\\n                    count--;\\n            }\\n        }\\n        return count;\\n    }\\n    boolean chk(int u,List<List<Integer>> adj,boolean vis[],int c){\\n        vis[u]=true;\\n        if(adj.get(u).size()!=c-1)\\n            return false;\\n        boolean ans=true;\\n        for(int nbr:adj.get(u)){\\n            if(!vis[nbr])\\n                ans&=chk(nbr,adj,vis,c);\\n        }\\n        //System.out.println(u+\" \"+c);\\n        return ans;\\n            \\n    }\\n    int dfs(int u, boolean[] visited, List<List<Integer>> adj) {\\n        visited[u] = true;\\n        int c=1;\\n        for (int v : adj.get(u)) {\\n            if (!visited[v]) {\\n                c+=dfs(v, visited, adj);\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        for(int edge[]:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3521969,
                "title": "rust-solution-with-collecting-edge-count-node-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_complete_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let mut graph = vec![vec![]; n];\\n        \\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n        \\n        let mut ret = 0;\\n        let mut flag = vec![0; n];\\n        \\n        for u in 0 .. n {\\n            if flag[u] == 1 { continue }\\n            \\n            let mut s = HashSet::new();\\n            let mut count = 0;\\n            Self::dfs(u, &graph, &mut flag, &mut s, &mut count);\\n            if count * (count - 1) == s.len() * 2 { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n    \\n    fn dfs(u: usize, graph: &Vec<Vec<usize>>, flag: &mut Vec<i32>, s: &mut HashSet<usize>, count: &mut usize) {\\n        flag[u] = 1;\\n        *count += 1;\\n        \\n        for v in &graph[u] {\\n            let v = *v;\\n            s.insert(u.min(v) * flag.len() + u.max(v));\\n            if flag[v] == 1 { continue }\\n            \\n            Self::dfs(v, graph, flag, s, count);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn count_complete_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let mut graph = vec![vec![]; n];\\n        \\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n        \\n        let mut ret = 0;\\n        let mut flag = vec![0; n];\\n        \\n        for u in 0 .. n {\\n            if flag[u] == 1 { continue }\\n            \\n            let mut s = HashSet::new();\\n            let mut count = 0;\\n            Self::dfs(u, &graph, &mut flag, &mut s, &mut count);\\n            if count * (count - 1) == s.len() * 2 { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n    \\n    fn dfs(u: usize, graph: &Vec<Vec<usize>>, flag: &mut Vec<i32>, s: &mut HashSet<usize>, count: &mut usize) {\\n        flag[u] = 1;\\n        *count += 1;\\n        \\n        for v in &graph[u] {\\n            let v = *v;\\n            s.insert(u.min(v) * flag.len() + u.max(v));\\n            if flag[v] == 1 { continue }\\n            \\n            Self::dfs(v, graph, flag, s, count);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521953,
                "title": "2685-count-the-number-of-complete-components-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n       int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }    \\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int parentU = find(parent, u);\\n            int parentV = find(parent, v);\\n            if (parentU != parentV) {\\n                parent[parentV] = parentU;\\n            }\\n        }  \\n        Map<Integer, Set<Integer>> groups = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int group = find(parent, i);\\n            groups.computeIfAbsent(group, k -> new HashSet<>()).add(i);\\n        }\\n        \\n        int count = 0;\\n        for (Set<Integer> group : groups.values()) {\\n            boolean isComplete = true;\\n            for (int i : group) {\\n                for (int j : group) {\\n                    if (i != j && !hasEdge(edges, i, j)) {\\n                        isComplete = false;\\n                        break;\\n                    }\\n                }\\n                if (!isComplete) {\\n                    break;\\n                }\\n            }\\n            if (isComplete) {\\n                count++;\\n            }\\n        }    \\n        return count;\\n    }\\n    private int find(int[] parent, int node) {\\n        if (parent[node] != node) {\\n            parent[node] = find(parent, parent[node]);\\n        }\\n        return parent[node];\\n    }\\n    \\n    private boolean hasEdge(int[][] edges, int u, int v) {\\n        for (int[] edge : edges) {\\n            if ((edge[0] == u && edge[1] == v) || (edge[0] == v && edge[1] == u)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n       int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }    \\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int parentU = find(parent, u);\\n            int parentV = find(parent, v);\\n            if (parentU != parentV) {\\n                parent[parentV] = parentU;\\n            }\\n        }  \\n        Map<Integer, Set<Integer>> groups = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int group = find(parent, i);\\n            groups.computeIfAbsent(group, k -> new HashSet<>()).add(i);\\n        }\\n        \\n        int count = 0;\\n        for (Set<Integer> group : groups.values()) {\\n            boolean isComplete = true;\\n            for (int i : group) {\\n                for (int j : group) {\\n                    if (i != j && !hasEdge(edges, i, j)) {\\n                        isComplete = false;\\n                        break;\\n                    }\\n                }\\n                if (!isComplete) {\\n                    break;\\n                }\\n            }\\n            if (isComplete) {\\n                count++;\\n            }\\n        }    \\n        return count;\\n    }\\n    private int find(int[] parent, int node) {\\n        if (parent[node] != node) {\\n            parent[node] = find(parent, parent[node]);\\n        }\\n        return parent[node];\\n    }\\n    \\n    private boolean hasEdge(int[][] edges, int u, int v) {\\n        for (int[] edge : edges) {\\n            if ((edge[0] == u && edge[1] == v) || (edge[0] == v && edge[1] == u)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521889,
                "title": "python-dfs-count-edges-in-every-subgraph",
                "content": "```\\nclass Solution:\\n    def dfs(self, cur, graph, seen, node_count, elements):\\n        seen[cur] = True\\n        node_count[0] += 1\\n        elements.add(cur)\\n        for neighbor in graph[cur]:\\n            if seen[neighbor] == False:\\n                self.dfs(neighbor, graph, seen, node_count, elements)\\n    \\n    def subcheck(self, elements, graph, node_count):\\n        for element in elements:\\n            edge_count = len(graph[element])\\n            if edge_count != node_count[0] - 1:\\n                return False\\n        return True\\n    \\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            \\n        seen = [False]*n\\n        answer = 0\\n        for node in range(n):\\n            if seen[node] == False:\\n                node_count = [0]\\n                elements = set()\\n                self.dfs(node, graph, seen, node_count, elements)\\n                # Subgraph check\\n                is_complete = self.subcheck(elements, graph, node_count)\\n                if is_complete:\\n                    answer += 1\\n                \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, cur, graph, seen, node_count, elements):\\n        seen[cur] = True\\n        node_count[0] += 1\\n        elements.add(cur)\\n        for neighbor in graph[cur]:\\n            if seen[neighbor] == False:\\n                self.dfs(neighbor, graph, seen, node_count, elements)\\n    \\n    def subcheck(self, elements, graph, node_count):\\n        for element in elements:\\n            edge_count = len(graph[element])\\n            if edge_count != node_count[0] - 1:\\n                return False\\n        return True\\n    \\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            \\n        seen = [False]*n\\n        answer = 0\\n        for node in range(n):\\n            if seen[node] == False:\\n                node_count = [0]\\n                elements = set()\\n                self.dfs(node, graph, seen, node_count, elements)\\n                # Subgraph check\\n                is_complete = self.subcheck(elements, graph, node_count)\\n                if is_complete:\\n                    answer += 1\\n                \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521877,
                "title": "bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> AList(n);\\n        \\n        for(vector<int>& edge : edges) {\\n            AList[edge[0]].push_back(edge[1]);\\n            AList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        \\n        function<bool(int)> bfs = [&](int i) {\\n            int nodes = 0;\\n            int edges = 0;\\n            visited[i] = true;\\n            queue<int> queue;\\n            queue.push(i);\\n            \\n            while(not queue.empty()) {\\n                int u = queue.front();\\n                queue.pop();\\n                \\n                nodes++;\\n                edges += AList[u].size();\\n                \\n                for(int v : AList[u]) {\\n                    if(not visited[v]) {\\n                        visited[v] = true;\\n                        queue.push(v);\\n                    }\\n                }\\n            }\\n            \\n            edges /= 2;\\n            if(((nodes*(long long)(nodes-1))/2) == edges) return true;\\n            return false;\\n        };\\n        \\n        \\n        int result = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(not visited[i]) {\\n                result += bfs(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> AList(n);\\n        \\n        for(vector<int>& edge : edges) {\\n            AList[edge[0]].push_back(edge[1]);\\n            AList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        \\n        function<bool(int)> bfs = [&](int i) {\\n            int nodes = 0;\\n            int edges = 0;\\n            visited[i] = true;\\n            queue<int> queue;\\n            queue.push(i);\\n            \\n            while(not queue.empty()) {\\n                int u = queue.front();\\n                queue.pop();\\n                \\n                nodes++;\\n                edges += AList[u].size();\\n                \\n                for(int v : AList[u]) {\\n                    if(not visited[v]) {\\n                        visited[v] = true;\\n                        queue.push(v);\\n                    }\\n                }\\n            }\\n            \\n            edges /= 2;\\n            if(((nodes*(long long)(nodes-1))/2) == edges) return true;\\n            return false;\\n        };\\n        \\n        \\n        int result = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(not visited[i]) {\\n                result += bfs(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521863,
                "title": "c-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nUnion Find\\n\\nEdge by edge, we union the nodes and increase the number of edges.\\nFinally, we check every group and see if the expected number of edges is equal to the actual number of edges.\\n\\nIf there are k nodes within a group, to be a complete connected components,\\nthere should be k*(k-1)/2 edges such that there exists an edge between every pair of its vertices.\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> group; // group[i] >= 0 means it belongs to another; otherwise i is the group leader and abs(group[i]) is the number of members within the group\\n    vector<int> count; // number of edges in group i\\n    \\n    int Parent(int i) {\\n        return group[i]<0?i:group[i]=Parent(group[i]);\\n    }\\n    void Union(int i, int j) {\\n        i = Parent(i);\\n        j = Parent(j);\\n        if( i != j) {\\n            // union groups\\n            group[i] += group[j];\\n            // accumulate edges\\n            count[i] += count[j];\\n            group[j] = i;\\n            \\n        } \\n        // increment the number of edge after adding a pair\\n        count[i]++;\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        group.resize(n, -1);\\n        count.resize(n, 0);\\n        for(vector<int>& edge: edges) {\\n            int a = edge[0], b = edge[1];\\n            Union(a, b);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(group[i]<0) {\\n                // if there are k nodes, there should be k*(k-1)/2 edges to be the complete connected components\\n                int k = -group[i];\\n                if(k*(k-1)/2==count[i])\\n                    ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> group; // group[i] >= 0 means it belongs to another; otherwise i is the group leader and abs(group[i]) is the number of members within the group\\n    vector<int> count; // number of edges in group i\\n    \\n    int Parent(int i) {\\n        return group[i]<0?i:group[i]=Parent(group[i]);\\n    }\\n    void Union(int i, int j) {\\n        i = Parent(i);\\n        j = Parent(j);\\n        if( i != j) {\\n            // union groups\\n            group[i] += group[j];\\n            // accumulate edges\\n            count[i] += count[j];\\n            group[j] = i;\\n            \\n        } \\n        // increment the number of edge after adding a pair\\n        count[i]++;\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        group.resize(n, -1);\\n        count.resize(n, 0);\\n        for(vector<int>& edge: edges) {\\n            int a = edge[0], b = edge[1];\\n            Union(a, b);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(group[i]<0) {\\n                // if there are k nodes, there should be k*(k-1)/2 edges to be the complete connected components\\n                int k = -group[i];\\n                if(k*(k-1)/2==count[i])\\n                    ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098960,
                "title": "using-bfs",
                "content": "# Approach\\nCreate the graph using adjacency matrix. Iterate thru all the vertices and check if visited or not. If not visited then perform bfs on that vertex and count the number of edges and nodes in the component. For the component to be connected nodes * (nodes - 1) == edges. If this case is true then update the result by 1. Return the result after all the vertices are explored.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        res = 0\\n        visited = set()\\n\\n        for src, dest in edges:\\n            graph[src].append(dest)\\n            graph[dest].append(src)\\n\\n        for i in range(n):\\n            if i not in visited:\\n                queue = [i]\\n                visited.add(i)\\n                nodes, edges = 0, 0\\n\\n                while queue:\\n                    curr_node = queue.pop(0)\\n                    nodes += 1\\n                    edges += len(graph[curr_node])\\n\\n                    for nei in graph[curr_node]:\\n                        if nei not in visited:\\n                            queue.append(nei)\\n                            visited.add(nei)\\n\\n                if nodes * (nodes - 1) == edges:\\n                    res += 1\\n        \\n        return res\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        res = 0\\n        visited = set()\\n\\n        for src, dest in edges:\\n            graph[src].append(dest)\\n            graph[dest].append(src)\\n\\n        for i in range(n):\\n            if i not in visited:\\n                queue = [i]\\n                visited.add(i)\\n                nodes, edges = 0, 0\\n\\n                while queue:\\n                    curr_node = queue.pop(0)\\n                    nodes += 1\\n                    edges += len(graph[curr_node])\\n\\n                    for nei in graph[curr_node]:\\n                        if nei not in visited:\\n                            queue.append(nei)\\n                            visited.add(nei)\\n\\n                if nodes * (nodes - 1) == edges:\\n                    res += 1\\n        \\n        return res\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097281,
                "title": "bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool bfs(int node, vector<int> adj[], vector<int> &visited)\\n{\\n    visited[node] = 1;\\n    int totNodes = 0;\\n    int totEdges = 0;\\n\\n    queue<int> q;\\n    q.push(node);\\n\\n    while (!q.empty())\\n    {\\n        int x = q.front();\\n        q.pop();\\n        totNodes++;\\n        totEdges += adj[x].size();\\n\\n        for (auto adjNode : adj[x])\\n        {\\n            if (!visited[adjNode])\\n            {\\n                q.push(adjNode);\\n                visited[adjNode] = 1;\\n            }\\n        }\\n    }\\n    totEdges /= 2;\\n    return totEdges == (totNodes * (totNodes - 1)) / 2;\\n}\\n\\nint countCompleteComponents(int n, vector<vector<int>> &edges)\\n{\\n    vector<int> adj[n];\\n    for (auto it : edges)\\n    {\\n        int u = it[0];\\n        int v = it[1];\\n        adj[u].push_back(v);\\n        adj[v].push_back(u);\\n    }\\n\\n    int count = 0;\\n    vector<int> visited(n, 0);\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (!visited[i])\\n        {\\n            if (bfs(i, adj, visited))\\n            {\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool bfs(int node, vector<int> adj[], vector<int> &visited)\\n{\\n    visited[node] = 1;\\n    int totNodes = 0;\\n    int totEdges = 0;\\n\\n    queue<int> q;\\n    q.push(node);\\n\\n    while (!q.empty())\\n    {\\n        int x = q.front();\\n        q.pop();\\n        totNodes++;\\n        totEdges += adj[x].size();\\n\\n        for (auto adjNode : adj[x])\\n        {\\n            if (!visited[adjNode])\\n            {\\n                q.push(adjNode);\\n                visited[adjNode] = 1;\\n            }\\n        }\\n    }\\n    totEdges /= 2;\\n    return totEdges == (totNodes * (totNodes - 1)) / 2;\\n}\\n\\nint countCompleteComponents(int n, vector<vector<int>> &edges)\\n{\\n    vector<int> adj[n];\\n    for (auto it : edges)\\n    {\\n        int u = it[0];\\n        int v = it[1];\\n        adj[u].push_back(v);\\n        adj[v].push_back(u);\\n    }\\n\\n    int count = 0;\\n    vector<int> visited(n, 0);\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (!visited[i])\\n        {\\n            if (bfs(i, adj, visited))\\n            {\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096352,
                "title": "c-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(n*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint total2=0;\\nint dfs(int i,vector<vector<int>>&adj,vector<int>&vis){\\n    vis[i]=1;\\n    int ans=0;\\n    for(auto j:adj[i]){\\n        if(vis[j]==0){\\n            ans+=1+dfs(j,adj,vis);\\n        }\\n        total2++;\\n    }\\n    return ans;\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n            int total=1+dfs(i,adj,vis);\\n            if(total*(total-1)==total2){\\n                ans++;\\n            }\\n            total2=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint total2=0;\\nint dfs(int i,vector<vector<int>>&adj,vector<int>&vis){\\n    vis[i]=1;\\n    int ans=0;\\n    for(auto j:adj[i]){\\n        if(vis[j]==0){\\n            ans+=1+dfs(j,adj,vis);\\n        }\\n        total2++;\\n    }\\n    return ans;\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n            int total=1+dfs(i,adj,vis);\\n            if(total*(total-1)==total2){\\n                ans++;\\n            }\\n            total2=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094008,
                "title": "best-c-solution-with-dfs-and-degree-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<int> &visited, map<int,vector<int>> &mp,vector<int> &v)\\n    {\\n        visited[i]=1;\\n        v.push_back(i);\\n        for(auto j:mp[i])\\n        {\\n            if(visited[j]==0)\\n            {\\n                dfs(j,visited,mp,v);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        map<int,vector<int>>mp;\\n        vector<int>visited(n,0);\\n        vector<int>degree(n,0);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            degree[edges[i][0]]++;\\n            degree[edges[i][1]]++;\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>v;\\n        vector<vector<int>>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                dfs(i,visited,mp,v);\\n                m.push_back(v);\\n                v.clear();\\n            }\\n        }\\n        int count=0,c=0;\\n        for(auto i:m)\\n        {\\n            vector<int>p=i;\\n            int t=p.size();\\n            for(int j=0;j<t;j++)\\n            {\\n                if(degree[p[j]]==t-1)c++;\\n            }\\n            if(c==t)count++;\\n            c=0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<int> &visited, map<int,vector<int>> &mp,vector<int> &v)\\n    {\\n        visited[i]=1;\\n        v.push_back(i);\\n        for(auto j:mp[i])\\n        {\\n            if(visited[j]==0)\\n            {\\n                dfs(j,visited,mp,v);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        map<int,vector<int>>mp;\\n        vector<int>visited(n,0);\\n        vector<int>degree(n,0);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            degree[edges[i][0]]++;\\n            degree[edges[i][1]]++;\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>v;\\n        vector<vector<int>>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                dfs(i,visited,mp,v);\\n                m.push_back(v);\\n                v.clear();\\n            }\\n        }\\n        int count=0,c=0;\\n        for(auto i:m)\\n        {\\n            vector<int>p=i;\\n            int t=p.size();\\n            for(int j=0;j<t;j++)\\n            {\\n                if(degree[p[j]]==t-1)c++;\\n            }\\n            if(c==t)count++;\\n            c=0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077865,
                "title": "simple-c-union-find-solution-beats-98-time-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially noticing that the problem revolved around finding subgraphs in an undirected graph lead me to use the Disjoint Set Union Find approach. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe disjoint set datastructure describes a graph by the parent of each node. If two nodes have the same parent they are connected. As described in the problem statement, a connected component is a graph where an edge exists between any pair of nodes. This means that a given node will have n - 1 connections. Once Union Find determines the subgraphs, the size of this subgraph can be found by counting the number of nodes with the same parent. Once the size of the subgraph is determined, a final loop through each of the nodes in the subgraph can be preformed to check if the subgraph is connected by comparing the number of connections to the size of the subgraph. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> par;\\n\\n    int find(int x) {\\n        if (par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        par.resize(n);\\n        for (int i = 0; i < n; i++) par[i] = i;\\n\\n        vector<int> conn(n);\\n        for (auto& a : edges) {\\n            conn[a[0]]++;\\n            conn[a[1]]++;\\n\\n            int x = find(a[0]);\\n            int y = find(a[1]);\\n\\n            par[x] = y;\\n        }\\n\\n        vector<int> psz(n);\\n        for (auto& a : par) {\\n            a = find(a);\\n            psz[a]++;\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (psz[par[i]] - 1 != conn[i]) \\n                psz[par[i]] = 0;\\n        }\\n\\n        for (auto& a : psz) if (a) res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> par;\\n\\n    int find(int x) {\\n        if (par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        par.resize(n);\\n        for (int i = 0; i < n; i++) par[i] = i;\\n\\n        vector<int> conn(n);\\n        for (auto& a : edges) {\\n            conn[a[0]]++;\\n            conn[a[1]]++;\\n\\n            int x = find(a[0]);\\n            int y = find(a[1]);\\n\\n            par[x] = y;\\n        }\\n\\n        vector<int> psz(n);\\n        for (auto& a : par) {\\n            a = find(a);\\n            psz[a]++;\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (psz[par[i]] - 1 != conn[i]) \\n                psz[par[i]] = 0;\\n        }\\n\\n        for (auto& a : psz) if (a) res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059744,
                "title": "each-line-explained-easy-dfs",
                "content": "DFS\\n# Code\\n```\\nclass Solution {\\n    // Depth-First Search function to traverse the connected components\\n    void dfs(int node, const vector<vector<int>> &adjacencyList, vector<bool> &visited, int &componentSize, int &totalEdges) {\\n        // Check if the current node has already been visited\\n        if (visited[node]) {\\n            return; // If visited, no need to process it again\\n        }\\n\\n        visited[node] = true; // Mark the current node as visited\\n        ++componentSize; // Increment the size of the current connected component\\n        totalEdges += adjacencyList[node].size(); // Count the total number of edges connected to this component\\n\\n        // Recursively visit all connected nodes in the component\\n        for (int neighbor : adjacencyList[node]) {\\n            // Call dfs recursively for each neighboring node to explore the component\\n            dfs(neighbor, adjacencyList, visited, componentSize, totalEdges);\\n        }\\n    }\\n\\npublic:\\n    // Function to count the number of complete connected components in a graph\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        // Create an adjacency list to represent the graph\\n        vector<vector<int>> adjacencyList(n);\\n        for (const auto& edge : edges) {\\n            adjacencyList[edge[0]].push_back(edge[1]);\\n            adjacencyList[edge[1]].push_back(edge[0]);\\n        }\\n\\n        vector<bool> visited(n); // Create a boolean array to track visited nodes\\n        int completeComponents = 0; // Initialize the count of complete connected components\\n\\n        // Traverse the graph and count complete components\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i]) {\\n                int componentSize = 0; // Initialize the size of the current component\\n                int totalEdges = 0; // Initialize the total edges connected to the component\\n                dfs(i, adjacencyList, visited, componentSize, totalEdges);\\n\\n                // Check if the component is complete (meets the condition)\\n                if (componentSize * (componentSize - 1) == totalEdges) {\\n                    ++completeComponents; // If complete, increment the count of complete components\\n                }\\n            }\\n        }\\n        return completeComponents; // Return the total count of complete components in the graph\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // Depth-First Search function to traverse the connected components\\n    void dfs(int node, const vector<vector<int>> &adjacencyList, vector<bool> &visited, int &componentSize, int &totalEdges) {\\n        // Check if the current node has already been visited\\n        if (visited[node]) {\\n            return; // If visited, no need to process it again\\n        }\\n\\n        visited[node] = true; // Mark the current node as visited\\n        ++componentSize; // Increment the size of the current connected component\\n        totalEdges += adjacencyList[node].size(); // Count the total number of edges connected to this component\\n\\n        // Recursively visit all connected nodes in the component\\n        for (int neighbor : adjacencyList[node]) {\\n            // Call dfs recursively for each neighboring node to explore the component\\n            dfs(neighbor, adjacencyList, visited, componentSize, totalEdges);\\n        }\\n    }\\n\\npublic:\\n    // Function to count the number of complete connected components in a graph\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        // Create an adjacency list to represent the graph\\n        vector<vector<int>> adjacencyList(n);\\n        for (const auto& edge : edges) {\\n            adjacencyList[edge[0]].push_back(edge[1]);\\n            adjacencyList[edge[1]].push_back(edge[0]);\\n        }\\n\\n        vector<bool> visited(n); // Create a boolean array to track visited nodes\\n        int completeComponents = 0; // Initialize the count of complete connected components\\n\\n        // Traverse the graph and count complete components\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i]) {\\n                int componentSize = 0; // Initialize the size of the current component\\n                int totalEdges = 0; // Initialize the total edges connected to the component\\n                dfs(i, adjacencyList, visited, componentSize, totalEdges);\\n\\n                // Check if the component is complete (meets the condition)\\n                if (componentSize * (componentSize - 1) == totalEdges) {\\n                    ++completeComponents; // If complete, increment the count of complete components\\n                }\\n            }\\n        }\\n        return completeComponents; // Return the total count of complete components in the graph\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056585,
                "title": "simple-dfs-keep-track-of-edges-and-nodes-in-each-component",
                "content": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \"\"\"\\n        count the edges in each component.\\n        if number of edges == n * (n-1) / 2 then\\n        it\\'s a complete connected component else not\\n        \"\"\"\\n        edge_map = {i: set() for i in range(n)}\\n        for edge in edges:\\n            edge_map[edge[0]].add(edge[1])\\n            edge_map[edge[1]].add(edge[0])\\n\\n        def dfs(node, dfs_visited):\\n            dfs_visited.add(node)\\n            for nei in edge_map[node]:\\n                if nei not in dfs_visited:\\n                    dfs(nei, dfs_visited)\\n        \\n        self.comp_map = {}\\n        self.comp_count_map = {}\\n        comp_count = 0\\n        for i in range(n):\\n            if i not in self.comp_map:\\n                dfs_visited = set()\\n                dfs(i, dfs_visited)\\n                for node in dfs_visited:\\n                    self.comp_map[node] = comp_count\\n                self.comp_count_map[comp_count] = len(dfs_visited)\\n                comp_count+=1\\n        self.edge_map = collections.defaultdict(int)\\n        for edge in edges:\\n            self.edge_map[self.comp_map[edge[0]]]+=1\\n        \\n        # if there are nodes with zero edges then they won\\'t be present in\\n        # edge map. Those are actually complete connected components, hence \\n        # we will add that to answer towards the end\\n\\n        complete_count = 0\\n        for key in self.edge_map:\\n            edge_cnt = self.edge_map[key]\\n            node_cnt = self.comp_count_map[key]\\n            if node_cnt * (node_cnt-1)/2 == edge_cnt:\\n                complete_count+=1\\n\\n        #print(comp_count)\\n        #print(self.comp_count_map)\\n        #print(self.comp_map)\\n        #print(self.edge_map)\\n        return complete_count + len(self.comp_count_map) - len(self.edge_map)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        \"\"\"\\n        count the edges in each component.\\n        if number of edges == n * (n-1) / 2 then\\n        it\\'s a complete connected component else not\\n        \"\"\"\\n        edge_map = {i: set() for i in range(n)}\\n        for edge in edges:\\n            edge_map[edge[0]].add(edge[1])\\n            edge_map[edge[1]].add(edge[0])\\n\\n        def dfs(node, dfs_visited):\\n            dfs_visited.add(node)\\n            for nei in edge_map[node]:\\n                if nei not in dfs_visited:\\n                    dfs(nei, dfs_visited)\\n        \\n        self.comp_map = {}\\n        self.comp_count_map = {}\\n        comp_count = 0\\n        for i in range(n):\\n            if i not in self.comp_map:\\n                dfs_visited = set()\\n                dfs(i, dfs_visited)\\n                for node in dfs_visited:\\n                    self.comp_map[node] = comp_count\\n                self.comp_count_map[comp_count] = len(dfs_visited)\\n                comp_count+=1\\n        self.edge_map = collections.defaultdict(int)\\n        for edge in edges:\\n            self.edge_map[self.comp_map[edge[0]]]+=1\\n        \\n        # if there are nodes with zero edges then they won\\'t be present in\\n        # edge map. Those are actually complete connected components, hence \\n        # we will add that to answer towards the end\\n\\n        complete_count = 0\\n        for key in self.edge_map:\\n            edge_cnt = self.edge_map[key]\\n            node_cnt = self.comp_count_map[key]\\n            if node_cnt * (node_cnt-1)/2 == edge_cnt:\\n                complete_count+=1\\n\\n        #print(comp_count)\\n        #print(self.comp_count_map)\\n        #print(self.comp_map)\\n        #print(self.edge_map)\\n        return complete_count + len(self.comp_count_map) - len(self.edge_map)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049198,
                "title": "java-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    Map<Integer, List<Integer>> m = new HashMap();\\n    List<Set> connectedComponents = new ArrayList();\\n    boolean[] processed;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        processed = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            m.put(i, new ArrayList());\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            m.get(edges[i][0]).add(edges[i][1]);\\n            m.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!processed[i])\\n            connectedComponents.add(helper(i, new HashSet()));\\n        }\\n\\n        int completeConnectedCount = 0;\\n        for (Set<Integer> graph : connectedComponents) {\\n            int numNodes = graph.size();\\n            boolean isComplete = true;\\n            for (int node : graph) {\\n                if (m.get(node).size() != numNodes - 1) {\\n                    isComplete = false;\\n                    break;\\n                };\\n            }\\n            if (isComplete) completeConnectedCount++;\\n        }\\n\\n\\n        return completeConnectedCount;\\n    }\\n\\n    private Set<Integer> helper(int vertex, Set<Integer> set) {\\n        processed[vertex] = true;\\n        set.add(vertex);\\n        List<Integer> connections = m.get(vertex);\\n        for (int connection : connections) {\\n            if (!processed[connection]) {\\n                helper(connection, set);\\n            }\\n        }\\n        return set;\\n    }\\n}\\n\\n/*\\ncreate a map of vertex to its connections (adj lists)\\n\\n0 - 1, 2\\n1 - 0, 2\\n2 - 1, 0\\n\\nfor a graph to be completely connected, \\neach node should have numNodes in graph - 1 number of edges.\\n\\nform sets of nodes\\nfor each node in a set, find number of edges. each node should have n - 1 edges\\n\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    Map<Integer, List<Integer>> m = new HashMap();\\n    List<Set> connectedComponents = new ArrayList();\\n    boolean[] processed;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        processed = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            m.put(i, new ArrayList());\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            m.get(edges[i][0]).add(edges[i][1]);\\n            m.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!processed[i])\\n            connectedComponents.add(helper(i, new HashSet()));\\n        }\\n\\n        int completeConnectedCount = 0;\\n        for (Set<Integer> graph : connectedComponents) {\\n            int numNodes = graph.size();\\n            boolean isComplete = true;\\n            for (int node : graph) {\\n                if (m.get(node).size() != numNodes - 1) {\\n                    isComplete = false;\\n                    break;\\n                };\\n            }\\n            if (isComplete) completeConnectedCount++;\\n        }\\n\\n\\n        return completeConnectedCount;\\n    }\\n\\n    private Set<Integer> helper(int vertex, Set<Integer> set) {\\n        processed[vertex] = true;\\n        set.add(vertex);\\n        List<Integer> connections = m.get(vertex);\\n        for (int connection : connections) {\\n            if (!processed[connection]) {\\n                helper(connection, set);\\n            }\\n        }\\n        return set;\\n    }\\n}\\n\\n/*\\ncreate a map of vertex to its connections (adj lists)\\n\\n0 - 1, 2\\n1 - 0, 2\\n2 - 1, 0\\n\\nfor a graph to be completely connected, \\neach node should have numNodes in graph - 1 number of edges.\\n\\nform sets of nodes\\nfor each node in a set, find number of edges. each node should have n - 1 edges\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045228,
                "title": "simple-dfs-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**See we just need to find number of nodes in a component and we have to check if each node of that component is connected to every other node of that component. We can use DFS to mark all node of a particular component but how can we check if each node is connected to eveery other node of that component , it is simple we can store every node of a component in a vector lets say \"cnt\" and we can iterate the cnt vector and check the the size of every node in the adjacency list if it not equal to (cnt.size() - 1) then it won\\'t add to answer.**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<int> &cnt){\\n        vis[node] = 1;\\n        cnt.push_back(node);\\n        for(auto it : adj[node]){\\n            if(!vis[it]){\\n                dfs(it, adj, vis, cnt);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        vector<int> adj[n];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                vector<int> cnt;\\n                dfs(i, adj, vis, cnt);\\n                bool flag = true;\\n                for(int j = 0; j < cnt.size(); j++){\\n                    if(adj[cnt[j]].size() != cnt.size() - 1){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, vector<int> &cnt){\\n        vis[node] = 1;\\n        cnt.push_back(node);\\n        for(auto it : adj[node]){\\n            if(!vis[it]){\\n                dfs(it, adj, vis, cnt);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        vector<int> adj[n];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                vector<int> cnt;\\n                dfs(i, adj, vis, cnt);\\n                bool flag = true;\\n                for(int j = 0; j < cnt.size(); j++){\\n                    if(adj[cnt[j]].size() != cnt.size() - 1){\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045175,
                "title": "java-easy-code-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /* Step 1: construct a graph\\n    Step 2: applying dfs on graph to find number of components & no. of nodes in each subgraphs\\n    Step 3: comparing no.of edges with no. of edges needed for CCC */\\n\\n    public void dfs(ArrayList<ArrayList<Integer>> graph, boolean visited[], int curr, int em[]) {\\n        visited[curr] = true; // marking visited\\n\\n        for(int nbr: graph.get(curr)) {\\n            if(!visited[nbr]) {\\n                dfs(graph, visited, nbr, em); // traversing to next node if not visited\\n                em[0]++;\\n            }\\n            em[1]++;\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>(); // graph schema\\n\\n        for(int i = 0; i < n; i++) \\n            graph.add(new ArrayList<Integer>());\\n\\n        for(int edge[]: edges) { // constructing graph\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n\\n        boolean visited[] = new boolean[n]; // to track position while traversing\\n        int components = 0; // count of all components\\n        int em[] = new int[2]; // to keep count of edges & nodes\\n        em[0] = 1; // starting point is a node\\n\\n        for(int i = 0; i < n; i++) \\n            if(!visited[i]) {\\n                dfs(graph, visited, i, em); // applying dfs to traverse through graph\\n                if(em[0]*(em[0]-1)/2 == em[1]/2) components++; // checking is subgraph a CCC\\n                em[0] = 1; // updating for new subgraph\\n                em[1] = 0; // updating for new subgraph\\n            } \\n        \\n        return components;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /* Step 1: construct a graph\\n    Step 2: applying dfs on graph to find number of components & no. of nodes in each subgraphs\\n    Step 3: comparing no.of edges with no. of edges needed for CCC */\\n\\n    public void dfs(ArrayList<ArrayList<Integer>> graph, boolean visited[], int curr, int em[]) {\\n        visited[curr] = true; // marking visited\\n\\n        for(int nbr: graph.get(curr)) {\\n            if(!visited[nbr]) {\\n                dfs(graph, visited, nbr, em); // traversing to next node if not visited\\n                em[0]++;\\n            }\\n            em[1]++;\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>(); // graph schema\\n\\n        for(int i = 0; i < n; i++) \\n            graph.add(new ArrayList<Integer>());\\n\\n        for(int edge[]: edges) { // constructing graph\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n\\n        boolean visited[] = new boolean[n]; // to track position while traversing\\n        int components = 0; // count of all components\\n        int em[] = new int[2]; // to keep count of edges & nodes\\n        em[0] = 1; // starting point is a node\\n\\n        for(int i = 0; i < n; i++) \\n            if(!visited[i]) {\\n                dfs(graph, visited, i, em); // applying dfs to traverse through graph\\n                if(em[0]*(em[0]-1)/2 == em[1]/2) components++; // checking is subgraph a CCC\\n                em[0] = 1; // updating for new subgraph\\n                em[1] = 0; // updating for new subgraph\\n            } \\n        \\n        return components;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045124,
                "title": "cpp-solution-easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i , int parent , int &nodeCount , int &edgeCount , vector<vector<bool>> &edgeVisited , vector<bool> &visited , vector<vector<int>> &adj)\\n    {\\n        if((parent != -1 && edgeVisited[i][parent])) return;\\n        if(parent != -1)\\n        { \\n            edgeCount++;\\n            edgeVisited[i][parent] = edgeVisited[parent][i] = true;\\n        }\\n        if(visited[i]) return;\\n        nodeCount++;\\n        visited[i] = true;\\n        for(auto node : adj[i])\\n        {\\n            dfs(node , i , nodeCount , edgeCount , edgeVisited , visited , adj);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<vector<bool>> edgeVisited(n , vector<bool> (n , false));\\n        vector<bool> visited(n , false);\\n        int answer = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int nodeCount = 0;\\n                int edgeCount = 0;\\n                dfs(i , -1 , nodeCount , edgeCount , edgeVisited , visited , adj);\\n                if(edgeCount == (nodeCount*(nodeCount-1))/2) answer++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i , int parent , int &nodeCount , int &edgeCount , vector<vector<bool>> &edgeVisited , vector<bool> &visited , vector<vector<int>> &adj)\\n    {\\n        if((parent != -1 && edgeVisited[i][parent])) return;\\n        if(parent != -1)\\n        { \\n            edgeCount++;\\n            edgeVisited[i][parent] = edgeVisited[parent][i] = true;\\n        }\\n        if(visited[i]) return;\\n        nodeCount++;\\n        visited[i] = true;\\n        for(auto node : adj[i])\\n        {\\n            dfs(node , i , nodeCount , edgeCount , edgeVisited , visited , adj);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        vector<vector<bool>> edgeVisited(n , vector<bool> (n , false));\\n        vector<bool> visited(n , false);\\n        int answer = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int nodeCount = 0;\\n                int edgeCount = 0;\\n                dfs(i , -1 , nodeCount , edgeCount , edgeVisited , visited , adj);\\n                if(edgeCount == (nodeCount*(nodeCount-1))/2) answer++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040556,
                "title": "c-code-simple-count-component-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(int s,vector<int>*adj,vector<bool>&visited,int&chk,vector<int>&t){\\n        queue<int>q;\\n        q.push(s);\\n        visited[s]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(int x:adj[u]){\\n                if(!visited[x]){\\n                    t.push_back(x);\\n                    visited[x]=true;\\n                    q.push(x);\\n                    chk++;\\n                }\\n            }\\n        }\\n        \\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        //creation of graph\\n        vector<int>adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int compo=0;\\n        vector<bool>visited(n,false);\\n        //vector<bool>visi(n,false);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                int chk=0;\\n                vector<int>t;\\n                t.push_back(i);\\n                bfs(i,adj,visited,chk,t);\\n                int fg=0;\\n                for(int x:t){\\n                    if(adj[x].size()!=chk){fg=1;break;}\\n                }\\n                if(fg==0)compo++;\\n               \\n            }\\n        }\\n        return compo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bfs(int s,vector<int>*adj,vector<bool>&visited,int&chk,vector<int>&t){\\n        queue<int>q;\\n        q.push(s);\\n        visited[s]=true;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(int x:adj[u]){\\n                if(!visited[x]){\\n                    t.push_back(x);\\n                    visited[x]=true;\\n                    q.push(x);\\n                    chk++;\\n                }\\n            }\\n        }\\n        \\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        //creation of graph\\n        vector<int>adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int compo=0;\\n        vector<bool>visited(n,false);\\n        //vector<bool>visi(n,false);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                int chk=0;\\n                vector<int>t;\\n                t.push_back(i);\\n                bfs(i,adj,visited,chk,t);\\n                int fg=0;\\n                for(int x:t){\\n                    if(adj[x].size()!=chk){fg=1;break;}\\n                }\\n                if(fg==0)compo++;\\n               \\n            }\\n        }\\n        return compo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039490,
                "title": "simple-c-solution-using-dfs-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that for an fully connected Graph Maximum edges are => \\nE = N * (N-1);\\nE -> number of edges in Connected graph \\nN -> number of nodes in Connected graph\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<int> &visit,vector<int> adj[],int &node_count,int &edge_count){\\n        visit[i] = 1;\\n        node_count++; \\n        edge_count += adj[i].size();\\n\\n        for(auto x:adj[i]){\\n            if(!visit[x]) dfs(x,visit,adj,node_count,edge_count);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> visit(n,0);\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int res = 0;\\n        for(int i=0;i<n;i++){\\n            if(!visit[i]){\\n                int node_count = 0, edge_count = 0; \\n                dfs(i,visit,adj,node_count,edge_count);\\n\\n                if(edge_count == node_count * (node_count-1)) \\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<int> &visit,vector<int> adj[],int &node_count,int &edge_count){\\n        visit[i] = 1;\\n        node_count++; \\n        edge_count += adj[i].size();\\n\\n        for(auto x:adj[i]){\\n            if(!visit[x]) dfs(x,visit,adj,node_count,edge_count);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> visit(n,0);\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int res = 0;\\n        for(int i=0;i<n;i++){\\n            if(!visit[i]){\\n                int node_count = 0, edge_count = 0; \\n                dfs(i,visit,adj,node_count,edge_count);\\n\\n                if(edge_count == node_count * (node_count-1)) \\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025927,
                "title": "using-dfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the Graph: Create an adjacency list representation of the graph using a 2D vector graph, where graph[i] contains the neighbors of node i. This is done by iterating through the edges vector and adding each edge to the graph.\\n\\n2. Initialize Variables: Initialize a variable res to keep track of the number of complete components. Also, create a boolean vector visited of size n to keep track of visited nodes.\\n\\n3. Iterate Through Nodes: Iterate through all nodes in the graph from 0 to n-1.\\n\\n4. DFS (Depth-First Search):\\n\\n    - If the current node has not been visited (!visited[i]), initiate a DFS from this node.\\n    - In the DFS, the dfs function is called, which:\\n      Marks the current node as visited.\\n    - Increments the node count (number of nodes in the current component).\\n    - Increments the edge_c count by the number of neighbors (edges) of the current node.\\n    - Recursively explores unvisited neighbors.\\n    - Check for Complete Component:\\n\\n5. After the DFS, check if the current component is complete. A component is considered complete if the number of nodes (node) multiplied by (node-1) equals the number of edges (edge_c). If this condition is met, increment the res count.\\nReturn the Result:\\n\\n6. After iterating through all nodes, the function returns the total count of complete components, which is stored in the res variable.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&graph,int curr, vector<bool>&visited, int &node,int &edge_c){\\n        visited[curr]=true;\\n        node+=1;\\n        edge_c+=graph[curr].size();\\n        for(int nex: graph[curr]){\\n            if(!visited[nex]){\\n                dfs(graph,nex,visited,node,edge_c);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for(auto edge: edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);        \\n        }int res=0;\\n        vector<bool> visited(n);\\n        for(int i=0;i<n;i++){\\n            int node=0,edge_c=0;\\n            if(!visited[i]){\\n                dfs(graph,i,visited,node,edge_c);\\n                if(node*(node-1)==edge_c){ res+=1;}\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&graph,int curr, vector<bool>&visited, int &node,int &edge_c){\\n        visited[curr]=true;\\n        node+=1;\\n        edge_c+=graph[curr].size();\\n        for(int nex: graph[curr]){\\n            if(!visited[nex]){\\n                dfs(graph,nex,visited,node,edge_c);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for(auto edge: edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);        \\n        }int res=0;\\n        vector<bool> visited(n);\\n        for(int i=0;i<n;i++){\\n            int node=0,edge_c=0;\\n            if(!visited[i]){\\n                dfs(graph,i,visited,node,edge_c);\\n                if(node*(node-1)==edge_c){ res+=1;}\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015890,
                "title": "easy-cpp-dfs-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart DFS from each and every unvisited node of the graph.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart DFS from each and every unvisited node of the graph and then put the node values in a list and then check if there exist a edge between all the pairs of nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(vector<std::vector<int>> &edgelst,vector<int>& subans,vector<bool>& visited,int startver)\\n{  \\n    if(visited[startver]==true)\\n    {\\n        return;\\n    }\\n     subans.push_back(startver);\\n     visited[startver]=true;\\n    for(int i=0;i<edgelst[startver].size();i++)\\n    {\\n           // visited[edgelst[startver][i]]==true;\\n            dfs(edgelst,subans,visited,edgelst[startver][i]);\\n        \\n    }\\n    return;\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<bool>visited;\\n        for(int i=0;i<n;i++)\\n        {\\n            visited.push_back(false);\\n        }\\n      std::vector<std::vector<int>> edgelst(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            edgelst[edges[i][0]].push_back(edges[i][1]);\\n            edgelst[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<visited.size();i++)\\n        {\\n            if(visited[i]==false)\\n            {\\n                vector<int>subans;\\n                dfs(edgelst,subans,visited,i);\\n             \\n                cout<<endl;\\n                bool flag=true;\\n                for(int i=0;i<subans.size();i++)\\n                {\\n                    for(int j=i+1;j<subans.size();j++)\\n                    {\\n                        if (!(std::find(edgelst[subans[i]].begin(), edgelst[subans[i]].end(), subans[j]) != edgelst[subans[i]].end())) {\\n                           flag=false;\\n                        }\\n                    }\\n                }\\n                if(flag==true)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<std::vector<int>> &edgelst,vector<int>& subans,vector<bool>& visited,int startver)\\n{  \\n    if(visited[startver]==true)\\n    {\\n        return;\\n    }\\n     subans.push_back(startver);\\n     visited[startver]=true;\\n    for(int i=0;i<edgelst[startver].size();i++)\\n    {\\n           // visited[edgelst[startver][i]]==true;\\n            dfs(edgelst,subans,visited,edgelst[startver][i]);\\n        \\n    }\\n    return;\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<bool>visited;\\n        for(int i=0;i<n;i++)\\n        {\\n            visited.push_back(false);\\n        }\\n      std::vector<std::vector<int>> edgelst(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            edgelst[edges[i][0]].push_back(edges[i][1]);\\n            edgelst[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<visited.size();i++)\\n        {\\n            if(visited[i]==false)\\n            {\\n                vector<int>subans;\\n                dfs(edgelst,subans,visited,i);\\n             \\n                cout<<endl;\\n                bool flag=true;\\n                for(int i=0;i<subans.size();i++)\\n                {\\n                    for(int j=i+1;j<subans.size();j++)\\n                    {\\n                        if (!(std::find(edgelst[subans[i]].begin(), edgelst[subans[i]].end(), subans[j]) != edgelst[subans[i]].end())) {\\n                           flag=false;\\n                        }\\n                    }\\n                }\\n                if(flag==true)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4002576,
                "title": "dfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(E+V)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(E+V)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        from collections import deque,defaultdict\\n        adj = defaultdict(list)\\n        visited = [False]*(n)\\n        count = 0\\n        for i in edges:\\n            adj[i[0]]+=[i[1]]\\n            adj[i[1]]+=[i[0]]\\n        for i in range(n):\\n            v = 0\\n            ce = 0\\n            if not visited[i]:\\n                q = deque()\\n                q.append(i)\\n                visited[i] = True\\n                while q:\\n                    \\n                    node = q.popleft()\\n                    v+=1\\n                    ce+=len(adj[node])\\n                    for x in adj[node]:\\n                        if not visited[x]:\\n                            q.append(x)\\n                            visited[x] = True\\n                if ce == v*(v-1):\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        from collections import deque,defaultdict\\n        adj = defaultdict(list)\\n        visited = [False]*(n)\\n        count = 0\\n        for i in edges:\\n            adj[i[0]]+=[i[1]]\\n            adj[i[1]]+=[i[0]]\\n        for i in range(n):\\n            v = 0\\n            ce = 0\\n            if not visited[i]:\\n                q = deque()\\n                q.append(i)\\n                visited[i] = True\\n                while q:\\n                    \\n                    node = q.popleft()\\n                    v+=1\\n                    ce+=len(adj[node])\\n                    for x in adj[node]:\\n                        if not visited[x]:\\n                            q.append(x)\\n                            visited[x] = True\\n                if ce == v*(v-1):\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998432,
                "title": "c-simple-traversal-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int start, vector<int> &vis, vector<int> adj[], vector<int> &temp){\\n    vis[start] = 1;\\n    temp.push_back(start);\\n    for(auto it : adj[start]){\\n        if(vis[it]==0){\\n            dfs(it, vis, adj, temp);\\n        }\\n    }\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                vector<int> temp;\\n                dfs(i, vis, adj, temp);\\n                int count = 0;\\n                for(int i=0;i<temp.size();i++){\\n                    if(adj[temp[i]].size()==temp.size()-1){\\n                        count++;\\n                    }\\n                }\\n                if(count==temp.size()) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int start, vector<int> &vis, vector<int> adj[], vector<int> &temp){\\n    vis[start] = 1;\\n    temp.push_back(start);\\n    for(auto it : adj[start]){\\n        if(vis[it]==0){\\n            dfs(it, vis, adj, temp);\\n        }\\n    }\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                vector<int> temp;\\n                dfs(i, vis, adj, temp);\\n                int count = 0;\\n                for(int i=0;i<temp.size();i++){\\n                    if(adj[temp[i]].size()==temp.size()-1){\\n                        count++;\\n                    }\\n                }\\n                if(count==temp.size()) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989666,
                "title": "using-bfs-beats-97-of-users",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool BFSUtils(vector<vector<int>>& adjList, int v, vector<int> &visited){\\n        int count_edges = 0;\\n        int count_nodes = 0;\\n        queue<int> q;\\n        q.push(v);\\n        visited[v] = 1;\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n\\n            count_edges += adjList[front].size();\\n            count_nodes++;\\n\\n            for(auto x : adjList[front]){\\n                if(visited[x] == 0){\\n                    q.push(x);\\n                    visited[x] = 1;\\n                }\\n            }\\n        }\\n        count_edges = count_edges/2;\\n        if(count_edges ==  ((count_nodes*(count_nodes-1))/2))\\n           return true;\\n\\n        return false;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adjList(n);\\n\\n        for(int i=0 ; i<edges.size() ; ++i){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adjList[u].push_back(v);\\n            adjList[v].push_back(u);\\n        }\\n\\n        vector<int> visited(n, 0);\\n        int ans = 0;\\n        for(int v=0 ; v<n ; v++){\\n            if(visited[v] == 0){\\n                bool isCompleteComponent = BFSUtils(adjList, v, visited);\\n                if(isCompleteComponent)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool BFSUtils(vector<vector<int>>& adjList, int v, vector<int> &visited){\\n        int count_edges = 0;\\n        int count_nodes = 0;\\n        queue<int> q;\\n        q.push(v);\\n        visited[v] = 1;\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n\\n            count_edges += adjList[front].size();\\n            count_nodes++;\\n\\n            for(auto x : adjList[front]){\\n                if(visited[x] == 0){\\n                    q.push(x);\\n                    visited[x] = 1;\\n                }\\n            }\\n        }\\n        count_edges = count_edges/2;\\n        if(count_edges ==  ((count_nodes*(count_nodes-1))/2))\\n           return true;\\n\\n        return false;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adjList(n);\\n\\n        for(int i=0 ; i<edges.size() ; ++i){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adjList[u].push_back(v);\\n            adjList[v].push_back(u);\\n        }\\n\\n        vector<int> visited(n, 0);\\n        int ans = 0;\\n        for(int v=0 ; v<n ; v++){\\n            if(visited[v] == 0){\\n                bool isCompleteComponent = BFSUtils(adjList, v, visited);\\n                if(isCompleteComponent)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981912,
                "title": "dfs-cpp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool>v1,v2;\\n    vector<vector<int>>g;\\n\\n    void dfs(int ind)\\n    {\\n        if(v1[ind]==true) return;\\n        v1[ind] = true;\\n        v2[ind] = true;\\n        for(auto x : g[ind])\\n        {\\n            dfs(x);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        v1.resize(n,false);\\n        v2.resize(n,false);\\n        g = vector<vector<int>>(n);\\n        vector<int> incount(n,0);\\n\\n        for(auto x : edges)\\n        {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n            incount[x[0]]++;\\n            incount[x[1]]++;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < n ; i++)\\n        {       \\n            if(v1[i]==false)\\n            {\\n                v2.clear();\\n                v2 = vector<bool>(n,false);\\n                dfs(i);\\n                ans = ans + 1;\\n                int total = 0;\\n                for(auto x : v2){if(x==true)total++;}\\n                for(int j = 0; j < n ; j++)\\n                {\\n                    if(v2[j] == true)\\n                    {\\n                        if(incount[j]!=total-1){ans--;break;}\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool>v1,v2;\\n    vector<vector<int>>g;\\n\\n    void dfs(int ind)\\n    {\\n        if(v1[ind]==true) return;\\n        v1[ind] = true;\\n        v2[ind] = true;\\n        for(auto x : g[ind])\\n        {\\n            dfs(x);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        v1.resize(n,false);\\n        v2.resize(n,false);\\n        g = vector<vector<int>>(n);\\n        vector<int> incount(n,0);\\n\\n        for(auto x : edges)\\n        {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n            incount[x[0]]++;\\n            incount[x[1]]++;\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < n ; i++)\\n        {       \\n            if(v1[i]==false)\\n            {\\n                v2.clear();\\n                v2 = vector<bool>(n,false);\\n                dfs(i);\\n                ans = ans + 1;\\n                int total = 0;\\n                for(auto x : v2){if(x==true)total++;}\\n                for(int j = 0; j < n ; j++)\\n                {\\n                    if(v2[j] == true)\\n                    {\\n                        if(incount[j]!=total-1){ans--;break;}\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972273,
                "title": "python-clean-and-simple-dsu",
                "content": "```\\nfrom collections import Counter, defaultdict\\nfrom dataclasses import dataclass, field\\nfrom math import comb\\n\\n\\n@dataclass\\nclass Group:\\n    nodes: int = field(init=False, default=0)\\n    edges: int = field(init=False, default=0)\\n\\n    @property\\n    def is_completely_connected(self) -> bool:\\n        return comb(self.nodes, 2) == self.edges // 2\\n\\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: list[list[int]]) -> int:\\n        uf = UF(n)\\n\\n        edge_cnt = Counter()\\n\\n        for a, b in edges:\\n            uf.union(a, b)\\n\\n            edge_cnt[a] += 1\\n            edge_cnt[b] += 1\\n\\n        groups = defaultdict(Group)\\n\\n        for u in range(n):\\n            p = uf.find(u)\\n\\n            g = groups[p]\\n            g.nodes += 1\\n            g.edges += edge_cnt[u]\\n\\n        return sum(g.is_completely_connected for g in groups.values())\\n```\\n\\nDefinition of **UF**,\\n\\n```python\\nfrom dataclasses import dataclass\\nfrom functools import cached_property\\n\\n\\n@dataclass(frozen=True)\\nclass UF:\\n    \"\"\"\\n    Implementing union find algorithm\\n    \"\"\"\\n    node_count: int\\n\\n    def find(self, u: int) -> int:\\n        \"\"\"\\n        :return: representative node of cluster containing node \"u\"\\n        \"\"\"\\n        parent = self._parent\\n\\n        if u != (pu := parent[u]):\\n            parent[u] = self.find(pu)  # path compression\\n\\n        return parent[u]\\n\\n    def union(self, u: int, v: int) -> bool:\\n        \"\"\"\\n        merging clusters containing node \"u\" and node \"v\"\\n        :param u:\\n        :param v:\\n        :return: True if union/merge is needed else False\\n        \"\"\"\\n        root_u, root_v = self.find(u), self.find(v)\\n\\n        if root_u != root_v:\\n            self._merge_roots(root_u, root_v)\\n\\n        return root_u != root_v\\n\\n    def _merge_roots(self, u: int, v: int):\\n        \"\"\"\\n        \"u\" and \"v\" are root nodes of two different clusters and the two\\n        clusters are to be merged. In this function, we determine which\\n        node should be made parent using rank and update parent accordingly.\\n\\n        Node with higher rank is made parent and in case of tie, \"v\" (\"u\" can\\n        also be chosen) node is chosen as parent and its rank is incremented\\n        by 1\\n\\n        :param u:\\n        :param v:\\n        \"\"\"\\n        rank = self._rank\\n\\n        if rank[u] > rank[v]:\\n            self._parent[v] = u\\n        else:\\n            self._parent[u] = v\\n\\n            if rank[u] == rank[v]:\\n                self._rank[v] += 1\\n\\n    @cached_property\\n    def _parent(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is the ith element and value\\n                 is its corresponding parent\\n        \"\"\"\\n        return list(range(self.node_count))\\n\\n    @cached_property\\n    def _rank(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is ith node element and value\\n        is its rank. Rank is used while merging clusters\\n        \"\"\"\\n        return [1] * self.node_count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter, defaultdict\\nfrom dataclasses import dataclass, field\\nfrom math import comb\\n\\n\\n@dataclass\\nclass Group:\\n    nodes: int = field(init=False, default=0)\\n    edges: int = field(init=False, default=0)\\n\\n    @property\\n    def is_completely_connected(self) -> bool:\\n        return comb(self.nodes, 2) == self.edges // 2\\n\\n\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: list[list[int]]) -> int:\\n        uf = UF(n)\\n\\n        edge_cnt = Counter()\\n\\n        for a, b in edges:\\n            uf.union(a, b)\\n\\n            edge_cnt[a] += 1\\n            edge_cnt[b] += 1\\n\\n        groups = defaultdict(Group)\\n\\n        for u in range(n):\\n            p = uf.find(u)\\n\\n            g = groups[p]\\n            g.nodes += 1\\n            g.edges += edge_cnt[u]\\n\\n        return sum(g.is_completely_connected for g in groups.values())\\n```\n```python\\nfrom dataclasses import dataclass\\nfrom functools import cached_property\\n\\n\\n@dataclass(frozen=True)\\nclass UF:\\n    \"\"\"\\n    Implementing union find algorithm\\n    \"\"\"\\n    node_count: int\\n\\n    def find(self, u: int) -> int:\\n        \"\"\"\\n        :return: representative node of cluster containing node \"u\"\\n        \"\"\"\\n        parent = self._parent\\n\\n        if u != (pu := parent[u]):\\n            parent[u] = self.find(pu)  # path compression\\n\\n        return parent[u]\\n\\n    def union(self, u: int, v: int) -> bool:\\n        \"\"\"\\n        merging clusters containing node \"u\" and node \"v\"\\n        :param u:\\n        :param v:\\n        :return: True if union/merge is needed else False\\n        \"\"\"\\n        root_u, root_v = self.find(u), self.find(v)\\n\\n        if root_u != root_v:\\n            self._merge_roots(root_u, root_v)\\n\\n        return root_u != root_v\\n\\n    def _merge_roots(self, u: int, v: int):\\n        \"\"\"\\n        \"u\" and \"v\" are root nodes of two different clusters and the two\\n        clusters are to be merged. In this function, we determine which\\n        node should be made parent using rank and update parent accordingly.\\n\\n        Node with higher rank is made parent and in case of tie, \"v\" (\"u\" can\\n        also be chosen) node is chosen as parent and its rank is incremented\\n        by 1\\n\\n        :param u:\\n        :param v:\\n        \"\"\"\\n        rank = self._rank\\n\\n        if rank[u] > rank[v]:\\n            self._parent[v] = u\\n        else:\\n            self._parent[u] = v\\n\\n            if rank[u] == rank[v]:\\n                self._rank[v] += 1\\n\\n    @cached_property\\n    def _parent(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is the ith element and value\\n                 is its corresponding parent\\n        \"\"\"\\n        return list(range(self.node_count))\\n\\n    @cached_property\\n    def _rank(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is ith node element and value\\n        is its rank. Rank is used while merging clusters\\n        \"\"\"\\n        return [1] * self.node_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969884,
                "title": "c-easy-fast-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int node,vector<bool> &vis,int &v,int &edge)\\n    {\\n        vis[node]=true;\\n\\n        v++;\\n        edge+=adj[node].size();\\n\\n        for(auto it:adj[node])\\n        {\\n            if(vis[it]==false)\\n            {\\n                dfs(adj,it,vis,v,edge);\\n            }\\n        }\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n];\\n        vector<bool> vis(n,false);\\n        int ans=0;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==false)\\n            {\\n                int v=0,edge=0;\\n                dfs(adj,i,vis,v,edge);\\n                if(edge==v*(v-1))\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int node,vector<bool> &vis,int &v,int &edge)\\n    {\\n        vis[node]=true;\\n\\n        v++;\\n        edge+=adj[node].size();\\n\\n        for(auto it:adj[node])\\n        {\\n            if(vis[it]==false)\\n            {\\n                dfs(adj,it,vis,v,edge);\\n            }\\n        }\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n];\\n        vector<bool> vis(n,false);\\n        int ans=0;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==false)\\n            {\\n                int v=0,edge=0;\\n                dfs(adj,i,vis,v,edge);\\n                if(edge==v*(v-1))\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966826,
                "title": "easy-explanation-simple-dfs-connected-component-complete-graph",
                "content": "# Intuition\\n        \\nFor connected component (acc to Question) \\neach pair of vertices should have edge **(which is somewhat\\\\* to complete graph)**\\n\\nEdge - Vertices Relationship for a Complete Graph : ```|E| = V*(V-1)/2```\\n\\n\\nSince matrix is given for undirected graph so each edge is encountered twice\\n```eg 1 ---- 2 is same as 2 --- 1``` \\n\\nSo now, edge-vertice relationship : ```|E| = V*(V-1)```\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* use dfs to count number of component\\n* simply count the on edges and vertices in a connected component and use the above eqn to check whether the connected component is a complete graph or not.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int node, vector<int>&vis, int& V, int& E){\\n        vis[node]=1;\\n        V++;\\n        for(auto u :adj[node]){\\n            E++;\\n            if(!vis[u]) dfs(adj,u,vis,V,E);\\n        }\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n\\n        vector<int> adj[n];\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int V=0, E=0;\\n                dfs(adj,i, vis, V, E);\\n\\n                if(E == V*(V-1)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```|E| = V*(V-1)/2```\n```eg 1 ---- 2 is same as 2 --- 1```\n```|E| = V*(V-1)```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int node, vector<int>&vis, int& V, int& E){\\n        vis[node]=1;\\n        V++;\\n        for(auto u :adj[node]){\\n            E++;\\n            if(!vis[u]) dfs(adj,u,vis,V,E);\\n        }\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n\\n        vector<int> adj[n];\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int V=0, E=0;\\n                dfs(adj,i, vis, V, E);\\n\\n                if(E == V*(V-1)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966283,
                "title": "java-union-find-clean",
                "content": "# Code\\n```\\nclass Solution {\\n    class DSU {\\n        public int[] roots;\\n        public int[] sizes;\\n        DSU(int n) {\\n            roots = new int[n];\\n            sizes = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                sizes[i] = 1;\\n                roots[i] = i;\\n            }\\n        }\\n        public int find(int v) {\\n            if (roots[v] != v) {\\n                roots[v] = find(roots[v]);\\n            }\\n            return roots[v];\\n        }\\n\\n        public void union(int a, int b) {\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            if (rootA == rootB) {\\n                return;\\n            }\\n            roots[rootB] = rootA;\\n            sizes[rootA] += sizes[rootB];\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        DSU dsu = new DSU(n);\\n        int[] indegree = new int[n];\\n        for (int[] e : edges) {\\n            dsu.union(e[0], e[1]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n\\n        int[] gcount = new int[n];\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int root = dsu.find(i);\\n            if (dsu.sizes[root] == (indegree[i]+1)) {\\n                gcount[root]++;\\n            }\\n            if (gcount[root] == dsu.sizes[root]) {\\n                res++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class DSU {\\n        public int[] roots;\\n        public int[] sizes;\\n        DSU(int n) {\\n            roots = new int[n];\\n            sizes = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                sizes[i] = 1;\\n                roots[i] = i;\\n            }\\n        }\\n        public int find(int v) {\\n            if (roots[v] != v) {\\n                roots[v] = find(roots[v]);\\n            }\\n            return roots[v];\\n        }\\n\\n        public void union(int a, int b) {\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            if (rootA == rootB) {\\n                return;\\n            }\\n            roots[rootB] = rootA;\\n            sizes[rootA] += sizes[rootB];\\n        }\\n    }\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        DSU dsu = new DSU(n);\\n        int[] indegree = new int[n];\\n        for (int[] e : edges) {\\n            dsu.union(e[0], e[1]);\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n\\n        int[] gcount = new int[n];\\n\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int root = dsu.find(i);\\n            if (dsu.sizes[root] == (indegree[i]+1)) {\\n                gcount[root]++;\\n            }\\n            if (gcount[root] == dsu.sizes[root]) {\\n                res++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965908,
                "title": "solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncounting no of edges between the vertices and checking count of edges = (no.of vertices)*(no.of vertices-1)/2\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS and indegree\\n\\n# Complexity\\n- Time complexity:$$$O(n^2)$$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int [] con = new int [n];\\n        boolean [] vis = new boolean [n];\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            int x =edges[i][0];\\n            int y= edges[i][1];\\n\\n            adj.get(x).add(y);\\n            adj.get(y).add(x);\\n            con[x]++;\\n            con[y]++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==false){\\n                ans+= bfs(i,adj,vis,con);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int bfs(int indx,ArrayList<ArrayList<Integer>> adj,boolean [] vis ,int [] con){\\n        int count =0;\\n        int num=0;\\n        Queue<Integer> q= new LinkedList<>();\\n        q.add(indx);\\n        while(!q.isEmpty()){\\n            int curr = q.poll();\\n            if(vis[curr]==false){\\n                num++;\\n                vis[curr]=true;\\n                count += con[curr];\\n                for(int i:adj.get(curr)){\\n                    q.add(i);\\n                }\\n            }  \\n        }\\n        if(count ==(num*(num-1))) return 1;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int [] con = new int [n];\\n        boolean [] vis = new boolean [n];\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            int x =edges[i][0];\\n            int y= edges[i][1];\\n\\n            adj.get(x).add(y);\\n            adj.get(y).add(x);\\n            con[x]++;\\n            con[y]++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==false){\\n                ans+= bfs(i,adj,vis,con);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int bfs(int indx,ArrayList<ArrayList<Integer>> adj,boolean [] vis ,int [] con){\\n        int count =0;\\n        int num=0;\\n        Queue<Integer> q= new LinkedList<>();\\n        q.add(indx);\\n        while(!q.isEmpty()){\\n            int curr = q.poll();\\n            if(vis[curr]==false){\\n                num++;\\n                vis[curr]=true;\\n                count += con[curr];\\n                for(int i:adj.get(curr)){\\n                    q.add(i);\\n                }\\n            }  \\n        }\\n        if(count ==(num*(num-1))) return 1;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962575,
                "title": "well-commented-dfs-solution-one-trivial-optimization-also-included",
                "content": "# Intuition\\nVery simple intuition. Complete component => All nodes should be connected to eachother in a component. So we have to, \\n1. Identify the components\\n2. Check node in the component is connected to every other node\\n\\nSimple!\\n\\n# Approach\\n1. DFS starting from every node\\n2. Accumulate all nodes in a list. This is the \"path\"\\n3. Check if each entry in the path we just found is having connections to every other entry in the path\\n\\n# Complexity\\n- Time complexity:\\nO(n) to do DFS, O(n) INSIDE each DFS to check if path is fully connected \\n=> OVERALL O(n^2) CORRECT ME IF I\\'M WRONG\\n\\n- Space complexity:\\n    O(n) for the stack recursion, O(n) for storing the path, O(n) for the hashSet (optimization)\\n=> OVERALL O(n) since no nesting is occuring. After the entire DFS stack is popped out, we use the stored path to verify completeness.\\n\\nWell commented, read the comments and you\\'ll understand. Hope this helps.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        #region Adjacency List and seen initialization\\n        List<int>[] adjList = new List<int>[n]; bool[] seen = new bool[n];\\n        for(int i = 0; i < n; i++){\\n            adjList[i] = new List<int>();\\n        }\\n        foreach(int[] edge in edges){\\n            adjList[edge[0]].Add(edge[1]); adjList[edge[1]].Add(edge[0]);\\n        }\\n        #endregion\\n\\n        //Start DFS on every element to find all connected components\\n        List<int> path = new(); //Store all elements in a path in path list\\n        int count = 0; //Keep track of connected components\\n        for(int i = 0; i < n; i++){\\n            if(!seen[i]){\\n                DFS(i);\\n                //Increment count based on if path fully is connected\\n                count += CheckIfCompleteComponent(); \\n                path.Clear(); //Start exploring new path\\n            }\\n        }\\n\\n        return count;\\n\\n        //Very simple DFS function, nothing fancy\\n        void DFS(int curr){\\n            if(seen[curr]) return;\\n\\n            seen[curr] = true; path.Add(curr);\\n            foreach(int entry in adjList[curr]){\\n                DFS(entry);\\n            }\\n        }\\n\\n        //Function to check if path accumulated is complete or not\\n        int CheckIfCompleteComponent(){ //Only 2 (1 and 2) criteria\\n            HashSet<int> set = new(); //Quickly creating a hashset for easy lookup\\n            foreach(int entry in path){ set.Add(entry); }\\n\\n            foreach(int pathEntry in path){\\n                //(1) Each member in path should contain connections to all other membes in path\\n                //First we check the count (-1 because it won\\'t contain that starting point itself)\\n                if(adjList[pathEntry].Count != path.Count - 1){ \\n                    return 0; \\n                }\\n                else{ //(2) Checking if each element is contained in it. \\n                    foreach(int adjListEntry in adjList[pathEntry]){\\n                        if(!set.Contains(adjListEntry)){ \\n                            return 0; \\n                        }\\n                    }\\n                }\\n            }\\n            return 1; //If not a valid path, return 0, else return 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        #region Adjacency List and seen initialization\\n        List<int>[] adjList = new List<int>[n]; bool[] seen = new bool[n];\\n        for(int i = 0; i < n; i++){\\n            adjList[i] = new List<int>();\\n        }\\n        foreach(int[] edge in edges){\\n            adjList[edge[0]].Add(edge[1]); adjList[edge[1]].Add(edge[0]);\\n        }\\n        #endregion\\n\\n        //Start DFS on every element to find all connected components\\n        List<int> path = new(); //Store all elements in a path in path list\\n        int count = 0; //Keep track of connected components\\n        for(int i = 0; i < n; i++){\\n            if(!seen[i]){\\n                DFS(i);\\n                //Increment count based on if path fully is connected\\n                count += CheckIfCompleteComponent(); \\n                path.Clear(); //Start exploring new path\\n            }\\n        }\\n\\n        return count;\\n\\n        //Very simple DFS function, nothing fancy\\n        void DFS(int curr){\\n            if(seen[curr]) return;\\n\\n            seen[curr] = true; path.Add(curr);\\n            foreach(int entry in adjList[curr]){\\n                DFS(entry);\\n            }\\n        }\\n\\n        //Function to check if path accumulated is complete or not\\n        int CheckIfCompleteComponent(){ //Only 2 (1 and 2) criteria\\n            HashSet<int> set = new(); //Quickly creating a hashset for easy lookup\\n            foreach(int entry in path){ set.Add(entry); }\\n\\n            foreach(int pathEntry in path){\\n                //(1) Each member in path should contain connections to all other membes in path\\n                //First we check the count (-1 because it won\\'t contain that starting point itself)\\n                if(adjList[pathEntry].Count != path.Count - 1){ \\n                    return 0; \\n                }\\n                else{ //(2) Checking if each element is contained in it. \\n                    foreach(int adjListEntry in adjList[pathEntry]){\\n                        if(!set.Contains(adjListEntry)){ \\n                            return 0; \\n                        }\\n                    }\\n                }\\n            }\\n            return 1; //If not a valid path, return 0, else return 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960232,
                "title": "time-complexity-yes",
                "content": "- Time/Space complexity:\\n$$O(infinity)$$\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n    if not edges:\\n      return n\\n\\n    # visited vertices & edges\\n    visited = set()\\n    visited_edges = set()\\n\\n    # groups\\n    g = defaultdict(int)\\n\\n    # connectivity\\n    c = defaultdict(set)\\n    for edge in edges:\\n      c[edge[0]].add(edge[1])\\n      c[edge[1]].add(edge[0])\\n\\n    def dfs(edge_index, color):\\n      if edge_index in visited_edges:\\n        return\\n      visited_edges.add(edge_index)\\n      try:\\n        if edge_index not in c:\\n          raise IndexError\\n        for vertex in c[edge_index]:\\n          if vertex in visited:\\n            continue\\n          dfs(vertex, color)\\n          visited.add(vertex)\\n          g[vertex] = color\\n      except IndexError:\\n        visited.add(edge_index)\\n        g[edge_index] = color\\n\\n    color = 1\\n\\n    for v in range(n):\\n      if g[v] == 0:\\n        dfs(v, color)\\n        color += 1\\n    \\n    # not filtered groups\\n    allg = set(g.values())\\n    # number of elements in each group\\n    gc = Counter(g.values())\\n\\n    # complete groups filter\\n    invalidated = set()\\n    for gr in allg:\\n      for k,v in c.items():\\n        # if vertex belongs to a group we currently checking &\\n        # this vertex connected to less than group size - 1 neighbors\\n        if g[k] == gr and len(c[k]) < gc[gr]-1:\\n          invalidated.add(gr)\\n    \\n    allg = allg.difference(invalidated)\\n    return len(allg)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n    if not edges:\\n      return n\\n\\n    # visited vertices & edges\\n    visited = set()\\n    visited_edges = set()\\n\\n    # groups\\n    g = defaultdict(int)\\n\\n    # connectivity\\n    c = defaultdict(set)\\n    for edge in edges:\\n      c[edge[0]].add(edge[1])\\n      c[edge[1]].add(edge[0])\\n\\n    def dfs(edge_index, color):\\n      if edge_index in visited_edges:\\n        return\\n      visited_edges.add(edge_index)\\n      try:\\n        if edge_index not in c:\\n          raise IndexError\\n        for vertex in c[edge_index]:\\n          if vertex in visited:\\n            continue\\n          dfs(vertex, color)\\n          visited.add(vertex)\\n          g[vertex] = color\\n      except IndexError:\\n        visited.add(edge_index)\\n        g[edge_index] = color\\n\\n    color = 1\\n\\n    for v in range(n):\\n      if g[v] == 0:\\n        dfs(v, color)\\n        color += 1\\n    \\n    # not filtered groups\\n    allg = set(g.values())\\n    # number of elements in each group\\n    gc = Counter(g.values())\\n\\n    # complete groups filter\\n    invalidated = set()\\n    for gr in allg:\\n      for k,v in c.items():\\n        # if vertex belongs to a group we currently checking &\\n        # this vertex connected to less than group size - 1 neighbors\\n        if g[k] == gr and len(c[k]) < gc[gr]-1:\\n          invalidated.add(gr)\\n    \\n    allg = allg.difference(invalidated)\\n    return len(allg)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958144,
                "title": "99-faster-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n+e)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+e)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,int &v,int &e,vector<bool>&visited,vector<vector<int>>&adj)\\n    {\\n        visited[node]=true;\\n        v++;\\n        e = e + adj[node].size();\\n    \\n        for(auto nbr : adj[node])\\n        {\\n            if(!visited[nbr])\\n            {\\n                dfs(nbr,v,e,visited,adj);\\n            }\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        for (const auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<bool>visited(n,false);\\n        int count = 0;\\n\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int v=0;\\n                int e=0;\\n                dfs(i,v,e,visited,adj);\\n\\n                if(e == v * (v-1) )count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,int &v,int &e,vector<bool>&visited,vector<vector<int>>&adj)\\n    {\\n        visited[node]=true;\\n        v++;\\n        e = e + adj[node].size();\\n    \\n        for(auto nbr : adj[node])\\n        {\\n            if(!visited[nbr])\\n            {\\n                dfs(nbr,v,e,visited,adj);\\n            }\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<vector<int>> adj(n);\\n        for (const auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<bool>visited(n,false);\\n        int count = 0;\\n\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int v=0;\\n                int e=0;\\n                dfs(i,v,e,visited,adj);\\n\\n                if(e == v * (v-1) )count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956134,
                "title": "explained-in-comments-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs( int node, int & size, vector<int> adj[],  vector<int> & vis, vector<int> & all ){\\n        vis[node] = 1;\\n        size ++;\\n        all.push_back(node);\\n\\n        for( auto it : adj[node] ){\\n            if( vis[it] == 0 ) dfs(it, size, adj,vis,all);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n]; // adjacency array\\n        vector<int> vis(n,0); // visited array\\n\\n        for( int i = 0; i<edges.size(); i++ ){ // creating the adjacency array\\n            vector<int> temp = edges[i];\\n            adj[temp[0]].push_back(temp[1]);\\n            adj[temp[1]].push_back(temp[0]);\\n        }\\n\\n\\n        int ans = 0; // to keep a count of the number of complete components\\n\\n        // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat\\n\\n        for( int i = 0; i<n; i++ ){ \\n            if( vis[i] == 0 ) {\\n                // call dfs -> this function will traverse to all the nodes in a component\\n                int size = 0; // to store the number of nodes in that component\\n                vector<int> all; // we need to know who all nodes are there in that component so that we can check if its connected to all others\\n                dfs(i, size, adj,vis, all);\\n                bool check = true; // to check if \"ALL\" the nodes fulfill the requirement\\n                for( int j = 0; j<all.size(); j++ ){\\n                    vector<int> node = adj[all[j]];\\n                    if( node.size() < size-1 ) check = false;\\n                }\\n                if( check == true ) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs( int node, int & size, vector<int> adj[],  vector<int> & vis, vector<int> & all ){\\n        vis[node] = 1;\\n        size ++;\\n        all.push_back(node);\\n\\n        for( auto it : adj[node] ){\\n            if( vis[it] == 0 ) dfs(it, size, adj,vis,all);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n]; // adjacency array\\n        vector<int> vis(n,0); // visited array\\n\\n        for( int i = 0; i<edges.size(); i++ ){ // creating the adjacency array\\n            vector<int> temp = edges[i];\\n            adj[temp[0]].push_back(temp[1]);\\n            adj[temp[1]].push_back(temp[0]);\\n        }\\n\\n\\n        int ans = 0; // to keep a count of the number of complete components\\n\\n        // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat\\n\\n        for( int i = 0; i<n; i++ ){ \\n            if( vis[i] == 0 ) {\\n                // call dfs -> this function will traverse to all the nodes in a component\\n                int size = 0; // to store the number of nodes in that component\\n                vector<int> all; // we need to know who all nodes are there in that component so that we can check if its connected to all others\\n                dfs(i, size, adj,vis, all);\\n                bool check = true; // to check if \"ALL\" the nodes fulfill the requirement\\n                for( int j = 0; j<all.size(); j++ ){\\n                    vector<int> node = adj[all[j]];\\n                    if( node.size() < size-1 ) check = false;\\n                }\\n                if( check == true ) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952790,
                "title": "cpp-solution-using-dfs-traversal",
                "content": "# Complexity\\n- Time complexity:\\nO(V + E)\\n\\n- Space complexity:\\nO(V + E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<int, list<int>> &m, unordered_map<int, bool> &visited, int src, int &node, int &edge)\\n    {\\n        visited[src] = true;\\n        node++;\\n        edge += m[src].size();\\n\\n        for(auto nbr: m[src])\\n        {\\n            if(!visited[nbr])\\n                dfs(m, visited, nbr, node, edge);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, list<int>>m;\\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            m[u].push_back(v);\\n            m[v].push_back(u);\\n        }\\n\\n        unordered_map<int, bool>visited;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int node = 0, edge = 0;\\n                dfs(m, visited, i, node, edge);\\n                edge /= 2;\\n                if(((node * (node - 1)) / 2) == edge)\\n                    ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\nHope you understand the code.",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<int, list<int>> &m, unordered_map<int, bool> &visited, int src, int &node, int &edge)\\n    {\\n        visited[src] = true;\\n        node++;\\n        edge += m[src].size();\\n\\n        for(auto nbr: m[src])\\n        {\\n            if(!visited[nbr])\\n                dfs(m, visited, nbr, node, edge);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, list<int>>m;\\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            m[u].push_back(v);\\n            m[v].push_back(u);\\n        }\\n\\n        unordered_map<int, bool>visited;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                int node = 0, edge = 0;\\n                dfs(m, visited, i, node, edge);\\n                edge /= 2;\\n                if(((node * (node - 1)) / 2) == edge)\\n                    ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951650,
                "title": "easy-to-understand-using-dfs",
                "content": "# Intuition\\nDFS\\n\\n# Approach\\nDFS and check number of nodes ond edges.\\n\\n# Complexity\\n- Time complexity:\\n O( N+M )\\n\\n- Space complexity:\\n O( N+M )\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node, vector<bool>&vis,vector<vector<int>>&adj,int &x,int &y){\\n        vis[node]=true;\\n        x+=adj[node].size();\\n         y++;\\n        for(auto child:adj[node]){\\n            if(!vis[child]){\\n               \\n                dfs(child,vis,adj,x,y);\\n            }\\n        }\\n\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        int k=edges.size();\\n        for(int i=0;i<k;i++){\\n           adj[edges[i][0]].push_back(edges[i][1]);\\n           adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<bool>vis(n);\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            int x=0,y=0;\\n            if(!vis[i]){\\n                dfs(i,vis,adj,x,y);\\n                if(x==(y*(y-1)))cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int node, vector<bool>&vis,vector<vector<int>>&adj,int &x,int &y){\\n        vis[node]=true;\\n        x+=adj[node].size();\\n         y++;\\n        for(auto child:adj[node]){\\n            if(!vis[child]){\\n               \\n                dfs(child,vis,adj,x,y);\\n            }\\n        }\\n\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        int k=edges.size();\\n        for(int i=0;i<k;i++){\\n           adj[edges[i][0]].push_back(edges[i][1]);\\n           adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<bool>vis(n);\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            int x=0,y=0;\\n            if(!vis[i]){\\n                dfs(i,vis,adj,x,y);\\n                if(x==(y*(y-1)))cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949059,
                "title": "c-easy-to-understand-solution",
                "content": "class Solution {\\npublic:\\n  void dfs(int node, int size,vector<int>&vis,vector<int>adj[],bool &f,int &number)\\n  {\\n    vis[node]=1;\\n    if(adj[node].size()!=size)\\n      f=0;\\n    number++;\\n    for(auto it:adj[node])\\n    {\\n      if(vis[it]==0)\\n        dfs(it,size,vis,adj,f,number);\\n    }\\n    \\n  }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n       vector<int>adj[n];\\n      \\n      for(int i=0;i<edges.size();i++)\\n      {\\n        adj[edges[i][0]].push_back(edges[i][1]);\\n         adj[edges[i][1]].push_back(edges[i][0]);\\n      }\\n      \\n      vector<int>vis(n);\\n      int c=0;\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n                  \\n        if(vis[i]==0)\\n        {\\n          bool f=1;\\n          int number=0;\\n          int size=adj[i].size();\\n          dfs(i,size,vis,adj,f,number);\\n          if(f==1 && size==number-1)\\n            c++;\\n        }\\n      }\\n      return c;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n  void dfs(int node, int size,vector<int>&vis,vector<int>adj[],bool &f,int &number)\\n  {\\n    vis[node]=1;\\n    if(adj[node].size()!=size)\\n      f=0;\\n    number++;\\n    for(auto it:adj[node])\\n    {\\n      if(vis[it]==0)\\n        dfs(it,size,vis,adj,f,number);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3945695,
                "title": "c-dfs-and-bfs-both-easiest-approach-killer-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# DFS\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\nint nodec=0;\\nint edgec=0;\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        //vector<int> adj[n];\\n        vector<bool> vis(n,false);\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        for(int i = 0; i < n; i += 1) \\n        {\\n            int nodec = 0,edgec = 0;\\n            if(vis[i]==false) \\n            {\\n                dfs(adj,vis,i,nodec,edgec);\\n                if(nodec*(nodec - 1) == edgec) \\n                ans ++;\\n            }\\n        }\\n        return ans;\\n    }\\n    void dfs(vector<vector<int>>  &adj,vector<bool> &vis,int start,int &nodec,int &edgec)\\n    {\\n\\n        vis[start]=true;\\n        nodec++;\\n        edgec+=adj[start].size();\\n        for(auto x: adj[start])\\n        {\\n            if(vis[x]==false)\\n            {\\n                dfs(adj,vis,x,nodec,edgec);\\n            }\\n        }\\n\\n    }\\n};\\n```\\n# BFS\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                bfs(adj,vis,n,i);\\n            }\\n        }\\n        return ans;\\n    }\\n    void bfs(vector<int> adj[],vector<int> &vis,int n,int start)\\n    {\\n        int nodec=0;\\n        int edgec=0;\\n        queue<int> q;\\n        q.push(start);\\n        vis[start]=1;\\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            q.pop();\\n            nodec++;\\n            for(auto x: adj[u])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    vis[x]=1;\\n                    q.push(x);\\n                }\\n                edgec++;\\n            }\\n        }\\n        if(edgec==nodec*(nodec-1))\\n        ans++;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=0;\\nint nodec=0;\\nint edgec=0;\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        //vector<int> adj[n];\\n        vector<bool> vis(n,false);\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        for(int i = 0; i < n; i += 1) \\n        {\\n            int nodec = 0,edgec = 0;\\n            if(vis[i]==false) \\n            {\\n                dfs(adj,vis,i,nodec,edgec);\\n                if(nodec*(nodec - 1) == edgec) \\n                ans ++;\\n            }\\n        }\\n        return ans;\\n    }\\n    void dfs(vector<vector<int>>  &adj,vector<bool> &vis,int start,int &nodec,int &edgec)\\n    {\\n\\n        vis[start]=true;\\n        nodec++;\\n        edgec+=adj[start].size();\\n        for(auto x: adj[start])\\n        {\\n            if(vis[x]==false)\\n            {\\n                dfs(adj,vis,x,nodec,edgec);\\n            }\\n        }\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint ans=0;\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int> adj[n];\\n        vector<int> vis(n,0);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                bfs(adj,vis,n,i);\\n            }\\n        }\\n        return ans;\\n    }\\n    void bfs(vector<int> adj[],vector<int> &vis,int n,int start)\\n    {\\n        int nodec=0;\\n        int edgec=0;\\n        queue<int> q;\\n        q.push(start);\\n        vis[start]=1;\\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            q.pop();\\n            nodec++;\\n            for(auto x: adj[u])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    vis[x]=1;\\n                    q.push(x);\\n                }\\n                edgec++;\\n            }\\n        }\\n        if(edgec==nodec*(nodec-1))\\n        ans++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945686,
                "title": "simple-bfs",
                "content": "# Code\\n```\\n\\nbool f(int src,vector<int>adj[],vector<bool>&visited)\\n{\\n    int count1 = 0;\\n    int count2 = 0;\\n    queue<int>q;\\n    q.push(src);\\n    visited[src] = true;\\n    while(!q.empty())\\n    {\\n        int a = q.front();\\n        q.pop();\\n        count1++;\\n        count2 += adj[a].size();\\n        for(auto x:adj[a])\\n        {\\n            if(!visited[x])\\n            {\\n                visited[x] = true;\\n                q.push(x);\\n            }\\n        }\\n    }\\n    cout<<count1<<\" \"<<count2<<endl;\\n    count1 = count1 * (count1 - 1);\\n    return count1 == count2;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        vector<int>adj[n];\\n        int count = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<bool>visited(n,false);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                if(f(i,adj,visited))\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nbool f(int src,vector<int>adj[],vector<bool>&visited)\\n{\\n    int count1 = 0;\\n    int count2 = 0;\\n    queue<int>q;\\n    q.push(src);\\n    visited[src] = true;\\n    while(!q.empty())\\n    {\\n        int a = q.front();\\n        q.pop();\\n        count1++;\\n        count2 += adj[a].size();\\n        for(auto x:adj[a])\\n        {\\n            if(!visited[x])\\n            {\\n                visited[x] = true;\\n                q.push(x);\\n            }\\n        }\\n    }\\n    cout<<count1<<\" \"<<count2<<endl;\\n    count1 = count1 * (count1 - 1);\\n    return count1 == count2;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        vector<int>adj[n];\\n        int count = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<bool>visited(n,false);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                if(f(i,adj,visited))\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3942208,
                "title": "easy-union-find-solution",
                "content": "https://youtu.be/uYzdVfnx2UY\\n\\n# Code\\n```\\npublic class Solution {\\n    Dictionary<int, List<int>> adj = new();\\n    int[] parent;\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        parent = new int[n];\\n        Dictionary<int, List<int>> groups = new();\\n        \\n        for (var i = 0; i < n; i++) {\\n            parent[i] = i;\\n            adj[i] = new List<int>();\\n        }\\n\\n        foreach (var edge in edges) {\\n            adj[edge[0]].Add(edge[1]);\\n            adj[edge[1]].Add(edge[0]);\\n            union(edge[0], edge[1]);\\n        }\\n\\n        int comp = 0;\\n\\n        for (var i = 0; i < parent.Length; i++) {\\n            var parent = findParent(i);\\n            if (!groups.ContainsKey(parent)) {\\n                groups[parent] = new List<int>();\\n            }\\n            groups[parent].Add(i);\\n        }\\n\\n        foreach (var group in groups) {\\n            if (isComplete(group.Value)) comp++;\\n        }\\n        return comp;\\n    }\\n\\n    private bool isComplete(List<int> vertices) {\\n        foreach (var v in vertices) {\\n            if (adj[v].Count != vertices.Count - 1) return false;\\n        }\\n        return true;\\n    }\\n\\n    private int findParent(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = findParent(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    private void union(int x, int y) {\\n        parent[findParent(x)] = parent[findParent(y)];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    Dictionary<int, List<int>> adj = new();\\n    int[] parent;\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        parent = new int[n];\\n        Dictionary<int, List<int>> groups = new();\\n        \\n        for (var i = 0; i < n; i++) {\\n            parent[i] = i;\\n            adj[i] = new List<int>();\\n        }\\n\\n        foreach (var edge in edges) {\\n            adj[edge[0]].Add(edge[1]);\\n            adj[edge[1]].Add(edge[0]);\\n            union(edge[0], edge[1]);\\n        }\\n\\n        int comp = 0;\\n\\n        for (var i = 0; i < parent.Length; i++) {\\n            var parent = findParent(i);\\n            if (!groups.ContainsKey(parent)) {\\n                groups[parent] = new List<int>();\\n            }\\n            groups[parent].Add(i);\\n        }\\n\\n        foreach (var group in groups) {\\n            if (isComplete(group.Value)) comp++;\\n        }\\n        return comp;\\n    }\\n\\n    private bool isComplete(List<int> vertices) {\\n        foreach (var v in vertices) {\\n            if (adj[v].Count != vertices.Count - 1) return false;\\n        }\\n        return true;\\n    }\\n\\n    private int findParent(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = findParent(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    private void union(int x, int y) {\\n        parent[findParent(x)] = parent[findParent(y)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930943,
                "title": "simple-bfs-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&lis,set<pair<int,int>>&se)\\n    {\\n        for(int i=0;i<lis.size();i++)\\n        {\\n            for(int j=i+1;j<lis.size();j++)\\n            {\\n                int a=min(lis[i],lis[j]);\\n                int b=max(lis[i],lis[j]);\\n                if(se.find({a,b})==se.end())\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n    vector<int>adj[n];\\n    set<pair<int,int>>se;\\n    int res=0;\\n    for(auto x:edges)\\n    {\\n        adj[x[0]].push_back(x[1]);\\n        adj[x[1]].push_back(x[0]);\\n        se.insert({min(x[0],x[1]),max(x[0],x[1])});\\n\\n    }\\n    vector<int>vis(n);\\n   queue<int>q;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(vis[i])\\n        continue;\\n         \\n        q.push(i);\\n        vector<int>lis;\\n        vis[i]++;\\n        lis.push_back(i);\\n        while(q.size())\\n        {\\n            int k=q.front();\\n            q.pop();\\n            for(auto x:adj[k])\\n            {\\n                if(vis[x])\\n                continue;\\n                vis[x]=1;\\n                lis.push_back(x);\\n                q.push(x);\\n            }\\n        }\\n        if(check(lis,se))\\n        res++;\\n    }\\n    return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&lis,set<pair<int,int>>&se)\\n    {\\n        for(int i=0;i<lis.size();i++)\\n        {\\n            for(int j=i+1;j<lis.size();j++)\\n            {\\n                int a=min(lis[i],lis[j]);\\n                int b=max(lis[i],lis[j]);\\n                if(se.find({a,b})==se.end())\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n    vector<int>adj[n];\\n    set<pair<int,int>>se;\\n    int res=0;\\n    for(auto x:edges)\\n    {\\n        adj[x[0]].push_back(x[1]);\\n        adj[x[1]].push_back(x[0]);\\n        se.insert({min(x[0],x[1]),max(x[0],x[1])});\\n\\n    }\\n    vector<int>vis(n);\\n   queue<int>q;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(vis[i])\\n        continue;\\n         \\n        q.push(i);\\n        vector<int>lis;\\n        vis[i]++;\\n        lis.push_back(i);\\n        while(q.size())\\n        {\\n            int k=q.front();\\n            q.pop();\\n            for(auto x:adj[k])\\n            {\\n                if(vis[x])\\n                continue;\\n                vis[x]=1;\\n                lis.push_back(x);\\n                q.push(x);\\n            }\\n        }\\n        if(check(lis,se))\\n        res++;\\n    }\\n    return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929347,
                "title": "c-simple-dfs-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&adj, vector<bool>&vis, int i, int&curr1, int &curr2)\\n    {\\n        vis[i]=true;\\n        curr1++;\\n        for(int x: adj[i])\\n        {\\n            curr2++;\\n            if(vis[x]==false){dfs(adj, vis, x, curr1, curr2);}\\n        }\\n        return ;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges)\\n    {\\n        vector<vector<int>> adj(n);\\n        for(vector<int>&e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> vis(n, false);\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==false)\\n            {\\n                int curr1 = 0;int curr2 = 0;\\n                dfs(adj, vis, i, curr1, curr2);\\n                if(curr2 == curr1*(curr1-1)){ans++;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Counting",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&adj, vector<bool>&vis, int i, int&curr1, int &curr2)\\n    {\\n        vis[i]=true;\\n        curr1++;\\n        for(int x: adj[i])\\n        {\\n            curr2++;\\n            if(vis[x]==false){dfs(adj, vis, x, curr1, curr2);}\\n        }\\n        return ;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges)\\n    {\\n        vector<vector<int>> adj(n);\\n        for(vector<int>&e : edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> vis(n, false);\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==false)\\n            {\\n                int curr1 = 0;int curr2 = 0;\\n                dfs(adj, vis, i, curr1, curr2);\\n                if(curr2 == curr1*(curr1-1)){ans++;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928899,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int u, vector<vector<int>>& adj,vector<int>&vis,int& nodes,int& sum){\\n        vis[u]=1;\\n        nodes++;\\n        sum=sum+adj[u].size();\\n        for(auto v:adj[u]){\\n            if(vis[v]==0)dfs(v,adj,vis,nodes,sum);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>vis(n,0);\\n        vector<vector<int>>adj(n);\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            int nodes=0,sum=0;\\n            if(vis[i]==0){\\n                dfs(i,adj,vis,nodes,sum);\\n                if((nodes*(nodes-1)/2)==(sum/2))c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int u, vector<vector<int>>& adj,vector<int>&vis,int& nodes,int& sum){\\n        vis[u]=1;\\n        nodes++;\\n        sum=sum+adj[u].size();\\n        for(auto v:adj[u]){\\n            if(vis[v]==0)dfs(v,adj,vis,nodes,sum);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>vis(n,0);\\n        vector<vector<int>>adj(n);\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            int nodes=0,sum=0;\\n            if(vis[i]==0){\\n                dfs(i,adj,vis,nodes,sum);\\n                if((nodes*(nodes-1)/2)==(sum/2))c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912080,
                "title": "simple-dfs-solution-with-full-explanation",
                "content": "# Intuition\\nThe problem asks us to find the number of complete subgraphs within a given graph. Each complete subgraph is a group of nodes where every node is connected to all other nodes in the group, forming a complete graph structure. We can solve this problem using Depth-First Search (DFS) to explore connected components and checking if they are complete.\\n\\n# Approach\\n1. **Adjacency List:** Create an adjacency list representation of the graph using the given edges. This allows efficient traversal of the graph.\\n\\n2. **DFS Exploration:** Iterate through each unvisited node. Perform a DFS traversal starting from that node. During traversal, keep track of the number of visited nodes (nodeCount) and edges traversed (edgeCount).\\n\\n3. **Complete Subgraph Check:** After the DFS traversal completes, check if the component is complete. A complete subgraph with n nodes has precisely n * (n - 1) edges. Compare edgeCount with nodeCount * (nodeCount - 1) to determine if the component is complete.\\n\\n4. **Count Complete Components:** Increment a count whenever a complete component is found.\\n\\n5. **Result:** Return the total count of complete components.\\n\\n# Complexity\\n- Time complexity:\\n**O(N + E)**\\n\\n- Space complexity:\\n**O(N + E)**\\n\\n# Code\\n```\\nclass Solution {\\n    int edgeCount = 0; // Counter for counting edges during DFS traversal\\n    int nodeCount = 0; // Counter for counting nodes during DFS traversal\\n    \\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int count = 0; // Counter for complete components\\n        \\n        // Create an adjacency list representation of the graph\\n        HashMap<Integer, List<Integer>> adjacencyList = prepareAdjacencyList(edges, n);\\n        \\n        HashSet<Integer> visited = new HashSet<>(); // Set to keep track of visited nodes\\n        \\n        // Iterate through each node in the graph\\n        for(int currentNode : adjacencyList.keySet()){\\n            if(visited.contains(currentNode)) continue; // Skip if already visited\\n            \\n            nodeCount = 0; // Reset nodeCount for each component\\n            edgeCount = 0; // Reset edgeCount for each component\\n            \\n            // Explore the current component using DFS and check if it\\'s complete\\n            if(exploreByDfs(currentNode, adjacencyList, visited) == true){\\n                // If the component is complete, check if it\\'s a complete graph\\n                if(edgeCount == nodeCount * (nodeCount-1)){\\n                    // please refer to line no 42-43, as to why\\n                    // we are doing nodeCount * (nodeCount-1)\\n                    count++; // Increment the count of complete components\\n                }\\n            }\\n        }\\n        return count; // Return the total count of complete components\\n    }\\n\\n    // DFS traversal to explore a component and count nodes and edges\\n    private boolean exploreByDfs(int currentNode, HashMap<Integer, List<Integer>> adjacencyList, HashSet<Integer> visited){\\n        if(visited.contains(currentNode)) return false; // Stop if already visited\\n        nodeCount++; // Increment node count for the current component\\n        visited.add(currentNode); // Mark the current node as visited\\n        \\n        // Traverse neighbors of the current node\\n        for(int neighbour : adjacencyList.get(currentNode)){\\n            // as we are doing direct edgeCount++, hence for\\n            // 2 connected nodes, we\\'ll have 2 edges\\n            edgeCount++; // Increment edge count for each edge traversed\\n            exploreByDfs(neighbour, adjacencyList, visited); // Recursive DFS on neighbors\\n        }\\n\\n        return true; // Indicates that the current component is complete\\n    }\\n\\n    // Function to create an adjacency list representation of the graph\\n    private HashMap<Integer, List<Integer>> prepareAdjacencyList(int[][] edges, int n){\\n        HashMap<Integer, List<Integer>> adjacencyList = new HashMap<>(); // Initialize the adjacency list\\n        \\n        // Populate the adjacency list using the given edges\\n        for(int[] edge : edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            \\n            // Add edges for both nodes in the adjacency list\\n            adjacencyList.putIfAbsent(node1, new ArrayList<>());\\n            adjacencyList.get(node1).add(node2);\\n\\n            adjacencyList.putIfAbsent(node2, new ArrayList<>());\\n            adjacencyList.get(node2).add(node1);\\n        }\\n\\n        // Add nodes with no edges as well\\n        for(int node = 0; node < n; node++){\\n            if(!adjacencyList.containsKey(node)){\\n                adjacencyList.putIfAbsent(node, new ArrayList<>());\\n            }\\n        }\\n        return adjacencyList; // Return the prepared adjacency list\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int edgeCount = 0; // Counter for counting edges during DFS traversal\\n    int nodeCount = 0; // Counter for counting nodes during DFS traversal\\n    \\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int count = 0; // Counter for complete components\\n        \\n        // Create an adjacency list representation of the graph\\n        HashMap<Integer, List<Integer>> adjacencyList = prepareAdjacencyList(edges, n);\\n        \\n        HashSet<Integer> visited = new HashSet<>(); // Set to keep track of visited nodes\\n        \\n        // Iterate through each node in the graph\\n        for(int currentNode : adjacencyList.keySet()){\\n            if(visited.contains(currentNode)) continue; // Skip if already visited\\n            \\n            nodeCount = 0; // Reset nodeCount for each component\\n            edgeCount = 0; // Reset edgeCount for each component\\n            \\n            // Explore the current component using DFS and check if it\\'s complete\\n            if(exploreByDfs(currentNode, adjacencyList, visited) == true){\\n                // If the component is complete, check if it\\'s a complete graph\\n                if(edgeCount == nodeCount * (nodeCount-1)){\\n                    // please refer to line no 42-43, as to why\\n                    // we are doing nodeCount * (nodeCount-1)\\n                    count++; // Increment the count of complete components\\n                }\\n            }\\n        }\\n        return count; // Return the total count of complete components\\n    }\\n\\n    // DFS traversal to explore a component and count nodes and edges\\n    private boolean exploreByDfs(int currentNode, HashMap<Integer, List<Integer>> adjacencyList, HashSet<Integer> visited){\\n        if(visited.contains(currentNode)) return false; // Stop if already visited\\n        nodeCount++; // Increment node count for the current component\\n        visited.add(currentNode); // Mark the current node as visited\\n        \\n        // Traverse neighbors of the current node\\n        for(int neighbour : adjacencyList.get(currentNode)){\\n            // as we are doing direct edgeCount++, hence for\\n            // 2 connected nodes, we\\'ll have 2 edges\\n            edgeCount++; // Increment edge count for each edge traversed\\n            exploreByDfs(neighbour, adjacencyList, visited); // Recursive DFS on neighbors\\n        }\\n\\n        return true; // Indicates that the current component is complete\\n    }\\n\\n    // Function to create an adjacency list representation of the graph\\n    private HashMap<Integer, List<Integer>> prepareAdjacencyList(int[][] edges, int n){\\n        HashMap<Integer, List<Integer>> adjacencyList = new HashMap<>(); // Initialize the adjacency list\\n        \\n        // Populate the adjacency list using the given edges\\n        for(int[] edge : edges){\\n            int node1 = edge[0];\\n            int node2 = edge[1];\\n            \\n            // Add edges for both nodes in the adjacency list\\n            adjacencyList.putIfAbsent(node1, new ArrayList<>());\\n            adjacencyList.get(node1).add(node2);\\n\\n            adjacencyList.putIfAbsent(node2, new ArrayList<>());\\n            adjacencyList.get(node2).add(node1);\\n        }\\n\\n        // Add nodes with no edges as well\\n        for(int node = 0; node < n; node++){\\n            if(!adjacencyList.containsKey(node)){\\n                adjacencyList.putIfAbsent(node, new ArrayList<>());\\n            }\\n        }\\n        return adjacencyList; // Return the prepared adjacency list\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901204,
                "title": "solution-in-java-indegree-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int[] indegree = new int[n];\\n        for (int[] e : edges) {\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n\\n        int result = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!visited.contains(i)) {\\n                Set<Integer> subGraph = new HashSet<>();\\n\\n                fillSubGraph(i, edges, visited, subGraph);\\n                \\n                int edgeCount = subGraph.size() - 1;\\n                for (int v : subGraph) {\\n                    if (indegree[v] != edgeCount) {\\n                        subGraph.clear();\\n                        break;\\n                    }\\n                }\\n                if (!subGraph.isEmpty()) {\\n                    result++;\\n                }           \\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void fillSubGraph(int source, int[][] edges, Set<Integer> visited, Set<Integer> subGraph) {\\n        if (visited.contains(source)) {\\n            return;\\n        }\\n\\n        visited.add(source);\\n        subGraph.add(source);\\n\\n        for (int[] e : edges) {\\n            if (e[0] == source) {\\n                fillSubGraph(e[1], edges, visited, subGraph);\\n            }\\n            if (e[1] == source) {\\n                fillSubGraph(e[0], edges, visited, subGraph);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int[] indegree = new int[n];\\n        for (int[] e : edges) {\\n            indegree[e[0]]++;\\n            indegree[e[1]]++;\\n        }\\n\\n        int result = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!visited.contains(i)) {\\n                Set<Integer> subGraph = new HashSet<>();\\n\\n                fillSubGraph(i, edges, visited, subGraph);\\n                \\n                int edgeCount = subGraph.size() - 1;\\n                for (int v : subGraph) {\\n                    if (indegree[v] != edgeCount) {\\n                        subGraph.clear();\\n                        break;\\n                    }\\n                }\\n                if (!subGraph.isEmpty()) {\\n                    result++;\\n                }           \\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void fillSubGraph(int source, int[][] edges, Set<Integer> visited, Set<Integer> subGraph) {\\n        if (visited.contains(source)) {\\n            return;\\n        }\\n\\n        visited.add(source);\\n        subGraph.add(source);\\n\\n        for (int[] e : edges) {\\n            if (e[0] == source) {\\n                fillSubGraph(e[1], edges, visited, subGraph);\\n            }\\n            if (e[1] == source) {\\n                fillSubGraph(e[0], edges, visited, subGraph);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900779,
                "title": "c-easy-and-fast-dfs-recursion",
                "content": "TC:O(N  -->number of nodes)\\nSC:O(2 * N) + Auxiliary stack space \\n```\\nclass Solution {\\npublic:\\n    pair<int,int>solve(int node,vector<int>&visited,vector<vector<int>>&adj){\\n    //base case    \\n    //-->this will never happen as we\\'re alreday checking visited in for loop\\n        if(visited[node])return {0,0};\\n        \\n        visited[node]=1;\\n        pair<int,int>ans={1,0};\\n        \\n        for(auto it:adj[node]){\\n            if(!visited[it]){\\n                pair<int,int> temp = solve(it,visited,adj);\\n                ans.first+= temp.first;\\n                ans.second+= 1 + temp.second;\\n            }\\n            else\\n                ans.second+=1;\\n        }\\n        return ans; // {total_nodes in components,2* toltal edges in component}\\n    }\\n        \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>visited(n,0);\\n        vector<vector<int>>adj(n);\\n        int components=0;\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int node=0;node<n;node++){\\n            if(!visited[node]){\\n                pair<int,int> ans = solve(node,visited,adj);\\n                int total_nodes = ans.first;\\n                int total_edges = ans.second/2;\\n                if((total_nodes*(total_nodes-1))/2==total_edges)\\n                    components++;\\n            }\\n        }\\n        return components;\\n    }\\n};\\n\\n\\t//Appraoch: total number of edges in complete component = (n * (n-1))/2\\n\\t// where \\'n\\' is the number of nodes in that component\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int>solve(int node,vector<int>&visited,vector<vector<int>>&adj){\\n    //base case    \\n    //-->this will never happen as we\\'re alreday checking visited in for loop\\n        if(visited[node])return {0,0};\\n        \\n        visited[node]=1;\\n        pair<int,int>ans={1,0};\\n        \\n        for(auto it:adj[node]){\\n            if(!visited[it]){\\n                pair<int,int> temp = solve(it,visited,adj);\\n                ans.first+= temp.first;\\n                ans.second+= 1 + temp.second;\\n            }\\n            else\\n                ans.second+=1;\\n        }\\n        return ans; // {total_nodes in components,2* toltal edges in component}\\n    }\\n        \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int>visited(n,0);\\n        vector<vector<int>>adj(n);\\n        int components=0;\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int node=0;node<n;node++){\\n            if(!visited[node]){\\n                pair<int,int> ans = solve(node,visited,adj);\\n                int total_nodes = ans.first;\\n                int total_edges = ans.second/2;\\n                if((total_nodes*(total_nodes-1))/2==total_edges)\\n                    components++;\\n            }\\n        }\\n        return components;\\n    }\\n};\\n\\n\\t//Appraoch: total number of edges in complete component = (n * (n-1))/2\\n\\t// where \\'n\\' is the number of nodes in that component\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894452,
                "title": "dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\nvoid dfs( vector<int> adj[] ,int i , vector<bool> & vis , int nodes, bool & fl , int & cir){\\n    if( vis[i]==true)return ;\\n    cir ++;\\n    if(  cir > nodes+1) fl= true;\\n    vis[i]=true;\\n    for(auto x : adj[i]){\\n        if( adj[x].size()!=nodes )fl=true;\\n        if( vis[x]==false){\\n           \\n            dfs( adj , x, vis , nodes , fl , cir);\\n        }\\n    }\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> adj[n];\\n        for(auto x : e){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int ct=0;\\n        vector<bool> vis( n , false);\\n        for( int i =0; i< n ; i++){\\n            if( vis[i]==false){\\n                int nodes = adj[i].size();\\n                bool fl = false;\\n                int cir =0;\\n                dfs( adj , i , vis  , nodes , fl , cir);\\n                if( fl==false)ct++;\\n            }\\n            \\n        }\\n        return ct;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs( vector<int> adj[] ,int i , vector<bool> & vis , int nodes, bool & fl , int & cir){\\n    if( vis[i]==true)return ;\\n    cir ++;\\n    if(  cir > nodes+1) fl= true;\\n    vis[i]=true;\\n    for(auto x : adj[i]){\\n        if( adj[x].size()!=nodes )fl=true;\\n        if( vis[x]==false){\\n           \\n            dfs( adj , x, vis , nodes , fl , cir);\\n        }\\n    }\\n}\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> adj[n];\\n        for(auto x : e){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int ct=0;\\n        vector<bool> vis( n , false);\\n        for( int i =0; i< n ; i++){\\n            if( vis[i]==false){\\n                int nodes = adj[i].size();\\n                bool fl = false;\\n                int cir =0;\\n                dfs( adj , i , vis  , nodes , fl , cir);\\n                if( fl==false)ct++;\\n            }\\n            \\n        }\\n        return ct;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893651,
                "title": "dfs-graph-theory-knowledge-c-solution",
                "content": "# Intuition\\nLooking at this we can find it is a connected component sum and one thing for sure is like we should use DFS in order to find the connected components in the graph.\\n\\nLogic:\\nIf there are `n` vertices in a component, then how many edges should be there if it each and every edge should be connected in the component?\\n\\nAnswer: `(n*(n-1)) - For each vertices it should be connected to n-1 vertices.`\\n\\n# Approach\\nWith the following said, just do a normal DFS and then calculate the number of edges and vertices we have and compare it in order to check whether the component is complete component.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(N+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int idx, vector<int> adj[], vector<int> &vis, int &noOfVertices, int &noOfEdges) {\\n        vis[idx] = 1;\\n        noOfVertices++;\\n        noOfEdges+=adj[idx].size();\\n        for(auto &it:adj[idx]) {\\n            if(!vis[it]) {\\n                dfs(it, adj, vis, noOfVertices, noOfEdges);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int cnt = 0;\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<n;i++) {\\n            if(!vis[i]) {\\n                // cout<<\"YES \"<<i<<\"\\\\n\";\\n                int noOfVertices = 0, noOfEdges = 0;\\n                dfs(i, adj, vis, noOfVertices, noOfEdges);\\n                if(noOfEdges == (noOfVertices*(noOfVertices-1))) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n`Pls Upvote if you understood the solution!!`",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int idx, vector<int> adj[], vector<int> &vis, int &noOfVertices, int &noOfEdges) {\\n        vis[idx] = 1;\\n        noOfVertices++;\\n        noOfEdges+=adj[idx].size();\\n        for(auto &it:adj[idx]) {\\n            if(!vis[it]) {\\n                dfs(it, adj, vis, noOfVertices, noOfEdges);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int cnt = 0;\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++) {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<n;i++) {\\n            if(!vis[i]) {\\n                // cout<<\"YES \"<<i<<\"\\\\n\";\\n                int noOfVertices = 0, noOfEdges = 0;\\n                dfs(i, adj, vis, noOfVertices, noOfEdges);\\n                if(noOfEdges == (noOfVertices*(noOfVertices-1))) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3878049,
                "title": "simplest-solution-easy-to-understand-c",
                "content": "# Intuition\\nAdjacency list for all the nodes in a complete component will become same if we insert that node in its respective adjacency list.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<bool>& vis, int curr, vector<vector<int>>& adj){\\n        vis[curr]=true;\\n        for(auto a: adj[curr]){\\n            if(!vis[a])\\n                if(!check(vis, a, adj)) return false;\\n                if(adj[a]!=adj[curr])return false;\\n        }\\n    return true;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n        int count=0;    \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<adj.size();i++){\\n            adj[i].push_back(i);\\n            sort(adj[i].begin(), adj[i].end());\\n        }\\n\\n        for(int i=0;i<vis.size();i++)\\n            if(!vis[i] && check(vis, i, adj))\\n            count++;\\n\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<bool>& vis, int curr, vector<vector<int>>& adj){\\n        vis[curr]=true;\\n        for(auto a: adj[curr]){\\n            if(!vis[a])\\n                if(!check(vis, a, adj)) return false;\\n                if(adj[a]!=adj[curr])return false;\\n        }\\n    return true;\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        vector<bool> vis(n, false);\\n        int count=0;    \\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<adj.size();i++){\\n            adj[i].push_back(i);\\n            sort(adj[i].begin(), adj[i].end());\\n        }\\n\\n        for(int i=0;i<vis.size();i++)\\n            if(!vis[i] && check(vis, i, adj))\\n            count++;\\n\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876965,
                "title": "using-dfs-broken-down-into-steps-easily-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Firstly, In order to find all the connected components we need to do a DFS. \\n After this, the next step is to confirm whether the given component that we traversed is connected or not. \\nFor this, we just run a simple for loop on every node present in the set and check if the degree of the curr node is equal to size of set(i.e all nodes present in the componet) minus 1 it means that the componet is connected\\nAfter this condition has been checked we can now increase our res variable.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isConnected(vector<vector<int>> &AL, unordered_set<int> &s)\\n    {\\n        //comparing degree of each node present in set since every node in a connected component\\n        //has a degree that is equal to total no of nodes in the component - 1\\n        int ExpectedDegree = s.size()-1;\\n        for(auto i : s)\\n        {\\n            if(AL[i].size() != ExpectedDegree)\\n                return false;\\n        }\\n        return true;\\n    }\\n    void DFS(int i, vector<vector<int>>& al, unordered_set<int> &s)\\n    {\\n        if(s.insert(i).second)//the second parameter tells whether the insertion was succesful or not\\n            for(auto j : al[i])\\n                DFS(j, al, s);\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> AL(n);\\n        int res = 0;\\n        //creating adjacency list\\n        for(const auto i : edges)\\n        {\\n            AL[i[0]].push_back(i[1]);\\n            AL[i[1]].push_back(i[0]);\\n        }\\n        //stores all nodes processed in a single DFS iteration\\n        unordered_set<int> ms;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ms.count(i) == 0)\\n            {\\n                unordered_set<int> s;\\n                DFS(i, AL, s);\\n                if(isConnected(AL,s))\\n                    res++;\\n                ms.insert(s.begin(), s.end());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isConnected(vector<vector<int>> &AL, unordered_set<int> &s)\\n    {\\n        //comparing degree of each node present in set since every node in a connected component\\n        //has a degree that is equal to total no of nodes in the component - 1\\n        int ExpectedDegree = s.size()-1;\\n        for(auto i : s)\\n        {\\n            if(AL[i].size() != ExpectedDegree)\\n                return false;\\n        }\\n        return true;\\n    }\\n    void DFS(int i, vector<vector<int>>& al, unordered_set<int> &s)\\n    {\\n        if(s.insert(i).second)//the second parameter tells whether the insertion was succesful or not\\n            for(auto j : al[i])\\n                DFS(j, al, s);\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> AL(n);\\n        int res = 0;\\n        //creating adjacency list\\n        for(const auto i : edges)\\n        {\\n            AL[i[0]].push_back(i[1]);\\n            AL[i[1]].push_back(i[0]);\\n        }\\n        //stores all nodes processed in a single DFS iteration\\n        unordered_set<int> ms;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ms.count(i) == 0)\\n            {\\n                unordered_set<int> s;\\n                DFS(i, AL, s);\\n                if(isConnected(AL,s))\\n                    res++;\\n                ms.insert(s.begin(), s.end());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876218,
                "title": "c-beats-96-51-users",
                "content": "![Screenshot 2023-08-07 at 3.51.38 PM.png](https://assets.leetcode.com/users/images/132c2b51-1c60-41d5-812b-97e0571efb4b_1691403769.3194032.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSave nodes of component in every dfs call, keep tab on the size of component and check if every node has adjacent (component-size - 1 ) neighbours or not, if it does, ans++\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int in,vector<int>& vis,vector<int> adj[],vector<int>& nodes,int &compsize)\\n    {\\n        vis[in]=1;\\n        nodes.push_back(in);\\n        compsize++;\\n        for(auto it : adj[in])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,vis,adj,nodes,compsize);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int x = edges[i][0];\\n            int y = edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int> vis(n,0);\\n        int ans = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                int compsize = 0;\\n                vector<int> nodes;\\n                dfs(i,vis,adj,nodes,compsize);\\n                int flag = 0;\\n                for(auto j : nodes)\\n                {\\n                    if(adj[j].size()!=compsize-1)\\n                        flag=1;\\n                }\\n                if(flag==0)\\n                    ans++;\\n            };\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int in,vector<int>& vis,vector<int> adj[],vector<int>& nodes,int &compsize)\\n    {\\n        vis[in]=1;\\n        nodes.push_back(in);\\n        compsize++;\\n        for(auto it : adj[in])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it,vis,adj,nodes,compsize);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int x = edges[i][0];\\n            int y = edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int> vis(n,0);\\n        int ans = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                int compsize = 0;\\n                vector<int> nodes;\\n                dfs(i,vis,adj,nodes,compsize);\\n                int flag = 0;\\n                for(auto j : nodes)\\n                {\\n                    if(adj[j].size()!=compsize-1)\\n                        flag=1;\\n                }\\n                if(flag==0)\\n                    ans++;\\n            };\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870914,
                "title": "solution-using-dfs-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    void dfs(int i, vector<int> &vis, vector<vector<int>>&adj,vector<int>&v){\\n        \\n        vis[i]=1;\\n        v.push_back(i);\\n        for(auto it : adj[i]){\\n            if(vis[it]==0)  dfs(it,vis,adj,v);\\n            \\n        }\\n        return ;\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        \\n        for(auto i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            \\n            if(vis[i]==0){\\n                int count=0;\\n                vector<int>v;\\n                dfs(i,vis,adj,v);\\n                for(auto j : v){\\n                    if(adj[j].size()>=v.size()-1) count++;\\n                }\\n                \\n                if(count == v.size())ans++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if found usefull**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    void dfs(int i, vector<int> &vis, vector<vector<int>>&adj,vector<int>&v){\\n        \\n        vis[i]=1;\\n        v.push_back(i);\\n        for(auto it : adj[i]){\\n            if(vis[it]==0)  dfs(it,vis,adj,v);\\n            \\n        }\\n        return ;\\n    }\\n    \\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        \\n        for(auto i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            \\n            if(vis[i]==0){\\n                int count=0;\\n                vector<int>v;\\n                dfs(i,vis,adj,v);\\n                for(auto j : v){\\n                    if(adj[j].size()>=v.size()-1) count++;\\n                }\\n                \\n                if(count == v.size())ans++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869470,
                "title": "using-only-dfs-no-hashing",
                "content": "# Code\\n```\\nclass Solution {\\n    private:\\n    pair<int,int> DFS(int node,vector<int>adj[],vector<int>&vis,int par){\\n        vis[node] = 1;\\n        int nCnt = 1;\\n        int edgCnt = 0;\\n        for(auto it:adj[node]){\\n            if(vis[it] == 0){\\n                edgCnt++;\\n                auto pr = DFS(it,adj,vis,node);\\n                vis[it]=-1;\\n                edgCnt+= pr.second;\\n                nCnt+= pr.first;\\n            }\\n            else if(it!=par && vis[it]!=-1){\\n                edgCnt++;\\n            }\\n        }\\n        return {nCnt,edgCnt};\\n    }\\n\\n    int calNC2(int n){\\n        return n*(n-1)/2;\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n,0);\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                auto pr = DFS(i,adj,vis,-1);\\n                int nc2 = calNC2(pr.first);\\n                if(nc2 == pr.second)cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    pair<int,int> DFS(int node,vector<int>adj[],vector<int>&vis,int par){\\n        vis[node] = 1;\\n        int nCnt = 1;\\n        int edgCnt = 0;\\n        for(auto it:adj[node]){\\n            if(vis[it] == 0){\\n                edgCnt++;\\n                auto pr = DFS(it,adj,vis,node);\\n                vis[it]=-1;\\n                edgCnt+= pr.second;\\n                nCnt+= pr.first;\\n            }\\n            else if(it!=par && vis[it]!=-1){\\n                edgCnt++;\\n            }\\n        }\\n        return {nCnt,edgCnt};\\n    }\\n\\n    int calNC2(int n){\\n        return n*(n-1)/2;\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n,0);\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                auto pr = DFS(i,adj,vis,-1);\\n                int nc2 = calNC2(pr.first);\\n                if(nc2 == pr.second)cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866318,
                "title": "easy-bfs-solution-thoda-different",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a BFS Solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst get all the connected components using BFS and then check for each connected component whether it is completely connected by calculating the total number of edges between the graph.\\nTotal number of edges between the graph should be >= n(n-1)/2. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n\\n    vector<int> bfs(int source,vector<vector<int>> &adj)\\n    {\\n        vector<int> connCom;\\n\\n        vector<bool> curr_visited(adj.size(),false);\\n        queue<int> q;\\n        q.push(source);\\n        curr_visited[source] = true;\\n        \\n\\n        while(!q.empty())\\n        {\\n            //pop the first element;\\n            int fNode = q.front();q.pop();\\n            connCom.push_back(fNode);\\n\\n            for(int k =0;k<adj[fNode].size();k++)\\n            {\\n                int nN = adj[fNode][k];\\n                if( curr_visited[nN]== false)\\n                {\\n                    q.push(nN);\\n                    curr_visited[nN] = true;\\n                }\\n            }\\n\\n        }\\n    return connCom;\\n    }\\n\\n    bool isComponentComplete(vector<int> & graph, vector<vector<int>> &adj)\\n    {\\n        int graphSize = graph.size();\\n\\n        if(graphSize < 2)\\n        {\\n            return true;\\n        }\\n        int totalEdgesCount = 0;\\n\\n        for(int i =0;i<graphSize;i++)\\n        {\\n            // cout<<\" : \"<<graph[i];\\n            totalEdgesCount+=(adj[graph[i]].size());\\n        }\\n        // cout<<endl;\\n\\n        if(totalEdgesCount >= graphSize*(graphSize-1))\\n        {\\n            return true;\\n        }\\n\\n\\n        return false;\\n    }\\n\\n    vector<vector<int>> getAllConnectedComponents(vector<vector<int>> &adj) {\\n        vector<vector<int>> res;\\n\\n        int total_nodes = adj.size();\\n\\n  \\n\\n        vector<int> visited(total_nodes,false);\\n\\n        for(int i =0;i<total_nodes;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                //BFS\\n                vector<int> cC = bfs(i,adj);\\n\\n\\n                for(int j =0;j<cC.size();j++)\\n                {\\n                    visited[cC[j]] = true;\\n                }\\n                res.push_back(cC);\\n            }\\n        }\\n        return res;\\n\\n\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n);\\n        //0...n-1\\n\\n        for(int i =0;i<edges.size();i++)\\n        {\\n            //Add the element to adj\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        //Adj matrix is complete\\n\\n\\n\\n        vector<vector<int>> connectedComponents = getAllConnectedComponents(adj);\\n\\n        //CHECK FOR COMPETENESS;\\n\\n        int fRes = 0;\\n        for(int cCom =0; cCom< connectedComponents.size(); cCom++)\\n        {\\n            if(isComponentComplete(connectedComponents[cCom],adj)){\\n                fRes++;\\n            }\\n        }\\n\\n        return fRes;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n\\n    vector<int> bfs(int source,vector<vector<int>> &adj)\\n    {\\n        vector<int> connCom;\\n\\n        vector<bool> curr_visited(adj.size(),false);\\n        queue<int> q;\\n        q.push(source);\\n        curr_visited[source] = true;\\n        \\n\\n        while(!q.empty())\\n        {\\n            //pop the first element;\\n            int fNode = q.front();q.pop();\\n            connCom.push_back(fNode);\\n\\n            for(int k =0;k<adj[fNode].size();k++)\\n            {\\n                int nN = adj[fNode][k];\\n                if( curr_visited[nN]== false)\\n                {\\n                    q.push(nN);\\n                    curr_visited[nN] = true;\\n                }\\n            }\\n\\n        }\\n    return connCom;\\n    }\\n\\n    bool isComponentComplete(vector<int> & graph, vector<vector<int>> &adj)\\n    {\\n        int graphSize = graph.size();\\n\\n        if(graphSize < 2)\\n        {\\n            return true;\\n        }\\n        int totalEdgesCount = 0;\\n\\n        for(int i =0;i<graphSize;i++)\\n        {\\n            // cout<<\" : \"<<graph[i];\\n            totalEdgesCount+=(adj[graph[i]].size());\\n        }\\n        // cout<<endl;\\n\\n        if(totalEdgesCount >= graphSize*(graphSize-1))\\n        {\\n            return true;\\n        }\\n\\n\\n        return false;\\n    }\\n\\n    vector<vector<int>> getAllConnectedComponents(vector<vector<int>> &adj) {\\n        vector<vector<int>> res;\\n\\n        int total_nodes = adj.size();\\n\\n  \\n\\n        vector<int> visited(total_nodes,false);\\n\\n        for(int i =0;i<total_nodes;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                //BFS\\n                vector<int> cC = bfs(i,adj);\\n\\n\\n                for(int j =0;j<cC.size();j++)\\n                {\\n                    visited[cC[j]] = true;\\n                }\\n                res.push_back(cC);\\n            }\\n        }\\n        return res;\\n\\n\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> adj(n);\\n        //0...n-1\\n\\n        for(int i =0;i<edges.size();i++)\\n        {\\n            //Add the element to adj\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        //Adj matrix is complete\\n\\n\\n\\n        vector<vector<int>> connectedComponents = getAllConnectedComponents(adj);\\n\\n        //CHECK FOR COMPETENESS;\\n\\n        int fRes = 0;\\n        for(int cCom =0; cCom< connectedComponents.size(); cCom++)\\n        {\\n            if(isComponentComplete(connectedComponents[cCom],adj)){\\n                fRes++;\\n            }\\n        }\\n\\n        return fRes;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3866123,
                "title": "c-dfs-math",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> G[100];\\n    int vis[1000];\\n    void dfs(int u, int &p, int &q) {\\n        if(vis[u]) return;\\n        vis[u] = 1;\\n        p++;\\n        q += G[u].size();\\n        for(auto &x : G[u]) {\\n            if(x != u) dfs(x, p, q);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        for(auto &x : edges) {\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n        }\\n        int components = 0, p, q;\\n        memset(vis, 0, sizeof(vis));\\n        for(int i = 0; i < n; ++i) {\\n            p = 0, q = 0;\\n            if(!vis[i]) {\\n                dfs(i, p, q);\\n                if(p*(p-1) == q) ++components;\\n            }\\n        }\\n        return components;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> G[100];\\n    int vis[1000];\\n    void dfs(int u, int &p, int &q) {\\n        if(vis[u]) return;\\n        vis[u] = 1;\\n        p++;\\n        q += G[u].size();\\n        for(auto &x : G[u]) {\\n            if(x != u) dfs(x, p, q);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        for(auto &x : edges) {\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n        }\\n        int components = 0, p, q;\\n        memset(vis, 0, sizeof(vis));\\n        for(int i = 0; i < n; ++i) {\\n            p = 0, q = 0;\\n            if(!vis[i]) {\\n                dfs(i, p, q);\\n                if(p*(p-1) == q) ++components;\\n            }\\n        }\\n        return components;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862191,
                "title": "cpp-easy-implemenatation-beats-95-breadth-first-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<bool> visit(n,false);\\n        if(edges.size()==0)return n;\\n        vector<vector<int>> adj(n);\\n        for(auto e: edges){\\n            adj[e[1]].push_back(e[0]);\\n            adj[e[0]].push_back(e[1]);\\n        }\\n        int nas=0;\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(visit[i]==false){\\n                visit[i]=true;\\n                q.push(i);\\n            }\\n            else continue;\\n            int count=0;\\n            int edges=0;\\n            while(!q.empty()){\\n                int n=q.front();\\n                q.pop();\\n                count++;\\n                for(int e: adj[n]){\\n                    edges++;\\n                    if(visit[e]==false){\\n                        visit[e]=true;\\n                        q.push(e);\\n                    }\\n                }\\n            \\n        }\\n        edges/=2;\\n            if(edges == (count-1)*count/2)nas++;\\n        }\\n        return nas;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<bool> visit(n,false);\\n        if(edges.size()==0)return n;\\n        vector<vector<int>> adj(n);\\n        for(auto e: edges){\\n            adj[e[1]].push_back(e[0]);\\n            adj[e[0]].push_back(e[1]);\\n        }\\n        int nas=0;\\n        queue<int>q;\\n        for(int i=0;i<n;i++){\\n            if(visit[i]==false){\\n                visit[i]=true;\\n                q.push(i);\\n            }\\n            else continue;\\n            int count=0;\\n            int edges=0;\\n            while(!q.empty()){\\n                int n=q.front();\\n                q.pop();\\n                count++;\\n                for(int e: adj[n]){\\n                    edges++;\\n                    if(visit[e]==false){\\n                        visit[e]=true;\\n                        q.push(e);\\n                    }\\n                }\\n            \\n        }\\n        edges/=2;\\n            if(edges == (count-1)*count/2)nas++;\\n        }\\n        return nas;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857802,
                "title": "easy-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void bfs(int node , vector<int> adj[] , vector<int> &vis , int &nodes , int &edges){\\n        queue<int> q;\\n        q.push(node);\\n        vis[node] = 1;\\n        int cnt = 0;\\n\\n        while(!q.empty()){\\n            int f = q.front();\\n            q.pop();\\n\\n            for(int ele : adj[f]){\\n                if(!vis[ele]){\\n                    nodes++;\\n                    q.push(ele);\\n                    vis[ele] = 1;\\n                }\\n                cnt++;\\n            }\\n        }\\n        edges = cnt/2;\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto ele : edges){\\n            adj[ele[0]].push_back(ele[1]);\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n\\n        vector<int> vis(n , 0);\\n\\n        int ans = 0;\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(!vis[i]){\\n                int nodes = 1 , edges = 0;\\n                bfs(i , adj , vis , nodes , edges);\\n\\n                if( edges == (nodes*(nodes-1))/2 ) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void bfs(int node , vector<int> adj[] , vector<int> &vis , int &nodes , int &edges){\\n        queue<int> q;\\n        q.push(node);\\n        vis[node] = 1;\\n        int cnt = 0;\\n\\n        while(!q.empty()){\\n            int f = q.front();\\n            q.pop();\\n\\n            for(int ele : adj[f]){\\n                if(!vis[ele]){\\n                    nodes++;\\n                    q.push(ele);\\n                    vis[ele] = 1;\\n                }\\n                cnt++;\\n            }\\n        }\\n        edges = cnt/2;\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto ele : edges){\\n            adj[ele[0]].push_back(ele[1]);\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n\\n        vector<int> vis(n , 0);\\n\\n        int ans = 0;\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(!vis[i]){\\n                int nodes = 1 , edges = 0;\\n                bfs(i , adj , vis , nodes , edges);\\n\\n                if( edges == (nodes*(nodes-1))/2 ) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854042,
                "title": "simple-logic-each-vertex-have-edges-no-of-vertices-1-for-that-connected-component",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,int& edge,int& v,vector<int>& vis,vector<vector<int>>& adjList){\\n        v++;\\n        vis[node]=1;\\n        for(auto it:adjList[node]){\\n            edge++;\\n            if(vis[it]==0){\\n                dfs(it,edge,v,vis,adjList);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adjList(n);\\n        for(int i=0;i<edges.size();i++){\\n            adjList[edges[i][0]].push_back(edges[i][1]);\\n            adjList[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n              int edge=0,v=0;\\n              if(vis[i]==0){\\n                  dfs(i,edge,v,vis,adjList);\\n                  \\n                  if(edge/v==v-1 ){\\n                      count++;\\n                  }\\n              }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,int& edge,int& v,vector<int>& vis,vector<vector<int>>& adjList){\\n        v++;\\n        vis[node]=1;\\n        for(auto it:adjList[node]){\\n            edge++;\\n            if(vis[it]==0){\\n                dfs(it,edge,v,vis,adjList);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adjList(n);\\n        for(int i=0;i<edges.size();i++){\\n            adjList[edges[i][0]].push_back(edges[i][1]);\\n            adjList[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n              int edge=0,v=0;\\n              if(vis[i]==0){\\n                  dfs(i,edge,v,vis,adjList);\\n                  \\n                  if(edge/v==v-1 ){\\n                      count++;\\n                  }\\n              }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852500,
                "title": "easy-sol-cpp",
                "content": "void dfs(int ver, vector<int> g[], vector<int> &vis, vector<int> &ele)\\n    {\\n        vis[ver]=1;\\n        cout<<ver<<\" \";\\n        ele.push_back(ver);\\n        for(auto child:g[ver])\\n        {\\n            if(vis[child])continue;\\n            vis[child]=1;\\n            dfs(child,g,vis,ele);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int i,ans=0;\\n        vector<int> g[n],vis(n,0);\\n        for(i=0;i<edges.size();i++)\\n        {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // vector<int> ele;\\n        // dfs(5,g,vis,ele);\\n        // cout<<\"\\\\n\"<<ele.size();\\n        for(i=0;i<n;i++)\\n        {\\n            vector<int> ele;\\n            if(vis[i])continue;\\n            dfs(i,g,vis,ele);\\n            // cout<<ele.size();\\n            int f=0;\\n            for(int j=0;j<ele.size();j++)\\n            {\\n                if(g[ele[j]].size()!=ele.size()-1)\\n                {\\n                    f=1;break;\\n                }\\n            }\\n            if(f==0)ans++;\\n        }\\n        return ans;",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "void dfs(int ver, vector<int> g[], vector<int> &vis, vector<int> &ele)\\n    {\\n        vis[ver]=1;\\n        cout<<ver<<\" \";\\n        ele.push_back(ver);\\n        for(auto child:g[ver])\\n        {\\n            if(vis[child])continue;\\n            vis[child]=1;\\n            dfs(child,g,vis,ele);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int i,ans=0;\\n        vector<int> g[n],vis(n,0);\\n        for(i=0;i<edges.size();i++)\\n        {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        // vector<int> ele;\\n        // dfs(5,g,vis,ele);\\n        // cout<<\"\\\\n\"<<ele.size();\\n        for(i=0;i<n;i++)\\n        {\\n            vector<int> ele;\\n            if(vis[i])continue;\\n            dfs(i,g,vis,ele);\\n            // cout<<ele.size();\\n            int f=0;\\n            for(int j=0;j<ele.size();j++)\\n            {\\n                if(g[ele[j]].size()!=ele.size()-1)\\n                {\\n                    f=1;break;\\n                }\\n            }\\n            if(f==0)ans++;\\n        }\\n        return ans;",
                "codeTag": "C++"
            },
            {
                "id": 3850472,
                "title": "dfs-which-counts-nodes-and-edges",
                "content": "# Code\\n```\\nclass Solution {\\n    int nodeCountForDFS = 0;\\n    long edgeCountForDFS = 0l;\\n\\n    // TC: O(V+E)\\n    // SC: O(V)\\n    public int countCompleteComponents(final int n,final int[][] edges) {\\n        int count = 0;\\n        boolean[] visited = new boolean[n];\\n        List<List<Integer>> adj = new ArrayList<>();\\n        buildAdj(n,edges,adj);\\n\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                nodeCountForDFS=0;\\n                edgeCountForDFS=0l;\\n                dfs(i,adj,visited);\\n                // as we have undirected graph\\n                if((nodeCountForDFS*(nodeCountForDFS-1))*1l==edgeCountForDFS){\\n                    count++;\\n                    // System.out.println(nodeCountForDFS+\"\"+edgeCountForDFS);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void buildAdj(int n,final int[][] edges,List<List<Integer>> adj){\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] e:edges){\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n    }\\n\\n    private void dfs(final int p,final List<List<Integer>> adj,boolean[] visited){\\n        visited[p] = true;\\n        nodeCountForDFS++;\\n        for(int c:adj.get(p)){\\n            edgeCountForDFS++;\\n            if(!visited[c]){\\n                visited[c] = true;\\n                dfs(c,adj,visited);\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int nodeCountForDFS = 0;\\n    long edgeCountForDFS = 0l;\\n\\n    // TC: O(V+E)\\n    // SC: O(V)\\n    public int countCompleteComponents(final int n,final int[][] edges) {\\n        int count = 0;\\n        boolean[] visited = new boolean[n];\\n        List<List<Integer>> adj = new ArrayList<>();\\n        buildAdj(n,edges,adj);\\n\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                nodeCountForDFS=0;\\n                edgeCountForDFS=0l;\\n                dfs(i,adj,visited);\\n                // as we have undirected graph\\n                if((nodeCountForDFS*(nodeCountForDFS-1))*1l==edgeCountForDFS){\\n                    count++;\\n                    // System.out.println(nodeCountForDFS+\"\"+edgeCountForDFS);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void buildAdj(int n,final int[][] edges,List<List<Integer>> adj){\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] e:edges){\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n    }\\n\\n    private void dfs(final int p,final List<List<Integer>> adj,boolean[] visited){\\n        visited[p] = true;\\n        nodeCountForDFS++;\\n        for(int c:adj.get(p)){\\n            edgeCountForDFS++;\\n            if(!visited[c]){\\n                visited[c] = true;\\n                dfs(c,adj,visited);\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848704,
                "title": "java-using-bfs-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean ans(List<List<Integer>> al,int n,boolean v[],int i,int s){\\n        Deque<Integer> q=new ArrayDeque();\\n        q.addLast(i);\\n        //boolean b=true;\\n        Set<Integer> hs=new HashSet<>();\\n        hs.add(i);\\n        while(q.size()!=0){\\n            int curr=q.getFirst();\\n            q.removeFirst();\\n            v[curr]=true;\\n            for(int ele:al.get(curr)){\\n                if(v[ele]==false){\\n                    q.addLast(ele);\\n                    v[ele]=true;\\n                    hs.add(ele);\\n                    //if(al.get(ele).size()!=s) b=false;\\n                }\\n            }\\n        }\\n        for(int k:hs){\\n            if(al.get(k).size()!=hs.size()-1) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> al=new ArrayList<>();\\n            for(int i=0;i<=n;i++){\\n                List<Integer> l=new ArrayList<>();\\n                al.add(l);\\n            }\\n            for(int i=0;i<edges.length;i++){\\n                    al.get(edges[i][0]).add(edges[i][1]);\\n                    al.get(edges[i][1]).add(edges[i][0]);\\n            }\\n            boolean v[]=new boolean[n];\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i]==false){\\n                v[i]=true;\\n                boolean b=ans(al,n,v,i,al.get(i).size());\\n                System.out.println(b+\" \"+i);\\n                if(b) c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean ans(List<List<Integer>> al,int n,boolean v[],int i,int s){\\n        Deque<Integer> q=new ArrayDeque();\\n        q.addLast(i);\\n        //boolean b=true;\\n        Set<Integer> hs=new HashSet<>();\\n        hs.add(i);\\n        while(q.size()!=0){\\n            int curr=q.getFirst();\\n            q.removeFirst();\\n            v[curr]=true;\\n            for(int ele:al.get(curr)){\\n                if(v[ele]==false){\\n                    q.addLast(ele);\\n                    v[ele]=true;\\n                    hs.add(ele);\\n                    //if(al.get(ele).size()!=s) b=false;\\n                }\\n            }\\n        }\\n        for(int k:hs){\\n            if(al.get(k).size()!=hs.size()-1) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>> al=new ArrayList<>();\\n            for(int i=0;i<=n;i++){\\n                List<Integer> l=new ArrayList<>();\\n                al.add(l);\\n            }\\n            for(int i=0;i<edges.length;i++){\\n                    al.get(edges[i][0]).add(edges[i][1]);\\n                    al.get(edges[i][1]).add(edges[i][0]);\\n            }\\n            boolean v[]=new boolean[n];\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i]==false){\\n                v[i]=true;\\n                boolean b=ans(al,n,v,i,al.get(i).size());\\n                System.out.println(b+\" \"+i);\\n                if(b) c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846494,
                "title": "c-easy-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void t(int i,int n,vector<int>& v,vector<vector<int>>& a,vector<int>& r)\\n    {\\n        v[i]=1;\\n        r.push_back(i);\\n        for(auto j: a[i])\\n        {\\n            if(!v[j])\\n                t(j,n,v,a,r);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        int c=0;\\n        vector<vector<int>> a(n);\\n        for(auto i: e)\\n        a[i[0]].push_back(i[1]),a[i[1]].push_back(i[0]);\\n        \\n        vector<int> v(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> r;\\n            if(!v[i])\\n            {\\n            bool b=1;    \\n            t(i,n,v,a,r); \\n            for(auto x: r)\\n             for(auto y: r)\\n              if(find(a[x].begin(),a[x].end(),y)==a[x].end() && x!=y) {\\n                  b=0;break;\\n              }\\n            if(b) \\n            c++;  \\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void t(int i,int n,vector<int>& v,vector<vector<int>>& a,vector<int>& r)\\n    {\\n        v[i]=1;\\n        r.push_back(i);\\n        for(auto j: a[i])\\n        {\\n            if(!v[j])\\n                t(j,n,v,a,r);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        int c=0;\\n        vector<vector<int>> a(n);\\n        for(auto i: e)\\n        a[i[0]].push_back(i[1]),a[i[1]].push_back(i[0]);\\n        \\n        vector<int> v(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> r;\\n            if(!v[i])\\n            {\\n            bool b=1;    \\n            t(i,n,v,a,r); \\n            for(auto x: r)\\n             for(auto y: r)\\n              if(find(a[x].begin(),a[x].end(),y)==a[x].end() && x!=y) {\\n                  b=0;break;\\n              }\\n            if(b) \\n            c++;  \\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844628,
                "title": "using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int cnt=0;\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int edge[]:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n\\n        boolean[] vis=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                cnt++;\\n               int tmp=dfs(i,vis,adj);\\n               System.out.println(tmp);\\n               if(!check(i,adj,new boolean[n],tmp))cnt--;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    public boolean check(int i,List<List<Integer>> adj,boolean vis[],int tmp){\\n        vis[i]=true;\\n        if(adj.get(i).size()!=tmp-1)return false;\\n        boolean ans=true;\\n        for(int neigh : adj.get(i)){\\n            if(!vis[neigh])\\n                ans&=check(neigh,adj,vis,tmp);\\n        }\\n        return ans;  \\n    }\\n\\n    public int dfs(int i,boolean[] vis,List<List<Integer>> adj){\\n        vis[i]=true;\\n        int tmp=1;\\n        for(int neigh : adj.get(i)){\\n            if(!vis[neigh]){\\n               tmp+=dfs(neigh,vis,adj);\\n            }\\n        }\\n        return tmp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        int cnt=0;\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int edge[]:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n\\n        boolean[] vis=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                cnt++;\\n               int tmp=dfs(i,vis,adj);\\n               System.out.println(tmp);\\n               if(!check(i,adj,new boolean[n],tmp))cnt--;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    public boolean check(int i,List<List<Integer>> adj,boolean vis[],int tmp){\\n        vis[i]=true;\\n        if(adj.get(i).size()!=tmp-1)return false;\\n        boolean ans=true;\\n        for(int neigh : adj.get(i)){\\n            if(!vis[neigh])\\n                ans&=check(neigh,adj,vis,tmp);\\n        }\\n        return ans;  \\n    }\\n\\n    public int dfs(int i,boolean[] vis,List<List<Integer>> adj){\\n        vis[i]=true;\\n        int tmp=1;\\n        for(int neigh : adj.get(i)){\\n            if(!vis[neigh]){\\n               tmp+=dfs(neigh,vis,adj);\\n            }\\n        }\\n        return tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838234,
                "title": "simple-java-intuition-beginner-friendly-and-different",
                "content": "# Intuition\\nall the strongly connected components are having same edges as parent \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nits a simple strongly connected components\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(E*V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V*V+V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //classic graph data \\n        int[] visited =  new int[n];\\n\\n        //looping\\n        int len = edges.length;\\n        int[][] arr = new int[n][n];\\n        for(int i=0; i<len; i++){\\n            arr[edges[i][0]][edges[i][1]]=1;\\n            arr[edges[i][1]][edges[i][0]]=1;\\n        }\\n        //so that all the peer have the same elements\\n        for(int i=0; i<n; i++){\\n            arr[i][i]=1;\\n        }\\n\\n        //hey! the logic is here\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            if(visited[i]==0){\\n                if(dfsCheck(i,-1,arr,visited)==1) res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static int dfsCheck( int curr, int parent, int[][] arr, int[] visited){\\n        if(visited[curr]==1) return 1;\\n        else if(visited[curr]==2) return 2;\\n        //check parent with all the elements in the current vertix\\n        if(parent!=-1){\\n            for(int i=0; i<arr.length; i++){\\n                if(arr[curr][i]!=arr[parent][i]){\\n                    visited[curr]=2;\\n                    return visited[curr];\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0; i<arr.length; i++){\\n                if(arr[curr][i]==1){\\n                    if(dfsCheck(i,curr,arr,visited)==2){\\n                        visited[curr]=2;\\n                        return visited[curr];\\n                    }\\n                }\\n            }\\n        }\\n        visited[curr]=1;\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //classic graph data \\n        int[] visited =  new int[n];\\n\\n        //looping\\n        int len = edges.length;\\n        int[][] arr = new int[n][n];\\n        for(int i=0; i<len; i++){\\n            arr[edges[i][0]][edges[i][1]]=1;\\n            arr[edges[i][1]][edges[i][0]]=1;\\n        }\\n        //so that all the peer have the same elements\\n        for(int i=0; i<n; i++){\\n            arr[i][i]=1;\\n        }\\n\\n        //hey! the logic is here\\n        int res = 0;\\n        for(int i=0; i<n; i++){\\n            if(visited[i]==0){\\n                if(dfsCheck(i,-1,arr,visited)==1) res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static int dfsCheck( int curr, int parent, int[][] arr, int[] visited){\\n        if(visited[curr]==1) return 1;\\n        else if(visited[curr]==2) return 2;\\n        //check parent with all the elements in the current vertix\\n        if(parent!=-1){\\n            for(int i=0; i<arr.length; i++){\\n                if(arr[curr][i]!=arr[parent][i]){\\n                    visited[curr]=2;\\n                    return visited[curr];\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0; i<arr.length; i++){\\n                if(arr[curr][i]==1){\\n                    if(dfsCheck(i,curr,arr,visited)==2){\\n                        visited[curr]=2;\\n                        return visited[curr];\\n                    }\\n                }\\n            }\\n        }\\n        visited[curr]=1;\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835197,
                "title": "java-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>>adj=new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        Queue<Integer>q=new LinkedList<>();\\n        for (int[] i :edges) {\\n            int u=i[0];\\n            int v=i[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        int c=0;\\n        Set<Integer>s=new HashSet<>();\\n        for(int i=0;i<n;i++){\\n            \\n            if(!s.contains(i)){\\n              int ed=0;\\n              int node=0;   \\n              q.add(i);\\n              s.add(i);\\n                while(!q.isEmpty()){\\n                int val=q.poll();\\n                \\n                node++;\\n                for(int v:adj.get(val)){\\n                     ed++;\\n                     if(!s.contains(v)){\\n                          s.add(v);\\n                          \\n                          q.add(v);\\n                     }\\n                     \\n                     \\n                } \\n            }\\n             \\n             \\n            if(ed/2==node*(node-1)/2){\\n                c++;\\n            }\\n\\n            }\\n           \\n            \\n             \\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        List<List<Integer>>adj=new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        Queue<Integer>q=new LinkedList<>();\\n        for (int[] i :edges) {\\n            int u=i[0];\\n            int v=i[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        int c=0;\\n        Set<Integer>s=new HashSet<>();\\n        for(int i=0;i<n;i++){\\n            \\n            if(!s.contains(i)){\\n              int ed=0;\\n              int node=0;   \\n              q.add(i);\\n              s.add(i);\\n                while(!q.isEmpty()){\\n                int val=q.poll();\\n                \\n                node++;\\n                for(int v:adj.get(val)){\\n                     ed++;\\n                     if(!s.contains(v)){\\n                          s.add(v);\\n                          \\n                          q.add(v);\\n                     }\\n                     \\n                     \\n                } \\n            }\\n             \\n             \\n            if(ed/2==node*(node-1)/2){\\n                c++;\\n            }\\n\\n            }\\n           \\n            \\n             \\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828195,
                "title": "dsu-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst make all the components. Any component is said to be complete iff there is an edge from every vertex of that component to every other vertex.\\nSo, maintain an array of count of edges from each vertex. If the size of the component is say X then there should be X-1 edgeCount for each of the vertex that is present in the component.\\n\\n\\n\\n# Code\\n```\\nclass DSU{\\nprivate:\\n    int N;\\n    vector<int> par,sz,edgeCount;\\n    int Find(int u){\\n        if(par[u]==-1){\\n            return u;\\n        }\\n        return par[u]=Find(par[u]);\\n    }\\n    void Union(int u, int v){\\n        //increament the edgeCount\\n        edgeCount[u]++;\\n        edgeCount[v]++;\\n        int s1 = Find(u);\\n        int s2 = Find(v);\\n        if(s1!=s2){\\n            if(sz[s1]>=sz[s2]){\\n                sz[s1]+=sz[s2];\\n                par[s2]=s1;\\n            }else{\\n                sz[s2]+=sz[s1];\\n                par[s1]=s2;\\n            } \\n        }\\n    }\\n    int getCount(){\\n        int cnt = 0;\\n        vector<int> flag(N,true);\\n        for(int i=0;i<N;i++){\\n            int par = Find(i);\\n            int reqSize = (sz[par]-1);\\n            if(flag[par] and edgeCount[i]!=reqSize){\\n                flag[par]=false;\\n            }\\n        }\\n        for(int i=0;i<N;i++){\\n            if(Find(i)==i and flag[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    DSU(int n){\\n        N = n;\\n        par = vector<int>(n,-1);\\n        sz = vector<int>(n,1);\\n        //edgeCount stores the count of edges from a node\\n        edgeCount = vector<int>(n,0);\\n    }\\n    void getUnion(int u,int v){\\n        Union(u,v);\\n    }\\n    int getCountOfComponents(){\\n        return getCount();\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU* D = new DSU(n);\\n        for(auto &e: edges){\\n            D->getUnion(e[0],e[1]);\\n        }\\n        return D->getCountOfComponents();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\nprivate:\\n    int N;\\n    vector<int> par,sz,edgeCount;\\n    int Find(int u){\\n        if(par[u]==-1){\\n            return u;\\n        }\\n        return par[u]=Find(par[u]);\\n    }\\n    void Union(int u, int v){\\n        //increament the edgeCount\\n        edgeCount[u]++;\\n        edgeCount[v]++;\\n        int s1 = Find(u);\\n        int s2 = Find(v);\\n        if(s1!=s2){\\n            if(sz[s1]>=sz[s2]){\\n                sz[s1]+=sz[s2];\\n                par[s2]=s1;\\n            }else{\\n                sz[s2]+=sz[s1];\\n                par[s1]=s2;\\n            } \\n        }\\n    }\\n    int getCount(){\\n        int cnt = 0;\\n        vector<int> flag(N,true);\\n        for(int i=0;i<N;i++){\\n            int par = Find(i);\\n            int reqSize = (sz[par]-1);\\n            if(flag[par] and edgeCount[i]!=reqSize){\\n                flag[par]=false;\\n            }\\n        }\\n        for(int i=0;i<N;i++){\\n            if(Find(i)==i and flag[i]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    DSU(int n){\\n        N = n;\\n        par = vector<int>(n,-1);\\n        sz = vector<int>(n,1);\\n        //edgeCount stores the count of edges from a node\\n        edgeCount = vector<int>(n,0);\\n    }\\n    void getUnion(int u,int v){\\n        Union(u,v);\\n    }\\n    int getCountOfComponents(){\\n        return getCount();\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU* D = new DSU(n);\\n        for(auto &e: edges){\\n            D->getUnion(e[0],e[1]);\\n        }\\n        return D->getCountOfComponents();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826842,
                "title": "count-the-number-of-complete-components-degree-hashset",
                "content": "A **connected component** is a subgraph of a graph in which there exists **a path between any two vertices**, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.\\n\\nThen in every single component of a graph the degree of every vertex in that component must be **one less then size of the component**\\n\\n# Code\\n```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        int deg[]=new int[n];\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        int vis[]=new int[n];\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0)\\n            {\\n                Set<Integer> hs=new HashSet<>();\\n                dfs(i,adj,vis,hs);\\n                int size=hs.size();\\n                int temp=0;\\n                for(int it:hs)\\n                {\\n                    if(size-1==deg[it])\\n                    {\\n                        temp++;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(temp==size)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int s,ArrayList<ArrayList<Integer>> adj,int[] vis,Set<Integer> hs)\\n    {\\n        vis[s]=1;\\n        hs.add(s);\\n        for(int it:adj.get(s))\\n        {\\n            if(vis[it]==0)\\n            {\\n                dfs(it,adj,vis,hs);\\n            }\\n        }\\n        return ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        int deg[]=new int[n];\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        int vis[]=new int[n];\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0)\\n            {\\n                Set<Integer> hs=new HashSet<>();\\n                dfs(i,adj,vis,hs);\\n                int size=hs.size();\\n                int temp=0;\\n                for(int it:hs)\\n                {\\n                    if(size-1==deg[it])\\n                    {\\n                        temp++;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(temp==size)\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int s,ArrayList<ArrayList<Integer>> adj,int[] vis,Set<Integer> hs)\\n    {\\n        vis[s]=1;\\n        hs.add(s);\\n        for(int it:adj.get(s))\\n        {\\n            if(vis[it]==0)\\n            {\\n                dfs(it,adj,vis,hs);\\n            }\\n        }\\n        return ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825484,
                "title": "o-v-e-solution-beats-100",
                "content": "Use dfs to count the no. of edges and vertices of a component and then check if it is complete graph or not , if it is complete graph then increment the count of components otherwise not. \\n# Code\\n```\\nclass Solution:\\n  def __init__(self):\\n    self.mark = []\\n    self.g = [] \\n    self.eds = 0 \\n    self.nodes = 0 \\n\\n  def dfs(self, x:int, degree:int):\\n    self.mark[x] = True \\n    self.nodes += 1 \\n    for i in self.g[x]:\\n      if not self.mark[i]:\\n        self.dfs(i,degree) \\n      self.eds+=1\\n      \\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n    self.g = [[] for _ in range(n)] \\n    self.mark = [False  for _ in range(n)] \\n    ans = 0 \\n    for i in edges: \\n      x = i[0]\\n      y = i[1] \\n      self.g[x].append(y)\\n      self.g[y].append(x) \\n      \\n    for i in range(0,n):\\n      if not self.mark[i]:\\n        self.eds = 0 \\n        self.nodes = 0 \\n        self.dfs(i, len(self.g[i])) \\n        if (self.nodes - 1)*self.nodes == self.eds:\\n          ans+=1\\n        \\n    return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def __init__(self):\\n    self.mark = []\\n    self.g = [] \\n    self.eds = 0 \\n    self.nodes = 0 \\n\\n  def dfs(self, x:int, degree:int):\\n    self.mark[x] = True \\n    self.nodes += 1 \\n    for i in self.g[x]:\\n      if not self.mark[i]:\\n        self.dfs(i,degree) \\n      self.eds+=1\\n      \\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n    self.g = [[] for _ in range(n)] \\n    self.mark = [False  for _ in range(n)] \\n    ans = 0 \\n    for i in edges: \\n      x = i[0]\\n      y = i[1] \\n      self.g[x].append(y)\\n      self.g[y].append(x) \\n      \\n    for i in range(0,n):\\n      if not self.mark[i]:\\n        self.eds = 0 \\n        self.nodes = 0 \\n        self.dfs(i, len(self.g[i])) \\n        if (self.nodes - 1)*self.nodes == self.eds:\\n          ans+=1\\n        \\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823157,
                "title": "super-simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind out the no. of nodes and the no. of edges in all the components.\\nIf in a component, edges >= nodes*(nodes-1), it is a complete connected component.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse DFS to keep track of no. of edges and nodes in every component.\\n\\n# Complexity\\n- Time complexity: O(V + E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int src, vector<vector<int>>& adj, vector<int>& vis, int& nodes, int& edges){\\n        vis[src] = 1;\\n        nodes++;\\n        for(auto it: adj[src]){\\n            edges++;\\n            if(!vis[it]){\\n                dfs(it, adj, vis, nodes, edges);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        vector<vector<int>> adj(n);\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int nodes = 0, eges = 0;\\n        for(int i=0; i<n; i++){\\n            if(!vis[i]){\\n                dfs(i, adj, vis, nodes, eges);\\n                cout<<nodes<<\" \"<<eges<<endl;\\n                if(eges >= nodes*(nodes-1)) ans++;\\n                nodes = 0;\\n                eges = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int src, vector<vector<int>>& adj, vector<int>& vis, int& nodes, int& edges){\\n        vis[src] = 1;\\n        nodes++;\\n        for(auto it: adj[src]){\\n            edges++;\\n            if(!vis[it]){\\n                dfs(it, adj, vis, nodes, edges);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        int ans = 0;\\n        vector<int> vis(n, 0);\\n        vector<vector<int>> adj(n);\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int nodes = 0, eges = 0;\\n        for(int i=0; i<n; i++){\\n            if(!vis[i]){\\n                dfs(i, adj, vis, nodes, eges);\\n                cout<<nodes<<\" \"<<eges<<endl;\\n                if(eges >= nodes*(nodes-1)) ans++;\\n                nodes = 0;\\n                eges = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3820511,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThough this might not be a best solution but I had this in my mind when I tried to solve this. There might other better approches, even I will try to look for it, but now lets check this.\\n\\nSo the idea here is if we check the numbers of nodes any vertex is connected to and also insert them in an set, and then check all those nodes if they connected to the same(hence same size also) vertexes or not.\\nAfter exploring one Node, we will traverse it and mark all the connected as visited true. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is little complicated code to explain for me. \\n\\n**Step 1 :** create 2d vector for graph (here g);\\n**Step 2 :** build up an undirected graph\\n**Step 3 :** initialze count to 0, create set and visited vector to all false.\\n**Step 4 :** iterate through all the nodes if not visited.\\n**Step 5 :** insert it in set, then insert all the nodes connected with it in that set.\\n**Step 6 :** for temprary purpose intialize the flag with value true for every iteration of not visited nodes.\\n**Step 7 :** Now iterate through all the nodes and if the size of it is same as set(exclude the index i \\'of iteration\\', hence s.size()-1) and also that size should match with size of the very first node connection (for index i).\\n**Step 8 :** if the all the elements are present in the set and also step 7 is correct then all good, else set flag false;\\n**Step 9 :** if flag is true increment count because this the complete component.\\n**Step 10 :** now considering the ith index as source, traverse the graph and mark all the visited nodes.\\n**Step 11 :** clear the set and go for the next iteration of the loop.\\n**Step 12 :** return count. \\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n***Let me know if anything wrong in this solution***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int s, vector<vector<int>>& g, vector<bool>& visited){\\n        if(!visited[s]){\\n            visited[s] = true;\\n            for(int i = 0; i < g[s].size(); ++i)\\n                dfs( g[s][i], g, visited);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        for(auto edge : edges){\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        int count = 0;\\n        set<int> s;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < n; ++i){\\n            if(!visited[i]){\\n                // cout << i << \" \\\\n\";\\n                // visited[i] = true;\\n                s.insert(i);\\n                for(int j = 0; j < g[i].size(); ++j){\\n                    s.insert(g[i][j]);\\n                }\\n                bool flag = true;\\n                for(auto k = s.begin(); k != s.end(); ++k){\\n                    if(!((s.size()-1 == g[*k].size()) && g[*k].size() == g[i].size())){\\n                        flag = false;\\n                        break;\\n                    }\\n                    for(int x = 0; x < g[*k].size(); ++x){\\n                        if(s.find(g[*k][x]) == s.end()){\\n                            flag = false;\\n                            break;\\n                        } \\n                    }\\n                }\\n                if(flag){\\n                    count++;\\n                }\\n                dfs(i, g, visited);\\n                s.clear();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int s, vector<vector<int>>& g, vector<bool>& visited){\\n        if(!visited[s]){\\n            visited[s] = true;\\n            for(int i = 0; i < g[s].size(); ++i)\\n                dfs( g[s][i], g, visited);\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        for(auto edge : edges){\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        int count = 0;\\n        set<int> s;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < n; ++i){\\n            if(!visited[i]){\\n                // cout << i << \" \\\\n\";\\n                // visited[i] = true;\\n                s.insert(i);\\n                for(int j = 0; j < g[i].size(); ++j){\\n                    s.insert(g[i][j]);\\n                }\\n                bool flag = true;\\n                for(auto k = s.begin(); k != s.end(); ++k){\\n                    if(!((s.size()-1 == g[*k].size()) && g[*k].size() == g[i].size())){\\n                        flag = false;\\n                        break;\\n                    }\\n                    for(int x = 0; x < g[*k].size(); ++x){\\n                        if(s.find(g[*k][x]) == s.end()){\\n                            flag = false;\\n                            break;\\n                        } \\n                    }\\n                }\\n                if(flag){\\n                    count++;\\n                }\\n                dfs(i, g, visited);\\n                s.clear();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3820438,
                "title": "easy-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFS and Connected Components\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the connected components of an undirected graph using depth-first search (DFS). For each connected components to be complete, each node of a particular connected components should have edges equal to size of components-1.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int vis[50];\\n    vector<int> graph[51];\\n\\n    void dfs(int node, vector<int>&cc){\\n        vis[node]  = 1;\\n\\n        for(auto child: graph[node]){\\n            if(!vis[child]){\\n                cc.push_back(child);\\n               \\n                dfs(child,cc);\\n            }\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n               \\n\\n                for(int i= 0; i<edges.size(); i++){\\n                    graph[edges[i][0]].push_back(edges[i][1]);\\n                    graph[edges[i][1]].push_back(edges[i][0]);\\n                }\\n\\n                vector<vector<int>> ccs;\\n\\n                int count = 0;\\n\\n                memset(vis,0,sizeof(vis));\\n\\n                bool flag = true;\\n\\n                for(int i=0; i<n;i++){\\n                if(!vis[i]){\\n                vector<int>cc;\\n                cc.push_back(i);\\n                dfs(i,cc);\\n                flag = true;\\n                \\n                for(int j=0; j<cc.size();j++){\\n                    if(graph[cc[j]].size()<cc.size()-1) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n\\n                if(flag != false)count++;                \\n              }\\n              \\n            }\\n\\n            return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[50];\\n    vector<int> graph[51];\\n\\n    void dfs(int node, vector<int>&cc){\\n        vis[node]  = 1;\\n\\n        for(auto child: graph[node]){\\n            if(!vis[child]){\\n                cc.push_back(child);\\n               \\n                dfs(child,cc);\\n            }\\n        }\\n    }\\n\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n               \\n\\n                for(int i= 0; i<edges.size(); i++){\\n                    graph[edges[i][0]].push_back(edges[i][1]);\\n                    graph[edges[i][1]].push_back(edges[i][0]);\\n                }\\n\\n                vector<vector<int>> ccs;\\n\\n                int count = 0;\\n\\n                memset(vis,0,sizeof(vis));\\n\\n                bool flag = true;\\n\\n                for(int i=0; i<n;i++){\\n                if(!vis[i]){\\n                vector<int>cc;\\n                cc.push_back(i);\\n                dfs(i,cc);\\n                flag = true;\\n                \\n                for(int j=0; j<cc.size();j++){\\n                    if(graph[cc[j]].size()<cc.size()-1) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n\\n                if(flag != false)count++;                \\n              }\\n              \\n            }\\n\\n            return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819903,
                "title": "java-union-find-complete-connected-components",
                "content": "# Code\\n```\\nclass DisjointSet {\\n    List<Integer> parent=new ArrayList<>();\\n    List<Integer> rank=new ArrayList<>();\\n    public DisjointSet(int n) {\\n        for(int i=0;i<=n-1;++i) {\\n            parent.add(i);\\n            rank.add(0);\\n        }\\n    }\\n    public int findUPar(int node) {\\n        if(node==parent.get(node)) {\\n            return node;\\n        }\\n        int ulp_node=findUPar(parent.get(node));\\n        parent.set(node,ulp_node);\\n        return parent.get(node);\\n    }\\n    public void unionByRank(int u,int v) {\\n        int ulp_u=findUPar(u);\\n        int ulp_v=findUPar(v);\\n        if(ulp_u==ulp_v) {\\n            return;\\n        }\\n        if(rank.get(ulp_u)>rank.get(ulp_v)) {\\n            parent.set(ulp_v,ulp_u);\\n        }\\n        else if(rank.get(ulp_v)>rank.get(ulp_u)) {\\n            parent.set(ulp_u,ulp_v);\\n        }\\n        else {\\n            parent.set(ulp_v,ulp_u);\\n            int rankU=rank.get(ulp_u);\\n            rank.set(ulp_u,rankU+1);\\n        }\\n    }\\n}\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        // T.C. -> O(n*n+edges.length+n+n)\\n        // A.S. -> O(n*n+3*n+n)\\n        \\n        int[][] adjm=new int[n][n];\\n        for(int i=0;i<=n-1;++i) {\\n            for(int j=0;j<=n-1;++j) {\\n                adjm[i][j]=0;\\n            }\\n        }\\n        int m=edges.length;\\n        DisjointSet ds=new DisjointSet(n);\\n        for(int i=0;i<=m-1;++i) {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adjm[u][v]=1;\\n            adjm[v][u]=1;\\n            int ulp_u=ds.findUPar(u);\\n            int ulp_v=ds.findUPar(v);\\n            if(ulp_u!=ulp_v) {\\n                ds.unionByRank(u,v);\\n            }\\n        }\\n        Map<Integer,List<Integer>> mp=new HashMap<>();\\n        for(int i=0;i<=n-1;++i) {\\n            int ulp_i=ds.findUPar(i);\\n            if(mp.containsKey(ulp_i)!=true) {\\n                List<Integer> l=new ArrayList<>();\\n                l.add(i);\\n                mp.put(ulp_i,l);\\n            }\\n            else {\\n                List<Integer> l=mp.get(ulp_i);\\n                l.add(i);\\n                mp.put(ulp_i,l);\\n            }\\n        }\\n        int ans=0;\\n        for(Map.Entry<Integer,List<Integer>> p:mp.entrySet()) {\\n            List<Integer> l=p.getValue();\\n            boolean f=true;\\n            for(int i:l) {\\n                for(int j:l) {\\n                    if(i!=j) {\\n                        if(adjm[i][j]!=1) {\\n                            f=false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(f!=true) {\\n                    break;\\n                }\\n            }\\n            if(f==true) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DisjointSet {\\n    List<Integer> parent=new ArrayList<>();\\n    List<Integer> rank=new ArrayList<>();\\n    public DisjointSet(int n) {\\n        for(int i=0;i<=n-1;++i) {\\n            parent.add(i);\\n            rank.add(0);\\n        }\\n    }\\n    public int findUPar(int node) {\\n        if(node==parent.get(node)) {\\n            return node;\\n        }\\n        int ulp_node=findUPar(parent.get(node));\\n        parent.set(node,ulp_node);\\n        return parent.get(node);\\n    }\\n    public void unionByRank(int u,int v) {\\n        int ulp_u=findUPar(u);\\n        int ulp_v=findUPar(v);\\n        if(ulp_u==ulp_v) {\\n            return;\\n        }\\n        if(rank.get(ulp_u)>rank.get(ulp_v)) {\\n            parent.set(ulp_v,ulp_u);\\n        }\\n        else if(rank.get(ulp_v)>rank.get(ulp_u)) {\\n            parent.set(ulp_u,ulp_v);\\n        }\\n        else {\\n            parent.set(ulp_v,ulp_u);\\n            int rankU=rank.get(ulp_u);\\n            rank.set(ulp_u,rankU+1);\\n        }\\n    }\\n}\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        \\n        // T.C. -> O(n*n+edges.length+n+n)\\n        // A.S. -> O(n*n+3*n+n)\\n        \\n        int[][] adjm=new int[n][n];\\n        for(int i=0;i<=n-1;++i) {\\n            for(int j=0;j<=n-1;++j) {\\n                adjm[i][j]=0;\\n            }\\n        }\\n        int m=edges.length;\\n        DisjointSet ds=new DisjointSet(n);\\n        for(int i=0;i<=m-1;++i) {\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            adjm[u][v]=1;\\n            adjm[v][u]=1;\\n            int ulp_u=ds.findUPar(u);\\n            int ulp_v=ds.findUPar(v);\\n            if(ulp_u!=ulp_v) {\\n                ds.unionByRank(u,v);\\n            }\\n        }\\n        Map<Integer,List<Integer>> mp=new HashMap<>();\\n        for(int i=0;i<=n-1;++i) {\\n            int ulp_i=ds.findUPar(i);\\n            if(mp.containsKey(ulp_i)!=true) {\\n                List<Integer> l=new ArrayList<>();\\n                l.add(i);\\n                mp.put(ulp_i,l);\\n            }\\n            else {\\n                List<Integer> l=mp.get(ulp_i);\\n                l.add(i);\\n                mp.put(ulp_i,l);\\n            }\\n        }\\n        int ans=0;\\n        for(Map.Entry<Integer,List<Integer>> p:mp.entrySet()) {\\n            List<Integer> l=p.getValue();\\n            boolean f=true;\\n            for(int i:l) {\\n                for(int j:l) {\\n                    if(i!=j) {\\n                        if(adjm[i][j]!=1) {\\n                            f=false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(f!=true) {\\n                    break;\\n                }\\n            }\\n            if(f==true) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817413,
                "title": "dfs-count-nodes-and-edges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Edge{\\n        int src;\\n        int dest;\\n\\n        public Edge(int s, int d){\\n            this.src = s;\\n            this.dest = d;\\n        }\\n    }\\n    \\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //create a graph\\n        List<Edge> graph[] = new ArrayList[n];\\n        for(int i=0; i<n; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int ed[] : edges){\\n            graph[ed[0]].add(new Edge(ed[0], ed[1]));\\n            graph[ed[1]].add(new Edge(ed[1], ed[0]));\\n        }\\n        \\n        boolean vis[] = new boolean[n];\\n        List<int[]> components = new ArrayList<>();\\n        //components at 0 will be edges and at 1 will be nodes\\n        \\n        for(int i=0; i<n; i++){\\n            int arr[] = new int[2];\\n            if(!vis[i]){                \\n                dfs(graph, vis, i, arr);\\n                components.add(arr); \\n            }                 \\n        }\\n\\n        int compo = 0; //calculate components using formula m*(m-1)/2\\n        for(int i=0; i<components.size(); i++){\\n            int temp[] = components.get(i);\\n            int edge = temp[1]/2;\\n            int nodes = temp[0];\\n            int cal = (nodes * (nodes-1))/2;\\n            if(edge == cal){\\n                compo++;\\n            }\\n        }\\n        return compo;\\n    }\\n    private void dfs(List<Edge> graph[], boolean vis[], int curr, int arr[]){\\n        vis[curr] = true;\\n        arr[0]++; //nodes increment\\n        for(int i=0; i<graph[curr].size(); i++){\\n            Edge e = graph[curr].get(i);\\n            arr[1]++; //edges increment\\n            if(!vis[e.dest]){                \\n                dfs(graph, vis, e.dest, arr);\\n            }            \\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Edge{\\n        int src;\\n        int dest;\\n\\n        public Edge(int s, int d){\\n            this.src = s;\\n            this.dest = d;\\n        }\\n    }\\n    \\n    public int countCompleteComponents(int n, int[][] edges) {\\n        //create a graph\\n        List<Edge> graph[] = new ArrayList[n];\\n        for(int i=0; i<n; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int ed[] : edges){\\n            graph[ed[0]].add(new Edge(ed[0], ed[1]));\\n            graph[ed[1]].add(new Edge(ed[1], ed[0]));\\n        }\\n        \\n        boolean vis[] = new boolean[n];\\n        List<int[]> components = new ArrayList<>();\\n        //components at 0 will be edges and at 1 will be nodes\\n        \\n        for(int i=0; i<n; i++){\\n            int arr[] = new int[2];\\n            if(!vis[i]){                \\n                dfs(graph, vis, i, arr);\\n                components.add(arr); \\n            }                 \\n        }\\n\\n        int compo = 0; //calculate components using formula m*(m-1)/2\\n        for(int i=0; i<components.size(); i++){\\n            int temp[] = components.get(i);\\n            int edge = temp[1]/2;\\n            int nodes = temp[0];\\n            int cal = (nodes * (nodes-1))/2;\\n            if(edge == cal){\\n                compo++;\\n            }\\n        }\\n        return compo;\\n    }\\n    private void dfs(List<Edge> graph[], boolean vis[], int curr, int arr[]){\\n        vis[curr] = true;\\n        arr[0]++; //nodes increment\\n        for(int i=0; i<graph[curr].size(); i++){\\n            Edge e = graph[curr].get(i);\\n            arr[1]++; //edges increment\\n            if(!vis[e.dest]){                \\n                dfs(graph, vis, e.dest, arr);\\n            }            \\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813968,
                "title": "c-solution-dfs-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(N) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        // Get Adjacency List\\n        IList<IList<int>> adj = GetAdj(n, edges);\\n        int count = 0;\\n        \\n        // Stores Considered Nodes\\n        HashSet<int> considered = new HashSet<int>();\\n\\n        for(int i=0; i<n; i++){\\n            if(considered.Contains(i)){\\n                continue;\\n            }\\n\\n            HashSet<int> graphNodes = new();\\n            GetConnectedGraphNodes(adj, i, graphNodes);\\n            int edgesCount = graphNodes.Count - 1;\\n            bool isConnected = true;\\n\\n            foreach(var node in graphNodes){\\n                considered.Add(node);\\n\\n                if(adj[node].Count != edgesCount){\\n                    isConnected = false;\\n                }\\n            }\\n\\n            if(isConnected){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void GetConnectedGraphNodes(IList<IList<int>> adj, int currentNode, HashSet<int> graphNodes){\\n        if(graphNodes.Contains(currentNode)){\\n            return;\\n        }\\n\\n        graphNodes.Add(currentNode);\\n\\n        foreach(var childNode in  adj[currentNode]){\\n            GetConnectedGraphNodes(adj, childNode, graphNodes);\\n        }\\n    }\\n\\n    private IList<IList<int>> GetAdj(int n, int[][] edges){\\n        IList<IList<int>> adj = new List<IList<int>>();\\n\\n        for(int i=0; i<n; i++){\\n            adj.Add(new List<int>());\\n        }\\n\\n        foreach(var edge in edges){\\n            adj[edge[0]].Add(edge[1]);\\n            adj[edge[1]].Add(edge[0]);\\n        }\\n\\n        return adj;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountCompleteComponents(int n, int[][] edges) {\\n        // Get Adjacency List\\n        IList<IList<int>> adj = GetAdj(n, edges);\\n        int count = 0;\\n        \\n        // Stores Considered Nodes\\n        HashSet<int> considered = new HashSet<int>();\\n\\n        for(int i=0; i<n; i++){\\n            if(considered.Contains(i)){\\n                continue;\\n            }\\n\\n            HashSet<int> graphNodes = new();\\n            GetConnectedGraphNodes(adj, i, graphNodes);\\n            int edgesCount = graphNodes.Count - 1;\\n            bool isConnected = true;\\n\\n            foreach(var node in graphNodes){\\n                considered.Add(node);\\n\\n                if(adj[node].Count != edgesCount){\\n                    isConnected = false;\\n                }\\n            }\\n\\n            if(isConnected){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void GetConnectedGraphNodes(IList<IList<int>> adj, int currentNode, HashSet<int> graphNodes){\\n        if(graphNodes.Contains(currentNode)){\\n            return;\\n        }\\n\\n        graphNodes.Add(currentNode);\\n\\n        foreach(var childNode in  adj[currentNode]){\\n            GetConnectedGraphNodes(adj, childNode, graphNodes);\\n        }\\n    }\\n\\n    private IList<IList<int>> GetAdj(int n, int[][] edges){\\n        IList<IList<int>> adj = new List<IList<int>>();\\n\\n        for(int i=0; i<n; i++){\\n            adj.Add(new List<int>());\\n        }\\n\\n        foreach(var edge in edges){\\n            adj[edge[0]].Add(edge[1]);\\n            adj[edge[1]].Add(edge[0]);\\n        }\\n\\n        return adj;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812270,
                "title": "elegent-dfs-approach",
                "content": "# Approach\\n- First get all the connected components & then check if those connected components are complete or not.\\n\\n# Complexity\\n- Time complexity:\\nO(N) + O(C^3) Where N is number of vertex & c is number of connected components\\n\\n- Space complexity:\\nO(3N)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    HashSet<int>[] adjList;\\n    bool[] isSeen;\\n    IList<IList<int>> ltComponents;\\n\\n    public int CountCompleteComponents(int n, int[][] edges)\\n    {\\n        adjList = new HashSet<int>[n];\\n        isSeen = new bool[n];\\n        ltComponents = new List<IList<int>>();\\n        for (int i = 0; i < n; i++)\\n            adjList[i] = new HashSet<int>();\\n\\n        //Prepare adjList\\n        foreach (int[] edge in edges)\\n        {\\n            adjList[edge[0]].Add(edge[1]);\\n            adjList[edge[1]].Add(edge[0]);\\n        }\\n\\n        //Get the number of connected components & nodes in them\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (isSeen[i])\\n                continue;\\n\\n            List<int> ltComp = new List<int>();\\n            DFS(i, ltComp);\\n            ltComponents.Add(ltComp);\\n        }\\n\\n        //Check which components are complete\\n        int completeComponents = 0;\\n        foreach (IList<int> component in ltComponents)\\n        {\\n            int verticesCount = component.Count;\\n            bool consider = true;\\n\\n            foreach (int vertex in component)\\n            {\\n                var adjNds = adjList[vertex];\\n                if (adjNds.Count != verticesCount - 1)\\n                {\\n                    consider = false;\\n                    break;\\n                }\\n\\n                foreach (int element in component)\\n                {\\n                    if (element == vertex)\\n                        continue;\\n\\n                    if (!adjNds.Contains(element))\\n                    {\\n                        consider = false;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (consider)\\n                ++completeComponents;\\n        }\\n\\n        return completeComponents;\\n    }\\n\\n    private void DFS(int node, IList<int> ltComp)\\n    {\\n        if (isSeen[node])\\n            return;\\n\\n        isSeen[node] = true;\\n        ltComp.Add(node);\\n\\n        var adjNodes = adjList[node];\\n        foreach (int nd in adjNodes)\\n            DFS(nd, ltComp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic class Solution\\n{\\n    HashSet<int>[] adjList;\\n    bool[] isSeen;\\n    IList<IList<int>> ltComponents;\\n\\n    public int CountCompleteComponents(int n, int[][] edges)\\n    {\\n        adjList = new HashSet<int>[n];\\n        isSeen = new bool[n];\\n        ltComponents = new List<IList<int>>();\\n        for (int i = 0; i < n; i++)\\n            adjList[i] = new HashSet<int>();\\n\\n        //Prepare adjList\\n        foreach (int[] edge in edges)\\n        {\\n            adjList[edge[0]].Add(edge[1]);\\n            adjList[edge[1]].Add(edge[0]);\\n        }\\n\\n        //Get the number of connected components & nodes in them\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (isSeen[i])\\n                continue;\\n\\n            List<int> ltComp = new List<int>();\\n            DFS(i, ltComp);\\n            ltComponents.Add(ltComp);\\n        }\\n\\n        //Check which components are complete\\n        int completeComponents = 0;\\n        foreach (IList<int> component in ltComponents)\\n        {\\n            int verticesCount = component.Count;\\n            bool consider = true;\\n\\n            foreach (int vertex in component)\\n            {\\n                var adjNds = adjList[vertex];\\n                if (adjNds.Count != verticesCount - 1)\\n                {\\n                    consider = false;\\n                    break;\\n                }\\n\\n                foreach (int element in component)\\n                {\\n                    if (element == vertex)\\n                        continue;\\n\\n                    if (!adjNds.Contains(element))\\n                    {\\n                        consider = false;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (consider)\\n                ++completeComponents;\\n        }\\n\\n        return completeComponents;\\n    }\\n\\n    private void DFS(int node, IList<int> ltComp)\\n    {\\n        if (isSeen[node])\\n            return;\\n\\n        isSeen[node] = true;\\n        ltComp.Add(node);\\n\\n        var adjNodes = adjList[node];\\n        foreach (int nd in adjNodes)\\n            DFS(nd, ltComp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799472,
                "title": "c-simple-dfs-connected-component",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<vector<int>>&adj, unordered_set<int>&st, vector<int>&vis)\\n    {\\n        vis[node] = 1;\\n        st.insert(node);\\n        \\n        for(auto j : adj[node])\\n        {\\n            if(!vis[j])\\n            {\\n                dfs(j, adj, st, vis);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int  ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                bool flag = true;\\n                unordered_set<int>st;\\n                dfs(i,adj,st,vis);\\n                int sz = st.size()-1;\\n                for(auto k : st)\\n                {\\n                    if(adj[k].size() != sz)\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag)ans++;\\n                \\n                st.clear();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<vector<int>>&adj, unordered_set<int>&st, vector<int>&vis)\\n    {\\n        vis[node] = 1;\\n        st.insert(node);\\n        \\n        for(auto j : adj[node])\\n        {\\n            if(!vis[j])\\n            {\\n                dfs(j, adj, st, vis);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>vis(n,0);\\n        int  ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                bool flag = true;\\n                unordered_set<int>st;\\n                dfs(i,adj,st,vis);\\n                int sz = st.size()-1;\\n                for(auto k : st)\\n                {\\n                    if(adj[k].size() != sz)\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag)ans++;\\n                \\n                st.clear();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794237,
                "title": "easy-explained-sol-for-newbies",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust a normal bfs or dfs traversal to count the subgraphs.\\n1.Convert the edges into adjacency list for bidirectinal graph.\\n2.Traverse in the graph for every node mark if it is visited.Once the graph is visited completely calculate the vertices and edges at the same time and store it .\\n3.Each time after calculating for a subgraph check if the edges are equal to vertice*(vertices-1)if yeas increment the count.\\n4.Similarly calculate for each graph and check if it is complete.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->TC:-O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> dfs(vector<int> adj[],vector<int>&vis,int node){\\n        vis[node]=1;\\n        int v=1,e=adj[node].size();\\n        for(int x:adj[node]){\\n            if(!vis[x]){\\n              pair<int,int> temp=  dfs(adj,vis,x);\\n              v+=temp.first;\\n              e+=temp.second;\\n            }\\n        }\\n        return {v,e};\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n      vector<int>adj[n];\\n      for(auto x:edges){\\n              adj[x[0]].push_back(x[1]);\\n              adj[x[1]].push_back(x[0]);\\n      }  \\n      vector<int>vis(n,0); \\n      int count=0;\\n      for(int i=0;i<n;i++){\\n          if(!vis[i]){\\n            pair<int,int>tmp=  dfs(adj,vis,i);\\n            int ver=tmp.first;\\n            int edg=tmp.second;\\n            if(ver*(ver-1)==edg){\\n                count++;\\n            }\\n          }\\n      }\\n     return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> dfs(vector<int> adj[],vector<int>&vis,int node){\\n        vis[node]=1;\\n        int v=1,e=adj[node].size();\\n        for(int x:adj[node]){\\n            if(!vis[x]){\\n              pair<int,int> temp=  dfs(adj,vis,x);\\n              v+=temp.first;\\n              e+=temp.second;\\n            }\\n        }\\n        return {v,e};\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n      vector<int>adj[n];\\n      for(auto x:edges){\\n              adj[x[0]].push_back(x[1]);\\n              adj[x[1]].push_back(x[0]);\\n      }  \\n      vector<int>vis(n,0); \\n      int count=0;\\n      for(int i=0;i<n;i++){\\n          if(!vis[i]){\\n            pair<int,int>tmp=  dfs(adj,vis,i);\\n            int ver=tmp.first;\\n            int edg=tmp.second;\\n            if(ver*(ver-1)==edg){\\n                count++;\\n            }\\n          }\\n      }\\n     return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781706,
                "title": "easy-solution-cpp-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing DFS i will count the number of node and edges for each component\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif tot_node*(tot_node-1) == tot_edges(component for corrospoding dfs call) then it is counted in complete component \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*(n-1))// worst case\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*(n-1))+auxiliary space of recursion\\n# Code\\n```\\nclass Solution {\\n    public:\\n    int dfs(int node,vector<vector<int>> &adj, vector<int> &vis,int &edg){\\n        vis[node]=1;\\n      int ct=0;\\n        for(auto it: adj[node]){\\n            edg++;\\n            if(vis[it]!=1) ct+=dfs(it,adj,vis,edg);\\n        }\\n        return ct+1;\\n\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<vector<int>> adj(n);\\n        int m=e.size();\\n        vector<int> vis(n,0);\\n        int ans=0;\\n        for(int i=0; i<m; i++){\\n            adj[e[i][0]].push_back(e[i][1]);\\n            adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(vis[i]!=1){ \\n                int tot_edg=0;\\n                int tot_node=dfs(i,adj,vis,tot_edg);\\n                if(tot_edg==(tot_node*(tot_node-1))) ans++;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    int dfs(int node,vector<vector<int>> &adj, vector<int> &vis,int &edg){\\n        vis[node]=1;\\n      int ct=0;\\n        for(auto it: adj[node]){\\n            edg++;\\n            if(vis[it]!=1) ct+=dfs(it,adj,vis,edg);\\n        }\\n        return ct+1;\\n\\n    }\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<vector<int>> adj(n);\\n        int m=e.size();\\n        vector<int> vis(n,0);\\n        int ans=0;\\n        for(int i=0; i<m; i++){\\n            adj[e[i][0]].push_back(e[i][1]);\\n            adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        for(int i=0; i<n; i++){\\n            if(vis[i]!=1){ \\n                int tot_edg=0;\\n                int tot_node=dfs(i,adj,vis,tot_edg);\\n                if(tot_edg==(tot_node*(tot_node-1))) ans++;   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781618,
                "title": "dfs-solution-count-edges-and-nodes",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int nodes, edge;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int edge[] : edges) {\\n            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\\n            graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(edge[0]);\\n        }\\n        int ans = 0;\\n        boolean visited[] = new boolean[n];\\n        for (int i = 0 ; i < n ; i ++) {\\n            nodes = 0;\\n            edge = 0;\\n            if (visited[i])\\n                continue;\\n            \\n            dfs(graph,  visited, i);\\n            if ((nodes * (nodes - 1)) == edge)\\n                ans++;\\n            //System.out.println(nodes + \" \" + edge);\\n            int nodes = 0, edge = 0;\\n            visited[i] = true;\\n        }\\n        return ans;\\n    }\\n\\n    public void dfs (Map<Integer, List<Integer>> graph,  boolean visited [], int currNode) {\\n        if (visited[currNode])\\n            return;\\n        visited[currNode] = true;\\n        nodes++;\\n        for (Integer node : graph.getOrDefault(currNode, new ArrayList<>())) {\\n            edge++;\\n            dfs(graph, visited, node);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int nodes, edge;\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int edge[] : edges) {\\n            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);\\n            graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(edge[0]);\\n        }\\n        int ans = 0;\\n        boolean visited[] = new boolean[n];\\n        for (int i = 0 ; i < n ; i ++) {\\n            nodes = 0;\\n            edge = 0;\\n            if (visited[i])\\n                continue;\\n            \\n            dfs(graph,  visited, i);\\n            if ((nodes * (nodes - 1)) == edge)\\n                ans++;\\n            //System.out.println(nodes + \" \" + edge);\\n            int nodes = 0, edge = 0;\\n            visited[i] = true;\\n        }\\n        return ans;\\n    }\\n\\n    public void dfs (Map<Integer, List<Integer>> graph,  boolean visited [], int currNode) {\\n        if (visited[currNode])\\n            return;\\n        visited[currNode] = true;\\n        nodes++;\\n        for (Integer node : graph.getOrDefault(currNode, new ArrayList<>())) {\\n            edge++;\\n            dfs(graph, visited, node);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778615,
                "title": "c-easy-colution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void prepareList(unordered_map<int,set<int>>&adj,vector<vector<int>>& edges){\\n\\n        for(int i = 0; i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n\\n    }\\n    void dfs(int i,unordered_map<int,bool>&visited,vector<int>&component,unordered_map<int,set<int>>&adj){\\n        if(visited[i]) return;\\n\\n        visited[i] = true;\\n        component.push_back(i);\\n\\n        for(auto &it: adj[i]){\\n            dfs(it,visited,component,adj);\\n        }\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,set<int>>adj;\\n        unordered_map<int,bool>visited;\\n\\n        prepareList(adj,edges);\\n\\n        int count = 0;\\n\\n        for(int i = 0; i<n;i++){\\n            if(!visited[i]){\\n                vector<int>nodes;\\n\\n                dfs(i,visited,nodes,adj);\\n                int res = 0; \\n                for(int j = 0; j<nodes.size();j++){\\n                    if(adj[nodes[j]].size() >= nodes.size()-1) res++;\\n                }\\n\\n                if(res == nodes.size()) count++;\\n\\n            }\\n        }\\n       return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void prepareList(unordered_map<int,set<int>>&adj,vector<vector<int>>& edges){\\n\\n        for(int i = 0; i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n\\n    }\\n    void dfs(int i,unordered_map<int,bool>&visited,vector<int>&component,unordered_map<int,set<int>>&adj){\\n        if(visited[i]) return;\\n\\n        visited[i] = true;\\n        component.push_back(i);\\n\\n        for(auto &it: adj[i]){\\n            dfs(it,visited,component,adj);\\n        }\\n\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,set<int>>adj;\\n        unordered_map<int,bool>visited;\\n\\n        prepareList(adj,edges);\\n\\n        int count = 0;\\n\\n        for(int i = 0; i<n;i++){\\n            if(!visited[i]){\\n                vector<int>nodes;\\n\\n                dfs(i,visited,nodes,adj);\\n                int res = 0; \\n                for(int j = 0; j<nodes.size();j++){\\n                    if(adj[nodes[j]].size() >= nodes.size()-1) res++;\\n                }\\n\\n                if(res == nodes.size()) count++;\\n\\n            }\\n        }\\n       return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778322,
                "title": "intutive-dfs-one-is-for-adjacencylist-size-and-another-for-component-size",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int res=0;\\n        boolean[]visited=new boolean[n];\\n        boolean []vis=new boolean[n];\\n        for(int i=0;i<n;i++) {\\n            if (!visited[i]) {\\n                int size = findingcomponentsize(i, adj, visited) + 1;\\n                if (size != 1) {\\n                    boolean flag = checkingadjlistsize(i, size - 1, adj, vis);\\n                    if (flag) {\\n                        res++;\\n                    }\\n                }\\n                else{\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public int findingcomponentsize(int src,ArrayList<ArrayList<Integer>>adj,boolean[]visited){\\n        visited[src]=true;\\n        int count=0;\\n        for(int element:adj.get(src)){\\n            if (!visited[element]){\\n                count=1+findingcomponentsize(element,adj,visited);\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean checkingadjlistsize(int src,int size,ArrayList<ArrayList<Integer>>adj,boolean[]vis){\\n\\n        vis[src]=true;\\n\\n        if(adj.get(src).size()!=size){\\n            return false;\\n        }\\n        for(int el:adj.get(src)){\\n            if(!vis[el]) {\\n                boolean b = checkingadjlistsize(el, size, adj,vis);\\n                if (!b) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int countCompleteComponents(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int res=0;\\n        boolean[]visited=new boolean[n];\\n        boolean []vis=new boolean[n];\\n        for(int i=0;i<n;i++) {\\n            if (!visited[i]) {\\n                int size = findingcomponentsize(i, adj, visited) + 1;\\n                if (size != 1) {\\n                    boolean flag = checkingadjlistsize(i, size - 1, adj, vis);\\n                    if (flag) {\\n                        res++;\\n                    }\\n                }\\n                else{\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public int findingcomponentsize(int src,ArrayList<ArrayList<Integer>>adj,boolean[]visited){\\n        visited[src]=true;\\n        int count=0;\\n        for(int element:adj.get(src)){\\n            if (!visited[element]){\\n                count=1+findingcomponentsize(element,adj,visited);\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean checkingadjlistsize(int src,int size,ArrayList<ArrayList<Integer>>adj,boolean[]vis){\\n\\n        vis[src]=true;\\n\\n        if(adj.get(src).size()!=size){\\n            return false;\\n        }\\n        for(int el:adj.get(src)){\\n            if(!vis[el]) {\\n                boolean b = checkingadjlistsize(el, size, adj,vis);\\n                if (!b) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773848,
                "title": "dictionary-of-all-connections-per-element-96-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/0ed60561-e4f3-4f9f-999f-8605ceda001a_1689514900.510338.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        connections = {i: {i} for i in range(n)}\\n        for a, b in edges:\\n            connections[a].add(b)\\n            connections[b].add(a)\\n        nodes = [i for i in range(n)]\\n        nodes.sort(key=lambda i: -len(connections[i]))\\n        eliminated = set()\\n        count = 0\\n        for node in nodes:\\n            if node in eliminated:\\n                continue\\n            group = connections[node]\\n            if all(connections[element] == group for element in group):\\n                count += 1\\n            eliminated.update(group)\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n        connections = {i: {i} for i in range(n)}\\n        for a, b in edges:\\n            connections[a].add(b)\\n            connections[b].add(a)\\n        nodes = [i for i in range(n)]\\n        nodes.sort(key=lambda i: -len(connections[i]))\\n        eliminated = set()\\n        count = 0\\n        for node in nodes:\\n            if node in eliminated:\\n                continue\\n            group = connections[node]\\n            if all(connections[element] == group for element in group):\\n                count += 1\\n            eliminated.update(group)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766270,
                "title": "o-n-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUse DFS and every time DFS restarts is a start of a new component \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nTakes $O(n + m)$ time using DFS; going through each component and check if the adjList == m - 1 takes $O(n)$ time because there are n total nodes that we go through and getting the length of a list takes $O(1)$ time\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is $O(n + m)$ to store the components, explored array, adjList. \\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n\\n        adjList = {}\\n\\n        for i in range(n):\\n            adjList[i] = []\\n\\n        for edge in edges:\\n\\n            u = edge[0] \\n\\n            v = edge[1]\\n\\n            adjList[u].append(v)\\n\\n            adjList[v].append(u)\\n\\n        explored = [False for i in range(n)]\\n\\n        components = {}\\n\\n        def search(v, component):\\n\\n            explored[v] = True \\n\\n            components[component].append(v)\\n\\n            for w in adjList[v]:\\n                if not explored[w]:\\n                    search(w, component)\\n\\n        def dfs():\\n            component = 0 \\n            for i in range(n):\\n                if not explored[i]:\\n                    components[component] = []\\n                    search(i, component)\\n                    component += 1 \\n\\n        dfs()\\n\\n        completeCount = 0 \\n        \\n\\n        for k in components:\\n            m = len(components[k])\\n            Complete = True\\n            for node in components[k]:\\n                if len(adjList[node]) != m - 1:\\n                    Complete = False \\n                    break \\n            if Complete == True:\\n                completeCount += 1\\n\\n        return completeCount\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n\\n        adjList = {}\\n\\n        for i in range(n):\\n            adjList[i] = []\\n\\n        for edge in edges:\\n\\n            u = edge[0] \\n\\n            v = edge[1]\\n\\n            adjList[u].append(v)\\n\\n            adjList[v].append(u)\\n\\n        explored = [False for i in range(n)]\\n\\n        components = {}\\n\\n        def search(v, component):\\n\\n            explored[v] = True \\n\\n            components[component].append(v)\\n\\n            for w in adjList[v]:\\n                if not explored[w]:\\n                    search(w, component)\\n\\n        def dfs():\\n            component = 0 \\n            for i in range(n):\\n                if not explored[i]:\\n                    components[component] = []\\n                    search(i, component)\\n                    component += 1 \\n\\n        dfs()\\n\\n        completeCount = 0 \\n        \\n\\n        for k in components:\\n            m = len(components[k])\\n            Complete = True\\n            for node in components[k]:\\n                if len(adjList[node]) != m - 1:\\n                    Complete = False \\n                    break \\n            if Complete == True:\\n                completeCount += 1\\n\\n        return completeCount\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752186,
                "title": "simple-dfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int i,vector<int>&vis,vector<int>&vec)\\n    {\\n        vis[i]=1;\\n        vec.push_back(i);\\n        for(auto it:adj[i])\\n        {   \\n            if(!vis[it])\\n            {\\n                dfs(adj,it,vis,vec);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int cnt=0;\\n        vector<int>vis(n,0);\\n        vector<int>vec;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(adj,i,vis,vec);\\n                int flag=0;\\n                int sz=vec.size()-1;\\n                for(int j=0;j<vec.size();j++)\\n                {\\n                   if(sz!=adj[vec[j]].size())\\n                   {\\n                       flag=1;\\n                       break;\\n                   }                    \\n                }\\n                if(!flag)\\n                cnt++;\\n                vec.clear();\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[],int i,vector<int>&vis,vector<int>&vec)\\n    {\\n        vis[i]=1;\\n        vec.push_back(i);\\n        for(auto it:adj[i])\\n        {   \\n            if(!vis[it])\\n            {\\n                dfs(adj,it,vis,vec);\\n            }\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int cnt=0;\\n        vector<int>vis(n,0);\\n        vector<int>vec;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(adj,i,vis,vec);\\n                int flag=0;\\n                int sz=vec.size()-1;\\n                for(int j=0;j<vec.size();j++)\\n                {\\n                   if(sz!=adj[vec[j]].size())\\n                   {\\n                       flag=1;\\n                       break;\\n                   }                    \\n                }\\n                if(!flag)\\n                cnt++;\\n                vec.clear();\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749221,
                "title": "easy-c-solution-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,vector<vector<int>>&adj,vector<int>&vis){\\n        vis[i]=1;\\n        for(int k=0;k<adj[i].size();k++){\\n            if(vis[adj[i][k]]==0) solve(adj[i][k],adj,vis);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<e.size();i++){\\n            adj[e[i][0]].push_back(e[i][1]);\\n            adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                solve(i,adj,vis);\\n                int count=0;\\n                bool temp=true;\\n                for(int j=0;j<n;j++){\\n                    if(vis[j]==1) count++;\\n                }\\n                for(int j=0;j<n;j++){\\n                    if(vis[j]==1){\\n                        if(adj[j].size()!=count-1) temp=false;\\n                        vis[j]=2;\\n                    } \\n                }\\n                if(temp) res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,vector<vector<int>>&adj,vector<int>&vis){\\n        vis[i]=1;\\n        for(int k=0;k<adj[i].size();k++){\\n            if(vis[adj[i][k]]==0) solve(adj[i][k],adj,vis);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<e.size();i++){\\n            adj[e[i][0]].push_back(e[i][1]);\\n            adj[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                solve(i,adj,vis);\\n                int count=0;\\n                bool temp=true;\\n                for(int j=0;j<n;j++){\\n                    if(vis[j]==1) count++;\\n                }\\n                for(int j=0;j<n;j++){\\n                    if(vis[j]==1){\\n                        if(adj[j].size()!=count-1) temp=false;\\n                        vis[j]=2;\\n                    } \\n                }\\n                if(temp) res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738352,
                "title": "beats-98-in-runtime-77-in-memory-dfs-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738351,
                "title": "beats-98-in-runtime-77-in-memory-dfs-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738350,
                "title": "beats-98-in-runtime-77-in-memory-dfs-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        visited = set()\\n        myGarph = collections.defaultdict(list)\\n        for a,b in edges:\\n            myGarph[a].append(b)\\n            myGarph[b].append(a)\\n        myStack = []\\n        res = 0\\n        numberOfEdges = 0\\n        countNodes = 0\\n        keys = list(myGarph.keys())\\n        for i in range(n):\\n            if i not in visited:\\n                myStack.append(i)\\n                visited.add(i)\\n\\n                while myStack:\\n\\n                    curVal = myStack.pop()                    \\n                    temp = myGarph[curVal]\\n\\n                    numberOfEdges += len(temp)\\n                    countNodes += 1\\n                    \\n                    for j in temp:\\n                        if j not in visited:\\n                            myStack.append(j)\\n                            visited.add(j)\\n            \\n                m = countNodes\\n                if ((m * (m-1))/2 == numberOfEdges/2):\\n                    res += 1\\n                countNodes = 0\\n                numberOfEdges = 0\\n    \\n        return res\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734734,
                "title": "dsu-degree-solution",
                "content": "# Complexity\\n- [Time complexity:](https://cp-algorithms.com/data_structures/disjoint_set_union.html#time-complexity) $O(n.\\\\alpha(n))$  \\n\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass DSU {\\npublic:\\n    vector<int> p, r, sz;\\n    int n, cc;\\n\\n    DSU() {\\n        n = 0;\\n    }\\n    \\n    DSU(int _n) {\\n        cc = n = _n;\\n        p = r = sz = vector<int>(n, 1);\\n        for(int i = 0; i < n; i++) p[i] = i;\\n    }\\n    \\n    int find(int x) {\\n        assert(0 <= x and x < n);\\n        int y = x;\\n        while(x != p[x]) x = p[x];\\n        while(y != p[y]) {\\n            int z = p[y];\\n            p[y] = x;\\n            y = z;\\n        }\\n        return x;\\n    }\\n    \\n    void join(int x, int y) {\\n        assert(0 <= x and x < n and 0 <= y and y < n);\\n        x = find(x), y = find(y);\\n        if(x == y) return;\\n        if(r[x] > r[y]) swap(x, y); // for rank heuristics\\n        // if(sz[x] > sz[y]) swap(x, y); // to size heuristics\\n        p[x] = y;\\n        sz[y] += sz[x];\\n        r[y] += r[x] == r[y];\\n        cc--;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU uf(n);\\n        vector<int> deg(n, 0);\\n        for (auto& e: edges) {\\n            int u = e[0], v = e[1];\\n            uf.join(u, v);\\n            deg[u]++, deg[v]++;\\n        }\\n        int ans = 0;\\n        vector<int> cnt(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            int u = uf.find(i);\\n            int sz = uf.sz[u];\\n            if (deg[i] == sz - 1) {\\n                cnt[u]++;\\n                ans += (cnt[u] == sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DSU {\\npublic:\\n    vector<int> p, r, sz;\\n    int n, cc;\\n\\n    DSU() {\\n        n = 0;\\n    }\\n    \\n    DSU(int _n) {\\n        cc = n = _n;\\n        p = r = sz = vector<int>(n, 1);\\n        for(int i = 0; i < n; i++) p[i] = i;\\n    }\\n    \\n    int find(int x) {\\n        assert(0 <= x and x < n);\\n        int y = x;\\n        while(x != p[x]) x = p[x];\\n        while(y != p[y]) {\\n            int z = p[y];\\n            p[y] = x;\\n            y = z;\\n        }\\n        return x;\\n    }\\n    \\n    void join(int x, int y) {\\n        assert(0 <= x and x < n and 0 <= y and y < n);\\n        x = find(x), y = find(y);\\n        if(x == y) return;\\n        if(r[x] > r[y]) swap(x, y); // for rank heuristics\\n        // if(sz[x] > sz[y]) swap(x, y); // to size heuristics\\n        p[x] = y;\\n        sz[y] += sz[x];\\n        r[y] += r[x] == r[y];\\n        cc--;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int countCompleteComponents(int n, vector<vector<int>>& edges) {\\n        DSU uf(n);\\n        vector<int> deg(n, 0);\\n        for (auto& e: edges) {\\n            int u = e[0], v = e[1];\\n            uf.join(u, v);\\n            deg[u]++, deg[v]++;\\n        }\\n        int ans = 0;\\n        vector<int> cnt(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            int u = uf.find(i);\\n            int sz = uf.sz[u];\\n            if (deg[i] == sz - 1) {\\n                cnt[u]++;\\n                ans += (cnt[u] == sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732153,
                "title": "rust-solution-using-union-find",
                "content": "# Code\\n```\\nuse std::collections::*;\\n\\nstruct UnionFind {\\n  parents: Vec<usize>,\\n  sizes: Vec<usize>,\\n  ranks: Vec<usize>\\n}\\n\\nimpl UnionFind {\\n  fn new(n:usize) -> UnionFind {\\n    let mut uf = UnionFind { parents: vec![0;n], sizes:vec![1;n], ranks:vec![0;n] };\\n    for i in 0..n {\\n      uf.parents[i] = i;\\n    }\\n    uf\\n  }\\n\\n  fn root(&mut self, x:usize) -> usize {\\n    let ti = self.parents[x];\\n    if ti == x {\\n      x\\n    } else {\\n      self.parents[x] = self.root(ti);\\n      self.parents[x]\\n    }\\n  }\\n\\n  fn is_same(&mut self, x:usize, y:usize) -> bool {\\n    self.root(x) == self.root(y)\\n  }\\n\\n  fn unite(&mut self, x:usize, y:usize) -> bool {\\n    let rx = self.root(x);\\n    let ry = self.root(y);\\n    if rx == ry { return false }\\n    let (rx, ry) = if self.ranks[rx] < self.ranks[ry] {\\n      (ry, rx)\\n    } else {\\n      (rx, ry)\\n    };\\n    self.parents[ry] = rx;\\n    if self.ranks[rx] == self.ranks[ry] {\\n      self.ranks[rx] += 1;\\n    }\\n\\n    self.sizes[rx] += self.sizes[ry];\\n    true\\n  }\\n\\n  fn group_size(&mut self, x:usize) -> usize {\\n    let i = self.root(x);\\n    self.sizes[i]\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn count_complete_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n    let n = n as usize;\\n    let mut g = vec![vec![];n];\\n    let mut tree = UnionFind::new(n);\\n\\n    for arr in &edges {\\n      let a = arr[0] as usize;\\n      let b = arr[1] as usize;\\n\\n      g[a].push(b);\\n      g[b].push(a);\\n      tree.unite(a, b);\\n    } \\n\\n    let mut map = HashMap::new();\\n    for i in 0..n {\\n      let pi = tree.root(i);\\n      map.entry(pi).or_insert(vec![]).push(i);\\n    }\\n\\n    let mut result = 0;\\n    for (_, nodes) in map {\\n      let need_edge_num = nodes.len() - 1;\\n      let mut success = true;\\n      for i in nodes {\\n        if g[i].len() != need_edge_num {\\n          success = false;\\n          break\\n        }\\n      }\\n      if success {\\n        result += 1;\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Union Find"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nstruct UnionFind {\\n  parents: Vec<usize>,\\n  sizes: Vec<usize>,\\n  ranks: Vec<usize>\\n}\\n\\nimpl UnionFind {\\n  fn new(n:usize) -> UnionFind {\\n    let mut uf = UnionFind { parents: vec![0;n], sizes:vec![1;n], ranks:vec![0;n] };\\n    for i in 0..n {\\n      uf.parents[i] = i;\\n    }\\n    uf\\n  }\\n\\n  fn root(&mut self, x:usize) -> usize {\\n    let ti = self.parents[x];\\n    if ti == x {\\n      x\\n    } else {\\n      self.parents[x] = self.root(ti);\\n      self.parents[x]\\n    }\\n  }\\n\\n  fn is_same(&mut self, x:usize, y:usize) -> bool {\\n    self.root(x) == self.root(y)\\n  }\\n\\n  fn unite(&mut self, x:usize, y:usize) -> bool {\\n    let rx = self.root(x);\\n    let ry = self.root(y);\\n    if rx == ry { return false }\\n    let (rx, ry) = if self.ranks[rx] < self.ranks[ry] {\\n      (ry, rx)\\n    } else {\\n      (rx, ry)\\n    };\\n    self.parents[ry] = rx;\\n    if self.ranks[rx] == self.ranks[ry] {\\n      self.ranks[rx] += 1;\\n    }\\n\\n    self.sizes[rx] += self.sizes[ry];\\n    true\\n  }\\n\\n  fn group_size(&mut self, x:usize) -> usize {\\n    let i = self.root(x);\\n    self.sizes[i]\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn count_complete_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n    let n = n as usize;\\n    let mut g = vec![vec![];n];\\n    let mut tree = UnionFind::new(n);\\n\\n    for arr in &edges {\\n      let a = arr[0] as usize;\\n      let b = arr[1] as usize;\\n\\n      g[a].push(b);\\n      g[b].push(a);\\n      tree.unite(a, b);\\n    } \\n\\n    let mut map = HashMap::new();\\n    for i in 0..n {\\n      let pi = tree.root(i);\\n      map.entry(pi).or_insert(vec![]).push(i);\\n    }\\n\\n    let mut result = 0;\\n    for (_, nodes) in map {\\n      let need_edge_num = nodes.len() - 1;\\n      let mut success = true;\\n      for i in nodes {\\n        if g[i].len() != need_edge_num {\\n          success = false;\\n          break\\n        }\\n      }\\n      if success {\\n        result += 1;\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3729254,
                "title": "python-super-easy-union-find-degree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        parent = {}\\n        def find_parent(i):\\n            if i not in parent or parent[i] == i:\\n                parent[i] = i\\n                return i \\n            \\n            parent[i] = find_parent(parent[i])\\n            return parent[i]\\n        in_degree = collections.defaultdict(int)\\n        for a , b in edges:\\n            p_a = find_parent(a)\\n            p_b = find_parent(b)\\n            in_degree[b] +=1\\n            if p_a != p_b:\\n                parent[p_a] = p_b\\n\\n        group = collections.defaultdict(set)\\n        for i in range(n):\\n            p = find_parent(i)\\n            group[p].add(i)\\n        ans = 0\\n        for p in group:\\n            edges = 0\\n            for n in group[p]:\\n                edges += in_degree[n]\\n            if edges == comb(len(group[p]), 2):\\n                ans +=1        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\\n\\n        parent = {}\\n        def find_parent(i):\\n            if i not in parent or parent[i] == i:\\n                parent[i] = i\\n                return i \\n            \\n            parent[i] = find_parent(parent[i])\\n            return parent[i]\\n        in_degree = collections.defaultdict(int)\\n        for a , b in edges:\\n            p_a = find_parent(a)\\n            p_b = find_parent(b)\\n            in_degree[b] +=1\\n            if p_a != p_b:\\n                parent[p_a] = p_b\\n\\n        group = collections.defaultdict(set)\\n        for i in range(n):\\n            p = find_parent(i)\\n            group[p].add(i)\\n        ans = 0\\n        for p in group:\\n            edges = 0\\n            for n in group[p]:\\n                edges += in_degree[n]\\n            if edges == comb(len(group[p]), 2):\\n                ans +=1        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1893984,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 1898383,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 1939877,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 2023056,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 1893523,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 1893328,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 2028934,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            },
            {
                "id": 2022000,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tip:-`\n\nIf you know the standard method for how to count no of disconnected component, use the same thing, but at each DFS of a component, count the total no of nodes and total no of edges and use this mathematical relation\n\nFor any closed shape\n\n`(noCorners)*(noCorners-1) = 2*(noEdges)`"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Here's an alternative to the UF and other dfs methods.\n\nA connected component is complete if and only if each node of the component has an edges list that contains exactly the other nodes in that component.\n\n If a 'self-edge\" (ie, [k,k]) is added to the edges list of each node, then the above becomes:\n\nA connected component is complete if and only if each node of the component has exactly the same list of edges, and the number of edges in that list is equal to the number of nodes.\n\nI've left a figure here: [python-3-6-lines-counter-t-m-91-97/](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/3538690/python-3-6-lines-counter-t-m-91-97/)"
                    },
                    {
                        "username": "maxtate",
                        "content": "That\\'s brilliant. Thanks for the figure too."
                    },
                    {
                        "username": "akhilg11",
                        "content": "n =4\\nedges =[[1,0],[2,0],[3,1],[3,2]]\\nHow is this 0 ?? \\nn =2\\nedges =[[1,0]]\\nAnd this is 1.\\nCan somebody explain it to me??Did i understand something wrong??"
                    },
                    {
                        "username": "kenlau",
                        "content": "For complete connected component, it means a node connects to every nodes in the same component except itself.\\ni.e. a complete connected component with`n` nodes, each node has `n - 1` edges (or called it degree).\\nFor case \"n = 4, [[1,0],[2,0],[3,1],[3,2]]\", there are 4 nodes but each node has only 2 edges, so it is NOT complete connected\\nFor case \"n = 2, [[1,0]]\", there are 2 nodes and each node has 1 edges, so it is complete connected"
                    },
                    {
                        "username": "jeffreylsq",
                        "content": "Same here, I don\\'t why this case is 0, confuse me a lot"
                    },
                    {
                        "username": "akhilg11",
                        "content": "[@Adhiraj-MNNIT](/Adhiraj-MNNIT) aaha graphs pdhne lge bhai"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "bhai mil gya yha :)"
                    },
                    {
                        "username": "danielmascena",
                        "content": "it seems the answer lies in the hint: A connected component is complete if and only if the number of edges in the component is equal to m*(m-1)/2, where m is the number of nodes in the component."
                    },
                    {
                        "username": "danielmascena",
                        "content": "I didn\\xB4t get it either. Problem description fails "
                    },
                    {
                        "username": "rnikh",
                        "content": "Indegree/Outdegree of each node in each connected components should be equal to the number of nodes in that component - 1.\\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Thought of DSU but DFS is enough it\\'s easier to solve using DFS"
                    },
                    {
                        "username": "aman1320",
                        "content": "DSU approach could be used to separate the different connected component. In one connected component there will be only one root."
                    },
                    {
                        "username": "pa-one55",
                        "content": "Intution -> DFS\\n       \\n // so\\n        // we need to find how many complete comoponents are there in the given graph system\\n        // and a complete component means all the nodes in that component should be connected to every other node in that component\\n        // means we need to go to a component and check the size of adjacency list of all the nodes in the array\\n        // if, the size of the adjacency list of all the nodes in that component is 1 less that the number of nodes means all the nodes are connected to all the other ones, and hence its a complete component\\n        // increase the ans by 1 and repeat"
                    },
                    {
                        "username": "mihir2310",
                        "content": "Can someone please check my code and logic and explain why it doesn\\'t work?\\n\\n `# Create adj_list\\n        adj_list = {i:[] for i in range(n)}\\n        for pointer, pointed in edges:\\n            adj_list[pointer].append(pointed)\\n            adj_list[pointed].append(pointer)\\n        \\n        # Recursive dfs step to add all elements not seen from paths from node to a visited set\\n        grand_visited = set()\\n\\n        def dfs(node, mini_visited):\\n            # So if the node was already visited in this new unvisited node\\'s dfs: there is a loop so return true\\n            if node in mini_visited: \\n                return True\\n\\n            mini_visited.add(node) # Else, add the node to the visited set\\n            for neighbor in adj_list[node]: # Run the dfs on its neighbors\\n                if dfs(neighbor, mini_visited) == True:\\n                    return True\\n            grand_visited.add(node)  # Add the current node to grand_visited\\n            return False\\n\\n        res = 0 # Final answer\\n\\n        for node in range(n): # iterate through each node within the total number of nodes\\n            if adj_list[node] == []:\\n                res+=1 # Lone elements are always connected so increment\\n            if node not in grand_visited:\\n                if dfs(node, set()): # If loop was detected, increment by 1\\n                    res+=1  # Run dfs to add all node\\'s connected nodes to the visited set\\n                \\n\\n\\n        return res`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Operations to Make Numbers Non-positive",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Minimum Cost to Make All Characters Equal",
        "question_content": "<p>You are given a <strong>0-indexed</strong> binary string <code>s</code> of length <code>n</code> on which you can apply two types of operations:</p>\n\n<ul>\n\t<li>Choose an index <code>i</code> and invert all characters from&nbsp;index <code>0</code> to index <code>i</code>&nbsp;(both inclusive), with a cost of <code>i + 1</code></li>\n\t<li>Choose an index <code>i</code> and invert all characters&nbsp;from&nbsp;index <code>i</code> to index <code>n - 1</code>&nbsp;(both inclusive), with a cost of <code>n - i</code></li>\n</ul>\n\n<p>Return <em>the <strong>minimum cost </strong>to make all characters of the string <strong>equal</strong></em>.</p>\n\n<p><strong>Invert</strong> a character means&nbsp;if its value is &#39;0&#39; it becomes &#39;1&#39; and vice-versa.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0011&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Apply the second operation with <code>i = 2</code> to obtain <code>s = &quot;0000&quot; for a cost of 2</code>. It can be shown that 2 is the minimum cost to make all characters equal.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;010101&quot;\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> Apply the first operation with i = 2 to obtain s = &quot;101101&quot; for a cost of 3.\nApply the first operation with i = 1 to obtain s = &quot;011101&quot; for a cost of 2. \nApply the first operation with i = 0 to obtain s = &quot;111101&quot; for a cost of 1. \nApply the second operation with i = 4 to obtain s = &quot;111110&quot; for a cost of 2.\nApply the second operation with i = 5 to obtain s = &quot;111111&quot; for a cost of 1. \nThe total cost to make all characters equal is 9. It can be shown that 9 is the minimum cost to make all characters equal.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length == n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3570185,
                "title": "single-pass-iterative-easy-explanation-think-greedy-one-line-clean-code-c",
                "content": "# Intuition\\nDon\\'t worry if you were not able to solve this problem during the contest,\\nLets get into the question:\\n\\n\\nIt says we have to flip all the bits in a Binary string i.e (0,1) to make the string of same bits of:\\n\\n        Take ::  000000100\\n    For this test case first it is feasile to make last two zeroes flip\\n    i.e\\n                000000111\\n    And then make those three one\\'s again flip:\\n                000000000\\n    Total step required : 2+3,\\n\\n\\n# Approach\\n1. start traversing through the array\\n    a. If you encounter different element i.e s[i] != s[i-1]:\\n        check from which side it is feasible for us to take less move to       make it equal min(i,n-i) either from the front or from the back.\\n2. Maintain a variable ans and keep on adding the min value required for us.\\n\\n# Complexity\\n- Time complexity:\\n**Traversing the Array Once - 0(n)**\\n\\n- Space complexity:\\n**No space Requeired - 0(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // Key Observation\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // Key Observation\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570380,
                "title": "java-c-python-check-s-i-s-i-1",
                "content": "# **Explanation**\\nCheck if `s[i] == s[i - 1]`.\\nIf they are different, we need to either:\\n1. change the prefix to from start to `s[i - 1]`, cost `i`.\\n2. change the suffix from `s[i]` to end, cost `n - i`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long minimumCost(String s) {\\n        long res = 0;\\n        for (int i = 1, n = s.length(); i < n; ++i)\\n            if (s.charAt(i) != s.charAt(i - 1))\\n                res += Math.min(i, n - i);\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long minimumCost(string s) {\\n        long long res = 0;\\n        for (int i = 1, n = s.size(); i < n; ++i)\\n            if (s[i] != s[i - 1])\\n                res += min(i, n - i);\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        return sum(min(i, n - i) for i in range(1, n) if s[i] != s[i - 1])\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```java\\n    public long minimumCost(String s) {\\n        long res = 0;\\n        for (int i = 1, n = s.length(); i < n; ++i)\\n            if (s.charAt(i) != s.charAt(i - 1))\\n                res += Math.min(i, n - i);\\n        return res;\\n    }\\n```\n```cpp\\n    long long minimumCost(string s) {\\n        long long res = 0;\\n        for (int i = 1, n = s.size(); i < n; ++i)\\n            if (s[i] != s[i - 1])\\n                res += min(i, n - i);\\n        return res;\\n    }\\n```\n```py\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        return sum(min(i, n - i) for i in range(1, n) if s[i] != s[i - 1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3570183,
                "title": "cpp-prefix-and-suffix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust make a prefix array `ps` and store the cost for making all the elements from `0` to `i` equal to `s[i]`\\n\\nMake a suffix array `ss` and store the cost for making all the elements from `i` to `n - 1` equal to `s[i]`\\n\\nNow your answer will be `min(ps[i] + ss[i])` for all `i` from `0` to `n - 1`\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<ll> ps(n);\\n        ll ss = 0;\\n        for(int i = 1; i < n; i += 1) {\\n            if(s[i - 1] != s[i]) {\\n                ps[i] += (ps[i - 1] + i);\\n            } else ps[i] = ps[i - 1];\\n        }\\n        ll ans = 1e14;\\n        for(int i = n - 2; i >= 0; i -= 1) {\\n            if(s[i] != s[i + 1]) ss += (n - i - 1);\\n            ans = min(ans,ps[i] + ss);\\n        }\\n        return min(ans,ss);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<ll> ps(n);\\n        ll ss = 0;\\n        for(int i = 1; i < n; i += 1) {\\n            if(s[i - 1] != s[i]) {\\n                ps[i] += (ps[i - 1] + i);\\n            } else ps[i] = ps[i - 1];\\n        }\\n        ll ans = 1e14;\\n        for(int i = n - 2; i >= 0; i -= 1) {\\n            if(s[i] != s[i + 1]) ss += (n - i - 1);\\n            ans = min(ans,ps[i] + ss);\\n        }\\n        return min(ans,ss);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570182,
                "title": "simple-iteration-very-simple-easy-to-understand-solution",
                "content": "Up vote if you like the solution \\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted </b>\\n\\n# Approach 1\\n\\n1. Keep traversing from both left and right side\\n2. Where ever we find a miss match of the char with the previous one from left or right just add the index to the ans. ( basically we want to make all equal to the current char )\\n\\nFor ex: \\n10110100. i= 0, j = 0\\n00110100 on second iteration we make the first char as 0, so add 1 to the ans.\\n00110111 on third itration we make the last 2 char equal to 1 which is pointed by j th index and add 2 to the ans\\n...\\n\\nBasicaly we do the following :\\nAdd the ith index if there is a change from the front.\\nAdd the n-jth index -1 if there is a change from the last.\\n\\n# Code\\n```\\nlong long minimumCost(string s) {\\n    long long ans = 0, i = 1, j = s.size()-2;\\n    while(i < j){\\n        if(s[i] != s[i-1]) ans += i; \\n        if(s[j] != s[j+1]) ans += s.size() - j - 1; \\n        i++; j--;\\n    }\\n    if(i != j && s[i-1] != s[j+1]) ans += i;\\n    if(i == j && s[i] != s[i-1]) ans += i;\\n    if(i == j && s[j] != s[j+1]) ans += s.size() - j - 1;\\n    return ans;\\n}\\n```\\n\\n# Approach 2\\nCheck out the following solution which is more consise and stright forward then above solution :\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3570185/single-pass-iterative-easy-explanation-think-greedy-one-line-clean-code-c/\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long minimumCost(string s) {\\n    long long ans = 0, i = 1, j = s.size()-2;\\n    while(i < j){\\n        if(s[i] != s[i-1]) ans += i; \\n        if(s[j] != s[j+1]) ans += s.size() - j - 1; \\n        i++; j--;\\n    }\\n    if(i != j && s[i-1] != s[j+1]) ans += i;\\n    if(i == j && s[i] != s[i-1]) ans += i;\\n    if(i == j && s[j] != s[j+1]) ans += s.size() - j - 1;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570308,
                "title": "all-possible-solution-with-explanation",
                "content": "# Intuition By greedy\\n\\n**Start traversing through the array**\\n1. If you encounter different element i.e s[i] != s[i-1]:\\ncheck from which side it is feasible for us to take less move to make it equal min(i,n-i) either from the front or from the back.\\n2. Maintain a variable ans and keep on adding the min value required for us.\\n```\\nCode block\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // Key Observation\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    }\\n};\\n```\\n\\n\\n# Intuition By prefix array\\nhe code calculates the cost of flipping characters in the string and finds the minimum cost required to make all characters the same. It does this by considering the cost of flipping characters up to each position and then calculating the remaining cost from each position to the end of the string. The overall minimum cost is then determined and returned.\\n\\n# Algo \\n\\n1. First, we initialize some variables and containers to store information.\\n\\n2. We go through the string and calculate the partial sums. These represent the cost of flipping characters up to each position. For example, if we have \"0011\", the partial sums would be [0, 1, 1, 4], indicating the cost of flipping characters up to each position.\\nWe initialize the minimum cost as a very large value.\\n\\n3. Next, we go through the string in reverse order. We calculate the remaining cost by considering the difference between adjacent characters. If the characters are different, we add the remaining cost of flipping the characters from the current position to the end of the string.\\n\\n4. We calculate the current cost by combining the partial sum up to the current position with the remaining cost.\\nWe update the minimum cost if the current cost is lower than the current minimum cost.\\n\\n5. Finally, we return the minimum cost as the result.\\nI hope this simplified explanation helps you understand the algorithm better. Let me know if you have any further questions!\\n\\n# Code\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int length = s.size();  // Get the length of the input string\\n        vector<ll> partialSums(length);  // Store partial sums\\n        ll remainingSum = 0;  // Track the sum of remaining characters\\n\\n        // Calculate partial sums for flipping characters up to each index\\n        for (int i = 1; i < length; i += 1) {\\n            if (s[i - 1] != s[i]) {\\n                partialSums[i] += (partialSums[i - 1] + i);\\n            } else {\\n                partialSums[i] = partialSums[i - 1];\\n            }\\n        }\\n\\n        ll minCost = 1e14;  // Initialize minimum cost to a large value\\n\\n        // Iterate through the string in reverse to calculate the minimum cost\\n        for (int i = length - 2; i >= 0; i -= 1) {\\n            if (s[i] != s[i + 1]) {\\n                remainingSum += (length - i - 1);\\n            }\\n            ll currentCost = partialSums[i] + remainingSum;\\n            minCost = min(minCost, currentCost);\\n        }\\n\\n        // Return the minimum cost\\n        return min(minCost, remainingSum);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nCode block\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // Key Observation\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    }\\n};\\n```\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int length = s.size();  // Get the length of the input string\\n        vector<ll> partialSums(length);  // Store partial sums\\n        ll remainingSum = 0;  // Track the sum of remaining characters\\n\\n        // Calculate partial sums for flipping characters up to each index\\n        for (int i = 1; i < length; i += 1) {\\n            if (s[i - 1] != s[i]) {\\n                partialSums[i] += (partialSums[i - 1] + i);\\n            } else {\\n                partialSums[i] = partialSums[i - 1];\\n            }\\n        }\\n\\n        ll minCost = 1e14;  // Initialize minimum cost to a large value\\n\\n        // Iterate through the string in reverse to calculate the minimum cost\\n        for (int i = length - 2; i >= 0; i -= 1) {\\n            if (s[i] != s[i + 1]) {\\n                remainingSum += (length - i - 1);\\n            }\\n            ll currentCost = partialSums[i] + remainingSum;\\n            minCost = min(minCost, currentCost);\\n        }\\n\\n        // Return the minimum cost\\n        return min(minCost, remainingSum);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570321,
                "title": "fastest-beats-100-0ms-o-n-c-java-python",
                "content": "# Intuition\\n**```Standing at any particular index check what can be minimum cost to make it equal to the next character \\u2705.```**\\n\\n![image.png](https://assets.leetcode.com/users/images/f2e8e6c2-d98b-4e62-b4b9-6ff0313dc08e_1685248470.042611.png)\\n\\n# Approach\\n**```Since we need to minimize the cost, standing at any particular find out what is the minimum number of steps required to make char at the index equal to next character.```**\\n\\n**Lets say in 010101\\nat index 0 : \\nif ```s[0] != s[1] ```\\nthen there 2 ways to make ```s[0] == s[1]```\\neither by reversing all the characters from 0 ... i \\nor by reversing all the character from i + 1 ... n**\\n\\n**After perform operating till ith index the elements in the left half become equal \\ni.e if at i = 4 \\nthe elements would now be \\n1 1 1 1 0 1**\\n\\n# Complexity\\n- Time complexity:\\n```**Since it requires just to traverse the entire string only once the time complexity is: O(N)**```\\n\\n- Space complexity:\\n**```Cost variable is used to store the cost so the space complexity is O(1)```**\\n\\n# Code (C++)\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0, n = s.size();\\n        for (int i = 0; i < s.size() - 1; ++i)\\n        {\\n            if (s[i] != s[i + 1])\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code(Java)\\n``` public class Solution\\n{\\npublic\\n    long minimumCost(String s)\\n    {\\n        long ans = 0;\\n        int n = s.length();\\n        for (int i = 0; i < s.length() - 1; ++i)\\n        {\\n            if (s.charAt(i) != s.charAt(i + 1))\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n# Code(Python)\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        for i in range(n - 1):\\n            if s[i] != s[i + 1]:\\n                if i + 1 <= n - i - 1:\\n                    ans += i + 1\\n                else:\\n                    ans += n - i - 1\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```Standing at any particular index check what can be minimum cost to make it equal to the next character \\u2705.```\n```Since we need to minimize the cost, standing at any particular find out what is the minimum number of steps required to make char at the index equal to next character.```\n```s[0] != s[1] ```\n```s[0] == s[1]```\n```**Since it requires just to traverse the entire string only once the time complexity is: O(N)**```\n```Cost variable is used to store the cost so the space complexity is O(1)```\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0, n = s.size();\\n        for (int i = 0; i < s.size() - 1; ++i)\\n        {\\n            if (s[i] != s[i + 1])\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` public class Solution\\n{\\npublic\\n    long minimumCost(String s)\\n    {\\n        long ans = 0;\\n        int n = s.length();\\n        for (int i = 0; i < s.length() - 1; ++i)\\n        {\\n            if (s.charAt(i) != s.charAt(i + 1))\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        for i in range(n - 1):\\n            if s[i] != s[i + 1]:\\n                if i + 1 <= n - i - 1:\\n                    ans += i + 1\\n                else:\\n                    ans += n - i - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570239,
                "title": "simple-greedy-complete-intuition-explained",
                "content": "Operation-1 : Flip bits towards left\\nOperation-2 : Flip bits towards right\\n \\nJust observe that\\nFor the left indexes like (0, 1..) if we do operation-2 it will be very costly\\nFor the right indexes like (n - 3, n - 2, n - 1\\u2026) if we do operation-1 it will be very costly\\nFor the **mid index (indexes)**, both **operation-1 and operation-2 will be of almost equal cost**\\n\\n\\nSo it would be better to **make all chars equal to \\u2018mid\\u2019 character of string**\\nSo targetCh = s[mid]\\nBy which we can \\n**Apply \\u201COperation-1\\u201D on the left indexes** of mid (if character is not equal to target)\\n**Apply \\u201COperation-2\\u201D on the right indexes** of mid (if character is not equal to target)\\n\\n\\nDo we really need to manually perform the operation by flipping all the bits (left/right)\\nIf not then how do we know what is the correct character at some index after some operations are done on it\\nWe can optimize it\\nWe can keep a count of operations done on both left and right indexes\\n\\nSo if char in string is str = ch\\nop = (operations done on it)\\n**If (op is even) : we flipped ch even no. of times => so no change**\\n**If (op is odd) : we flipped ch odd no, of time => flip ch**\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        int n = s.size();\\n        int mid = n / 2;\\n        long long ans = 0;\\n        char target = s[mid]; \\n        //we will make all chars of string equal to target\\n        \\n        int i = mid - 1, j = mid + 1;\\n        int leftOp = 0, rightOp = 0;\\n        //===============================================================================\\n        while(i >= 0)\\n        {\\n            char ch = s[i];\\n            if (leftOp % 2 != 0) //if odd operations done, FLIP CHAR\\n                ch = (ch == \\'0\\')? \\'1\\' : \\'0\\';\\n            \\n            if (ch != target) \\n            {\\n                leftOp++;\\n                ans += (i + 1);\\n            }\\n            i--;\\n        }\\n        //===============================================================================\\n        while(j < n)\\n        {\\n            char ch = s[j];\\n            if (rightOp % 2 != 0) //if odd operations done, FLIP CHAR\\n                ch = (ch == \\'0\\')? \\'1\\' : \\'0\\';\\n            \\n            if (ch != target)\\n            {\\n                rightOp++; \\n                ans += (n - j);\\n            }\\n            j++;\\n        }\\n        //================================================================================\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        int n = s.size();\\n        int mid = n / 2;\\n        long long ans = 0;\\n        char target = s[mid]; \\n        //we will make all chars of string equal to target\\n        \\n        int i = mid - 1, j = mid + 1;\\n        int leftOp = 0, rightOp = 0;\\n        //===============================================================================\\n        while(i >= 0)\\n        {\\n            char ch = s[i];\\n            if (leftOp % 2 != 0) //if odd operations done, FLIP CHAR\\n                ch = (ch == \\'0\\')? \\'1\\' : \\'0\\';\\n            \\n            if (ch != target) \\n            {\\n                leftOp++;\\n                ans += (i + 1);\\n            }\\n            i--;\\n        }\\n        //===============================================================================\\n        while(j < n)\\n        {\\n            char ch = s[j];\\n            if (rightOp % 2 != 0) //if odd operations done, FLIP CHAR\\n                ch = (ch == \\'0\\')? \\'1\\' : \\'0\\';\\n            \\n            if (ch != target)\\n            {\\n                rightOp++; \\n                ans += (n - j);\\n            }\\n            j++;\\n        }\\n        //================================================================================\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570298,
                "title": "simple-dynamic-programming-solution-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(string &s,int idx,int curr,vector<vector<long long int>>&dp)\\n    {\\n        if(idx==s.size())\\n            return 0;\\n        if(dp[idx][curr]!=-1)\\n            return dp[idx][curr];\\n        \\n        long long int a=0,b=0;\\n        if(curr!=s[idx]-\\'0\\')\\n        {\\n            a=a+((int)s.size()-idx)+solve(s,idx+1,!curr,dp);\\n            b=b+idx+solve(s,idx+1,!curr,dp);\\n            return dp[idx][curr]= min(a,b);\\n        }\\n        else\\n            return dp[idx][curr]= solve(s,idx+1,curr,dp);\\n        \\n    }\\n    long long minimumCost(string s) {\\n        vector<vector<long long int>>dp(s.size()+1,vector<long long int>(2,-1));\\n        vector<vector<long long int>>dp1(s.size()+1,vector<long long int>(2,-1));\\n        return min(solve(s,0,0,dp),solve(s,0,1,dp1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(string &s,int idx,int curr,vector<vector<long long int>>&dp)\\n    {\\n        if(idx==s.size())\\n            return 0;\\n        if(dp[idx][curr]!=-1)\\n            return dp[idx][curr];\\n        \\n        long long int a=0,b=0;\\n        if(curr!=s[idx]-\\'0\\')\\n        {\\n            a=a+((int)s.size()-idx)+solve(s,idx+1,!curr,dp);\\n            b=b+idx+solve(s,idx+1,!curr,dp);\\n            return dp[idx][curr]= min(a,b);\\n        }\\n        else\\n            return dp[idx][curr]= solve(s,idx+1,curr,dp);\\n        \\n    }\\n    long long minimumCost(string s) {\\n        vector<vector<long long int>>dp(s.size()+1,vector<long long int>(2,-1));\\n        vector<vector<long long int>>dp1(s.size()+1,vector<long long int>(2,-1));\\n        return min(solve(s,0,0,dp),solve(s,0,1,dp1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570234,
                "title": "l2r-and-r2l",
                "content": "We go left-to-right first, and, for each position `i`, we track the cost to make string `s[0...i]` equal.\\n\\nIf `s[i - 1]` is not equal to `s[i]`, we flip `i` characters (cost is `i`) to flip. Plus, we need to add cost to make previos `i - 1` characters equal.\\n\\nSo, the transition function is:\\n```cpp\\ndp[i] = dp[i - 1] + (s[i - 1] != s[i] ? i : 0);`\\n```\\n\\nThen, we go right-to-left, and also count the number of operations to make s[i..] characters equal.\\n\\nFinally, we track the minimum cost to make prefix (`s[0..i - 1]`) and suffix (`s[i + 1...]`) equal to `s[i]`.\\n\\n**C++**\\n```cpp\\nlong long minimumCost(const string &s) {\\n    long long dp[100001] = {};\\n    for (int i = 1; i < s.size(); ++i)\\n        dp[i] = dp[i - 1] + (s[i - 1] != s[i] ? i : 0);\\n    long long res = dp[s.size() - 1], right = 0;\\n    for (int i = s.size() - 2; i > 0; --i) {\\n        right += s[i] != s[i + 1] ? s.size() - i - 1 : 0;\\n        res = min(res, dp[i] + right);\\n    }    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\ndp[i] = dp[i - 1] + (s[i - 1] != s[i] ? i : 0);`\\n```\n```cpp\\nlong long minimumCost(const string &s) {\\n    long long dp[100001] = {};\\n    for (int i = 1; i < s.size(); ++i)\\n        dp[i] = dp[i - 1] + (s[i - 1] != s[i] ? i : 0);\\n    long long res = dp[s.size() - 1], right = 0;\\n    for (int i = s.size() - 2; i > 0; --i) {\\n        right += s[i] != s[i + 1] ? s.size() - i - 1 : 0;\\n        res = min(res, dp[i] + right);\\n    }    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570655,
                "title": "visually-explained-intuition-based-greedy-python-easy",
                "content": "# Intuition\\n- First thing to notice in this question is that we only need to find the minimum number of steps required to make string equal.\\n- Whether we make the string all ones or all zeros is not the concern.\\nTherefore we can traverse through the string linearly and check for pairs of adjacent characters.\\n- If the adjacent characters are equal then we need not make any changes. But if they are not we greedily choose either left or right subarray to make the pair equal.\\n- While traversing all the elements indexed from 0 to i(both inclusive) will always stay all 0\\'s or all 1\\'s.\\n\\n# Approach\\n- As we are checking pairs we can either start from index 0 and go upto index n-2 or start from index 1 and go upto index n-1.(I have chosen the first option)\\n- We initiate a \"ans\" varible with 0 and keep on adding the size of smaller subarray(right or left).\\n- The image below shows the pairs and the correspoing sub-array we choose to invert. The green highlighted cells are the one we choose to invert in given step.\\n![leet.jpg](https://assets.leetcode.com/users/images/a48d3ee2-9ac0-4408-9483-5b3573536bd7_1685250782.7351863.jpeg)\\n- The cost is simply calculated by taking the difference between the end and the start index of the sub-array. i.e. end-start+1\\nFor eg. in step 2, i=1 therefore left subarray size = i-0+1 = i+1 =2 and right subarray size = (n-1)-(i+1)+1 = n-i-1=6-1-1=4\\n# Complexity\\n- Time complexity:\\nWe iterate through the array only once. We don\\'t even actually flip the bits. Hence the time complexity is O(N).\\n\\n- Space complexity:\\nWe do not use any extra space. So the space complexity in O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(n-1):\\n            if s[i] != s[i+1]:\\n                ans += min(i+1, n-i-1)\\n        return ans\\n```\\nAlternate option for choosing pairs:\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(1,n):\\n            if s[i] != s[i-1]:\\n                ans += min(i, n-i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(n-1):\\n            if s[i] != s[i+1]:\\n                ans += min(i+1, n-i-1)\\n        return ans\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(1,n):\\n            if s[i] != s[i-1]:\\n                ans += min(i, n-i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574435,
                "title": "one-pass-dp-intuition-for-check-s-i-s-i-1",
                "content": "# Approach 1: Computing prefix and suffix\\n# Intuition\\nFor each index in the string, we can either modify the string before it or coming after it. We calculate the total cost of making the prefix and suffix to index `i` equal to the character at `i`, for each index `i` in s.\\n\\n\\n# Approach\\nWe calculate the prefix and suffix array by iterating over the string once. \\nFor prefix array, at each point where `s[i] != s[i-1]`, the cost to make the prefix string to `s[i]` equal to `s[i]` is given by the cost to make all characters in the prefix equal plus the cost to flip the prefix. \\ni.e `prefix[i] = prefix[i-1] + i`\\n\\nA similar computation is done for the suffix.\\n\\nAt the end, we simply traverse over the prefix and suffix, sum up the cost to make both parts, and choose the minimum.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<long long> pref(n, 0), suff(n, 0);\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] != s[i-1]) pref[i] = i + pref[i-1];\\n            else pref[i] = pref[i-1];\\n\\n            if (s[n-1-i] != s[n-i]) suff[n-1-i] = i + suff[n-i];\\n            else suff[n-1-i] = suff[n-i];\\n        }\\n        long long res = LLONG_MAX;\\n        for (int i = 0; i < n; i++) {\\n            res = min(res, pref[i] + suff[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Approach 2: One pass DP\\n# Intuition\\nThe key intuition here is that flipping any section of the string does not modify the cost. i.e `101` can become `010` but the amount of bit flips remains same. Or in other words, the minimum cost for a binary string `num`, is equal to that for `!num`. \\n\\nTherefore, at each point we can either flip the prefix or the suffix without actually knowing the cost to make all characters in the suffix equal.\\n\\n# Approach\\nConsider a dp array, where dp[i] denotes the minimum cost to make the first `i` characters in the string equal.\\n\\nWe can set `dp[0] = 0` as base case.\\n\\nNow, if we encounter an index `i` such that `s[i] != s[i-1]` then we can either flip the prefix with cost `i` or the suffix with cost `n-i`. We choose the minimum of these two.\\n\\nWe have essentially made the first `i+1` characters equal, while maintaining the cost required to make all characters of the remaining suffix equal. \\n\\nWe thus have the relation,\\n`dp[i] = dp[i-1] + min(i, n-i)` if `s[i] != s[i-1]` \\n`dp[i] = dp[i-1]` otherwise \\n\\nSince, we only rely on the previous value, we can avoid allocating space.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] != s[i-1]) {\\n                ans += min(i, n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nSolve first if you are stuck: https://leetcode.com/problems/flip-string-to-monotone-increasing/\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<long long> pref(n, 0), suff(n, 0);\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] != s[i-1]) pref[i] = i + pref[i-1];\\n            else pref[i] = pref[i-1];\\n\\n            if (s[n-1-i] != s[n-i]) suff[n-1-i] = i + suff[n-i];\\n            else suff[n-1-i] = suff[n-i];\\n        }\\n        long long res = LLONG_MAX;\\n        for (int i = 0; i < n; i++) {\\n            res = min(res, pref[i] + suff[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] != s[i-1]) {\\n                ans += min(i, n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584095,
                "title": "python-3-4-lines-w-explanation-t-m-94-70",
                "content": "Intuition:\\nThe problem can be restated as follows. Given an array of bits, perform this operation any number of times: partition the array in two, then flip all bits in one of those two partitions with the eventual goal of having the bits all of the same parity. Return the minimum number of bits needed to be flipped in total to accomplish this goal.\\n\\nIt should be clear that if two adjacent bits differ in parity, then one of the partitions must separate these two bits. Thus, a flip is required if and only if the partitions separates two adjacent bits differing in parity, and the flip should be executed on the partition with the lesser length. It should also be clear for partitions in the the left half of the string the minimum count of bits is`i`, and in the right half, the minimum count is`n - i`.\\n\\nHere\\'s the code:\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n\\n        n, ans = len(s), 0\\n \\n        for i in range(1,(n+1)//2): ans+= (s[i] != s[i-1])*i\\n        for i in range((n+1)//2,n): ans+= (s[i] != s[i-1])*(n-i)\\n            \\n        return ans \\n```\\n[https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/961289114/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`len(s)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n\\n        n, ans = len(s), 0\\n \\n        for i in range(1,(n+1)//2): ans+= (s[i] != s[i-1])*i\\n        for i in range((n+1)//2,n): ans+= (s[i] != s[i-1])*(n-i)\\n            \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570424,
                "title": "prefix-sum-suffix-sum-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long int ans1 = 0, sum = 0,ans2 = 0;\\n        vector<long long int> tmp1,tmp2;\\n        int i = 0, n = s.length(),j;\\n        while(i<n){\\n            j = i;\\n            while(i<n&&s[i]==s[j]){\\n                i++;\\n            }\\n            ans1 += sum;\\n            tmp1.push_back(ans1);\\n            sum = i;\\n        }\\n        reverse(s.begin(),s.end());\\n        i = 0,sum = 0;\\n        while(i<n){\\n            j = i;\\n            while(i<n&&s[i]==s[j]){\\n                i++;\\n            }\\n            ans2 += sum;\\n            tmp2.push_back(ans2);\\n            sum = i;\\n        }\\n        reverse(tmp2.begin(),tmp2.end());\\n        n = tmp1.size();\\n        long long int ans = LONG_LONG_MAX;\\n        for(i = 0; i <  n; i++){\\n            ans = min(ans,tmp1[i]+tmp2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long int ans1 = 0, sum = 0,ans2 = 0;\\n        vector<long long int> tmp1,tmp2;\\n        int i = 0, n = s.length(),j;\\n        while(i<n){\\n            j = i;\\n            while(i<n&&s[i]==s[j]){\\n                i++;\\n            }\\n            ans1 += sum;\\n            tmp1.push_back(ans1);\\n            sum = i;\\n        }\\n        reverse(s.begin(),s.end());\\n        i = 0,sum = 0;\\n        while(i<n){\\n            j = i;\\n            while(i<n&&s[i]==s[j]){\\n                i++;\\n            }\\n            ans2 += sum;\\n            tmp2.push_back(ans2);\\n            sum = i;\\n        }\\n        reverse(tmp2.begin(),tmp2.end());\\n        n = tmp1.size();\\n        long long int ans = LONG_LONG_MAX;\\n        for(i = 0; i <  n; i++){\\n            ans = min(ans,tmp1[i]+tmp2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570218,
                "title": "c-with-3-line-code-beginner",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1])\\n                ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1])\\n                ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570188,
                "title": "c-solution-5-line-code-100-beat",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574875,
                "title": "minimum-cost-to-make-all-elements-equal-tc-o-n-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        bool first = (s[0]==\\'0\\')? false:true;\\n        int n = s.size(),ctr=0;\\n        long long ans =0;\\n        for(int i=1; i<n; i++){\\n            bool curr = (s[i]==\\'0\\')? false:true;\\n            if(ctr%2)\\n                curr = curr^1;\\n            if(first != curr){\\n                if(i<=n/2)\\n                {\\n                    ans += i;\\n                    first = first^1;\\n                }\\n                else{\\n                    ans += (n-i);\\n                    ctr++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        bool first = (s[0]==\\'0\\')? false:true;\\n        int n = s.size(),ctr=0;\\n        long long ans =0;\\n        for(int i=1; i<n; i++){\\n            bool curr = (s[i]==\\'0\\')? false:true;\\n            if(ctr%2)\\n                curr = curr^1;\\n            if(first != curr){\\n                if(i<=n/2)\\n                {\\n                    ans += i;\\n                    first = first^1;\\n                }\\n                else{\\n                    ans += (n-i);\\n                    ctr++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570719,
                "title": "iterative-dp-prefix-and-suffix-dp-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the $i^{th}$ state, we have the following options:\\n- If the $i^{th}$ character is the same as the previous characters:\\n    1. We can either keep the $s[i]$ same as the previous characters. \\n    2. Or we can change $s[i]$, but then we also have to change the previous $i - 1$ characters.\\n- If the $i^{th}$ character is not the same as the previous characters:\\n    1. We can either change $s[i]$.\\n    2. Or we can change the previous $i - 1$ characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe $dp$ that we calculate using the above algorithm will only give us the optimal answer if we do only prefix operations. But the problems says we are allowed to do suffix operations as well. Hence we have to calculate a $dp2$ using the same algorithm, the only difference being we will calculate it from the end of the string.\\n\\nAfter these $dp$ and $dp2$ arrays are ready, for each $i$, we take the minimum of $dp[i]$ $+$ $dp2[i + 1]$, since we are looking for the most optimal solution. Also, since the characters can be either all $0$ or all $1$, hence the $dp$ and $dp2$ will have $2$ substates at the $i^{th}$ state.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(n, vector<long long>(2, 1e9));\\n        vector<vector<long long>> dp2 = dp;\\n        if(s[0] == \\'0\\'){\\n            dp[0][0] = 0;\\n            dp[0][1] = 1;\\n        }else{\\n            dp[0][0] = 1;\\n            dp[0][1] = 0;\\n        }\\n        \\n        for(int i = 1; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                dp[i][0] = min({dp[i - 1][0], dp[i - 1][1] + i});\\n                dp[i][1] = min({dp[i - 1][1] + 2 * i + 1, dp[i - 1][0] + i + 1});\\n            }else{\\n                dp[i][0] = min({dp[i - 1][0] + 2 * i + 1, dp[i - 1][1] + i + 1});\\n                dp[i][1] = min({dp[i - 1][1], dp[i - 1][0] + i});\\n            }\\n        }\\n        \\n        reverse(s.begin(), s.end());\\n        if(s[0] == \\'0\\'){\\n            dp2[0][0] = 0;\\n            dp2[0][1] = 1;\\n        }else{\\n            dp2[0][0] = 1;\\n            dp2[0][1] = 0;\\n        }\\n        \\n        for(int i = 1; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                dp2[i][0] = min({dp2[i - 1][0], dp2[i - 1][1] + i});\\n                dp2[i][1] = min({dp2[i - 1][1] + 2 * i + 1, dp2[i - 1][0] + i + 1});\\n            }else{\\n                dp2[i][0] = min({dp2[i - 1][0] + 2 * i + 1, dp2[i - 1][1] + i + 1});\\n                dp2[i][1] = min({dp2[i - 1][1], dp2[i - 1][0] + i});\\n            }\\n        }\\n        reverse(dp2.begin(), dp2.end());\\n        long long ans = 1e12;\\n        for(int i = 0; i < n - 1; i++){\\n            ans = min({ans, dp[i][0] + dp2[i + 1][0], dp[i][1] + dp2[i + 1][1]});\\n        }\\n        \\n        return (ans == 1e12 ? 0 : ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        vector<vector<long long>> dp(n, vector<long long>(2, 1e9));\\n        vector<vector<long long>> dp2 = dp;\\n        if(s[0] == \\'0\\'){\\n            dp[0][0] = 0;\\n            dp[0][1] = 1;\\n        }else{\\n            dp[0][0] = 1;\\n            dp[0][1] = 0;\\n        }\\n        \\n        for(int i = 1; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                dp[i][0] = min({dp[i - 1][0], dp[i - 1][1] + i});\\n                dp[i][1] = min({dp[i - 1][1] + 2 * i + 1, dp[i - 1][0] + i + 1});\\n            }else{\\n                dp[i][0] = min({dp[i - 1][0] + 2 * i + 1, dp[i - 1][1] + i + 1});\\n                dp[i][1] = min({dp[i - 1][1], dp[i - 1][0] + i});\\n            }\\n        }\\n        \\n        reverse(s.begin(), s.end());\\n        if(s[0] == \\'0\\'){\\n            dp2[0][0] = 0;\\n            dp2[0][1] = 1;\\n        }else{\\n            dp2[0][0] = 1;\\n            dp2[0][1] = 0;\\n        }\\n        \\n        for(int i = 1; i < n; i++){\\n            if(s[i] == \\'0\\'){\\n                dp2[i][0] = min({dp2[i - 1][0], dp2[i - 1][1] + i});\\n                dp2[i][1] = min({dp2[i - 1][1] + 2 * i + 1, dp2[i - 1][0] + i + 1});\\n            }else{\\n                dp2[i][0] = min({dp2[i - 1][0] + 2 * i + 1, dp2[i - 1][1] + i + 1});\\n                dp2[i][1] = min({dp2[i - 1][1], dp2[i - 1][0] + i});\\n            }\\n        }\\n        reverse(dp2.begin(), dp2.end());\\n        long long ans = 1e12;\\n        for(int i = 0; i < n - 1; i++){\\n            ans = min({ans, dp[i][0] + dp2[i + 1][0], dp[i][1] + dp2[i + 1][1]});\\n        }\\n        \\n        return (ans == 1e12 ? 0 : ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570174,
                "title": "prefix",
                "content": "\\n**<<<<<Upvote**\\n\\n\\n1st Method\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590804,
                "title": "simple-explanation-of-why-greedy-starting-with-backtracking-python",
                "content": "# Intuition\\nThis problem is the third problem of Weekly Contest 347. Many of you guys might be like me. When you first see it, you might have no idea why we can use this problem using the Greedy approach. So let\\'s start with a simple Backtracking algorithm.\\n\\n# Approach\\nThink of this problem with the backtracking algorithm. Starting from left to right, we can compare the char at each index with the char immediately preceeding it, and assume all chars preceeding it are the same (This is the essential idea behind backtracking). Consider this string ``000101``. At index ``i = 2`` and we compare the the char ``0`` with the char ``0`` before it. They are the same, so we move on to index 3 with the addtional cost ``backtracking(i + 1)``. At index 3, the char ``1`` is different from the char ``0`` before it. According to the question, there are 2 ways to make them the same. The first approach is to flip every char before index ``i`` (since they are the same) to make them equal with the cost ``i - 1 + 1``, and we can move on to the next char. So the total additional cost for this approach is ``i + backtracking(i + 1)``. For the second approach, we can flip the char at index ``i`` and every char behind it with the cost ``n - i`` to make the char at index ``i`` equals to all the char preceeding it, with the additional cost ``n - i + backtracking(i + 1)``. The backtracking code is provide below.\\n\\n```\\ndef minimumCost(self, s: str) -> int:\\n    def backtracking(i):\\n        if i == len(s):\\n            return 0\\n        if s[i] == s[i-1]:\\n            return backtracking(i+1)\\n        leftcost = i + backtracking(i+1)\\n        rightcost = len(s) - i + backtracking(i+1)\\n        return min(leftcost, rightcost)\\n    return backtracking(1)\\n```\\nEssentially, we are calling ``backtracking(i + 1)`` in every step, no matter if the char at ``i`` is equal to the char at ``i - 1`` and what approach we choose to make them equal if they are different. This makes this backtracking approach essentially greedy since the only choice we make on whether to use the first approach or the second approach is to choose the smaller value between ``i`` and ``n - i``, or in Python code, ``min(i, n-i)``. This leads to a simpler, much quicker Greedy code written in the following.\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ where ``n == length of s``. Since we are iterating the string ``s`` once in the greedy approach.\\n\\n- Space complexity:\\n$$O(1)$$ since we are not using any extra memory.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        n = len(s)\\n        for i in range(1, n):\\n            if s[i] != s[i-1]:\\n                cost += min(i, n-i)\\n        return cost\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minimumCost(self, s: str) -> int:\\n    def backtracking(i):\\n        if i == len(s):\\n            return 0\\n        if s[i] == s[i-1]:\\n            return backtracking(i+1)\\n        leftcost = i + backtracking(i+1)\\n        rightcost = len(s) - i + backtracking(i+1)\\n        return min(leftcost, rightcost)\\n    return backtracking(1)\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        n = len(s)\\n        for i in range(1, n):\\n            if s[i] != s[i-1]:\\n                cost += min(i, n-i)\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572043,
                "title": "c-greedy-recursion-memoization-intuition-approach-explained",
                "content": "Please upvote this post if you find it useful\\n# Intuition\\n    0  1  0  1  0  1\\n    i i+1               not matched: ans += min(1, 5) => 1\\n    1  1  0  1  0  1\\n       i i+1            not matched: ans += min(2, 4) => 2\\n    0  0  0  1  0  1\\n          i i+1         not matched: ans += min(3, 3) => 3\\n    1  1  1  1  0  1\\n             i  i+1     not matched: ans += min(4, 2) => 2\\n    1  1  1  1  1  0\\n                i i+1   not matched: ans += min(5, 1) => 1\\n    1  1  1  1  1  1\\n    -----------------   ans = 1+2+3+2+1 = 9\\n\\n---\\n\\n# Approach:\\nSo, see we will go to every index(i) and check whether the character of that index is same as the previous character. If they are same then just go forward, else we have two choices:\\n- flip 0 to the previous index(i-1) that becomes same to s[i]\\n- flip current index(i) to n-1\\n\\nIn case1: cost will be added :  (i-1)+1 = i\\nIn case2: cost will be added :  (n-i)\\n\\nFind the minimum cost using recursion.\\n\\n# Code 1: Recursion + Memoization\\n```\\nclass Solution {\\npublic:\\n    long long helper(int i, int n, string &s, char lastChar, vector<vector<long long>> &dp){\\n        if(i==n){\\n            return 0;\\n        }\\n        if(dp[i][lastChar-\\'0\\'] != -1) return dp[i][lastChar-\\'0\\'];\\n\\n        if(s[i]==lastChar){\\n            return dp[i][lastChar-\\'0\\'] = helper(i+1, n, s, lastChar, dp);\\n        }\\n        else{\\n            return dp[i][lastChar-\\'0\\'] = min(i + helper(i+1, n, s, s[i], dp), n-i + helper(i+1, n, s, s[i], dp));\\n        }\\n    }\\n    long long minimumCost(string s) {\\n        if(s.size()==1){\\n            return 0;\\n        }\\n        int n = s.size();   vector<vector<long long>> dp(n, vector<long long>(2, -1));\\n        return helper(1, s.size(), s, s[0], dp);        \\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code 2: Greedy\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;    int n = s.size();\\n        for(int i=0; i<n-1; i++){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(int i, int n, string &s, char lastChar, vector<vector<long long>> &dp){\\n        if(i==n){\\n            return 0;\\n        }\\n        if(dp[i][lastChar-\\'0\\'] != -1) return dp[i][lastChar-\\'0\\'];\\n\\n        if(s[i]==lastChar){\\n            return dp[i][lastChar-\\'0\\'] = helper(i+1, n, s, lastChar, dp);\\n        }\\n        else{\\n            return dp[i][lastChar-\\'0\\'] = min(i + helper(i+1, n, s, s[i], dp), n-i + helper(i+1, n, s, s[i], dp));\\n        }\\n    }\\n    long long minimumCost(string s) {\\n        if(s.size()==1){\\n            return 0;\\n        }\\n        int n = s.size();   vector<vector<long long>> dp(n, vector<long long>(2, -1));\\n        return helper(1, s.size(), s, s[0], dp);        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;    int n = s.size();\\n        for(int i=0; i<n-1; i++){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571110,
                "title": "java-greedy",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLoop from head, every time you find next bit different with prev one, you have to invert, just invert with the lowest cost.\\n\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic long minimumCost(String s) {\\n    long res = 0l;\\n    for (int i = 1, n = s.length(); i < n; i++) {\\n        if (s.charAt(i) != s.charAt(i - 1)) res += Math.min(i, n - i);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long minimumCost(String s) {\\n    long res = 0l;\\n    for (int i = 1, n = s.length(); i < n; i++) {\\n        if (s.charAt(i) != s.charAt(i - 1)) res += Math.min(i, n - i);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570922,
                "title": "easy-c-solution-o-n-greedy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1]){\\n                int prefix=i+1;\\n                int sufix=s.size()-1-i;\\n                ans+=min(prefix,sufix);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1]){\\n                int prefix=i+1;\\n                int sufix=s.size()-1-i;\\n                ans+=min(prefix,sufix);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570726,
                "title": "prefix-and-suffix-sum-based-c-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n    int length = s.size();  \\n    vector<ll> prefixSums(length, 0);  \\n    vector<ll> suffixSums(length, 0);  \\n    ll ans =LONG_LONG_MAX;\\n    for (int i = 1; i < length; i += 1) {\\n        prefixSums[i] = prefixSums[i - 1] + (s[i - 1] != s[i] ? i : 0);\\n    }\\n    for (int i = length - 2; i >= 0; i -= 1) {\\n        suffixSums[i] = suffixSums[i + 1] + (s[i] != s[i + 1] ? (length - i - 1) : 0);\\n    }\\n\\n    ll res = suffixSums[0];  \\n\\n    // Iterate through the string to calculate the minimum cost\\n    for (int i = 0; i < length; i += 1) {\\n        ans =min(ans, prefixSums[i] + res);\\n        if (i + 1 < length) {\\n            res -= (length - i - 1) * (s[i] != s[i + 1]);\\n        }\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n    int length = s.size();  \\n    vector<ll> prefixSums(length, 0);  \\n    vector<ll> suffixSums(length, 0);  \\n    ll ans =LONG_LONG_MAX;\\n    for (int i = 1; i < length; i += 1) {\\n        prefixSums[i] = prefixSums[i - 1] + (s[i - 1] != s[i] ? i : 0);\\n    }\\n    for (int i = length - 2; i >= 0; i -= 1) {\\n        suffixSums[i] = suffixSums[i + 1] + (s[i] != s[i + 1] ? (length - i - 1) : 0);\\n    }\\n\\n    ll res = suffixSums[0];  \\n\\n    // Iterate through the string to calculate the minimum cost\\n    for (int i = 0; i < length; i += 1) {\\n        ans =min(ans, prefixSums[i] + res);\\n        if (i + 1 < length) {\\n            res -= (length - i - 1) * (s[i] != s[i + 1]);\\n        }\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570220,
                "title": "explained-3-liner-c-easiest-solution",
                "content": "# Approach\\nFor every pair of unequal adjacent characters, we calculate the cost of transforming all characters before or after them to match the adjacent character. \\nThe total cost is accumulated and returned as the minimum cost.\\n# Code\\n```\\nlong long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.length();\\n        for(int i=0;i<s.length()-1;i++) \\n            if(s[i]!=s[i+1]) //If a character is not equal to its adjacent\\n                ans+=min(i+1, n-(i+1)); //Take min to check which operation will be cheaper\\n        return ans;\\n    }\\n```\\n# \\u2B06\\uFE0F **PLEASE UPVOTE IF YOU UNDERSTOOD!** \\u2764\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.length();\\n        for(int i=0;i<s.length()-1;i++) \\n            if(s[i]!=s[i+1]) //If a character is not equal to its adjacent\\n                ans+=min(i+1, n-(i+1)); //Take min to check which operation will be cheaper\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570192,
                "title": "c-easy-to-understand-5-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        long long ans=0;\\n        for(int i=0; i<n-1; i++) {\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570181,
                "title": "python-elegant-dp-solution",
                "content": "```\\ndef minimumCost(self, s: str) -> int:\\n\\tdef check(strs):\\n\\t\\tdp0, dp1 = [0]+[float(\\'inf\\')]*(len(strs)), [0]+[float(\\'inf\\')]*(len(strs))\\n\\t\\tfor i in range(len(strs)):\\n\\t\\t\\tif strs[i]==\\'0\\':\\n\\t\\t\\t\\tdp0[i+1] = dp0[i]\\n\\t\\t\\t\\tdp1[i+1] = min(dp1[i+1], dp0[i]+i+1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp0[i+1] = min(dp0[i+1], dp1[i]+i+1)      \\n\\t\\t\\t\\tdp1[i+1] = dp1[i]\\n\\t\\treturn dp0[-1], dp1[-1]\\n\\tx0, x1 = check(s[:len(s)//2])\\n\\ty0, y1 = check(s[len(s)//2:][::-1])\\n\\treturn min(x0+y0, x1+y1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumCost(self, s: str) -> int:\\n\\tdef check(strs):\\n\\t\\tdp0, dp1 = [0]+[float(\\'inf\\')]*(len(strs)), [0]+[float(\\'inf\\')]*(len(strs))\\n\\t\\tfor i in range(len(strs)):\\n\\t\\t\\tif strs[i]==\\'0\\':\\n\\t\\t\\t\\tdp0[i+1] = dp0[i]\\n\\t\\t\\t\\tdp1[i+1] = min(dp1[i+1], dp0[i]+i+1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdp0[i+1] = min(dp0[i+1], dp1[i]+i+1)      \\n\\t\\t\\t\\tdp1[i+1] = dp1[i]\\n\\t\\treturn dp0[-1], dp1[-1]\\n\\tx0, x1 = check(s[:len(s)//2])\\n\\ty0, y1 = check(s[len(s)//2:][::-1])\\n\\treturn min(x0+y0, x1+y1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4034749,
                "title": "greedy-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry converting the string to all 1\\'s or all 0\\'s and return the minimum operations required to do so.\\n\\n# Complexity\\n- Time complexity:O(2*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nlong long change_to(string s,char from,char to)\\n{\\n    long long n = s.size(),count = 0,ans = 0;\\n    int i = 0;\\n    while(i<n)\\n    {\\n        while(i<n && s[i]==from)\\n        {\\n            i++;\\n            count++;\\n        }\\n        if((s[i]==to || i>=n-1)&& count>0)\\n        {\\n            int rem = i-count;\\n            ans = ans+i+rem;\\n            count = 0;\\n        }\\n        i++;\\n    }\\n    return ans;\\n}\\nlong long minimumCost(string s)\\n   {\\n       long long n = s.size(),ans1 = 0,ans2 = 0;\\n       long long len = (n)/2;\\n       string s1 = s.substr(0,len),s2 = s.substr(n%2==0 ? n/2 : n/2+1,len);\\n       reverse(s2.begin(),s2.end());\\n\\n        ans1 = change_to(s1,\\'0\\',\\'1\\')+change_to(s2,\\'0\\',\\'1\\');\\n        ans2 = change_to(s1,\\'1\\',\\'0\\')+change_to(s2,\\'1\\',\\'0\\');\\n\\n        if(n%2!=0 && s[n/2]==\\'1\\') ans2+=n;\\n        if(n%2!=0 && s[n/2]==\\'0\\') ans1+=n;\\n        \\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nlong long change_to(string s,char from,char to)\\n{\\n    long long n = s.size(),count = 0,ans = 0;\\n    int i = 0;\\n    while(i<n)\\n    {\\n        while(i<n && s[i]==from)\\n        {\\n            i++;\\n            count++;\\n        }\\n        if((s[i]==to || i>=n-1)&& count>0)\\n        {\\n            int rem = i-count;\\n            ans = ans+i+rem;\\n            count = 0;\\n        }\\n        i++;\\n    }\\n    return ans;\\n}\\nlong long minimumCost(string s)\\n   {\\n       long long n = s.size(),ans1 = 0,ans2 = 0;\\n       long long len = (n)/2;\\n       string s1 = s.substr(0,len),s2 = s.substr(n%2==0 ? n/2 : n/2+1,len);\\n       reverse(s2.begin(),s2.end());\\n\\n        ans1 = change_to(s1,\\'0\\',\\'1\\')+change_to(s2,\\'0\\',\\'1\\');\\n        ans2 = change_to(s1,\\'1\\',\\'0\\')+change_to(s2,\\'1\\',\\'0\\');\\n\\n        if(n%2!=0 && s[n/2]==\\'1\\') ans2+=n;\\n        if(n%2!=0 && s[n/2]==\\'0\\') ans1+=n;\\n        \\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589361,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long firstHalf(string &s , char k){\\n        long long ans = 0;\\n        int n = s.length();\\n        bool flip = false;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == k){\\n                if(flip){\\n                    ans += i+1;\\n                    flip = false;\\n                }\\n            }\\n            else{\\n                if(!flip){\\n                    ans += i+1;\\n                    flip = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    long long secondHalf(string &s , char k, int l, int mid){\\n        long long ans = 0;\\n        int n = s.length();\\n        bool flip = false;\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i] == k){\\n                if(flip){\\n                    ans += (l - (mid+i));\\n                    flip = false;\\n                }\\n            }\\n            else{\\n                if(!flip){\\n                    ans += (l - (mid + i));\\n                    flip = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n\\n        int mid = n/2;\\n        string s1 = s.substr(0,mid);\\n        string s2 = s.substr(mid, n-mid);\\n        // cout << s1 << \" \" << s2 << endl;\\n        long long a = firstHalf(s1, \\'0\\');\\n        long long b = secondHalf(s2, \\'0\\', n , mid);\\n        // cout << a << \" \" << b << endl;\\n        long long c = firstHalf(s1, \\'1\\');\\n        long long d = secondHalf(s2, \\'1\\', n , mid);\\n        // cout << c << \" \" << d << endl;\\n        return min(a+b , c+d);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long firstHalf(string &s , char k){\\n        long long ans = 0;\\n        int n = s.length();\\n        bool flip = false;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == k){\\n                if(flip){\\n                    ans += i+1;\\n                    flip = false;\\n                }\\n            }\\n            else{\\n                if(!flip){\\n                    ans += i+1;\\n                    flip = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    long long secondHalf(string &s , char k, int l, int mid){\\n        long long ans = 0;\\n        int n = s.length();\\n        bool flip = false;\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i] == k){\\n                if(flip){\\n                    ans += (l - (mid+i));\\n                    flip = false;\\n                }\\n            }\\n            else{\\n                if(!flip){\\n                    ans += (l - (mid + i));\\n                    flip = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n\\n        int mid = n/2;\\n        string s1 = s.substr(0,mid);\\n        string s2 = s.substr(mid, n-mid);\\n        // cout << s1 << \" \" << s2 << endl;\\n        long long a = firstHalf(s1, \\'0\\');\\n        long long b = secondHalf(s2, \\'0\\', n , mid);\\n        // cout << a << \" \" << b << endl;\\n        long long c = firstHalf(s1, \\'1\\');\\n        long long d = secondHalf(s2, \\'1\\', n , mid);\\n        // cout << c << \" \" << d << endl;\\n        return min(a+b , c+d);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3577768,
                "title": "simple-iterative-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we need to declare a variable mincost which defines the minimum cost for swaping the elements\\nthen we need to check if  s[i] != s[i+1] then it compares i + 1, representing the distance from the start of the string to the current character, and n - i - 1, representing the distance from the current character from the end of the string. The minimum of these two values represents the minimum cost of the swap.\\nmincost variable is incremented for every swap.\\nthen we need to return the mincost.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        long long mincost = 0;\\n        \\n        for (int i = 0; i < n - 1; ++i) {\\n            if (s[i] != s[i + 1]) {\\n                mincost += min(i + 1, n - i - 1);\\n            }\\n        }\\n        \\n        return mincost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        long long mincost = 0;\\n        \\n        for (int i = 0; i < n - 1; ++i) {\\n            if (s[i] != s[i + 1]) {\\n                mincost += min(i + 1, n - i - 1);\\n            }\\n        }\\n        \\n        return mincost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575708,
                "title": "using-prefix-and-suffix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOverthinking \\nbecause I could not think of a one liner solution\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n1) I created a prefix array which contains the cost i would spend if i change my array from the left end to this element.\\nEx: 01000(1)0110\\nIf i am at the bracket element and i want to change it (using the left side) then it becomes 0 then in the left i would change another 1 to get all the same elements.\\n>Like if i consider that element and want to change it by using the left side then it would change (1 current ele)->(next 0 to the left) -> (next 1 to the left) -> (next 0 to the left) -> so on..\\n>After using the left operation for that element now i would do the same from the same parity element in the right.\\n\\n2) The suffix has the same logic as the prefix but the change i will make would be in the right direction of the array.\\nEx: 0100(1)1000100\\nIf i am at the bracket element and i want to change it (using the right side) then i becomes 0 , then i would change the next 1 to the right , then next 0 to the right and so on...\\n\\n>Inshort:Prefix contains the cost of alternate 0\\'s and 1\\'s (the last occurance) from the current element in the left direction\\nlike 0100(1) cost would be (5th element)+(4th element)+(2nd element)+(1st element)\\nSuffix Contains the cost of alternate 0\\'s and 1\\'s (the first occurance) from the current element in the right direction.\\nlike 10(1)1001 cost would be (3rd + 5th + 7th)\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        int cnt = count(s.begin(),s.end(),\\'0\\');\\n        if(cnt == 0 || cnt == n)return 0;\\n        long long pre[2][n];\\n        long long suf[2][n];\\n        memset(pre,0,sizeof(pre));\\n        memset(suf,0,sizeof(suf));\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'0\\'){\\n                pre[1][i] = i == 0 ? 0:pre[1][i - 1];\\n                pre[0][i] = (i + 1) + pre[1][i];\\n            }\\n            else{\\n                pre[0][i] = i == 0 ? 0:pre[0][i - 1];\\n                pre[1][i] = (i + 1) + pre[0][i];\\n            }\\n        }\\n        \\n        for(int i = n - 1;i>=0;i--){\\n            if(s[i] == \\'0\\'){\\n                suf[1][i] = i == n - 1 ? 0:suf[1][i + 1];\\n                suf[0][i] = (n - i) + suf[1][i];\\n            }\\n            else{\\n                suf[0][i] = i == n - 1 ? 0:suf[0][i + 1];\\n                suf[1][i] = (n - i) + suf[0][i];\\n            }\\n        }\\n        long long ans = LLONG_MAX;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'1\\'){\\n                long long left = pre[1][i] + (i == n - 1 ? 0:suf[1][i + 1]);\\n                long long right = suf[1][i] + (i == 0 ? 0:pre[1][i - 1]);\\n                ans = min({ans,left,right});\\n            }\\n            else{\\n                long long left = pre[0][i] + (i == n - 1 ? 0:suf[0][i + 1]);\\n                long long right = suf[0][i] + (i == 0 ? 0:pre[0][i - 1]);\\n                ans = min({ans,left,right});\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        int cnt = count(s.begin(),s.end(),\\'0\\');\\n        if(cnt == 0 || cnt == n)return 0;\\n        long long pre[2][n];\\n        long long suf[2][n];\\n        memset(pre,0,sizeof(pre));\\n        memset(suf,0,sizeof(suf));\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'0\\'){\\n                pre[1][i] = i == 0 ? 0:pre[1][i - 1];\\n                pre[0][i] = (i + 1) + pre[1][i];\\n            }\\n            else{\\n                pre[0][i] = i == 0 ? 0:pre[0][i - 1];\\n                pre[1][i] = (i + 1) + pre[0][i];\\n            }\\n        }\\n        \\n        for(int i = n - 1;i>=0;i--){\\n            if(s[i] == \\'0\\'){\\n                suf[1][i] = i == n - 1 ? 0:suf[1][i + 1];\\n                suf[0][i] = (n - i) + suf[1][i];\\n            }\\n            else{\\n                suf[0][i] = i == n - 1 ? 0:suf[0][i + 1];\\n                suf[1][i] = (n - i) + suf[0][i];\\n            }\\n        }\\n        long long ans = LLONG_MAX;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'1\\'){\\n                long long left = pre[1][i] + (i == n - 1 ? 0:suf[1][i + 1]);\\n                long long right = suf[1][i] + (i == 0 ? 0:pre[1][i - 1]);\\n                ans = min({ans,left,right});\\n            }\\n            else{\\n                long long left = pre[0][i] + (i == n - 1 ? 0:suf[0][i + 1]);\\n                long long right = suf[0][i] + (i == 0 ? 0:pre[0][i - 1]);\\n                ans = min({ans,left,right});\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571253,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        return sum(min(i,len(s)-i) for i in range(1,len(s)) if s[i]!=s[i-1])\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        return sum(min(i,len(s)-i) for i in range(1,len(s)) if s[i]!=s[i-1])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570946,
                "title": "simple-greedy-solution-with-bonus-1-liner",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        s1, s2 = list(s[:n//2]), list(s[n//2:][::-1])\\n        r = 0\\n        for i in range(len(s1)-1):\\n            if s1[i] != s1[i+1]:\\n                r+=(i+1)\\n                s1[i] = s1[i+1]\\n        for i in range(len(s2)-1):\\n            if s2[i] != s2[i+1]:\\n                r+=(i+1)\\n                s2[i] = s2[i+1]\\n        return r+len(s1) if s1 and s1[-1] != s2[-1] else r\\n```\\nOne-liner (Technically 2 liner but heh):\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        return sum(min(n-i-1, i+1) for i in range(n-1) if s[i] != s[i+1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        s1, s2 = list(s[:n//2]), list(s[n//2:][::-1])\\n        r = 0\\n        for i in range(len(s1)-1):\\n            if s1[i] != s1[i+1]:\\n                r+=(i+1)\\n                s1[i] = s1[i+1]\\n        for i in range(len(s2)-1):\\n            if s2[i] != s2[i+1]:\\n                r+=(i+1)\\n                s2[i] = s2[i+1]\\n        return r+len(s1) if s1 and s1[-1] != s2[-1] else r\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        return sum(min(n-i-1, i+1) for i in range(n-1) if s[i] != s[i+1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570941,
                "title": "easy-java-fast-100",
                "content": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)!=s.charAt(i+1)){\\n                ans+=Math.min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)!=s.charAt(i+1)){\\n                ans+=Math.min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570904,
                "title": "python3-easy-one-pass-greedy-solution-with-clear-readable-explanation",
                "content": "# Intuition\\nAssume the string is all equal up to index i. At index i+1, if the character is different from i, then you either flip all the previous characters up to index i to make it the same as i+1, or flip the string from i+1 onwards to make it equal to index i. Continue this process until you are done.\\n\\nFor example, for the string 0011:\\n\\nAt index 2: there is a discrepancy with index 1 (0). You can either flip all the characters up to index 1 (with cost 2), or flip the suffix from index 2 (with cost 2) to resolve this discrepancy.\\n\\nContinue doing this for all discrepancies. As you iterate to the next index, you have maintained the invariant that all characters are equal up to index i.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution:\\n                \\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        for idx in range(1, len(s)):\\n            if s[idx-1] != s[idx]:\\n                cost += min(idx, len(s) - idx)\\n        return cost\\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n                \\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        for idx in range(1, len(s)):\\n            if s[idx-1] != s[idx]:\\n                cost += min(idx, len(s) - idx)\\n        return cost\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570814,
                "title": "python-single-pass-greedy-approach-with-explanation-o-n-beats-100",
                "content": "## **Approach** :\\n\\nCheck if `s[i-1]` != `s[i]` \\n\\nIf so, you can \\n* either flip the bits in the prefix of i `[0:i+1]` with cost `i`\\n* or flip the bits in the suffix of i `[i:n]` with cost `n-i`\\n \\nto make the adjacent bits equal. Choose minimum cost among them.\\n\\n\\n## **Complexity** : \\n* **Time Complexity** : `O(n)`\\n* **Space Complexity** : `O(1)`\\n\\n## **Solution** :\\nPython\\n```python\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(n-1,0,-1):\\n            if s[i-1] != s[i]: \\n\\t\\t\\t\\tans += min(i,n-i)               \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n        for i in range(n-1,0,-1):\\n            if s[i-1] != s[i]: \\n\\t\\t\\t\\tans += min(i,n-i)               \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570635,
                "title": "very-easy-c-100-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long result = 0;\\n        // Iterate over the string\\n        for (int i = 0; i + 1 < s.size(); i++) {\\n            // Check if the current character is different from the next character\\n            if (s[i] != s[i + 1]) {\\n                // Calculate the cost and add it to the result\\n                result += min(i + 1, (int)s.size() - i - 1);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long result = 0;\\n        // Iterate over the string\\n        for (int i = 0; i + 1 < s.size(); i++) {\\n            // Check if the current character is different from the next character\\n            if (s[i] != s[i + 1]) {\\n                // Calculate the cost and add it to the result\\n                result += min(i + 1, (int)s.size() - i - 1);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570393,
                "title": "1-line-python-solution",
                "content": "# Intuition\\n\\nThe minimum cost can be found using a greedy approach based on each two-character substring.\\n\\n# Approach\\n\\nFocus on one two-character substring at a time. Assume the preceding characters match the first character and the following characters match the second.\\n\\nCase 1: ...000 **00** 000...\\n\\nSince all characters are equal, no operations are required.\\n\\nCase 2: ...000 **01** 111...\\n\\nSince the characters are not equal, an operation must be performed.\\n\\nSuppose the second character, **1**, has index `i`. \\n* The cost to inverse all the 0 bits would be `i - 1 + 1` where `i - 1` gives us the index of the first character, **0**, and the `+ 1` is the cost addend from the problem description.\\n* The cost to inverse all the 1 bits is simply `i`: the cost of inverting `i` to `n - i` as described in the description.\\n\\nThe remaining cases are `\"11\"` which follows the logic of Case 1 and `\"10\"` which follows the logic of Case 2.\\n\\n# Example\\n\\nUsing `\"0011\"` as an example.\\n\\nThe total minimum cost is built independently from the two-character cases described in the **Approach** section.\\n\\nSubstring 1: **00**11\\n\\n* The cost to make the strings equal is 0 as they are already equal.\\n* There are no preceding characters and thus there is no cost to make it equal to the first character, **0**.\\n* The succeeding characters, **11**, will have their cost to make equal to the second character, **0**, computed in the following iterations.\\n\\nSubstring 2: 0**01**1\\n\\n* The cost to make the strings equal is `min(i, len(s) - i) = min(2, 2) = 2`.\\n* The preceding characters, **0** has already had its cost to make equal to the first character, **0**, computed.\\n* As before, the cost to make the succeeding characters, **1**, equal to the second character, **1** will be computed in the following iterations.\\n\\nSubstring 3: 00**11**\\n\\n* Again, the cost to make the strings equal is 0 as they are already equal.\\n* As before the preceding characters, **00**, have had their minmum cost to make equal to the first character, **1**, computed.\\n* There are no following characters and thus have no cost to make equal to the second character, **1**.\\n\\n# Complexity\\n\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n\\nThe minimum cost of each operation on a pair is considered.\\n* Case 1: The pairs that are equal are filtered out.\\n* Case 2: The minimum operation cost to make all characters equal is calculated.\\n  * The first operation type is simplified from `i - 1 + 1` to `i`.\\n\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        return sum(\\n            min(i, len(s) - i)\\n            for i, (a, b) in enumerate(pairwise(s), 1)\\n            if a != b\\n        )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        return sum(\\n            min(i, len(s) - i)\\n            for i, (a, b) in enumerate(pairwise(s), 1)\\n            if a != b\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570388,
                "title": "easy-java-solution-100-faster",
                "content": "- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n     \\n        int len=s.length()-1;\\n        long count=0;\\n        for(int m=0;m<len;m++)\\n        {\\n            if(s.charAt(m)!=s.charAt(m+1)) count+=Math.min(len-m,m+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n     \\n        int len=s.length()-1;\\n        long count=0;\\n        for(int m=0;m<len;m++)\\n        {\\n            if(s.charAt(m)!=s.charAt(m+1)) count+=Math.min(len-m,m+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570387,
                "title": "python-simple-python-solution-100-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 212 ms, faster than 100.00% of Python3 online submissions for Minimum Cost to Make All Characters Equal.\\n# Memory Usage: 17.4 MB, less than 37.50% of Python3 online submissions for Minimum Cost to Make All Characters Equal.\\n![image](https://assets.leetcode.com/users/images/e4eaf582-9bd1-4eb1-86de-aa29bf584f59_1685247274.0060494.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef minimumCost(self, s: str) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tlength = len(s)\\n\\n\\t\\t\\tfor index in range(1 ,  length):\\n\\n\\t\\t\\t\\tif s[index - 1] == s[index]:\\n\\n\\t\\t\\t\\t\\tresult = result + 0\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tresult = result + min(index , length - index)\\n\\n\\t\\t\\treturn result\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 212 ms, faster than 100.00% of Python3 online submissions for Minimum Cost to Make All Characters Equal.\\n# Memory Usage: 17.4 MB, less than 37.50% of Python3 online submissions for Minimum Cost to Make All Characters Equal.\\n![image](https://assets.leetcode.com/users/images/e4eaf582-9bd1-4eb1-86de-aa29bf584f59_1685247274.0060494.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef minimumCost(self, s: str) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tlength = len(s)\\n\\n\\t\\t\\tfor index in range(1 ,  length):\\n\\n\\t\\t\\t\\tif s[index - 1] == s[index]:\\n\\n\\t\\t\\t\\t\\tresult = result + 0\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tresult = result + min(index , length - index)\\n\\n\\t\\t\\treturn result\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3570379,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to determine the minimum cost required to make all characters in the string s equal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code uses a simple approach to calculate the minimum cost. It iterates through the string and checks adjacent character pairs. Whenever a pair of characters is different, it increments the cost by the minimum value between the indices of the characters.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through the string once, so the time complexity is O(n), where n is the length of the string s.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The code uses a constant amount of extra space, so the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        // Iterate over the string\\n        for (int i = 0; i + 1 < s.size(); i++) {\\n            // Check if the current character is different from the next character\\n            if (s[i] != s[i + 1]) {\\n                // Calculate the cost and add it to the answer\\n                ans += min(i + 1, (int)s.size() - i - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        // Iterate over the string\\n        for (int i = 0; i + 1 < s.size(); i++) {\\n            // Check if the current character is different from the next character\\n            if (s[i] != s[i + 1]) {\\n                // Calculate the cost and add it to the answer\\n                ans += min(i + 1, (int)s.size() - i - 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570346,
                "title": "python-simple-easy-two-pointer-approach-beat-98",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        mid = (n-1)//2\\n        target = int(s[mid])\\n        left = mid-1; right = mid+1\\n        answer = 0\\n        count = 0\\n        while left >= 0:\\n            if (count + int(s[left])) % 2 != target:\\n                answer += left+1\\n                count += 1\\n            left -= 1\\n        \\n        count = 0\\n        while right < n:\\n            if (count + int(s[right])) % 2 != target:\\n                answer += n-right\\n                count += 1\\n            right += 1\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        mid = (n-1)//2\\n        target = int(s[mid])\\n        left = mid-1; right = mid+1\\n        answer = 0\\n        count = 0\\n        while left >= 0:\\n            if (count + int(s[left])) % 2 != target:\\n                answer += left+1\\n                count += 1\\n            left -= 1\\n        \\n        count = 0\\n        while right < n:\\n            if (count + int(s[right])) % 2 != target:\\n                answer += n-right\\n                count += 1\\n            right += 1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570252,
                "title": "very-easy-solution-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        long long ans=0;\\n        for(int i=0 ; i< n-1 ; i++) {\\n            if(s[i] != s[i+1]) {\\n                ans += min(i+1, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        long long ans=0;\\n        for(int i=0 ; i< n-1 ; i++) {\\n            if(s[i] != s[i+1]) {\\n                ans += min(i+1, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570238,
                "title": "very-inuitive-one-pass-c-o-1-space",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply make all elements till i equal, then 0 to i all elements are same. Now if i and i+1 are not equal, then either flip 0 to i(inclusive) or i+1 till end, whichever is has lesser cost.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string &s) \\n    {\\n        long long flips=0;\\n        \\n        int n=s.size();\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i]!=s[i+1])\\n                flips+=min(i+1,n-i-1);\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string &s) \\n    {\\n        long long flips=0;\\n        \\n        int n=s.size();\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i]!=s[i+1])\\n                flips+=min(i+1,n-i-1);\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570233,
                "title": "detailed-python-explanation-easy-to-understand-simulation-divide-and-conquer",
                "content": "# Intuition\\nLet us understand this by an example. \\nWe take 1110\\nNow if we want to make all 0s\\nWe flip the first 1, \\nNow s becomes 0110\\nNow we flip the second char\\nBut the string becomes 1010\\nThis isn\\'t the most optimal. How about we start flipping from the middle. We have two ways to flip: Either left: towards 0 or right: towards the end\\nWe choose to flip towards the closest end. And since we want to do it optimally, we start from the middle.\\n\\nThere are only two possibilities. Either all 0s or all 1s\\nNow while flipping, if we something even number of times, it becomes same\\n\\n# Approach\\nWe try abd make all 0s or all 1s\\n- Compute the cost of making all 0s \\n- Compute cost of making all 1s\\n- Return the min of both\\n- Let us see the case of making all 0s\\n    - Divide the string into equal halves(left and right)\\n    - For left string, start from the end and process towards the start\\n    - If we encounter a 1, we flip and add index to score\\n    - if we encounter a 1 and number of flips is odd(in which case the number becomes a 0), we can leave that\\n    - And if we encounter a 0 and number of flips is even, we leave that too.\\n    - Now since we are going from right to left, flipping an index\\'d element changes the left elements of it too. So if number of flips is even, it doesn\\'t change, else it changes.\\nNow that we have processed left, we should process the right half too\\n\\n- Similiary we do for all 1s. \\n- Now we find the minimum and return it\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$: n being the length of string\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        p2 = n//2\\n        p1 = p2-1\\n        cp1 = p1\\n        cp2 = p2\\n        c1 = 0\\n        #all 0s\\n        fl = 0\\n        while p1 >= 0:\\n            if (s[p1] == \\'0\\' and fl%2==0) or (s[p1]==\\'1\\' and fl%2==1):\\n                p1 -= 1\\n                continue\\n            fl += 1\\n            c1 += p1+1\\n            p1 -= 1\\n        fl = 0\\n        while p2 < len(s):\\n            if (s[p2] == \\'0\\' and fl%2==0) or (s[p2]==\\'1\\' and fl%2==1):\\n                p2 += 1\\n                continue\\n            fl += 1\\n            c1 += n-p2\\n            p2+=1\\n        #all1s\\n        p1,p2 = cp1,cp2\\n        fl = 0\\n        c2  = 0\\n        while p1 >= 0:\\n            if (s[p1] == \\'1\\' and fl%2==0) or (s[p1]==\\'0\\' and fl%2==1):\\n                p1 -= 1\\n                continue\\n            fl += 1\\n            c2+= p1+1\\n            p1 -= 1\\n        fl = 0\\n        while p2 < len(s):\\n            if (s[p2] == \\'1\\' and fl%2==0) or (s[p2]==\\'0\\' and fl%2==1):\\n                p2 += 1\\n                continue\\n            fl += 1\\n            c2 += n-p2\\n            p2 += 1\\n        return min(c1, c2)\\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        p2 = n//2\\n        p1 = p2-1\\n        cp1 = p1\\n        cp2 = p2\\n        c1 = 0\\n        #all 0s\\n        fl = 0\\n        while p1 >= 0:\\n            if (s[p1] == \\'0\\' and fl%2==0) or (s[p1]==\\'1\\' and fl%2==1):\\n                p1 -= 1\\n                continue\\n            fl += 1\\n            c1 += p1+1\\n            p1 -= 1\\n        fl = 0\\n        while p2 < len(s):\\n            if (s[p2] == \\'0\\' and fl%2==0) or (s[p2]==\\'1\\' and fl%2==1):\\n                p2 += 1\\n                continue\\n            fl += 1\\n            c1 += n-p2\\n            p2+=1\\n        #all1s\\n        p1,p2 = cp1,cp2\\n        fl = 0\\n        c2  = 0\\n        while p1 >= 0:\\n            if (s[p1] == \\'1\\' and fl%2==0) or (s[p1]==\\'0\\' and fl%2==1):\\n                p1 -= 1\\n                continue\\n            fl += 1\\n            c2+= p1+1\\n            p1 -= 1\\n        fl = 0\\n        while p2 < len(s):\\n            if (s[p2] == \\'1\\' and fl%2==0) or (s[p2]==\\'0\\' and fl%2==1):\\n                p2 += 1\\n                continue\\n            fl += 1\\n            c2 += n-p2\\n            p2 += 1\\n        return min(c1, c2)\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570228,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUpvote if you liked it :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUpvote if you liked it :)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long cost = 0;\\n        for(int i=0; i<(n-1); i++) if(s.charAt(i) != s.charAt(i+1)) cost += Math.min(i+1,n-i-1);\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long cost = 0;\\n        for(int i=0; i<(n-1); i++) if(s.charAt(i) != s.charAt(i+1)) cost += Math.min(i+1,n-i-1);\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570190,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe try to make all zero or one, and we split the array in two half to perform operation\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        int k = n/2; // to split in half\\n        \\n        // all zero\\n        vector<char> to = {\\'0\\', \\'1\\'}; \\n        long long res1 = 0; \\n        for(int i = k-1; i>=0; i--){\\n            if(s[i] != to[0]){\\n                res1 += i+1; \\n                swap(to[0], to[1]); \\n            }\\n        }\\n        to = {\\'0\\', \\'1\\'};  \\n        for(int i = k; i<n; i++){\\n            if(s[i] != to[0]){\\n                res1 += n-i; \\n                swap(to[0], to[1]); \\n            }\\n            \\n        }\\n        \\n        // all one\\n        to = {\\'1\\', \\'0\\'};\\n        long long res2 = 0; \\n        for(int i = k-1; i>=0; i--){\\n            if(s[i] != to[0]){\\n                res2 += i+1; \\n                swap(to[0], to[1]); \\n            }\\n        }\\n        to = {\\'1\\', \\'0\\'};\\n        for(int i = k; i<n; i++){\\n            if(s[i] != to[0]){\\n                res2 += n-i; \\n                swap(to[0], to[1]); \\n            }\\n            \\n        }\\n        return min(res1, res2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        int k = n/2; // to split in half\\n        \\n        // all zero\\n        vector<char> to = {\\'0\\', \\'1\\'}; \\n        long long res1 = 0; \\n        for(int i = k-1; i>=0; i--){\\n            if(s[i] != to[0]){\\n                res1 += i+1; \\n                swap(to[0], to[1]); \\n            }\\n        }\\n        to = {\\'0\\', \\'1\\'};  \\n        for(int i = k; i<n; i++){\\n            if(s[i] != to[0]){\\n                res1 += n-i; \\n                swap(to[0], to[1]); \\n            }\\n            \\n        }\\n        \\n        // all one\\n        to = {\\'1\\', \\'0\\'};\\n        long long res2 = 0; \\n        for(int i = k-1; i>=0; i--){\\n            if(s[i] != to[0]){\\n                res2 += i+1; \\n                swap(to[0], to[1]); \\n            }\\n        }\\n        to = {\\'1\\', \\'0\\'};\\n        for(int i = k; i<n; i++){\\n            if(s[i] != to[0]){\\n                res2 += n-i; \\n                swap(to[0], to[1]); \\n            }\\n            \\n        }\\n        return min(res1, res2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047521,
                "title": "greedy-super-simple-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        long long n=s.size();\\n        long long ans=0;\\n        for(int x=0; x<n-1; x++)\\n        {\\n            if(s[x]!=s[x+1]) ans+=(x+1>n-x-1?n-x-1:x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        long long n=s.size();\\n        long long ans=0;\\n        for(int x=0; x<n-1; x++)\\n        {\\n            if(s[x]!=s[x+1]) ans+=(x+1>n-x-1?n-x-1:x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028275,
                "title": "easiest-one-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust iterate the string and if two adjacent characters are not equal then just invert it i.e. add the min value of inversion.\\nmin value of inversion means which operation we are using 1st one or 2nd one.\\n\\nIf you like it please upvote \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n-1; ++i){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1 , n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n-1; ++i){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1 , n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028274,
                "title": "easiest-one-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust iterate the string and if two adjacent characters are not equal then just invert it i.e. add the min value of inversion.\\nmin value of inversion means which operation we are using 1st one or 2nd one.\\n\\nIf you like it please upvote \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n-1; ++i){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1 , n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n-1; ++i){\\n            if(s[i] != s[i+1]){\\n                ans += min(i+1 , n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011723,
                "title": "prefix-sum-suffix-sum-dp",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        vector<long long>pre(s.size(),0),suf(s.size(),0);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==s[i-1])pre[i]=pre[i-1];\\n            else pre[i]=i+pre[i-1];\\n            // cout<<pre[i]<<\" \";\\n        }\\n        // return 0;\\n        // cout<<endl;\\n        for(int i=s.size()-2;i>=0;i--){\\n            if(s[i]==s[i+1])suf[i]=suf[i+1];\\n            else suf[i]=s.size()-i-1+suf[i+1];\\n            // cout<<suf[i]<<\" \";\\n        }\\n        // return 0;\\n        // for(int i=0;i<s.size();i++){\\n        //     cout<<pre[i]<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<s.size();i++){\\n        //     cout<<suf[i]<<\" \";\\n        // }\\n        long long ans=1e18;\\n        for(int i=0;i<s.size();i++){\\n            if(i==0)ans=min(ans,suf[i]);\\n            else if(i==s.size()-1)ans=min(ans,pre[i]);\\n            else ans=min(ans,pre[i]+suf[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        vector<long long>pre(s.size(),0),suf(s.size(),0);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==s[i-1])pre[i]=pre[i-1];\\n            else pre[i]=i+pre[i-1];\\n            // cout<<pre[i]<<\" \";\\n        }\\n        // return 0;\\n        // cout<<endl;\\n        for(int i=s.size()-2;i>=0;i--){\\n            if(s[i]==s[i+1])suf[i]=suf[i+1];\\n            else suf[i]=s.size()-i-1+suf[i+1];\\n            // cout<<suf[i]<<\" \";\\n        }\\n        // return 0;\\n        // for(int i=0;i<s.size();i++){\\n        //     cout<<pre[i]<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<s.size();i++){\\n        //     cout<<suf[i]<<\" \";\\n        // }\\n        long long ans=1e18;\\n        for(int i=0;i<s.size();i++){\\n            if(i==0)ans=min(ans,suf[i]);\\n            else if(i==s.size()-1)ans=min(ans,pre[i]);\\n            else ans=min(ans,pre[i]+suf[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4001774,
                "title": "easy-to-understand-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    long long minimumCost(string s) {\\n        long long ans=1e18;\\n        int n=s.length();\\n       \\n        vector<vector<long long>> dpp(n+1,vector<long long> (2,0));\\n                vector<vector<long long>> dps(n+2,vector<long long> (2,0));\\n\\n        \\n        dpp[1][0]=0;\\n        dpp[1][1]=1;\\n        for(int i=2;i<=n;i++){\\n            \\n         if(s[i-1]!=s[i-2]){\\n             dpp[i][0]=dpp[i-1][1];\\n             dpp[i][1]=i+dpp[i-1][1];\\n         }\\n        else{\\n             dpp[i][0]=dpp[i-1][0];\\n            dpp[i][1]=i+dpp[i-1][0];\\n        }\\n            \\n            \\n            \\n\\n        }\\n        \\n        \\n         dps[n][0]=0;\\n        dps[n][1]=1;\\n        for(int i=n-1;i>=1;i--){\\n                if(s[i-1]!=s[i]){\\n             dps[i][0]=dps[i+1][1];\\n             dps[i][1]=n-i+1+dps[i+1][1];\\n         }\\n        else{\\n             dps[i][0]=dps[i+1][0];\\n            dps[i][1]=n-i+1+dps[i+1][0];\\n        }\\n            \\n            \\n        }\\n        \\n        \\n\\n//         for(int i=1;i<=n;i++){\\n//             cout<<i<<\" \"<<dpp[i][0]<<\" \"<<dpp[i][1]<<endl;\\n//         }\\n        \\n//          for(int i=1;i<=n;i++){\\n//             cout<<i<<\" \"<<dps[i][0]<<\" \"<<dps[i][1]<<endl;\\n//         }\\n        \\n//         cout<<ans<<endl;\\n        \\n        \\n        for(int i=1;i<=n;i++){\\n            long long f1=dpp[i][0];\\n            long long f2=dpp[i][1];\\n            if(i!=n and s[i-1]!=s[i]){\\n                f1+=dps[i+1][1];\\n                f2+=dps[i+1][0];\\n            }\\n            else{\\n                  f1+=dps[i+1][0];\\n                f2+=dps[i+1][1];\\n            }\\n            // cout<<min(f2,f2)<<endl;\\n             ans=min(ans,min(f1,f2));\\n            // cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    long long minimumCost(string s) {\\n        long long ans=1e18;\\n        int n=s.length();\\n       \\n        vector<vector<long long>> dpp(n+1,vector<long long> (2,0));\\n                vector<vector<long long>> dps(n+2,vector<long long> (2,0));\\n\\n        \\n        dpp[1][0]=0;\\n        dpp[1][1]=1;\\n        for(int i=2;i<=n;i++){\\n            \\n         if(s[i-1]!=s[i-2]){\\n             dpp[i][0]=dpp[i-1][1];\\n             dpp[i][1]=i+dpp[i-1][1];\\n         }\\n        else{\\n             dpp[i][0]=dpp[i-1][0];\\n            dpp[i][1]=i+dpp[i-1][0];\\n        }\\n            \\n            \\n            \\n\\n        }\\n        \\n        \\n         dps[n][0]=0;\\n        dps[n][1]=1;\\n        for(int i=n-1;i>=1;i--){\\n                if(s[i-1]!=s[i]){\\n             dps[i][0]=dps[i+1][1];\\n             dps[i][1]=n-i+1+dps[i+1][1];\\n         }\\n        else{\\n             dps[i][0]=dps[i+1][0];\\n            dps[i][1]=n-i+1+dps[i+1][0];\\n        }\\n            \\n            \\n        }\\n        \\n        \\n\\n//         for(int i=1;i<=n;i++){\\n//             cout<<i<<\" \"<<dpp[i][0]<<\" \"<<dpp[i][1]<<endl;\\n//         }\\n        \\n//          for(int i=1;i<=n;i++){\\n//             cout<<i<<\" \"<<dps[i][0]<<\" \"<<dps[i][1]<<endl;\\n//         }\\n        \\n//         cout<<ans<<endl;\\n        \\n        \\n        for(int i=1;i<=n;i++){\\n            long long f1=dpp[i][0];\\n            long long f2=dpp[i][1];\\n            if(i!=n and s[i-1]!=s[i]){\\n                f1+=dps[i+1][1];\\n                f2+=dps[i+1][0];\\n            }\\n            else{\\n                  f1+=dps[i+1][0];\\n                f2+=dps[i+1][1];\\n            }\\n            // cout<<min(f2,f2)<<endl;\\n             ans=min(ans,min(f1,f2));\\n            // cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3947691,
                "title": "key-idea-explained-from-dp-to-greedy",
                "content": "**Intuition**\\nFlip left and Flip right operations can not cross each other because othwerwise you are just wasting flips\\nSo all operations might look something like this:\\n`[..L..L..........R..R..]`,\\nwhere `L` is Flip Left, `R` is Flip Right, `.` is where operation wasnt applied\\n\\nThe question to ask now is:\\nHow to find min cost to make 0110011 all 1s assuming you can do ONLY Flip Left?\\nAnswer:\\nYou flip everytime the next char is different, excluding the last substring of all 1s\\n\\n\\n**DP Approach**\\nWe calculate and save the cost of flipping left to right and right to left separately. \\nThen iterate along and find the cheapest cost combination of left flips and right flips. \\n**Time: O(n)\\nSpace: O(n)**\\n```\\ndef minimumCost(self, s: str) -> int:\\n    n = len(s)\\n    def min_cost(s):\\n        zero = one = cost = 0\\n        info = []\\n        for i in range(len(s)):\\n            cost += i + 1\\n            if i and s[i-1] == s[i]:\\n                cost -= i\\n            \\n            zero = 0 if s[i] == \"1\" else i + 1\\n            one = 0 if zero else i + 1\\n            \\n            info.append([zero, one, cost])\\n        return info\\n    \\n    left = min_cost(s)\\n    right = min_cost(s[::-1])[::-1]\\n\\n    ans = right[0][-1] - max(right[0][:-1])\\n\\n    for i in range(n-1):\\n        left_z, left_o, left_c = left[i]\\n        right_z, right_o, right_c = right[i+1]\\n\\n        # convert to all one\\n        ans = min(ans, left_c - left_o + right_c - right_o)\\n        # convert to all zero\\n        ans = min(ans, left_c - left_z + right_c - right_z)\\n        \\n    ans = min(ans, left[-1][-1] - max(left[-1][:-1]))\\n    return ans\\n```\\n\\n**Greedy Approach**\\nIt should be clear that flip operation is needed whenenver adjacent chars are different\\n\\nIf we always choose the `min(i (Flip Left), n - i (Flip Right))`,\\nthen Flip Left and Flip Right will never cross each other,\\nand since we are only flipping when needed, then we must be applying min cost approach\\n\\n**Time: O(n)\\nSpace: O(1)**\\n```\\ndef minimumCost(self, s: str) -> int:\\n    n = len(s)\\n    ans = 0\\n    for i in range(1, n):\\n        if s[i] != s[i-1]:\\n            ans += min(i, n - i)\\n    return ans\\n\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minimumCost(self, s: str) -> int:\\n    n = len(s)\\n    def min_cost(s):\\n        zero = one = cost = 0\\n        info = []\\n        for i in range(len(s)):\\n            cost += i + 1\\n            if i and s[i-1] == s[i]:\\n                cost -= i\\n            \\n            zero = 0 if s[i] == \"1\" else i + 1\\n            one = 0 if zero else i + 1\\n            \\n            info.append([zero, one, cost])\\n        return info\\n    \\n    left = min_cost(s)\\n    right = min_cost(s[::-1])[::-1]\\n\\n    ans = right[0][-1] - max(right[0][:-1])\\n\\n    for i in range(n-1):\\n        left_z, left_o, left_c = left[i]\\n        right_z, right_o, right_c = right[i+1]\\n\\n        # convert to all one\\n        ans = min(ans, left_c - left_o + right_c - right_o)\\n        # convert to all zero\\n        ans = min(ans, left_c - left_z + right_c - right_z)\\n        \\n    ans = min(ans, left[-1][-1] - max(left[-1][:-1]))\\n    return ans\\n```\n```\\ndef minimumCost(self, s: str) -> int:\\n    n = len(s)\\n    ans = 0\\n    for i in range(1, n):\\n        if s[i] != s[i-1]:\\n            ans += min(i, n - i)\\n    return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3888049,
                "title": "dry-run-yourself-you-will-understand-one-pass-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // https://www.youtube.com/watch?v=ybMuZTqQHFY\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n\\n        long long ans = 0;\\n\\n        // current index will make the indices previous to it equal to itself\\n        for(int i =1; i<n; i++){\\n            if(s[i-1] != s[i]){\\n                ans = ans + min(i, n-i);\\n                // cout<<i<<\"->\"<<min(i,n-i)<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // https://www.youtube.com/watch?v=ybMuZTqQHFY\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n\\n        long long ans = 0;\\n\\n        // current index will make the indices previous to it equal to itself\\n        for(int i =1; i<n; i++){\\n            if(s[i-1] != s[i]){\\n                ans = ans + min(i, n-i);\\n                // cout<<i<<\"->\"<<min(i,n-i)<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3871847,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n         int n = s.length();\\n        long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)!=s.charAt(i+1)){\\n                ans+=Math.min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n         int n = s.length();\\n        long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s.charAt(i)!=s.charAt(i+1)){\\n                ans+=Math.min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854371,
                "title": "golang-solution-iterate-once-very-simple",
                "content": "# Code\\n```go\\nfunc minimumCost(s string) int64 {\\n\\tcost := 0\\n\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\tif s[i] != s[i+1] {\\n\\t\\t\\tcost += min(i+1, len(s)-i-1)\\n\\t\\t}\\n\\t}\\n\\treturn int64(cost)\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minimumCost(s string) int64 {\\n\\tcost := 0\\n\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\tif s[i] != s[i+1] {\\n\\t\\t\\tcost += min(i+1, len(s)-i-1)\\n\\t\\t}\\n\\t}\\n\\treturn int64(cost)\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853309,
                "title": "leaning-on-the-stl",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    template <typename I>\\n    long long fix(I first, I last, bool make_zero) {\\n        long long cost = 0;\\n        for ( ; first != last; ++first) {\\n            if ((*first == \\'0\\') != make_zero) {\\n                cost += static_cast<long long>(last - first);\\n                make_zero = !make_zero;\\n            }\\n        }\\n        return cost;\\n    }\\n\\n    long long minimumCost(string s) {\\n        auto mid = begin(s) + s.size() / 2;\\n        return fix(make_reverse_iterator(mid), rend(s), *mid == \\'0\\') +\\n               fix(mid, end(s), *mid == \\'0\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    template <typename I>\\n    long long fix(I first, I last, bool make_zero) {\\n        long long cost = 0;\\n        for ( ; first != last; ++first) {\\n            if ((*first == \\'0\\') != make_zero) {\\n                cost += static_cast<long long>(last - first);\\n                make_zero = !make_zero;\\n            }\\n        }\\n        return cost;\\n    }\\n\\n    long long minimumCost(string s) {\\n        auto mid = begin(s) + s.size() / 2;\\n        return fix(make_reverse_iterator(mid), rend(s), *mid == \\'0\\') +\\n               fix(mid, end(s), *mid == \\'0\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809228,
                "title": "step-by-step-explnation-give-a-try",
                "content": "# Intuition\\n\\ns = \"010101\"\\nWe start iterating from index 1, and compare the current character with previous charcter and see if they are equal or not..\\n\\ni=1\\n    s[1]!=s[0]\\n        so we have two choices, either invert from index 0 to i or i to n-1, and among them we choose the operation which cost us minimum\\n\\nso lets try both way, \\n    invertin from 0 to i will cost 1 and make string look something like this\\n    1 1 0 1 0 1\\n\\ninverting from i to n-1 which is from 1 to 5 will cost 5 and make string look like this\\n\\n    0 0 1 0 1 0\\nand among this we choose the first operation ans our ans = 0 +min(1,5) = 1\\n\\n---------------------------\\n\\ni = 2\\n\\nstring is 1 1 0 1 0 1\\n    s[2]!=s[1]\\n\\nagain two choice, so let\\'s invert from 0 to i\\n    0 0 0 1 0 1 ==> with cose of 2\\nlet\\'s invert from i to n-1\\n1 1 1 0 1 0 === with cost of 4\\n\\nso among both these operation minimum is 2, so our ans becomes\\n    ans = 1 +min(2,4) = 3\\n\\nso we keep doing this operation till we reach last index.\\nOne thing which we notice is that , all string before i, are becoming either 0 or 1 after 1st operation.\\n\\n\\n\\n\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    // even after inversion, mismatch at each index remains sames, just their bits changes\\n    long long minimumCost(string s) {\\n        ll ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i]!=s[i-1]){\\n                ans+=min(i,n-i);\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    // even after inversion, mismatch at each index remains sames, just their bits changes\\n    long long minimumCost(string s) {\\n        ll ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i]!=s[i-1]){\\n                ans+=min(i,n-i);\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805156,
                "title": "explanation-for-myself",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![WechatIMG11.jpeg](https://assets.leetcode.com/users/images/9e96f78d-8cfb-49a2-a809-d0dbca16affd_1690106958.2032874.jpeg)\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n=len(s)\\n        res=0\\n        for i in range(1,n):\\n            if s[i]!=s[i-1]:\\n                res+=min(i,n-i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n=len(s)\\n        res=0\\n        for i in range(1,n):\\n            if s[i]!=s[i-1]:\\n                res+=min(i,n-i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747306,
                "title": "java-solution-just-applied-simple-intution-using-mid",
                "content": "# Approach\\nMove from mid to left and then right.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        if(s.length()<=1)return 0;\\n        if(s.length()==2){\\n            if(s.charAt(0)==s.charAt(1))return 0;\\n            else return 1;\\n        }\\n        int x=0,y=0,n=s.length();\\n        for(int i=0;i<s.length();i++)\\n        {\\n           if(s.charAt(i)==\\'1\\'){x=1;}\\n           if(s.charAt(i)==\\'0\\'){y=1;}      \\n        }\\n        if(x==0||y==0)return 0;\\n\\nint m=0;\\nif(n%2==0){m=(n/2)-1;}\\nelse{m=n/2;}\\nlong ans=0;\\nif(s.charAt(m)==\\'0\\'){\\n   int u=m,v=m+1,c=0;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\n}\\n}\\nelse{\\n  int u=m,v=m+1,c=0;\\n  while(u<n&&s.charAt(u)==\\'1\\'){u++;}\\n  u=m-1;v=m;\\n  ans+=u+1;c++;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\n}\\n\\n\\n}\\nlong ans1=0;\\nif(s.charAt(m)==\\'1\\'){\\n  int u=m,v=m+1,c=0;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\n}\\n\\n}\\nelse{\\n     int u=m,v=m+1,c=0;\\n  while(u<n&&s.charAt(u)==\\'0\\'){u++;}\\n  u=m-1;v=m;\\n  ans1+=u+1;c++;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\n}\\n}\\n\\n//System.out.print(ans+\" \"+ans1);\\nreturn Math.min(ans,ans1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        if(s.length()<=1)return 0;\\n        if(s.length()==2){\\n            if(s.charAt(0)==s.charAt(1))return 0;\\n            else return 1;\\n        }\\n        int x=0,y=0,n=s.length();\\n        for(int i=0;i<s.length();i++)\\n        {\\n           if(s.charAt(i)==\\'1\\'){x=1;}\\n           if(s.charAt(i)==\\'0\\'){y=1;}      \\n        }\\n        if(x==0||y==0)return 0;\\n\\nint m=0;\\nif(n%2==0){m=(n/2)-1;}\\nelse{m=n/2;}\\nlong ans=0;\\nif(s.charAt(m)==\\'0\\'){\\n   int u=m,v=m+1,c=0;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\n}\\n}\\nelse{\\n  int u=m,v=m+1,c=0;\\n  while(u<n&&s.charAt(u)==\\'1\\'){u++;}\\n  u=m-1;v=m;\\n  ans+=u+1;c++;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans+=n-v;c++;}\\n}\\n}\\n\\n\\n}\\nlong ans1=0;\\nif(s.charAt(m)==\\'1\\'){\\n  int u=m,v=m+1,c=0;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\n}\\n\\n}\\nelse{\\n     int u=m,v=m+1,c=0;\\n  while(u<n&&s.charAt(u)==\\'0\\'){u++;}\\n  u=m-1;v=m;\\n  ans1+=u+1;c++;\\nwhile(u>=0){\\nif(c%2==0){\\n    if(s.charAt(u)==\\'1\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\nelse{\\n        if(s.charAt(u)==\\'0\\'){u--;}\\n    else{ans1+=u+1;c++;}\\n}\\n\\n}\\nc=0;\\nwhile(v<s.length()){\\nif(c%2==0){\\n    if(s.charAt(v)==\\'1\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\nelse{\\n        if(s.charAt(v)==\\'0\\'){v++;}\\n    else{ans1+=n-v;c++;}\\n}\\n}\\n}\\n\\n//System.out.print(ans+\" \"+ans1);\\nreturn Math.min(ans,ans1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699247,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        res = 0\\n        for i in range(1, n):\\n            if s[i] != s[i - 1]:\\n                res += min(i, n - i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        res = 0\\n        for i in range(1, n):\\n            if s[i] != s[i - 1]:\\n                res += min(i, n - i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687694,
                "title": "simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans = 0L;\\n        int n = s.length();\\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) != s.charAt(i - 1)) {\\n                ans += Math.min(i, n - i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans = 0L;\\n        int n = s.length();\\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) != s.charAt(i - 1)) {\\n                ans += Math.min(i, n - i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663258,
                "title": "c-greedy-single-pass-98-time-20ms-75-space-12-1mb",
                "content": "This problem is clearly not approachable with a brute force approach, since each character might be flipped to either `\\'0\\'` or `\\'1\\'`, which implies we would have to compute $$2^n$$ different alternatives; it might tempt us into going through some complex DP approach, branching each time we find dissimilar characters, but actually we can proceed in a much easier way:\\n* when we encounter identical consecutive characters, clearly nothing much to be done;\\n* when we encounter different consecutive characters, then we have two options to consider - we either:\\n    * flip all the previous ones (that we can assume either were already homogeneous or we turned them that way with previous flips) for a cost of `i` OR\\n    * flip the current character and all the following ones, for a cost of `len - i`;\\n* regardless of the outcome, we can proceed and know that again all the characters up to the current index (excluded) are now homogeneous.\\n\\nThe beauty of it is that at each step we can proceed knowing that the cheapest move will also be the right one (ie: pure greedy approach); let\\'s assume for example at some point we are in this situation:\\n\\n```cpp\\n...0000000100010101...\\n          ^\\n```\\n\\nWe have made all the characters up to that point homogeneous, but then we found another different character: in that case the best course of action is to either flip all the previous characters to `\\'1\\'` or flip that character and all the following ones; so we will have two alternatives for this scenario:\\n\\n```cpp\\n...1111111100010101... // 1st case, flipping all the previous chars\\n          ^\\n...0000000011101010... // 2nd case, flipping from there onwards\\n          ^\\n```\\n\\nAnd it can be demonstrated that the cheapest option is the right one, since the cost of all the following flips still depends uniquely on how many flips we would need to do and how close to the end of the string we are.\\n\\nNow, to put all of this into code, we can start declaring our usual support variables:\\n* `len` will store the length of `s`;\\n* `res` will be our usual accumulator variable, counting how many flips we did overall.\\n\\nWe will then parse with `i` each character from the second (position `1`) to the last and, when we will find two different adjacent elements (ie: `s[i] != s[i - 1]`), we will update `res`, as explained by adding the minimum between flipping all the element before the current one (with a cost of `i`) or all the others from there onwards (with a cost of `n - i`).\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        // support variables\\n        int len = s.size();\\n        long long res = 0;\\n        // parsing s\\n        for (int i = 1; i < len; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += min(i, len - i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWe can save ourselves the cost of the `min` operation, if we think about it, since we know that taking the `i` will be cheaper in the first half of `s`, and more expensive after that, so we can refactor and split our main loop into two parts:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        // support variables\\n        int len = s.size(), halfLen = len >> 1;\\n        long long res = 0;\\n        // parsing the 1st half of s\\n        for (int i = 1; i <= halfLen; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += i;\\n            }\\n        }\\n        // parsing the 2nd half of s\\n        for (int i = halfLen + 1; i < len; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += len - i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```cpp\\n...0000000100010101...\\n          ^\\n```\n```cpp\\n...1111111100010101... // 1st case, flipping all the previous chars\\n          ^\\n...0000000011101010... // 2nd case, flipping from there onwards\\n          ^\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        // support variables\\n        int len = s.size();\\n        long long res = 0;\\n        // parsing s\\n        for (int i = 1; i < len; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += min(i, len - i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        // support variables\\n        int len = s.size(), halfLen = len >> 1;\\n        long long res = 0;\\n        // parsing the 1st half of s\\n        for (int i = 1; i <= halfLen; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += i;\\n            }\\n        }\\n        // parsing the 2nd half of s\\n        for (int i = halfLen + 1; i < len; i++) {\\n            // difference encountered\\n            if (s[i] != s[i - 1]) {\\n                res += len - i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651566,
                "title": "8-line-code-o-n-o-1-100-c-basic-greedy-dp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust make all the left of ith to be equal (i.e -> if you are at i==2 , s=\"111..0101\" as you can see till i==2 string contain equal char \\'1\\'. ). To do show we have to check ith char with i+1th char \\n\\ncase 1: if s[i]==s[i+1] just move forward as it is equal to left one.\\n \\ncase 2: if(s[i]!=s[i+1]) just make s[i+1]==s[i] such that your left side string till i must have same char to do so *first_approch-> we can change all char from 0 to i or, *second_approch-> we can change all the char form i+1 to n-1. so you can go with anyone of it but as we have to min the cost take the min of both the approch. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=s[i+1]){\\n                ans+=min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=s[i+1]){\\n                ans+=min(i+1,n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642652,
                "title": "greedy-approach-java-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    long helper(String s,int v){\\n        int len = s.length();\\n        long ans = 0;\\n        int flip = 0;\\n        for(int i = len / 2 - 1;i >= 0;i--){\\n            int c = s.charAt(i) - \\'0\\';\\n            if(c != v && flip % 2 == 0){\\n                ans += i + 1L;\\n                flip++;\\n            }\\n            else if(c == v && flip % 2 != 0){\\n                ans += i + 1L;\\n                flip++;\\n            }\\n        }\\n        flip = 0;\\n        for(int i = len / 2;i < len;i++){\\n            int c = s.charAt(i) - \\'0\\';\\n            if(c != v && flip % 2 == 0){\\n                ans += len - i;\\n                flip++;\\n            }\\n            else if(c == v && flip % 2 != 0){\\n                ans += len - i;\\n                flip++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public long minimumCost(String s) {\\n        long ans0 = helper(s,0);\\n        long ans1 = helper(s,1);\\n        return Math.min(ans0,ans1);\\n    }\\n}\\n```\\n\\n# Upvote if you like it \\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    long helper(String s,int v){\\n        int len = s.length();\\n        long ans = 0;\\n        int flip = 0;\\n        for(int i = len / 2 - 1;i >= 0;i--){\\n            int c = s.charAt(i) - \\'0\\';\\n            if(c != v && flip % 2 == 0){\\n                ans += i + 1L;\\n                flip++;\\n            }\\n            else if(c == v && flip % 2 != 0){\\n                ans += i + 1L;\\n                flip++;\\n            }\\n        }\\n        flip = 0;\\n        for(int i = len / 2;i < len;i++){\\n            int c = s.charAt(i) - \\'0\\';\\n            if(c != v && flip % 2 == 0){\\n                ans += len - i;\\n                flip++;\\n            }\\n            else if(c == v && flip % 2 != 0){\\n                ans += len - i;\\n                flip++;\\n            }\\n        }\\n        return ans;\\n    }\\n    public long minimumCost(String s) {\\n        long ans0 = helper(s,0);\\n        long ans1 = helper(s,1);\\n        return Math.min(ans0,ans1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638398,
                "title": "simplest-approach-beats-97",
                "content": "# Intuition\\n1. Calculate the middle position of the string s\\n2. Starting from both ends moving toward the middle to make all chars on each side the same\\n3. check if s[m-1] = s[m], if not add m to the result. This is because we\\'ve made the left m characters the same, the right n - m character the same. We need flip m chars to make the whole string the same chars. \\n\\nIf you like my approach please upvote!\\n\\n# Approach\\nIterative, one pass scan\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        m = n//2\\n        l, r = 0, 0\\n        for i in range(1, m):\\n            if s[i-1] != s[i]:\\n                l += i\\n        for i in range(n-2, m-1, -1):\\n            if s[i] != s[i+1]:\\n                r += n - i - 1\\n        if s[m-1] != s[m]:\\n            return l + r + m\\n        return l + r\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        m = n//2\\n        l, r = 0, 0\\n        for i in range(1, m):\\n            if s[i-1] != s[i]:\\n                l += i\\n        for i in range(n-2, m-1, -1):\\n            if s[i] != s[i+1]:\\n                r += n - i - 1\\n        if s[m-1] != s[m]:\\n            return l + r + m\\n        return l + r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633977,
                "title": "tc-o-n-sc-o-1",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        \\n        long result = 0;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s.charAt(i) != s.charAt(i - 1)) result += Math.min(i , s.length() - i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        \\n        long result = 0;\\n        for(int i = 1; i < s.length(); i++){\\n            if(s.charAt(i) != s.charAt(i - 1)) result += Math.min(i , s.length() - i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632403,
                "title": "simple-greedy-approch",
                "content": "# Intuition\\n<b>Simple check if([i] !=[i+1]</b> \\nthen we need to change it so choose cost from option 1 or optiom 2 which one is: \\nans+= Math.mim(option 1, option 2))\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:<b>O(1)</b>\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long ans = 0L;\\n        for(int i =0;i<n-1;i++){\\n            if(s.charAt(i) !=s.charAt(i+1)){\\n                ans += (i+1<n-i-1 ? i+1:n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        int n = s.length();\\n        long ans = 0L;\\n        for(int i =0;i<n-1;i++){\\n            if(s.charAt(i) !=s.charAt(i+1)){\\n                ans += (i+1<n-i-1 ? i+1:n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630058,
                "title": "just-the-proof-no-code",
                "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions.\\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].\\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof.",
                "solutionTags": [
                    "C++"
                ],
                "code": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions.\\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].\\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof.",
                "codeTag": "Unknown"
            },
            {
                "id": 3626048,
                "title": "antarnab-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // antarnab solution\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int n = s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans += min(i,n-i); // antarnab solution\\n                                    //Think Greedy \\n            }\\n        }return ans;\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622232,
                "title": "o-n-easy-to-understand-python",
                "content": "# Intuition\\nIt can be done trough looking into two halves of the string from mid\\n\\n# Approach\\nIf next bit is in Left Half: check if it is not same then swap the left part\\nelse next bit is in Right Half : check if it is not same then swap the right part\\n\\n# Complexity \\n- Time complexity: O(n) -> As only one iteration required\\n\\n- Space complexity: O(1) -> Const space is used for variable \\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        mid = n // 2\\n        for i in range(n - 1):\\n            if s[i] != s[i + 1]:\\n                if i + 1 <= mid:\\n                    ans += i + 1\\n                else:\\n                    ans += n - (i+1)\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        mid = n // 2\\n        for i in range(n - 1):\\n            if s[i] != s[i + 1]:\\n                if i + 1 <= mid:\\n                    ans += i + 1\\n                else:\\n                    ans += n - (i+1)\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621112,
                "title": "c-super-easy-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i]!=s[i-1])\\n                {\\n                if(i<s.size()-i)\\n                    ans+=i;\\n                else\\n                    ans+=s.size()-i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i]!=s[i-1])\\n                {\\n                if(i<s.size()-i)\\n                    ans+=i;\\n                else\\n                    ans+=s.size()-i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619458,
                "title": "rust-python-linear-solution-with-detailed-explanation",
                "content": "# Intuition\\n\\nLets look at a restricted problem where we can do change only from one side. And lets also assume that we have an some array:\\n\\n```\\nx, x, x, x, ... X, \\n```\\n\\nfor which the answer is `n` (the values for `x` does not matter and they can be different or equal). Now lets add one more character to our array:\\n\\n```\\nx, x, x, x, ... X, Y\\n```\\n\\nif `Y == X` the answer will be the same as previous array was already changed to have all numbers equal. If they are not the same, you need to flip all the values before Y (doing only one flip as they all have equal values). And that flip will cost us `i`.\\n\\nSo we have the following dp:\\n`dp_lr[i] = dp_lr[i - 1] + (i if s[i - 1] != s[i] else 0)`\\n\\n----------------\\n\\nSo we know how to get results moving from Left to Right. We can do the same doing from Right to Left.\\n\\nAnd to get the resulting answer we can try every position and find the smallest values of `dp_lr[i] + dp_rl[i]`\\n\\n\\n\\n# Complexity\\n\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn minimum_cost(s: String) -> i64 {\\n    let n = s.len();\\n    let s = s.as_bytes();\\n    let mut dp = vec![0i64; n];\\n\\n    for i in 1 .. n {\\n      dp[i] = dp[i - 1];\\n      if s[i] != s[i - 1] {\\n        dp[i] += i as i64;\\n      }\\n    }\\n\\n    let (mut res, mut cnt) = (dp[n - 1] as i64, 0);\\n    for i in (0 .. n - 1).rev() {\\n      if s[i] != s[i + 1] {\\n        cnt += (n - i - 1) as i64;\\n      }\\n      res = res.min(dp[i] + cnt);\\n    }\\n    \\n    return res;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def minimumCost(self, s: str) -> int:\\n    dp, n = [0] * len(s), len(s)\\n    for i in range(1, n):\\n      dp[i] = dp[i - 1] + (i if s[i - 1] != s[i] else 0)\\n    \\n    res, cnt = dp[-1], 0\\n    for i in range(n - 2, -1, -1):\\n      cnt += n - 1 - i if s[i] != s[i + 1] else 0\\n      res = min(res, dp[i] + cnt)\\n\\n    return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```\\nx, x, x, x, ... X, \\n```\n```\\nx, x, x, x, ... X, Y\\n```\n```Rust []\\nimpl Solution {\\n  pub fn minimum_cost(s: String) -> i64 {\\n    let n = s.len();\\n    let s = s.as_bytes();\\n    let mut dp = vec![0i64; n];\\n\\n    for i in 1 .. n {\\n      dp[i] = dp[i - 1];\\n      if s[i] != s[i - 1] {\\n        dp[i] += i as i64;\\n      }\\n    }\\n\\n    let (mut res, mut cnt) = (dp[n - 1] as i64, 0);\\n    for i in (0 .. n - 1).rev() {\\n      if s[i] != s[i + 1] {\\n        cnt += (n - i - 1) as i64;\\n      }\\n      res = res.min(dp[i] + cnt);\\n    }\\n    \\n    return res;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def minimumCost(self, s: str) -> int:\\n    dp, n = [0] * len(s), len(s)\\n    for i in range(1, n):\\n      dp[i] = dp[i - 1] + (i if s[i - 1] != s[i] else 0)\\n    \\n    res, cnt = dp[-1], 0\\n    for i in range(n - 2, -1, -1):\\n      cnt += n - 1 - i if s[i] != s[i + 1] else 0\\n      res = min(res, dp[i] + cnt)\\n\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616040,
                "title": "python-2d-dp-greedy",
                "content": "Before solving this one. https://leetcode.com/problems/flip-string-to-monotone-increasing/ needs to be solved. **Similar greedy idea**.\\n\\n**DP**\\nThis feels like hard when you do it with DP :(\\n\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \"\"\"\\n        dp[v][i] - min cost to make all elements equal v [0...i]\\n        1) s[i] == \\'0\\': 00[0] to 000: -> cost(00) -> 000\\n        2) s[i] == \\'0\\': 11[0] to 111: -> cost(00) + invert(000) -> 111\\n        3) s[i] == \\'1\\': 11[1] to 111: -> cost(11) -> 111\\n        4) s[i] == \\'1\\': 00[1] to 000: -> cost(11) + invert(111) -> 000\\n        \"\"\"\\n        def fill(dp_0, dp_1, s):\\n            for i in range(N):\\n                if s[i] == \\'0\\':\\n                    dp_0[i] = dp_0[i - 1]\\n                    dp_1[i] = dp_0[i - 1] + i + 1\\n                else:\\n                    dp_0[i] = dp_1[i - 1] + i + 1\\n                    dp_1[i] = dp_1[i - 1]\\n\\n        N = len(s)\\n        l2r_dp_0, l2r_dp_1 = [0] * N, [0] * N,\\n        r2l_dp_0, r2l_dp_1, = [0] * (N + 1), [0] * (N + 1)\\n\\n        fill(l2r_dp_0, l2r_dp_1, s)\\n        fill(r2l_dp_0, r2l_dp_1, s[::-1])\\n       \\n        min_cost = float(inf)\\n        for i in range(N):\\n            min_cost = min(min_cost, l2r_dp_0[i] + r2l_dp_0[N - 1 - i])\\n            min_cost = min(min_cost, l2r_dp_1[i] + r2l_dp_1[N - 1 - i])\\n\\n        return min_cost\\n```\\n\\n**Greedy**\\nAt each position we check `s[i-1]` and `s[i]`.\\n`If s[i-1] != s[i]` we need to flip either `[0...i - 1]` or `[i...N]` to make `s[i-1] == s[i]`\\nWe pick minimum number of flips required to make `s[i-1] == s[i]`.\\n\\nDry run example:\\n\\n```\\n|010101\\nwe are good as just 1 element is equal to itself -> no flips needed\\n\\n0|10101\\n0!=1 we need to make a decision - flip left or right sides, which is cheaper?\\n\\nleft: flip 0->1 which costs 1, and make it 1|10101 <-- cheaper: cost <1>\\nor\\nright: flip 10101 which costs 5, and make it 0|01010\\n\\n11|0101\\n1!=0\\n\\nleft: flip 11->00 which costs 2, and make it 00|0101 <-- cheaper: cost <2>\\nor\\nright: flip 0101 which costs 4, and make it 11|1010\\n\\n000|101\\n0!=1\\n\\nleft: flip 000->111 which costs 3, and make it 111|101 <-- cheaper: cost <3>, let\\'g go with this one\\nor\\nright: flip 101 which costs 3, and make it 000|010 <-- cheaper: cost <3>\\n\\n1111|01\\n1!=0\\n\\nleft: flip 1111->0000 which costs 4, and make it 0000|01\\nor\\nright: flip 01 which costs 2, and make it 1111|10 <-- cheaper: cost <2>\\n\\n11111|0\\n0!=1\\n\\nleft: flip 11111->00000 which costs 5, and make it 00000|0\\nor\\nright: flip 0 which costs 1, and make it 11111|1 <-- cheaper: cost <1>\\n\\nTotal cost: 1 + 2 + 3 + 2 + 1 = 9\\n```\\n\\nSource code:\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        N = len(s)\\n        cost = 0\\n        for i in range(N):\\n            if i and s[i - 1] != s[i]:\\n                cost += min(i, N - i)\\n        return cost\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \"\"\"\\n        dp[v][i] - min cost to make all elements equal v [0...i]\\n        1) s[i] == \\'0\\': 00[0] to 000: -> cost(00) -> 000\\n        2) s[i] == \\'0\\': 11[0] to 111: -> cost(00) + invert(000) -> 111\\n        3) s[i] == \\'1\\': 11[1] to 111: -> cost(11) -> 111\\n        4) s[i] == \\'1\\': 00[1] to 000: -> cost(11) + invert(111) -> 000\\n        \"\"\"\\n        def fill(dp_0, dp_1, s):\\n            for i in range(N):\\n                if s[i] == \\'0\\':\\n                    dp_0[i] = dp_0[i - 1]\\n                    dp_1[i] = dp_0[i - 1] + i + 1\\n                else:\\n                    dp_0[i] = dp_1[i - 1] + i + 1\\n                    dp_1[i] = dp_1[i - 1]\\n\\n        N = len(s)\\n        l2r_dp_0, l2r_dp_1 = [0] * N, [0] * N,\\n        r2l_dp_0, r2l_dp_1, = [0] * (N + 1), [0] * (N + 1)\\n\\n        fill(l2r_dp_0, l2r_dp_1, s)\\n        fill(r2l_dp_0, r2l_dp_1, s[::-1])\\n       \\n        min_cost = float(inf)\\n        for i in range(N):\\n            min_cost = min(min_cost, l2r_dp_0[i] + r2l_dp_0[N - 1 - i])\\n            min_cost = min(min_cost, l2r_dp_1[i] + r2l_dp_1[N - 1 - i])\\n\\n        return min_cost\\n```\n```\\n|010101\\nwe are good as just 1 element is equal to itself -> no flips needed\\n\\n0|10101\\n0!=1 we need to make a decision - flip left or right sides, which is cheaper?\\n\\nleft: flip 0->1 which costs 1, and make it 1|10101 <-- cheaper: cost <1>\\nor\\nright: flip 10101 which costs 5, and make it 0|01010\\n\\n11|0101\\n1!=0\\n\\nleft: flip 11->00 which costs 2, and make it 00|0101 <-- cheaper: cost <2>\\nor\\nright: flip 0101 which costs 4, and make it 11|1010\\n\\n000|101\\n0!=1\\n\\nleft: flip 000->111 which costs 3, and make it 111|101 <-- cheaper: cost <3>, let\\'g go with this one\\nor\\nright: flip 101 which costs 3, and make it 000|010 <-- cheaper: cost <3>\\n\\n1111|01\\n1!=0\\n\\nleft: flip 1111->0000 which costs 4, and make it 0000|01\\nor\\nright: flip 01 which costs 2, and make it 1111|10 <-- cheaper: cost <2>\\n\\n11111|0\\n0!=1\\n\\nleft: flip 11111->00000 which costs 5, and make it 00000|0\\nor\\nright: flip 0 which costs 1, and make it 11111|1 <-- cheaper: cost <1>\\n\\nTotal cost: 1 + 2 + 3 + 2 + 1 = 9\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        N = len(s)\\n        cost = 0\\n        for i in range(N):\\n            if i and s[i - 1] != s[i]:\\n                cost += min(i, N - i)\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612711,
                "title": "sweeeeeeeeeet-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int l = 1, r = s.length()-1;\\n        int p = 0, n = 1;\\n        long long count = 0;\\n        while(n != s.length()){\\n\\n            if(s[p] != s[n]){\\n                if(l <= r){\\n                    count += l;\\n                }\\n                else {\\n                    count += r;\\n                }\\n            }\\n            l++; r--; p++; n++;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int l = 1, r = s.length()-1;\\n        int p = 0, n = 1;\\n        long long count = 0;\\n        while(n != s.length()){\\n\\n            if(s[p] != s[n]){\\n                if(l <= r){\\n                    count += l;\\n                }\\n                else {\\n                    count += r;\\n                }\\n            }\\n            l++; r--; p++; n++;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609343,
                "title": "python-easy-to-understand-solution-prefix-sum",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \\n        # going left to right\\n        cost = 0\\n        prev = \\'\\'\\n        ans = float(\\'inf\\')\\n        prefix = []\\n        for i in range(len(s)):\\n            if not prev:\\n                prev = s[i]\\n                prefix.append((cost, s[i]))\\n                continue\\n            if prev != s[i]:\\n                cost += i \\n                prev = s[i]\\n            prefix.append((cost, s[i]))\\n        \\n        # going right to left\\n        \\n        s = s[::-1]\\n        cost = 0\\n        prev = \\'\\'\\n        suffix = []\\n        for i in range(len(s)):\\n            if not prev:\\n                prev = s[i]\\n                suffix.append((cost, s[i]))\\n                continue\\n            if prev != s[i]:\\n                cost += i \\n                prev = s[i]\\n            suffix.append((cost, s[i]))\\n                \\n        suffix = suffix[::-1]\\n        \\n        for i in range(len(prefix)):\\n            if prefix[i][1] == suffix[i][1]:\\n                ans = min(ans, prefix[i][0] + suffix[i][0])\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \\n        # going left to right\\n        cost = 0\\n        prev = \\'\\'\\n        ans = float(\\'inf\\')\\n        prefix = []\\n        for i in range(len(s)):\\n            if not prev:\\n                prev = s[i]\\n                prefix.append((cost, s[i]))\\n                continue\\n            if prev != s[i]:\\n                cost += i \\n                prev = s[i]\\n            prefix.append((cost, s[i]))\\n        \\n        # going right to left\\n        \\n        s = s[::-1]\\n        cost = 0\\n        prev = \\'\\'\\n        suffix = []\\n        for i in range(len(s)):\\n            if not prev:\\n                prev = s[i]\\n                suffix.append((cost, s[i]))\\n                continue\\n            if prev != s[i]:\\n                cost += i \\n                prev = s[i]\\n            suffix.append((cost, s[i]))\\n                \\n        suffix = suffix[::-1]\\n        \\n        for i in range(len(prefix)):\\n            if prefix[i][1] == suffix[i][1]:\\n                ans = min(ans, prefix[i][0] + suffix[i][0])\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605501,
                "title": "c-dynamic-programming-prefix-and-suffix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int sz = s.size();\\n        vector<vector<long long>> prefixDp(s.size()+1,{0,0});\\n        for(int i=1;i<=sz;i++){\\n            if (s[i-1]==\\'0\\'){\\n                prefixDp[i][0]=min(prefixDp[i-1][0],prefixDp[i-1][1]+i-1);\\n                prefixDp[i][1]=min(prefixDp[i-1][0]+i,prefixDp[i-1][1]+i+i-1);\\n            }\\n            else{\\n                prefixDp[i][1]=min(prefixDp[i-1][1],prefixDp[i-1][0]+i-1);\\n                prefixDp[i][0]=min(prefixDp[i-1][1]+i,prefixDp[i-1][0]+i+i-1);\\n            }\\n        }\\n        \\n        \\n        vector<vector<long long>> suffixDp(s.size()+1,{0,0});\\n        for(int i=sz-1;i>=0;i--){\\n            if (s[i]==\\'0\\'){\\n                suffixDp[i][0]=min(suffixDp[i+1][0],suffixDp[i+1][1]+sz-(i+1));\\n                suffixDp[i][1]=min(suffixDp[i+1][0]+sz-i,suffixDp[i+1][1]+sz-(i+1)+sz-i);\\n            }\\n            else{\\n                suffixDp[i][1]=min(suffixDp[i+1][1],suffixDp[i+1][0]+sz-(i+1));\\n                suffixDp[i][0]=min(suffixDp[i+1][1]+sz-i,suffixDp[i+1][0]+sz-(i+1)+sz-i);\\n            }\\n        }\\n        long long ans =1LL*sz*sz;\\n        for(int i=0;i<=sz;i++){\\n            //cout << \"i:\" << i << \" prefix0: \"<< prefixDp[i][0] << \" prefix1: \"<< prefixDp[i][1] << \" suffix0: \"<< suffixDp[i][0] << \" suffix1: \"<< suffixDp[i][1] << endl;\\n            ans = min(ans,min(prefixDp[i][0]+suffixDp[i][0],prefixDp[i][1]+suffixDp[i][1]));\\n            ans = min(ans,prefixDp[i][0]+suffixDp[i][1]+i);\\n            ans = min(ans,prefixDp[i][0]+suffixDp[i][1]+sz-i);\\n            ans = min(ans,prefixDp[i][1]+suffixDp[i][0]+i);\\n            ans = min(ans,prefixDp[i][1]+suffixDp[i][0]+sz-i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int sz = s.size();\\n        vector<vector<long long>> prefixDp(s.size()+1,{0,0});\\n        for(int i=1;i<=sz;i++){\\n            if (s[i-1]==\\'0\\'){\\n                prefixDp[i][0]=min(prefixDp[i-1][0],prefixDp[i-1][1]+i-1);\\n                prefixDp[i][1]=min(prefixDp[i-1][0]+i,prefixDp[i-1][1]+i+i-1);\\n            }\\n            else{\\n                prefixDp[i][1]=min(prefixDp[i-1][1],prefixDp[i-1][0]+i-1);\\n                prefixDp[i][0]=min(prefixDp[i-1][1]+i,prefixDp[i-1][0]+i+i-1);\\n            }\\n        }\\n        \\n        \\n        vector<vector<long long>> suffixDp(s.size()+1,{0,0});\\n        for(int i=sz-1;i>=0;i--){\\n            if (s[i]==\\'0\\'){\\n                suffixDp[i][0]=min(suffixDp[i+1][0],suffixDp[i+1][1]+sz-(i+1));\\n                suffixDp[i][1]=min(suffixDp[i+1][0]+sz-i,suffixDp[i+1][1]+sz-(i+1)+sz-i);\\n            }\\n            else{\\n                suffixDp[i][1]=min(suffixDp[i+1][1],suffixDp[i+1][0]+sz-(i+1));\\n                suffixDp[i][0]=min(suffixDp[i+1][1]+sz-i,suffixDp[i+1][0]+sz-(i+1)+sz-i);\\n            }\\n        }\\n        long long ans =1LL*sz*sz;\\n        for(int i=0;i<=sz;i++){\\n            //cout << \"i:\" << i << \" prefix0: \"<< prefixDp[i][0] << \" prefix1: \"<< prefixDp[i][1] << \" suffix0: \"<< suffixDp[i][0] << \" suffix1: \"<< suffixDp[i][1] << endl;\\n            ans = min(ans,min(prefixDp[i][0]+suffixDp[i][0],prefixDp[i][1]+suffixDp[i][1]));\\n            ans = min(ans,prefixDp[i][0]+suffixDp[i][1]+i);\\n            ans = min(ans,prefixDp[i][0]+suffixDp[i][1]+sz-i);\\n            ans = min(ans,prefixDp[i][1]+suffixDp[i][0]+i);\\n            ans = min(ans,prefixDp[i][1]+suffixDp[i][0]+sz-i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3605379,
                "title": "c-python-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question goal is to minimize the cost , it can be done by using **Greedy Algorithm , Dynamic Programming , Divide and Conquer** etc.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Greedy Approach , Iterating over different pair `01` or `10` and finding minimum cost `cost += min(index,n-index)`.\\n```\\nif (string[index]!=string[index+1]){\\n    cost += min(index+1,n-(index+1));\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long  ans = 0;\\n        int n = s.size();\\n        for (int i=0;i<n-1;i++){\\n            if (s[i]!=s[i+1]){\\n                ans += min( i+1 ,n-i-1);\\n            } \\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n            ans =0\\n            n=len(s)\\n            for i in range(n-1):\\n                if (s[i]!=s[i+1]):\\n                    ans+=min(n-i-1,i+1)\\n            return ans\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nif (string[index]!=string[index+1]){\\n    cost += min(index+1,n-(index+1));\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long  ans = 0;\\n        int n = s.size();\\n        for (int i=0;i<n-1;i++){\\n            if (s[i]!=s[i+1]){\\n                ans += min( i+1 ,n-i-1);\\n            } \\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n            ans =0\\n            n=len(s)\\n            for i in range(n-1):\\n                if (s[i]!=s[i+1]):\\n                    ans+=min(n-i-1,i+1)\\n            return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604007,
                "title": "no-dp-involved",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntraverse through the array and if the ith and next element does not match than there exists 2 cases:\\n1) cost from starting is less than add i+1\\n2) cost from ending is less than add n-i-1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s){\\n        long ans = 0;\\n        int n = s.length();\\n        for (int i = 0; i < s.length() - 1; ++i)\\n        {\\n            if (s.charAt(i) != s.charAt(i + 1))\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s){\\n        long ans = 0;\\n        int n = s.length();\\n        for (int i = 0; i < s.length() - 1; ++i)\\n        {\\n            if (s.charAt(i) != s.charAt(i + 1))\\n            {\\n                if (i + 1 <= n - i - 1)\\n                    ans += i + 1;\\n                else\\n                    ans += n - i - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591086,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) to avoid TLE, we can preprocess the input to reduce the asymptotic bounds of considering all optimal possibilities.  Similar to Kadane\\'s algorithm, we can track the \"best ending/beginning here\" for each `k`<sup>th</sup> ending/beginning value from `0..1` inclusive at each `i`<sup>th</sup> prefix index and each `j`<sup>th</sup> suffix index of the input string `s` formulated from left-to-right and right-to-left as `L` and `R` correspondingly, then we perform a linear scan to consider the cost of each `i`<sup>th</sup> prefix/suffix index candidate as `L[i][k] + R[i][k]` ending/beginning in the value `k = 0..1` inclusive.\\n\\n**\\uD83D\\uDC49 Prefix \\uD83E\\uDD14 Recurrence Relation Details:** For each `k`<sup>th</sup> ending value from `k = 0..1` inclusive, there are two possibilities to consider each each `i`<sup>th</sup> prefix:\\n\\n* **\\uD83D\\uDEAB Case 1:** if `s[i] == k`, then there is **no additional cost** since we do *not* need to flip this bit.  Thus, we set the `i`<sup>th</sup> cost to the previous `i - 1`<sup>th</sup> cost.\\n    * if `s[i] == k` then `L[i][k] = L[i - 1][k]`\\n\\n* **\\u2705 Case 2:** if `s[i] != k`, then the **additional cost** is `i + 1`, ie. the cost to flip the current `i`<sup>th</sup> bit to ending value `k` *plus* the cost of flipping the previous `i - 1`<sup>th</sup> prefix to the *opposite* value of `k`.\\n    * if `s[i] != k` then `L[i][k] = L[i - 1][k ^ 1]`\\n\\n**\\uD83D\\uDC48 Suffix \\uD83E\\uDD14 Recurrence Relation Details:** For each `k`<sup>th</sup> beginning value from `k = 0..1` inclusive, there are two possibilities to consider each each `j`<sup>th</sup> suffix:\\n\\n* **\\uD83D\\uDEAB Case 1:** if `s[j] == k`, then there is **no additional cost** since we do *not* need to flip this bit.  Thus, we set the `j`<sup>th</sup> cost to the previous `j + 1`<sup>th</sup> cost.\\n    * if `s[j] == k` then `R[j][k] = R[j + 1][k]`\\n\\n* **\\u2705 Case 2:** if `s[j] != k`, then the **additional cost** is `N - j`, ie. the cost to flip the current `j`<sup>th</sup> bit to beginning value `k` *plus* the cost of flipping the previous `j + 1`<sup>th</sup> suffix to the *opposite* value of `k`.\\n    * if `s[j] != k` then `R[j][k] = R[j + 1][k ^ 1]`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumCost(s: String): Long {\\n        var A = s.toCharArray().map{ if (it == \\'0\\') 0 else 1 }\\n        var N = s.length\\n        var L = Array(N){ LongArray(2) }\\n        var R = Array(N){ LongArray(2) }\\n        for (i in 0 until N) {\\n            var j = N - 1 - i\\n            for (k in 0..1) {\\n                L[i][k] = if (A[i] == k) { if (0 <= i - 1) L[i - 1][k] else 0 } else { i + 1 + if (0 <= i - 1) L[i - 1][k xor 1] else 0 }\\n                R[j][k] = if (A[j] == k) { if (j + 1 < N) R[j + 1][k] else 0 } else { N - j + if (j + 1 < N) R[j + 1][k xor 1] else 0 }\\n            }\\n        }\\n        return (0 until N).map{ i -> (0..1).map{ k -> L[i][k] + R[i][k] } }.flatten().min()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumCost = (s, N = s.length, L = [...Array(N)].map(_ => Array(2).fill(0)), R = [...Array(N)].map(_ => Array(2).fill(0))) => {\\n    for (let i = 0; i < N; ++i) {\\n        let j = N - 1 - i;\\n        for (let k = 0; k < 2; ++k) {\\n            L[i][k] = Number(s[i]) == k ? (0 <= i - 1 ? L[i - 1][k] : 0) : (i + 1 + (0 <= i - 1 ? L[i - 1][k ^ 1] : 0));\\n            R[j][k] = Number(s[j]) == k ? (j + 1 < N ? R[j + 1][k] : 0) : (N - j + (j + 1 < N ? R[j + 1][k ^ 1] : 0));\\n        }\\n    }\\n    return Math.min(..._.flatten(_.range(0, N).map(i => _.range(0, 2).map(k => L[i][k] + R[i][k]))));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        N = len(s)\\n        L = [[0] * 2 for _ in range(N)]\\n        R = [[0] * 2 for _ in range(N)]\\n        for i in range(N):\\n            j = N - i - 1\\n            for k in range(2):\\n                L[i][k] = (L[i - 1][k] if 0 <= i - 1 else 0) if int(s[i]) == k else (i + 1) + (L[i - 1][k ^ 1] if 0 <= i - 1 else 0)\\n                R[j][k] = (R[j + 1][k] if j + 1 < N else 0) if int(s[j]) == k else (N - j) + (R[j + 1][k ^ 1] if j + 1 < N else 0)\\n        return min(L[i][k] + R[i][k] for k in range(2) for i in range(N))\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_cost(s: String) -> i64 {\\n        let A = s.chars().map(|c| if c == \\'0\\' { 0 } else { 1 }).collect::<Vec<usize>>();\\n        let N = A.len();\\n        let (mut L, mut R) = (vec![vec![0i64; 2]; N], vec![vec![0i64; 2]; N]);\\n        for i in 0..N {\\n            let j = N - 1 - i;\\n            for k in 0..=1 {\\n                L[i][k] = if A[i] == k { if 0 <= i as i32 - 1 { L[i - 1][k] } else { 0 } } else { (i + 1) as i64 + if 0 <= i as i32 - 1 { L[i - 1][k ^ 1] } else { 0 } };\\n                R[j][k] = if A[j] == k { if j + 1 < N { R[j + 1][k] } else { 0 } } else { (N - j) as i64 + if j + 1 < N { R[j + 1][k ^ 1] } else { 0 } };\\n            }\\n        }\\n        let mut best = (1e5 * 1e5) as i64;\\n        for i in 0..N {\\n            for k in 0..=1 {\\n                best = min(best, L[i][k] + R[i][k]);\\n            }\\n        }\\n        best\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VVL = vector<VL>;\\n    LL minimumCost(string s, LL best = LL(1e5) * LL(1e5)) {\\n        int N = s.size();\\n        VVL L(N, VL(2)),\\n            R(N, VL(2));\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto j = N - 1 - i;\\n            for (auto k{ 0 }; k < 2; ++k) {\\n                L[i][k] = s[i] - \\'0\\' == k ? (0 <= i - 1 ? L[i - 1][k] : 0) : (i + 1 + (0 <= i - 1 ? L[i - 1][k ^ 1] : 0));\\n                R[j][k] = s[j] - \\'0\\' == k ? (j + 1 < N ? R[j + 1][k] : 0) : (N - j + (j + 1 < N ? R[j + 1][k ^ 1] : 0));\\n            }\\n        }\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto k{ 0 }; k < 2; ++k)\\n                best = min(best, L[i][k] + R[i][k]);\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumCost(s: String): Long {\\n        var A = s.toCharArray().map{ if (it == \\'0\\') 0 else 1 }\\n        var N = s.length\\n        var L = Array(N){ LongArray(2) }\\n        var R = Array(N){ LongArray(2) }\\n        for (i in 0 until N) {\\n            var j = N - 1 - i\\n            for (k in 0..1) {\\n                L[i][k] = if (A[i] == k) { if (0 <= i - 1) L[i - 1][k] else 0 } else { i + 1 + if (0 <= i - 1) L[i - 1][k xor 1] else 0 }\\n                R[j][k] = if (A[j] == k) { if (j + 1 < N) R[j + 1][k] else 0 } else { N - j + if (j + 1 < N) R[j + 1][k xor 1] else 0 }\\n            }\\n        }\\n        return (0 until N).map{ i -> (0..1).map{ k -> L[i][k] + R[i][k] } }.flatten().min()!!\\n    }\\n}\\n```\n```\\nlet minimumCost = (s, N = s.length, L = [...Array(N)].map(_ => Array(2).fill(0)), R = [...Array(N)].map(_ => Array(2).fill(0))) => {\\n    for (let i = 0; i < N; ++i) {\\n        let j = N - 1 - i;\\n        for (let k = 0; k < 2; ++k) {\\n            L[i][k] = Number(s[i]) == k ? (0 <= i - 1 ? L[i - 1][k] : 0) : (i + 1 + (0 <= i - 1 ? L[i - 1][k ^ 1] : 0));\\n            R[j][k] = Number(s[j]) == k ? (j + 1 < N ? R[j + 1][k] : 0) : (N - j + (j + 1 < N ? R[j + 1][k ^ 1] : 0));\\n        }\\n    }\\n    return Math.min(..._.flatten(_.range(0, N).map(i => _.range(0, 2).map(k => L[i][k] + R[i][k]))));\\n};\\n```\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        N = len(s)\\n        L = [[0] * 2 for _ in range(N)]\\n        R = [[0] * 2 for _ in range(N)]\\n        for i in range(N):\\n            j = N - i - 1\\n            for k in range(2):\\n                L[i][k] = (L[i - 1][k] if 0 <= i - 1 else 0) if int(s[i]) == k else (i + 1) + (L[i - 1][k ^ 1] if 0 <= i - 1 else 0)\\n                R[j][k] = (R[j + 1][k] if j + 1 < N else 0) if int(s[j]) == k else (N - j) + (R[j + 1][k ^ 1] if j + 1 < N else 0)\\n        return min(L[i][k] + R[i][k] for k in range(2) for i in range(N))\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_cost(s: String) -> i64 {\\n        let A = s.chars().map(|c| if c == \\'0\\' { 0 } else { 1 }).collect::<Vec<usize>>();\\n        let N = A.len();\\n        let (mut L, mut R) = (vec![vec![0i64; 2]; N], vec![vec![0i64; 2]; N]);\\n        for i in 0..N {\\n            let j = N - 1 - i;\\n            for k in 0..=1 {\\n                L[i][k] = if A[i] == k { if 0 <= i as i32 - 1 { L[i - 1][k] } else { 0 } } else { (i + 1) as i64 + if 0 <= i as i32 - 1 { L[i - 1][k ^ 1] } else { 0 } };\\n                R[j][k] = if A[j] == k { if j + 1 < N { R[j + 1][k] } else { 0 } } else { (N - j) as i64 + if j + 1 < N { R[j + 1][k ^ 1] } else { 0 } };\\n            }\\n        }\\n        let mut best = (1e5 * 1e5) as i64;\\n        for i in 0..N {\\n            for k in 0..=1 {\\n                best = min(best, L[i][k] + R[i][k]);\\n            }\\n        }\\n        best\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VVL = vector<VL>;\\n    LL minimumCost(string s, LL best = LL(1e5) * LL(1e5)) {\\n        int N = s.size();\\n        VVL L(N, VL(2)),\\n            R(N, VL(2));\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto j = N - 1 - i;\\n            for (auto k{ 0 }; k < 2; ++k) {\\n                L[i][k] = s[i] - \\'0\\' == k ? (0 <= i - 1 ? L[i - 1][k] : 0) : (i + 1 + (0 <= i - 1 ? L[i - 1][k ^ 1] : 0));\\n                R[j][k] = s[j] - \\'0\\' == k ? (j + 1 < N ? R[j + 1][k] : 0) : (N - j + (j + 1 < N ? R[j + 1][k ^ 1] : 0));\\n            }\\n        }\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto k{ 0 }; k < 2; ++k)\\n                best = min(best, L[i][k] + R[i][k]);\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591078,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def minimumCost(s: String): Long = {\\n    val n = s.length\\n    (1 until n).foldLeft(0L)((acc, i) =>{\\n      if(s.charAt(i) != s.charAt(i - 1)) acc + (i min n - i)\\n      else acc\\n    })\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def minimumCost(s: String): Long = {\\n    val n = s.length\\n    (1 until n).foldLeft(0L)((acc, i) =>{\\n      if(s.charAt(i) != s.charAt(i - 1)) acc + (i min n - i)\\n      else acc\\n    })\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3590137,
                "title": "rust",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefix sum dp \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_cost(s: String) -> i64 {\\n     \\n        //dp \\n        let s = s.chars().into_iter().collect::<Vec<char>>();\\n        \\n        let n = s.len();\\n        let mut dp1 = vec![vec![0i64; 2]; n];//minimum cost to convert 0 or 1 till 0..i \\n        let mut dp2 = vec![vec![0i64; 2]; n];//minimum cost to convert 0 or 1 till i from right\\n\\n        for i in 0..n{\\n            \\n            let one_cost = if s[i]==\\'1\\' {0} else {1};\\n            let zero_cost = 1-one_cost ; \\n            \\n            if i>0{\\n                if s[i]==\\'0\\'{\\n                    dp1[i][0] = dp1[i-1][0];\\n                }else{\\n                    dp1[i][0] = dp1[i-1][1]+ i as i64+1;\\n                }\\n                \\n                if s[i]==\\'1\\'{\\n                    dp1[i][1] = dp1[i-1][1];\\n                }else{\\n                    dp1[i][1] = dp1[i-1][0]+ i as i64+1;\\n                }\\n            }else{\\n                dp1[0][0] = zero_cost;\\n                dp1[0][1] = one_cost;\\n            }\\n        }\\n        \\n        println!(\"{:?}\", dp1);\\n        let mut ans: i64 =  dp1[n-1][0].min(dp1[n-1][1]);\\n        \\n        for i in (0..n).rev(){\\n            let one_cost = if s[i]==\\'1\\' {0} else {1};\\n            let zero_cost = 1-one_cost ; \\n            \\n            if i<n-1{\\n                if s[i]==\\'0\\'{\\n                    dp2[i][0] = dp2[i+1][0];\\n                }else{\\n                    dp2[i][0] = dp2[i+1][1]+ (n-i) as i64;\\n                }\\n                \\n                if s[i]==\\'1\\'{\\n                    dp2[i][1] = dp2[i+1][1];\\n                }else{\\n                    dp2[i][1] = dp2[i+1][0]+ (n-i) as i64;\\n                }\\n            }else{\\n                dp2[i][0] = zero_cost;\\n                dp2[i][1] = one_cost;\\n            }\\n            \\n        }\\n        \\n        ans = ans.min(dp2[0][0].min(dp2[0][1]));\\n        \\n        for i in 0..n{\\n            if i+1<n{\\n                ans = ans.min(dp1[i][0]+dp2[i+1][0]);\\n                ans = ans.min(dp1[i][1]+dp2[i+1][1]);\\n            }\\n        \\n        }\\n        ans\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_cost(s: String) -> i64 {\\n     \\n        //dp \\n        let s = s.chars().into_iter().collect::<Vec<char>>();\\n        \\n        let n = s.len();\\n        let mut dp1 = vec![vec![0i64; 2]; n];//minimum cost to convert 0 or 1 till 0..i \\n        let mut dp2 = vec![vec![0i64; 2]; n];//minimum cost to convert 0 or 1 till i from right\\n\\n        for i in 0..n{\\n            \\n            let one_cost = if s[i]==\\'1\\' {0} else {1};\\n            let zero_cost = 1-one_cost ; \\n            \\n            if i>0{\\n                if s[i]==\\'0\\'{\\n                    dp1[i][0] = dp1[i-1][0];\\n                }else{\\n                    dp1[i][0] = dp1[i-1][1]+ i as i64+1;\\n                }\\n                \\n                if s[i]==\\'1\\'{\\n                    dp1[i][1] = dp1[i-1][1];\\n                }else{\\n                    dp1[i][1] = dp1[i-1][0]+ i as i64+1;\\n                }\\n            }else{\\n                dp1[0][0] = zero_cost;\\n                dp1[0][1] = one_cost;\\n            }\\n        }\\n        \\n        println!(\"{:?}\", dp1);\\n        let mut ans: i64 =  dp1[n-1][0].min(dp1[n-1][1]);\\n        \\n        for i in (0..n).rev(){\\n            let one_cost = if s[i]==\\'1\\' {0} else {1};\\n            let zero_cost = 1-one_cost ; \\n            \\n            if i<n-1{\\n                if s[i]==\\'0\\'{\\n                    dp2[i][0] = dp2[i+1][0];\\n                }else{\\n                    dp2[i][0] = dp2[i+1][1]+ (n-i) as i64;\\n                }\\n                \\n                if s[i]==\\'1\\'{\\n                    dp2[i][1] = dp2[i+1][1];\\n                }else{\\n                    dp2[i][1] = dp2[i+1][0]+ (n-i) as i64;\\n                }\\n            }else{\\n                dp2[i][0] = zero_cost;\\n                dp2[i][1] = one_cost;\\n            }\\n            \\n        }\\n        \\n        ans = ans.min(dp2[0][0].min(dp2[0][1]));\\n        \\n        for i in 0..n{\\n            if i+1<n{\\n                ans = ans.min(dp1[i][0]+dp2[i+1][0]);\\n                ans = ans.min(dp1[i][1]+dp2[i+1][1]);\\n            }\\n        \\n        }\\n        ans\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589141,
                "title": "c-easy-to-understand-solution",
                "content": "# Please dont forget to UPVOTE\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            //please upvote while loop is executing;\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Please dont forget to UPVOTE",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            //please upvote while loop is executing;\\n            if(s[i]!=s[i+1]) ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587803,
                "title": "python-just-check-the-cost-of-change-the-string-to-all-1s-and-to-all-0s",
                "content": "Since the final string can only be all 1s or all 0s, we can simply calculate the cost to change the string to all 1s and to all 0s. Finally, we return the minimum of the cost.\\n\\nAnother trick is doing the flip operations from the middle to both front and end side.\\n\\nsee the code for details:\\n\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        self.len_s = len(s)\\n        # starting from the middle and try to convert the string to 1s or 0s\\n        self.s = s\\n        self.pattern = [\\'0\\', \\'1\\']\\n        if self.len_s % 2:\\n            sidx = self.len_s // 2\\n            if s[sidx] == \\'0\\':\\n                cost0 = self.getCost(sidx - 1, True, 0) + self.getCost(sidx + 1, False , 0)\\n                cost1 = min(self.getCost(sidx, True, 1) + self.getCost(sidx + 1, False, 1), self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1))\\n            else:\\n                cost1 = self.getCost(sidx - 1, True, 1) + self.getCost(sidx + 1, False, 1)\\n                cost0 = min(self.getCost(sidx, True, 0) + self.getCost(sidx + 1, False, 0), self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1))\\n        else:\\n            sidx = self.len_s // 2\\n            cost0 = self.getCost(sidx - 1, True, 0) + self.getCost(sidx, False, 0)\\n            cost1 = self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1)\\n        return min(cost0, cost1)\\n    \\n        \\n    def getCost(self, idx, forward, pat):\\n        cost, curp_idx, cur_pat = 0, pat, self.pattern[pat]\\n        if forward:\\n            while idx >= 0:\\n                if self.s[idx] != cur_pat:\\n                    cost += idx + 1\\n                    curp_idx = (curp_idx + 1) % 2\\n                    cur_pat = self.pattern[curp_idx]\\n                idx -= 1\\n        else:\\n            while idx < self.len_s:\\n                if self.s[idx] != cur_pat:\\n                    cost += (self.len_s - idx)\\n                    curp_idx = (curp_idx + 1) % 2\\n                    cur_pat = self.pattern[curp_idx]\\n                idx += 1\\n        return cost\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        self.len_s = len(s)\\n        # starting from the middle and try to convert the string to 1s or 0s\\n        self.s = s\\n        self.pattern = [\\'0\\', \\'1\\']\\n        if self.len_s % 2:\\n            sidx = self.len_s // 2\\n            if s[sidx] == \\'0\\':\\n                cost0 = self.getCost(sidx - 1, True, 0) + self.getCost(sidx + 1, False , 0)\\n                cost1 = min(self.getCost(sidx, True, 1) + self.getCost(sidx + 1, False, 1), self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1))\\n            else:\\n                cost1 = self.getCost(sidx - 1, True, 1) + self.getCost(sidx + 1, False, 1)\\n                cost0 = min(self.getCost(sidx, True, 0) + self.getCost(sidx + 1, False, 0), self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1))\\n        else:\\n            sidx = self.len_s // 2\\n            cost0 = self.getCost(sidx - 1, True, 0) + self.getCost(sidx, False, 0)\\n            cost1 = self.getCost(sidx - 1, True, 1) + self.getCost(sidx, False, 1)\\n        return min(cost0, cost1)\\n    \\n        \\n    def getCost(self, idx, forward, pat):\\n        cost, curp_idx, cur_pat = 0, pat, self.pattern[pat]\\n        if forward:\\n            while idx >= 0:\\n                if self.s[idx] != cur_pat:\\n                    cost += idx + 1\\n                    curp_idx = (curp_idx + 1) % 2\\n                    cur_pat = self.pattern[curp_idx]\\n                idx -= 1\\n        else:\\n            while idx < self.len_s:\\n                if self.s[idx] != cur_pat:\\n                    cost += (self.len_s - idx)\\n                    curp_idx = (curp_idx + 1) % 2\\n                    cur_pat = self.pattern[curp_idx]\\n                idx += 1\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585342,
                "title": "simple-js-code-with-complete-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n  /** \\n    here what we are going to do is \\n    we are going to itrate through the string \\n    => and check if the value at ith postion is same as value at i-1th postion \\n\\n=> if they are not same we have to make it same \\n=> we can do two operations we can make value upto i-1 same as i or\\nwe can make values of i to n same as the value at i-1th index\\n\\n=>the cost of converting value from 0 to i is i+1 \\nso cost of converting value from o to i-1 is i+1-1==i;\\n\\nso we need to calculate cost as cost+= Math.min(i,s.length-i); \\n     */\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumCost = function(s) {\\n  \\n\\n    let cost = 0;\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]!=s[i-1]){\\n            cost+=Math.min(i,s.length-i);\\n        }\\n    }\\n    return cost;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumCost = function(s) {\\n  \\n\\n    let cost = 0;\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]!=s[i-1]){\\n            cost+=Math.min(i,s.length-i);\\n        }\\n    }\\n    return cost;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585268,
                "title": "a-sad-dp-cuz-my-analytical-skills-suck",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we flip bits, for a prefix only 2 types of strings are possible.\\nSo there is a scope for re-usability of subproblem solution (screaming DP!) [although later i found out a simple greedy exists ;-;]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet inv be the inverse of input string\\ns = \"010101\" => inv = \"101010\"\\n```\\ndp[i][0] = dp[i - 1][0] if s[i] == 0\\nelse\\ndp[i][0] = i + 1 + dp_inv[i - 1][0]\\n```\\nBecause if we flip a character, then entire prefix is flipped and hence we can use solution from the inversed prefix.\\n\\nDivide the strings into two half and for second half only perform suffix ops.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(2 * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        if (n == 1) return 0;\\n        string inv = \"\";\\n        for (int i = 0; i < n; i++) {\\n            inv += (s[i] == \\'0\\' ? \\'1\\' : \\'0\\');\\n        }\\n        // cout << inv << \"\\\\n\";\\n        vector<vector<long long>> cost(n , vector<long long>(2 , 0));\\n        vector<vector<long long>> cost_inv(n , vector<long long>(2 , 0));\\n        cost[0][0] = (s[0] != \\'0\\');\\n        cost[0][1] = (s[0] != \\'1\\');\\n        cost_inv[0][0] = (inv[0] != \\'0\\');\\n        cost_inv[0][1] = (inv[0] != \\'1\\');\\n        int half = (n - 1) / 2;\\n        // cout << half << \"\\\\n\";\\n        for (int i = 1; i <= half; i++) {\\n            if (s[i] == \\'0\\') {\\n                cost[i][0] = cost[i - 1][0];\\n                cost[i][1] = (i + 1) + cost_inv[i - 1][1];\\n                cost_inv[i][0] = (i + 1) + cost[i - 1][0];\\n                cost_inv[i][1] = cost_inv[i - 1][1];\\n            } else {\\n                cost[i][0] = (i + 1) + cost_inv[i - 1][0];\\n                cost[i][1] = cost[i - 1][1];\\n                cost_inv[i][0] = cost_inv[i - 1][0];\\n                cost_inv[i][1] = (i + 1) + cost[i - 1][1];\\n            } \\n        }\\n        cost[n - 1][0] = (s[n - 1] != \\'0\\');\\n        cost[n - 1][1] = (s[n - 1] != \\'1\\');\\n        cost_inv[n - 1][0] = (inv[n - 1] != \\'0\\');\\n        cost_inv[n - 1][1] = (inv[n - 1] != \\'1\\');\\n        for (int i = n - 2; i > half; i--) {\\n          if (s[i] == \\'0\\') {\\n                cost[i][0] = cost[i + 1][0];\\n                cost[i][1] = (n - i) + cost_inv[i + 1][1];\\n                cost_inv[i][0] = (n - i) + cost[i + 1][0];\\n                cost_inv[i][1] = cost_inv[i + 1][1];\\n            } else {\\n                cost[i][0] = (n - i) + cost_inv[i + 1][0];\\n                cost[i][1] = cost[i + 1][1];\\n                cost_inv[i][0] = cost_inv[i + 1][0];\\n                cost_inv[i][1] = (n - i) + cost[i + 1][1];\\n            }  \\n        }\\n        long long one = cost[half][1] + cost[half + 1][1];\\n        // cout << cost[half][1] << \" \" << cost[half + 1][1] << \"\\\\n\";\\n        long long zero = cost[half][0] + cost[half + 1][0];\\n        return min(one , zero);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][0] = dp[i - 1][0] if s[i] == 0\\nelse\\ndp[i][0] = i + 1 + dp_inv[i - 1][0]\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        if (n == 1) return 0;\\n        string inv = \"\";\\n        for (int i = 0; i < n; i++) {\\n            inv += (s[i] == \\'0\\' ? \\'1\\' : \\'0\\');\\n        }\\n        // cout << inv << \"\\\\n\";\\n        vector<vector<long long>> cost(n , vector<long long>(2 , 0));\\n        vector<vector<long long>> cost_inv(n , vector<long long>(2 , 0));\\n        cost[0][0] = (s[0] != \\'0\\');\\n        cost[0][1] = (s[0] != \\'1\\');\\n        cost_inv[0][0] = (inv[0] != \\'0\\');\\n        cost_inv[0][1] = (inv[0] != \\'1\\');\\n        int half = (n - 1) / 2;\\n        // cout << half << \"\\\\n\";\\n        for (int i = 1; i <= half; i++) {\\n            if (s[i] == \\'0\\') {\\n                cost[i][0] = cost[i - 1][0];\\n                cost[i][1] = (i + 1) + cost_inv[i - 1][1];\\n                cost_inv[i][0] = (i + 1) + cost[i - 1][0];\\n                cost_inv[i][1] = cost_inv[i - 1][1];\\n            } else {\\n                cost[i][0] = (i + 1) + cost_inv[i - 1][0];\\n                cost[i][1] = cost[i - 1][1];\\n                cost_inv[i][0] = cost_inv[i - 1][0];\\n                cost_inv[i][1] = (i + 1) + cost[i - 1][1];\\n            } \\n        }\\n        cost[n - 1][0] = (s[n - 1] != \\'0\\');\\n        cost[n - 1][1] = (s[n - 1] != \\'1\\');\\n        cost_inv[n - 1][0] = (inv[n - 1] != \\'0\\');\\n        cost_inv[n - 1][1] = (inv[n - 1] != \\'1\\');\\n        for (int i = n - 2; i > half; i--) {\\n          if (s[i] == \\'0\\') {\\n                cost[i][0] = cost[i + 1][0];\\n                cost[i][1] = (n - i) + cost_inv[i + 1][1];\\n                cost_inv[i][0] = (n - i) + cost[i + 1][0];\\n                cost_inv[i][1] = cost_inv[i + 1][1];\\n            } else {\\n                cost[i][0] = (n - i) + cost_inv[i + 1][0];\\n                cost[i][1] = cost[i + 1][1];\\n                cost_inv[i][0] = cost_inv[i + 1][0];\\n                cost_inv[i][1] = (n - i) + cost[i + 1][1];\\n            }  \\n        }\\n        long long one = cost[half][1] + cost[half + 1][1];\\n        // cout << cost[half][1] << \" \" << cost[half + 1][1] << \"\\\\n\";\\n        long long zero = cost[half][0] + cost[half + 1][0];\\n        return min(one , zero);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3584311,
                "title": "intuitive-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        \\n        string one = \"\";\\n        string zero = \"\";\\n\\n        for (int i = 0; i < n; i++) {\\n            one.push_back(\\'1\\');\\n            zero.push_back(\\'0\\');\\n        }\\n        \\n        if (s == one || s == zero) {\\n            return 0;\\n        }\\n\\n        vector<vector<long long>> pre(2, vector<long long>(n, 0));\\n        vector<vector<long long>> suf(2, vector<long long>(n, 0));\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                pre[0][i] = s[i] == \\'0\\' ? 0 : 1;\\n                pre[1][i] = s[i] == \\'1\\' ? 0 : 1;\\n            } else {\\n                pre[0][i] = s[i] == \\'0\\' ? pre[0][i - 1] : i + 1 + pre[1][i - 1];\\n                pre[1][i] = s[i] == \\'1\\' ? pre[1][i - 1] : i + 1 + pre[0][i - 1];\\n            }\\n\\n            int j = n - i - 1;\\n            if (j == n - 1) {\\n                suf[0][j] = s[j] == \\'0\\' ? 0 : 1;\\n                suf[1][j] = s[j] == \\'1\\' ? 0 : 1;\\n            } else {\\n                suf[0][j] = s[j] == \\'0\\' ? suf[0][j + 1] : n - j + suf[1][j + 1];\\n                suf[1][j] = s[j] == \\'1\\' ? suf[1][j + 1] : n - j + suf[0][j + 1];\\n            }\\n        }    \\n\\n        long long res = LLONG_MAX;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                res = min(res, suf[s[i] - \\'0\\'][i + 1]);\\n            } else if (i == n - 1) {\\n                res = min(res, pre[s[i] - \\'0\\'][i - 1]);\\n            } else {\\n                res = min(res, pre[s[i] - \\'0\\'][i - 1] + suf[s[i] - \\'0\\'][i + 1]);\\n            }\\n        }  \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        \\n        string one = \"\";\\n        string zero = \"\";\\n\\n        for (int i = 0; i < n; i++) {\\n            one.push_back(\\'1\\');\\n            zero.push_back(\\'0\\');\\n        }\\n        \\n        if (s == one || s == zero) {\\n            return 0;\\n        }\\n\\n        vector<vector<long long>> pre(2, vector<long long>(n, 0));\\n        vector<vector<long long>> suf(2, vector<long long>(n, 0));\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                pre[0][i] = s[i] == \\'0\\' ? 0 : 1;\\n                pre[1][i] = s[i] == \\'1\\' ? 0 : 1;\\n            } else {\\n                pre[0][i] = s[i] == \\'0\\' ? pre[0][i - 1] : i + 1 + pre[1][i - 1];\\n                pre[1][i] = s[i] == \\'1\\' ? pre[1][i - 1] : i + 1 + pre[0][i - 1];\\n            }\\n\\n            int j = n - i - 1;\\n            if (j == n - 1) {\\n                suf[0][j] = s[j] == \\'0\\' ? 0 : 1;\\n                suf[1][j] = s[j] == \\'1\\' ? 0 : 1;\\n            } else {\\n                suf[0][j] = s[j] == \\'0\\' ? suf[0][j + 1] : n - j + suf[1][j + 1];\\n                suf[1][j] = s[j] == \\'1\\' ? suf[1][j + 1] : n - j + suf[0][j + 1];\\n            }\\n        }    \\n\\n        long long res = LLONG_MAX;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                res = min(res, suf[s[i] - \\'0\\'][i + 1]);\\n            } else if (i == n - 1) {\\n                res = min(res, pre[s[i] - \\'0\\'][i - 1]);\\n            } else {\\n                res = min(res, pre[s[i] - \\'0\\'][i - 1] + suf[s[i] - \\'0\\'][i + 1]);\\n            }\\n        }  \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584287,
                "title": "c-prefix-sum-and-suffix-sum-initial-approach-to-optimization",
                "content": "\\n# 1) Initially thought \\n```\\nI initally thought to calculate for all indexes , \\nif we want to make all indexes from left to curr index 0 or 1 in prefsum,\\nand from right to curr index in suffsum.\\nand then finally calculate minimum by iteraing through 0-(n-1)\\n```\\n```\\n#define ll long long        \\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        vector<vector<ll>> prefsum(2,vector<ll>(n,0)),suffsum(2,vector<ll>(n,0));\\n\\n        if(s[0]==\\'1\\') prefsum[0][0]=1;\\n        else prefsum[1][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                prefsum[0][i]=prefsum[0][i-1];\\n                prefsum[1][i]=prefsum[0][i-1]+i+1;\\n            }\\n            else{\\n                prefsum[0][i]=prefsum[1][i-1]+i+1;\\n                prefsum[1][i]=prefsum[1][i-1];\\n            }\\n        }\\n\\n        if(s[n-1]==\\'1\\') suffsum[0][n-1]=1;\\n        else suffsum[1][n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                suffsum[0][i]=suffsum[0][i+1];\\n                suffsum[1][i]=suffsum[0][i+1]+n-i;\\n            }\\n            else{\\n                suffsum[0][i]=suffsum[1][i+1]+n-i;\\n                suffsum[1][i]=suffsum[1][i+1];\\n            }\\n        }\\n\\n        ll ans=1e15;\\n        ans=min(ans,min(prefsum[0][n-1],prefsum[1][n-1]));\\n        ans=min(ans,min(suffsum[0][0],suffsum[1][0]));\\n\\n        for(int i=0;i<n-1;i++){\\n            ans=min(ans,prefsum[0][i]+suffsum[0][i+1]);\\n            ans=min(ans,prefsum[1][i]+suffsum[1][i+1]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n```\\n2) optimised the previous code.\\nI just thought that why to calculate if we want to make all index 0 or 1,\\njust look upon the character of curr idx, and calculate to make every element to right and left equal to the curr idx .\\nstore for left-> curr in prefsum, and right->curr in suffsum\\nthen our final answer should be min(prefsum[i]+suffsum[i]) for all i.\\n```\\n```\\n#define ll long long  \\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        if(n==1) return 0;\\n        \\n        vector<ll> prefsum(n,0),suffsum(n,0);\\n        for(int i=1;i<n;i++){\\n            if(s[i]!=s[i-1]) prefsum[i]=prefsum[i-1]+i;\\n            else prefsum[i]=prefsum[i-1];\\n        }\\n\\n        ll ans=1e15;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]!=s[i+1]) suffsum[i]=suffsum[i+1]+(n-1-i);\\n            else suffsum[i]=suffsum[i+1];\\n\\n            ans=min(ans,prefsum[i]+suffsum[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nI initally thought to calculate for all indexes , \\nif we want to make all indexes from left to curr index 0 or 1 in prefsum,\\nand from right to curr index in suffsum.\\nand then finally calculate minimum by iteraing through 0-(n-1)\\n```\n```\\n#define ll long long        \\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        vector<vector<ll>> prefsum(2,vector<ll>(n,0)),suffsum(2,vector<ll>(n,0));\\n\\n        if(s[0]==\\'1\\') prefsum[0][0]=1;\\n        else prefsum[1][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                prefsum[0][i]=prefsum[0][i-1];\\n                prefsum[1][i]=prefsum[0][i-1]+i+1;\\n            }\\n            else{\\n                prefsum[0][i]=prefsum[1][i-1]+i+1;\\n                prefsum[1][i]=prefsum[1][i-1];\\n            }\\n        }\\n\\n        if(s[n-1]==\\'1\\') suffsum[0][n-1]=1;\\n        else suffsum[1][n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                suffsum[0][i]=suffsum[0][i+1];\\n                suffsum[1][i]=suffsum[0][i+1]+n-i;\\n            }\\n            else{\\n                suffsum[0][i]=suffsum[1][i+1]+n-i;\\n                suffsum[1][i]=suffsum[1][i+1];\\n            }\\n        }\\n\\n        ll ans=1e15;\\n        ans=min(ans,min(prefsum[0][n-1],prefsum[1][n-1]));\\n        ans=min(ans,min(suffsum[0][0],suffsum[1][0]));\\n\\n        for(int i=0;i<n-1;i++){\\n            ans=min(ans,prefsum[0][i]+suffsum[0][i+1]);\\n            ans=min(ans,prefsum[1][i]+suffsum[1][i+1]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\n2) optimised the previous code.\\nI just thought that why to calculate if we want to make all index 0 or 1,\\njust look upon the character of curr idx, and calculate to make every element to right and left equal to the curr idx .\\nstore for left-> curr in prefsum, and right->curr in suffsum\\nthen our final answer should be min(prefsum[i]+suffsum[i]) for all i.\\n```\n```\\n#define ll long long  \\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length();\\n        if(n==1) return 0;\\n        \\n        vector<ll> prefsum(n,0),suffsum(n,0);\\n        for(int i=1;i<n;i++){\\n            if(s[i]!=s[i-1]) prefsum[i]=prefsum[i-1]+i;\\n            else prefsum[i]=prefsum[i-1];\\n        }\\n\\n        ll ans=1e15;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]!=s[i+1]) suffsum[i]=suffsum[i+1]+(n-1-i);\\n            else suffsum[i]=suffsum[i+1];\\n\\n            ans=min(ans,prefsum[i]+suffsum[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583014,
                "title": "ans",
                "content": "# APPROACH 1: \\n\\n**ALGO:**\\n\\n* basically hame saare char equal krne h\\n\\n* i=1 se shuru karo aur har s[i] ko s[i-1] se compare karo\\n\\n* agar ye dono equal h : to iska mtlb ye h ki index 0 se i tk sabhi elements equal h(kyuinki ye procedure ham shuru se krte aa rhe h)\\n\\n* aur agar unequal h to mtlb:\\n\\n\\t\\t\\t\\t\\t0 se i-1 tk to sab equal h because ye procedure ham shuru se krte aa rhe h\\n\\t\\t\\t\\t\\tbut index i-1 aur i pr values different h\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t=> ya to 0 se lekar i-1 tk inversion perform kr do taaki sab i k equal ho jae  (mtlb cost = i ko ans me add kr do)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t=> ya fir i se lekar n-1 tk inversion perform kr do taaki sab i-1 k equal ho jae  (mtlb cost = n-i ko ans me add kr do)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t=>in dono me se jo kam wali cost h us hisab se operation perform karo (GREEDY)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n**CODE :**\\n\\n```\\nlong long minimumCost(string s) {\\n        long long ans =0;\\n\\n        int n= s.length();\\n\\n        for(int i=1 ; i<n ; i++){\\n            if(s[i] != s[i-1]){\\n                ans += min(i,n-i);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n```\\n\\n# APPROACH 2\\n\\nham 2 vectors ka istemal krenge : one for calculating prefix sum and other for suffix sum\\n\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n\\n    \\n    long long minimumCost(string s) {\\n\\n        int n=s.length();\\n\\n\\n        vector<ll> prefix(n,0); \\n\\n        // prefix[i] : total cost if 0 se i-1 index tk same \\n        // char{jo ith index ka char h} krne h \\n        // ( first operation ka hi istemal kr skte h )\\n\\n        // isme left to right evaluate krenge\\n\\n        for(int i=1 ; i<n ; i++){\\n            if(s[i] == s[i-1]){\\n                prefix[i] =  prefix[i-1];\\n            }\\n            else{\\n                ll current_cost = i; // as inverting from 0 to i-1 index\\n                prefix[i] = prefix[i-1] + current_cost;\\n            }\\n        }\\n\\n\\n        vector<ll> suffix(n,0); \\n\\n        // suffix[i] : total cost if i+1 se n-i index tk same \\n        // char{jo ith index ka char h} krne h \\n        // ( first operation ka hi istemal kr skte h )\\n\\n        // isme right to left evaluate krenge\\n\\n\\n        for(int i=n-2 ; i>=0 ; i--){\\n            if(s[i] == s[i+1]){\\n                suffix[i] =  suffix[i+1];\\n            }\\n            else{\\n                ll current_cost = n-i-1; // as inverting from i+1 to n-1 index\\n                suffix[i] = suffix[i+1] + current_cost;\\n            }\\n        }\\n\\n\\n\\n        ll ans =LONG_LONG_MAX;\\n        ll res=suffix[0];\\n\\n        // ab har index pr jaenge ek ek krke\\n\\n        // for every i , hame left walo ko bhi s[i] k equal krna h aur right walo ko bhi\\n        // sabhi possibilities ka minimum hi hamara ans h\\n\\n        for(int i=0;i<n;i++){\\n\\n            ans = min( ans , prefix[i] + res );\\n\\n            if(i+1 < n){\\n                if( s[i] != s[i + 1] ){\\n                    res -= n-i-1;\\n                }\\n            }\\n        }\\n        \\n\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long minimumCost(string s) {\\n        long long ans =0;\\n\\n        int n= s.length();\\n\\n        for(int i=1 ; i<n ; i++){\\n            if(s[i] != s[i-1]){\\n                ans += min(i,n-i);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n```\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n\\n    \\n    long long minimumCost(string s) {\\n\\n        int n=s.length();\\n\\n\\n        vector<ll> prefix(n,0); \\n\\n        // prefix[i] : total cost if 0 se i-1 index tk same \\n        // char{jo ith index ka char h} krne h \\n        // ( first operation ka hi istemal kr skte h )\\n\\n        // isme left to right evaluate krenge\\n\\n        for(int i=1 ; i<n ; i++){\\n            if(s[i] == s[i-1]){\\n                prefix[i] =  prefix[i-1];\\n            }\\n            else{\\n                ll current_cost = i; // as inverting from 0 to i-1 index\\n                prefix[i] = prefix[i-1] + current_cost;\\n            }\\n        }\\n\\n\\n        vector<ll> suffix(n,0); \\n\\n        // suffix[i] : total cost if i+1 se n-i index tk same \\n        // char{jo ith index ka char h} krne h \\n        // ( first operation ka hi istemal kr skte h )\\n\\n        // isme right to left evaluate krenge\\n\\n\\n        for(int i=n-2 ; i>=0 ; i--){\\n            if(s[i] == s[i+1]){\\n                suffix[i] =  suffix[i+1];\\n            }\\n            else{\\n                ll current_cost = n-i-1; // as inverting from i+1 to n-1 index\\n                suffix[i] = suffix[i+1] + current_cost;\\n            }\\n        }\\n\\n\\n\\n        ll ans =LONG_LONG_MAX;\\n        ll res=suffix[0];\\n\\n        // ab har index pr jaenge ek ek krke\\n\\n        // for every i , hame left walo ko bhi s[i] k equal krna h aur right walo ko bhi\\n        // sabhi possibilities ka minimum hi hamara ans h\\n\\n        for(int i=0;i<n;i++){\\n\\n            ans = min( ans , prefix[i] + res );\\n\\n            if(i+1 < n){\\n                if( s[i] != s[i + 1] ){\\n                    res -= n-i-1;\\n                }\\n            }\\n        }\\n        \\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582996,
                "title": "very-easy-cpp-solution",
                "content": "# Intuition & Approach\\nWE traverse in the string if we find the opposite bit then we check which inverse will be mininum so that we choose that number of swaps to add to our ans\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n         long long ans = 0;\\n          int n=s.size();\\n       for(int i=1; i<n; i++){\\n           if(s[i]!=s[i-1])\\n           ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n         long long ans = 0;\\n          int n=s.size();\\n       for(int i=1; i<n; i++){\\n           if(s[i]!=s[i-1])\\n           ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582160,
                "title": "c-5-line-code-easy-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate string with for loop and at its every iteration check the next charcter of string.\\nIf they are not equal add the minimum value of cost of operation to convert them to equal characters.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n= s.length();\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s[i]!=s[i+1]){\\n                ans+=min(n-i-1, i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n= s.length();\\n        long long ans=0;\\n        for(int i=0;i<n-1;i++){\\n            if(s[i]!=s[i+1]){\\n                ans+=min(n-i-1, i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582016,
                "title": "c-19-ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(const string& s)\\n    {\\n        if(s.size() < 2) return 0;\\n\\n        const int half = s.size()/2;\\n        long long cost = 0;\\n\\n        for(size_t i = 1; i <= half; ++i)\\n            if(s[i] != s[i - 1])\\n                cost += i;\\n\\n        for(size_t i = s.size() - 2; i >= half; --i)\\n            if(s[i] != s[i + 1])\\n                cost += s.size() - 1 - i;\\n\\n        return cost;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(const string& s)\\n    {\\n        if(s.size() < 2) return 0;\\n\\n        const int half = s.size()/2;\\n        long long cost = 0;\\n\\n        for(size_t i = 1; i <= half; ++i)\\n            if(s[i] != s[i - 1])\\n                cost += i;\\n\\n        for(size_t i = s.size() - 2; i >= half; --i)\\n            if(s[i] != s[i + 1])\\n                cost += s.size() - 1 - i;\\n\\n        return cost;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581301,
                "title": "python-simple-solution-with-video-explanation",
                "content": "# Video Explanation\\nWatch my full video explanation [here](https://www.youtube.com/watch?v=nnRiTbiCi8A):\\n\\nhttps://www.youtube.com/watch?v=nnRiTbiCi8A\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        n = len(s)\\n\\n        for i in range(1, n):\\n            if s[i] != s[i - 1]:\\n                cost += min(i, n - i)\\n\\n        return cost\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        cost = 0\\n        n = len(s)\\n\\n        for i in range(1, n):\\n            if s[i] != s[i - 1]:\\n                cost += min(i, n - i)\\n\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580192,
                "title": "python-3-one-line-one-pass",
                "content": "# Intuition\\nIf any adjascent pairs don\\'t equal, you need to flip one without the other.\\n\\nFor each pair, you either have to do operation 1 or operation 2. Do the one that\\'s cheaper.\\n\\n# Approach\\nYou can either do it in two half-passes, or you can do it in one full pass and apply a minimum. I chose the latter approach because it\\'s easier to write in one line.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, one pass\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n  def minimumCost(self, s: str) -> int:\\n    return sum(min(i+1, len(s)-i-1) for i,(a,b) in enumerate(pairwise(s)) if a != b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def minimumCost(self, s: str) -> int:\\n    return sum(min(i+1, len(s)-i-1) for i,(a,b) in enumerate(pairwise(s)) if a != b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579259,
                "title": "shorter-recursive-resolusion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nShorter recursive resolusion\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing fliping target instead to fliping substring\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        int i = (n & 1) ? n / 2 : n / 2 - 1;\\n        long long min0, min1;\\n        min0 = calc(s, i-1, \\'0\\', -1)+calc(s, i, \\'0\\', 1);\\n        min1 = calc(s, i-1, \\'1\\', -1)+calc(s, i, \\'1\\', 1);\\n        return min(min0, min1);\\n    }\\n    \\n    long long calc(string &s, int i, char t, int dir) {\\n        int n = s.size();\\n        for(; i>=0 && i<n && s[i]==t; i+=dir);\\n        if(i<0 || i>=n) return 0;\\n        long long cost = (dir > 0)? n-i: i+1;\\n        cost += (t==\\'0\\')? calc(s, i+dir, \\'1\\', dir): calc(s, i+dir, \\'0\\', dir);\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        int i = (n & 1) ? n / 2 : n / 2 - 1;\\n        long long min0, min1;\\n        min0 = calc(s, i-1, \\'0\\', -1)+calc(s, i, \\'0\\', 1);\\n        min1 = calc(s, i-1, \\'1\\', -1)+calc(s, i, \\'1\\', 1);\\n        return min(min0, min1);\\n    }\\n    \\n    long long calc(string &s, int i, char t, int dir) {\\n        int n = s.size();\\n        for(; i>=0 && i<n && s[i]==t; i+=dir);\\n        if(i<0 || i>=n) return 0;\\n        long long cost = (dir > 0)? n-i: i+1;\\n        cost += (t==\\'0\\')? calc(s, i+dir, \\'1\\', dir): calc(s, i+dir, \\'0\\', dir);\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579101,
                "title": "simple-o-n-time-and-o-n-space-dp-approach",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll minimumCost(string s) {\\n        ll n=s.length();\\n        if(n==1)\\n            return 0;\\n        if(n==2){\\n            if(s[0]!=s[1])\\n                return 1;\\n            return 0;\\n        }\\n        vector<vector<vector<ll>>> dp(2,vector<vector<ll>>(3,vector<ll>(n,-1)));\\n        if(s[0]==\\'0\\'){\\n            dp[0][0][0]=0;\\n            dp[0][1][0]=1;\\n        }else{\\n            dp[0][0][0]=1;\\n            dp[0][1][0]=0;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                dp[0][0][i]=dp[0][0][i-1];\\n                dp[0][1][i]=dp[0][0][i-1]+i+1;\\n            }else{\\n                dp[0][1][i]=dp[0][1][i-1];\\n                dp[0][0][i]=dp[0][1][i-1]+i+1;\\n            }\\n        }\\n        if(s[n-1]==\\'0\\'){\\n            dp[1][0][n-1]=0;\\n            dp[1][1][n-1]=1;\\n        }else{\\n            dp[1][0][n-1]=1;\\n            dp[1][1][n-1]=0;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                dp[1][0][i]=dp[1][0][i+1];\\n                dp[1][1][i]=dp[1][0][i+1]+n-i;\\n            }else{\\n                dp[1][1][i]=dp[1][1][i+1];\\n                dp[1][0][i]=dp[1][1][i+1]+n-i;\\n            }\\n        }\\n        ll ans=min(dp[0][0][0]+dp[1][0][1],dp[0][1][0]+dp[1][1][1]);\\n        for(int i=1;i<n-1;i++)\\n            ans=min({ans,dp[0][0][i]+dp[1][0][i+1],dp[0][1][i]+dp[1][1][i+1]});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll minimumCost(string s) {\\n        ll n=s.length();\\n        if(n==1)\\n            return 0;\\n        if(n==2){\\n            if(s[0]!=s[1])\\n                return 1;\\n            return 0;\\n        }\\n        vector<vector<vector<ll>>> dp(2,vector<vector<ll>>(3,vector<ll>(n,-1)));\\n        if(s[0]==\\'0\\'){\\n            dp[0][0][0]=0;\\n            dp[0][1][0]=1;\\n        }else{\\n            dp[0][0][0]=1;\\n            dp[0][1][0]=0;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                dp[0][0][i]=dp[0][0][i-1];\\n                dp[0][1][i]=dp[0][0][i-1]+i+1;\\n            }else{\\n                dp[0][1][i]=dp[0][1][i-1];\\n                dp[0][0][i]=dp[0][1][i-1]+i+1;\\n            }\\n        }\\n        if(s[n-1]==\\'0\\'){\\n            dp[1][0][n-1]=0;\\n            dp[1][1][n-1]=1;\\n        }else{\\n            dp[1][0][n-1]=1;\\n            dp[1][1][n-1]=0;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                dp[1][0][i]=dp[1][0][i+1];\\n                dp[1][1][i]=dp[1][0][i+1]+n-i;\\n            }else{\\n                dp[1][1][i]=dp[1][1][i+1];\\n                dp[1][0][i]=dp[1][1][i+1]+n-i;\\n            }\\n        }\\n        ll ans=min(dp[0][0][0]+dp[1][0][1],dp[0][1][0]+dp[1][1][1]);\\n        for(int i=1;i<n-1;i++)\\n            ans=min({ans,dp[0][0][i]+dp[1][0][i+1],dp[0][1][i]+dp[1][1][i+1]});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578846,
                "title": "code-explanation-analysis-perfect-guide-for-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to minimize the cost so invert which half is small.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstart from 1st index in the string, is not equal to i-1 then check which half is small.\\n\\nif left half is small just add the cost to res \\n\\nelse right half is small we invert values in right and add cost to res\\n\\nNote:- loop is move in right side so, we need to maintain the invert string so, if flip is true it flip the i and i-1 values so we make sure we pick correct value in the string.\\n\\nDont need to over complete the fliping process we have only 2 values either 1 or 0 so dont think run extra loop and place the invert values in string then proceed further (it cause TLE as well this is brute force approach)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n\\n        boolean flip = false;\\n        long res = 0l, n = s.length();\\n        for(int i = 1; i<n; i++){\\n            char left = s.charAt(i-1);\\n            char curr = s.charAt(i);\\n            if(flip){\\n                if(left == \\'0\\') left = \\'1\\';\\n                else left = \\'0\\';\\n\\n                if(curr == \\'0\\') curr = \\'1\\';\\n                else curr = \\'0\\';\\n            }\\n\\n            if(left != curr)\\n            if(i <= n-i){\\n                res += i;\\n\\n            }\\n            else{\\n                res += (n-i);\\n                flip = !flip;\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n\\n        boolean flip = false;\\n        long res = 0l, n = s.length();\\n        for(int i = 1; i<n; i++){\\n            char left = s.charAt(i-1);\\n            char curr = s.charAt(i);\\n            if(flip){\\n                if(left == \\'0\\') left = \\'1\\';\\n                else left = \\'0\\';\\n\\n                if(curr == \\'0\\') curr = \\'1\\';\\n                else curr = \\'0\\';\\n            }\\n\\n            if(left != curr)\\n            if(i <= n-i){\\n                res += i;\\n\\n            }\\n            else{\\n                res += (n-i);\\n                flip = !flip;\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577401,
                "title": "two-approaches-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /*\\n    Observations:\\n    1. A nice property is, two strings of the same pattern need\\n       same cost to become equal, regardless of the real value.\\n       \"10\"\\n       \"01\" cost = 1\\n\\n       \"011\"\\n       \"100\" cost = 1\\n\\n       \"1001\"\\n       \"0110\" cost = 4\\n\\n       \"101010\"\\n       \"010101\" cost = 9\\n    2. It means if we flip s[0...i-1], the cost to make the flipped\\n       string become equal again is unchanged.\\n            \"00101\"\\n       cost  0025\\n\\n       i = 3, s[2] != s[3] so flip s[0...i-1] -> cost += 3\\n              now \"110\" also takes 2 cost to become \"000\"\\n\\n       So dp[i] = d[i - 1] + (s[i - 1] != s[i] ? i : 0)\\n    3. Another traversal from the back with same idea.\\n       candi = dp[i] + right\\n       ans = min(ans, candi)\\n\\n       O(n) space and time\\n    */\\n    long long minCost2(string s) {\\n        int n = s.size();\\n        // cost to make s[0...i] equal\\n        vector<long long> left(n);\\n        left[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            left[i] = left[i - 1] + (s[i] == s[i - 1] ? 0 : i);\\n        }\\n\\n        long long ans = left[n - 1], right = 0;\\n        for (int i = n - 2; i >= 0; i--) {\\n            right += s[i] == s[i + 1] ? 0 : n - 1 - i;\\n            ans = min(ans, left[i] + right);\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    long long minimumCost(string s) {\\n        return minCost2(s);\\n\\n        int n = s.size();\\n        vector<long long> remain1(n), flip1(n);\\n        int prev = -1;\\n        for (int i = 0; i < n; i++) {\\n            if ((i + 1 < n && s[i] != s[i + 1])) {\\n                remain1[i] = prev == -1 ? 0 : flip1[prev];\\n                flip1[i] = (prev == -1 ? 0 : flip1[prev]) + (i + 1);\\n                prev = i;\\n            }\\n        }\\n        \\n        if (prev == -1) {\\n            return 0;\\n        }\\n        \\n        vector<long long> remain2(n), flip2(n);\\n        prev = -1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if ((i - 1 >= 0 && s[i - 1] != s[i])) {\\n                remain2[i] = prev == -1 ? 0 : flip2[prev];\\n                flip2[i] = (prev == -1 ? 0 : flip2[prev]) + (n - i);\\n                prev = i;\\n            }\\n        }\\n        \\n        long long ans = 1LL * n * (n + 1) / 2;\\n        for (int i = 0; i < n; i++) {\\n            if (i + 1 < n && s[i] != s[i + 1]) {\\n                long long a = remain1[i] + flip2[i + 1];\\n                long long b = flip1[i] + remain2[i + 1];\\n                // std::cout << i << \" \" << a << \" \" << b << std::endl;\\n                ans = min(ans, min(a, b));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    Observations:\\n    1. A nice property is, two strings of the same pattern need\\n       same cost to become equal, regardless of the real value.\\n       \"10\"\\n       \"01\" cost = 1\\n\\n       \"011\"\\n       \"100\" cost = 1\\n\\n       \"1001\"\\n       \"0110\" cost = 4\\n\\n       \"101010\"\\n       \"010101\" cost = 9\\n    2. It means if we flip s[0...i-1], the cost to make the flipped\\n       string become equal again is unchanged.\\n            \"00101\"\\n       cost  0025\\n\\n       i = 3, s[2] != s[3] so flip s[0...i-1] -> cost += 3\\n              now \"110\" also takes 2 cost to become \"000\"\\n\\n       So dp[i] = d[i - 1] + (s[i - 1] != s[i] ? i : 0)\\n    3. Another traversal from the back with same idea.\\n       candi = dp[i] + right\\n       ans = min(ans, candi)\\n\\n       O(n) space and time\\n    */\\n    long long minCost2(string s) {\\n        int n = s.size();\\n        // cost to make s[0...i] equal\\n        vector<long long> left(n);\\n        left[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            left[i] = left[i - 1] + (s[i] == s[i - 1] ? 0 : i);\\n        }\\n\\n        long long ans = left[n - 1], right = 0;\\n        for (int i = n - 2; i >= 0; i--) {\\n            right += s[i] == s[i + 1] ? 0 : n - 1 - i;\\n            ans = min(ans, left[i] + right);\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    long long minimumCost(string s) {\\n        return minCost2(s);\\n\\n        int n = s.size();\\n        vector<long long> remain1(n), flip1(n);\\n        int prev = -1;\\n        for (int i = 0; i < n; i++) {\\n            if ((i + 1 < n && s[i] != s[i + 1])) {\\n                remain1[i] = prev == -1 ? 0 : flip1[prev];\\n                flip1[i] = (prev == -1 ? 0 : flip1[prev]) + (i + 1);\\n                prev = i;\\n            }\\n        }\\n        \\n        if (prev == -1) {\\n            return 0;\\n        }\\n        \\n        vector<long long> remain2(n), flip2(n);\\n        prev = -1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if ((i - 1 >= 0 && s[i - 1] != s[i])) {\\n                remain2[i] = prev == -1 ? 0 : flip2[prev];\\n                flip2[i] = (prev == -1 ? 0 : flip2[prev]) + (n - i);\\n                prev = i;\\n            }\\n        }\\n        \\n        long long ans = 1LL * n * (n + 1) / 2;\\n        for (int i = 0; i < n; i++) {\\n            if (i + 1 < n && s[i] != s[i + 1]) {\\n                long long a = remain1[i] + flip2[i + 1];\\n                long long b = flip1[i] + remain2[i + 1];\\n                // std::cout << i << \" \" << a << \" \" << b << std::endl;\\n                ans = min(ans, min(a, b));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3577167,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun minimumCost(s: String): Long {\\n        val n = s.length\\n        val h = n / 2\\n        val ca = s.toCharArray()\\n        var result = Long.MAX_VALUE\\n\\n        // to 1\\'s\\n        var m = 0L\\n        var inverse = false\\n        for (i in h downTo 0) {\\n            if (inverse) {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = false\\n                    m += i + 1\\n                }\\n            } else {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = true\\n                    m += i + 1\\n                }\\n            }\\n        }\\n\\n        inverse = false\\n        for (i in h + 1 until n) {\\n            if (inverse) {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = false\\n                    m += n - i\\n                }\\n            } else {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = true\\n                    m += n - i\\n                }\\n            }\\n        }\\n\\n        result = m\\n\\n        // to 0\\'s\\n        m = 0L\\n        inverse = false\\n\\n        for (i in h downTo 0) {\\n            if (inverse) {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = false\\n                    m += i + 1\\n                }\\n            } else {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = true\\n                    m += i + 1\\n                }\\n            }\\n        }\\n\\n        inverse = false\\n        for (i in h + 1 until n) {\\n            if (inverse) {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = false\\n                    m += n - i\\n                }\\n            } else {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = true\\n                    m += n - i\\n                }\\n            }\\n        }\\n\\n        result = Math.min(result, m)\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minimumCost(s: String): Long {\\n        val n = s.length\\n        val h = n / 2\\n        val ca = s.toCharArray()\\n        var result = Long.MAX_VALUE\\n\\n        // to 1\\'s\\n        var m = 0L\\n        var inverse = false\\n        for (i in h downTo 0) {\\n            if (inverse) {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = false\\n                    m += i + 1\\n                }\\n            } else {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = true\\n                    m += i + 1\\n                }\\n            }\\n        }\\n\\n        inverse = false\\n        for (i in h + 1 until n) {\\n            if (inverse) {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = false\\n                    m += n - i\\n                }\\n            } else {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = true\\n                    m += n - i\\n                }\\n            }\\n        }\\n\\n        result = m\\n\\n        // to 0\\'s\\n        m = 0L\\n        inverse = false\\n\\n        for (i in h downTo 0) {\\n            if (inverse) {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = false\\n                    m += i + 1\\n                }\\n            } else {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = true\\n                    m += i + 1\\n                }\\n            }\\n        }\\n\\n        inverse = false\\n        for (i in h + 1 until n) {\\n            if (inverse) {\\n                if (ca[i] == \\'0\\') {\\n                    inverse = false\\n                    m += n - i\\n                }\\n            } else {\\n                if (ca[i] == \\'1\\') {\\n                    inverse = true\\n                    m += n - i\\n                }\\n            }\\n        }\\n\\n        result = Math.min(result, m)\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577139,
                "title": "c-check-next",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=size(s);\\n        for(int i=0;i<n-1;++i)\\n            if(s[i]!=s[i+1])ans+=min(i+1,n-i-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=size(s);\\n        for(int i=0;i<n-1;++i)\\n            if(s[i]!=s[i+1])ans+=min(i+1,n-i-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576770,
                "title": "python-left-to-right-counts-and-right-to-left-counts",
                "content": "**Idea:**\\n - Create two arrays `Z = [0]` and `O = [0]`. \\n - For each charater in string if it\\'s the same as before for example it\\'s 0 then just copy to Z its previous element, if it\\'s different 1 then in Z goes O[-1] + i - 1.\\n - Do the same for reversed string\\n - minimize LeftZeros[i] + RightZeros[i] and  LeftOnes[i] + RightOnes[i]\\n\\n```python\\nclass Solution:\\n    def minimumCost(self, S: str) -> int:\\n        def count(s):\\n            Z = [0]\\n            O = [0]\\n            for i,l in enumerate(s):\\n                if l == \\'1\\':\\n                    O.append(O[-1])\\n                    Z.append(O[-1] + i + 1)\\n                else:\\n                    Z.append(Z[-1])\\n                    O.append(Z[-1] + i + 1)\\n                    \\n            return Z[1:],O[1:]\\n        \\n        LZ, LO = count(S)\\n        RZ, RO = count(S[::-1])\\n        ans = inf\\n        for x,y in zip(LZ,RZ[::-1]):\\n            ans = min(ans, x + y)\\n    \\n        for x,y in zip(LO,RO[::-1]):\\n            ans = min(ans, x + y)\\n            \\n        return ans\\n\\n```\\n\\nTime: `O(N)`\\nSpace: `O(N)`\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumCost(self, S: str) -> int:\\n        def count(s):\\n            Z = [0]\\n            O = [0]\\n            for i,l in enumerate(s):\\n                if l == \\'1\\':\\n                    O.append(O[-1])\\n                    Z.append(O[-1] + i + 1)\\n                else:\\n                    Z.append(Z[-1])\\n                    O.append(Z[-1] + i + 1)\\n                    \\n            return Z[1:],O[1:]\\n        \\n        LZ, LO = count(S)\\n        RZ, RO = count(S[::-1])\\n        ans = inf\\n        for x,y in zip(LZ,RZ[::-1]):\\n            ans = min(ans, x + y)\\n    \\n        for x,y in zip(LO,RO[::-1]):\\n            ans = min(ans, x + y)\\n            \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576667,
                "title": "c-greedy-solution-observe-the-change-in-bits",
                "content": "# Intuition\\nSum up the min cost for every change in bit.\\n\\n# Approach\\nFor the first half of the string, for every change in bit, we do first operation\\nFor the other half of the string, for every change in bit, we do second operation\\nAnd magic, the answer is found!!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=0;i<n/2;i++) {\\n            if(s[i]!=s[i+1]) {\\n                ans+=i+1;\\n            }\\n        }\\n        for(int i=n/2;i<n-1;i++) {\\n            if(s[i]!=s[i+1]) {\\n                ans+=n-i-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=0;i<n/2;i++) {\\n            if(s[i]!=s[i+1]) {\\n                ans+=i+1;\\n            }\\n        }\\n        for(int i=n/2;i<n-1;i++) {\\n            if(s[i]!=s[i+1]) {\\n                ans+=n-i-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576191,
                "title": "easy-begineer-friendly-java-code-o-n",
                "content": "# Intuition\\n  After standing on characters from index : 1 to n-1. Check the number of characters that are required to flip in the left portion and right portion. The portion in which less flips are required will be added to the ans.\\n\\n\\n# Complexity\\n  $$O(n)$$ \\n\\n# Space complexity:\\n  $$O(1)$$\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n\\n    public long minimumCost(String s) {\\n        \\n        long ans = 0;\\n        \\n        for (int i = 1 ; i < s.length () ; i++) {\\n            \\n            // Left main kitne flip karne hain aur right main kitne flip karne hain.\\n            // Inme se jo minimum flip lagengye unhe ans main add kardo.        \\n            if (s.charAt(i) != s.charAt(i-1)) {\\n                \\n                ans += Math.min (i , s.length() - i);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n\\n    public long minimumCost(String s) {\\n        \\n        long ans = 0;\\n        \\n        for (int i = 1 ; i < s.length () ; i++) {\\n            \\n            // Left main kitne flip karne hain aur right main kitne flip karne hain.\\n            // Inme se jo minimum flip lagengye unhe ans main add kardo.        \\n            if (s.charAt(i) != s.charAt(i-1)) {\\n                \\n                ans += Math.min (i , s.length() - i);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575822,
                "title": "only-5-lines-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans=0;\\n        int n=s.length();\\n        for(int i=0;i<n-1;i++)\\n            if(s.charAt(i)!=s.charAt(i+1))ans+=Math.min(i+1,n-i-1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans=0;\\n        int n=s.length();\\n        for(int i=0;i<n-1;i++)\\n            if(s.charAt(i)!=s.charAt(i+1))ans+=Math.min(i+1,n-i-1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575400,
                "title": "c-o-n-and-o-1-100-faster-at-time-of-my-submission-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        char tar=s[n/2];\\n        for(int i=n/2;i<n;)\\n        {\\n            while(i<n&&s[i]==tar) i++;\\n            ans+=(long long)(n-i);\\n            if(tar==\\'1\\') tar=\\'0\\';\\n            else tar=\\'1\\';\\n            while(i<n&&s[i]!=tar) i++;\\n        }\\n        tar=s[n/2];\\n        for(int i=n/2;i>=0;)\\n        {\\n            while(i>=0&&s[i]==tar) i--;\\n            ans+=(long long)(i+1);\\n            if(tar==\\'1\\') tar=\\'0\\';\\n            else tar=\\'1\\';\\n            while(i>=0&&s[i]!=tar) i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        int n=s.size();\\n        char tar=s[n/2];\\n        for(int i=n/2;i<n;)\\n        {\\n            while(i<n&&s[i]==tar) i++;\\n            ans+=(long long)(n-i);\\n            if(tar==\\'1\\') tar=\\'0\\';\\n            else tar=\\'1\\';\\n            while(i<n&&s[i]!=tar) i++;\\n        }\\n        tar=s[n/2];\\n        for(int i=n/2;i>=0;)\\n        {\\n            while(i>=0&&s[i]==tar) i--;\\n            ans+=(long long)(i+1);\\n            if(tar==\\'1\\') tar=\\'0\\';\\n            else tar=\\'1\\';\\n            while(i>=0&&s[i]!=tar) i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575142,
                "title": "always-try-mid",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll solve(string s,int st,int end,int type,char val){\\n        ll ans = 0 ; \\n        if(type == 0){\\n            int x = 0 ; \\n            for(int i = end;i>=st;i--){\\n                if(x%2 != 0){\\n                    if(s[i]==\\'1\\')s[i]=\\'0\\';\\n                    else s[i]=\\'1\\';\\n                }\\n                if(s[i]!= val){\\n                    x++;\\n                    ans = ans + i+1;\\n                }\\n            }\\n        }\\n        if(type == 1){\\n            int x = 0 ; \\n            for(int i = st;i<=end ; i++){\\n                if(x%2 != 0){\\n                    if(s[i]==\\'1\\')s[i]=\\'0\\';\\n                    else s[i]=\\'1\\';\\n                }\\n                if(s[i]!= val){\\n                    x++;\\n                    ans = ans + s.size()-i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        int mid = n/2;\\n        ll zf = solve(s,0,mid,0,\\'0\\');\\n        ll zs = solve(s,mid+1,n-1,1,\\'0\\');\\n        ll of = solve(s,0,mid,0,\\'1\\');\\n        ll os =  solve(s,mid+1,n-1,1,\\'1\\');\\n        return min(zs+zf,os+of);\\n        \\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long \\n    ll solve(string s,int st,int end,int type,char val){\\n        ll ans = 0 ; \\n        if(type == 0){\\n            int x = 0 ; \\n            for(int i = end;i>=st;i--){\\n                if(x%2 != 0){\\n                    if(s[i]==\\'1\\')s[i]=\\'0\\';\\n                    else s[i]=\\'1\\';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3574534,
                "title": "c-easy-solution-t-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1> s[i] != s[i-1];\\n2>min(i, n-i), it will cheak the string from back and front both side\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        long long ans = 0;\\n        for(int i=1; i<n ; i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans+=min(i, n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.size();\\n        long long ans = 0;\\n        for(int i=1; i<n ; i++)\\n        {\\n            if(s[i] != s[i-1])\\n            {\\n                ans+=min(i, n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574490,
                "title": "greedy-algo-dry-run-and-clean-code",
                "content": "# Idea\\n- We can see with example\\n- 0 | 1 0 1 0 1 => 0\\n- 1 | 1 0 1 0 1 => 1\\n- 1 1 | 0 1 0 1 => 2\\n- 0 0 0 | 1 0 1 => 3\\n- 1 1 1 1 | 0 1 => 2\\n- 1 1 1 1 1 | 0 => 1\\n- 1 1 1 1 1 1\\n- 1 + 2 + 3 + 2 + 1 = 9\\n- We pick min no of invertions possible at each time\\n- 0 to i-1 => cost i\\n- i to N-1 => cost N-i\\n- We pick the point of differ and try to either change 0 or 1 to the other one.\\n- GREEDY BEST WAY\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int N = s.length();\\n        ll ans = 0;\\n\\n        for(int i=1; i<N; i++){\\n            if(s[i] != s[i-1]){\\n                //0 to i-1 invert or i to N-1 invert\\n                ans += min(i, N-i);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int N = s.length();\\n        ll ans = 0;\\n\\n        for(int i=1; i<N; i++){\\n            if(s[i] != s[i-1]){\\n                //0 to i-1 invert or i to N-1 invert\\n                ans += min(i, N-i);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574128,
                "title": "java-linear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long minimumCost(String s) {\\n    long fl0 = to_left(s,0);\\n    long fl1 = to_left(s,1);\\n    long fr0 = to_right(s, 0);\\n    long fr1 = to_right(s, 1);\\n\\n    long mini0 = fl0 + fr0, mini1 = fl1 + fr1;  \\n    if( (s.length() & 1) == 0) return Math.min(mini0, mini1);\\n    \\n    int k = s.length()>>1, k0, k1;\\n    if(s.charAt(k) == \\'0\\') mini1 = Math.min(k + fl1 + fr0, k + fl0 + fr1);\\n    else                   mini0 = Math.min(k + fl1 + fr0, k + fl0 + fr1);\\n    \\n    return Math.min(mini0, mini1);\\n  }\\n  \\n  private long to_left(String s, int mark){\\n    long flip = 0;\\n    for(int i = (s.length()>>1) - 1; i >= 0; --i)\\n      if(s.charAt(i) - \\'0\\' != mark){\\n        flip += i+1;\\n        mark ^= 1;\\n      }\\n    \\n    return flip;\\n  }\\n  private long to_right(String s, int mark){\\n    long flip = 0;\\n    for(int i = (s.length()+1)>>1; i != s.length(); ++i)\\n      if(s.charAt(i) - \\'0\\' != mark){\\n        flip += s.length() - i;\\n        mark ^= 1;\\n      }\\n    \\n    return flip;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long minimumCost(String s) {\\n    long fl0 = to_left(s,0);\\n    long fl1 = to_left(s,1);\\n    long fr0 = to_right(s, 0);\\n    long fr1 = to_right(s, 1);\\n\\n    long mini0 = fl0 + fr0, mini1 = fl1 + fr1;  \\n    if( (s.length() & 1) == 0) return Math.min(mini0, mini1);\\n    \\n    int k = s.length()>>1, k0, k1;\\n    if(s.charAt(k) == \\'0\\') mini1 = Math.min(k + fl1 + fr0, k + fl0 + fr1);\\n    else                   mini0 = Math.min(k + fl1 + fr0, k + fl0 + fr1);\\n    \\n    return Math.min(mini0, mini1);\\n  }\\n  \\n  private long to_left(String s, int mark){\\n    long flip = 0;\\n    for(int i = (s.length()>>1) - 1; i >= 0; --i)\\n      if(s.charAt(i) - \\'0\\' != mark){\\n        flip += i+1;\\n        mark ^= 1;\\n      }\\n    \\n    return flip;\\n  }\\n  private long to_right(String s, int mark){\\n    long flip = 0;\\n    for(int i = (s.length()+1)>>1; i != s.length(); ++i)\\n      if(s.charAt(i) - \\'0\\' != mark){\\n        flip += s.length() - i;\\n        mark ^= 1;\\n      }\\n    \\n    return flip;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574023,
                "title": "optimal-solution-c-best-solution-guarenteed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n see , we traverse from either 0 to n-1  / n-1 to 0  \\n    // we have to check for (i , i+1)  , if they are different  \\n    // either we can change ith part with cost (n-i)  or we can change (i+1)th part with cost   n-i-1  , take which is minimum\\n    int n=s.length();\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIN THIS LOGIC  : we have say that if we calculate the cost of any item , other items apart from i and i+1 , if they and there neibhours are equal then after inversion they remains equal \\n\\n and if they are different they remains different even after inversion so traverse from one direction and equaling all previous //elements so that they neither change nor effect in our solution  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n long long minimumCost(string s) {       \\n    \\n    //********************optimal Approach**************************\\n\\n    // LOGIC :  see , we traverse from either 0 to n-1  / n-1 to 0  \\n    // we have to check for (i , i+1)  , if they are different  \\n    // either we can change ith part with cost (n-i)  or we can change (i+1)th part with cost   n-i-1  , take which is minimum\\n    int n=s.length();\\n\\n\\n// \\n     long long cost =0;\\n     \\n    for(int i=0 ;i<n-1;i++)\\n    {\\n        if(s[i] != s[i+1])\\n        {\\n            cost += min(i+1 , n-i-1);\\n        }\\n    }\\n     return cost;\\n     \\n }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n long long minimumCost(string s) {       \\n    \\n    //********************optimal Approach**************************\\n\\n    // LOGIC :  see , we traverse from either 0 to n-1  / n-1 to 0  \\n    // we have to check for (i , i+1)  , if they are different  \\n    // either we can change ith part with cost (n-i)  or we can change (i+1)th part with cost   n-i-1  , take which is minimum\\n    int n=s.length();\\n\\n\\n// \\n     long long cost =0;\\n     \\n    for(int i=0 ;i<n-1;i++)\\n    {\\n        if(s[i] != s[i+1])\\n        {\\n            cost += min(i+1 , n-i-1);\\n        }\\n    }\\n     return cost;\\n     \\n }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573761,
                "title": "python-two-pointers-solution-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor any invert operation, say at index i, we either invert all 0~ith numbers or i~nth numbers. That means numbers on both sides of the string will get inverted more frequently and cannot fix those numbers. Therefore, why not make invert operations to make numbers in the center same first, then work it toward both sides of the string?\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first find the mid index of the string.\\n\\nIf the string is of odd length, we assign l and r pointer to be one index left and right of mid index. If it is of even length, we first check if s[mid] != s[mid+1] to make the first invert operation (to make these two numbers the same)\\n\\nThen, we shift l towards left and r towards right, each iteration by 1. If s[l] != s[l+1] or s[r] != s[r-1], that indicates invert operation is needed to make s[l] == s[l+1] or s[r] == s[r+1], we increase the cost by l+1 or by n-r.\\n# Complexity\\n- Time complexity: $$O(n)$$\\nWe iterate each position only once\\n\\n- Space complexity: $$O(1)$$\\nWe didn\\'t use any extra memory\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        if len(s) == 1:\\n            return 0\\n\\n        n = len(s)\\n        cost = 0\\n\\n        l, r = 0, n-1\\n        mid = int((l+r)/2)\\n        if n % 2:\\n            l, r = mid-1, mid+1\\n        else:\\n            l, r = mid, mid+1\\n            if s[l] != s[r]: cost += l+1\\n            l -= 1\\n            r += 1\\n        \\n        while l >= 0 and r < n:\\n            if s[l] != s[l+1]:\\n                cost += l+1\\n            if s[r] != s[r-1]:\\n                cost += n-r\\n            l -= 1\\n            r += 1\\n        return cost \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        if len(s) == 1:\\n            return 0\\n\\n        n = len(s)\\n        cost = 0\\n\\n        l, r = 0, n-1\\n        mid = int((l+r)/2)\\n        if n % 2:\\n            l, r = mid-1, mid+1\\n        else:\\n            l, r = mid, mid+1\\n            if s[l] != s[r]: cost += l+1\\n            l -= 1\\n            r += 1\\n        \\n        while l >= 0 and r < n:\\n            if s[l] != s[l+1]:\\n                cost += l+1\\n            if s[r] != s[r-1]:\\n                cost += n-r\\n            l -= 1\\n            r += 1\\n        return cost \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573735,
                "title": "prefix-suffix-dp-solution-c-best-solution-for-this-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    using ll = long long;\\npublic:\\n    long long minimumCost(string s) {\\n        int n = size(s);\\n        vector<ll> prefix(n);\\n        vector<ll> suffix(n);\\n        //prefix[i] represent the cost required to make all the charecters from 0th to (i-1)th index equal to the charecter at ith charecter \\n        for(int i=0;i<n;i++){\\n            if(i == 0){\\n                prefix[i] = 0;\\n            }\\n            else{\\n                if(s[i] == s[i-1]){\\n                    prefix[i] = prefix[i-1];\\n                }\\n                else if(s[i]!=s[i-1]){\\n                    prefix[i] = i + prefix[i-1];\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(i == n-1){\\n                suffix[i] = 0;\\n            }\\n            else{\\n                if(s[i] == s[i+1]){\\n                    suffix[i] = suffix[i+1];\\n                }\\n                else{\\n                    suffix[i] = (n-i-1) + suffix[i+1];\\n                }\\n            }\\n        }\\n        ll ans = LONG_LONG_MAX;\\n        for(int i=0;i<n;i++){\\n            ans = min(ans,prefix[i] + suffix[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    using ll = long long;\\npublic:\\n    long long minimumCost(string s) {\\n        int n = size(s);\\n        vector<ll> prefix(n);\\n        vector<ll> suffix(n);\\n        //prefix[i] represent the cost required to make all the charecters from 0th to (i-1)th index equal to the charecter at ith charecter \\n        for(int i=0;i<n;i++){\\n            if(i == 0){\\n                prefix[i] = 0;\\n            }\\n            else{\\n                if(s[i] == s[i-1]){\\n                    prefix[i] = prefix[i-1];\\n                }\\n                else if(s[i]!=s[i-1]){\\n                    prefix[i] = i + prefix[i-1];\\n                }\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(i == n-1){\\n                suffix[i] = 0;\\n            }\\n            else{\\n                if(s[i] == s[i+1]){\\n                    suffix[i] = suffix[i+1];\\n                }\\n                else{\\n                    suffix[i] = (n-i-1) + suffix[i+1];\\n                }\\n            }\\n        }\\n        ll ans = LONG_LONG_MAX;\\n        for(int i=0;i<n;i++){\\n            ans = min(ans,prefix[i] + suffix[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573680,
                "title": "easy-and-small-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n\\n        long long ans = 0;\\n        \\n        for (int i = 0; i < s.size()-1; i++) {\\n            if(s[i]!=s[i+1])\\n            {\\n                ans += min(i + 1, static_cast<int>(s.size()) - i -1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n\\n        long long ans = 0;\\n        \\n        for (int i = 0; i < s.size()-1; i++) {\\n            if(s[i]!=s[i+1])\\n            {\\n                ans += min(i + 1, static_cast<int>(s.size()) - i -1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573381,
                "title": "python-dp-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        right = [[0]*2 for _ in range(n+1)]\\n        for i in range(n-1,-1,-1):\\n            right[i][0] = right[i+1][1] + (n-i) if s[i] == \\'1\\' else right[i+1][0]\\n            right[i][1] = right[i+1][0] + (n-i) if s[i] == \\'0\\' else right[i+1][1]\\n        left = [0]*2\\n        res = [[0]*2 for _ in range(n)]\\n        for i in range(n):\\n            res[i][0] = left[0]+right[i+1][0] if s[i] == \\'0\\' else min(left[1]+right[i+1][0]+i+1, left[0]+right[i+1][1]+n-i)\\n            res[i][1] = left[1]+right[i+1][1] if s[i] == \\'1\\' else min(left[1]+right[i+1][0]+n-i, left[0]+right[i+1][1]+i+1)\\n            left[0], left[1] = left[0] if s[i] == \\'0\\' else left[1] + i + 1, left[1] if s[i] == \\'1\\' else left[0] + i + 1 \\n        return min(map(min, res))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        n = len(s)\\n        right = [[0]*2 for _ in range(n+1)]\\n        for i in range(n-1,-1,-1):\\n            right[i][0] = right[i+1][1] + (n-i) if s[i] == \\'1\\' else right[i+1][0]\\n            right[i][1] = right[i+1][0] + (n-i) if s[i] == \\'0\\' else right[i+1][1]\\n        left = [0]*2\\n        res = [[0]*2 for _ in range(n)]\\n        for i in range(n):\\n            res[i][0] = left[0]+right[i+1][0] if s[i] == \\'0\\' else min(left[1]+right[i+1][0]+i+1, left[0]+right[i+1][1]+n-i)\\n            res[i][1] = left[1]+right[i+1][1] if s[i] == \\'1\\' else min(left[1]+right[i+1][0]+n-i, left[0]+right[i+1][1]+i+1)\\n            left[0], left[1] = left[0] if s[i] == \\'0\\' else left[1] + i + 1, left[1] if s[i] == \\'1\\' else left[0] + i + 1 \\n        return min(map(min, res))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573331,
                "title": "not-greedy-easier-understanding",
                "content": "# Intuition\\n\\nThis code is not as elegant as the other one use Math.min(i, n-i), but it does explain things well.\\n\\nFirst finding, the cost is the number of characters get flipped, from left or right.\\nSecond oberservation, you will always choose rule 1 if index is less than mid point, choose rule 2 if index is greater than mid point.\\n\\nLast, Key point, when there\\'s a char different from the previous one. you have two choices\\nop1: invert all characters before i (not include i) or \\nop2: invert all chars from i (inclusive) to the end\\n\\n\\nHere Math.min just help to solve the obersavation 2 in an elagant way, it also helps once the cost rule get changed in case.\\n\\nBelow solution works as well.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long getCost(String s, int begin, int end, int direction) {\\n        int cost = 0;\\n        for (int i = begin; direction > 0 ? i <= end : i >= end ; i += direction) {\\n            if (s.charAt(i) != s.charAt(i + direction)) {\\n                cost += direction > 0 ? i - begin + 1 : begin - i + 1;\\n            }\\n        }\\n        return cost;\\n    }\\n\\n    public long minimumCost(String s) {\\n        return getCost(s, 0, s.length() / 2 - 1, 1)\\n            + getCost(s, s.length() - 1, s.length() / 2 + 1, -1);           \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long getCost(String s, int begin, int end, int direction) {\\n        int cost = 0;\\n        for (int i = begin; direction > 0 ? i <= end : i >= end ; i += direction) {\\n            if (s.charAt(i) != s.charAt(i + direction)) {\\n                cost += direction > 0 ? i - begin + 1 : begin - i + 1;\\n            }\\n        }\\n        return cost;\\n    }\\n\\n    public long minimumCost(String s) {\\n        return getCost(s, 0, s.length() / 2 - 1, 1)\\n            + getCost(s, s.length() - 1, s.length() / 2 + 1, -1);           \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573182,
                "title": "c-dp-solution",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        //l2r\\n        vector<vector<ll>> l2r(2,vector<ll>(n,0));\\n        l2r[0][0]=(s[0]==\\'0\\')?0:1;\\n        l2r[1][0]=(s[0]==\\'1\\')?0:1;\\n        for(int i=1; i<n; i++){\\n            l2r[0][i]=\\n                s[i]==\\'0\\'?\\n                    l2r[0][i-1]:\\n                    l2r[1][i-1] + i+1;\\n            l2r[1][i]=\\n                s[i]==\\'1\\'?\\n                    l2r[1][i-1]:\\n                    l2r[0][i-1] + i+1;\\n        }\\n        //r2l\\n        vector<vector<ll>> r2l(2,vector<ll>(n,0));\\n        r2l[0][n-1]=(s[n-1]==\\'0\\')?0:1;\\n        r2l[1][n-1]=(s[n-1]==\\'1\\')?0:1;\\n        for(int i=n-2; i>=0; i--){\\n            r2l[0][i]=\\n                s[i]==\\'0\\'?\\n                    r2l[0][i+1]:\\n                    r2l[1][i+1] + n-i;\\n            r2l[1][i]=\\n                s[i]==\\'1\\'?\\n                    r2l[1][i+1]:\\n                    r2l[0][i+1] + n-i;\\n        }\\n        //calcu res\\n        ll res=LLONG_MAX;\\n        for(int i=0; i<=n; i++){\\n           res=min({res,\\n                   (i-1>=0?l2r[0][i-1]:0) + (i<=n-1?r2l[0][i]:0),\\n                   (i-1>=0?l2r[1][i-1]:0) + (i<=n-1?r2l[1][i]:0)\\n                   });\\n        }\\n        return res;\\n    }\\n};\\n\\n/*\\ndp\\nl2r [0][0..i]: cost to convert s[0..i] to all 0s\\n    \\ni: 0...n-1\\nl2r [0][0..i] = \\n    if s[i]==0 dp[0][i-1]\\n    if s[i]==1 dp[1][i-1] + i+1\\n        \\nl2r [1][0..i] = \\n    if s[i]==1 dp[1][i-1]\\n    if s[i]==0 dp[0][i-1] + i+1\\n\\ni: n-1..0        \\nr2l [0][i..n-1] = \\n    if s[i]==0 dp[0][i+1]\\n    if s[i]==1 dp[1][i+1] + n-i\\n        \\nr2l [1][0..i] = \\n    if s[i]==1 dp[1][i+1]\\n    if s[i]==0 dp[0][i+1] + n-i\\n        \\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        //l2r\\n        vector<vector<ll>> l2r(2,vector<ll>(n,0));\\n        l2r[0][0]=(s[0]==\\'0\\')?0:1;\\n        l2r[1][0]=(s[0]==\\'1\\')?0:1;\\n        for(int i=1; i<n; i++){\\n            l2r[0][i]=\\n                s[i]==\\'0\\'?\\n                    l2r[0][i-1]:\\n                    l2r[1][i-1] + i+1;\\n            l2r[1][i]=\\n                s[i]==\\'1\\'?\\n                    l2r[1][i-1]:\\n                    l2r[0][i-1] + i+1;\\n        }\\n        //r2l\\n        vector<vector<ll>> r2l(2,vector<ll>(n,0));\\n        r2l[0][n-1]=(s[n-1]==\\'0\\')?0:1;\\n        r2l[1][n-1]=(s[n-1]==\\'1\\')?0:1;\\n        for(int i=n-2; i>=0; i--){\\n            r2l[0][i]=\\n                s[i]==\\'0\\'?\\n                    r2l[0][i+1]:\\n                    r2l[1][i+1] + n-i;\\n            r2l[1][i]=\\n                s[i]==\\'1\\'?\\n                    r2l[1][i+1]:\\n                    r2l[0][i+1] + n-i;\\n        }\\n        //calcu res\\n        ll res=LLONG_MAX;\\n        for(int i=0; i<=n; i++){\\n           res=min({res,\\n                   (i-1>=0?l2r[0][i-1]:0) + (i<=n-1?r2l[0][i]:0),\\n                   (i-1>=0?l2r[1][i-1]:0) + (i<=n-1?r2l[1][i]:0)\\n                   });\\n        }\\n        return res;\\n    }\\n};\\n\\n/*\\ndp\\nl2r [0][0..i]: cost to convert s[0..i] to all 0s\\n    \\ni: 0...n-1\\nl2r [0][0..i] = \\n    if s[i]==0 dp[0][i-1]\\n    if s[i]==1 dp[1][i-1] + i+1\\n        \\nl2r [1][0..i] = \\n    if s[i]==1 dp[1][i-1]\\n    if s[i]==0 dp[0][i-1] + i+1\\n\\ni: n-1..0        \\nr2l [0][i..n-1] = \\n    if s[i]==0 dp[0][i+1]\\n    if s[i]==1 dp[1][i+1] + n-i\\n        \\nr2l [1][0..i] = \\n    if s[i]==1 dp[1][i+1]\\n    if s[i]==0 dp[0][i+1] + n-i\\n        \\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573173,
                "title": "c-easy-understandable-solution-using-linear-traversal-t-c-o-n-s-c-o-1",
                "content": "# Approach\\nExplained in the code itself\\n\\n# Complexity\\n- Time complexity:\\nO[N]\\n\\n- Space complexity:\\nO[1]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long minimumCost(string s) \\n    {\\n        long long int i, j, len=s.length();\\n        i=(s.length()/2)-1;\\n        long long int chg=0, target, cost0=0, cost1=0;\\n        \\n        // [1] for converting all to 0------------------------------------------------------\\n        \\n        // 1,(a) For conversion of left half to 0 we use first method as it\\'s cheaper than second method\\n        target=0;\\n        while(i>=0)\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost0+=(i+1);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i--;\\n        }\\n        \\n        // 1,(b) For conversion of right half to 0 we use second method as it\\'s cheaper than first method\\n        i=(s.length()/2);\\n        chg=0;\\n        while(i<s.length())\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            \\n            if(val!=target)\\n            {\\n                cost0+=(len-i);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            \\n            i++;\\n        }\\n        \\n        // [2] for converting all to 1------------------------------------------------------\\n        \\n        // 2,(a) For conversion of left half to 1 we use first method as it\\'s cheaper than second method\\n        \\n        // for target= \\'1\\'\\n        i=(s.length()/2)-1;\\n        target=1;\\n        chg=0;\\n        while(i>=0)\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost1+=(i+1);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i--;\\n        }\\n        \\n        // 2,(b) For conversion of right half to 1 we use second method as it\\'s cheaper than first method\\n        \\n        i=(s.length()/2) ;\\n        chg=0;\\n        while(i<s.length())\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost1+=(len-i);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        \\n        return min(cost1, cost0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long minimumCost(string s) \\n    {\\n        long long int i, j, len=s.length();\\n        i=(s.length()/2)-1;\\n        long long int chg=0, target, cost0=0, cost1=0;\\n        \\n        // [1] for converting all to 0------------------------------------------------------\\n        \\n        // 1,(a) For conversion of left half to 0 we use first method as it\\'s cheaper than second method\\n        target=0;\\n        while(i>=0)\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost0+=(i+1);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i--;\\n        }\\n        \\n        // 1,(b) For conversion of right half to 0 we use second method as it\\'s cheaper than first method\\n        i=(s.length()/2);\\n        chg=0;\\n        while(i<s.length())\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            \\n            if(val!=target)\\n            {\\n                cost0+=(len-i);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            \\n            i++;\\n        }\\n        \\n        // [2] for converting all to 1------------------------------------------------------\\n        \\n        // 2,(a) For conversion of left half to 1 we use first method as it\\'s cheaper than second method\\n        \\n        // for target= \\'1\\'\\n        i=(s.length()/2)-1;\\n        target=1;\\n        chg=0;\\n        while(i>=0)\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost1+=(i+1);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i--;\\n        }\\n        \\n        // 2,(b) For conversion of right half to 1 we use second method as it\\'s cheaper than first method\\n        \\n        i=(s.length()/2) ;\\n        chg=0;\\n        while(i<s.length())\\n        {\\n            int val=s[i]-\\'0\\';\\n            if(chg == 1)\\n            {\\n                val=abs(val-1);\\n            }\\n            \\n            if(val!=target)\\n            {\\n                cost1+=(len-i);\\n                chg++;\\n                \\n                if(chg>1)\\n                {\\n                    chg=0;\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        \\n        return min(cost1, cost0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573077,
                "title": "c-prefix-sum",
                "content": "# Intuition\\nUse prefix sum.\\n\\n# Approach\\nCreate 2 arrays of type long of size `s.Length` - `left` and `right`. Then fill these arrays from start to finish and from finish to start accordingly:\\n```\\nfor (int i = 0; i < s.Length - 1; i++)\\n{\\n    if (s[i] != s[i + 1])\\n    {\\n        left[i] = i + 1;\\n    }\\n    if (0 < i) left[i] += left[i - 1];\\n}\\n...\\nfor (int i = s.Length - 1; i > 0; i--)\\n{\\n    if (s[i] != s[i - 1])\\n    {\\n        right[i] = s.Length - i;\\n    }\\n    if (i < s.Length - 1) right[i] += right[i + 1];\\n}\\n```\\nIn the final cycle find the minimum result:\\n```\\nfor (int i = 1; i < s.Length - 1; i++)\\n{\\n    var rs0 = left[i - 1] + right[i + 1];\\n    if (rs > rs0) rs = rs0;\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is s.Length.\\n\\n- Space complexity:\\n$$O(n)$$, where n is s.Length.\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinimumCost(string s) {\\n        if (s.Length == 1) return 0;\\n        var left = new long[s.Length];\\n        for (int i = 0; i < s.Length - 1; i++)\\n        {\\n            if (s[i] != s[i + 1])\\n            {\\n                left[i] = i + 1;\\n            }\\n            if (0 < i) left[i] += left[i - 1];\\n        }\\n        var right = new long[s.Length];\\n        for (int i = s.Length - 1; i > 0; i--)\\n        {\\n            if (s[i] != s[i - 1])\\n            {\\n                right[i] = s.Length - i;\\n            }\\n            if (i < s.Length - 1) right[i] += right[i + 1];\\n        }\\n        long rs = Math.Min(left[left.Length - 2], right[1]);\\n        for (int i = 1; i < s.Length - 1; i++)\\n        {\\n            var rs0 = left[i - 1] + right[i + 1];\\n            if (rs > rs0) rs = rs0;\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Prefix Sum"
                ],
                "code": "```\\nfor (int i = 0; i < s.Length - 1; i++)\\n{\\n    if (s[i] != s[i + 1])\\n    {\\n        left[i] = i + 1;\\n    }\\n    if (0 < i) left[i] += left[i - 1];\\n}\\n...\\nfor (int i = s.Length - 1; i > 0; i--)\\n{\\n    if (s[i] != s[i - 1])\\n    {\\n        right[i] = s.Length - i;\\n    }\\n    if (i < s.Length - 1) right[i] += right[i + 1];\\n}\\n```\n```\\nfor (int i = 1; i < s.Length - 1; i++)\\n{\\n    var rs0 = left[i - 1] + right[i + 1];\\n    if (rs > rs0) rs = rs0;\\n}\\n```\n```\\npublic class Solution {\\n    public long MinimumCost(string s) {\\n        if (s.Length == 1) return 0;\\n        var left = new long[s.Length];\\n        for (int i = 0; i < s.Length - 1; i++)\\n        {\\n            if (s[i] != s[i + 1])\\n            {\\n                left[i] = i + 1;\\n            }\\n            if (0 < i) left[i] += left[i - 1];\\n        }\\n        var right = new long[s.Length];\\n        for (int i = s.Length - 1; i > 0; i--)\\n        {\\n            if (s[i] != s[i - 1])\\n            {\\n                right[i] = s.Length - i;\\n            }\\n            if (i < s.Length - 1) right[i] += right[i + 1];\\n        }\\n        long rs = Math.Min(left[left.Length - 2], right[1]);\\n        for (int i = 1; i < s.Length - 1; i++)\\n        {\\n            var rs0 = left[i - 1] + right[i + 1];\\n            if (rs > rs0) rs = rs0;\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572977,
                "title": "c-easy-solution-simple-middle-technique-100-fast",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Start from middle technique for minimum cost\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int mid = s.length() / 2;\\n        for(int i = mid - 1 ; i >= 0 ; i--) {\\n            if(s[i] != s[i + 1]) {\\n                ans += i + 1;\\n            }\\n        }\\n        for(int i = mid + 1 ; i < s.length() ; i++) {\\n            if(s[i] != s[i - 1]) {\\n                ans += s.length() - i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans = 0;\\n        int mid = s.length() / 2;\\n        for(int i = mid - 1 ; i >= 0 ; i--) {\\n            if(s[i] != s[i + 1]) {\\n                ans += i + 1;\\n            }\\n        }\\n        for(int i = mid + 1 ; i < s.length() ; i++) {\\n            if(s[i] != s[i - 1]) {\\n                ans += s.length() - i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572903,
                "title": "java-o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDivide the array into two halves:\\n1. For the first half the cost will be minimum if we take the first operation since all our values lie before our midpoint or at it if we include the midpoint(I have included the midpoint in this approach)\\n2. For the second half all our observations are on the right hand side of the midpoint so the second operation is the choice of inverting the bits \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have two choices on our hands :\\n1. Make all the array elements equal to \\'1\\'\\n2. Make all the array elements equal to \\'0\\'\\nUse a function to solve for both scenarios and the result is taking the min cost of the two possibilities\\n\\n**The main function in question:**\\n\\nAssuming input string :\\'010101\\' and the scenario where we want to make all the characters equal to \\'0\\' aka all the bits are 0\\nstring:\\'0 1 0 1 0 1\\'\\n- Start at the midpoint (n-1)/2 aka index 2 in this case\\n- **Solving for the left half[0 1 0] with cost formula (i+1) for inverting indices (0,i):**\\n        **1)** Initialize  cost=0 \\n             **2)** Since we are solving to make all the bits to \\'0\\' traverse from the mid point 2 towards the left and check if the character is not equal to \\'0\\' aka find the nearest \\'1\\' when traversing from the midpoint towards the left.\\n             **3)** In this scenario the \\'1\\' is at index 1 we invert the characters from (0,1)[1 inclusive] which makes the result : **[1 0 0]** and the cost(for i=1)=**0+(1+1)=2**\\n             **4)** But here comes the catch since we are not modifying the string itself we can still perform the inversion by just inverting the condition we are searching on so instead of checking for \\'1\\' we search for \\'0\\' and our actual string is still:**[0 1 0]** we encounter the first \\'0\\' at index 0 and now the cost(for i=0)=**2+(0+1) =3**\\n             **5)** We have now reached the end of the left half\\n\\n We follow a similar approach for the right half traversing from the midpoint to the end and the cost formula is **(n-i)** with n being the size of the string\\n- **Solving for the right half[1 0 1] with cost formula (n-i) for inverting indices (i,n):**\\n           **1)**  Since we are solving to make all the bits to \\'0\\' traverse from the mid point 2 towards the right and check if the character is not equal to \\'0\\' aka find the first \\'1\\' when traversing from the midpoint towards the left.\\n             **2)** In this scenario the \\'1\\' is at index 3 we invert the characters from (3,5)[5 inclusive] which makes the result : **[0 1 1]** and the cost(for i=1)=**3+(6-3)=6**\\n             **3)** Inverting the condition we are searching on so instead of checking for  \\'1\\' we search for \\'0\\' and our actual string is still:**[1 0 1]** we encounter the  \\'0\\' at index 0 and now the cost(for i=0)=**6+(6-4) =8**\\n             **4)**  Inverting the condition we are searching on so instead of checking for  \\'0\\' we search for \\'1\\' and our actual string is still:**[1 0 1]** we encounter the  \\'1\\' at index 5 and now the cost(for i=0)=**8+(6-5) =9**\\n            **5)** We reach the end of the string \\n**Repeat the above steps with the choice of making all the bits to \\'1\\'**\\n**Take the minimum of the two costs as the final result**\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  \\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        return Math.min(this.solve(s,\\'1\\'),this.solve(s,\\'0\\'));\\n    }\\n    public long solve(String s ,char c){\\n        //left half from mid to index 0(start index)\\n        int mid=(s.length()-1)/2;\\n        int i=mid;\\n        char ch=c;\\n        long cost=0;\\n        while(i>=0){\\n            if(s.charAt(i)!=ch){\\n                cost+=(i+1);\\n                ch=ch==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            i--;\\n        }\\n        //Resetting the search to the original character\\n        ch=c;\\n        //right half from mid to index n-1(end index)\\n        i=mid+1;\\n\\n        while(i<s.length()){\\n            if(s.charAt(i)!=ch){\\n                cost+=(s.length()-i);\\n                ch=ch==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            i++;\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        return Math.min(this.solve(s,\\'1\\'),this.solve(s,\\'0\\'));\\n    }\\n    public long solve(String s ,char c){\\n        //left half from mid to index 0(start index)\\n        int mid=(s.length()-1)/2;\\n        int i=mid;\\n        char ch=c;\\n        long cost=0;\\n        while(i>=0){\\n            if(s.charAt(i)!=ch){\\n                cost+=(i+1);\\n                ch=ch==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            i--;\\n        }\\n        //Resetting the search to the original character\\n        ch=c;\\n        //right half from mid to index n-1(end index)\\n        i=mid+1;\\n\\n        while(i<s.length()){\\n            if(s.charAt(i)!=ch){\\n                cost+=(s.length()-i);\\n                ch=ch==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            i++;\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572872,
                "title": "beats-100-both-space-and-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do as we are being told.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nloop over the entire string\\nIf s[i] != s[i-1] we check which side we could get our answer, i.e. ans += min(i,n-i)\\n\\nwe then return this answer.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1]){\\n                ans+=min(i,n-i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        long long ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i] != s[i-1]){\\n                ans+=min(i,n-i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572765,
                "title": "100-beats-27-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long fun(string s,char ch)\\n  {\\n    long long t=-1,ans=0,n=s.size(),i=0;\\n\\n    while(i<n/2)\\n    {\\n       if(s[i]!=ch){\\n        while(i<n/2 and s[i]!=ch) i++;\\n        ans+=i+t+1;\\n        }\\n        else t=i,i++;\\n    }\\n    i=n-1,t=n;\\n    while(i>=n/2)\\n    {\\n      if(s[i]!=ch){\\n      while(i>=n/2 and s[i]!=ch) i--;\\n      ans+=n-i-1+n-t;\\n      }\\n      else  t=i,i--;\\n    }\\n    return ans;\\n  }\\n    long long minimumCost(string s) {\\n        // for(int i=0;i<s.size();i++) if(s[i]==\\'1\\') o++;else z++;\\n       return min(fun(s,\\'1\\'),fun(s,\\'0\\'));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long fun(string s,char ch)\\n  {\\n    long long t=-1,ans=0,n=s.size(),i=0;\\n\\n    while(i<n/2)\\n    {\\n       if(s[i]!=ch){\\n        while(i<n/2 and s[i]!=ch) i++;\\n        ans+=i+t+1;\\n        }\\n        else t=i,i++;\\n    }\\n    i=n-1,t=n;\\n    while(i>=n/2)\\n    {\\n      if(s[i]!=ch){\\n      while(i>=n/2 and s[i]!=ch) i--;\\n      ans+=n-i-1+n-t;\\n      }\\n      else  t=i,i--;\\n    }\\n    return ans;\\n  }\\n    long long minimumCost(string s) {\\n        // for(int i=0;i<s.size();i++) if(s[i]==\\'1\\') o++;else z++;\\n       return min(fun(s,\\'1\\'),fun(s,\\'0\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572598,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to think greedy either we flip left part or right part\\nleft part contains i elements, right part contains another n-i elements\\nAccording to the given problem cost \\nFor left part cost = (i) and for right part cost=n-i\\nwe\\'ve to take min steps for flip \\ntherefore, flip/take min(leftPart,rightPart) and add it to res \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n         long long ans = 0;\\n          int n=s.size();\\n       for(int i=1; i<n; i++){\\n           if(s[i]!=s[i-1])\\n           ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n         long long ans = 0;\\n          int n=s.size();\\n       for(int i=1; i<n; i++){\\n           if(s[i]!=s[i-1])\\n           ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572534,
                "title": "c-solution-beats-100-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n       long long ans = 0; int n=s.size();\\n       for(int i=1; i<s.size(); i++){\\n           if(s[i]!=s[i-1])ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n       long long ans = 0; int n=s.size();\\n       for(int i=1; i<s.size(); i++){\\n           if(s[i]!=s[i-1])ans+=min(i,n-i);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572436,
                "title": "very-simple-easy-solution-with-best-explanation",
                "content": "# Approach\\n    In range [L,R] => R-L+1 elements\\n    loop i=1 to n-1      \\n    we\\'re at any ith index and check \\n    left part================================================\\n    We\\'ve already check till ith index \\n    it means that all the character from [0,i-1] are same \\n    total elements in [0,i-1] => (i-1)-(0)+1 => i elements \\n    \\n    right part================================================\\n    total elements in [i,n-1] => (n-1)-(i)+1 => n-i elements\\n\\n    We have to think greedy either we flip left part or right part\\n    left part contains i elements, right part contains another n-i elements\\n    According to the given problem cost \\n    For left part cost = (i) and for right part cost=n-i\\n    we\\'ve to take min steps for flip \\n    therefore, flip/take min(leftPart,rightPart) and add it to res \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long res=0;\\n        int n=s.size();\\n        for(int i=1 ; i<n ; ++i) {\\n            if(s[i]!=s[i-1]) {\\n                res+=min(i,n-i); \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long res=0;\\n        int n=s.size();\\n        for(int i=1 ; i<n ; ++i) {\\n            if(s[i]!=s[i-1]) {\\n                res+=min(i,n-i); \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572303,
                "title": "very-simple-and-easy-to-understand-different-from-other-single-loop-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        int lenMid = s.length()%2;\\n        long long ans = 0;\\n            if(s[s.length()/2] == \\'1\\'){\\n            int mid = s.length()/2;\\n            if(s.length()%2 == 0)mid--;\\n            int x = mid+1;\\n            bool b = false;\\n            while(mid >= 0){\\n                if(s[mid] == \\'0\\' && b == false){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                else if(s[mid] == \\'1\\' && b == true){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                mid--;\\n            }\\n            b = false;\\n            while(x<s.length()){\\n                if(s[x] == \\'0\\' && b == false){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                else if(s[x] == \\'1\\' && b == true){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                x++;\\n            }\\n        }\\n        else {\\n            int mid = s.length()/2;\\n            if(s.length()%2 == 0)mid--;\\n            int x = mid+1;\\n            bool b = false;\\n            while(mid >= 0){\\n                if(s[mid] == \\'1\\' && b == false){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                else if(s[mid] == \\'0\\' && b == true){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                mid--;\\n            }\\n            b = false;\\n            while(x<s.length()){\\n                if(s[x] == \\'1\\' && b == false){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                else if(s[x] == \\'0\\' && b == true){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                x++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n = s.length();\\n        int lenMid = s.length()%2;\\n        long long ans = 0;\\n            if(s[s.length()/2] == \\'1\\'){\\n            int mid = s.length()/2;\\n            if(s.length()%2 == 0)mid--;\\n            int x = mid+1;\\n            bool b = false;\\n            while(mid >= 0){\\n                if(s[mid] == \\'0\\' && b == false){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                else if(s[mid] == \\'1\\' && b == true){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                mid--;\\n            }\\n            b = false;\\n            while(x<s.length()){\\n                if(s[x] == \\'0\\' && b == false){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                else if(s[x] == \\'1\\' && b == true){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                x++;\\n            }\\n        }\\n        else {\\n            int mid = s.length()/2;\\n            if(s.length()%2 == 0)mid--;\\n            int x = mid+1;\\n            bool b = false;\\n            while(mid >= 0){\\n                if(s[mid] == \\'1\\' && b == false){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                else if(s[mid] == \\'0\\' && b == true){\\n                    b = !b;\\n                    ans += mid+1;\\n                }\\n                mid--;\\n            }\\n            b = false;\\n            while(x<s.length()){\\n                if(s[x] == \\'1\\' && b == false){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                else if(s[x] == \\'0\\' && b == true){\\n                    b = !b;\\n                    ans += n-x;\\n                }\\n                x++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572198,
                "title": "3d-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][2][2];\\n    int n;\\n    long long f(int ind, int prev, string &s, bool inverted){\\n        if(ind >= n) return 0;\\n        if(dp[ind][prev][inverted] != -1)\\n            return dp[ind][prev][inverted];\\n     \\n        //if curr and prev match and inverted is false\\n        if(s[ind] - 48 == prev && !inverted)\\n            return dp[ind][prev][inverted]= f(ind+1, s[ind]-48, s,false);\\n        //if prev and curr match and inverted is true.. then its considered as mismatch\\n        else if(s[ind]-48 == prev and inverted)\\n            return dp[ind][prev][inverted]= min(ind+ f(ind+1,s[ind]-48,s,false), n-ind + f(ind+1,!(s[ind]-48), s,true));\\n       //if prev and curr not match and inverted is true.. then its considered as match\\n        else if(s[ind] - 48 != prev and inverted)\\n            return dp[ind][prev][inverted]= f(ind+1, s[ind]-48, s,false);\\n        //if prev and curr not match and inverted is false.. then its considered as mismatch\\n        else if(s[ind] - 48 != prev and !inverted)\\n            return dp[ind][prev][inverted]= min(ind+ f(ind+1,s[ind]-48,s,false), n-ind + f(ind+1,!(s[ind]-48), s,true));\\n        else return -1;\\n    }\\n    long long minimumCost(string s) {\\n        n= s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(1,s[0]-48,s,false); //ind,prev,string,inverted\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][2][2];\\n    int n;\\n    long long f(int ind, int prev, string &s, bool inverted){\\n        if(ind >= n) return 0;\\n        if(dp[ind][prev][inverted] != -1)\\n            return dp[ind][prev][inverted];\\n     \\n        //if curr and prev match and inverted is false\\n        if(s[ind] - 48 == prev && !inverted)\\n            return dp[ind][prev][inverted]= f(ind+1, s[ind]-48, s,false);\\n        //if prev and curr match and inverted is true.. then its considered as mismatch\\n        else if(s[ind]-48 == prev and inverted)\\n            return dp[ind][prev][inverted]= min(ind+ f(ind+1,s[ind]-48,s,false), n-ind + f(ind+1,!(s[ind]-48), s,true));\\n       //if prev and curr not match and inverted is true.. then its considered as match\\n        else if(s[ind] - 48 != prev and inverted)\\n            return dp[ind][prev][inverted]= f(ind+1, s[ind]-48, s,false);\\n        //if prev and curr not match and inverted is false.. then its considered as mismatch\\n        else if(s[ind] - 48 != prev and !inverted)\\n            return dp[ind][prev][inverted]= min(ind+ f(ind+1,s[ind]-48,s,false), n-ind + f(ind+1,!(s[ind]-48), s,true));\\n        else return -1;\\n    }\\n    long long minimumCost(string s) {\\n        n= s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(1,s[0]-48,s,false); //ind,prev,string,inverted\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572171,
                "title": "c-100-faster-and-easy-explanation-and-clear-concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition behind this logis is that you have to flip the the bit in the string only when there is no match with next character. This is because if the character is matching then inverting it does not make a sense.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo check the next character and flip it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n                long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1])\\n                ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n                long long ans=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1])\\n                ans+=min(i+1,n-i-1);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572102,
                "title": "easy-100-space-andtime-beat",
                "content": "# Intuition\\n  - 1.cost can be i+1 or n-i.\\n  - 2.Splitting into and adding cost that is i+1 or n-i.\\n\\n  \\n![image.png](https://assets.leetcode.com/users/images/853d4fda-b852-4165-b7ee-c5f203eef799_1685280625.1763096.png)\\n\\n\\n# Approach\\n 1.spit the string into halves.check for matching in both sides and keep track of changes u have done .\\n2.Update the term before check and complte travel.\\n\\n# Complexity\\n- Time complexity:\\no(N)  single traversal\\n\\n- Space complexity:\\n O(1) constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size(),f=0,e=0;\\n        long long int ans=0;int a[n];\\n        a[n/2]=s[n/2]-\\'0\\';\\n         for (int i =n/2 ; i>0 ; i--)\\n        {  \\n           int p=s[i-1]-\\'0\\'+f;\\n             p=p%2;\\n           if (p!=a[i])\\n           {\\n              f++;\\n              ans+=i;\\n           }\\n             a[i-1]=a[i];\\n           \\n        }\\n        for (int i =n/2 ; i<n-1 ; i++)\\n        {  \\n           int p=s[i+1]-\\'0\\'+e; \\n            p=p%2;\\n           if (p!=a[i])\\n           {\\n              e++;\\n              ans+=(n-i-1);\\n           }\\n            a[i+1]=a[i];\\n           \\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size(),f=0,e=0;\\n        long long int ans=0;int a[n];\\n        a[n/2]=s[n/2]-\\'0\\';\\n         for (int i =n/2 ; i>0 ; i--)\\n        {  \\n           int p=s[i-1]-\\'0\\'+f;\\n             p=p%2;\\n           if (p!=a[i])\\n           {\\n              f++;\\n              ans+=i;\\n           }\\n             a[i-1]=a[i];\\n           \\n        }\\n        for (int i =n/2 ; i<n-1 ; i++)\\n        {  \\n           int p=s[i+1]-\\'0\\'+e; \\n            p=p%2;\\n           if (p!=a[i])\\n           {\\n              e++;\\n              ans+=(n-i-1);\\n           }\\n            a[i+1]=a[i];\\n           \\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572078,
                "title": "o-n-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans = 0;\\n        for(int i = 0; i<s.length()-1;i++){\\n            if(s.charAt(i) != s.charAt(i+1)) ans += Math.min(i+1,s.length()-i-1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        long ans = 0;\\n        for(int i = 0; i<s.length()-1;i++){\\n            if(s.charAt(i) != s.charAt(i+1)) ans += Math.min(i+1,s.length()-i-1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572070,
                "title": "one-path-iterative-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf two characters are different, flipping all characters starting at one of them makes those two characters equal, while preserving number of differences between characters in the flipped part.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start from the middle - to the left, we use first method because it is cheaper to the left, while to the right we use the second method. Commented out code is for debugging only, as we do not need to actually flip characters - we only need to compute cost.\\nThis allows for $$O(n)$$ time and $$O(1)$$ space solution, we only need one path to count cost. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long cost = 0;\\n        for(int i=s.size()/2; i > 0; i--) {\\n            if(s[i] != s[i-1]) {\\n                cost += i;\\n                /*\\n                for(int ii=0;ii<i;ii++) {\\n                    if(s[ii] == \\'1\\') {\\n                        s[ii] = \\'0\\';\\n                    } else {\\n                        s[ii] = \\'1\\';\\n                    }\\n                }\\n                */\\n            }\\n        }\\n        for(int i=s.size()/2; i < s.size() - 1; i++) {\\n            if(s[i] != s[i+1]) {\\n                cost += s.size() - i - 1;\\n                /*\\n                for(int ii=i+1;ii< s.size();ii++) {\\n                    if(s[ii] == \\'1\\') {\\n                        s[ii] = \\'0\\';\\n                    } else {\\n                        s[ii] = \\'1\\';\\n                    }\\n                }\\n                */\\n            }\\n        }\\n        //cout << s << endl;\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long cost = 0;\\n        for(int i=s.size()/2; i > 0; i--) {\\n            if(s[i] != s[i-1]) {\\n                cost += i;\\n                /*\\n                for(int ii=0;ii<i;ii++) {\\n                    if(s[ii] == \\'1\\') {\\n                        s[ii] = \\'0\\';\\n                    } else {\\n                        s[ii] = \\'1\\';\\n                    }\\n                }\\n                */\\n            }\\n        }\\n        for(int i=s.size()/2; i < s.size() - 1; i++) {\\n            if(s[i] != s[i+1]) {\\n                cost += s.size() - i - 1;\\n                /*\\n                for(int ii=i+1;ii< s.size();ii++) {\\n                    if(s[ii] == \\'1\\') {\\n                        s[ii] = \\'0\\';\\n                    } else {\\n                        s[ii] = \\'1\\';\\n                    }\\n                }\\n                */\\n            }\\n        }\\n        //cout << s << endl;\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3572060,
                "title": "c-prefix-and-suffix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long minimumCost(string s) {\\n        ll ans=1e18;\\n        int n= s.size();\\n        vector<ll> pre(n,0),suf(n,0);\\n        pre[0]=0;\\n        suf[n-1]=0;\\n        for(int i=1;i<n;++i)\\n           pre[i]= pre[i-1] + (s[i] != s[i-1] ? i : 0);\\n        for(int i=n-2;i>=0;--i)\\n            suf[i]= suf[i+1] + (s[i] != s[i+1] ? (n-i-1) : 0);\\n        \\n        for(int i=0;i<n;i++)\\n            ans= min(ans, pre[i]+suf[i]);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long minimumCost(string s) {\\n        ll ans=1e18;\\n        int n= s.size();\\n        vector<ll> pre(n,0),suf(n,0);\\n        pre[0]=0;\\n        suf[n-1]=0;\\n        for(int i=1;i<n;++i)\\n           pre[i]= pre[i-1] + (s[i] != s[i-1] ? i : 0);\\n        for(int i=n-2;i>=0;--i)\\n            suf[i]= suf[i+1] + (s[i] != s[i+1] ? (n-i-1) : 0);\\n        \\n        for(int i=0;i<n;i++)\\n            ans= min(ans, pre[i]+suf[i]);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571935,
                "title": "fast-100-easy-explanation-greedy-o-n-clean-code-c",
                "content": "# Intuition\\nIt says we have to flip all the bits in a Binary string i.e (0,1) to make the string of same bits of:\\n* *Think Greedy*\\n\\n# Approach\\n* start traversing through the array\\n*  If you encounter different element i.e s[i] != s[i-1]:\\ncheck from which side it is feasible for us to take less move to make it equal min(i,n-i) either from the front or from the back.\\nMaintain a variable ans and keep on adding the min value required for us.\\n* finally return ans\\uD83D\\uDE0A\\n\\n# Complexity\\n- Time complexity: - 0(n)\\n\\n- Space complexity: - 0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        \\n     long long  int res=0;\\n       int n=s.size();\\n    \\n       for(int i=1;i<n;i++){\\n                  if(s[i]!=s[i-1]){\\n                      res+=min(n-i,i);\\n                  }\\n       }\\n       return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        \\n     long long  int res=0;\\n       int n=s.size();\\n    \\n       for(int i=1;i<n;i++){\\n                  if(s[i]!=s[i-1]){\\n                      res+=min(n-i,i);\\n                  }\\n       }\\n       return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571913,
                "title": "o-n-intution-expained-beats-100-people-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nactually by seeong minimization problem i thought this question we can do by recursion but i first tried of greedy approach first think like if we have an array of 0 and 1s of length n then we can make all its elemnys to either 1 or 0 but for changing we must think greedyly\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirstly think of a solution where u make all elemnts to 0 and after that all elemnts to 1 and we can take minimum of both answers\\nbut here coes a catch let length of arr is n=6 then if we want to make 0th index elemnt change from 9 to 1 or 1 to 0 it would be optimal to change all i elemnts and take i+1 score rather than changing n-1 to i elemnts and adding answer n-i so if we are we divide array to two halfs one left half other right half.\\nnow let us take an array =[011000] left=[011]right=[000]\\n# 1)convert all elemnts to 0:\\ntarverse from mid-1 th index if its not set to zero update answer with ans+=(i+1) change all elemnts from 0 to i but it would take n time approx for each step so keep a flag that says whether if its 0 then that value is not changed if its one then that value is changed do like this till we reach left end\\ntarverse from mid to last index and do same step here first keep flag to 0\\n# 2)convert all elemnts to 1:\\ndo smae as we done for 0 but here convert 0s to 1\\n# 3)after finding both asnwwrs return minimum:\\n#    PLEASE UPVOTE IF U LIKE\\n\\n\\n# Complexity\\n- Time complexity:\\n# - O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        if(s.length()==1)return 0;\\n        long long int ans=0;\\n        long long int ans2=0;\\n        int mid=s.length()/2;\\n        \\n        int flag=0;\\n        int flag2=0;\\n        for(int i=mid-1;i>=0 ;i--){\\n            if(s[i]==\\'1\\'){\\n                \\n                if(flag==0){\\n                ans+=(i+1);\\n                flag++;\\n                }\\n                if(flag2==1){\\n                ans2+=(i+1);\\n                flag2++;\\n                }\\n                \\n            }\\n            else{\\n                if(flag==1){\\n                ans+=(i+1);\\n                flag++;\\n                }\\n                if(flag2==0){\\n                ans2+=(i+1);\\n                flag2++;\\n                }\\n                \\n                \\n            }\\n            flag=flag%2;\\n            flag2=flag2%2;\\n        }\\n        flag=0;\\n        flag2=0;\\n        for(int i=mid;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                \\n                if(flag==0){\\n                ans+=(s.length()-i);\\n                    \\n                flag++;\\n                }\\n                 if(flag2==1){\\n                \\n                     ans2+=(s.length()-i);\\n                flag2++;\\n                }\\n            }\\n            else{\\n                if(flag==1){\\n                \\n                    ans+=(s.length()-i);\\n                flag++;\\n                }\\n                if(flag2==0){\\n               \\n                    ans2+=(s.length()-i);\\n                flag2++;\\n                }\\n                \\n            }\\n            flag=flag%2;\\n            flag2=flag2%2;\\n            \\n        }\\n        return min(ans,ans2);\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        if(s.length()==1)return 0;\\n        long long int ans=0;\\n        long long int ans2=0;\\n        int mid=s.length()/2;\\n        \\n        int flag=0;\\n        int flag2=0;\\n        for(int i=mid-1;i>=0 ;i--){\\n            if(s[i]==\\'1\\'){\\n                \\n                if(flag==0){\\n                ans+=(i+1);\\n                flag++;\\n                }\\n                if(flag2==1){\\n                ans2+=(i+1);\\n                flag2++;\\n                }\\n                \\n            }\\n            else{\\n                if(flag==1){\\n                ans+=(i+1);\\n                flag++;\\n                }\\n                if(flag2==0){\\n                ans2+=(i+1);\\n                flag2++;\\n                }\\n                \\n                \\n            }\\n            flag=flag%2;\\n            flag2=flag2%2;\\n        }\\n        flag=0;\\n        flag2=0;\\n        for(int i=mid;i<s.length();i++){\\n            if(s[i]==\\'1\\'){\\n                \\n                if(flag==0){\\n                ans+=(s.length()-i);\\n                    \\n                flag++;\\n                }\\n                 if(flag2==1){\\n                \\n                     ans2+=(s.length()-i);\\n                flag2++;\\n                }\\n            }\\n            else{\\n                if(flag==1){\\n                \\n                    ans+=(s.length()-i);\\n                flag++;\\n                }\\n                if(flag2==0){\\n               \\n                    ans2+=(s.length()-i);\\n                flag2++;\\n                }\\n                \\n            }\\n            flag=flag%2;\\n            flag2=flag2%2;\\n            \\n        }\\n        return min(ans,ans2);\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571851,
                "title": "swift-solution-using-iteration-over-string",
                "content": "# Code\\n```\\nclass Solution {\\n    func minimumCost(_ s: String) -> Int {\\n        let s = Array(s)\\n        var res = 0\\n\\n        for i in s.indices.dropFirst() where s[i] != s[i - 1] {\\n            res += min(i, s.count - i)\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumCost(_ s: String) -> Int {\\n        let s = Array(s)\\n        var res = 0\\n\\n        for i in s.indices.dropFirst() where s[i] != s[i - 1] {\\n            res += min(i, s.count - i)\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571844,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        int h=n/2;\\n        long long ans1=0,ans2=0;\\n        //to ones\\n        bool ch=0;\\n        for(int i=h-1;i>=0;i--){\\n            if(s[i]!=\\'1\\' && ch==0){ans1+=i+1;ch=!ch;}\\n            if(s[i]==\\'1\\' && ch){ans1+=i+1;ch=!ch;}\\n        }\\n        ch=0;\\n        for(int i=h;i<n;i++){\\n            if(s[i]!=\\'1\\' && ch==0){ans1+=n-i;ch=!ch;}\\n            if(s[i]==\\'1\\' && ch){ans1+=n-i;ch=!ch;}\\n        }\\n        //to zeros\\n        ch=0;\\n        for(int i=h-1;i>=0;i--){\\n            if(s[i]!=\\'0\\' && ch==0){ans2+=i+1;ch=!ch;}\\n            if(s[i]==\\'0\\' && ch){ans2+=i+1;ch=!ch;}\\n        }\\n        ch=0;\\n        for(int i=h;i<n;i++){\\n            if(s[i]!=\\'0\\' && ch==0){ans2+=n-i;ch=!ch;}\\n            if(s[i]==\\'0\\' && ch){ans2+=n-i;ch=!ch;}\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n // for(int i=1;i<h;i++){\\n        //     if(s[i]!=s[i-1])ans+=i;\\n        // }\\n        // for(int i=h;i<n-1;i++){\\n        //     if(s[i]!=s[i+1])ans+=n-i;\\n        // }\\n        // if(s[h-1]!=s[h])ans+=min(h,n-h);\\n        // return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n        int h=n/2;\\n        long long ans1=0,ans2=0;\\n        //to ones\\n        bool ch=0;\\n        for(int i=h-1;i>=0;i--){\\n            if(s[i]!=\\'1\\' && ch==0){ans1+=i+1;ch=!ch;}\\n            if(s[i]==\\'1\\' && ch){ans1+=i+1;ch=!ch;}\\n        }\\n        ch=0;\\n        for(int i=h;i<n;i++){\\n            if(s[i]!=\\'1\\' && ch==0){ans1+=n-i;ch=!ch;}\\n            if(s[i]==\\'1\\' && ch){ans1+=n-i;ch=!ch;}\\n        }\\n        //to zeros\\n        ch=0;\\n        for(int i=h-1;i>=0;i--){\\n            if(s[i]!=\\'0\\' && ch==0){ans2+=i+1;ch=!ch;}\\n            if(s[i]==\\'0\\' && ch){ans2+=i+1;ch=!ch;}\\n        }\\n        ch=0;\\n        for(int i=h;i<n;i++){\\n            if(s[i]!=\\'0\\' && ch==0){ans2+=n-i;ch=!ch;}\\n            if(s[i]==\\'0\\' && ch){ans2+=n-i;ch=!ch;}\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n // for(int i=1;i<h;i++){\\n        //     if(s[i]!=s[i-1])ans+=i;\\n        // }\\n        // for(int i=h;i<n-1;i++){\\n        //     if(s[i]!=s[i+1])ans+=n-i;\\n        // }\\n        // if(s[h-1]!=s[h])ans+=min(h,n-h);\\n        // return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571720,
                "title": "c-greedy-full-explaination",
                "content": "# Approach\\nTake 2 cases i.e. either make all characters 0 or all characters 1 and take minimum answer of the two. Now to turn a character which is \\'1\\' to \\'0\\' at index i, we need to flip all indices from 0 to i and then to make the previous characters (before index i) back to their original values we need to flip all characters from 0 to i-1 index hence the total cost would be (i+1)+i, hence we  need to take minimum of the two cases i.e. flip from left end or right end and the minimum will be added in the answer. We have maintained two answers one for the case when we are turning every character to 0 if it is not and the other case is for turning every character to 1.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans1 = 0,ans2=0;\\n        int n = s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                long long tmp1 = i;\\n                int idx = i;\\n                while(i<n && s[i]==\\'1\\')\\n                    i++;\\n                tmp1+=i;\\n                long long tmp2 = n-idx+(n-i);\\n                ans1+=min(tmp1,tmp2);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                long long tmp1 = i;\\n                int idx = i;\\n                while(i<n && s[i]==\\'0\\')\\n                    i++;\\n                tmp1+=i;\\n                long long tmp2 = n-idx+(n-i);\\n                ans2+=min(tmp1,tmp2);\\n            }\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans1 = 0,ans2=0;\\n        int n = s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                long long tmp1 = i;\\n                int idx = i;\\n                while(i<n && s[i]==\\'1\\')\\n                    i++;\\n                tmp1+=i;\\n                long long tmp2 = n-idx+(n-i);\\n                ans1+=min(tmp1,tmp2);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                long long tmp1 = i;\\n                int idx = i;\\n                while(i<n && s[i]==\\'0\\')\\n                    i++;\\n                tmp1+=i;\\n                long long tmp2 = n-idx+(n-i);\\n                ans2+=min(tmp1,tmp2);\\n            }\\n        }\\n        return min(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571707,
                "title": "easy-c-dp-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(string &s, int x, int count, long long**dp){\\n        if(x>=s.size())\\n            return 0;\\n        else if(dp[x][count]!=-1)\\n            return dp[x][count];\\n        long long ans=0;\\n        if(count==0){\\n            if(s[x]!=s[x-1])\\n                ans=ans+x;\\n            ans=ans+min(solve(s,x+1,1,dp),solve(s,x+1,0,dp));\\n        }else{\\n            \\n            if(s[x]!=s[x-1])\\n                ans=ans+s.size()-x;\\n            ans= ans+solve(s,x+1,1,dp);\\n           \\n        }\\n        dp[x][count]=ans;\\n         return ans;\\n    }\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n    long long** dp = new long long*[n];\\n \\n    for (int i = 0; i < n; i++) {\\n        dp[i] = new long long[2];\\n        for(int j=0;j<2;j++)\\n            dp[i][j]=-1;\\n    }\\n            \\n       return solve(s,1,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(string &s, int x, int count, long long**dp){\\n        if(x>=s.size())\\n            return 0;\\n        else if(dp[x][count]!=-1)\\n            return dp[x][count];\\n        long long ans=0;\\n        if(count==0){\\n            if(s[x]!=s[x-1])\\n                ans=ans+x;\\n            ans=ans+min(solve(s,x+1,1,dp),solve(s,x+1,0,dp));\\n        }else{\\n            \\n            if(s[x]!=s[x-1])\\n                ans=ans+s.size()-x;\\n            ans= ans+solve(s,x+1,1,dp);\\n           \\n        }\\n        dp[x][count]=ans;\\n         return ans;\\n    }\\n    long long minimumCost(string s) {\\n        int n=s.size();\\n    long long** dp = new long long*[n];\\n \\n    for (int i = 0; i < n; i++) {\\n        dp[i] = new long long[2];\\n        for(int j=0;j<2;j++)\\n            dp[i][j]=-1;\\n    }\\n            \\n       return solve(s,1,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571638,
                "title": "good-question-great-solution-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        return min(countCost(s,\\'1\\'),countCost(s,\\'0\\'));      \\n    }\\n\\n    long long countCost(string& s,char ch){\\n        long long sum = 0;\\n        int n = s.size();\\n        char c= ch;\\n        for(int i=n/2;i>=0;i--){\\n            if(s[i]==c){\\n                sum+=(i+1);\\n                c = c==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n        }\\n        c = ch;\\n        for(int i=n/2+1;i<n;i++){\\n            if(s[i]==c){\\n                sum+=(n-i);\\n                c = c==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        return min(countCost(s,\\'1\\'),countCost(s,\\'0\\'));      \\n    }\\n\\n    long long countCost(string& s,char ch){\\n        long long sum = 0;\\n        int n = s.size();\\n        char c= ch;\\n        for(int i=n/2;i>=0;i--){\\n            if(s[i]==c){\\n                sum+=(i+1);\\n                c = c==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n        }\\n        c = ch;\\n        for(int i=n/2+1;i<n;i++){\\n            if(s[i]==c){\\n                sum+=(n-i);\\n                c = c==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571610,
                "title": "c-1-liner-with-linq",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public long MinimumCost(string s)\\n    {\\n        return Enumerable.Range(1, s.Length - 1)\\n            .Where(i => s[i - 1] != s[i])\\n            .Select(i => (long)Math.Min(i, s.Length - i))\\n            .Sum();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long MinimumCost(string s)\\n    {\\n        return Enumerable.Range(1, s.Length - 1)\\n            .Where(i => s[i - 1] != s[i])\\n            .Select(i => (long)Math.Min(i, s.Length - i))\\n            .Sum();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571540,
                "title": "easy-python-solution-missed-this-approach-in-leetcode-challenge",
                "content": "# AT EVERY IND CHECK IF WE SHOULD FLIP THE PREFIX INDEXES OR SUFFIX INDEXES BASED ON WHICH IS LESS.\\n# HAPPY LEETCODING !\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \\n        ans=0\\n        for i in range(1,len(s)):\\n            if s[i]!=s[i-1]:\\n                ans+=min(i,len(s)-i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        \\n        ans=0\\n        for i in range(1,len(s)):\\n            if s[i]!=s[i-1]:\\n                ans+=min(i,len(s)-i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571529,
                "title": "c-dp-solution",
                "content": "```\\n/*\\n    Let f(i,0/1,0/1) denote the minimum cost of setting all the first i elements to 0/1 and having an odd/even number of flips to the right\\n    \\nDecision 1: No flipping\\n    f(i,w,t) = f(i-1,w,t)                       w = t^si\\nDecision 2: Flip to the left only\\n    f(i,0,t) = f(i-1,1,t) + i                   t^si == 1\\n    f(i,1,t) = f(i-1,0,t) + i                   t^si == 0\\nDecision 3: Flip to the right only\\n    f(i,0,t^1) = f(i-1,0,t) + (n+1-i)           t^si == 1\\n    f(i,1,t^1) = f(i-1,1,t) + (n+1-i)           t^si == 0\\nDecision 4: Flip on each side\\n    f(i,1,t^1) = f(i-1,0,t) + (n+1)             t^si == 1\\n    f(i,0,t^1) = f(i-1,1,t) + (n+1)             t^si == 0\\n    \\n*/\\n```\\n\\n\\n```\\ntypedef long long       ll;\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {               int n = s.size();   s = \"#\" + s;\\n    \\n        ll  f[2][2][2];\\n        memset(f, 0x3f, sizeof(f));\\n        f[0][0][0] = 0;\\n        f[0][1][0] = 0;\\n                     \\n        int x = 0, w = 0;\\n        for (int i = 1; i <= n; i++) {                  x ^= 1;\\n            for (int t = 0; t <= 1; t++) {              w = t ^ (s[i]-\\'0\\');                       \\n                f[x][w][t]      = min(f[x][w][t],       f[1-x][w][t]);                  // Decision 1\\n                f[x][w^1][t]    = min(f[x][w^1][t],     f[1-x][w][t] + i);              // Decision 2\\n                f[x][w^1][t^1]  = min(f[x][w^1][t^1],   f[1-x][w^1][t] + (n+1-i));      // Decision 3\\n                f[x][w][t^1]    = min(f[x][w][t^1],     f[1-x][w][t] + (n+1));          // Decision 4\\n            }\\n            memset(f[1-x], 0x3f, sizeof(f[1-x]));\\n        }\\n                    \\n        ll  ans = LLONG_MAX;\\n        for (int w = 0; w <= 1; w++) {\\n            for (int t = 0; t <= 1; t++) ans = min(ans, f[x][w][t]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Let f(i,0/1,0/1) denote the minimum cost of setting all the first i elements to 0/1 and having an odd/even number of flips to the right\\n    \\nDecision 1: No flipping\\n    f(i,w,t) = f(i-1,w,t)                       w = t^si\\nDecision 2: Flip to the left only\\n    f(i,0,t) = f(i-1,1,t) + i                   t^si == 1\\n    f(i,1,t) = f(i-1,0,t) + i                   t^si == 0\\nDecision 3: Flip to the right only\\n    f(i,0,t^1) = f(i-1,0,t) + (n+1-i)           t^si == 1\\n    f(i,1,t^1) = f(i-1,1,t) + (n+1-i)           t^si == 0\\nDecision 4: Flip on each side\\n    f(i,1,t^1) = f(i-1,0,t) + (n+1)             t^si == 1\\n    f(i,0,t^1) = f(i-1,1,t) + (n+1)             t^si == 0\\n    \\n*/\\n```\n```\\ntypedef long long       ll;\\n\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {               int n = s.size();   s = \"#\" + s;\\n    \\n        ll  f[2][2][2];\\n        memset(f, 0x3f, sizeof(f));\\n        f[0][0][0] = 0;\\n        f[0][1][0] = 0;\\n                     \\n        int x = 0, w = 0;\\n        for (int i = 1; i <= n; i++) {                  x ^= 1;\\n            for (int t = 0; t <= 1; t++) {              w = t ^ (s[i]-\\'0\\');                       \\n                f[x][w][t]      = min(f[x][w][t],       f[1-x][w][t]);                  // Decision 1\\n                f[x][w^1][t]    = min(f[x][w^1][t],     f[1-x][w][t] + i);              // Decision 2\\n                f[x][w^1][t^1]  = min(f[x][w^1][t^1],   f[1-x][w^1][t] + (n+1-i));      // Decision 3\\n                f[x][w][t^1]    = min(f[x][w][t^1],     f[1-x][w][t] + (n+1));          // Decision 4\\n            }\\n            memset(f[1-x], 0x3f, sizeof(f[1-x]));\\n        }\\n                    \\n        ll  ans = LLONG_MAX;\\n        for (int w = 0; w <= 1; w++) {\\n            for (int t = 0; t <= 1; t++) ans = min(ans, f[x][w][t]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571520,
                "title": "simple-traversal-beats-100-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to make either all 0s and all 1s\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe do 1st operation on the first half of the string and second operation for the second half of the string,for both having all 0s and all 1s and the operation is sum with first half and second half,and take minimum of converting to 0s and converting to 1s\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    long long help(string s,char ch){\\n        long long ans=0,i;\\n        int n=s.size();\\n        bool correct=true;\\n//first half\\n        for(i=n/2-1;i>-1;--i){\\n            if(correct&&s[i]!=ch){\\n                ans+=i+1;\\n                correct=false;\\n            }\\n            else if(!correct&&s[i]==ch){\\n                ans+=i+1;\\n                correct=true;\\n            }\\n        }\\n//correct is used so that we dont have to invert all the 0s and 1s \\n//everytime we apply an operation\\n        long long ans2=0;\\n        correct=true;\\n        int x=s.size()/2;\\n        if(x&1)++x;\\n//second half\\n        for(i=n/2;i<n;++i){\\n            if(correct&&s[i]!=ch){\\n                ans2+=n-i;\\n                correct=false;\\n            }\\n            else if(!correct&&s[i]==ch){\\n                ans2+=n-i;\\n                correct=true;\\n            }\\n        }\\n\\n        return ans+ans2;\\n\\n    }\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=LLONG_MAX;\\n        ans=min(ans,help(s,\\'0\\'));\\n        ans=min(ans,help(s,\\'1\\'));\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long help(string s,char ch){\\n        long long ans=0,i;\\n        int n=s.size();\\n        bool correct=true;\\n//first half\\n        for(i=n/2-1;i>-1;--i){\\n            if(correct&&s[i]!=ch){\\n                ans+=i+1;\\n                correct=false;\\n            }\\n            else if(!correct&&s[i]==ch){\\n                ans+=i+1;\\n                correct=true;\\n            }\\n        }\\n//correct is used so that we dont have to invert all the 0s and 1s \\n//everytime we apply an operation\\n        long long ans2=0;\\n        correct=true;\\n        int x=s.size()/2;\\n        if(x&1)++x;\\n//second half\\n        for(i=n/2;i<n;++i){\\n            if(correct&&s[i]!=ch){\\n                ans2+=n-i;\\n                correct=false;\\n            }\\n            else if(!correct&&s[i]==ch){\\n                ans2+=n-i;\\n                correct=true;\\n            }\\n        }\\n\\n        return ans+ans2;\\n\\n    }\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=LLONG_MAX;\\n        ans=min(ans,help(s,\\'0\\'));\\n        ans=min(ans,help(s,\\'1\\'));\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571512,
                "title": "c-from-constraints-get-idea-of-linear-traversal-keep-past-traversed-substr-chars-equal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length(),i;\\n        long long cost=0;\\n        for(i=1;i<n;i++) if(s[i-1]!=s[i]) cost+=min(i,n-i);\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        int n=s.length(),i;\\n        long long cost=0;\\n        for(i=1;i<n;i++) if(s[i-1]!=s[i]) cost+=min(i,n-i);\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571496,
                "title": "just-a-2-line-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1]){\\n                if(i+1>s.size()-i-1){\\n                    ans+=s.size()-i-1;\\n                }\\n                else{\\n                    ans+=i+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) {\\n        long long ans=0;\\n        for(int i=0;i<s.size()-1;i++){\\n            if(s[i]!=s[i+1]){\\n                if(i+1>s.size()-i-1){\\n                    ans+=s.size()-i-1;\\n                }\\n                else{\\n                    ans+=i+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571486,
                "title": "very-easy-simple-one-loop-greedy-solution-beginner-friendly-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    private:\\n    int mini(int a,int b)\\n    {\\n        if(a>=b)return b;\\n        return a;\\n    }\\npublic:\\n    long long minimumCost(string s) \\n    {\\n       long long ans=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]!=s[i+1])\\n            {\\n                int temp=mini(s.size()-i-1,i+1);\\n                ans+=temp; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int mini(int a,int b)\\n    {\\n        if(a>=b)return b;\\n        return a;\\n    }\\npublic:\\n    long long minimumCost(string s) \\n    {\\n       long long ans=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]!=s[i+1])\\n            {\\n                int temp=mini(s.size()-i-1,i+1);\\n                ans+=temp; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571433,
                "title": "c-easiest-solution-beating-100-in-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        int n = s.length();\\n        long long ans = 0;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]!=s[i-1])\\n            {\\n                int mini = min(i,n-i);\\n                ans+=mini;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        int n = s.length();\\n        long long ans = 0;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]!=s[i-1])\\n            {\\n                int mini = min(i,n-i);\\n                ans+=mini;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571403,
                "title": "easy-c-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nclass Solution { \\npublic:\\n    long long minimumCost(string s) {\\n        long long count=0; \\n        for (int i=0; i<s.size()-1; i++){\\n            if (s[i]!=s[i+1]){\\n                count+=min(i+1, (int)s.size()-i-1);\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nclass Solution { \\npublic:\\n    long long minimumCost(string s) {\\n        long long count=0; \\n        for (int i=0; i<s.size()-1; i++){\\n            if (s[i]!=s[i+1]){\\n                count+=min(i+1, (int)s.size()-i-1);\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3571374,
                "title": "greedy-approach-with-detailed-explanation-best-code-for-new-users-one-line-code",
                "content": "# Intuition Detailed Explained code for the new users\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Greedy\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity \\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        //AUTHOR::MOHD FAISAL FROM INDIA\\n        long long ans=0;\\n        //HERE FIRST DECLARE THE VARIABLE THAT WILL BE OUR ANSWER\\n        for(int i=0;i<s.size()-1;i++) //A LOOP FOR CHECKING EVERY INDEX\\n        {\\n            if(s[i]!=s[i+1])\\n            {\\n                /*\\n                SUPPOSE THE STRING IS LIKE \"111000101\"\\n                NOW WE KNOW THAT FOR i=2 s[2]=\\'1\\',and S[3]=\\'0\\';\\n                FIRST CASE 1:\\n                SO EITHER WE WILL CHANGE ALL THE ELEMENT \\n                BEFORE i=2 TO THE \\'0\\' AND THAT OPERATION \\n                WILL COST i+1;\\n                SECOND CASE 2:(VERY IMPORTANT)\\n                HERE WE WILL GIVE CHANGE THE i+1(NOTE THAT IS NOT i)\\n                TO THE EVERY ELEMENT THAT ARE SAME BEFORE i\\n                IN THIS CASE ABOVE EXAMLE THAT IS \"111\" AND HERE \\n                WE ARE CHANGING THE S[3] WHICH IS \\'0\\' WE HAVE TO\\n                CHANGE S[3]=\\'0\\' TO THE \\'1\\' BUT HERE NOTE THAT \\n                ACCORDING TO  QUESTION CRITERIA WE CAN NOT\\n                CHANGE ONLY A SPECIFIC INDEX FROM \\'0\\' TO \\'1\\' AND\\n                VICE VERSA,IN THIS CASE WE CANNOT CHANGE ONLY S[3] \\n                FROM \\'0\\' TO \\'1\\'{EITHER CHANGE ALL INDEX FROM 0 to \\n                (i+1) OR ALL INDEX FROM (i+1) TO (n-(1))}               \\n                HERE WE HAVE TO CHANGE ALL THE ELEMENT FROM\\n                i+1 to n-1 AND ACCORDING TO THE QUESTION THAT WILL\\n                COST n-(i+1)\\n                [NOTE THAT :: HERE AGAIN INDEX IS NOT i HERE INDEX IS i+1(IMP)]\\n                NOW FOR EACH INDEX WHERE( i!=(i+1) ) WE HAVE TO ADD \\n                THE MINIMUM OF THE SITUATION 1 AND 2 TO OUR INITIALLY\\n                DECLARED VARIABLE\\n                NOW THE AFTER A LOOP WE HAVE CHECKED EVERY INDEX\\n                NOW VALUE OF ans(VARIABLE) WILL BE OUR FINAL ANSWER\\n*/\\n                int a=(i+1);  //CASE 1 COST\\n                int b=s.size()-(i+1); //CASE 2 COST\\n                ans=ans+(min(a,b));  //ADDING THE MINIMUM OF CASE 1 AND CASE 2 TO OUR DECLARED VARIABLE\\n            }\\n        }\\n      return ans; //RETURNING THE ANSWER\\n      /*\\n      HAPPY CODING,THANKS FOR WACTHING THE SOLUTION \\n      PLEASE UPVOTE\\n      HAPPY CODING\\n    LOVE FOR ALL HATRED FOR NONE\\n        */\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumCost(string s) \\n    {\\n        //AUTHOR::MOHD FAISAL FROM INDIA\\n        long long ans=0;\\n        //HERE FIRST DECLARE THE VARIABLE THAT WILL BE OUR ANSWER\\n        for(int i=0;i<s.size()-1;i++) //A LOOP FOR CHECKING EVERY INDEX\\n        {\\n            if(s[i]!=s[i+1])\\n            {\\n                /*\\n                SUPPOSE THE STRING IS LIKE \"111000101\"\\n                NOW WE KNOW THAT FOR i=2 s[2]=\\'1\\',and S[3]=\\'0\\';\\n                FIRST CASE 1:\\n                SO EITHER WE WILL CHANGE ALL THE ELEMENT \\n                BEFORE i=2 TO THE \\'0\\' AND THAT OPERATION \\n                WILL COST i+1;\\n                SECOND CASE 2:(VERY IMPORTANT)\\n                HERE WE WILL GIVE CHANGE THE i+1(NOTE THAT IS NOT i)\\n                TO THE EVERY ELEMENT THAT ARE SAME BEFORE i\\n                IN THIS CASE ABOVE EXAMLE THAT IS \"111\" AND HERE \\n                WE ARE CHANGING THE S[3] WHICH IS \\'0\\' WE HAVE TO\\n                CHANGE S[3]=\\'0\\' TO THE \\'1\\' BUT HERE NOTE THAT \\n                ACCORDING TO  QUESTION CRITERIA WE CAN NOT\\n                CHANGE ONLY A SPECIFIC INDEX FROM \\'0\\' TO \\'1\\' AND\\n                VICE VERSA,IN THIS CASE WE CANNOT CHANGE ONLY S[3] \\n                FROM \\'0\\' TO \\'1\\'{EITHER CHANGE ALL INDEX FROM 0 to \\n                (i+1) OR ALL INDEX FROM (i+1) TO (n-(1))}               \\n                HERE WE HAVE TO CHANGE ALL THE ELEMENT FROM\\n                i+1 to n-1 AND ACCORDING TO THE QUESTION THAT WILL\\n                COST n-(i+1)\\n                [NOTE THAT :: HERE AGAIN INDEX IS NOT i HERE INDEX IS i+1(IMP)]\\n                NOW FOR EACH INDEX WHERE( i!=(i+1) ) WE HAVE TO ADD \\n                THE MINIMUM OF THE SITUATION 1 AND 2 TO OUR INITIALLY\\n                DECLARED VARIABLE\\n                NOW THE AFTER A LOOP WE HAVE CHECKED EVERY INDEX\\n                NOW VALUE OF ans(VARIABLE) WILL BE OUR FINAL ANSWER\\n*/\\n                int a=(i+1);  //CASE 1 COST\\n                int b=s.size()-(i+1); //CASE 2 COST\\n                ans=ans+(min(a,b));  //ADDING THE MINIMUM OF CASE 1 AND CASE 2 TO OUR DECLARED VARIABLE\\n            }\\n        }\\n      return ans; //RETURNING THE ANSWER\\n      /*\\n      HAPPY CODING,THANKS FOR WACTHING THE SOLUTION \\n      PLEASE UPVOTE\\n      HAPPY CODING\\n    LOVE FOR ALL HATRED FOR NONE\\n        */\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571328,
                "title": "time-100-java-12ms-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        // Original: 0100100\\n        // Step 1: 1100101\\n        // Step 2: 0000101\\n        // Step 3: 0000010\\n        // Step 4: 0000001\\n        // Step 5: 0000000\\n        long cost = 0;\\n        for (int i = 0; i < s.length()-1; ++i) {\\n            if(s.charAt(i) != s.charAt(i+1)) {\\n                if (invertFront(i, s))\\n                    cost += i + 1;\\n                else\\n                    cost += s.length() - i - 1;\\n            }\\n        }\\n        return cost;\\n    }\\n    public boolean invertFront(int idx, String s) {\\n        // In order to make charAt(idx) and charAt(idx+1) equals,\\n        // Compare the cost of inverting front and back,\\n        // To determine should invert front or back of string.\\n        return idx + 1 < s.length() - idx - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumCost(String s) {\\n        // Original: 0100100\\n        // Step 1: 1100101\\n        // Step 2: 0000101\\n        // Step 3: 0000010\\n        // Step 4: 0000001\\n        // Step 5: 0000000\\n        long cost = 0;\\n        for (int i = 0; i < s.length()-1; ++i) {\\n            if(s.charAt(i) != s.charAt(i+1)) {\\n                if (invertFront(i, s))\\n                    cost += i + 1;\\n                else\\n                    cost += s.length() - i - 1;\\n            }\\n        }\\n        return cost;\\n    }\\n    public boolean invertFront(int idx, String s) {\\n        // In order to make charAt(idx) and charAt(idx+1) equals,\\n        // Compare the cost of inverting front and back,\\n        // To determine should invert front or back of string.\\n        return idx + 1 < s.length() - idx - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571314,
                "title": "simple-c-video",
                "content": "\\n    using ll = long long;\\n    class Solution {\\n    public:\\n    \\n    ll solve(string s, char c) {\\n        \\n        int n = s.size();\\n        \\n        ll sum = 0;\\n\\n        char ch  = c;\\n        \\n        for(int i = n/2; i >= 0; --i) {\\n            if(s[i] == ch) {\\n                sum += i+1;\\n                if(ch == \\'1\\') ch = \\'0\\'; else ch = \\'1\\';\\n            }\\n        }\\n \\n        ch = c;\\n        for(int i = n/2+1; i < n; ++i) {\\n            if(s[i] == ch) {\\n                sum += n - i;\\n                if(ch == \\'1\\') ch = \\'0\\' ;else ch = \\'1\\';\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    \\n    \\n    ll minimumCost(string s) {\\n\\n        \\n        return min(solve(s, \\'0\\'), solve(s, \\'1\\'));\\n\\n        \\n    }\\n};\\nhttps://youtu.be/zxJ2Zq_r2IQ",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\n    ll solve(string s, char c) {\\n        \\n        int n = s.size();\\n        \\n        ll sum = 0;\\n\\n        char ch  = c;\\n        \\n        for(int i = n/2; i >= 0; --i) {\\n            if(s[i] == ch) {\\n                sum += i+1;\\n                if(ch == \\'1\\') ch = \\'0\\'; else ch = \\'1\\';\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1908191,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1910225,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1908427,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1908777,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1908279,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 2019329,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1910341,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1908411,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            },
            {
                "id": 1908366,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Please suggest me some good resources/content, to solve these types of problems easily."
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "+1. These types of problems are bit time taking and difficult to solve\\n\\n"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "+1, Me too "
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "I am not sure how people get to that fancy dynamic-like one-liner `Math.min(i+1, n-i)`, but I was able to solve the task by drawing in the notepad. \n\nSo, the very first idea after trying out multiple cases was that sometimes 1st and 2nd operation may give a different cost based on the index, so I simply tried a bruteforce where you select the MID of the string and check left(applying just 1st) + right(applying just 2nd) cost. \n\nThen - one needs to come up with idea - what's the cost of applying just 1st or just the 2nd operation.\nThat also can be done by using notepad.\nOverall that was giving me a TLE as I was checking the stuff for each middle element which gives $$O(n^2)$$ which results in TLE for n=10^6. \n\nSomehow, I was able to grasp that I don't really need to select ALL MID positions and can select just the very middle as N/2. That was a deep insight and I haven't really figured that out myself, but that worked.\n\nI was really surprised to see a very similar approach in the HINTs section.. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "+1. I am not getting intuition to solve such kind of problems."
                    },
                    {
                        "username": "shivamxSK",
                        "content": "I guess this is time for me to quit coding"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "What is the proof of greedy solution works [prefix and suffix]? Can somebody explain me that?"
                    },
                    {
                        "username": "Meher6124",
                        "content": "simple greedy approach // easy to inderstand // just comparision (want then chek  it out)\\nhttps://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/solutions/3571496/just-a-2-line-simple-c-solution/"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "I solved it using two pointers in O(1) space. There can be many ways to solve such problems."
                    },
                    {
                        "username": "BlueNihilist",
                        "content": "i HATE Greedy problems. every time I think \"well there\\'s this algorithm but i\\'m not sure if it\\'ll yield optimal optimal solution. should i try dp?\" and every time whenever it\\'s dp i try to use different algorithm and when it\\'s a different algorithm i try to use dp. best case - it doesn\\'t work at all. worst case - i try to optimize it until i give up and look up the solution. darn."
                    },
                    {
                        "username": "SSD9797",
                        "content": "For the prefix-suffix dp approach, note the following: you cannot have an optimal scenario where a window from the start and a window from the end merge, because then you will just remove the merging part and get less cost as 2 flips result in no change. This is why it makes sense that there will be an index which does not change in the final answer, and you will have all the start-window operations ending before it, and end-window operations ending after. This is an important part that no one seemed to prove in their solutions. \\n\\nNow we define dp[i] as the optimal cost to make all s[0..i] equal to s[i], for prefix operations. The next part is why we claim that dp[i] = dp[i-1] + i, if s[i] != s[i-1].  \\n\\nHere is a short proof I thought of and I think this can also be extended to why the greedy solution that people have in the discuss section works: Note that  if s[i] != s[i-1] there will be at least one operation with cost of i to flip s[0..i-1], since we have to make s[i-1] = s[i]. In fact, there will be exactly one such operation in the optimal answer, because other such operations cancel out in pairs of 2, since we are flipping, and we can just remove them. WLOG we can say that we perform this operation in the end for the optimal answer, since the order of flipping operations doesn\\'t matter. Hence just before this operation all s[0..i-1] should be equal to s[i-1], and we are looking for the optimal way to get there which is dp[i-1]. Thus dp[i] = dp[i-1] + i. Similar reasoning can be applied for suffix operations.\\n\\nPlease let me know your thoughts/comments on the proof. \\n"
                    },
                    {
                        "username": "math3846",
                        "content": "I can not prove why greedy works."
                    },
                    {
                        "username": "VIDHWANSHAK",
                        "content": "https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/submissions/958742865/\nI was able to write the backtracking approach for this but couldn't come up with any better approach.\nI couldn't memoize this solution.\nPlease share some tips and questions (to practice) to solve these kind of problems.\n"
                    }
                ]
            }
        ]
    }
]