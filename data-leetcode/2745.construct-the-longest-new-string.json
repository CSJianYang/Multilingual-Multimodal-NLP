[
    {
        "title": "Find Maximum Number of String Pairs",
        "question_content": "You are given a 0-indexed array words consisting of distinct strings.\nThe string words[i] can be paired with the string words[j] if:\n\n\tThe string words[i] is equal to the reversed string of words[j].\n\t0 <= i < j < words.length.\n\nReturn the maximum number of pairs that can be formed from the array words.\nNote that&nbsp;each string can belong in&nbsp;at most one pair.\n&nbsp;\nExample 1:\n\nInput: words = [\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]\nOutput: 2\nExplanation: In this example, we can form 2 pair of strings in the following way:\n- We pair the 0th string with the 2nd string, as the reversed string of word[0] is \"dc\" and is equal to words[2].\n- We pair the 1st string with the 3rd string, as the reversed string of word[1] is \"ca\" and is equal to words[3].\nIt can be proven that 2 is the maximum number of pairs that can be formed.\nExample 2:\n\nInput: words = [\"ab\",\"ba\",\"cc\"]\nOutput: 1\nExplanation: In this example, we can form 1 pair of strings in the following way:\n- We pair the 0th string with the 1st string, as the reversed string of words[1] is \"ab\" and is equal to words[0].\nIt can be proven that 1 is the maximum number of pairs that can be formed.\n\nExample 3:\n\nInput: words = [\"aa\",\"ab\"]\nOutput: 0\nExplanation: In this example, we are unable to form any pair of strings.\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 50\n\twords[i].length == 2\n\twords&nbsp;consists of distinct strings.\n\twords[i]&nbsp;contains only lowercase English letters.",
        "solutions": [
            {
                "id": 3677578,
                "title": "explained-using-map-very-simple-easy-to-understand-solution",
                "content": "#### Upvote if you like the solution\\n# Approach\\n1. Take a map with seen string as the index and its count as its value.\\n2. Iterate the words vector and check if its reverse exist in the map or not. \\n3. If exist in the map then update the ans and decrement the map value as the we have considered this value for pairing.\\n\\n# Code\\n```\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int ans = 0;\\n        unordered_map<string, int> mp;\\n        for(auto w: words){\\n            string r = w;\\n            reverse(r.begin(), r.end());\\n            if(mp[r] > 0){ ans++; mp[r]--; }\\n            else mp[w]++;\\n        }\\n        return ans;\\n    }\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int ans = 0;\\n        unordered_map<string, int> mp;\\n        for(auto w: words){\\n            string r = w;\\n            reverse(r.begin(), r.end());\\n            if(mp[r] > 0){ ans++; mp[r]--; }\\n            else mp[w]++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677686,
                "title": "676",
                "content": "There are 676 possible 2-character strings.\\n\\nSo, we can use a boolean array to track if we\\'ve seen a string before.\\n\\n**C++**\\n```cpp\\nint maximumNumberOfStringPairs(vector<string>& words) {\\n    int vis[676] = {}, res = 0;\\n    for (const auto &w : words) {\\n        res += vis[(w[1] - \\'a\\') * 26 + w[0] - \\'a\\'];\\n        vis[(w[0] - \\'a\\') * 26 + w[1] - \\'a\\'] = true;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumNumberOfStringPairs(vector<string>& words) {\\n    int vis[676] = {}, res = 0;\\n    for (const auto &w : words) {\\n        res += vis[(w[1] - \\'a\\') * 26 + w[0] - \\'a\\'];\\n        vis[(w[0] - \\'a\\') * 26 + w[1] - \\'a\\'] = true;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677662,
                "title": "c-java-python-o-1-space-easy-to-understand-with-explanation",
                "content": "- Time complexity : O(n^2)\\n- Space complexity : O(1)\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n        int ans = 0; // Initialize the variable to store the answer\\n        int n = v.size(); \\n\\n        // Iterate over all pairs of strings\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n\\n                // Check if i-th string is eaqual to reverse of j-th string\\n                if (v[i][0] == v[j][1] && v[i][1] == v[j][0]) {\\n                    ans++; // Increment the count of matching pairs\\n                }\\n            }\\n        }\\n\\n        return ans; // Return the total number of matching pairs\\n    }\\n};\\n\\n```\\n# Phython Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, word: List[str]) -> int:\\n        ans = 0\\n        n = len(word)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                if word[i][0] == word[j][1] and word[i][1] == word[j][0]:\\n                    ans += 1\\n        return ans\\n```\\n# JAVA Code \\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans = 0;\\n        int n = words.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n        int ans = 0; // Initialize the variable to store the answer\\n        int n = v.size(); \\n\\n        // Iterate over all pairs of strings\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n\\n                // Check if i-th string is eaqual to reverse of j-th string\\n                if (v[i][0] == v[j][1] && v[i][1] == v[j][0]) {\\n                    ans++; // Increment the count of matching pairs\\n                }\\n            }\\n        }\\n\\n        return ans; // Return the total number of matching pairs\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, word: List[str]) -> int:\\n        ans = 0\\n        n = len(word)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                if word[i][0] == word[j][1] and word[i][1] == word[j][0]:\\n                    ans += 1\\n        return ans\\n```\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans = 0;\\n        int n = words.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677591,
                "title": "easy-c-solution-using-unordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nreverse  and check the string is  present in the set\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string>mp;\\n        int res=0;\\n        for(auto it:words){\\n            string s=it;\\n            reverse(it.begin(),it.end());\\n            if(mp.find(it)==mp.end()){\\n                mp.insert(s);\\n            }\\n            else res++;\\n           \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string>mp;\\n        int res=0;\\n        for(auto it:words){\\n            string s=it;\\n            reverse(it.begin(),it.end());\\n            if(mp.find(it)==mp.end()){\\n                mp.insert(s);\\n            }\\n            else res++;\\n           \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721668,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n\\n# Intuition\\nThe problem asks us to find the maximum number of pairs that can be formed from a given list of words, where two words can be paired if one is the reverse of the other. We can use a set to keep track of the reversed versions of the words we have seen so far, and increment our answer whenever we encounter a word that is already in the set.\\n\\n# Approach\\n1. Initialize an empty set `strings` to keep track of the reversed versions of the words we have seen so far.\\n2. Initialize a variable `ans` to 0 to keep track of the number of pairs we have found.\\n3. Iterate over each word `w` in `words`.\\n4. If `w` is in `strings`, increment `ans` by 1.\\n5. Otherwise, add the reversed version of `w` to `strings`.\\n6. Return `ans`.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$, where $$n$$ is the number of words and $$k$$ is the maximum length of a word.\\n- Space complexity: $$O(nk)$$, where $$n$$ is the number of words and $$k$$ is the maximum length of a word.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        strings = set()\\n        ans = 0\\n        for w in words:\\n            if w in strings:\\n                ans += 1\\n            else:\\n                strings.add(w[::-1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        strings = set()\\n        ans = 0\\n        for w in words:\\n            if w in strings:\\n                ans += 1\\n            else:\\n                strings.add(w[::-1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678533,
                "title": "c-set-vs-hashing-string-to-int-vs-bitmask-hashing-4ms-20-5mb",
                "content": "Let\\'s start with the simplest approach, which means we will use a hashset (`seen`) to keep track of already encountered strings.\\n\\nMore specifically, we will start declaring:\\n* `res` as our usual counter variable, initially set to be `0`;\\n* `seen`, our set where we will store what we already saw (or its reverse, in the second version of this solution down below).\\n\\nFor each `word` in `words`, we will:\\n* store the original `word` in `orig`;\\n* swap its first and second character;\\n* check if we have ever seen the newly reversed `word` in `seen` and, if so, increase `res` by `1`;\\n* store `orig` in `seen`.\\n\\nFinally, we will `return` `res`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0;\\n        unordered_set<string> seen;\\n        // parsing words\\n        for (string &word: words) {\\n            string orig = word;\\n            swap(word[0], word[1]);\\n            if (seen.find(word) != end(seen)) res++;\\n            seen.insert(orig);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWe can actually play a bit smarter here and look up for the word itself, then store just the reverse of it, having to use `tmp` all the time:\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0;\\n        unordered_set<string> seen;\\n        // parsing words\\n        for (string &word: words) {\\n            if (seen.find(word) != end(seen)) res++;\\n            swap(word[0], word[1]);\\n            seen.insert(word);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut we can do better if we just consider that we have an alphabet of only `26` characters, and each word will only be `2` characters - so we can hash each string counting in base `26`, for a grant total of `26 * 26 == 676` cells.\\n\\nWe can then hash each word into an `int` and do way quicker checks about what we have seen before or not (albeit with potentially higher initialisation costs for `seen` with smaller sets of words).\\n\\nNotice we might actually optimise a bit more, space-wise, if we consider that strings like `\"aa\"`, `\"bb\"`, `\"cc\"`, etc. have no place being considered and since they appear every `27` positions, proceeding lexicographically, we might adjust our hashing by subtracting its value `/ 27`, but not really worth all the cost to save a handful of bites.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nconstexpr int maxRange = 676;\\n\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0, tmp;\\n        bool seen[maxRange] = {};\\n        // parsing words\\n        for (string &word: words) {\\n            tmp = (word[0] - \\'a\\') * 26 + word[1] - \\'a\\';\\n            if (seen[tmp]) res++;\\n            seen[(word[1] - \\'a\\') * 26 + word[0] - \\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nSame core logic, but hashing getting the value of each character with a bitmask (`\\'a\\' & 31` is `1`, `\\'b\\' & 31` is `2`, and so on), using `5` bits for each digits (since they are enough to represent values up to `31`, so fully within our range), which makes `10` bits total or, in other words, `1024` slots in `seen`.\\n\\nAgain, not a major increment with the small values we are dealing with, but still maybe a tad faster and a lot of fun to handle.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nconstexpr int maxRange = 1024, bitmask = 31;\\n\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0, tmp;\\n        bool seen[maxRange] = {};\\n        // parsing words\\n        for (string &word: words) {\\n            tmp = ((word[0] & bitmask) << 5) + (word[1] & bitmask);\\n            if (seen[tmp]) res++;\\n            seen[((word[1] & bitmask) << 5) + (word[0] & bitmask)] = true;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation",
                    "Hash Function",
                    "Bitmask"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0;\\n        unordered_set<string> seen;\\n        // parsing words\\n        for (string &word: words) {\\n            string orig = word;\\n            swap(word[0], word[1]);\\n            if (seen.find(word) != end(seen)) res++;\\n            seen.insert(orig);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0;\\n        unordered_set<string> seen;\\n        // parsing words\\n        for (string &word: words) {\\n            if (seen.find(word) != end(seen)) res++;\\n            swap(word[0], word[1]);\\n            seen.insert(word);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int maxRange = 676;\\n\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0, tmp;\\n        bool seen[maxRange] = {};\\n        // parsing words\\n        for (string &word: words) {\\n            tmp = (word[0] - \\'a\\') * 26 + word[1] - \\'a\\';\\n            if (seen[tmp]) res++;\\n            seen[(word[1] - \\'a\\') * 26 + word[0] - \\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int maxRange = 1024, bitmask = 31;\\n\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0, tmp;\\n        bool seen[maxRange] = {};\\n        // parsing words\\n        for (string &word: words) {\\n            tmp = ((word[0] & bitmask) << 5) + (word[1] & bitmask);\\n            if (seen[tmp]) res++;\\n            seen[((word[1] & bitmask) << 5) + (word[0] & bitmask)] = true;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834659,
                "title": "python-3-3-lines-w-explanation-t-m-99-77",
                "content": "Here\\'s how the code works:\\n\\nThe code initializes`d`to keep track of the count of each word or its reverse.\\n\\nWe iterate over each word in`words`, and we use the lexicographic minimum of the word and its reverse (`word[::-1]`)as the key for loading `words` into `d`, which ensures that the same pair is counted only once.\\n\\nWe return the sum of the counts of pairs in each value (using`x*(x-1)//2`) as the answer.\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n\\n        d = defaultdict(int)\\n\\n        for word in words:\\n            d[min(word, word[::-1])]+= 1\\n        \\n        return  sum(map((lambda x: x*(x-1)), d.values()))//2\\n```\\n[https://leetcode.com/problems/find-maximum-number-of-string-pairs/submissions/978714868/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*NM*) and space complexity is *O*(*N*), in which *N* ~`len(nums)` and *M* ~ average`len(word)`.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n\\n        d = defaultdict(int)\\n\\n        for word in words:\\n            d[min(word, word[::-1])]+= 1\\n        \\n        return  sum(map((lambda x: x*(x-1)), d.values()))//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816585,
                "title": "video-maximum-number-of-string-pairs-reversed-string-pairing",
                "content": "# Intuition\\nUpon reading the problem, it\\'s apparent that we need to pair strings that are the reverse of each other. The first instinct is to use a data structure that allows quick lookups to check for the existence of a reversed word. A Python dictionary fits this need perfectly.\\n\\nhttps://www.youtube.com/watch?v=zL2d3G-nO0A\\n\\n# Approach\\nWe\\'ll start by initializing an empty dictionary and a counter variable to track the number of pairs. Next, we iterate through each word in the list. For each word, we generate its reversed counterpart and check if this reversed word is in the dictionary. If it is, we increment our counter and remove the reversed word from the dictionary, effectively forming a pair. If not, we add the original word to the dictionary. This process continues until we\\'ve iterated through all the words. Finally, we return the counter as the result, which is the maximum number of pairs we can form.\\n\\n# Complexity\\n- Time complexity: The time complexity is \\\\(O(n)\\\\) where \\\\(n\\\\) is the length of the input list. This is because we\\'re iterating through the list once.\\n\\n- Space complexity: The space complexity is also \\\\(O(n)\\\\) in the worst-case scenario where no words can be paired and all words end up in the dictionary.\\n\\nIn the code, we\\'ve used Python\\'s string slicing feature to reverse the string and dictionary\\'s quick lookup feature to find the reversed string. This solution thus efficiently solves the problem.\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        word_dict = {} \\n        pairs = 0 \\n        for word in words: \\n            reversed_word = word[::-1] \\n            if reversed_word in word_dict: \\n                word_dict.pop(reversed_word) \\n                pairs += 1 \\n            else: \\n                word_dict[word] = 1 \\n        return pairs \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        std::unordered_map<std::string, int> word_dict;\\n        int pairs = 0;\\n        for (auto& word : words) {\\n            std::string reversed_word = word;\\n            std::reverse(reversed_word.begin(), reversed_word.end());\\n            if (word_dict[reversed_word]) {\\n                word_dict[reversed_word]--;\\n                pairs++;\\n            }\\n            else {\\n                word_dict[word]++;\\n            }\\n        }\\n        return pairs;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashMap<String, Integer> word_dict = new HashMap<>();\\n        int pairs = 0;\\n        for (String word : words) {\\n            String reversed_word = new StringBuilder(word).reverse().toString();\\n            if (word_dict.containsKey(reversed_word) && word_dict.get(reversed_word) > 0) {\\n                word_dict.put(reversed_word, word_dict.get(reversed_word) - 1);\\n                pairs++;\\n            }\\n            else {\\n                word_dict.put(word, word_dict.getOrDefault(word, 0) + 1);\\n            }\\n        }\\n        return pairs;        \\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let word_dict = {};\\n    let pairs = 0;\\n    for (let word of words) {\\n        let reversed_word = word.split(\\'\\').reverse().join(\\'\\');\\n        if (word_dict[reversed_word]) {\\n            word_dict[reversed_word]--;\\n            pairs++;\\n        }\\n        else {\\n            word_dict[word] = (word_dict[word] || 0) + 1;\\n        }\\n    }\\n    return pairs;    \\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public int MaximumNumberOfStringPairs(string[] words) {\\n        Dictionary<string, int> word_dict = new Dictionary<string, int>();\\n        int pairs = 0;\\n        foreach (string word in words) {\\n            char[] arr = word.ToCharArray();\\n            Array.Reverse(arr);\\n            string reversed_word = new string(arr);\\n            if (word_dict.ContainsKey(reversed_word) && word_dict[reversed_word] > 0) {\\n                word_dict[reversed_word]--;\\n                pairs++;\\n            }\\n            else {\\n                if (!word_dict.ContainsKey(word)) word_dict[word] = 0;\\n                word_dict[word]++;\\n            }\\n        }\\n        return pairs;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        word_dict = {} \\n        pairs = 0 \\n        for word in words: \\n            reversed_word = word[::-1] \\n            if reversed_word in word_dict: \\n                word_dict.pop(reversed_word) \\n                pairs += 1 \\n            else: \\n                word_dict[word] = 1 \\n        return pairs \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        std::unordered_map<std::string, int> word_dict;\\n        int pairs = 0;\\n        for (auto& word : words) {\\n            std::string reversed_word = word;\\n            std::reverse(reversed_word.begin(), reversed_word.end());\\n            if (word_dict[reversed_word]) {\\n                word_dict[reversed_word]--;\\n                pairs++;\\n            }\\n            else {\\n                word_dict[word]++;\\n            }\\n        }\\n        return pairs;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashMap<String, Integer> word_dict = new HashMap<>();\\n        int pairs = 0;\\n        for (String word : words) {\\n            String reversed_word = new StringBuilder(word).reverse().toString();\\n            if (word_dict.containsKey(reversed_word) && word_dict.get(reversed_word) > 0) {\\n                word_dict.put(reversed_word, word_dict.get(reversed_word) - 1);\\n                pairs++;\\n            }\\n            else {\\n                word_dict.put(word, word_dict.getOrDefault(word, 0) + 1);\\n            }\\n        }\\n        return pairs;        \\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let word_dict = {};\\n    let pairs = 0;\\n    for (let word of words) {\\n        let reversed_word = word.split(\\'\\').reverse().join(\\'\\');\\n        if (word_dict[reversed_word]) {\\n            word_dict[reversed_word]--;\\n            pairs++;\\n        }\\n        else {\\n            word_dict[word] = (word_dict[word] || 0) + 1;\\n        }\\n    }\\n    return pairs;    \\n};\\n```\n``` C# []\\npublic class Solution {\\n    public int MaximumNumberOfStringPairs(string[] words) {\\n        Dictionary<string, int> word_dict = new Dictionary<string, int>();\\n        int pairs = 0;\\n        foreach (string word in words) {\\n            char[] arr = word.ToCharArray();\\n            Array.Reverse(arr);\\n            string reversed_word = new string(arr);\\n            if (word_dict.ContainsKey(reversed_word) && word_dict[reversed_word] > 0) {\\n                word_dict[reversed_word]--;\\n                pairs++;\\n            }\\n            else {\\n                if (!word_dict.ContainsKey(word)) word_dict[word] = 0;\\n                word_dict[word]++;\\n            }\\n        }\\n        return pairs;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738371,
                "title": "simple-java-with-iterator",
                "content": "# Approach\\nI used Iterator and StringBuffer.reverse() for easy and simple solution.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        List<String> wordsList = new ArrayList(Arrays.asList(words));\\n        int count = 0;\\n        for (Iterator<String> wordsIterator = wordsList.iterator(); wordsIterator.hasNext();) {\\n            String word = wordsIterator.next();\\n            wordsIterator.remove();\\n            if (wordsList.contains(reverse(word))) count++;\\n        }\\n        return count;\\n    }\\n\\n    private String reverse(String input) {\\n        return new StringBuffer(input).reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        List<String> wordsList = new ArrayList(Arrays.asList(words));\\n        int count = 0;\\n        for (Iterator<String> wordsIterator = wordsList.iterator(); wordsIterator.hasNext();) {\\n            String word = wordsIterator.next();\\n            wordsIterator.remove();\\n            if (wordsList.contains(reverse(word))) count++;\\n        }\\n        return count;\\n    }\\n\\n    private String reverse(String input) {\\n        return new StringBuffer(input).reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736904,
                "title": "java-solution-using-stringbuilder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find whether the reverse of a string at words[i] is present at index j such that 0<=i<j<words.length and return the count of such pairs found.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used two for loops one from i=0 to words.length and inside it from j=i+1 to words.length and stored the words[j] in a string builder and compared it to the words[i] by reversing the one at index j and after the comparison has taken place then emtpying the stringbuilder so that new string can be stored in it.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                sb.append(words[j]);\\n                if(words[i].equals(sb.reverse().toString())){\\n                    count++;\\n                }\\n                sb.delete(0,sb.length());\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/789fb96d-4a96-464c-a4ee-ea8b1f844689_1688829277.9101799.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                sb.append(words[j]);\\n                if(words[i].equals(sb.reverse().toString())){\\n                    count++;\\n                }\\n                sb.delete(0,sb.length());\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690265,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681331,
                "title": "easy-peasy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677706,
                "title": "java-o-n-runtime-o-n-space-scalable-solution-using-stringbuilder-reverse",
                "content": "O(N) runtime due to iteration through `words`.\\nO(N) space due to HashSet `wordSet` that may go up to N, the input `words` length.\\n\\nPairs are unique so removing from HashSet is never needed.\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int maxPairs = 0;\\n        \\n        //Iterate through words and insert them into a HashSet\\n        //At each word, check if you have seen it\\'s reverse\\n        Set<String> wordSet = new HashSet<>();\\n        \\n        for(String word : words) {\\n            StringBuilder sb = new StringBuilder(word);\\n            String reversedWord = sb.reverse().toString();\\n            \\n            //We have seen the reverse here, so we increment a pair has been found\\n\\t\\t\\t//contains() check is O(1) runtime\\n            if(wordSet.contains(reversedWord)) {\\n                maxPairs++;\\n            }\\n            \\n            //Always add a word that we have run across\\n            wordSet.add(word);\\n        }\\n        \\n        return maxPairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int maxPairs = 0;\\n        \\n        //Iterate through words and insert them into a HashSet\\n        //At each word, check if you have seen it\\'s reverse\\n        Set<String> wordSet = new HashSet<>();\\n        \\n        for(String word : words) {\\n            StringBuilder sb = new StringBuilder(word);\\n            String reversedWord = sb.reverse().toString();\\n            \\n            //We have seen the reverse here, so we increment a pair has been found\\n\\t\\t\\t//contains() check is O(1) runtime\\n            if(wordSet.contains(reversedWord)) {\\n                maxPairs++;\\n            }\\n            \\n            //Always add a word that we have run across\\n            wordSet.add(word);\\n        }\\n        \\n        return maxPairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677535,
                "title": "map-c-most-simple-easy-to-understand",
                "content": "# if this code helps you, please upvote\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int ans = 0;\\n        unordered_map<string,int> mp;\\n        string s;\\n        for(auto &i: words){\\n            s = i;\\n            reverse(s.begin(),s.end());\\n            if(mp.count(s)){\\n                ans++;\\n                mp.erase(i);\\n            }else{\\n                mp[i]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int ans = 0;\\n        unordered_map<string,int> mp;\\n        string s;\\n        for(auto &i: words){\\n            s = i;\\n            reverse(s.begin(),s.end());\\n            if(mp.count(s)){\\n                ans++;\\n                mp.erase(i);\\n            }else{\\n                mp[i]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678773,
                "title": "1-line-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        return len(words)-len({f\"{sorted(i)}\" for i in words})\\n        \\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        return len(words)-len({f\"{sorted(i)}\" for i in words})\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677874,
                "title": "c-brute-force-set-solution-2-solution",
                "content": "# Intuition\\nThink of reverse the each words of the given string and check if the reverse words available or not.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\n1. *Brute Force:* **O(n^2)**\\n2. *Set:* **O(n)**\\n\\n- Space complexity:**O(n)**\\n\\n---\\n\\n\\n**Solution 1 - Brute Force**\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> rev;\\n        for(int i=0;i<n;i++)\\n        {\\n            string str = words[i];\\n            reverse(str.begin(),str.end());\\n            rev.push_back(str);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(words[i] == rev[j] && i!=j)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans/2;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n**Solution 2 - Set**\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> s;\\n        int r = 0;\\n        for (string &word : words) {\\n            sort(word.begin(), word.end());\\n            r += !s.insert(word).second;\\n        }\\n        return r;  \\n    }\\n};\\n```\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/970e1476-e7e6-4150-8f2c-33d33fac059f_1687626500.9282358.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> rev;\\n        for(int i=0;i<n;i++)\\n        {\\n            string str = words[i];\\n            reverse(str.begin(),str.end());\\n            rev.push_back(str);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(words[i] == rev[j] && i!=j)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans/2;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> s;\\n        int r = 0;\\n        for (string &word : words) {\\n            sort(word.begin(), word.end());\\n            r += !s.insert(word).second;\\n        }\\n        return r;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677526,
                "title": "simple-short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String s : words) {\\n            String rev = new StringBuilder(s).reverse().toString();\\n            if(map.containsKey(rev))    map.put(rev, map.get(rev)+1);\\n            else    map.put(s,0);\\n        }\\n        int ans = 0;\\n        for(int value : map.values())   ans += value;\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String s : words) {\\n            String rev = new StringBuilder(s).reverse().toString();\\n            if(map.containsKey(rev))    map.put(rev, map.get(rev)+1);\\n            else    map.put(s,0);\\n        }\\n        int ans = 0;\\n        for(int value : map.values())   ans += value;\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917802,
                "title": "finding-maximum-number-of-string-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWHEN I SEE THIS PROBLEM: Find Maximum Number of (String Pairs)\\n![image.png](https://assets.leetcode.com/users/images/da4fa02d-8240-425d-9ee7-93b95966a1ed_1692186832.7186623.png)\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        ArrayList<String> obj=new  ArrayList<String>();\\n        Collections.addAll(obj,words);\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            String str=words[i];\\n            int n=str.length();\\n            String ktr=\"\";\\n            //REVERSE\\n            for(int k=0;k<n;k++){\\n                ktr=str.charAt(k)+ktr;\\n            }\\n            //REMOVE ELEMENTS LIKE \"ZZ\",\"aa\"\\n            if(ktr.equals(str)){\\n                 obj.remove(ktr);\\n            }\\n             //REMOVE ELEMENTS IF PRESENT IN ARRAY LIST\\n            if(obj.contains(ktr)){\\n                obj.remove(str); \\n                count++;\\n            }\\n            \\n         \\n          \\n        }\\n        \\n        return count;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        ArrayList<String> obj=new  ArrayList<String>();\\n        Collections.addAll(obj,words);\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            String str=words[i];\\n            int n=str.length();\\n            String ktr=\"\";\\n            //REVERSE\\n            for(int k=0;k<n;k++){\\n                ktr=str.charAt(k)+ktr;\\n            }\\n            //REMOVE ELEMENTS LIKE \"ZZ\",\"aa\"\\n            if(ktr.equals(str)){\\n                 obj.remove(ktr);\\n            }\\n             //REMOVE ELEMENTS IF PRESENT IN ARRAY LIST\\n            if(obj.contains(ktr)){\\n                obj.remove(str); \\n                count++;\\n            }\\n            \\n         \\n          \\n        }\\n        \\n        return count;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786951,
                "title": "2-c-solutions-using-hash-map-and-hash-set-approach-beats-100",
                "content": "# Code\\n```\\n// Soution 1 (HashMap)\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        int ans = 0;\\n        for(auto i : words){\\n            string rev = i;\\n            reverse(rev.begin(), rev.end());\\n            if(mp[rev] > 0)\\n                ans++, mp[rev]--;\\n            else\\n                mp[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 2 (Using HashSet, beats 100%)\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> s;\\n        int ans = 0;\\n        for(auto i : words){\\n            string rev = i;\\n            reverse(rev.begin(), rev.end());\\n            if(s.find(rev) == s.end())\\n                s.insert(i);\\n            else\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n// Soution 1 (HashMap)\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        int ans = 0;\\n        for(auto i : words){\\n            string rev = i;\\n            reverse(rev.begin(), rev.end());\\n            if(mp[rev] > 0)\\n                ans++, mp[rev]--;\\n            else\\n                mp[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 2 (Using HashSet, beats 100%)\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> s;\\n        int ans = 0;\\n        for(auto i : words){\\n            string rev = i;\\n            reverse(rev.begin(), rev.end());\\n            if(s.find(rev) == s.end())\\n                s.insert(i);\\n            else\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688778,
                "title": "most-easy-c-ode",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                string a=words[i];\\n                string b=words[j];\\n                reverse(b.begin(),b.end());\\n                if(a==b)\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                string a=words[i];\\n                string b=words[j];\\n                reverse(b.begin(),b.end());\\n                if(a==b)\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686613,
                "title": "string-pairs-javascript-beats-99-46-56-ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/5387b061-43d8-4eb2-ad68-62c894a3d6f3_1687823172.9767308.png)\\n\\n1. Solution with two for loops\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    count = 0 \\n\\n    for (let i = 0; i < words.length; i++) \\n        for (let j = i + 1; j < words.length; j++) \\n            if (words[i][0] == words[j][1])\\n                if (words[i][1] == words[j][0])\\n                    count ++            \\n           \\n    return count\\n};\\n```\\n2. Solution with Hash Table\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    count = 0 \\n    obj = {}\\n    \\n    for (word of words) {\\n        reverse = word[1] + word[0]        \\n\\n        if (obj[reverse] == true) count ++\\n\\n        obj[word] = true        \\n    }    \\n    \\n    return count\\n};\\n```\\nPlease put likes, leave comments, share my solution, I try to find the best solutions)",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    count = 0 \\n\\n    for (let i = 0; i < words.length; i++) \\n        for (let j = i + 1; j < words.length; j++) \\n            if (words[i][0] == words[j][1])\\n                if (words[i][1] == words[j][0])\\n                    count ++            \\n           \\n    return count\\n};\\n```\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    count = 0 \\n    obj = {}\\n    \\n    for (word of words) {\\n        reverse = word[1] + word[0]        \\n\\n        if (obj[reverse] == true) count ++\\n\\n        obj[word] = true        \\n    }    \\n    \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678859,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        ans = 0\\n        for i in range(len(words)):\\n            for j in range(i+1, len(words)):\\n                if words[i][0] == words[j][1] and words[i][1] == words[j][0]:\\n                    ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        ans = 0\\n        for i in range(len(words)):\\n            for j in range(i+1, len(words)):\\n                if words[i][0] == words[j][1] and words[i][1] == words[j][0]:\\n                    ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677771,
                "title": "easy-bruteforce",
                "content": "```\\nclass Solution {\\n    public static int maximumNumberOfStringPairs(String[] words) {\\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].equals(reverse(words[j]))){\\n                   // System.out.println(words[i]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public static String  reverse(String str) {\\n        String ans=\"\";\\n        ans+=str.charAt(1);\\n        ans+=str.charAt(0);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public static int maximumNumberOfStringPairs(String[] words) {\\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].equals(reverse(words[j]))){\\n                   // System.out.println(words[i]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public static String  reverse(String str) {\\n        String ans=\"\";\\n        ans+=str.charAt(1);\\n        ans+=str.charAt(0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677520,
                "title": "javascript-simple-solution-with-explanation",
                "content": "# Approach\\n\\n1. Initialize `maxPairs` to keep track of the maximum number of pairs\\n2. Initialize `wordSet` to track words that can potentially form pairs\\n3. Iterate through the words:\\n    - sort the word lexicographically\\n    - checks if it is in `wordSet`\\n    - if found, a pair is formed, increment `maxPairs` and remove the word from the set\\n    - otherwise, add the word to the set\\n4. Return `maxPairs`\\n\\n# Complexity\\n\\n- Time Complexity: `O(n)` - It iterates through the array once.\\n- Space Complexity: `O(n)` - In the worst case, all words could be added to the set.\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst maximumNumberOfStringPairs = function (words) {\\n  let maxPairs = 0;\\n  const wordSet = new Set();\\n\\n  for (let i = 0; i < words.length; i++) {\\n    const w = words[i][0] > words[i][1] \\n      ? words[i][1] + words[i][0] \\n      : words[i];\\n\\n    if (wordSet.has(w)) {\\n      maxPairs++;\\n      wordSet.delete(w);\\n    } else {\\n      wordSet.add(w);\\n    }\\n  }\\n  return maxPairs;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst maximumNumberOfStringPairs = function (words) {\\n  let maxPairs = 0;\\n  const wordSet = new Set();\\n\\n  for (let i = 0; i < words.length; i++) {\\n    const w = words[i][0] > words[i][1] \\n      ? words[i][1] + words[i][0] \\n      : words[i];\\n\\n    if (wordSet.has(w)) {\\n      maxPairs++;\\n      wordSet.delete(w);\\n    } else {\\n      wordSet.add(w);\\n    }\\n  }\\n  return maxPairs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048840,
                "title": "find-maximum-number-of-string-pairs-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Unordered map\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, string> mp;\\n        int i, count=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            string str = words[i];\\n            reverse(str.begin(), str.end());\\n            if(mp.find(str)!=mp.end())\\n            {\\n                mp[str] = words[i];\\n                count++;\\n            }\\n            else\\n            {\\n                mp[words[i]] = \"\";\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/0933a2a5-9a92-4f43-a9a0-46eeda81e2b2_1694801285.4025972.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, string> mp;\\n        int i, count=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            string str = words[i];\\n            reverse(str.begin(), str.end());\\n            if(mp.find(str)!=mp.end())\\n            {\\n                mp[str] = words[i];\\n                count++;\\n            }\\n            else\\n            {\\n                mp[words[i]] = \"\";\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956301,
                "title": "easy-java-solution-beats-100",
                "content": "We can use a nested for-loop to iterate through our \\'words\\' array and compare any two words in our array without worrying about it being counted as a duplicate (because the second for loop starts at \\'i+1\\' to ensure it can not be compared again). \\n    We can make use of String\\'s charAt function to compare the characters. Since we are dealing with Strings of length 2, we can use charAt to compare the 1st character of one word with the 2nd character of the other word (We cannot use String.reverse or any similar functionality because Strings are not mutable in Java). If the comparison works, increment the pairs variable and return it at the end of the nested for loop.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int pairs = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = i + 1; j < words.length; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) {\\n                    pairs++;\\n                }\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int pairs = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = i + 1; j < words.length; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) {\\n                    pairs++;\\n                }\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949732,
                "title": "beats-95-59-64-74-the-most-simple-js-solution",
                "content": "```\\nvar maximumNumberOfStringPairs = function(words) {\\n    const set = new Set()\\n    let cnt = 0\\n    \\n    for (let word of words) {\\n        if (set.has(word.split(\\'\\').reverse().join(\\'\\'))) cnt++\\n        \\n        set.add(word)\\n    }\\n    \\n    return cnt\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumNumberOfStringPairs = function(words) {\\n    const set = new Set()\\n    let cnt = 0\\n    \\n    for (let word of words) {\\n        if (set.has(word.split(\\'\\').reverse().join(\\'\\'))) cnt++\\n        \\n        set.add(word)\\n    }\\n    \\n    return cnt\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3874241,
                "title": "simple-solution-using-hash-map-easy-to-understand-for-beginners-beats-about-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n![Screenshot from 2023-08-07 07-01-17.png](https://assets.leetcode.com/users/images/7258eb3a-f009-4df7-a514-c0ecc1501da6_1691373718.0283215.png)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        from collections import defaultdict\\n        dict_ = defaultdict(int)\\n        for i,word in enumerate(words):\\n            dict_[word[::-1]] = i\\n        pairs = 0\\n        extra = []\\n        for i,element in enumerate(words):\\n            if element in dict_ and dict_[element] != i and element not in extra:\\n                pairs += 1\\n                extra.append(element[::-1])\\n            else:\\n                continue\\n        return pairs\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        from collections import defaultdict\\n        dict_ = defaultdict(int)\\n        for i,word in enumerate(words):\\n            dict_[word[::-1]] = i\\n        pairs = 0\\n        extra = []\\n        for i,element in enumerate(words):\\n            if element in dict_ and dict_[element] != i and element not in extra:\\n                pairs += 1\\n                extra.append(element[::-1])\\n            else:\\n                continue\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851809,
                "title": "java-1ms-run-o-n-mem-o-1-boolean-flags-no-hashmap",
                "content": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        boolean[] found = new boolean[26 * 26];\\n        int pairCount = 0;\\n        for (String s : words) {\\n            if (found[(s.charAt(1) - \\'a\\') * 26 + s.charAt(0) - \\'a\\'])  pairCount++;\\n            found[(s.charAt(0) - \\'a\\') * 26 + s.charAt(1) - \\'a\\'] = true;\\n        }\\n        return pairCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        boolean[] found = new boolean[26 * 26];\\n        int pairCount = 0;\\n        for (String s : words) {\\n            if (found[(s.charAt(1) - \\'a\\') * 26 + s.charAt(0) - \\'a\\'])  pairCount++;\\n            found[(s.charAt(0) - \\'a\\') * 26 + s.charAt(1) - \\'a\\'] = true;\\n        }\\n        return pairCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811281,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words)\\n\\t\\t{\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=words.length;\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n          for(int j = i + 1; j < n; j++)\\n\\t\\t\\t\\t\\t{\\n            if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n\\t\\t\\t\\t\\t\\t{\\n              count++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words)\\n\\t\\t{\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=words.length;\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n          for(int j = i + 1; j < n; j++)\\n\\t\\t\\t\\t\\t{\\n            if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n\\t\\t\\t\\t\\t\\t{\\n              count++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784379,
                "title": "java-easy-solution-without-stringbuilder-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the entire array words count the number of times a word and its reverse is present in the array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor all the words check if the first letter of a word equals the second letter of another word in the array `words`  and vice versa\\n\\n# Complexity\\n- Time complexity: O(n * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769081,
                "title": "easy-c-solution-using-linear-search",
                "content": "# Intuition\\n\\n# Approach\\nBrute Force Solution:\\nUsing two loops firstly reverse the string of words and compare string of entire words.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        string s;\\n        int count = 0;\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                s = words[j];\\n                reverse(s.begin(),s.end());\\n                if(words[i]==s)    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        string s;\\n        int count = 0;\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                s = words[j];\\n                reverse(s.begin(),s.end());\\n                if(words[i]==s)    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763010,
                "title": "one-line-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        return words.count - Set(words.map(Set.init)).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        return words.count - Set(words.map(Set.init)).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762980,
                "title": "simple-php-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @return Integer\\n     */\\n    function maximumNumberOfStringPairs($words) {\\n        //Here we\\'ll keep words as array keys\\n        $hash = [];\\n        $counter = 0;\\n        //for every item in $words\\n        foreach ($words as $value) {\\n            //if $hash has item with key == reverse $value then increment $counter\\n            if ($hash[strrev($value)]) {\\n                $counter++;\\n            } else {\\n                //if item has not pair then just save it in $hash\\n                $hash[$value] = \\'1\\';\\n            }\\n        }\\n        return $counter;\\n    }\\n}\\n```\\n# P.S.\\nUpvote if it helps you)\\n",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @return Integer\\n     */\\n    function maximumNumberOfStringPairs($words) {\\n        //Here we\\'ll keep words as array keys\\n        $hash = [];\\n        $counter = 0;\\n        //for every item in $words\\n        foreach ($words as $value) {\\n            //if $hash has item with key == reverse $value then increment $counter\\n            if ($hash[strrev($value)]) {\\n                $counter++;\\n            } else {\\n                //if item has not pair then just save it in $hash\\n                $hash[$value] = \\'1\\';\\n            }\\n        }\\n        return $counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748429,
                "title": "java-simple-solution-rutime-100-memory-94-with-explanation",
                "content": "# Approach\\n\\n1. Initialize two variables: `n` to store the length of the `words` array and `cnt` to keep track of the count of valid pairs.\\n2. Use nested loops to iterate over all possible pairs of strings in the `words` array. The outer loop variable `i` represents the index of the first word, and the inner loop variable `j` represents the index of the second word.\\n3. Inside the nested loops, check if the first character of `words[i]` is equal to the second character of `words[j]`, and the second character of `words[i]` is equal to the first character of `words[j]`. This condition ensures that the two words can be paired according to the given conditions.\\n4. If the condition is satisfied, increment the `cnt` variable by 1.\\n5. After the loops finish executing, return the final value of `cnt` as the maximum number of pairs that can be formed.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int n = words.length;\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            for(int j = i + 1; j < n; j++)\\n                if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n                        cnt++;\\n                        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int n = words.length;\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            for(int j = i + 1; j < n; j++)\\n                if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n                        cnt++;\\n                        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740459,
                "title": "q2744-accepted-c-hashmap-o-n-easiest-method",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        int count = 0;\\n        unordered_map <string,int> mp;\\n        for(int i=0;i<n;i++){\\n            if(words[i][0] > words[i][1]){\\n                swap(words[i][0],words[i][1]);\\n            }\\n            mp[words[i]]++;\\n        }\\n            \\n        for(auto i : mp)\\n            count += i.second/2;\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        int count = 0;\\n        unordered_map <string,int> mp;\\n        for(int i=0;i<n;i++){\\n            if(words[i][0] > words[i][1]){\\n                swap(words[i][0],words[i][1]);\\n            }\\n            mp[words[i]]++;\\n        }\\n            \\n        for(auto i : mp)\\n            count += i.second/2;\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736558,
                "title": "easy-simple-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n        HashMap<String,Integer> arr = new HashMap<>();\\n\\n        for(int i=0 ;i<words.length;i++){\\n             String r = new StringBuilder(words[i]).reverse().toString();\\n            if(arr.containsKey(r)){\\n                arr.put(r, arr.get(r)+1);\\n            }\\n            else{\\n                arr.put(words[i],0);\\n            }\\n        }\\n\\n        for(int j : arr.values()){\\n            count += j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n        HashMap<String,Integer> arr = new HashMap<>();\\n\\n        for(int i=0 ;i<words.length;i++){\\n             String r = new StringBuilder(words[i]).reverse().toString();\\n            if(arr.containsKey(r)){\\n                arr.put(r, arr.get(r)+1);\\n            }\\n            else{\\n                arr.put(words[i],0);\\n            }\\n        }\\n\\n        for(int j : arr.values()){\\n            count += j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732675,
                "title": "java-2-different-approach-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String>set=new HashSet<>();\\n        for(String s:words){\\n            set.add(s);\\n        }\\n        System.out.println(set);\\n\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            String rev=reverse(words[i]);\\n            set.remove(words[i]);\\n            if(set.contains(rev)){\\n                count++;\\n                set.remove(rev);\\n                \\n            }\\n        }\\n        return count;\\n    }\\n\\n    public String reverse(String temp){\\n        char ch[]=temp.toCharArray();\\n        char cur=ch[0];\\n        ch[0]=ch[1];\\n        ch[1]=cur;\\n        String ans=\"\";\\n        for(int i=0;i<ch.length;i++){\\n            ans+=ch[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String>set=new HashSet<>();\\n        for(String s:words){\\n            set.add(s);\\n        }\\n        System.out.println(set);\\n\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            String rev=reverse(words[i]);\\n            set.remove(words[i]);\\n            if(set.contains(rev)){\\n                count++;\\n                set.remove(rev);\\n                \\n            }\\n        }\\n        return count;\\n    }\\n\\n    public String reverse(String temp){\\n        char ch[]=temp.toCharArray();\\n        char cur=ch[0];\\n        ch[0]=ch[1];\\n        ch[1]=cur;\\n        String ans=\"\";\\n        for(int i=0;i<ch.length;i++){\\n            ans+=ch[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696525,
                "title": "solution-with-shift-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Remove the first `item` from the array `words` and returns that removed `item`;\\n2. Reverce letters in removed `item`;\\n3. Determine whether the array `words` includes a reverce `item` among its entries;\\n4. Repeat until the array `words` has elements.\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst maximumNumberOfStringPairs = (words) => {\\n  let num = 0;\\n  while (words.length) {\\n    let item = words.shift();\\n    item = item[1] + item[0];\\n    if (words.includes(item)) num++;\\n  }\\n  return num;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst maximumNumberOfStringPairs = (words) => {\\n  let num = 0;\\n  while (words.length) {\\n    let item = words.shift();\\n    item = item[1] + item[0];\\n    if (words.includes(item)) num++;\\n  }\\n  return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3693160,
                "title": "java-hashset",
                "content": "# Solution:\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        int cnt = 0;\\n        for (String s : words) {\\n            StringBuilder sb = new StringBuilder(s).reverse();\\n            if (set.contains(sb.toString())) {\\n                cnt++;\\n            } else {\\n                set.add(s);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n### Time complexity: $$O(n^2)$$\\n> Worst case time complexity for lookup in hashset can be $$O(n)$$.\\n### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        int cnt = 0;\\n        for (String s : words) {\\n            StringBuilder sb = new StringBuilder(s).reverse();\\n            if (set.contains(sb.toString())) {\\n                cnt++;\\n            } else {\\n                set.add(s);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692667,
                "title": "python-simple-python-solution-using-hashmap-95-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 52 ms, faster than 95.84% of Python3 online submissions for Find Maximum Number of String Pairs.\\n# Memory Usage: 16.3 MB, less than 77.61% of Python3 online submissions for Find Maximum Number of String Pairs.\\n\\n![image](https://assets.leetcode.com/users/images/a34a2061-717a-4bd4-968e-4184005e17bf_1687949173.33394.png)\\n\\n\\tclass Solution:\\n\\t\\tdef maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\t\\t\\thash_map = {}\\n\\n\\t\\t\\tfor word in words:\\n\\n\\t\\t\\t\\treverse_word = word[::-1]\\n\\n\\t\\t\\t\\tif reverse_word in hash_map:\\n\\t\\t\\t\\t\\thash_map[reverse_word] = hash_map[reverse_word] + 1\\n\\n\\t\\t\\t\\telif word not in hash_map:\\n\\t\\t\\t\\t\\thash_map[word] = 1\\n\\n\\t\\t\\tfor key in hash_map:\\n\\n\\t\\t\\t\\tif hash_map[key] > 1:\\n\\t\\t\\t\\t\\tresult = result + 1\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "class Solution:\\n\\t\\tdef maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\t\\t\\thash_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 3686151,
                "title": "easy-and-understandable-code-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReverse can help\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate the loop\\n2. each and every word reverse\\n3. and check weather they are equal or not\\n4. print result \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j = i+ 1;j<n;j++){\\n                string s1 = words[i];\\n                string s2 = words[j];\\n                reverse(s2.begin(), s2.end());\\n                // cout<<s1<<\" \"<<s2<<endl;\\n                if(s1 == s2){\\n                    ans++;\\n                    // cout<<ans;\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j = i+ 1;j<n;j++){\\n                string s1 = words[i];\\n                string s2 = words[j];\\n                reverse(s2.begin(), s2.end());\\n                // cout<<s1<<\" \"<<s2<<endl;\\n                if(s1 == s2){\\n                    ans++;\\n                    // cout<<ans;\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3685959,
                "title": "easy-one-xd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n\\tst := make(map[string]bool)\\n\\tres := 0\\n\\tfor _, i := range words {\\n\\t\\ts := i\\n\\t\\ti = reverseString(i)\\n\\t\\tif !st[i] {\\n\\t\\t\\tst[s] = true\\n\\t\\t} else {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc reverseString(s string) string {\\n\\trunes := []rune(s)\\n\\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\\n\\t\\trunes[i], runes[j] = runes[j], runes[i]\\n\\t}\\n\\treturn string(runes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n\\tst := make(map[string]bool)\\n\\tres := 0\\n\\tfor _, i := range words {\\n\\t\\ts := i\\n\\t\\ti = reverseString(i)\\n\\t\\tif !st[i] {\\n\\t\\t\\tst[s] = true\\n\\t\\t} else {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc reverseString(s string) string {\\n\\trunes := []rune(s)\\n\\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\\n\\t\\trunes[i], runes[j] = runes[j], runes[i]\\n\\t}\\n\\treturn string(runes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685958,
                "title": "easy-one-xd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n\\tst := make(map[string]bool)\\n\\tres := 0\\n\\tfor _, i := range words {\\n\\t\\ts := i\\n\\t\\ti = reverseString(i)\\n\\t\\tif !st[i] {\\n\\t\\t\\tst[s] = true\\n\\t\\t} else {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc reverseString(s string) string {\\n\\trunes := []rune(s)\\n\\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\\n\\t\\trunes[i], runes[j] = runes[j], runes[i]\\n\\t}\\n\\treturn string(runes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n\\tst := make(map[string]bool)\\n\\tres := 0\\n\\tfor _, i := range words {\\n\\t\\ts := i\\n\\t\\ti = reverseString(i)\\n\\t\\tif !st[i] {\\n\\t\\t\\tst[s] = true\\n\\t\\t} else {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc reverseString(s string) string {\\n\\trunes := []rune(s)\\n\\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\\n\\t\\trunes[i], runes[j] = runes[j], runes[i]\\n\\t}\\n\\treturn string(runes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680958,
                "title": "python-beginner-friendly",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        cnt=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    cnt+=1\\n                    break\\n        return cnt\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        cnt=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    cnt+=1\\n                    break\\n        return cnt\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680928,
                "title": "go-straightforward",
                "content": "```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n    res := 0\\n    h := make(map[string]bool)\\n    for _, w := range words {\\n        if r := fmt.Sprintf(\"%c%c\", w[1], w[0]); h[r] {\\n            res++\\n        } else {\\n            h[w] = true\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n    res := 0\\n    h := make(map[string]bool)\\n    for _, w := range words {\\n        if r := fmt.Sprintf(\"%c%c\", w[1], w[0]); h[r] {\\n            res++\\n        } else {\\n            h[w] = true\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680055,
                "title": "no-map-no-set-using-find-easy-c",
                "content": "# Intuition\\nSimply Pick each words Reverse it and check by using find().\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Dry run the 1st Test Case.\\n- pick the 1st string of the words and reverse it .\\n- Befor finding the reversed string first check either 1st and 2nd letter are same or not (since there is only 2 char) \\n- NOW using find().. we search for str(ie reversed string) in words[]\\n- if found then increase the count \\n- AND Here the important stepwe have to make words[i]=str ?? think u will get if not then....\\n\\n---> because if we futher check we will again reach to element whose reversed is present before ie increase the count 2 times .\\n\\n---> Eg ; 1St TC : [\"cd\",\"ac\",\"dc\",...]  for \"cd\" we get \"dc\" in words[] and again for \"dc\" we get \"cd\" means extra count so replace with reversed(ie str itself) simpply...\\n\\ndry run more .... :)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=words[i];\\n            reverse(str.begin(),str.end());\\n            if(str[0]==str[1]) continue; \\n\\n            auto it = find(words.begin(),words.end(),str);\\n            if(it!=words.end())\\n            {\\n                cnt++;\\n            }\\n            words[i]=str;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=words[i];\\n            reverse(str.begin(),str.end());\\n            if(str[0]==str[1]) continue; \\n\\n            auto it = find(words.begin(),words.end(),str);\\n            if(it!=words.end())\\n            {\\n                cnt++;\\n            }\\n            words[i]=str;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679988,
                "title": "swift-simple-set-self-made-hash-solutions",
                "content": "# Simple Set\\n## Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n$n$ is words count\\n\\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int\\n    {\\n        var wordSet: Set<String> = [], count = 0\\n        for word in words\\n        {\\n            if wordSet.contains(String(word.reversed())) { count += 1 }\\n            else { wordSet.insert(word) }\\n        }\\n        return count\\n    }\\n}\\n```\\n\\n# Custom hash\\n\\nAs the words are constained to have just 2 letters, we can do without the Set with its costly hash calculation. Just use ascii values of two letters, which can produce 26 * 26 = 676 combinations and map these combinations to a bit array.\\nAlso when calculating hash we first bring the word\\'s letters to ascending order. This conveniently ensures that reversals, i.e. pair words that we need to count will have the same hash value.\\n\\n## Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(26^m)$\\n$n$ is words count, m is words letter count (currently 2)\\n\\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int\\n    {\\n        var wordSet: [UInt8] = Array(repeating: 0, count: 26*26/8 + 1)\\n        let a: UInt8 = 97 //asciiValue\\n\\n        func hash(_ word: String) -> Int\\n        {\\n            var chars = Array(word)\\n            if chars[0] > chars[1] { chars.swapAt(0, 1) }\\n            return Int(chars[0].asciiValue! - a) * 26 + Int(chars[1].asciiValue! - a)\\n        }\\n        func contains(_ word: String) -> Bool {\\n            let hashValue = hash(word)\\n            return wordSet[hashValue / 8] & (1 << (hashValue % 8)) != 0\\n        }\\n        func insert(_ word: String) {\\n            let hashValue = hash(word)\\n            wordSet[hashValue / 8] |= (1 << (hashValue % 8))\\n        }\\n        \\n        var count = 0\\n        for word in words\\n        {\\n            if contains(word) { count += 1 }\\n            else { insert(word) }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "Bit Manipulation",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int\\n    {\\n        var wordSet: Set<String> = [], count = 0\\n        for word in words\\n        {\\n            if wordSet.contains(String(word.reversed())) { count += 1 }\\n            else { wordSet.insert(word) }\\n        }\\n        return count\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int\\n    {\\n        var wordSet: [UInt8] = Array(repeating: 0, count: 26*26/8 + 1)\\n        let a: UInt8 = 97 //asciiValue\\n\\n        func hash(_ word: String) -> Int\\n        {\\n            var chars = Array(word)\\n            if chars[0] > chars[1] { chars.swapAt(0, 1) }\\n            return Int(chars[0].asciiValue! - a) * 26 + Int(chars[1].asciiValue! - a)\\n        }\\n        func contains(_ word: String) -> Bool {\\n            let hashValue = hash(word)\\n            return wordSet[hashValue / 8] & (1 << (hashValue % 8)) != 0\\n        }\\n        func insert(_ word: String) {\\n            let hashValue = hash(word)\\n            wordSet[hashValue / 8] |= (1 << (hashValue % 8))\\n        }\\n        \\n        var count = 0\\n        for word in words\\n        {\\n            if contains(word) { count += 1 }\\n            else { insert(word) }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678003,
                "title": "easy-c-solution-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        int cnt = 0;\\n        for(int i=0;i<words.size();i++) {\\n            if(mp.find(words[i]) != mp.end()) {\\n                cnt++;\\n                mp.erase(words[i]);\\n            } else {\\n                swap(words[i][0], words[i][1]);\\n                mp[words[i]]++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        int cnt = 0;\\n        for(int i=0;i<words.size();i++) {\\n            if(mp.find(words[i]) != mp.end()) {\\n                cnt++;\\n                mp.erase(words[i]);\\n            } else {\\n                swap(words[i][0], words[i][1]);\\n                mp[words[i]]++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677778,
                "title": "simple-c-soltion-without-map",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n=words.size();\\n        int cnt=0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            string s=words[i];\\n            for(int j=i+1; j<n; j++){\\n                string t=words[j];\\n                reverse(t.begin(), t.end());\\n                if(t==s && s[0]!=s[1]) cnt++;\\n                \\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n\\'\\'\\'\\n\\n-----------------UPVOTE--------------------",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n=words.size();\\n        int cnt=0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            string s=words[i];\\n            for(int j=i+1; j<n; j++){\\n                string t=words[j];\\n                reverse(t.begin(), t.end());\\n                if(t==s && s[0]!=s[1]) cnt++;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3677673,
                "title": "c-hash-table",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> us;\\n        int res = 0;\\n        for(auto w : words) {\\n            if(us.count(w)) res += 1;\\n            reverse(begin(w), end(w));\\n            us.insert(w);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> us;\\n        int res = 0;\\n        for(auto w : words) {\\n            if(us.count(w)) res += 1;\\n            reverse(begin(w), end(w));\\n            us.insert(w);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677587,
                "title": "using-hashing-easy-commented-code",
                "content": "# Guys consider upvoting! Thanks!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n  = words.size();\\n        unordered_map<string, int> mp;\\n        //add words to the map\\n        for(int i = 0; i < n; i++){\\n            mp[words[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            string temp = words[i];\\n            reverse(temp.begin(), temp.end());\\n            // if reverse is present and is not equal (eg \"zz\")\\n            if(words[i] != temp){\\n                if(mp.count(temp) > 0){\\n                    ans++;\\n                    // reducing the count to remove duplicates\\n                    mp[temp]--;\\n                    mp[words[i]]--;\\n                    // if count is zero we remove it\\n                    if(mp[temp] == 0)\\n                        mp.erase(temp);\\n                    if(mp[words[i]] == 0)\\n                        mp.erase(words[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n  = words.size();\\n        unordered_map<string, int> mp;\\n        //add words to the map\\n        for(int i = 0; i < n; i++){\\n            mp[words[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            string temp = words[i];\\n            reverse(temp.begin(), temp.end());\\n            // if reverse is present and is not equal (eg \"zz\")\\n            if(words[i] != temp){\\n                if(mp.count(temp) > 0){\\n                    ans++;\\n                    // reducing the count to remove duplicates\\n                    mp[temp]--;\\n                    mp[words[i]]--;\\n                    // if count is zero we remove it\\n                    if(mp[temp] == 0)\\n                        mp.erase(temp);\\n                    if(mp[words[i]] == 0)\\n                        mp.erase(words[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677570,
                "title": "c-brute-force-approach",
                "content": "\\t\\tint count = 0;\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            string str = words[i];\\n            \\n            for(int j = i+1; j < words.size(); j++){\\n                string s = words[j];\\n                string st;\\n                reverse(s.begin(),s.end());\\n                \\n                if(str == s){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "\\t\\tint count = 0;\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            string str = words[i];\\n            \\n            for(int j = i+1; j < words.size(); j++){\\n                string s = words[j];\\n                string st;\\n                reverse(s.begin(),s.end());\\n                \\n                if(str == s){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 3677561,
                "title": "easy-easy-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n           for(int j=i+1;j<words.size();j++)\\n           {\\n               string ans=words[j];\\n               reverse(ans.begin(),ans.end());\\n               if(words[i]==ans)\\n               {\\n                   count++;\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n           for(int j=i+1;j<words.size();j++)\\n           {\\n               string ans=words[j];\\n               reverse(ans.begin(),ans.end());\\n               if(words[i]==ans)\\n               {\\n                   count++;\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677558,
                "title": "easy-easy-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n           for(int j=i+1;j<words.size();j++)\\n           {\\n               string ans=words[j];\\n               reverse(ans.begin(),ans.end());\\n               if(words[i]==ans)\\n               {\\n                   count++;\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n           for(int j=i+1;j<words.size();j++)\\n           {\\n               string ans=words[j];\\n               reverse(ans.begin(),ans.end());\\n               if(words[i]==ans)\\n               {\\n                   count++;\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677490,
                "title": "c-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string,bool> mp;\\n        int ans=0;\\n        for(auto ele:words){\\n            string st=ele;\\n            reverse(st.begin(),st.end());\\n            if(mp.find(st) != mp.end()){\\n                ans++;\\n            }\\n            mp[ele]=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string,bool> mp;\\n        int ans=0;\\n        for(auto ele:words){\\n            string st=ele;\\n            reverse(st.begin(),st.end());\\n            if(mp.find(st) != mp.end()){\\n                ans++;\\n            }\\n            mp[ele]=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677486,
                "title": "python-easy-using-of-set",
                "content": "During this beweekly contest leetcode server is down again \\uD83D\\uDE2D\\n\\n```python\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        v = set()\\n        \\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words[j][::-1] and j not in v:\\n                    v.add(j)\\n                    break\\n                    \\n        return len(v)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        v = set()\\n        \\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words[j][::-1] and j not in v:\\n                    v.add(j)\\n                    break\\n                    \\n        return len(v)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087350,
                "title": "c-solution-with-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumNumberOfStringPairs(string[] words) {\\n        Dictionary<string,string> d=new Dictionary<string,string>();\\n        int count=0;\\n        for(int i=0;i<words.Count();i++)\\n        {\\n            if(d.ContainsKey(String.Join(\"\",words[i].ToCharArray().Reverse())))\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                d.Add(words[i],\"*\");\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumNumberOfStringPairs(string[] words) {\\n        Dictionary<string,string> d=new Dictionary<string,string>();\\n        int count=0;\\n        for(int i=0;i<words.Count();i++)\\n        {\\n            if(d.ContainsKey(String.Join(\"\",words[i].ToCharArray().Reverse())))\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                d.Add(words[i],\"*\");\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086228,
                "title": "approach-using-hashmap-and-making-a-new-function-reverse-as-helper-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:2ms 70% faster\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:70% better\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashMap<String,Boolean> map=new HashMap<>(); \\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            String key=words[i];\\n            String keyrev=reverse(key);\\n            if(map.containsKey(keyrev))\\n            count++;\\n            else map.put(key,true);\\n        }\\n        return count;\\n    }\\n\\n    public String reverse(String word)\\n    {\\n        StringBuilder rev=new StringBuilder();\\n        rev.append(word);\\n        rev.reverse();\\n        return rev.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashMap<String,Boolean> map=new HashMap<>(); \\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            String key=words[i];\\n            String keyrev=reverse(key);\\n            if(map.containsKey(keyrev))\\n            count++;\\n            else map.put(key,true);\\n        }\\n        return count;\\n    }\\n\\n    public String reverse(String word)\\n    {\\n        StringBuilder rev=new StringBuilder();\\n        rev.append(word);\\n        rev.reverse();\\n        return rev.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084556,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int c=0;\\n        StringBuilder sb=new StringBuilder();\\n        String w=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n            \\n            if(words[i].charAt(0)==words[j].charAt(1)&&words[i].charAt(1)==words[j].charAt(0))\\n            {\\n                c++;\\n            }\\n                  \\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int c=0;\\n        StringBuilder sb=new StringBuilder();\\n        String w=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n            \\n            if(words[i].charAt(0)==words[j].charAt(1)&&words[i].charAt(1)==words[j].charAt(0))\\n            {\\n                c++;\\n            }\\n                  \\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082084,
                "title": "easy-java-solution-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        for(int i=0; i<words.length; i++){\\n            for(int j=i+1;j<words.length; j++){\\n                String c = new StringBuffer(words[j]).reverse().toString();\\n                if(words[i].equals(c)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        for(int i=0; i<words.length; i++){\\n            for(int j=i+1;j<words.length; j++){\\n                String c = new StringBuffer(words[j]).reverse().toString();\\n                if(words[i].equals(c)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080187,
                "title": "bruteforce",
                "content": "# Intuition\\njust count numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n       int count = 0;\\n        for(int i=0; i<words.length;i++){\\n            for(int j=i+1; j<words.length;j++){\\n                if(Objects.equals(words[i],\"\"+words[j].charAt(1)+words[j].charAt(0))){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n       int count = 0;\\n        for(int i=0; i<words.length;i++){\\n            for(int j=i+1; j<words.length;j++){\\n                if(Objects.equals(words[i],\"\"+words[j].charAt(1)+words[j].charAt(0))){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080063,
                "title": "java-1ms-beats-100-easy-to-understand",
                "content": "# Intuition\\n\\nas the size of the each String in an Array is 2 so we can just use \\n\\nstr.charAt(0)==str.charAt(1) && str.charAt(1)==str.charAt(0)\\n\\nif it was not fixed we can just convert String into StringBuilder and the revese it with the .revese() function and then compare it \\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n         int count=0;\\n        for (int i = 0; i < words.length-1; i++) {\\n\\n            for (int j = i+1; j <words.length ; j++) {\\n\\n\\n                   if (words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0) )\\n                   {\\n                       count++;\\n                       break;\\n                   }\\n\\n\\n            }\\n\\n        }\\nreturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n         int count=0;\\n        for (int i = 0; i < words.length-1; i++) {\\n\\n            for (int j = i+1; j <words.length ; j++) {\\n\\n\\n                   if (words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0) )\\n                   {\\n                       count++;\\n                       break;\\n                   }\\n\\n\\n            }\\n\\n        }\\nreturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079415,
                "title": "easy-solution-using-length",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        s = []\\n        for ch in words :\\n            s.append(\\'\\'.join(sorted(ch)))\\n        return len(words) - len(set(s))\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        s = []\\n        for ch in words :\\n            s.append(\\'\\'.join(sorted(ch)))\\n        return len(words) - len(set(s))\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078531,
                "title": "simple-approach-sort-and-next-compare-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        for(int i = 0; i < words.size(); i++){\\n          sort(words[i].begin(),words[i].end());\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < words.size()-1; i++){\\n          for(int j = i + 1; j < words.size(); j++){\\n            if(words[i] == words[j]){\\n              ans = ans + 1;\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        for(int i = 0; i < words.size(); i++){\\n          sort(words[i].begin(),words[i].end());\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < words.size()-1; i++){\\n          for(int j = i + 1; j < words.size(); j++){\\n            if(words[i] == words[j]){\\n              ans = ans + 1;\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074050,
                "title": "run-time-high-but-easy-to-understand-java-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        String temp=new String();\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n             StringBuilder sb=new StringBuilder(words[i]);\\n             sb.reverse();\\n             temp=sb.toString();\\n             System.out.println(temp);\\n             for(int j=0;j<words.length;j++){\\n                 System.out.println(words[j]);\\n                 if((temp.equals(words[j]))&&(i!=j))\\n                 count++;\\n             }\\n             \\n\\n        }\\n\\n            return count/2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        String temp=new String();\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n             StringBuilder sb=new StringBuilder(words[i]);\\n             sb.reverse();\\n             temp=sb.toString();\\n             System.out.println(temp);\\n             for(int j=0;j<words.length;j++){\\n                 System.out.println(words[j]);\\n                 if((temp.equals(words[j]))&&(i!=j))\\n                 count++;\\n             }\\n             \\n\\n        }\\n\\n            return count/2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072901,
                "title": "100-fast-solution-of-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity\\n- O(N-Square)\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& w) {\\n        int count=0;\\n        int n=w.size();\\n     for(int i=0;i<n;i++){\\n         for(int j=i+1;j<n;j++){\\n             if(w[i][0]==w[j][1] && w[i][1]==w[j][0]){\\n                 count++;\\n             }\\n             }\\n         } \\n     return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& w) {\\n        int count=0;\\n        int n=w.size();\\n     for(int i=0;i<n;i++){\\n         for(int j=i+1;j<n;j++){\\n             if(w[i][0]==w[j][1] && w[i][1]==w[j][0]){\\n                 count++;\\n             }\\n             }\\n         } \\n     return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072399,
                "title": "easiest-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean func(String a, String b){\\n        int n=a.length();\\n        int m=b.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++){\\n            if(a.charAt(i)!=b.charAt(n-1-i))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans=0;\\n        int n=words.length;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(func(words[i],words[j])==true){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean func(String a, String b){\\n        int n=a.length();\\n        int m=b.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++){\\n            if(a.charAt(i)!=b.charAt(n-1-i))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans=0;\\n        int n=words.length;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(func(words[i],words[j])==true){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072183,
                "title": "len-words-words-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)) :\\n                if words[i] == words[j][::-1] and 0 <= i < j < len(words):\\n                    count +=1\\n        return count        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)) :\\n                if words[i] == words[j][::-1] and 0 <= i < j < len(words):\\n                    count +=1\\n        return count        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071898,
                "title": "java-easy-solution-o-n",
                "content": "# Approach\\ngo to each string in words, make a reverse of the string check if that reverse is present in the set or not, if present increase the count by 1, if not then add the the original string into the set, when next time the iterator comes to the reverse of the stored string, it will reverse the string, check it\\'s presence in the set and increase the count by 1\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        Set<String> set = new HashSet<>();\\n\\n        for(String w: words){\\n            StringBuilder str = new StringBuilder(w);\\n            String reverseStr = str.reverse().toString();\\n\\n            if(set.contains(reverseStr))\\n                count++;\\n            \\n            set.add(w);\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        Set<String> set = new HashSet<>();\\n\\n        for(String w: words){\\n            StringBuilder str = new StringBuilder(w);\\n            String reverseStr = str.reverse().toString();\\n\\n            if(set.contains(reverseStr))\\n                count++;\\n            \\n            set.add(w);\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071641,
                "title": "solution-using-while",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        var wordss = words\\n        var count = 0\\n        while wordss.count != 1{\\n            let check = wordss.remove(at: 0)\\n            if wordss.contains(String(check.reversed())) {\\n                print(wordss.first!)\\n                count += 1\\n            }\\n           \\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        var wordss = words\\n        var count = 0\\n        while wordss.count != 1{\\n            let check = wordss.remove(at: 0)\\n            if wordss.contains(String(check.reversed())) {\\n                print(wordss.first!)\\n                count += 1\\n            }\\n           \\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071373,
                "title": "best-solution-in-java-beats-100-in-time-and-99-in-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDone using sliding window approach; eliminating the already checked cases.\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        if(words.length == 1) return 0;\\n        for(int i = 0; i < words.length; i++) {\\n            if(words[i].equals(\"\"))continue;\\n            for(int j = i+1; j < words.length; j++) {\\n                if(words[j].equals(\"\")) continue;\\n                if((words[i].charAt(0) == words[j].charAt(1)) && (words[i].charAt(1) == words[j].charAt(0))) {\\n                    count++;\\n                    words[j] = \"\";\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        if(words.length == 1) return 0;\\n        for(int i = 0; i < words.length; i++) {\\n            if(words[i].equals(\"\"))continue;\\n            for(int j = i+1; j < words.length; j++) {\\n                if(words[j].equals(\"\")) continue;\\n                if((words[i].charAt(0) == words[j].charAt(1)) && (words[i].charAt(1) == words[j].charAt(0))) {\\n                    count++;\\n                    words[j] = \"\";\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071064,
                "title": "easy-code-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070714,
                "title": "python-rust-solutions",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n        words_reversed = [word[::-1] for word in words]\\n        for i in range(len(words) - 1):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words_reversed[j]:\\n                    count += 1\\n        return count\\n```\\n```rust []\\nimpl Solution {\\n    pub fn maximum_number_of_string_pairs(words: Vec<String>) -> i32 {\\n        let len = words.len();\\n        let mut count = 0;\\n        let words_reversed: Vec<String> = words\\n            .iter()\\n            .map(|word| word.chars().rev().collect::<String>())\\n            .collect();\\n        for (i, word) in words.iter().take(len - 1).enumerate() {\\n            for word_reversed in words_reversed.iter().skip(i + 1) {\\n                if word == word_reversed {\\n                    dbg!(word);\\n                    dbg!(word_reversed);\\n                    count += 1\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n        words_reversed = [word[::-1] for word in words]\\n        for i in range(len(words) - 1):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words_reversed[j]:\\n                    count += 1\\n        return count\\n```\n```rust []\\nimpl Solution {\\n    pub fn maximum_number_of_string_pairs(words: Vec<String>) -> i32 {\\n        let len = words.len();\\n        let mut count = 0;\\n        let words_reversed: Vec<String> = words\\n            .iter()\\n            .map(|word| word.chars().rev().collect::<String>())\\n            .collect();\\n        for (i, word) in words.iter().take(len - 1).enumerate() {\\n            for word_reversed in words_reversed.iter().skip(i + 1) {\\n                if word == word_reversed {\\n                    dbg!(word);\\n                    dbg!(word_reversed);\\n                    count += 1\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069560,
                "title": "simple-c-solution",
                "content": "# Intuition\\nnested for loops with if condition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068667,
                "title": "simple-code-that-beats-100",
                "content": "# Intuition\\nthey have given that if same elements exist, they are in pairs. So when you encounter a pair, just increment count and you have your number of pairs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int len=words.length,count=0;\\n        for(int i=0;i<len-1;i++)\\n        {\\n            for(int j=i+1;j<len;j++)\\n            {\\n                if(words[i]==words[j] || (words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0)))\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int len=words.length,count=0;\\n        for(int i=0;i<len-1;i++)\\n        {\\n            for(int j=i+1;j<len;j++)\\n            {\\n                if(words[i]==words[j] || (words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0)))\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068107,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans =0, n = words.length;\\n        List<String> list = new ArrayList<>();\\n        Set<String> set = new HashSet<>();\\n        // for(int i=0;i<n;i++){\\n        //     list.add(words[i]);\\n        // }\\n        for(int i=0;i<n;i++){\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            if(set.contains(sb.reverse().toString())) ans++;\\n            else set.add(words[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans =0, n = words.length;\\n        List<String> list = new ArrayList<>();\\n        Set<String> set = new HashSet<>();\\n        // for(int i=0;i<n;i++){\\n        //     list.add(words[i]);\\n        // }\\n        for(int i=0;i<n;i++){\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            if(set.contains(sb.reverse().toString())) ans++;\\n            else set.add(words[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066435,
                "title": "easy-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i+1: ]:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i+1: ]:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065683,
                "title": "easy-solution-brooos",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n      pairs = 0\\n      seen = set()\\n      for word in words:\\n          if word[::-1] not in seen:\\n             seen.add(word)\\n          else:\\n              pairs += 1\\n              seen.remove(word[::-1])\\n\\n      return pairs\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n      pairs = 0\\n      seen = set()\\n      for word in words:\\n          if word[::-1] not in seen:\\n             seen.add(word)\\n          else:\\n              pairs += 1\\n              seen.remove(word[::-1])\\n\\n      return pairs\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064265,
                "title": "easy-and-understandable-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n    int count=0;\\n        for(int i=0;i<words.size();i++){\\n            string vp=words[i];\\n            reverse(words[i].begin(),words[i].end());\\n            for(int j=i+1;j<words.size();j++){\\n                if(words[i]==words[j]){\\n                    count++;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n\\n   return  count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n    int count=0;\\n        for(int i=0;i<words.size();i++){\\n            string vp=words[i];\\n            reverse(words[i].begin(),words[i].end());\\n            for(int j=i+1;j<words.size();j++){\\n                if(words[i]==words[j]){\\n                    count++;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n\\n   return  count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063849,
                "title": "java-easy-solution-map-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       public int maximumNumberOfStringPairs(String[] words) {\\n        int pairs = 0;\\n        Set<String> wordSet= Arrays.stream(words).collect(Collectors.toSet());\\n        for (int i = 0; i < words.length; i++) {\\n            String currentWord = words[i];\\n            wordSet.remove(currentWord);\\n            // StringBuilder reversedWord = new StringBuilder(currentWord).reverse();\\n            String reversedWordStr = new StringBuilder(currentWord).reverse().toString();\\n            \\n            if (wordSet.contains(reversedWordStr)) {\\n                pairs++;\\n            }\\n        }\\n        \\n        return pairs;\\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n       public int maximumNumberOfStringPairs(String[] words) {\\n        int pairs = 0;\\n        Set<String> wordSet= Arrays.stream(words).collect(Collectors.toSet());\\n        for (int i = 0; i < words.length; i++) {\\n            String currentWord = words[i];\\n            wordSet.remove(currentWord);\\n            // StringBuilder reversedWord = new StringBuilder(currentWord).reverse();\\n            String reversedWordStr = new StringBuilder(currentWord).reverse().toString();\\n            \\n            if (wordSet.contains(reversedWordStr)) {\\n                pairs++;\\n            }\\n        }\\n        \\n        return pairs;\\n    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061162,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) \\n    {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n                StringBuilder st=new StringBuilder();\\n                st.append(words[j]);\\n                st.reverse();\\n                if(st.toString().equals(words[i]))\\n                {\\n                    count++;\\n                }\\n            }\\n        }    \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) \\n    {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n                StringBuilder st=new StringBuilder();\\n                st.append(words[j]);\\n                st.reverse();\\n                if(st.toString().equals(words[i]))\\n                {\\n                    count++;\\n                }\\n            }\\n        }    \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056801,
                "title": "java-beats-100-user",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        int n = words.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        int n = words.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056779,
                "title": "simple-java-1ms-beats-100-runtime-easy-to-understand",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the number of pairs present in the array of strings.\\nWhen two strings are reverse of each other then they are pairs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFollow the steps below to understand the solution:\\n    \\n    1. Find the length of the array.\\n    2. Iterate the outer for-loop from 0 to n-1.\\n    3. Iterate the inner for-loop from i+1 to n-1.\\n    4. Check the conditions.\\n    5. Increment the counter if condition is satisfied.\\n**Follow the code below to understand the solution.**\\n\\n      **If this solution helped you, give it an up-vote to help others** \\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n\\n        //it will count the number of pairs\\n        int count=0;\\n\\n        //find the length of the array.\\n        int n = words.length;\\n\\n        //outer for loop will check ith string.\\n        for(int i=0;i<n;i++)\\n        {\\n            //inner for loop will check jth string.\\n            for(int j=i+1;j<n;j++)\\n            {\\n                //since string are of length 2\\n                //we can apply the following condition.\\n                if(words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0))\\n                {\\n                    //if they are pairs then increment the count.\\n                    count+=1;                   \\n                }\\n            }\\n        }\\n        //finally, return the count variable.\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n\\n        //it will count the number of pairs\\n        int count=0;\\n\\n        //find the length of the array.\\n        int n = words.length;\\n\\n        //outer for loop will check ith string.\\n        for(int i=0;i<n;i++)\\n        {\\n            //inner for loop will check jth string.\\n            for(int j=i+1;j<n;j++)\\n            {\\n                //since string are of length 2\\n                //we can apply the following condition.\\n                if(words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0))\\n                {\\n                    //if they are pairs then increment the count.\\n                    count+=1;                   \\n                }\\n            }\\n        }\\n        //finally, return the count variable.\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056668,
                "title": "java-easy-explanation-time-and-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReverse the word and compare it with the contents in the set\\nIf found increase count.\\nRemove the reverseword from set.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each word, we need to reverse it and compare it with contents of set, if found increase the count and remove the reversed word.\\nElse, add the word.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int count = 0;\\n        for(String word : words){\\n            String reverseWord = new StringBuilder(word).reverse().toString();\\n            if(set.contains(reverseWord)){\\n                count++;\\n                set.remove(reverseWord);\\n            }\\n            else{\\n                set.add(word);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int count = 0;\\n        for(String word : words){\\n            String reverseWord = new StringBuilder(word).reverse().toString();\\n            if(set.contains(reverseWord)){\\n                count++;\\n                set.remove(reverseWord);\\n            }\\n            else{\\n                set.add(word);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055805,
                "title": "one-line-of-javascript-code-with-high-ordered-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    return  words.length - new Set(words.map(e=>e.split(\"\").sort().join(\"\"))).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    return  words.length - new Set(words.map(e=>e.split(\"\").sort().join(\"\"))).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055411,
                "title": "0ms-beats-100-by-memory",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n    ln := len(words)\\n    c:=0\\n    for i :=0;i<ln-1;i++{\\n        for j :=i+1;j<ln;j++{\\n            if words[i][0]==words[j][1] && words[i][1] == words[j][0]{\\n                c++\\n            }\\n        }\\n    }\\n    return c\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n    ln := len(words)\\n    c:=0\\n    for i :=0;i<ln-1;i++{\\n        for j :=i+1;j<ln;j++{\\n            if words[i][0]==words[j][1] && words[i][1] == words[j][0]{\\n                c++\\n            }\\n        }\\n    }\\n    return c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055365,
                "title": "easy-approach-to-find-the-pair-of-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i =0;i < words.length;i++){\\n            String st = new StringBuilder(words[i]).reverse().toString();\\n            for(int j = i+1;j<words.length;j++){\\n               if(st.equals(words[j]))\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i =0;i < words.length;i++){\\n            String st = new StringBuilder(words[i]).reverse().toString();\\n            for(int j = i+1;j<words.length;j++){\\n               if(st.equals(words[j]))\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054193,
                "title": "brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nChecking each word against every other word in words \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        res = 0 \\n\\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words[j] or words[i] == words[j][::-1]:\\n                    res += 1\\n        return res \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        res = 0 \\n\\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words[j] or words[i] == words[j][::-1]:\\n                    res += 1\\n        return res \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053385,
                "title": "simple-solution-java-1ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int count = 0;\\n      int len = words.length;\\n\\n      for (int i = 0; i < len; i++) {\\n        for (int j = i + 1; j < len; j++) {\\n          if (isEqual(words[i], words[j]))\\n            count++;\\n          }\\n      }\\n\\n      return count;\\n    }\\n\\n    public boolean isEqual(String a, String b) {\\n      int j = a.length() - 1;\\n      int x = a.length();\\n\\n      for (int i = 0; i < x; i++) {\\n        if (a.charAt(i) != b.charAt(j))\\n          return false;\\n        j--;\\n      }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int count = 0;\\n      int len = words.length;\\n\\n      for (int i = 0; i < len; i++) {\\n        for (int j = i + 1; j < len; j++) {\\n          if (isEqual(words[i], words[j]))\\n            count++;\\n          }\\n      }\\n\\n      return count;\\n    }\\n\\n    public boolean isEqual(String a, String b) {\\n      int j = a.length() - 1;\\n      int x = a.length();\\n\\n      for (int i = 0; i < x; i++) {\\n        if (a.charAt(i) != b.charAt(j))\\n          return false;\\n        j--;\\n      }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052918,
                "title": "java-beats-100-1ms-and-beats-83-memory",
                "content": "# Here\\'s a breakdown of how the code works:\\n\\n```int count = 0``` Initialize a variable count to keep track of the number of valid pairs of strings.\\n\\n1. The code uses two nested loops to iterate through all pairs of strings in the words array:\\n    - The outer loop iterates from ```i = 0``` to ```i < words.length```.\\n    - The inner loop iterates from ```j = i + 1``` to ```j < words.length```.\\n2. Inside the nested loops, it checks if the first character of the ```i-th string``` \\n\\n- If both conditions are true, it means that the two strings can form a valid pair.\\n\\n3. If the conditions in step 3 are met, increment the count variable by 1, indicating that a valid pair has been found.\\n\\n4. After both loops have finished, the method returns the final value of count, which represents the maximum number of valid pairs of strings in the array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$$O(n^2)$$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$$O(1)$$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].charAt(0)==words[j].charAt(1)&&words[i].charAt(1)==words[j].charAt(0)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```int count = 0```\n```i = 0```\n```i < words.length```\n```j = i + 1```\n```j < words.length```\n```i-th string```\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].charAt(0)==words[j].charAt(1)&&words[i].charAt(1)==words[j].charAt(0)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050583,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        StringBuilder word1;\\n        StringBuilder word2;\\n\\n        for(int i = 0; i < words.length-1; i++){\\n            word1 = new StringBuilder(words[i]);\\n            for(int j = i+1; j < words.length; j++){\\n                word2 = new StringBuilder(words[j]);\\n                if(word1.toString().equals(word2.reverse().toString())){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        StringBuilder word1;\\n        StringBuilder word2;\\n\\n        for(int i = 0; i < words.length-1; i++){\\n            word1 = new StringBuilder(words[i]);\\n            for(int j = i+1; j < words.length; j++){\\n                word2 = new StringBuilder(words[j]);\\n                if(word1.toString().equals(word2.reverse().toString())){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048615,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n        int count = 0; // Initialize the variable to store the answer\\n        int n = v.size(); \\n        // Iterate over all pairs of strings\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                // Check if i-th string is eaqual to reverse of j-th string\\n                if (v[i][0] == v[j][1] && v[i][1] == v[j][0]) {\\n                    count++; // Increment the count of matching pairs\\n                }\\n            }\\n        }\\n        return count; // Return the total number of matching pairs\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n        int count = 0; // Initialize the variable to store the answer\\n        int n = v.size(); \\n        // Iterate over all pairs of strings\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                // Check if i-th string is eaqual to reverse of j-th string\\n                if (v[i][0] == v[j][1] && v[i][1] == v[j][0]) {\\n                    count++; // Increment the count of matching pairs\\n                }\\n            }\\n        }\\n        return count; // Return the total number of matching pairs\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048553,
                "title": "simple-o-n-space-complexity-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        n = len(words)\\n        cnt = 0\\n        d = {}\\n        for i in range(n):\\n            if words[i][::-1] in d:\\n                cnt += 1\\n            else:\\n                d[words[i]] = i\\n\\n        return (cnt)\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        n = len(words)\\n        cnt = 0\\n        d = {}\\n        for i in range(n):\\n            if words[i][::-1] in d:\\n                cnt += 1\\n            else:\\n                d[words[i]] = i\\n\\n        return (cnt)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048357,
                "title": "80-18-beats",
                "content": "> # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        HashSet<String> set=new HashSet<>();\\n        for(String word : words){\\n            if(set.contains(word)){\\n                count++;\\n                set.remove(word);\\n            }\\n            else{\\n                StringBuilder s=new StringBuilder(word);\\n                String s1=s.reverse().toString();\\n                set.add(s1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        HashSet<String> set=new HashSet<>();\\n        for(String word : words){\\n            if(set.contains(word)){\\n                count++;\\n                set.remove(word);\\n            }\\n            else{\\n                StringBuilder s=new StringBuilder(word);\\n                String s1=s.reverse().toString();\\n                set.add(s1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047436,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing string builder\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length;++i){\\n            for(int j=i+1; j<words.length; ++j){\\n                String str = new StringBuilder(words[j]).reverse().toString();\\n                if(words[i].equals(str)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length;++i){\\n            for(int j=i+1; j<words.length; ++j){\\n                String str = new StringBuilder(words[j]).reverse().toString();\\n                if(words[i].equals(str)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046076,
                "title": "o-n-python-beats-98-u-1f60e",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumNumberOfStringPairs(self, words):\\n        # 2744. Find Maximum Number of String Pairs\\n        d = {}\\n        out = 0\\n        for i, word in enumerate(words):\\n            r_word = word[::-1]\\n            if r_word in d:\\n                if d[r_word] == 0:\\n                    out += 1\\n                    d[r_word] = 1\\n                    d[word] = 1\\n            else:\\n                d[word] = 0\\n        return out\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumNumberOfStringPairs(self, words):\\n        # 2744. Find Maximum Number of String Pairs\\n        d = {}\\n        out = 0\\n        for i, word in enumerate(words):\\n            r_word = word[::-1]\\n            if r_word in d:\\n                if d[r_word] == 0:\\n                    out += 1\\n                    d[r_word] = 1\\n                    d[word] = 1\\n            else:\\n                d[word] = 0\\n        return out\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045673,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nint maximumNumberOfStringPairs(char ** words, int wordsSize)\\n{\\n\\n    int pairsCntr   = 0 ;\\n    int i           = 0 ;\\n    int j           = 0 ;\\n    char temp       = 0 ;\\n\\n    for( i = 0; i < wordsSize; i++ )\\n    {\\n\\n        /* Reverse the string */\\n        temp        = words[i][0] ;\\n        words[i][0] = words[i][1] ;\\n        words[i][1] = temp ;\\n\\n        for( j = i+1; j < wordsSize; j++ )\\n        {\\n            if(strcmp(words[i], words[j]) == 0)\\n            {\\n                pairsCntr++ ;\\n            }\\n            else\\n            {\\n                /* Do nothing */\\n            } \\n        }\\n\\n    }\\n\\n    return pairsCntr ;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maximumNumberOfStringPairs(char ** words, int wordsSize)\\n{\\n\\n    int pairsCntr   = 0 ;\\n    int i           = 0 ;\\n    int j           = 0 ;\\n    char temp       = 0 ;\\n\\n    for( i = 0; i < wordsSize; i++ )\\n    {\\n\\n        /* Reverse the string */\\n        temp        = words[i][0] ;\\n        words[i][0] = words[i][1] ;\\n        words[i][1] = temp ;\\n\\n        for( j = i+1; j < wordsSize; j++ )\\n        {\\n            if(strcmp(words[i], words[j]) == 0)\\n            {\\n                pairsCntr++ ;\\n            }\\n            else\\n            {\\n                /* Do nothing */\\n            } \\n        }\\n\\n    }\\n\\n    return pairsCntr ;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045132,
                "title": "2744-find-maximum-number-of-string-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    \\n    public int maximumNumberOfStringPairs(String[] words) {\\n          int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    \\n    public int maximumNumberOfStringPairs(String[] words) {\\n          int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044448,
                "title": "easy-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n       for(auto &i: v){\\n           sort(i.begin(),i.end());\\n       }\\n       // sorted the strings in the vector\\n        sort(v.begin(),v.end());\\n        // sorted the vector itself\\n        int ans = 0;\\n        // count the number of equal pairs\\n        for(int i=0;i<v.size()-1;i++){\\n            if(v[i] == v[i+1]) ans++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n       for(auto &i: v){\\n           sort(i.begin(),i.end());\\n       }\\n       // sorted the strings in the vector\\n        sort(v.begin(),v.end());\\n        // sorted the vector itself\\n        int ans = 0;\\n        // count the number of equal pairs\\n        for(int i=0;i<v.size()-1;i++){\\n            if(v[i] == v[i+1]) ans++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044216,
                "title": "javascript-beats-90-comments",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n// Initialize a variable to keep track of the count of reversed word pairs.\\nlet ans = 0;\\n\\n// Continue the loop as long as there are more than one word in the \\'words\\' array.\\nwhile (words.length > 1) {\\n    // Remove and store the first word from the \\'words\\' array.\\n    let shiftedArr = words.shift();\\n    // Split the word into an array of characters.\\n    let splitString = shiftedArr.split(\\'\\');\\n    // Reverse the characters.\\n    let reversed = splitString.reverse();\\n    // Join the reversed characters back into a string.\\n    reversed = reversed.join(\\'\\');\\n    // Check if the reversed word exists in the remaining words in the \\'words\\' array.\\n    if (words.includes(reversed)) {\\n        // If a reversed word is found, increment the count.\\n        ans++;\\n    }\\n}\\n// Return the count of reversed word pairs.\\nreturn ans;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n// Initialize a variable to keep track of the count of reversed word pairs.\\nlet ans = 0;\\n\\n// Continue the loop as long as there are more than one word in the \\'words\\' array.\\nwhile (words.length > 1) {\\n    // Remove and store the first word from the \\'words\\' array.\\n    let shiftedArr = words.shift();\\n    // Split the word into an array of characters.\\n    let splitString = shiftedArr.split(\\'\\');\\n    // Reverse the characters.\\n    let reversed = splitString.reverse();\\n    // Join the reversed characters back into a string.\\n    reversed = reversed.join(\\'\\');\\n    // Check if the reversed word exists in the remaining words in the \\'words\\' array.\\n    if (words.includes(reversed)) {\\n        // If a reversed word is found, increment the count.\\n        ans++;\\n    }\\n}\\n// Return the count of reversed word pairs.\\nreturn ans;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043267,
                "title": "2ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        \\n      int c=0;\\n        for(int i=0;i<words.length;i++){\\n             StringBuilder s=new StringBuilder(words[i]);\\n             String ans=(s.reverse()).toString();\\n           for(int j=i+1;j<words.length;j++){\\n             if(ans.equals(words[j])){\\n                 c++;\\n             }             \\n           }\\n           \\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        \\n      int c=0;\\n        for(int i=0;i<words.length;i++){\\n             StringBuilder s=new StringBuilder(words[i]);\\n             String ans=(s.reverse()).toString();\\n           for(int j=i+1;j<words.length;j++){\\n             if(ans.equals(words[j])){\\n                 c++;\\n             }             \\n           }\\n           \\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039720,
                "title": "easy-python-solution-stepwise-explained-python",
                "content": "# EASY PYTHON SOLUTION || STEPWISE EXPLAINED || PYTHON \\u270C\\u270C\\n\\n# Runtime\\n- 51ms\\n- Beats 82.16%of users with Python3\\n# Memory\\n- 16.09MB\\n- Beats 99.58%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        revSet = set()\\n        count = 0\\n\\n        for word in words:\\n            #print(word,word[::-1])\\n            revWord = word[::-1]\\n    \\n            if revWord in revSet:\\n                #print(\\'if run\\')\\n                revSet.remove(revWord)\\n                count+=1\\n                #print(count)\\n            else:\\n                #print(\\'else run\\')\\n                revSet.add(word)\\n\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        revSet = set()\\n        count = 0\\n\\n        for word in words:\\n            #print(word,word[::-1])\\n            revWord = word[::-1]\\n    \\n            if revWord in revSet:\\n                #print(\\'if run\\')\\n                revSet.remove(revWord)\\n                count+=1\\n                #print(count)\\n            else:\\n                #print(\\'else run\\')\\n                revSet.add(word)\\n\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037954,
                "title": "easy-java-solution-without-stringbuilder-and-hash-map",
                "content": "# Intuition\\nThe size of words[i]==2 i.e constant so we can operate statically on it, so the problem lies on array of string.\\n\\n# Approach\\nwe will iterate through array and compare the i+1 index then statically work with the words[i] value.\\n\\n# Complexity\\n- Time complexity:\\nTC: O(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSC: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length-1;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].charAt(0)==words[j].charAt(1) &&words[j].charAt(0)==words[i].charAt(1) )\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length-1;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].charAt(0)==words[j].charAt(1) &&words[j].charAt(0)==words[i].charAt(1) )\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036201,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i+1:]:\\n                count += 1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i+1:]:\\n                count += 1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035945,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int len = words.length;\\n        int temp[] = new int[5530];\\n        int count = 0;\\n        for(int i = 0; i < len; i++){\\n            int temp1 = words[i].charAt(0) - \\'a\\';\\n            int temp2 = words[i].charAt(1) - \\'a\\'; \\n            int ind = (temp1 + temp2) * 100 + Math.abs(temp1 - temp2);\\n            if(temp[ind] != 0){\\n                count++;\\n            }\\n            temp[ind]++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int len = words.length;\\n        int temp[] = new int[5530];\\n        int count = 0;\\n        for(int i = 0; i < len; i++){\\n            int temp1 = words[i].charAt(0) - \\'a\\';\\n            int temp2 = words[i].charAt(1) - \\'a\\'; \\n            int ind = (temp1 + temp2) * 100 + Math.abs(temp1 - temp2);\\n            if(temp[ind] != 0){\\n                count++;\\n            }\\n            temp[ind]++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035872,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nfunc maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n    guard words.count > 1 else {return 0}\\n    var sum = 0\\n    \\n    for i in 0...words.count - 2 {\\n        for j in i + 1..<words.count {\\n            if words[i] == String(words[j].reversed()){\\n                sum += 1\\n            }\\n        }\\n    }\\n    \\n    return sum\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\nfunc maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n    guard words.count > 1 else {return 0}\\n    var sum = 0\\n    \\n    for i in 0...words.count - 2 {\\n        for j in i + 1..<words.count {\\n            if words[i] == String(words[j].reversed()){\\n                sum += 1\\n            }\\n        }\\n    }\\n    \\n    return sum\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035434,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let count=0;\\n    for(let i=0;i<words.length;i++){\\n        for(let j=i+1;j<words.length;j++){\\n            let temp=words[j].split(\"\").reverse().join(\"\");\\n            if(words[i]===temp)\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let count=0;\\n    for(let i=0;i<words.length;i++){\\n        for(let j=i+1;j<words.length;j++){\\n            let temp=words[j].split(\"\").reverse().join(\"\");\\n            if(words[i]===temp)\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034793,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int maximumNumberOfStringPairs(String[] words) {\\n\\t\\tSet<String> set = new HashSet<>();\\n\\t\\tint count = 0;\\n\\t\\tfor (String st : words) {\\n\\t\\t\\tif(!set.contains(st)) {\\n\\t\\t\\t\\tString str = new StringBuilder(st).reverse().toString();\\n\\t\\t\\t\\tset.add(str);\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int maximumNumberOfStringPairs(String[] words) {\\n\\t\\tSet<String> set = new HashSet<>();\\n\\t\\tint count = 0;\\n\\t\\tfor (String st : words) {\\n\\t\\t\\tif(!set.contains(st)) {\\n\\t\\t\\t\\tString str = new StringBuilder(st).reverse().toString();\\n\\t\\t\\t\\tset.add(str);\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032343,
                "title": "easy-o-n-using-hashset",
                "content": "# Intuition\\nUSING HashSet for checking target pairs.\\n\\n# Approach\\nPutting sorted string in the hashset will result in getting false when same string is tried being added again. After every false return from set function we increment the count.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int count = 0;\\n\\n        for(String s : words){\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            String sh = new String(arr);\\n            if(!set.add(sh)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int count = 0;\\n\\n        for(String s : words){\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            String sh = new String(arr);\\n            if(!set.add(sh)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031155,
                "title": "php-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @return Integer\\n     */\\n    function maximumNumberOfStringPairs($words) {\\n        $result = 0;\\n        $map = [];\\n\\n        foreach($words as $word) {\\n            if (isset($map[strrev($word)])) {\\n                $result++;\\n            } else {\\n                $map[$word] = true;\\n            }\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @return Integer\\n     */\\n    function maximumNumberOfStringPairs($words) {\\n        $result = 0;\\n        $map = [];\\n\\n        foreach($words as $word) {\\n            if (isset($map[strrev($word)])) {\\n                $result++;\\n            } else {\\n                $map[$word] = true;\\n            }\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030226,
                "title": "using-dictionary-to-optimize-time-complexity-to-o-n",
                "content": "# Intuition\\n\\n\\n# Approach\\nusing dictionary to optimize the solution \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        word_count = {}\\n        count = 0\\n\\n        for word in words:\\n            if word in word_count:\\n                count += word_count[word]\\n            reversed_word = word[::-1]\\n            if reversed_word in word_count:\\n                count += word_count[reversed_word]\\n            \\n            if word in word_count:\\n                word_count[word] += 1\\n            else:\\n                word_count[word] = 1\\n        \\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        word_count = {}\\n        count = 0\\n\\n        for word in words:\\n            if word in word_count:\\n                count += word_count[word]\\n            reversed_word = word[::-1]\\n            if reversed_word in word_count:\\n                count += word_count[reversed_word]\\n            \\n            if word in word_count:\\n                word_count[word] += 1\\n            else:\\n                word_count[word] = 1\\n        \\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028936,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Set<String> bag = new HashSet<>();\\n        int count = 0;\\n        for(String word: words){\\n            StringBuilder rev = new StringBuilder(word);\\n            rev.reverse();\\n            if(bag.contains(rev.toString())){\\n                ++count;\\n            }else{\\n                bag.add(word);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Set<String> bag = new HashSet<>();\\n        int count = 0;\\n        for(String word: words){\\n            StringBuilder rev = new StringBuilder(word);\\n            rev.reverse();\\n            if(bag.contains(rev.toString())){\\n                ++count;\\n            }else{\\n                bag.add(word);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027996,
                "title": "c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n\\n        int count=0; \\n\\n        for (int i=0;i<words.size();i++){\\n            string str1 = words[i];\\n\\n            for(int j=i+1;j<words.size();j++){\\n                string str2 = words[j];\\n\\n                if(str1[0]==str2[1] && str1[1]==str2[0]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n\\n        int count=0; \\n\\n        for (int i=0;i<words.size();i++){\\n            string str1 = words[i];\\n\\n            for(int j=i+1;j<words.size();j++){\\n                string str2 = words[j];\\n\\n                if(str1[0]==str2[1] && str1[1]==str2[0]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026884,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n     public static String Reverse(String str)\\n        {\\n            char[] strChar = str.ToCharArray();\\n            Array.Reverse(strChar);\\n            String rev = new string(strChar);\\n            return rev;\\n        }\\n    public int MaximumNumberOfStringPairs(string[] s) {\\n         int count = 0;\\n            for(int i=0;i< s.Length; i++)\\n            {\\n               for(int j=0;j<s.Length;j++)\\n                {\\n                    if (s[i].Contains(Reverse(s[j])) && i>j)\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n     public static String Reverse(String str)\\n        {\\n            char[] strChar = str.ToCharArray();\\n            Array.Reverse(strChar);\\n            String rev = new string(strChar);\\n            return rev;\\n        }\\n    public int MaximumNumberOfStringPairs(string[] s) {\\n         int count = 0;\\n            for(int i=0;i< s.Length; i++)\\n            {\\n               for(int j=0;j<s.Length;j++)\\n                {\\n                    if (s[i].Contains(Reverse(s[j])) && i>j)\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026048,
                "title": "python-easy-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i + 1:]:\\n                count += 1\\n        \\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i + 1:]:\\n                count += 1\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020378,
                "title": "easy-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n          int count = 0;\\n\\t        for(String word: words) {\\n\\t        \\tStringBuilder resultword = new StringBuilder(word);\\n\\t        \\tString reversedWord = resultword.reverse().toString();\\n\\t        \\tif(Arrays.asList(words).indexOf(reversedWord) !=-1 && !word.equals(reversedWord)){\\n\\t        \\t\\tcount++;\\n\\t        \\t\\t}\\n\\t        }\\n\\t        return count/2;\\n\\t    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n          int count = 0;\\n\\t        for(String word: words) {\\n\\t        \\tStringBuilder resultword = new StringBuilder(word);\\n\\t        \\tString reversedWord = resultword.reverse().toString();\\n\\t        \\tif(Arrays.asList(words).indexOf(reversedWord) !=-1 && !word.equals(reversedWord)){\\n\\t        \\t\\tcount++;\\n\\t        \\t\\t}\\n\\t        }\\n\\t        return count/2;\\n\\t    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019759,
                "title": "swift-0-n-solution-ez-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(N\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N\\n# Code\\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        var unique: Set<String> = []\\n        var count = 0\\n        for i in words {\\n            if unique.contains(i) || unique.contains(String(i.reversed())) {\\n                count += 1\\n            }\\n            unique.insert(i)\\n        }\\n        return count \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        var unique: Set<String> = []\\n        var count = 0\\n        for i in words {\\n            if unique.contains(i) || unique.contains(String(i.reversed())) {\\n                count += 1\\n            }\\n            unique.insert(i)\\n        }\\n        return count \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014775,
                "title": "javascript-map",
                "content": "# Code\\n```\\nvar maximumNumberOfStringPairs = function(words) {\\n    const map = {}\\n    const rev = (w) => w.split(\\'\\').reverse().join(\\'\\');\\n    for (let i = 0; i < words.length; i++) {\\n        map[words[i]] = i;\\n    }\\n    let res = 0;\\n    for (let i = 0; i < words.length; i++) {\\n        let r = rev(words[i]);\\n        if (map[r] >= 0 && map[r] !== i) res++\\n        delete map[words[i]]\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumNumberOfStringPairs = function(words) {\\n    const map = {}\\n    const rev = (w) => w.split(\\'\\').reverse().join(\\'\\');\\n    for (let i = 0; i < words.length; i++) {\\n        map[words[i]] = i;\\n    }\\n    let res = 0;\\n    for (let i = 0; i < words.length; i++) {\\n        let r = rev(words[i]);\\n        if (map[r] >= 0 && map[r] !== i) res++\\n        delete map[words[i]]\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013349,
                "title": "simply-python-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count=0\\n        for i in range(len(words)):\\n            for j in range(1+i,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    count=count+1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count=0\\n        for i in range(len(words)):\\n            for j in range(1+i,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    count=count+1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012003,
                "title": "best-solution-using-set-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count = 0;\\n        unordered_set <string> s1;\\n        for(auto w : words) {\\n            string org = w;\\n            swap(w[0], w[1]);\\n            if(s1.find(w) != s1.end()) {\\n                count++;\\n            }\\n            s1.insert(org);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count = 0;\\n        unordered_set <string> s1;\\n        for(auto w : words) {\\n            string org = w;\\n            swap(w[0], w[1]);\\n            if(s1.find(w) != s1.end()) {\\n                count++;\\n            }\\n            s1.insert(org);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011066,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        for i in range(len(words)):\\n            words[i] = \"\".join(sorted(words[i]))\\n\\n        d = {}\\n        for i in words:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n\\n        count = 0\\n        for value in d.values():\\n            if value>1:\\n                count += 1\\n\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        for i in range(len(words)):\\n            words[i] = \"\".join(sorted(words[i]))\\n\\n        d = {}\\n        for i in words:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n\\n        count = 0\\n        for value in d.values():\\n            if value>1:\\n                count += 1\\n\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009660,
                "title": "java-solution-100-faster-1ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        boolean[] flag = new boolean[words.length];\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < words.length - 1; i++) {\\n            String word1 = words[i];\\n\\n            for(int j = i + 1; j < words.length; j++){\\n                if(flag[j])\\n                continue;\\n\\n                String word2 = words[j];\\n\\n                if(word1.charAt(0) == word2.charAt(1) && word1.charAt(1) == word2.charAt(0)){\\n                    flag[i] = true;\\n                    flag[j] = true;\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        boolean[] flag = new boolean[words.length];\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < words.length - 1; i++) {\\n            String word1 = words[i];\\n\\n            for(int j = i + 1; j < words.length; j++){\\n                if(flag[j])\\n                continue;\\n\\n                String word2 = words[j];\\n\\n                if(word1.charAt(0) == word2.charAt(1) && word1.charAt(1) == word2.charAt(0)){\\n                    flag[i] = true;\\n                    flag[j] = true;\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008778,
                "title": "java-easy-to-understand",
                "content": "The intuition here is to check if the reversed string is present in the map or not.\\nFor ex:- [\"ab\", \"ba\"]\\n\\nWhen the loops runs on \"ab\", then there is no entry present in the hashmap and the key-value pair is created with key being the string i.e. \"ab\" and the value being the reversed string \"ba\", now when the second iteration of the loop runs for the string \"ba\" then we check if the reverse of the string is present in the map, if present then we increase the count and return it after the loop has completed.\\n\\n\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n\\t\\tint count = 0;\\n\\t\\tMap<String, String> map = new HashMap<>();\\n\\t\\tfor(String word : words) {\\n\\t\\t\\tif(map.get(new StringBuilder(word).reverse().toString()) != null) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(word, new StringBuilder(word).reverse().toString());\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n\\t\\tint count = 0;\\n\\t\\tMap<String, String> map = new HashMap<>();\\n\\t\\tfor(String word : words) {\\n\\t\\t\\tif(map.get(new StringBuilder(word).reverse().toString()) != null) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(word, new StringBuilder(word).reverse().toString());\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006563,
                "title": "c-solution-using-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        map<string,int>mp;\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            reverse(temp.begin(),temp.end());\\n            if(mp[temp]&&i+1>mp[temp]) cnt++;\\n            mp[words[i]]=i+1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        map<string,int>mp;\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            reverse(temp.begin(),temp.end());\\n            if(mp[temp]&&i+1>mp[temp]) cnt++;\\n            mp[words[i]]=i+1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005185,
                "title": "easy-cpp-optimized-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count = 0;\\n        int n = words.size();\\n        unordered_set<string> seen;\\n\\n        for (int i = 0; i < n; i++) {\\n            string word = words[i];\\n            string reversedWord = word;\\n            reverse(reversedWord.begin(), reversedWord.end());\\n\\n            if (seen.count(reversedWord)) {\\n                count++;\\n                seen.erase(reversedWord);\\n            } else {\\n                seen.insert(word);\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count = 0;\\n        int n = words.size();\\n        unordered_set<string> seen;\\n\\n        for (int i = 0; i < n; i++) {\\n            string word = words[i];\\n            string reversedWord = word;\\n            reverse(reversedWord.begin(), reversedWord.end());\\n\\n            if (seen.count(reversedWord)) {\\n                count++;\\n                seen.erase(reversedWord);\\n            } else {\\n                seen.insert(word);\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005163,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001579,
                "title": "c-two-loops-using-sort-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort all the string in the vector and enter two for loop if the element are present in the vector two times or more then increment the result.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting and two for loops\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst case : O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int res = 0;\\n        int n = words.size();\\n        for(auto &it: words){\\n            sort(it.begin(),it.end());\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(words[i] == words[j]){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int res = 0;\\n        int n = words.size();\\n        for(auto &it: words){\\n            sort(it.begin(),it.end());\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(words[i] == words[j]){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001553,
                "title": "c-two-loops-using-sort-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort all the string in the vector and enter two for loop if the element are present in the vector two times or more then increment the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting and two for loops\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst case : O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int res = 0;\\n        int n = words.size();\\n        for(auto &it: words){\\n            sort(it.begin(),it.end());\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(words[i] == words[j]){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int res = 0;\\n        int n = words.size();\\n        for(auto &it: words){\\n            sort(it.begin(),it.end());\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(words[i] == words[j]){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998073,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        StringBuilder str;\\n        int l=words.length;\\n        int p=0;\\n        for(int i=0;i<l;i++){\\n            for(int j=i+1;j<l;j++){\\n                str=new StringBuilder();\\n                str.append(words[j]);\\n                String s=str.reverse().toString();\\n                if(words[i].equals(s))\\n                    p++;\\n            }\\n        }\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        StringBuilder str;\\n        int l=words.length;\\n        int p=0;\\n        for(int i=0;i<l;i++){\\n            for(int j=i+1;j<l;j++){\\n                str=new StringBuilder();\\n                str.append(words[j]);\\n                String s=str.reverse().toString();\\n                if(words[i].equals(s))\\n                    p++;\\n            }\\n        }\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996248,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995941,
                "title": "java-hashmap-solution",
                "content": "# Intuition\\nUse palindrome properties with a hashmap\\n# Approach\\nHashMap + sorting\\n# Complexity\\n- Time complexity:\\nO(N*KlogK), where N - length of an array and K - length of words\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) - HashMap\\n# Code\\n```\\nclass Solution {\\n    private String sortedWord(String w) {\\n        char[] arr = w.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < words.length; i++) {\\n            //System.out.println(sortedWord(words[i]));\\n            String word = sortedWord(words[i]);\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n        int result = 0;\\n        for (Map.Entry<String, Integer> entry: map.entrySet()) {\\n            if (entry.getValue() > 1) result += (entry.getValue() - 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private String sortedWord(String w) {\\n        char[] arr = w.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < words.length; i++) {\\n            //System.out.println(sortedWord(words[i]));\\n            String word = sortedWord(words[i]);\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n        int result = 0;\\n        for (Map.Entry<String, Integer> entry: map.entrySet()) {\\n            if (entry.getValue() > 1) result += (entry.getValue() - 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995901,
                "title": "using-stringbuilder-method-and-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {int a=0;\\n        StringBuilder str=new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                str.append(words[j]);\\n\\n            \\n            if(words[i].equals(str.reverse().toString()))a++;\\n            str.delete(0,str.length());//to input new string\\n        }}\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {int a=0;\\n        StringBuilder str=new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                str.append(words[j]);\\n\\n            \\n            if(words[i].equals(str.reverse().toString()))a++;\\n            str.delete(0,str.length());//to input new string\\n        }}\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990881,
                "title": "optiminal-solution-with-easy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    String reverse(String s1){\\n        StringBuilder s = new StringBuilder();\\n        for(int i=s1.length()-1; i>=0; i--){\\n            s.append(Character.toString(s1.charAt(i)));\\n        }\\n        return s.toString();\\n    }\\n\\n    boolean checksimilar(String s1, String s2){\\n        String rev = reverse(s1);\\n        if(s1.equals(s2) || s2.equals(rev)){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0; i<words.length; i++){\\n            for(int j=i+1; j<words.length; j++){\\n                if(checksimilar(words[i],words[j])){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    String reverse(String s1){\\n        StringBuilder s = new StringBuilder();\\n        for(int i=s1.length()-1; i>=0; i--){\\n            s.append(Character.toString(s1.charAt(i)));\\n        }\\n        return s.toString();\\n    }\\n\\n    boolean checksimilar(String s1, String s2){\\n        String rev = reverse(s1);\\n        if(s1.equals(s2) || s2.equals(rev)){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0; i<words.length; i++){\\n            for(int j=i+1; j<words.length; j++){\\n                if(checksimilar(words[i],words[j])){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989111,
                "title": "99-better-in-time-o-n-time-solution-an-easy-unique-techinque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumNumberOfStringPairs(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        ## Map solution\\n        n=len(words)\\n        mymap={}\\n        count=0\\n        for word in words:\\n           sorted_word = tuple(sorted(word))\\n           if sorted_word not in mymap:\\n             mymap[sorted_word] = 1\\n           else:\\n             mymap[sorted_word] += 1\\n        for key,value in mymap.items():\\n            if value==1 :\\n                continue\\n            while value!=1:\\n                count+=value-1\\n                value-=1\\n        return count\\n\\n            \\n\\n                 \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumNumberOfStringPairs(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        ## Map solution\\n        n=len(words)\\n        mymap={}\\n        count=0\\n        for word in words:\\n           sorted_word = tuple(sorted(word))\\n           if sorted_word not in mymap:\\n             mymap[sorted_word] = 1\\n           else:\\n             mymap[sorted_word] += 1\\n        for key,value in mymap.items():\\n            if value==1 :\\n                continue\\n            while value!=1:\\n                count+=value-1\\n                value-=1\\n        return count\\n\\n            \\n\\n                 \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986004,
                "title": "set-o-1-easy-friendly-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int z=0;\\n        set<string>s;\\n        for(int h=0; h<words.size(); h++){\\n            string f=words[h];\\n            reverse(f.begin(),f.end());\\n            if(f==words[h]) z++;\\n            s.insert(f);\\n            s.insert(words[h]);\\n        }\\n        int g=words.size();\\n        int w=0;\\n        if(z>1){\\n            return (2*g-s.size()-z)/2;\\n    }\\n    \\n    return (2*g-s.size())/2;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int z=0;\\n        set<string>s;\\n        for(int h=0; h<words.size(); h++){\\n            string f=words[h];\\n            reverse(f.begin(),f.end());\\n            if(f==words[h]) z++;\\n            s.insert(f);\\n            s.insert(words[h]);\\n        }\\n        int g=words.size();\\n        int w=0;\\n        if(z>1){\\n            return (2*g-s.size()-z)/2;\\n    }\\n    \\n    return (2*g-s.size())/2;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985668,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& w) {\\n\\n        int ans=0;\\n        for(int i=0;i<w.size();i++){\\n            string t=w[i];\\n            reverse(t.begin(),t.end());\\n            for(int j=i+1;j<w.size();j++){\\n                if(w[j]==t){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& w) {\\n\\n        int ans=0;\\n        for(int i=0;i<w.size();i++){\\n            string t=w[i];\\n            reverse(t.begin(),t.end());\\n            for(int j=i+1;j<w.size();j++){\\n                if(w[j]==t){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984420,
                "title": "easy-to-understand-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy First view of code you might feel like iits O(n^2), but its O(N). Try it once!.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Maintain a visited array on each iteration, so that u wont traverse second loop to search reversed data.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        n = len(words)\\n        visited = [False] * n\\n        count = 0\\n        for i in range(n):\\n            if visited[i] == False and i == n-1:\\n                break\\n            if visited[i] == True:\\n                continue\\n\\n            reversed_word = words[i][::-1]\\n            visited[i] = True\\n            for j in range(i+1, n):\\n                if words[j] == reversed_word:\\n                    visited[j] = True\\n                    count += 1\\n                    break\\n        return count\\n\\n\\n\"\"\"\\ncount = 2\\n\\nvisited =       T       T       T       T       F\\n                0       1       2       3       4\\n\\nwords           cd      ac      dc      ca      zz\\n\\n                        i\\n                                j(dc)\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        n = len(words)\\n        visited = [False] * n\\n        count = 0\\n        for i in range(n):\\n            if visited[i] == False and i == n-1:\\n                break\\n            if visited[i] == True:\\n                continue\\n\\n            reversed_word = words[i][::-1]\\n            visited[i] = True\\n            for j in range(i+1, n):\\n                if words[j] == reversed_word:\\n                    visited[j] = True\\n                    count += 1\\n                    break\\n        return count\\n\\n\\n\"\"\"\\ncount = 2\\n\\nvisited =       T       T       T       T       F\\n                0       1       2       3       4\\n\\nwords           cd      ac      dc      ca      zz\\n\\n                        i\\n                                j(dc)\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983231,
                "title": "world-easiest-solution-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let number =0;\\n    for(let i =0; i<words.length; i++){\\n        for(let j =i+1; j<words.length; j++){\\n            let count = checkstring(words[i], words[j]);\\n            if(count){\\n                number++;\\n            }\\n        }\\n    }\\n    return number;\\n};\\nfunction checkstring(firstString, secString){\\n    console.log(firstString,secString);\\n    for(let i=0, j=secString.length-1; i<firstString.length, j>=0; i++,j--){\\n        // console.log(firstString[i],secString[j]);\\n        if(firstString[i]!=secString[j])\\n        {\\n            // console.log(firstString[i],secString[j]);\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let number =0;\\n    for(let i =0; i<words.length; i++){\\n        for(let j =i+1; j<words.length; j++){\\n            let count = checkstring(words[i], words[j]);\\n            if(count){\\n                number++;\\n            }\\n        }\\n    }\\n    return number;\\n};\\nfunction checkstring(firstString, secString){\\n    console.log(firstString,secString);\\n    for(let i=0, j=secString.length-1; i<firstString.length, j>=0; i++,j--){\\n        // console.log(firstString[i],secString[j]);\\n        if(firstString[i]!=secString[j])\\n        {\\n            // console.log(firstString[i],secString[j]);\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982843,
                "title": "c-fast-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) \\n    {\\n        int count = 0;\\n        for (int i = 0; i < words.size(); i++)\\n        {\\n            for (int j = i + 1; j < words.size(); j++)\\n            {\\n                if (isPair(words[i], words[j]))\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\nprivate:\\n    bool isPair(const std::string& s, const std::string& t)\\n    {\\n        if (s.length() != t.length())\\n            return false;\\n        \\n        int left = 0, right = s.length() - 1;\\n        while (left < s.length())\\n        {\\n            if (s[left] != t[right])\\n                return false;\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) \\n    {\\n        int count = 0;\\n        for (int i = 0; i < words.size(); i++)\\n        {\\n            for (int j = i + 1; j < words.size(); j++)\\n            {\\n                if (isPair(words[i], words[j]))\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\nprivate:\\n    bool isPair(const std::string& s, const std::string& t)\\n    {\\n        if (s.length() != t.length())\\n            return false;\\n        \\n        int left = 0, right = s.length() - 1;\\n        while (left < s.length())\\n        {\\n            if (s[left] != t[right])\\n                return false;\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982571,
                "title": "c-super-easy-approach",
                "content": "# Intuition\\nClassic nested loop problem \\n\\n# Approach\\nWith a simple nested loop, you can access the characters of the string array that is shown below. My approach was not that fast though, I have no idea why. If you have an idea, please comment on why my approach is slower than others. Thanks!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n  public int MaximumNumberOfStringPairs(string[] words) {\\n    int result = 0, len = words.Length;\\n    \\n    for(int i = 0; i < len; i++){\\n      for(int j = i+1; j < len; j++){\\n        if((words[i][0] == words[j][1]) && (words[i][1] == words[j][0])){\\n          result++;\\n        }\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n  public int MaximumNumberOfStringPairs(string[] words) {\\n    int result = 0, len = words.Length;\\n    \\n    for(int i = 0; i < len; i++){\\n      for(int j = i+1; j < len; j++){\\n        if((words[i][0] == words[j][1]) && (words[i][1] == words[j][0])){\\n          result++;\\n        }\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982570,
                "title": "c-super-easy-approach",
                "content": "# Intuition\\nClassic nested loop problem \\n\\n# Approach\\nWith a simple nested loop, you can access the characters of the string array that is shown below. My approach was not that fast though, I have no idea why. If you have an idea, please comment on why my approach is slower than others. Thanks!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n  public int MaximumNumberOfStringPairs(string[] words) {\\n    int result = 0, len = words.Length;\\n    \\n    for(int i = 0; i < len; i++){\\n      for(int j = i+1; j < len; j++){\\n        if((words[i][0] == words[j][1]) && (words[i][1] == words[j][0])){\\n          result++;\\n        }\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n  public int MaximumNumberOfStringPairs(string[] words) {\\n    int result = 0, len = words.Length;\\n    \\n    for(int i = 0; i < len; i++){\\n      for(int j = i+1; j < len; j++){\\n        if((words[i][0] == words[j][1]) && (words[i][1] == words[j][0])){\\n          result++;\\n        }\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979568,
                "title": "just-3-lines-of-code-python",
                "content": "\\n# Complexity\\n- Time complexity: 84.12%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  93.49%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=[]\\n        for i in words:\\n            c+=[\"\".join(sorted(i))]\\n        return len(words)-len(set(c))\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=[]\\n        for i in words:\\n            c+=[\"\".join(sorted(i))]\\n        return len(words)-len(set(c))\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971750,
                "title": "2-easy-ways-to-solve-using-set-sort",
                "content": "# Method 1 : Using Sort Only\\n\\nInitialize an integer variable c to keep track of the count of pairs.\\n\\nLoop through each string in the words vector:\\n\\nFor each string, sort its characters in ascending order. This step essentially standardizes the character order within each string, making it easier to compare strings later.\\nAfter sorting the characters within each string, sort the entire words vector in lexicographically ascending order. This step is done to group together strings that are anagrams (i.e., they can be rearranged to form the same word).\\n\\nLoop through the sorted words vector (up to the second-to-last element):\\n\\nCompare each string with the next one in the vector.\\nIf two consecutive strings are equal, increment the c counter. This means they are anagrams and can form a pair.\\nReturn the final count c of anagram pairs.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int c=0;\\n        for(int i=0;i<words.size();i++){\\n            sort(words[i].begin(),words[i].end());\\n        }\\n        sort(words.begin(),words.end());\\n\\n        for(int i=0;i<words.size()-1;i++){\\n            if(words[i]==words[i+1]){\\n                c+=1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n# Method 2 : Using Set\\nCreate an empty set called ans. The set data structure is being used to store unique strings. This will help identify unique anagram patterns among the words.\\n\\nLoop through each string in the words vector:\\n\\nFor each string, create a copy called s.\\nSort the characters of s in ascending order. This standardizes the character order within each string, making it easier to identify anagrams.\\nInsert the sorted string s into the ans set. The set will automatically take care of removing duplicates, so only unique anagram patterns are stored.\\n\\nAfter processing all the strings, the size of the ans set will represent the number of unique anagram patterns.\\n\\nCalculate the difference between the total number of input words (words.size()) and the number of unique anagram patterns (ans.size()). This difference represents the count of strings that are not part of any anagram pair.\\n\\nReturn this difference as the result.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        set<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            string s = words[i];\\n            sort(s.begin(),s.end());\\n            ans.insert(s);\\n        }\\n        return words.size()-ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int c=0;\\n        for(int i=0;i<words.size();i++){\\n            sort(words[i].begin(),words[i].end());\\n        }\\n        sort(words.begin(),words.end());\\n\\n        for(int i=0;i<words.size()-1;i++){\\n            if(words[i]==words[i+1]){\\n                c+=1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        set<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            string s = words[i];\\n            sort(s.begin(),s.end());\\n            ans.insert(s);\\n        }\\n        return words.size()-ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967258,
                "title": "solution-in-java-with-85-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHasheSet Approach \\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n    \\n        Set<String> set = new HashSet<>();\\n\\n\\n        for(int i=0;i<words.length;i++){\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            sb.reverse();\\n            if(!set.contains(sb.toString())) set.add(words[i]);\\n        }\\n\\n\\n        return words.length-set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n    \\n        Set<String> set = new HashSet<>();\\n\\n\\n        for(int i=0;i<words.length;i++){\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            sb.reverse();\\n            if(!set.contains(sb.toString())) set.add(words[i]);\\n        }\\n\\n\\n        return words.length-set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964730,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        auto result = 0;\\n        unordered_map<string, int> map;\\n        for (auto word : words) {\\n            if (!map.count(word)) reverse(begin(word), end(word));\\n            ++map[word];\\n        }\\n        for (const auto& pair : map)\\n            result += pair.second / 2;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        auto result = 0;\\n        unordered_map<string, int> map;\\n        for (auto word : words) {\\n            if (!map.count(word)) reverse(begin(word), end(word));\\n            ++map[word];\\n        }\\n        for (const auto& pair : map)\\n            result += pair.second / 2;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963462,
                "title": "100-optimezed-java-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int n=words.length;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            String s1=words[i];\\n            for(int j=i+1;j<n;j++){\\n               String s2=words[j];\\n               if(s1.charAt(0)==s2.charAt(1) && s1.charAt(1)==s2.charAt(0)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int n=words.length;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            String s1=words[i];\\n            for(int j=i+1;j<n;j++){\\n               String s2=words[j];\\n               if(s1.charAt(0)==s2.charAt(1) && s1.charAt(1)==s2.charAt(0)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957107,
                "title": "find-maximum-number-of-string-in-pairs",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n     int count = 0;\\n     int len = words.length;\\n\\n      for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len ; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)){\\n                   count++;\\n                }\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n     int count = 0;\\n     int len = words.length;\\n\\n      for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len ; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)){\\n                   count++;\\n                }\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955227,
                "title": "java-easy-solution-string-reversing-100-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n\\t\\tfor(int i=0; i<words.length; i++) \\n\\t\\t\\tfor(int j=i+1; j<words.length; j++) \\n\\t\\t\\t\\tif(reverse(words[i]).equals(words[j])) count++;\\n\\t\\treturn count;\\n    }\\n\\n    public static String reverse(String str) {\\n\\t\\t  return str.isEmpty() ? \"\" : reverse(str.substring(1))+Character.toString(str.charAt(0));\\n\\t  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n\\t\\tfor(int i=0; i<words.length; i++) \\n\\t\\t\\tfor(int j=i+1; j<words.length; j++) \\n\\t\\t\\t\\tif(reverse(words[i]).equals(words[j])) count++;\\n\\t\\treturn count;\\n    }\\n\\n    public static String reverse(String str) {\\n\\t\\t  return str.isEmpty() ? \"\" : reverse(str.substring(1))+Character.toString(str.charAt(0));\\n\\t  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952333,
                "title": "python-dict-beats-98-32",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        d = {}\\n        count = 0\\n        for word in words:\\n            if word[::-1] in d:\\n                count += 1\\n            else:\\n                d[word] = True\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        d = {}\\n        count = 0\\n        for word in words:\\n            if word[::-1] in d:\\n                count += 1\\n            else:\\n                d[word] = True\\n        return count\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1942758,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Optimal solution.\\n\\n# Approach\\n\\n1. Create an empty set called `st` to store unique strings.\\n2. Get the size of the input vector `words` and store it in the variable `n`.\\n3. Initialize a counter variable `count` to keep track of the number of string pairs.\\n4. Iterate over each element in the `words` vector using a loop variable `i`.\\n5. Inside the loop, check if the current index `i` is 0 (first string in the vector).\\n6. If `i` is 0, insert the first string `words[i]` into the set `st`.\\n7. If `i` is not 0, perform the following steps:\\n   a. Create a temporary string `temp` by rotating the current string `words[i]` by one character to the left. This is done by taking a substring of `words[i]` starting from the second character (index 1) and appending the first character (index 0) at the end.\\n   b. Check if the rotated string `temp` exists in the set `st` by using the `find` function. If it does exist, it means a pair can be formed.\\n   c. If `temp` is found in `st`, increment the `count` variable by 1 to keep track of the number of pairs found, and remove `temp` from the set `st` using the `erase` function.\\n   d. If `temp` is not found in `st`, it means a pair cannot be formed at this point. Insert the current string `words[i]` into the set `st`.\\n8. After the loop ends, return the value of `count`, which represents the maximum number of string pairs that can be formed.\\n\\n--------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n- Space complexity:\\nS.C=O(n) set space.\\n------------------------------------\\nPlease Upvote. If Understand the concept.\\nSolution link:\\n https://leetcode.com/problems/find-maximum-number-of-string-pairs/solutions/3678104/c-optimal-solution/"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "brute force method is easy here\\n"
                    },
                    {
                        "username": "negarrrr",
                        "content": "I think test cases are not enough, as I could submit a solution that does not pass such a case: \\nInput: words =[\\'abc\\', \\'bca\\']\\noutput = 0"
                    },
                    {
                        "username": "vinnisnx",
                        "content": "words[i].length == 2"
                    },
                    {
                        "username": "Gabbar_007",
                        "content": "Test cases are not enough. "
                    }
                ]
            },
            {
                "id": 1984362,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Optimal solution.\\n\\n# Approach\\n\\n1. Create an empty set called `st` to store unique strings.\\n2. Get the size of the input vector `words` and store it in the variable `n`.\\n3. Initialize a counter variable `count` to keep track of the number of string pairs.\\n4. Iterate over each element in the `words` vector using a loop variable `i`.\\n5. Inside the loop, check if the current index `i` is 0 (first string in the vector).\\n6. If `i` is 0, insert the first string `words[i]` into the set `st`.\\n7. If `i` is not 0, perform the following steps:\\n   a. Create a temporary string `temp` by rotating the current string `words[i]` by one character to the left. This is done by taking a substring of `words[i]` starting from the second character (index 1) and appending the first character (index 0) at the end.\\n   b. Check if the rotated string `temp` exists in the set `st` by using the `find` function. If it does exist, it means a pair can be formed.\\n   c. If `temp` is found in `st`, increment the `count` variable by 1 to keep track of the number of pairs found, and remove `temp` from the set `st` using the `erase` function.\\n   d. If `temp` is not found in `st`, it means a pair cannot be formed at this point. Insert the current string `words[i]` into the set `st`.\\n8. After the loop ends, return the value of `count`, which represents the maximum number of string pairs that can be formed.\\n\\n--------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n- Space complexity:\\nS.C=O(n) set space.\\n------------------------------------\\nPlease Upvote. If Understand the concept.\\nSolution link:\\n https://leetcode.com/problems/find-maximum-number-of-string-pairs/solutions/3678104/c-optimal-solution/"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "brute force method is easy here\\n"
                    },
                    {
                        "username": "negarrrr",
                        "content": "I think test cases are not enough, as I could submit a solution that does not pass such a case: \\nInput: words =[\\'abc\\', \\'bca\\']\\noutput = 0"
                    },
                    {
                        "username": "vinnisnx",
                        "content": "words[i].length == 2"
                    },
                    {
                        "username": "Gabbar_007",
                        "content": "Test cases are not enough. "
                    }
                ]
            },
            {
                "id": 2000277,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Optimal solution.\\n\\n# Approach\\n\\n1. Create an empty set called `st` to store unique strings.\\n2. Get the size of the input vector `words` and store it in the variable `n`.\\n3. Initialize a counter variable `count` to keep track of the number of string pairs.\\n4. Iterate over each element in the `words` vector using a loop variable `i`.\\n5. Inside the loop, check if the current index `i` is 0 (first string in the vector).\\n6. If `i` is 0, insert the first string `words[i]` into the set `st`.\\n7. If `i` is not 0, perform the following steps:\\n   a. Create a temporary string `temp` by rotating the current string `words[i]` by one character to the left. This is done by taking a substring of `words[i]` starting from the second character (index 1) and appending the first character (index 0) at the end.\\n   b. Check if the rotated string `temp` exists in the set `st` by using the `find` function. If it does exist, it means a pair can be formed.\\n   c. If `temp` is found in `st`, increment the `count` variable by 1 to keep track of the number of pairs found, and remove `temp` from the set `st` using the `erase` function.\\n   d. If `temp` is not found in `st`, it means a pair cannot be formed at this point. Insert the current string `words[i]` into the set `st`.\\n8. After the loop ends, return the value of `count`, which represents the maximum number of string pairs that can be formed.\\n\\n--------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n- Space complexity:\\nS.C=O(n) set space.\\n------------------------------------\\nPlease Upvote. If Understand the concept.\\nSolution link:\\n https://leetcode.com/problems/find-maximum-number-of-string-pairs/solutions/3678104/c-optimal-solution/"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "brute force method is easy here\\n"
                    },
                    {
                        "username": "negarrrr",
                        "content": "I think test cases are not enough, as I could submit a solution that does not pass such a case: \\nInput: words =[\\'abc\\', \\'bca\\']\\noutput = 0"
                    },
                    {
                        "username": "vinnisnx",
                        "content": "words[i].length == 2"
                    },
                    {
                        "username": "Gabbar_007",
                        "content": "Test cases are not enough. "
                    }
                ]
            },
            {
                "id": 2005502,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Optimal solution.\\n\\n# Approach\\n\\n1. Create an empty set called `st` to store unique strings.\\n2. Get the size of the input vector `words` and store it in the variable `n`.\\n3. Initialize a counter variable `count` to keep track of the number of string pairs.\\n4. Iterate over each element in the `words` vector using a loop variable `i`.\\n5. Inside the loop, check if the current index `i` is 0 (first string in the vector).\\n6. If `i` is 0, insert the first string `words[i]` into the set `st`.\\n7. If `i` is not 0, perform the following steps:\\n   a. Create a temporary string `temp` by rotating the current string `words[i]` by one character to the left. This is done by taking a substring of `words[i]` starting from the second character (index 1) and appending the first character (index 0) at the end.\\n   b. Check if the rotated string `temp` exists in the set `st` by using the `find` function. If it does exist, it means a pair can be formed.\\n   c. If `temp` is found in `st`, increment the `count` variable by 1 to keep track of the number of pairs found, and remove `temp` from the set `st` using the `erase` function.\\n   d. If `temp` is not found in `st`, it means a pair cannot be formed at this point. Insert the current string `words[i]` into the set `st`.\\n8. After the loop ends, return the value of `count`, which represents the maximum number of string pairs that can be formed.\\n\\n--------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n- Space complexity:\\nS.C=O(n) set space.\\n------------------------------------\\nPlease Upvote. If Understand the concept.\\nSolution link:\\n https://leetcode.com/problems/find-maximum-number-of-string-pairs/solutions/3678104/c-optimal-solution/"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "brute force method is easy here\\n"
                    },
                    {
                        "username": "negarrrr",
                        "content": "I think test cases are not enough, as I could submit a solution that does not pass such a case: \\nInput: words =[\\'abc\\', \\'bca\\']\\noutput = 0"
                    },
                    {
                        "username": "vinnisnx",
                        "content": "words[i].length == 2"
                    },
                    {
                        "username": "Gabbar_007",
                        "content": "Test cases are not enough. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Construct the Longest New String",
        "question_content": "<p>You are given three integers <code>x</code>, <code>y</code>, and <code>z</code>.</p>\n\n<p>You have <code>x</code> strings equal to <code>&quot;AA&quot;</code>, <code>y</code> strings equal to <code>&quot;BB&quot;</code>, and <code>z</code> strings equal to <code>&quot;AB&quot;</code>. You want to choose some (possibly all or none) of these strings and concactenate them in some order to form a new string. This new string must not contain <code>&quot;AAA&quot;</code> or <code>&quot;BBB&quot;</code> as a substring.</p>\n\n<p>Return <em>the maximum possible length of the new string</em>.</p>\n\n<p>A <b>substring</b> is a contiguous <strong>non-empty</strong> sequence of characters within a string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 2, y = 5, z = 1\n<strong>Output:</strong> 12\n<strong>Explanation: </strong>We can concactenate the strings &quot;BB&quot;, &quot;AA&quot;, &quot;BB&quot;, &quot;AA&quot;, &quot;BB&quot;, and &quot;AB&quot; in that order. Then, our new string is &quot;BBAABBAABBAB&quot;. \nThat string has length 12, and we can show that it is impossible to construct a string of longer length.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 3, y = 2, z = 2\n<strong>Output:</strong> 14\n<strong>Explanation:</strong> We can concactenate the strings &quot;AB&quot;, &quot;AB&quot;, &quot;AA&quot;, &quot;BB&quot;, &quot;AA&quot;, &quot;BB&quot;, and &quot;AA&quot; in that order. Then, our new string is &quot;ABABAABBAABBAA&quot;. \nThat string has length 14, and we can show that it is impossible to construct a string of longer length.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x, y, z &lt;= 50</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3677601,
                "title": "c-java-python-o-1-complexity-with-explanation",
                "content": "# Intution\\n1. There is no requirement to match strings of the \"AB\" type with any specific string. These strings can be placed anywhere within the overall string as \"ABABABAB..\" .Hence we take all z type of strings\\n2. Combine \"AA\" and \"BB\" strings as \"AABB\" pairs.Thus,for the total length,  we choose the minimum number of occurrences between the two patterns and multiply it by 4, as the resulting composite string will have the pattern \"AABB\".\\n3. If there are remaining \"AA\" or \"BB\" strings, append a single occurrence at the end of the string. For example, with x=2, y=1, and z=0, the resulting string would be \"AABBA\".\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mn = min(x,y);\\n        if (x == y)\\n            return (4 * x + z * 2);\\n        else \\n            return (2 * mn + (mn + 1) * 2 + z * 2);\\n    }\\n};\\n```\\n# Java code \\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int mn = Math.min(x, y);\\n        if (x == y) {\\n            return (4 * x + 2 * z);\\n        } \\n        else {\\n            return (2 * mn + (mn + 1) * 2 + 2 * z);\\n        }\\n    }\\n}\\n```\\n# Python Code \\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        mn = min(x, y)\\n        if x == y:\\n            return 4 * x + 2 * z\\n        else:\\n            return 2 * mn + (mn + 1) * 2 + 2 * z\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mn = min(x,y);\\n        if (x == y)\\n            return (4 * x + z * 2);\\n        else \\n            return (2 * mn + (mn + 1) * 2 + z * 2);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int mn = Math.min(x, y);\\n        if (x == y) {\\n            return (4 * x + 2 * z);\\n        } \\n        else {\\n            return (2 * mn + (mn + 1) * 2 + 2 * z);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        mn = min(x, y)\\n        if x == y:\\n            return 4 * x + 2 * z\\n        else:\\n            return 2 * mn + (mn + 1) * 2 + 2 * z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677592,
                "title": "explained-dp-with-memorisation-possibility-of-adding-aa-ab-bb",
                "content": "#### Up vote if you like the solution \\n\\n# Approach\\nWe can think up to create the string with the restriction that there is no AAA & no BBB possible.\\nSo lets iterate over and try to build all possible cases and take the max length possible as the answer.\\nSo to do so we can store the last added word to our answer and then check the next possible cases with following restrictions. \\n1. we can add AA if the last added is not AA ( we can add it if last = BB or AB)\\n2. we can add BB id if the last added is not BB or AB\\n3. we can add AB id if the last added is not AA.\\n\\nSo with above constraint we can recursively track the largest length of string possible.\\n\\nThis can be solve using simple math but a bit tricky. Refer to this solution: \\nhttps://leetcode.com/problems/construct-the-longest-new-string/solutions/3677663/simple-observation-one-liner/\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][51][51][4] = {};\\n    int solve(int x, int y, int z, int last){\\n        if(dp[x][y][z][last] != 0) return dp[x][y][z][last];\\n        int res = 0;\\n        if(x > 0 && last != 1) res = max(res, 2 + solve(x-1, y, z, 1));\\n        if(y > 0 && last <= 1) res = max(res, 2 + solve(x, y-1, z, 2));\\n        if(z > 0 && last != 1) res = max(res, 2 + solve(x, y, z-1, 3));\\n        return dp[x][y][z][last] = res;\\n    }\\n    int longestString(int x, int y, int z) {\\n        return solve(x, y, z, 0);\\n    }\\n};\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][51][51][4] = {};\\n    int solve(int x, int y, int z, int last){\\n        if(dp[x][y][z][last] != 0) return dp[x][y][z][last];\\n        int res = 0;\\n        if(x > 0 && last != 1) res = max(res, 2 + solve(x-1, y, z, 1));\\n        if(y > 0 && last <= 1) res = max(res, 2 + solve(x, y-1, z, 2));\\n        if(z > 0 && last != 1) res = max(res, 2 + solve(x, y, z-1, 3));\\n        return dp[x][y][z][last] = res;\\n    }\\n    int longestString(int x, int y, int z) {\\n        return solve(x, y, z, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677618,
                "title": "java-c-python-1-line-o-1",
                "content": "# **Explanation**\\nAssume we only have `AA` and `BB`:\\n\\nIf we have more `AA` than `BB`,\\nwe will put `AABBAA..BBAA`,\\none more `AA` than `BB`,\\nso we will have atmost `min(x, y + 1)` of `AA`\\n\\nIf we have more `BB` than `AA`,\\nwe will put `BBAABB..AABB`,\\none more `BB` than `AA`,\\nso we will have atmost `min(x + 1, y)` of `BB`\\n\\nNow how about `AB` ?\\n`AB` has won\\'t affect the above rule,\\nand we can arrange as many as possible,\\nlike `ABAB..ABAB`,\\nand it can be, merged before `AA`, or after `BB`.\\nso we have `z * 2` more characters from `AB`\\n\\nSum up 3 parts,\\nwe return `(min(x, y + 1) + min(x + 1, y) + z) * 2`\\n<br>\\n\\n# **Complexity**\\nTime `O(1)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int longestString(int x, int y, int z) {\\n        return (Math.min(x, y + 1) + Math.min(x + 1, y) + z) * 2;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int longestString(int x, int y, int z) {\\n        return (min(x, y + 1) + min(x + 1, y) + z) * 2\\n    }\\n```\\n\\n**Python**\\n```py\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        return min(x + y + z, x + x + 1 + z, y + y + 1 + z) * 2\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int longestString(int x, int y, int z) {\\n        return (Math.min(x, y + 1) + Math.min(x + 1, y) + z) * 2;\\n    }\\n```\n```cpp\\n    int longestString(int x, int y, int z) {\\n        return (min(x, y + 1) + min(x + 1, y) + z) * 2\\n    }\\n```\n```py\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        return min(x + y + z, x + x + 1 + z, y + y + 1 + z) * 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3678458,
                "title": "c-java-python-completely-explained-all-cases-one-liner-brainteaser",
                "content": "You can see other solutions that are using recursion with DP to go to every case. But this problem is more of a brainteaser where maximum length can be found with some if-else conditions. I will try to explain what I did in contest.\\n\\n# Intuition\\nLet `X = \"AA\"`, `Y = \"BB\"`, and `Z = \"AB\"`. If we have taken any of the three strings, what are the different possibilities for next string? List every possible case (there are $3$ choices of both previous and current string so total $3 \\\\times 3 = 9$ cases are possible)\\n```\\nCurrent    Next    String    IsPossible\\nX          X       AAAA      0\\nX          Y       AABB      1\\nX          Z       AAAB      0\\nY          X       BBAA      1\\nY          Y       BBBB      0\\nY          Z       BBAB      1\\nZ          X       ABAA      1\\nZ          Y       ABBB      0\\nZ          Z       ABAB      1\\n```\\n\\n1. If we took `X` before, then we can take `Y`\\n2. If we took `Y` before, then we can take `X` or `Z`\\n3. If we took `Z` before, then we can take `X` or `Z`\\n\\nState transition diagram for these strings will look like:\\n![image.png](https://assets.leetcode.com/users/images/1a2139fe-6fb9-4a66-a6ef-3b494624d45e_1687634097.4788377.png)\\n(Gives me feels of Automata)\\n\\nSince `Z` has a self-loop, we can take `Z` as much as we want continuously (or as much as it is available). So, take all `Z`s together anytime. Now problem lies with `X` and `Y`.\\nWith the graph, it is clear that to maximize the take of `X` and `Y`, we can alternatively take `XYXYXY...` or `YXYXYX...`.\\n\\nSo, we have 3 cases now: $x = y$, $x > y$, and $x < y$.\\n\\n## Case 1: x = y\\nOptimal approach will be take all `Z`s together first.\\nFrom last `Z`, we can go to `X`, so take `XYXYXY...XY` then.\\n\\n```\\nString: \"ZZZ...Z XYXYXY...XY\"\\nanswer = 2 * (z + x + y)\\n```\\n\\n## Case 2: x > y\\nOptimal approach will be take all `Z`s together first.\\nFrom last `Z`, we can go to `X`, so start taking `XYXYXY...` as much as we can.\\nSince $x > y$, there will be a point after taking the last pair of `XY` (or $yth$ pair), where all `Y`s will be exhausted but some `X` will remain. At this point we can take another `X` at last.\\n```\\nString: \"ZZZ...Z XYXYXY...XY X\"\\nanswer = 2 * (z + y + y + 1)\\n```\\n\\n## Case 3: x < y\\nTake all `Z`s together first.\\nFrom last `Z`, we can go to `X`, so start taking `XYXYXY...` as much as we can.\\nSince $x < y$, there will be a point after taking the last pair of `XY` (or $xth$ pair), where all `X`s will be exhausted. At this point, we can\\'t do anything as we are standing at `Y`. But some `Y` are still remaining. So, we could have taken one `Y` at the very beginning, then we could have taken all `Z`s and `XY` pairs.\\n```\\nString: \"Y ZZZ...Z XYXYXY...XY\"\\nanswer = 2 * (1 + z + x + x)\\n```\\n\\n# Approach\\nCase 2 and 3 can be merged together by\\n```\\nanswer = 2 * (2 * min(x, y) + z + 1)\\n```\\n\\nCase 1 can also be merged, since `min(x, y) = x = y` for `x = y`\\n```\\nanswer = 2 * (2 * min(x, y) + z + (x != y))\\n```\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return 2 * (2 * min(x, y) + z + (x != y));\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        return 2 * (2 * Math.min(x, y) + z + (x != y ? 1 : 0));\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        return 2 * (2 * min(x, y) + z + (1 if x != y else 0))\\n```\\n\\n# Complexity\\n- Time complexity: $O(1)$\\n- Space complexity: $O(1)$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Brainteaser"
                ],
                "code": "```\\nCurrent    Next    String    IsPossible\\nX          X       AAAA      0\\nX          Y       AABB      1\\nX          Z       AAAB      0\\nY          X       BBAA      1\\nY          Y       BBBB      0\\nY          Z       BBAB      1\\nZ          X       ABAA      1\\nZ          Y       ABBB      0\\nZ          Z       ABAB      1\\n```\n```\\nString: \"ZZZ...Z XYXYXY...XY\"\\nanswer = 2 * (z + x + y)\\n```\n```\\nString: \"ZZZ...Z XYXYXY...XY X\"\\nanswer = 2 * (z + y + y + 1)\\n```\n```\\nString: \"Y ZZZ...Z XYXYXY...XY\"\\nanswer = 2 * (1 + z + x + x)\\n```\n```\\nanswer = 2 * (2 * min(x, y) + z + 1)\\n```\n```\\nanswer = 2 * (2 * min(x, y) + z + (x != y))\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return 2 * (2 * min(x, y) + z + (x != y));\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        return 2 * (2 * Math.min(x, y) + z + (x != y ? 1 : 0));\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        return 2 * (2 * min(x, y) + z + (1 if x != y else 0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682150,
                "title": "full-explaination-for-beginners-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        #\"AB\" can be placed any where in the answer ,count=\"AB\"*2\\n        count=z*2\\n\\n        #take pair of \"AA\" and \"BB\" then concatinate at the end like \"ABAB\"+\"AABBAABBAABB\"=\"ABABAABBAABBAABB\"\\n        n=min(x,y)\\n        count+=n*4 \\n        x-=n\\n        y-=n\\n        #now check if any one of  \"AA\" or \"BB\" is left or not and if \"AA\" is left then put it in the end. else put in the start\\n        if x>0 or y>0:\\n            count+=2\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        #\"AB\" can be placed any where in the answer ,count=\"AB\"*2\\n        count=z*2\\n\\n        #take pair of \"AA\" and \"BB\" then concatinate at the end like \"ABAB\"+\"AABBAABBAABB\"=\"ABABAABBAABBAABB\"\\n        n=min(x,y)\\n        count+=n*4 \\n        x-=n\\n        y-=n\\n        #now check if any one of  \"AA\" or \"BB\" is left or not and if \"AA\" is left then put it in the end. else put in the start\\n        if x>0 or y>0:\\n            count+=2\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677634,
                "title": "step-by-step-explanation-math-o-1-st",
                "content": "**Observations:**\\nWe can see that z can be concatenated with itself infinitely without any restrictions. If z = 5, then we can write: ABABABABAB\\nAlso the strings x and y can be concatenated infinitely. If x = 2 and y = 2, then we can write: AABBAABB\\n\\nWe can then have the following cases:-\\n**Case 1:** If x = 0 and y = 0, then we just have to return z.\\n\\n**Case 2:** If x = 0, then we can append y only once at the beginning. \\nEg:- x = 0, y = 3, z = 2;\\nans = BBABAB [yzz]\\n\\n**Case 3:** If y = 0, then we can append x only once at the end.\\nEg:- x = 3, y = 0, z = 2;\\nans = ABABAA [zzx]\\n\\n**Case 4:** If x = y, then we can use all the strings of x, y and z.\\nEg:- x = 3, y = 3, z = 2;\\nans = AABBAABBAABBABAB [xyxyxyzz] (OR)  ans = ABABAABBAABBAABB [zzxyxyxy]\\n\\n**Case 5:** If x != y, then we can concatenate min(x, y) strings together with z.\\nEg 1 (when x < y):- x = 2, y = 4, z = 3\\nans = BBABABABAABBAABB [yzzzxyxy]\\n\\nEg 2 (when x > y):- x = 4, y = 2, z = 3\\nans = AABBAABBABABABAA [xyxyzzzx]\\n\\n# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        ans = z * 2\\n        \\n        if x == 0 and y == 0: return ans\\n        elif x == 0 or y == 0: return ans + 2\\n        elif x == y: return ans + (x * 4)\\n        else: return ans + (min(x, y) * 4) + 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        ans = z * 2\\n        \\n        if x == 0 and y == 0: return ans\\n        elif x == 0 or y == 0: return ans + 2\\n        elif x == y: return ans + (x * 4)\\n        else: return ans + (min(x, y) * 4) + 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677590,
                "title": "java-python-3-time-space-o-1-simple-math-for-greedy-alg",
                "content": "**Intuition:**\\n\\n1. `AA`s can NOT be neighbors, neither do `BB`s;\\n2. `AB` can NOT be among `AA`s or `BB`s;\\n3. `AB`s can be neighbors, and also can always be before `AA` or after `BB`;\\nTherefore, in order to make full use of `AA`s and `BB`s, **we must put them as `AABBAABB...AA` if x > y, or `BBAABB...BB` if x < y**. Afer that we can put all `AB`s before or after it.\\n\\n```java\\n    public int longestString(int x, int y, int z) {\\n        int xy = 2 * Math.min(x, y);\\n        if (x != y) {\\n            ++xy;\\n        }\\n        return 2 * (xy + z);\\n    }\\n```\\n```python\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        xy = 2 * min(x, y) + (x != y)\\n        return 2 * (xy + z)\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(1)`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```java\\n    public int longestString(int x, int y, int z) {\\n        int xy = 2 * Math.min(x, y);\\n        if (x != y) {\\n            ++xy;\\n        }\\n        return 2 * (xy + z);\\n    }\\n```\n```python\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        xy = 2 * min(x, y) + (x != y)\\n        return 2 * (xy + z)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3677846,
                "title": "c-recursion-memoization-explained",
                "content": "# Intuition\\nWe have certain choices depending upon our last choosen string.So we need to explore all possible choices. How do we do that??  Recursion\\n\\n# Approach\\n- We will make a recursive function find(x,y,z,last).\\n- Here x represent no string left of form \"AA\"\\n- Here y represent no string left of form \"BB\"\\n- Here z represent no string left of form \"AB\"\\n- Here last represent the last_choice that we made.If last==1 that means last_choice was \"AA\" else if last==2 last_choice was \"BB\" else\\nlast_choice was \"AB\".\\n\\n\\nIf last_choic was \"AA\" we can take y only .As if we take x or z it will violate our condition as there will be either \"AAAA\" or \"AAAB\"which contains 3 and 4 A\\'s respectively.\\n\\nIf last_choic was \"BB\" we can take x or z only .As if we take y it will violate our condition as there will be \"BBBB\" which contains 4 B\\'s.\\n\\nIf last_choic was \"AB\" we can take x or z only .As if we take y it will violate our condition as there will be \"ABBB\" which contains  3 B\\'s.\\n\\n\\n\\n\\n# Recursive Code [TLE]\\n```\\nclass Solution {\\npublic:\\n\\n    // X -> AA\\n    // Y-> BB\\n    // Z-> AB\\n    int find(int x,int y,int z,int last)\\n    {\\n        int ans=0;\\n        \\n        if(last==-1)\\n        {\\n             if(x)\\n            ans=max(ans,2+find(x-1,y,z,1));\\n            if(y)\\n            ans=max(ans,2+find(x,y-1,z,2));\\n            if(z)\\n            ans=max(ans,2+find(x,y,z-1,3));\\n        }\\n        else\\n        {\\n            if(last==1)     // AA\\n            {\\n                if(y)    // can only take BB if available\\n                ans=max(ans,2+find(x,y-1,z,2));\\n                \\n               // cannot take AA OR AB as it will make AAB\\n                \\n            }\\n            else if(last==2)    // BB\\n            {\\n                if(x)   // can take AA if available\\n                    ans=max(ans,2+find(x-1,y,z,1));\\n                \\n                if(z)  // can take AB if available\\n                    ans=max(ans,2+find(x,y,z-1,3));\\n                \\n                // cannot take BB as it will make BBBB\\n            }\\n            else              //AB\\n            {\\n                if(x)   // can take AA if available\\n                    ans=max(ans,2+find(x-1,y,z,1));\\n                \\n                if(z)  // can take AB if available\\n                    ans=max(ans,2+find(x,y,z-1,3));\\n                \\n               // cannot take BB as it will make BBB \\n            }\\n        }\\n        return ans;\\n    }\\n    int longestString(int x, int y, int z) \\n    {\\n        \\n        int ans=find(x,y,z,-1);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Memoized Code[ACCEPTED]\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[51][51][51][5];\\n    \\n    // X -> AA\\n    // Y-> BB\\n    // Z-> AB\\n    int find(int x,int y,int z,int last)\\n    {\\n        int ans=0;\\n        if(dp[x][y][z][last+1]!=-1)\\n            return dp[x][y][z][last+1];\\n        if(last==-1)\\n        {\\n             if(x)\\n            ans=max(ans,2+find(x-1,y,z,1));\\n            if(y)\\n            ans=max(ans,2+find(x,y-1,z,2));\\n            if(z)\\n            ans=max(ans,2+find(x,y,z-1,3));\\n        }\\n        else\\n        {\\n            if(last==1)     // AA\\n            {\\n                if(y)    // can only take BB if available\\n                ans=max(ans,2+find(x,y-1,z,2));\\n                \\n               // cannot take AA OR AB as it will make AAB\\n                \\n            }\\n            else if(last==2)    // BB\\n            {\\n                if(x)   // can take AA if available\\n                    ans=max(ans,2+find(x-1,y,z,1));\\n                \\n                if(z)  // can take AB if available\\n                    ans=max(ans,2+find(x,y,z-1,3));\\n                \\n                // cannot take BB as it will make BBBB\\n            }\\n            else              //AB\\n            {\\n                if(x)   // can take AA if available\\n                    ans=max(ans,2+find(x-1,y,z,1));\\n                \\n                if(z)  // can take AB if available\\n                    ans=max(ans,2+find(x,y,z-1,3));\\n                \\n               // cannot take BB as it will make BBB \\n            }\\n        }\\n        return dp[x][y][z][last+1]=ans;\\n    }\\n    int longestString(int x, int y, int z) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=find(x,y,z,-1);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // X -> AA\\n    // Y-> BB\\n    // Z-> AB\\n    int find(int x,int y,int z,int last)\\n    {\\n        int ans=0;\\n        \\n        if(last==-1)\\n        {\\n             if(x)\\n            ans=max(ans,2+find(x-1,y,z,1));\\n            if(y)\\n            ans=max(ans,2+find(x,y-1,z,2));\\n            if(z)\\n            ans=max(ans,2+find(x,y,z-1,3));\\n        }\\n        else\\n        {\\n            if(last==1)     // AA\\n            {\\n                if(y)    // can only take BB if available\\n                ans=max(ans,2+find(x,y-1,z,2));\\n                \\n               // cannot take AA OR AB as it will make AAB\\n                \\n            }\\n            else if(last==2)    // BB\\n            {\\n                if(x)   // can take AA if available\\n                    ans=max(ans,2+find(x-1,y,z,1));\\n                \\n                if(z)  // can take AB if available\\n                    ans=max(ans,2+find(x,y,z-1,3));\\n                \\n                // cannot take BB as it will make BBBB\\n            }\\n            else              //AB\\n            {\\n                if(x)   // can take AA if available\\n                    ans=max(ans,2+find(x-1,y,z,1));\\n                \\n                if(z)  // can take AB if available\\n                    ans=max(ans,2+find(x,y,z-1,3));\\n                \\n               // cannot take BB as it will make BBB \\n            }\\n        }\\n        return ans;\\n    }\\n    int longestString(int x, int y, int z) \\n    {\\n        \\n        int ans=find(x,y,z,-1);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[51][51][51][5];\\n    \\n    // X -> AA\\n    // Y-> BB\\n    // Z-> AB\\n    int find(int x,int y,int z,int last)\\n    {\\n        int ans=0;\\n        if(dp[x][y][z][last+1]!=-1)\\n            return dp[x][y][z][last+1];\\n        if(last==-1)\\n        {\\n             if(x)\\n            ans=max(ans,2+find(x-1,y,z,1));\\n            if(y)\\n            ans=max(ans,2+find(x,y-1,z,2));\\n            if(z)\\n            ans=max(ans,2+find(x,y,z-1,3));\\n        }\\n        else\\n        {\\n            if(last==1)     // AA\\n            {\\n                if(y)    // can only take BB if available\\n                ans=max(ans,2+find(x,y-1,z,2));\\n                \\n               // cannot take AA OR AB as it will make AAB\\n                \\n            }\\n            else if(last==2)    // BB\\n            {\\n                if(x)   // can take AA if available\\n                    ans=max(ans,2+find(x-1,y,z,1));\\n                \\n                if(z)  // can take AB if available\\n                    ans=max(ans,2+find(x,y,z-1,3));\\n                \\n                // cannot take BB as it will make BBBB\\n            }\\n            else              //AB\\n            {\\n                if(x)   // can take AA if available\\n                    ans=max(ans,2+find(x-1,y,z,1));\\n                \\n                if(z)  // can take AB if available\\n                    ans=max(ans,2+find(x,y,z-1,3));\\n                \\n               // cannot take BB as it will make BBB \\n            }\\n        }\\n        return dp[x][y][z][last+1]=ans;\\n    }\\n    int longestString(int x, int y, int z) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=find(x,y,z,-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691345,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int first=Math.min(x,y);\\n        int second=x==y ? first : first+1;\\n        first<<=1;\\n        second<<=1;\\n        return first + second + (z<<1) ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int first=Math.min(x,y);\\n        int second=x==y ? first : first+1;\\n        first<<=1;\\n        second<<=1;\\n        return first + second + (z<<1) ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677623,
                "title": "easy-c-solution-in-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to check only x and y value\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mn=min(x,y);\\n        int cnt=0;\\n        if(x!=y)cnt=1;\\n        return (mn+mn+cnt+z)*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mn=min(x,y);\\n        int cnt=0;\\n        if(x!=y)cnt=1;\\n        return (mn+mn+cnt+z)*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677510,
                "title": "cpp-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(z > 0) {\\n            if(y > x) return 4 * (x + 1) + 2 * z - 2;\\n            return 4 * y + 2 * z + (x - y > 0 ? 2 : 0);\\n        }\\n        return 4*(min(x,y) + 1) - 2 - (x == y ? 2 : 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(z > 0) {\\n            if(y > x) return 4 * (x + 1) + 2 * z - 2;\\n            return 4 * y + 2 * z + (x - y > 0 ? 2 : 0);\\n        }\\n        return 4*(min(x,y) + 1) - 2 - (x == y ? 2 : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677841,
                "title": "dp-vs-math",
                "content": "This can be solved using DP with O(x * y * z * 3) complexity (see the second solution below).\\n\\nHowever, we can do it in O(1) with just a few observations.\\n\\nWe can always use all \"AB\" strings. So, we add `z * 2` to the result.\\n\\nHowever, we cannot use \"AB\" to \"glue\" other strings:\\n- \"~~AAA~~BAA\"\\n- \"BBA~~BBB~~\"\\n\\nSo, to include two \"AA\", we need one \"BB\" (and vice versa).\\n\\nSo, we add `2 * min(x, y)` to the result, plus one more string if `x != y`.\\n\\n## Math\\n**C++**\\n```cpp\\nint longestString(int x, int y, int z) {\\n    return 2 * (z + min(x, y) * 2 + (x != y));\\n}\\n```\\n\\n## DP\\nHere, we just try all valid combinations.\\n\\nWe memoise by the last character, and the remaining strings of each kind.\\n\\n**C++**\\n```cpp\\nint dp[51][51][51][4] = {};\\nint longestString(int x, int y, int z, int l = 3) {\\n    if (dp[x][y][z][l] == 0)\\n        dp[x][y][z][l] = max({\\n            x && l != 0 ? 2 + longestString(x - 1, y, z, 0) : 0,\\n            y && l != 1 && l != 2 ? 2 + longestString(x, y - 1, z, 1) : 0,\\n            z && l != 0 ? 2 + longestString(x, y, z - 1, 2) : 0\\n        });\\n    return dp[x][y][z][l];\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint longestString(int x, int y, int z) {\\n    return 2 * (z + min(x, y) * 2 + (x != y));\\n}\\n```\n```cpp\\nint dp[51][51][51][4] = {};\\nint longestString(int x, int y, int z, int l = 3) {\\n    if (dp[x][y][z][l] == 0)\\n        dp[x][y][z][l] = max({\\n            x && l != 0 ? 2 + longestString(x - 1, y, z, 0) : 0,\\n            y && l != 1 && l != 2 ? 2 + longestString(x, y - 1, z, 1) : 0,\\n            z && l != 0 ? 2 + longestString(x, y, z - 1, 2) : 0\\n        });\\n    return dp[x][y][z][l];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677650,
                "title": "easy-to-understand-c-solution-o-1-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    If x is greater than y then we can take entire y and\\n    1 more x than y because we can wrap like AABBAABBAA.\\n    (if x = 3 & y = 2) and we will add the entire z.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) { \\n        if(x>y) x=y+1;\\n        else if(x<y)  y = x+1;\\n        return 2*(x + y + z);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) { \\n        if(x>y) x=y+1;\\n        else if(x<y)  y = x+1;\\n        return 2*(x + y + z);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683437,
                "title": "easiest-solution-ever-3line-code",
                "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(Math.abs(x-y)<=1){\\n            return 2*(x+y+z);\\n        }else{\\n           return ((Math.min(x,y)*2+1)+z)*2;\\n        }\\n        // return 1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(Math.abs(x-y)<=1){\\n            return 2*(x+y+z);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3677829,
                "title": "java-readable-intuitive-strategy-with-detailed-comments-o-1-runtime-o-1-space",
                "content": "O(1) runtime, same number of computations regardless of x, y, z size\\nO(1) space, only need finite variables regardless of x, y, z size\\n\\nTechnically does not mutate input since the parameters are primitive `int` passed by value.\\n\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int longestString = 0;\\n        \\n        //Account for \\'AB\\' repetitions\\n        //AB is versatile because they can be used back to back or they can be used prepended by BB or appended by AA\\n        //Because AA, BB are best used together, then we should just stick to alternating AB-AB together\\n        longestString += z * 2;\\n        \\n        //Start alternating AABB pairs\\n        //AA and BB are best used when used together first since they are worth 4 together\\n        int aabbCount =  Math.min(x, y);\\n        \\n        longestString += aabbCount * 4;\\n        x -= aabbCount;\\n        y -= aabbCount;\\n        \\n        //Account for leftover AA,BB\\n        \\n        //Lastly, append an AA if possible\\n        if(x > 0) {\\n            longestString +=2;\\n        }\\n        \\n        //Lastly, prepend BB if possible\\n        if(y > 0) {\\n            longestString +=2;\\n        }\\n        \\n\\t\\t//End product looks like {Singular BB prepend if available} + {ABAB... pairs} + {AABB... pairs}  + {Singular AA append if available}\\n\\t\\t//ex: BB-ABABABABABAB-AABBAABB-AA\\n\\t\\t\\n        return longestString;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int longestString = 0;\\n        \\n        //Account for \\'AB\\' repetitions\\n        //AB is versatile because they can be used back to back or they can be used prepended by BB or appended by AA\\n        //Because AA, BB are best used together, then we should just stick to alternating AB-AB together\\n        longestString += z * 2;\\n        \\n        //Start alternating AABB pairs\\n        //AA and BB are best used when used together first since they are worth 4 together\\n        int aabbCount =  Math.min(x, y);\\n        \\n        longestString += aabbCount * 4;\\n        x -= aabbCount;\\n        y -= aabbCount;\\n        \\n        //Account for leftover AA,BB\\n        \\n        //Lastly, append an AA if possible\\n        if(x > 0) {\\n            longestString +=2;\\n        }\\n        \\n        //Lastly, prepend BB if possible\\n        if(y > 0) {\\n            longestString +=2;\\n        }\\n        \\n\\t\\t//End product looks like {Singular BB prepend if available} + {ABAB... pairs} + {AABB... pairs}  + {Singular AA append if available}\\n\\t\\t//ex: BB-ABABABABABAB-AABBAABB-AA\\n\\t\\t\\n        return longestString;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677542,
                "title": "most-simple-maths-c",
                "content": "# if this code helps you, please upvote\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(y>x)swap(x,y);\\n        if(x==y){\\n            return x*4+z*2;\\n        }\\n        return y*4+2+z*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(y>x)swap(x,y);\\n        if(x==y){\\n            return x*4+z*2;\\n        }\\n        return y*4+2+z*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682011,
                "title": "python-3-2-lines-t-m-99-64",
                "content": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n\\n        if x > y: x,y = y,x\\n\\n        return min(x + y, 2*x + 1 ) * 2 + 2*z;\\n```\\n[https://leetcode.com/problems/construct-the-longest-new-string/submissions/985072631/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n\\n        if x > y: x,y = y,x\\n\\n        return min(x + y, 2*x + 1 ) * 2 + 2*z;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677663,
                "title": "simple-observation-one-liner-o-1",
                "content": "# Intuition\\n\\n1. We don\\'t need to pair strings of type \"AB\" with anyone. They can appear anywhere in the string. Hence we take all z type of strings\\n2. We can pair up \"AA\" and \"BB\" as AABB so we take min of the two occurences and multiply it by 4 as the composite string will be AABB\\n3. If there are still occurences of AA or BB then we can take a single occurence and append it at the end example AABBAA for x=2, y=1, z = 0\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int temp = min(x,y);\\n        x -= temp;\\n        y -= temp;\\n        return z*2 + temp*4 + (x > 0 || y > 0)*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int temp = min(x,y);\\n        x -= temp;\\n        y -= temp;\\n        return z*2 + temp*4 + (x > 0 || y > 0)*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677617,
                "title": "1-line-easy-java-solution-c-solution",
                "content": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int u=Math.min(x,y);\\n        return (x==y)?((z+2*u)*2):((1+z+2*u)*2);\\n    }\\n}\\n```\\nAnother java Solution\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int a=z*2;\\n        if(x>y) a+=2*y+(y+1)*2;\\n        else if(y>x) a+=2*x+(x+1)*2;\\n        else a+=4*x;\\n        return a;\\n    }\\n}\\n```\\n\\nC++ Solution\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n            int u=min(x,y);\\n        return (x==y)?((z+2*u)*2):((1+z+2*u)*2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int u=Math.min(x,y);\\n        return (x==y)?((z+2*u)*2):((1+z+2*u)*2);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int a=z*2;\\n        if(x>y) a+=2*y+(y+1)*2;\\n        else if(y>x) a+=2*x+(x+1)*2;\\n        else a+=4*x;\\n        return a;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n            int u=min(x,y);\\n        return (x==y)?((z+2*u)*2):((1+z+2*u)*2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677545,
                "title": "c-3-lines-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=(min(x,y)*2+z)*2;\\n        if(x != y) ans +=2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=(min(x,y)*2+z)*2;\\n        if(x != y) ans +=2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677512,
                "title": "easy-maths-solution-easy-and-simple-explaination-and-intution",
                "content": "# **Approch:**\\n\\nFor avoiding 3 consecutive A and B\\'s,\\nOne thing should be clear if you use a X it should be followed by a Y\\ni.e\\nAA -- BB\\nor vice versa BB-AA\\nSo one observation is always to use Z at extreme point.\\n1. AB.......\\n or\\n2. ......AB\\n\\nIn first case you have to add a next X i.e AA\\'s in order to avoid three BBB\\'s \\nIn second case you have to add X and Y such that it ends at BB,\\n\\nso both the cases have min(count(a),count(b))+1 and max of both cases will be the best way\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\no(1)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int mini = min(x,y);\\n        ans1 += 2*z + 4*mini +(mini!=x?2:0);\\n        ans2 += 4*mini + 2*z +(mini!=y?2:0);\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int mini = min(x,y);\\n        ans1 += 2*z + 4*mini +(mini!=x?2:0);\\n        ans2 += 4*mini + 2*z +(mini!=y?2:0);\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017001,
                "title": "only-1-line-code-c",
                "content": "# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return   2*(2*min(x,y)+(x==y ? 0:1)+z);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return   2*(2*min(x,y)+(x==y ? 0:1)+z);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881648,
                "title": "self-explainatory-solution-beats-72",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        char s,e;\\n        int ans = 0;\\n        if(x>y)\\n        {\\n            s = \\'x\\';\\n            e = \\'x\\';\\n            x = x-y-1;\\n            ans+=2*y+1;\\n            y = 0;\\n            \\n        }\\n        else if(y>x)\\n        {\\n            s = \\'y\\';\\n            e = \\'y\\';\\n            y = y-x-1;\\n            ans+=2*x+1;\\n            x = 0;\\n            \\n        }\\n        else\\n        {\\n            s = \\'x\\';\\n            e = \\'y\\';\\n            x = 0;\\n            ans=ans+2*y;\\n            y = 0;\\n        }\\n\\n        if(x>0 && z>0)\\n        {\\n            if((s==\\'y\\' && e==\\'y\\') || (s==\\'x\\' && e==\\'y\\'))\\n            {\\n                z--;\\n                x--;\\n                ans+=2;\\n            }\\n        }\\n        if(y>0 && z>0)\\n        {\\n            if((s==\\'x\\' && e==\\'x\\') || (s==\\'x\\' && e==\\'y\\'))\\n            {\\n                z--;\\n                y--;\\n                ans+=2;\\n            }\\n        }\\n\\n        if(z>0)\\n        ans+=z;\\n\\n\\n        return ans*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        char s,e;\\n        int ans = 0;\\n        if(x>y)\\n        {\\n            s = \\'x\\';\\n            e = \\'x\\';\\n            x = x-y-1;\\n            ans+=2*y+1;\\n            y = 0;\\n            \\n        }\\n        else if(y>x)\\n        {\\n            s = \\'y\\';\\n            e = \\'y\\';\\n            y = y-x-1;\\n            ans+=2*x+1;\\n            x = 0;\\n            \\n        }\\n        else\\n        {\\n            s = \\'x\\';\\n            e = \\'y\\';\\n            x = 0;\\n            ans=ans+2*y;\\n            y = 0;\\n        }\\n\\n        if(x>0 && z>0)\\n        {\\n            if((s==\\'y\\' && e==\\'y\\') || (s==\\'x\\' && e==\\'y\\'))\\n            {\\n                z--;\\n                x--;\\n                ans+=2;\\n            }\\n        }\\n        if(y>0 && z>0)\\n        {\\n            if((s==\\'x\\' && e==\\'x\\') || (s==\\'x\\' && e==\\'y\\'))\\n            {\\n                z--;\\n                y--;\\n                ans+=2;\\n            }\\n        }\\n\\n        if(z>0)\\n        ans+=z;\\n\\n\\n        return ans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719112,
                "title": "easy-understandable-code-and-approach-in-c-programming-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou can understand it just by seeing code\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y)\\n        return 2*(x+y+z);\\n        else if(x<y)\\n        return 2*(x+x+1+z);\\n        else \\n        return 2*(y+y+1+z);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y)\\n        return 2*(x+y+z);\\n        else if(x<y)\\n        return 2*(x+x+1+z);\\n        else \\n        return 2*(y+y+1+z);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677729,
                "title": "shortest-code-basic-logic",
                "content": "\\n**<<<<<<UpVote**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int count=0;\\n        while(x>0 && y>0){\\n            count+=2;\\n            count+=2;\\n            x--;\\n            y--;   \\n        }\\n        if(x>=1) count+=2;\\n        if(y>=1) count+=2;\\n        count+=(z*2);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int count=0;\\n        while(x>0 && y>0){\\n            count+=2;\\n            count+=2;\\n            x--;\\n            y--;   \\n        }\\n        if(x>=1) count+=2;\\n        if(y>=1) count+=2;\\n        count+=(z*2);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677575,
                "title": "math-c-o-1-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple Math\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        \\n        if(x==y)\\n        {\\n            return (2*z) + (x * 2)*2;\\n        }\\n        return (2*z)+ (min(x,y)*2)*2+2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        \\n        if(x==y)\\n        {\\n            return (2*z) + (x * 2)*2;\\n        }\\n        return (2*z)+ (min(x,y)*2)*2+2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677506,
                "title": "c-very-simple-approach-with-explanation",
                "content": "- x = no. of \\'AA\\', y = no. of \\'BB\\' and z = no. of  \\'AB\\'\\n- we can put as many \\'AB\\' before \\'AB\\' without violating rules so longest string is z*2\\n- we have to put \\'AA\\' after \\'BB\\' alternate to each other otherwise rule will break\\n    - case 1 (x == y): let say x = 2 && y = 2 max possible string will be \\'AABBAABB\\' => x*4 or y*4\\n    - case 2 (x != y): let say x = 2 && y = 10 max possible string will be \\'BBAABBAABB\\' => (min(x, y)*2 + 1)*2\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {  \\n      if (x == y) return x*4 + z*2;\\n        \\n        return (min(x, y)*2 + 1)*2 + z * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {  \\n      if (x == y) return x*4 + z*2;\\n        \\n        return (min(x, y)*2 + 1)*2 + z * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786602,
                "title": "java-2-liner-solution-with-full-explanation-100-fast",
                "content": "# Explanation :\\nYou can include all \"AB\" regard less of number of \"AA\" / \"BB\" present but you can\\'t do same with \"AA\" or \"BB\" as it will form \"AAAA\" / \"BBBB\"( which we want to avoid).\\n\\nBest way to know max string we form we need to use \"AA\" and \"BB\" alternatively i.e \"AABBAA\" / \"BBAABB\".\\n\\nAs you can see we need one more than minimum number of \"AA\" / \"BB\" to get a string with max length.\\n=> return `(min(x,y)+ (min(x,y) +1) + z )*2;` (not considering x == y)\\n\\nfor `x == y`\\nWe can arrange \"AA\" and \"BB\" easily and also you can\\'t add extra staring as min(x,y) == x == y.\\n[(min(x,y) + 1) == x + 1) which is not possible].\\n=> return `(x+y+z) * 2;`\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n     if(x == y) return (x + y + z) * 2;\\n     else return (Math.min(x, y) + Math.min(x, y) + 1 + z) * 2;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n     if(x == y) return (x + y + z) * 2;\\n     else return (Math.min(x, y) + Math.min(x, y) + 1 + z) * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685699,
                "title": "100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n   int maxLen = 0;\\n        int k=min(x,y);\\n        if(x!=y){\\n    \\n   return 2*(z+k+k+1);}\\n        else{\\n            return 2*(z+2*k);\\n        }\\nreturn 0;}\\n\\n\\n\\n\\n\\n\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n   int maxLen = 0;\\n        int k=min(x,y);\\n        if(x!=y){\\n    \\n   return 2*(z+k+k+1);}\\n        else{\\n            return 2*(z+2*k);\\n        }\\nreturn 0;}\\n\\n\\n\\n\\n\\n\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684670,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return x==y ?  2*(x+y+z) :  2*(z+1+2*min(x,y));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return x==y ?  2*(x+y+z) :  2*(z+1+2*min(x,y));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683453,
                "title": "simple-bruteforce-java-solution-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int longestString(int x, int y, int z) \\n    {\\n        String ans=\"\";\\n        for(int i=0;i<z;i++)  ans=ans+\"AB\";\\n        int min=Math.min(x,y);\\n        for(int i=0;i<min;i++)\\n        {\\n            ans=ans+\"AA\";\\n            ans=ans+\"BB\";\\n            x--;\\n            y--;\\n        }\\n        if(x!=0)  ans=ans+\"AA\";\\n        if(y!=0)  ans=\"BB\"+ans;\\n        return ans.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int longestString(int x, int y, int z) \\n    {\\n        String ans=\"\";\\n        for(int i=0;i<z;i++)  ans=ans+\"AB\";\\n        int min=Math.min(x,y);\\n        for(int i=0;i<min;i++)\\n        {\\n            ans=ans+\"AA\";\\n            ans=ans+\"BB\";\\n            x--;\\n            y--;\\n        }\\n        if(x!=0)  ans=ans+\"AA\";\\n        if(y!=0)  ans=\"BB\"+ans;\\n        return ans.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681222,
                "title": "javascript-2745-construct-the-longest-new-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar longestString = function (x, y, z) {\\n  if (x === y) return (x + y + z) * 2\\n  let minxy = Math.min(x, y)\\n  return (minxy + minxy + 1 + z) * 2\\n}\\n```\\n\\n2\\n```\\nvar longestString = function (x, y, z) {\\n  let sum = 0\\n  if (x === y) {\\n    sum = x * 2\\n  } else if (x > y) {\\n    sum = 2 * y + 1\\n  } else {\\n    sum = 2 * x + 1\\n  }\\n  return (sum + z) * 2\\n}\\n```\\n\\n3\\n```\\nvar longestString = function (X, Y, Z) {\\n  function aa(x, y, z) {\\n    let minxy = Math.min(x, y)\\n    x -= minxy\\n    y -= minxy\\n\\n    let s = \\'\\'\\n    while (minxy--) {\\n      s += \\'BBAA\\'\\n    }\\n\\n    if (x) {\\n      s = \\'AA\\' + s\\n      x--\\n      while (z) {\\n        s = \\'AB\\' + s\\n        z--\\n      }\\n    } else if (y) {\\n      s += \\'BB\\'\\n      y--\\n      while (z) {\\n        s += \\'AB\\'\\n        z--\\n      }\\n    } else if (!s) {\\n      while (z) {\\n        s += \\'AB\\'\\n        z--\\n      }\\n    }\\n    return s\\n  }\\n\\n  function bb(x, y, z) {\\n    let minxy = Math.min(x, y)\\n\\n    x -= minxy\\n    y -= minxy\\n\\n    let s = \\'\\'\\n    while (minxy--) {\\n      s += \\'AABB\\'\\n    }\\n\\n    if (x) {\\n      while (z) {\\n        s = \\'AB\\' + s\\n        z--\\n      }\\n      s += \\'AA\\'\\n      x--\\n    } else if (y) {\\n      s = \\'BB\\' + s\\n      y--\\n      while (z) {\\n        s += \\'AB\\'\\n        z--\\n      }\\n    } else {\\n      while (z) {\\n        s += \\'AB\\'\\n        z--\\n      }\\n    }\\n    return s\\n  }\\n\\n  let a = aa(X, Y, Z)\\n  let b = bb(X, Y, Z)\\n\\n  return Math.max(a.length, b.length)\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestString = function (x, y, z) {\\n  if (x === y) return (x + y + z) * 2\\n  let minxy = Math.min(x, y)\\n  return (minxy + minxy + 1 + z) * 2\\n}\\n```\n```\\nvar longestString = function (x, y, z) {\\n  let sum = 0\\n  if (x === y) {\\n    sum = x * 2\\n  } else if (x > y) {\\n    sum = 2 * y + 1\\n  } else {\\n    sum = 2 * x + 1\\n  }\\n  return (sum + z) * 2\\n}\\n```\n```\\nvar longestString = function (X, Y, Z) {\\n  function aa(x, y, z) {\\n    let minxy = Math.min(x, y)\\n    x -= minxy\\n    y -= minxy\\n\\n    let s = \\'\\'\\n    while (minxy--) {\\n      s += \\'BBAA\\'\\n    }\\n\\n    if (x) {\\n      s = \\'AA\\' + s\\n      x--\\n      while (z) {\\n        s = \\'AB\\' + s\\n        z--\\n      }\\n    } else if (y) {\\n      s += \\'BB\\'\\n      y--\\n      while (z) {\\n        s += \\'AB\\'\\n        z--\\n      }\\n    } else if (!s) {\\n      while (z) {\\n        s += \\'AB\\'\\n        z--\\n      }\\n    }\\n    return s\\n  }\\n\\n  function bb(x, y, z) {\\n    let minxy = Math.min(x, y)\\n\\n    x -= minxy\\n    y -= minxy\\n\\n    let s = \\'\\'\\n    while (minxy--) {\\n      s += \\'AABB\\'\\n    }\\n\\n    if (x) {\\n      while (z) {\\n        s = \\'AB\\' + s\\n        z--\\n      }\\n      s += \\'AA\\'\\n      x--\\n    } else if (y) {\\n      s = \\'BB\\' + s\\n      y--\\n      while (z) {\\n        s += \\'AB\\'\\n        z--\\n      }\\n    } else {\\n      while (z) {\\n        s += \\'AB\\'\\n        z--\\n      }\\n    }\\n    return s\\n  }\\n\\n  let a = aa(X, Y, Z)\\n  let b = bb(X, Y, Z)\\n\\n  return Math.max(a.length, b.length)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680689,
                "title": "c-solution-o-1-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x == y) return 4*x + 2*z;\\n        int minValue = min(x, y);\\n        int len = 4 * minValue; \\n        if(z > 0) len += (4 + 2*(z-1));\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x == y) return 4*x + 2*z;\\n        int minValue = min(x, y);\\n        int len = 4 * minValue; \\n        if(z > 0) len += (4 + 2*(z-1));\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680095,
                "title": "easy-c-solution-beats-100-o-1-complexity",
                "content": "# Intuition\\nMake possible testcases and write the max outcome each time.\\nYou will Observe that in any of the cases Z ie \"AB\" can be attached anywhere in the string.\\n\\nAABBAABB-> AABBAABB\\'AB\\'\\'AB\\'\\'AB\\' infinite \\'AB\\'\\nBBAABBAA-> BBAABB\\'AB\\'\\'AB\\'....AA  infinite \\'AB\\'\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nNow the main crux after observing that z is just a diversion from the problem and in every case Z will be completely consumed.\\n\\nIts time to check the nuber of X and Y\\'s.\\nThree cases can arise basically.\\n1. X =  Y\\n2. X > Y\\n3. Y > x\\n\\nIn case 1 for eg:\\nX=2=Y and Z=1\\nwe will have AABBAABBAB ie twice the number of X plus Z\\n\\ncase 2\\nX=4 Y=2 Z=2\\nhere we start with filling Y\\'s with gaps \\nclearly 00BB00BB00 has 3 places to be filled with X\\ntherefore the number of X will be 1 more than Y \\n\\ncase 3 \\nX=2 Y=6 Z=1\\nsame as above here we start with filling X and leaving gaps for Y\\nwe will observe that 00AA00AA00 only has (2+1) places left \\ntherefore we will have \\n\\nBBAABBAABB\\'AB\\'\\n\\nthat is 2(min(X,Y)+1)+Z\\nhope the solution is clear. It took me 10 whole minutes to figure this out during the contest.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n<!-- PLS UPVOTE IF YOU FIND THIS HELPFUL -->\\n\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n\\n        <!-- for case 1 -->\\n         if(x==y) return 2*(2*x+z);\\n        \\n        <!-- for case 2 and 3 -->\\n        return 2*(2*min(x,y)+1+z); \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n<!-- PLS UPVOTE IF YOU FIND THIS HELPFUL -->\\n\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n\\n        <!-- for case 1 -->\\n         if(x==y) return 2*(2*x+z);\\n        \\n        <!-- for case 2 and 3 -->\\n        return 2*(2*min(x,y)+1+z); \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678870,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        if x==y:\\n            return 4*x+2*z\\n\\n        MIN=min(x,y)\\n        return 2*MIN+2*(MIN+1)+2*z    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        if x==y:\\n            return 4*x+2*z\\n\\n        MIN=min(x,y)\\n        return 2*MIN+2*(MIN+1)+2*z    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678370,
                "title": "fastest-solution-in-100-fast-basic-maths",
                "content": "# Intuition\\nThe intuition for solving this problem is as follows:\\n\\nWe need to construct a new string by concatenating the given strings in a way that avoids having \"AAA\" or \"BBB\" as a substring. To maximize the length of the new string, we should try to use as many strings as possible.\\n\\nTo approach this problem, we can consider the following observations:\\n\\n1. If either x or y is zero, we can concatenate all the strings without any restrictions, as there won\\'t be any occurrence of \"AAA\" or \"BBB\". So, the maximum possible length would be x + y + z.\\n\\n2. If x and y are both non-zero, we need to be careful about the concatenation order to avoid creating \"AAA\" or \"BBB\" as substrings. We can start by concatenating one instance of \"AB\" (z) to ensure that we don\\'t immediately have \"AAA\" or \"BBB\" as a substring. After that, we can alternate between \"AA\" (x) and \"BB\" (y) until we exhaust all instances of either \"AA\" or \"BB\". Finally, we can concatenate the remaining strings in any order.\\n\\nBased on these observations, the maximum possible length of the new string can be calculated as follows:\\n\\n1. If x == y, the maximum length would be x + y + z.\\n2. If x > y, the maximum length would be y + (y + 1) + z.\\n3. If x < y, the maximum length would be x + (x + 1) + z.\\n\\nThe above calculations consider the case where we alternate between \"AA\" and \"BB\" until we exhaust one of the counts, and then concatenate the remaining strings. This guarantees that \"AAA\" or \"BBB\" won\\'t be formed as substrings.\\n\\nBy following this intuition and applying the appropriate calculations based on the values of x, y, and z, we can determine the maximum possible length of the new string.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe provided code calculates the length of the longest string that can be formed using three given integers `x`, `y`, and `z`. It considers three cases:\\n\\n1. If `x` is equal to `y`, it means the longest string can be formed by concatenating `x`, `y`, and `z` twice. So, the length is calculated as `2 * (x + y + z)`.\\n\\n2. If `x` is the minimum among `x` and `y`, the longest string can be formed by concatenating `x`, `x + 1`, `z`, and `x` again. So, the length is calculated as `2 * (x + x + 1 + z)`.\\n\\n3. If `y` is the minimum among `x` and `y`, the longest string can be formed by concatenating `y`, `y + 1`, `z`, and `y` again. So, the length is calculated as `2 * (y + 1 + y + z)`.\\n\\nThe code correctly determines the longest string length based on the given inputs.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *O(1)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:*O(1)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int a=min(x,y);\\n        if(x==y){\\n            return 2*(x+y+z);\\n        }\\n        else if(x==a){\\n            return 2*(x+x+1+z);\\n        }else{\\n            return 2*(y+1+y+z);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int a=min(x,y);\\n        if(x==y){\\n            return 2*(x+y+z);\\n        }\\n        else if(x==a){\\n            return 2*(x+x+1+z);\\n        }else{\\n            return 2*(y+1+y+z);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678177,
                "title": "c-very-easy-solution-with-o-1-time-complexity",
                "content": "# Intuition\\n2 strings with `AB` can occur simultaneously. We just need to find the pattern in which the string won\\'t contain any `AAA` or `BBB` pattern.\\nFor instance `ABAABB` and `BBABAA` are 2 pattens that contain all three sorts of string simultaneously.\\n\\n# Approach\\nSo our solution primarily depends on x and y. We can easily decipher:-\\n1. If `x == y` then `ABAB......AABB...` appears simultaneously without breaking rules.\\n2. If `x>y` then `ABAB....ABAABBAABBAA` this is the pattern so the additional `AA` can be just 1 greater than y.\\n3. If `x<y` then `BBAABBAABBAB....AB` this is the pattern so the additional `BB` can be just 1 greater than x.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n       if(x == y) return 2*z + 4*x;\\n       if(x > y) return 2*z+4*y+2;\\n       return 2*z+4*x+2; \\n    }\\n};\\n```\\nPlease upvote if you liked the solution!!",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n       if(x == y) return 2*z + 4*x;\\n       if(x > y) return 2*z+4*y+2;\\n       return 2*z+4*x+2; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678160,
                "title": "very-very-simple-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**IN THIS QUE IS CAN BEEN SEEN THAT \"AB\" IS INDEPENDENT OF POSITION \\nSO WE JUST NEED TO SEE FOR AA AND BB STRING \\nSO BEST WAY TO ARRANGE THESE TWO STRING IS  START WITH MAX(X,Y) STRING FOLLOWED BY MIN(X,Y) ALTERNATIVELY****\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(y>x)swap(x,y);\\n        for(int i = 0; i < 100; i++){}\\n        if(x==y){\\n            return x*4+z*2;\\n        }\\n        return y*4+2+z*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(y>x)swap(x,y);\\n        for(int i = 0; i < 100; i++){}\\n        if(x==y){\\n            return x*4+z*2;\\n        }\\n        return y*4+2+z*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677819,
                "title": "math-c-o-1-time-easy",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. X is equal to Y, then string the possible answer can be;\\n\"ABABABAB...AABBAABBAABB...AA\"\\n\"BBAABBAABB....BBABABABAB..AB\"\\n\\n    Thus, the answer is just (x+y+z)*2.\\n\\n2. X is greater than Y, then we can take x as y+1 because;\\n\"ABABABAB...AABBAABBAA..\" now no more \"AA\" strings can be placed,     hence the maximum value for x can only be y+1.\\n\\n    Thus, the answer is just ((y+1)+x+z)*2.\\n\\n3. Y is greater than X, then the possible string is;\\n\"BBAABBAABB..ABABABAB\" notice that after the last (x+1)th \"BB\" string no more of them can be further placed, hence here the maximum value of y is x+1 only.\\n\\n    Thus, the answer is (x+(x+1)+z)*2.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y){\\n            return (x+y+z)*2;\\n        }\\n        else{\\n            if(y>x){\\n                return (2*x+z+1)*2;\\n            }\\n            else{\\n                return(2*y+z+1)*2;    \\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y){\\n            return (x+y+z)*2;\\n        }\\n        else{\\n            if(y>x){\\n                return (2*x+z+1)*2;\\n            }\\n            else{\\n                return(2*y+z+1)*2;    \\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677721,
                "title": "o-1-c-solution",
                "content": "# Intuition\\nSince no AB can be followed by BB and no AA can be followed by AB its obvious that AA and BB have to be together. Also since AB can occur any time we dont need to think about its occurence since we can just multiply it by 2 and add to our final answer.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind the minimum from the occurence of AA and BB and if they are together just take them both else take min_value + 1 for the other one. \\n\\nFor example: AA occurs 5 times and BB occurs 3 times. we will start by AA followed by BB. AA BB AA BB AA BB AA \\n\\nAfter this no further AA can be added without making AAA because of AB, that\\'s why we take min(no of AA, no of BB), this will give 3 in this case so we take 3 BB and since no of AA is not equal to number of BB we take min_value + 1 which is 3+1=4. so answer will be (3+4)*2 in this example\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans;\\n        int temp=min(x,y);\\n        ans=z+2*temp;\\n        if(x!=y) ans+=1;\\n        ans=ans*2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans;\\n        int temp=min(x,y);\\n        ans=z+2*temp;\\n        if(x!=y) ans+=1;\\n        ans=ans*2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677717,
                "title": "2-lines-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int min=Math.min(x,y);\\n        return x==y?(2*min+z)*2 : (2*min+1+z)*2;\\n    }\\n}\\n```\\n# Explanation\\n##### 1.Find out the minimum value between x & y.\\n##### 2. If x is equal to y then return (2*min+z)*2\\n##### 3. Else return (2*min+1+z)*2\\n\\n# Example 1\\n```\\nConsider x=3, y=5 and z=3:\\n-> We can return (3+4+3)*2=20\\n                  \\u2191 \\u2191 \\u2191\\nvalues     from   x y z\\n```\\n# Example 2\\n```\\nConsider x=4, y=10 and z=2:\\n-> We can return (4+5+10)*2=38\\n                  \\u2191 \\u2191 \\u2191\\nvalues     from   x y z\\n```\\n# Example 3\\n```\\nConsider x=9, y=9 and z=30:\\n-> We can return (9+9+30)*2=96\\n                  \\u2191 \\u2191 \\u2191\\nvalues     from   x y z\\n```\\n\\n# Example 4\\n```\\nConsider x=20, y=9 and z=10:\\n-> We can return (10+9+10)*2=58\\n                  \\u2191 \\u2191 \\u2191\\nvalues     from   x y z\\n```\\n# Example 5\\n```\\nConsider x=23, y=20 and z=30:\\n-> We can return (21+20+30)*2=142\\n                  \\u2191 \\u2191 \\u2191\\nvalues     from   x y z\\nThe minimum value between 23 and 20 is 20.\\n```\\nIf x is not equal to y, the code executes the second part of the conditional statement:\\n(2*min+1+z)*2. \\nSubstituting the values, we get (2x20+1+30)*2 = 142.\\n\\n```\\n# It\\'s Basically a simple Math\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int min=Math.min(x,y);\\n        return x==y?(2*min+z)*2 : (2*min+1+z)*2;\\n    }\\n}\\n```\n```\\nConsider x=3, y=5 and z=3:\\n-> We can return (3+4+3)*2=20\\n                  \\u2191 \\u2191 \\u2191\\nvalues     from   x y z\\n```\n```\\nConsider x=4, y=10 and z=2:\\n-> We can return (4+5+10)*2=38\\n                  \\u2191 \\u2191 \\u2191\\nvalues     from   x y z\\n```\n```\\nConsider x=9, y=9 and z=30:\\n-> We can return (9+9+30)*2=96\\n                  \\u2191 \\u2191 \\u2191\\nvalues     from   x y z\\n```\n```\\nConsider x=20, y=9 and z=10:\\n-> We can return (10+9+10)*2=58\\n                  \\u2191 \\u2191 \\u2191\\nvalues     from   x y z\\n```\n```\\nConsider x=23, y=20 and z=30:\\n-> We can return (21+20+30)*2=142\\n                  \\u2191 \\u2191 \\u2191\\nvalues     from   x y z\\nThe minimum value between 23 and 20 is 20.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677688,
                "title": "beats-100-c-shortest-o-1",
                "content": "```\\nint longestString(int x, int y, int z) {\\n        int cnt=z;\\n        if(x==y) cnt+=2*x;\\n        else cnt+= 1+ 2*min(x,y);\\n        \\n        return 2*cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint longestString(int x, int y, int z) {\\n        int cnt=z;\\n        if(x==y) cnt+=2*x;\\n        else cnt+= 1+ 2*min(x,y);\\n        \\n        return 2*cnt;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677676,
                "title": "c-greedy",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mi = min(x,y);\\n        x -= mi, y -= mi;\\n        mi = mi * 2 + z;\\n        mi += (x > 0 or y > 0);\\n        return mi * 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mi = min(x,y);\\n        x -= mi, y -= mi;\\n        mi = mi * 2 + z;\\n        mi += (x > 0 or y > 0);\\n        return mi * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677625,
                "title": "fastest-o-1-time-and-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans = 0;\\n        ans += z;\\n        int mn = min(x, y);\\n        if(x == y) ans +=(x + y);\\n        else {\\n            ans += mn*2 + 1;\\n        }\\n        return ans * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans = 0;\\n        ans += z;\\n        int mn = min(x, y);\\n        if(x == y) ans +=(x + y);\\n        else {\\n            ans += mn*2 + 1;\\n        }\\n        return ans * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677603,
                "title": "c-o-1-o-1-very-easy",
                "content": "```\\nint longestString(int x, int y, int z)\\n{\\n    // x - AA, y - BB, z - AB\\n    int ans = 0;\\n    int minComb = min(x, y);\\n    if (z == 0)\\n    {\\n        return 4 * minComb;\\n    }\\n\\n    if (x == y)\\n    {\\n        ans = (x + y) * 2;\\n        ans += z * 2;\\n        return ans;\\n    }\\n    ans += 4 * minComb;\\n    ans += 2;\\n    ans += z * 2;\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint longestString(int x, int y, int z)\\n{\\n    // x - AA, y - BB, z - AB\\n    int ans = 0;\\n    int minComb = min(x, y);\\n    if (z == 0)\\n    {\\n        return 4 * minComb;\\n    }\\n\\n    if (x == y)\\n    {\\n        ans = (x + y) * 2;\\n        ans += z * 2;\\n        return ans;\\n    }\\n    ans += 4 * minComb;\\n    ans += 2;\\n    ans += z * 2;\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677581,
                "title": "c-easy-intutive-recur-memo",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mem[4][51][51][51];\\n    int f(int sel,int x,int y,int z){\\n            \\n            if(mem[sel][x][y][z]!=-1) return mem[sel][x][y][z];\\n            int ans = 0;\\n            if(sel==1){\\n               if(y>0) ans = max(ans , 2+f(2,x,y-1,z));\\n            }else if(sel==2){\\n                if(x>0) ans=max(ans, 2+f(1,x-1,y,z));\\n                if(z>0) ans=max(ans, 2+f(3,x,y,z-1));\\n            }else{\\n                if(x>0) ans=max(ans, 2+f(1,x-1,y,z));\\n                if(z>0) ans=max(ans, 2+f(3,x,y,z-1));\\n            }\\n            return mem[sel][x][y][z]=ans;\\n        } \\n\\n\\n\\n    int longestString(int x, int y, int z) {\\n        int ans =0;\\n        memset(mem,-1,sizeof(mem));\\n        ans = max(ans , 2+f(1,x-1,y,z));\\n        ans = max(ans , 2+f(2,x,y-1,z));\\n        ans = max(ans , 2+f(3,x,y,z-1));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mem[4][51][51][51];\\n    int f(int sel,int x,int y,int z){\\n            \\n            if(mem[sel][x][y][z]!=-1) return mem[sel][x][y][z];\\n            int ans = 0;\\n            if(sel==1){\\n               if(y>0) ans = max(ans , 2+f(2,x,y-1,z));\\n            }else if(sel==2){\\n                if(x>0) ans=max(ans, 2+f(1,x-1,y,z));\\n                if(z>0) ans=max(ans, 2+f(3,x,y,z-1));\\n            }else{\\n                if(x>0) ans=max(ans, 2+f(1,x-1,y,z));\\n                if(z>0) ans=max(ans, 2+f(3,x,y,z-1));\\n            }\\n            return mem[sel][x][y][z]=ans;\\n        } \\n\\n\\n\\n    int longestString(int x, int y, int z) {\\n        int ans =0;\\n        memset(mem,-1,sizeof(mem));\\n        ans = max(ans , 2+f(1,x-1,y,z));\\n        ans = max(ans , 2+f(2,x,y-1,z));\\n        ans = max(ans , 2+f(3,x,y,z-1));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677568,
                "title": "o-1-solution-easy-to-understand",
                "content": "The maximum length of the New String can be achieved by arranging \"AA\" and \"BB\" alternatively, as much as possible.\\nAnd after considering \"AA\" and \"BB\" Strings, we can add the remaining \"AB\" Strings to the New String\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int min1 = (x == y) ? 2*min(x, y) : 2*min(x, y) + 1;\\n        min1 *= 2;\\n        min1 += (z*2);\\n        return min1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int min1 = (x == y) ? 2*min(x, y) : 2*min(x, y) + 1;\\n        min1 *= 2;\\n        min1 += (z*2);\\n        return min1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677551,
                "title": "3-line-code-100-fast-c-java-javascript-python3",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If the number of \"AA\" strings (x) is equal to the number of \"BB\" strings (y), concatenate them alternatively, resulting in a length of 4x + 2z.\\n\\n- If x and y are not equal, concatenate the minimum of x and y (mini) pairs of \"AA\" and \"BB\" strings, resulting in a length of 2*mini.\\n\\n- Concatenate one extra \"AA\" and one extra \"BB\" string at the end (2*(mini+1)) to avoid unmatched strings.\\n\\n- Add 2*z for the \"AB\" strings that need to be concatenated.\\n\\n- Return the total length as the maximum possible length of the new string.\\n# Complexity\\nThe **time complexity** is O(1) and the **space complexity** is also O(1).\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y)return (4*x + 2*z);\\n        int mini=min(x,y);\\n        return (2*mini + 2*(mini+1) + 2*z);\\n        \\n    }\\n};\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if (x == y)return (4 * x + 2 * z);\\n        int mini = Math.min(x, y);\\n        return (2 * mini + 2 * (mini + 1) + 2 * z);\\n    }\\n}\\n\\n```\\n\\n# JavaScript\\n```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @param {number} z\\n * @return {number}\\n */\\nvar longestString = function(x, y, z) {\\n    if (x === y)\\n        return (4 * x + 2 * z);\\n    var mini = Math.min(x, y);\\n    return (2 * mini + 2 * (mini + 1) + 2 * z);\\n};\\n\\n```\\n\\n# Python3\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        if x == y:return (4 * x + 2 * z)\\n        mini = min(x, y)\\n        return (2 * mini + 2 * (mini + 1) + 2 * z)\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y)return (4*x + 2*z);\\n        int mini=min(x,y);\\n        return (2*mini + 2*(mini+1) + 2*z);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if (x == y)return (4 * x + 2 * z);\\n        int mini = Math.min(x, y);\\n        return (2 * mini + 2 * (mini + 1) + 2 * z);\\n    }\\n}\\n\\n```\n```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @param {number} z\\n * @return {number}\\n */\\nvar longestString = function(x, y, z) {\\n    if (x === y)\\n        return (4 * x + 2 * z);\\n    var mini = Math.min(x, y);\\n    return (2 * mini + 2 * (mini + 1) + 2 * z);\\n};\\n\\n```\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        if x == y:return (4 * x + 2 * z)\\n        mini = min(x, y)\\n        return (2 * mini + 2 * (mini + 1) + 2 * z)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677499,
                "title": "just-2-lines",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y)return (x+y)*2+z*2;\\n        else return (min(x,y)*2+(min(x,y)+1)*2+z*2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y)return (x+y)*2+z*2;\\n        else return (min(x,y)*2+(min(x,y)+1)*2+z*2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677497,
                "title": "python-dfs-cache",
                "content": "During this beweekly contest leetcode server is down again\\n\\n```python\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n\\n        @cache\\n        def solve(s, aa, bb, ab):\\n            m = 0\\n\\n            if s in (\\'\\', \\'AA\\') and bb > 0:\\n                m = max(m, solve(\\'BB\\', aa, bb - 1, ab) + 2)\\n\\n            if s in (\\'\\', \\'BB\\', \\'AB\\') and aa > 0:\\n                m = max(m, solve(\\'AA\\', aa - 1, bb, ab) + 2)\\n\\n            if s in (\\'\\', \\'BB\\', \\'AB\\') and ab > 0:\\n                m = max(m, solve(\\'AB\\', aa, bb, ab - 1) + 2)\\n\\n            return m\\n\\n        return solve(\\'\\', x, y, z)\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n\\n        @cache\\n        def solve(s, aa, bb, ab):\\n            m = 0\\n\\n            if s in (\\'\\', \\'AA\\') and bb > 0:\\n                m = max(m, solve(\\'BB\\', aa, bb - 1, ab) + 2)\\n\\n            if s in (\\'\\', \\'BB\\', \\'AB\\') and aa > 0:\\n                m = max(m, solve(\\'AA\\', aa - 1, bb, ab) + 2)\\n\\n            if s in (\\'\\', \\'BB\\', \\'AB\\') and ab > 0:\\n                m = max(m, solve(\\'AB\\', aa, bb, ab - 1) + 2)\\n\\n            return m\\n\\n        return solve(\\'\\', x, y, z)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677493,
                "title": "easy-pattern-based",
                "content": "***PLS UPVOTE***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int first, int second, int third) {\\n        int mini=min(first,second);\\n        int x=abs(first-second);\\n        \\n        if(x<=1)\\n        {\\n            return 2*(((first+second+third)));\\n        }\\n        else\\n        \\n            return ((mini*2+1)+third)*2;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int first, int second, int third) {\\n        int mini=min(first,second);\\n        int x=abs(first-second);\\n        \\n        if(x<=1)\\n        {\\n            return 2*(((first+second+third)));\\n        }\\n        else\\n        \\n            return ((mini*2+1)+third)*2;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068106,
                "title": "full-explanation-2-approaches-get-answer-string-o-n-or-direct-answer-o-1",
                "content": "# Method 1 (Create exact string)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s get the pattern here\\n\\nFirst thing to do is AA BB AA BB AA... or BB AA BB AA BB...\\nWe can only do this Min(x, y) times else AAA or BBB will appear.\\n\\nNow whether we should start with AA or BB.\\nStart with AA when x>y, because string will end with BB and you\\'ve extra AA\\'s. So you can append one AA at the end.\\nStart with BB when y>x, because string will end with AA and you\\'ve extra BB\\'s. So you can append one BB at the end.\\nStart with either AA or BB when x===y, because we don\\'t have anything to spare.\\n\\nNow if x!==y then our string starts and ends with same stuff.\\n\\nNow place AB z times at the start if string starts with AA (when x>y), hence ```z(AB) AA...```\\nelse (when y>=x) place AB z times at the end, hence ```....BB, z(AB)```\\n\\n## Code\\n```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @param {number} z\\n * @return {number}\\n */\\n\\nvar longestString = function (x, y, z) {\\n    let res = \\'\\', zStr = \\'\\';\\n    for (let i = 0; i < z; i++)\\n        zStr += \"AB\"\\n\\n    if (x > y) {\\n        for (let i = 0; i < y; i++)\\n            res += \"AABB\"\\n        res = zStr + res + \"AA\"\\n    } else if (y > x) {\\n        for (let i = 0; i < x; i++)\\n            res += \"BBAA\"\\n        res = res + \"BB\" + zStr\\n    } else {\\n        for (let i = 0; i < y; i++)\\n            res += \"AABB\"\\n        res = res + zStr\\n    }\\n\\n    return res.length\\n};\\n```\\n\\n# Method 2 Direct Answer\\n<!-- Describe your approach to solving the problem. -->\\nDirectly the pattern is simply\\n``` (2*Min(x,y) + x===y?0:1 + z)*2 ```\\n\\n## Code\\n```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @param {number} z\\n * @return {number}\\n */\\n\\nvar longestString = function (x, y, z) {\\n    let count = z;\\n    count += 2*Math.min(x, y);\\n    if (x !== y)\\n        count++\\n    return count * 2\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "String",
                    "Brainteaser"
                ],
                "code": "```z(AB) AA...```\n```....BB, z(AB)```\n```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @param {number} z\\n * @return {number}\\n */\\n\\nvar longestString = function (x, y, z) {\\n    let res = \\'\\', zStr = \\'\\';\\n    for (let i = 0; i < z; i++)\\n        zStr += \"AB\"\\n\\n    if (x > y) {\\n        for (let i = 0; i < y; i++)\\n            res += \"AABB\"\\n        res = zStr + res + \"AA\"\\n    } else if (y > x) {\\n        for (let i = 0; i < x; i++)\\n            res += \"BBAA\"\\n        res = res + \"BB\" + zStr\\n    } else {\\n        for (let i = 0; i < y; i++)\\n            res += \"AABB\"\\n        res = res + zStr\\n    }\\n\\n    return res.length\\n};\\n```\n``` (2*Min(x,y) + x===y?0:1 + z)*2 ```\n```\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @param {number} z\\n * @return {number}\\n */\\n\\nvar longestString = function (x, y, z) {\\n    let count = z;\\n    count += 2*Math.min(x, y);\\n    if (x !== y)\\n        count++\\n    return count * 2\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058880,
                "title": "one-liner-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a string where AA and BB are interweaved(to avoid AAA and BBB). Then all AB\\'s can be added to string without creating AAA and BBB.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTotal AA and BB strings that can be interweaved are:\\n2*min(x,y) + 1(if x & y are not same, meaning max(x,y) - min(x,y) > 0).\\nAdd z strings of AB to it as well. The length is now:\\n2*(z + 2*min(x,y) + (max(x,y) > min(x,y))).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return 2*(z + 2*min(x,y) + (max(x,y) > min(x,y)));  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return 2*(z + 2*min(x,y) + (max(x,y) > min(x,y)));  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057771,
                "title": "python-check-your-zipper",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        if y > x + z:\\n            if z > x:\\n                return ( 1 + z - x + ( x * 3 ) ) * 2\\n            elif z <= x:\\n                return ( 1 + ( z * 3 ) + ( ( x - z ) * 2 ) ) * 2\\n        else:\\n            if x > y:\\n                return ( z + y * 2 + 1 ) * 2\\n            elif x < y:\\n                return ( 1 + z + x * 2 ) * 2\\n            elif x == y:\\n                return ( ( z - x ) + ( x * 3 ) ) * 2\\n        \\n        # 20230918\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        if y > x + z:\\n            if z > x:\\n                return ( 1 + z - x + ( x * 3 ) ) * 2\\n            elif z <= x:\\n                return ( 1 + ( z * 3 ) + ( ( x - z ) * 2 ) ) * 2\\n        else:\\n            if x > y:\\n                return ( z + y * 2 + 1 ) * 2\\n            elif x < y:\\n                return ( 1 + z + x * 2 ) * 2\\n            elif x == y:\\n                return ( ( z - x ) + ( x * 3 ) ) * 2\\n        \\n        # 20230918\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049855,
                "title": "based-on-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x==y){\\n            ans=4*x + 2*z;\\n                    }\\n                    else{\\n        int t=max(x,y);\\n        int d=min(x,y);\\n        int s=2*d +1;\\n        int a=2*z;\\n        ans= 2*s + a;}\\n        return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x==y){\\n            ans=4*x + 2*z;\\n                    }\\n                    else{\\n        int t=max(x,y);\\n        int d=min(x,y);\\n        int s=2*d +1;\\n        int a=2*z;\\n        ans= 2*s + a;}\\n        return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026621,
                "title": "1-liner-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int longestString(int x, int y, int z) \\n    {\\n        return (x==y) ? 2*(z+2*x) : 2*(z+min(x,y)*2+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestString(int x, int y, int z) \\n    {\\n        return (x==y) ? 2*(z+2*x) : 2*(z+min(x,y)*2+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011144,
                "title": "c-beats-100-solutions-simplest-easiest-optimal-solution-using-math",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n\\n        if(x == y)\\n            return ((x + y + z) * 2);\\n        \\n        x = min(x, y);\\n        return ((x + x + 1 + z) * 2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n\\n        if(x == y)\\n            return ((x + y + z) * 2);\\n        \\n        x = min(x, y);\\n        return ((x + x + 1 + z) * 2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008107,
                "title": "c-simplest-solution-using-math-in-o-1-time",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n\\n        if(x == y)\\n            return ((x + y + z) * 2);\\n        \\n        x = min(x, y);\\n        return ((x + x + 1 + z) * 2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n\\n        if(x == y)\\n            return ((x + y + z) * 2);\\n        \\n        x = min(x, y);\\n        return ((x + x + 1 + z) * 2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998181,
                "title": "very-veryyyyy-easy-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n\\n        int temp = min(x, y);\\n        int ans = 0;\\n        if(x != y)\\n            ans = temp*4+z*2+2;\\n        else\\n            ans = temp*4+z*2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n\\n        int temp = min(x, y);\\n        int ans = 0;\\n        if(x != y)\\n            ans = temp*4+z*2+2;\\n        else\\n            ans = temp*4+z*2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990052,
                "title": "simple-maths",
                "content": "# Intuition\\nPattern Recognition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int min=Math.min(x,y);\\n        int res=0;\\n        if(x==y){\\n             res=2*min+z;\\n        }\\n        else{\\n             res=2*min+1+z;\\n        }\\n        return res*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int min=Math.min(x,y);\\n        int res=0;\\n        if(x==y){\\n             res=2*min+z;\\n        }\\n        else{\\n             res=2*min+1+z;\\n        }\\n        return res*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990016,
                "title": "c-dp-recursion-and-memorization-easy-to-understand",
                "content": "\\tclass Solution \\n\\t{\\n\\tpublic:\\n\\n\\t\\tint dp[51][51][51][4];\\n\\t\\tint solve(int x,int y,int z,int pre)\\n\\t\\t{\\n\\t\\t\\tif(x <= 0 and y<=0 and z<= 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[x][y][z][pre+1] != -1)\\n\\t\\t\\t\\treturn dp[x][y][z][pre+1] ;\\n\\t\\t\\tint a = 0,b = 0,c = 0;\\n\\n\\t\\t\\tif(pre == -1) // it can start with any one of AA , BB , AB\\n\\t\\t\\t{\\n\\t\\t\\t\\ta = solve(x-1,y,z,0)+2;\\n\\n\\t\\t\\t\\tb = solve(x,y-1,z,1)+2;\\n\\n\\t\\t\\t\\tc = solve(x,y,z-1,2)+2;\\n\\n\\t\\t\\t\\treturn dp[x][y][z][pre+1] = max(a,max(b,c));\\n\\t\\t\\t}\\n\\t\\t\\telse if(pre == 0 and y>0)    //  if previous is AA then we cant use AA and AB so use BB if it is available\\n\\t\\t\\t{\\n\\t\\t\\t\\tb = solve(x,y-1,z,1)+2;\\n\\n\\t\\t\\t\\treturn dp[x][y][z][pre+1]  = b;\\n\\t\\t\\t}\\n\\t\\t\\telse if(pre == 2 || pre == 1) //  if previous is BB or AB then next can be AA or AB if they are available\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(x>0)\\n\\t\\t\\t\\t\\ta = solve(x-1,y,z,0)+2;\\n\\t\\t\\t\\tif(z>0)\\n\\t\\t\\t\\t\\tc = solve(x,y,z-1,2)+2;\\n\\n\\t\\t\\t\\treturn dp[x][y][z][pre+1] = max(a,c);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[x][y][z][pre+1] = 0;  // if we cant use any combination return 0\\n\\t\\t}\\n\\t\\tint longestString(int x, int y, int z) {\\n\\n\\t\\t\\tmemset(dp,-1,sizeof(dp));\\n\\t\\t\\tint ans = solve(x,y,z,-1);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution \\n\\t{\\n\\tpublic:\\n\\n\\t\\tint dp[51][51][51][4];\\n\\t\\tint solve(int x,int y,int z,int pre)\\n\\t\\t{\\n\\t\\t\\tif(x <= 0 and y<=0 and z<= 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3980209,
                "title": "dp-solution-for-practice",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][51][51][2][2];\\n    int helper(int x,int y,int z,int ff,int ss){\\n        if( dp[x][y][z][ff][ss] !=- 1 )return  dp[x][y][z][ff][ss];\\n    \\n        //if previous was AA we can only take BB\\n        if(ff==0 && ss==0){\\n            if(y)return  dp[x][y][z][ff][ss] = 2 + helper(x,y-1,z,1,1);\\n            return  dp[x][y][z][ff][ss] = 0;\\n        }\\n        \\n        //if previous was BB we can take either AA or AB\\n        if(ff==1 && ss==1){\\n            int aa = 0;\\n            if(x)aa = 2 + helper(x-1,y,z,0,0);\\n            int ab = 0;\\n            if(z)ab = 2 + helper(x,y,z-1,0,1);\\n            return  dp[x][y][z][ff][ss] = max(aa,ab);\\n        }\\n        //if previous was AB we can take either AB or AA\\n        int aa = 0;\\n        if(x)aa =  2 + helper(x-1,y,z,0,0);\\n        int ab = 0;\\n        if(z)ab = 2 + helper(x,y,z-1,0,1);\\n        return dp[x][y][z][ff][ss] = max(aa,ab);\\n    }\\n    int longestString(int x, int y, int z) {\\n         \\n        memset(dp,-1,sizeof(dp));\\n        int aa = helper(x-1,y,z,0,0);\\n        int bb = helper(x,y-1,z,1,1);\\n        int ab = helper(x,y,z-1,0,1);\\n        return  2 + max(aa,max(bb,ab));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][51][51][2][2];\\n    int helper(int x,int y,int z,int ff,int ss){\\n        if( dp[x][y][z][ff][ss] !=- 1 )return  dp[x][y][z][ff][ss];\\n    \\n        //if previous was AA we can only take BB\\n        if(ff==0 && ss==0){\\n            if(y)return  dp[x][y][z][ff][ss] = 2 + helper(x,y-1,z,1,1);\\n            return  dp[x][y][z][ff][ss] = 0;\\n        }\\n        \\n        //if previous was BB we can take either AA or AB\\n        if(ff==1 && ss==1){\\n            int aa = 0;\\n            if(x)aa = 2 + helper(x-1,y,z,0,0);\\n            int ab = 0;\\n            if(z)ab = 2 + helper(x,y,z-1,0,1);\\n            return  dp[x][y][z][ff][ss] = max(aa,ab);\\n        }\\n        //if previous was AB we can take either AB or AA\\n        int aa = 0;\\n        if(x)aa =  2 + helper(x-1,y,z,0,0);\\n        int ab = 0;\\n        if(z)ab = 2 + helper(x,y,z-1,0,1);\\n        return dp[x][y][z][ff][ss] = max(aa,ab);\\n    }\\n    int longestString(int x, int y, int z) {\\n         \\n        memset(dp,-1,sizeof(dp));\\n        int aa = helper(x-1,y,z,0,0);\\n        int bb = helper(x,y-1,z,1,1);\\n        int ab = helper(x,y,z-1,0,1);\\n        return  2 + max(aa,max(bb,ab));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978376,
                "title": "one-line-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return z*2 + min(x,y)*4 + 2*(x!=y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return z*2 + min(x,y)*4 + 2*(x!=y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964025,
                "title": "java-1-liner",
                "content": "# Intuition\\n* always going to be including all AB so solution must include z\\n* always going to include as many AA BB pairs as possible, max possible will be the min of x and y * 2 (since we will be pairing them off with each other)\\n* if x is equal to y, then we will pair off all AA and BB available, meaning our AABB sequence is either prepended or appended to our ABAB sequence \\n* if x is not equal to y, then we can fit one more instance of AA or BB, either prepended or appended to our ABAB sequence\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ just doing a math problem homies, not actually traversing anything\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ no extra space needed, no stack space or variable allocation either, there may be some in Math.min library implementation but still constant\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        return 2*(z + (Math.min(x, y)*2) + (x!= y ? 1 : 0)); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        return 2*(z + (Math.min(x, y)*2) + (x!= y ? 1 : 0)); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934206,
                "title": "simple-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(1)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        \\n        int ans = 0;\\n\\n        if(abs(x-y)==1 || abs(x-y)==0){\\n\\n            return (x*2) + (y*2) + (z*2);\\n\\n        }\\n        \\n        ans  = (min(x,y)+1)*2+(min(x,y)*2)+z*2;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        \\n        int ans = 0;\\n\\n        if(abs(x-y)==1 || abs(x-y)==0){\\n\\n            return (x*2) + (y*2) + (z*2);\\n\\n        }\\n        \\n        ans  = (min(x,y)+1)*2+(min(x,y)*2)+z*2;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917145,
                "title": "java-simple-solution-math-trick-pattern-analysis",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(x == y){\\n            return 2 * (x + y + z);\\n        }\\n\\n        if(x > y){\\n            return 2 * (y + y + 1 + z);\\n        }\\n        \\n        return 2 * (x + x + 1 + z);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(x == y){\\n            return 2 * (x + y + z);\\n        }\\n\\n        if(x > y){\\n            return 2 * (y + y + 1 + z);\\n        }\\n        \\n        return 2 * (x + x + 1 + z);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916805,
                "title": "easiest-and-sexiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int a=0;\\n        if(x<y){\\n            a=(2*x+1+z)*2;\\n        }\\n       else if(x>y){\\n            a=(2*y+1+z)*2;\\n        }\\n        else{\\n            a=(x+y+z)*2;\\n        }\\nreturn a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int a=0;\\n        if(x<y){\\n            a=(2*x+1+z)*2;\\n        }\\n       else if(x>y){\\n            a=(2*y+1+z)*2;\\n        }\\n        else{\\n            a=(x+y+z)*2;\\n        }\\nreturn a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910716,
                "title": "single-line-solution-o-1-tc-o-1-sc-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n\\n        // bool ab = false;\\n        // if( x > y)\\n        // {\\n        //     ab = true;\\n        // }\\n\\n        // int mn = min(x,y);\\n        // int gap = abs(y-x);\\n\\n        // string ans =\"\";\\n\\n        // if(z >= mn)\\n        // {\\n        //     for(int i = 0 ;i < mn;i++) ans+=\"AABBAB\";\\n        //     for(int i = 0 ; i < (z-mn);i++)ans+=\"AB\";\\n        // }\\n        // if(z < mn)\\n        // {\\n        //     for(int i = 0 ;i < z;i++) ans+=\"AABBAB\";\\n        //     for(int i = 0 ; i < (mn-z);i++)ans+=\"AABB\";\\n        // }\\n\\n        // if(ab == true)\\n        // {\\n        //     ans +=\"AA\";\\n        // }\\n        // if(x==y) return ans.length();\\n\\n        // if(ab == false)\\n        // {\\n        //     ans = \"BB\"+ans;\\n        // }\\n\\n        // return ans.length();\\n\\n        return ((x==y)?0:2) + 4*min(x,y) + 2*z;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n\\n        // bool ab = false;\\n        // if( x > y)\\n        // {\\n        //     ab = true;\\n        // }\\n\\n        // int mn = min(x,y);\\n        // int gap = abs(y-x);\\n\\n        // string ans =\"\";\\n\\n        // if(z >= mn)\\n        // {\\n        //     for(int i = 0 ;i < mn;i++) ans+=\"AABBAB\";\\n        //     for(int i = 0 ; i < (z-mn);i++)ans+=\"AB\";\\n        // }\\n        // if(z < mn)\\n        // {\\n        //     for(int i = 0 ;i < z;i++) ans+=\"AABBAB\";\\n        //     for(int i = 0 ; i < (mn-z);i++)ans+=\"AABB\";\\n        // }\\n\\n        // if(ab == true)\\n        // {\\n        //     ans +=\"AA\";\\n        // }\\n        // if(x==y) return ans.length();\\n\\n        // if(ab == false)\\n        // {\\n        //     ans = \"BB\"+ans;\\n        // }\\n\\n        // return ans.length();\\n\\n        return ((x==y)?0:2) + 4*min(x,y) + 2*z;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909460,
                "title": "java-beats-100-math-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n- Space complexity:\\n$$O(1)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(x>y){\\n            return 2*y + 2*(y+1) + 2*z;//exhaust all \\'y\\'s, add one extra \\'AA\\' at end, add all \\'z\\'s till exhausted.\\n        }\\n        else if(y>x){\\n            return 2*x +2*(x+1) +2*z;//first exhaust all \\'z\\'s,exhaust all \\'AA\\'s, add one \\'BB\\' at end.\\n        }\\n        else{\\n            return 2*(x+y+z); //add all \\'AA\\'s,\\'BB\\'s and \\'AB\\'s.\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(x>y){\\n            return 2*y + 2*(y+1) + 2*z;//exhaust all \\'y\\'s, add one extra \\'AA\\' at end, add all \\'z\\'s till exhausted.\\n        }\\n        else if(y>x){\\n            return 2*x +2*(x+1) +2*z;//first exhaust all \\'z\\'s,exhaust all \\'AA\\'s, add one \\'BB\\' at end.\\n        }\\n        else{\\n            return 2*(x+y+z); //add all \\'AA\\'s,\\'BB\\'s and \\'AB\\'s.\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901369,
                "title": "java-o-1-1-line-math-solution",
                "content": "# Intuition\\nSince all values are >= 1, then we don\\'t have to think about 0 cases.\\nThe thing is that we can always use all \"AB\"s;\\n\\nSo, the only thing we have to think about is the difference between x and y. If they are equal, that means that we can use all occurences so we just sum x, y, and z and multiply by 2. Else, we just need to find the minimum between x and y, let it be **min**. \\n\\nAfter that we do the following:\\nmin + min + 1 + z and all of this multiplied by 2.\\nmin + min = min * 2 => min * 2 + 1 + z. \\n\\n\\nExample, x = 5, y = 2, z = 6.\\nThe **min** here is 2. So, min + 1 = 3. That means that the max length for x and y we can build from is 3 of x\\'s and 2 of y\\'s => AABBAABBAA and then you append AB 6 time to the beginning, i.e.\\nABABABABABAB + AABBAABBAA => ABABABABABABAABBAABBAA => 22.\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        return x != y ? (Math.min(x, y) * 2 + 1 + z) * 2 : 2 * (x + y + z);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        return x != y ? (Math.min(x, y) * 2 + 1 + z) * 2 : 2 * (x + y + z);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895227,
                "title": "python-simple-logic-40-ms",
                "content": "# Intuition\\nJust think of concatenation of the letters.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf y < x start with \\'BB\\' else start with \\'AA\\'.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        a, b, s = x, y, \\'\\'\\n        if y < x:\\n            for j in range(y):\\n                s += \\'BB\\'\\n                if x != 0:\\n                    s += \\'AA\\'\\n                    x -= 1\\n        else:\\n            for j in range(x):\\n                s += \\'AA\\'\\n                if y != 0:\\n                    s += \\'BB\\'\\n                    y -= 1\\n        for k in range(z):\\n            s += \\'AB\\'\\n        if a == b:\\n            return len(s)\\n        return len(s) + 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        a, b, s = x, y, \\'\\'\\n        if y < x:\\n            for j in range(y):\\n                s += \\'BB\\'\\n                if x != 0:\\n                    s += \\'AA\\'\\n                    x -= 1\\n        else:\\n            for j in range(x):\\n                s += \\'AA\\'\\n                if y != 0:\\n                    s += \\'BB\\'\\n                    y -= 1\\n        for k in range(z):\\n            s += \\'AB\\'\\n        if a == b:\\n            return len(s)\\n        return len(s) + 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844338,
                "title": "simple-math-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmin(x,y)==x then y=x+1 times\\nmin(x,y)==y then x=y+1 times\\nz can be used as many times given\\nsum*2 for string length\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x>y){\\n          ans+=(y+ y+1 + z)*2;\\n        }\\n        else if(x<y){\\n            ans+=(x + x+1 + z)*2;\\n        }\\n        else{\\n            ans+=(x+y+z)*2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x>y){\\n          ans+=(y+ y+1 + z)*2;\\n        }\\n        else if(x<y){\\n            ans+=(x + x+1 + z)*2;\\n        }\\n        else{\\n            ans+=(x+y+z)*2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840128,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x>y){\\n            ans+=y;\\n            ans+=y+1;\\n        }\\n        else if(x<y){\\n            ans+=x;\\n            ans+=x+1;\\n        }\\n        else if(x==y){\\n            ans+= x*2;\\n        }\\n        ans+=z;\\n        return ans*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x>y){\\n            ans+=y;\\n            ans+=y+1;\\n        }\\n        else if(x<y){\\n            ans+=x;\\n            ans+=x+1;\\n        }\\n        else if(x==y){\\n            ans+= x*2;\\n        }\\n        ans+=z;\\n        return ans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834097,
                "title": "1-ms-o-1-time-complexity-solution-and-o-min-x-y-time-complexity-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo conside which type of pair whther AABB or BBAA can make the longest string \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmax1:- considering combinations like AABB types \\nmax2:- considering combinations like BBAA types \\nWhether we have AABBAA types strings( from loop ) , AB pairs will always be a part of final string as ABAB$$AABBAA$$ or \\nif we have BBAABB types strings ( from loop ), AB pairs will always be a partt of final string as $$BBAABB$$ABAB\\nThus max of pairs available in x and y needs to be calculated and z pairs can be added either in front or in back \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1 ms and time complexity is O(MIN(X,Y)) : -1st solution \\nO(1) time complexity solution :- 2nd Solution \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) space complexity\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n      int max1=0; int nx=0; int ny=0;\\n      int max2=0;\\n      nx=x; ny=y;\\n      while(nx>0&&ny>0){\\n          if(nx>0){\\n              if(ny>0){\\n                  nx-=1;\\n                  ny-=1;\\n                  max1+=2;\\n                  max2+=2;\\n              }\\n          }\\n          if(nx<=0&&ny>0)break;\\n          if(ny<=0&&nx>0)break;\\n      }\\n      if(nx>0){\\n          max1+=1;\\n      }\\n      \\n      if(ny>0){\\n          max2+=1;\\n      }\\n      return 2*Math.max(max1,max2)+2*z;       \\n    }\\n\\n}\\n\\n```\\n# Code\\n```\\nSolution 2:- ( same approach just removing the loop  )\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int included_pairs=Math.min(x,y);\\n        int ans=4*included_pairs;\\n        if(x>y||y>x){\\n            ans+=2;\\n        }\\n        ans+=2*z;\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n      int max1=0; int nx=0; int ny=0;\\n      int max2=0;\\n      nx=x; ny=y;\\n      while(nx>0&&ny>0){\\n          if(nx>0){\\n              if(ny>0){\\n                  nx-=1;\\n                  ny-=1;\\n                  max1+=2;\\n                  max2+=2;\\n              }\\n          }\\n          if(nx<=0&&ny>0)break;\\n          if(ny<=0&&nx>0)break;\\n      }\\n      if(nx>0){\\n          max1+=1;\\n      }\\n      \\n      if(ny>0){\\n          max2+=1;\\n      }\\n      return 2*Math.max(max1,max2)+2*z;       \\n    }\\n\\n}\\n\\n```\n```\\nSolution 2:- ( same approach just removing the loop  )\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int included_pairs=Math.min(x,y);\\n        int ans=4*included_pairs;\\n        if(x>y||y>x){\\n            ans+=2;\\n        }\\n        ans+=2*z;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831161,
                "title": "1-line-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return ((x < y ? x : y) * 2 + z + (x != y ? 1 : 0)) * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return ((x < y ? x : y) * 2 + z + (x != y ? 1 : 0)) * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820852,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n     if(x == y) return (x + y + z) * 2;\\n     else return (Math.min(x, y) + Math.min(x, y) + 1 + z) * 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n     if(x == y) return (x + y + z) * 2;\\n     else return (Math.min(x, y) + Math.min(x, y) + 1 + z) * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820769,
                "title": "o-1-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if( x== y && y == z ) return 2*(x+y+z);\\n        int pair = z + 2*min(x,y);\\n        if( x != y ) pair++;\\n        return pair*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if( x== y && y == z ) return 2*(x+y+z);\\n        int pair = z + 2*min(x,y);\\n        if( x != y ) pair++;\\n        return pair*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819782,
                "title": "brute-force-approach-c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        \\n        // x --> AA\\n        // y --> BB\\n        // Z --> AB\\n        // POSSIBLITY 1 : AABBAABB ( Starting with AA) --> ..ABABAB AABBAABBAA \\n        // POSSIBLITY 2 : BBAABBAA ( Starting with BB) -->          BB..ABABAB..AABBAA\\n        // AB -> can be added without the concern of reperting of 3 AAAs or BBBs within any possiblity\\n        \\n        // if we start with AA / x\\n        \\n        int ans = 0;\\n        int c1=0,c2=0;\\n        int x1=x;\\n        int y1=y;\\n        \\n        while(x>0 && y>=0)\\n        {\\n            if(y==0)\\n                c1+=1;\\n            else\\n                c1+=2;\\n            x--;\\n            y--;            \\n        }\\n        // cout<<c1<<endl;\\n        ans= max(ans,c1*2+z*2);\\n        \\n        // if we start with BB / y\\n        \\n        x=x1; y=y1;\\n\\n        while(y>0 && x>=0)\\n        {\\n            if(x==0)\\n                c2+=1;\\n            else\\n                c2+=2;\\n            \\n            y--;\\n            x--;            \\n        }\\n        \\n        // cout<<c2<<endl;\\n        return max(ans,c2*2+z*2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        \\n        // x --> AA\\n        // y --> BB\\n        // Z --> AB\\n        // POSSIBLITY 1 : AABBAABB ( Starting with AA) --> ..ABABAB AABBAABBAA \\n        // POSSIBLITY 2 : BBAABBAA ( Starting with BB) -->          BB..ABABAB..AABBAA\\n        // AB -> can be added without the concern of reperting of 3 AAAs or BBBs within any possiblity\\n        \\n        // if we start with AA / x\\n        \\n        int ans = 0;\\n        int c1=0,c2=0;\\n        int x1=x;\\n        int y1=y;\\n        \\n        while(x>0 && y>=0)\\n        {\\n            if(y==0)\\n                c1+=1;\\n            else\\n                c1+=2;\\n            x--;\\n            y--;            \\n        }\\n        // cout<<c1<<endl;\\n        ans= max(ans,c1*2+z*2);\\n        \\n        // if we start with BB / y\\n        \\n        x=x1; y=y1;\\n\\n        while(y>0 && x>=0)\\n        {\\n            if(x==0)\\n                c2+=1;\\n            else\\n                c2+=2;\\n            \\n            y--;\\n            x--;            \\n        }\\n        \\n        // cout<<c2<<endl;\\n        return max(ans,c2*2+z*2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3813665,
                "title": "cpp-time-o-1-beats-100",
                "content": "# Intuition\\nFilling the gaps that we usually do in mathematics permutation and combinations....\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMaths Combinatorics.....\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)--constant\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)--constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) \\n    {\\n        int mini=min(x,y);\\n        int placeAB=mini+1;\\n        int countBB=mini+1;\\n        if(mini==x&&mini==y)\\n        {\\n            countBB--;\\n        }\\n        int countAB=min(placeAB,z);\\n        countAB*=2;\\n        countBB*=2;\\n        int countAA=2*mini;\\n        int ans=(countAA+countBB+countAB);\\n        int more;\\n        if(countAB/2<z)\\n        {\\n            more=2*z-countAB;\\n            ans=ans+more;\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) \\n    {\\n        int mini=min(x,y);\\n        int placeAB=mini+1;\\n        int countBB=mini+1;\\n        if(mini==x&&mini==y)\\n        {\\n            countBB--;\\n        }\\n        int countAB=min(placeAB,z);\\n        countAB*=2;\\n        countBB*=2;\\n        int countAA=2*mini;\\n        int ans=(countAA+countBB+countAB);\\n        int more;\\n        if(countAB/2<z)\\n        {\\n            more=2*z-countAB;\\n            ans=ans+more;\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806336,
                "title": "python3-math-in-depth-explanation-true-math-oneliner",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        return 4 * (min(x, y)) + (2 if x != y else 0) + 2 * z\\n```\\n\\n# Intuition\\nThe first trick is to realize that `AA` can only be followed by `BB`. `BB` can be followed by `AA` or `AB`.\\n\\nHowever, another key trick is that you are guaranteed that `AB` can always fit into the string somewhere.\\n* If a string starts and ends with `A`, you can put all `AB` as the prefix (since `ABABAB` can build a string with itself).\\n* Same idea with a string that starts and ends with `B` - put `ABABAB` at the end.\\n* The only string where you can\\'t do this is a theoretical string that starts with `B` and ends in `A`. Based on the inputs, this would mean that the string MUST be of type `BB...AA`, which means you can put the `ABABAB` after the first `BB`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow that we know that all `AB` must be able to fit into the string, the problem is just a greedy problem to use the maximum number of `AA` and `BB`. The solution is to interleave the two strings, using the one you have more of first. If a > b, start the string with `AA`, if b > a, start the string with `BB`. If a == b, it doesn\\'t matter what you start with.\\n\\n# Tying it all together\\n* For each pair for x and y, create an `AABB/BBAA` pair, `ans = 4 * min(x,y)`\\n* If x != y, you will be able to end the `AABB/BBAA` string with another of the starting pair `ans += 2 if x != y else 0`\\n* Add all the z `AB` strings to the beginning/end `ans += 2 * z`\\n\\n```\\n# Example\\nx = 2, y = 5, z = 1\\n\\n# Solution\\ny > x therefore string starts with BB\\nCreate BB AA BB AA BB (one more BB since y > x)\\nAppend AB, 6 pairs, so answer = 12\\n\\n```\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        return 4 * (min(x, y)) + (2 if x != y else 0) + 2 * z\\n```\n```\\n# Example\\nx = 2, y = 5, z = 1\\n\\n# Solution\\ny > x therefore string starts with BB\\nCreate BB AA BB AA BB (one more BB since y > x)\\nAppend AB, 6 pairs, so answer = 12\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801628,
                "title": "o-1-time-complexity-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int min = 0;\\n\\n        if(x > y) {\\n            min = y;\\n        } else {\\n            min = x;\\n        }\\n\\n        if(x == y) {\\n            return (x + y + z) * 2;\\n        }\\n        return (min + (min+1) + z) * 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int min = 0;\\n\\n        if(x > y) {\\n            min = y;\\n        } else {\\n            min = x;\\n        }\\n\\n        if(x == y) {\\n            return (x + y + z) * 2;\\n        }\\n        return (min + (min+1) + z) * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801578,
                "title": "golang-simple-o-1-solution",
                "content": "# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n# Code\\n```go\\nfunc longestString(x int, y int, z int) int {\\n\\t// N(AB)+AABBAABBAA\\n\\t// BBAABBAABB+N(AB)\\n\\tcost := min(x, y)\\n\\tx -= cost\\n\\ty -= cost\\n\\tlength := 4*cost\\n\\tif x > 0 || y > 0 {\\n\\t\\tlength += 2\\n\\t}\\n\\tlength += 2*z\\n\\treturn length\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc longestString(x int, y int, z int) int {\\n\\t// N(AB)+AABBAABBAA\\n\\t// BBAABBAABB+N(AB)\\n\\tcost := min(x, y)\\n\\tx -= cost\\n\\ty -= cost\\n\\tlength := 4*cost\\n\\tif x > 0 || y > 0 {\\n\\t\\tlength += 2\\n\\t}\\n\\tlength += 2*z\\n\\treturn length\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3792797,
                "title": "1-line-java-with-explanation",
                "content": "# Approach\\nConsider the following rules when dealing with AA, BB, and AB sequences:\\n\\n1. If we have more AA than BB, we will arrange them as AABBAA..BBAA, with one more AA than BB. In this case, we will have at most min(x,y+1) occurrences of AA.\\n\\n2. If we have more BB than AA, we will arrange them as BBAABB..AABB, with one more BB than AA. Consequently, we will have at most min(x+1,y) occurrences of BB.\\n\\n3. We can arrange as many AB sequences as possible, such as ABAB..ABAB. AB can be merged either before AA or after BB. ( x2 )\\n\\nTotal characters = (min(x,y+1) + min(x+1,y)+z) * 2\\n\\nwhere z represents the number of AB sequences.\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        return (Math.min(x,y+1)+Math.min(x+1,y)+z)*2;\\n    }\\n}\\n```\\n\\n*`Please upvote if you find it helpful!`*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        return (Math.min(x,y+1)+Math.min(x+1,y)+z)*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792477,
                "title": "simple-java-soution-beats-99-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(x==y){\\n           return ((x+y+z) * 2);\\n        }\\n        int m = Math.min(x,y);\\n\\n        return (m+m+1+z)*2;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(x==y){\\n           return ((x+y+z) * 2);\\n        }\\n        int m = Math.min(x,y);\\n\\n        return (m+m+1+z)*2;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789355,
                "title": "c-o-1-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Add triplet sequence: min(aa, min(bb, ab))\\n\\n2) Add pair sequence: (aa, bb), (aa, ab), (bb, ab)\\n\\n* for (ab, _) we just add ab, as it\\'s impossible to make valid pair sequences with it.\\n* for (aa, bb), we add min(aa, bb) * 2\\n\\n3) Add remaining single values:\\n* aa/bb we add 1, since we can always put it before/after ab or (aa, bb) pair\\n* for ab we just add ab\\n\\n\\n# Complexity\\n- Time/Space complexity: O(1)\\n\\n```\\ncclass Solution {\\npublic:\\n    int longestString(int aa, int bb, int ab) \\n    {\\n        // Add triplet sequence\\n        int res = min(aa, min(bb, ab)) * 3;\\n        aa -= res/3;\\n        bb -= res/3;\\n        ab -= res/3;\\n\\n        // Add pair sequence\\n        res += min(aa, bb) * 2; // if there\\'re (aa, bb) pairs left, add them\\n\\n        // Add remaining single value\\n        res += ab + ((aa != bb)? 1 : 0); // cater for both ab and aa/bb cases\\n        return res * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ncclass Solution {\\npublic:\\n    int longestString(int aa, int bb, int ab) \\n    {\\n        // Add triplet sequence\\n        int res = min(aa, min(bb, ab)) * 3;\\n        aa -= res/3;\\n        bb -= res/3;\\n        ab -= res/3;\\n\\n        // Add pair sequence\\n        res += min(aa, bb) * 2; // if there\\'re (aa, bb) pairs left, add them\\n\\n        // Add remaining single value\\n        res += ab + ((aa != bb)? 1 : 0); // cater for both ab and aa/bb cases\\n        return res * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785910,
                "title": "go-solution",
                "content": "# Approach\\nSum up the possible combinations\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Code\\n```\\nfunc longestString(x int, y int, z int) int {\\n    ret := 0\\n\\n    // \\'AB\\' can be repeated back to back and counts for 2 each.\\n    ret += z * 2\\n\\n    // AA / BB alternating pairs are 4 long but we can only do it as many times as the lesser of x,y.\\n    aabbCnt := Min(x, y)\\n    ret += aabbCnt * 4\\n    // This is what we have left.\\n    x -= aabbCnt\\n    y -= aabbCnt\\n\\n    // We can add at most one more \\'AA\\'.\\n    if x > 0 {\\n        ret += 2\\n    }\\n    // And likewise \\'BB\\'.\\n    if y > 0 {\\n        ret += 2\\n    }\\n    return ret\\n}\\n\\nfunc Min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestString(x int, y int, z int) int {\\n    ret := 0\\n\\n    // \\'AB\\' can be repeated back to back and counts for 2 each.\\n    ret += z * 2\\n\\n    // AA / BB alternating pairs are 4 long but we can only do it as many times as the lesser of x,y.\\n    aabbCnt := Min(x, y)\\n    ret += aabbCnt * 4\\n    // This is what we have left.\\n    x -= aabbCnt\\n    y -= aabbCnt\\n\\n    // We can add at most one more \\'AA\\'.\\n    if x > 0 {\\n        ret += 2\\n    }\\n    // And likewise \\'BB\\'.\\n    if y > 0 {\\n        ret += 2\\n    }\\n    return ret\\n}\\n\\nfunc Min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781401,
                "title": "best-solution-in-o-1-time-and-space-complexity",
                "content": "# Intuition\\nby observing the pattern we can see there is pattern in this question\\n\\n \\n\\n# Approach\\nAfter Carefully observing the pattern we can see that it doesn\\'t matter the number of x so we simply add twice the number of z\\'s given in the problem. after that we can see if x and y are not equal than we will take one plus min(x,y) and twice it after that we simply twice the number min(x,y) and return it.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return 2*z+2*(x!=y?min(x,y)+1:x)+2*min(x,y);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return 2*z+2*(x!=y?min(x,y)+1:x)+2*min(x,y);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779275,
                "title": "easiest-java-solution-3-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n\\n        if(x > y){\\n            int ans = ((z*2) + (y*2) + ((y+1)*2));\\n            return ans;\\n        } else if(x == y){\\n            int ans = ((x+y+z)*2);\\n            return ans;\\n        } else {\\n            int ans = ((z*2) + (x*2) + ((x+1)*2));\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n\\n        if(x > y){\\n            int ans = ((z*2) + (y*2) + ((y+1)*2));\\n            return ans;\\n        } else if(x == y){\\n            int ans = ((x+y+z)*2);\\n            return ans;\\n        } else {\\n            int ans = ((z*2) + (x*2) + ((x+1)*2));\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775643,
                "title": "c-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestString(int x, int y, int z) => z * 2 + (Math.Min(x, y) * 2 + (x == y ? 0 : 1)) * 2;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestString(int x, int y, int z) => z * 2 + (Math.Min(x, y) * 2 + (x == y ? 0 : 1)) * 2;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775343,
                "title": "master-the-greedy-approach",
                "content": "# Intuition\\nUpon reading this problem, it becomes clear that the constraints for creating the new string make this a great candidate for a greedy algorithm approach. By always making the most optimal decision at each step, we should be able to create the longest new string possible without the forbidden sequences.\\n\\nhttps://youtu.be/IYHl0JH_cV8\\n\\n# Approach\\nThe approach we take in this problem is to use a greedy algorithm. We first find the minimum count between \"AA\" and \"BB\" strings. Then, we try to interleave \"AA\" and \"BB\" strings. If their counts are equal, we simply alternate them and append \"AB\" strings to maximize the length. If one count is larger than the other, we place an extra string from the larger group in between to prevent \"AAA\" or \"BBB\" from appearing. Finally, we add the count of \"AB\" strings. Note that for each \"AA\" or \"BB\", we are counting them as 2 characters.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is $$O(1)$$ as we are performing constant time operations.\\n- Space complexity: The space complexity is also $$O(1)$$, as we are not using any extra data structures.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        mxy = min(x, y)  # Find the minimum count between \"AA\" and \"BB\"\\n        if x == y: \\n            # If \"AA\" and \"BB\" counts are equal, just interleave them and append \"AB\"\\n            return 4 * x + 2 * z \\n        else: \\n            # If one is more, place an extra string from the larger group in between \\n            return 2 * mxy + (mxy + 1) * 2 + 2 * z \\n                                                                                 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        mxy = min(x, y)  # Find the minimum count between \"AA\" and \"BB\"\\n        if x == y: \\n            # If \"AA\" and \"BB\" counts are equal, just interleave them and append \"AB\"\\n            return 4 * x + 2 * z \\n        else: \\n            # If one is more, place an extra string from the larger group in between \\n            return 2 * mxy + (mxy + 1) * 2 + 2 * z \\n                                                                                 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772425,
                "title": "cpp-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int AAStart = 0;\\n        int BBStart = 0;\\n        while(x>0 && y>0){\\n            AAStart+=2;\\n            BBStart+=2;\\n            x--;\\n            y--;\\n        }\\n        if(x>0){\\n            AAStart++;\\n        }\\n        if(y>0){\\n            BBStart++;\\n        }\\n        int ans = max(AAStart,BBStart);\\n        ans += z;\\n        return ans*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int AAStart = 0;\\n        int BBStart = 0;\\n        while(x>0 && y>0){\\n            AAStart+=2;\\n            BBStart+=2;\\n            x--;\\n            y--;\\n        }\\n        if(x>0){\\n            AAStart++;\\n        }\\n        if(y>0){\\n            BBStart++;\\n        }\\n        int ans = max(AAStart,BBStart);\\n        ans += z;\\n        return ans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771730,
                "title": "my-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhahaha.. idk ppl like this one or not..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint longestString(int x, int y, int z){\\n    int ret = 0;\\n    int temp = 0;\\n    if (x>y){\\n        temp = x-y;\\n        ret = y*4;\\n    }\\n    else if(y>x){\\n        ret = x*4;\\n        temp = y-x;\\n    }\\n    else\\n        ret = x*4;\\n\\n    ret += z*2;\\n    if(temp)\\n        ret += 2;\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestString(int x, int y, int z){\\n    int ret = 0;\\n    int temp = 0;\\n    if (x>y){\\n        temp = x-y;\\n        ret = y*4;\\n    }\\n    else if(y>x){\\n        ret = x*4;\\n        temp = y-x;\\n    }\\n    else\\n        ret = x*4;\\n\\n    ret += z*2;\\n    if(temp)\\n        ret += 2;\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3762308,
                "title": "o-1-c-solution-100-fast",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y) return (z+2*min(x,y))*2;\\n        return (z+2*min(x,y)+1)*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Greedy",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y) return (z+2*min(x,y))*2;\\n        return (z+2*min(x,y)+1)*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760086,
                "title": "one-line-solution-faang",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) \\n    {\\n        return (x==y)? 2*(x+y+z) : 2*(2*min(x,y)+1+z);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) \\n    {\\n        return (x==y)? 2*(x+y+z) : 2*(2*min(x,y)+1+z);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760018,
                "title": "one-line-faang-best-for-beginner-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) \\n    {\\n        if(x==y) return 2*(x+y+z);\\n        else if(x>y) return 2*y+2*(y+1)+2*z;\\n        else return 2*x+2*(x+1)+2*z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) \\n    {\\n        if(x==y) return 2*(x+y+z);\\n        else if(x>y) return 2*y+2*(y+1)+2*z;\\n        else return 2*x+2*(x+1)+2*z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757709,
                "title": "one-line-math",
                "content": "# Intuition\\nCLEARLY the question begs for a greedy math approach.\\n\\n# Approach\\n1. Let \\\\<SY> denote a SEQUENCE : SYSYSYSYSY....\\n2. By trial and error we can say that the optimal arrangement is only affected **by values of x and y**. \\n\\nConsider two cases :  \\n    \\n* Case 1 : x = y \\n    \\n  Optimal Arrangement = \\\\<AABB> \\\\<AB>\\n  Number of pairs in \\\\<AABB> = x + y and in \\\\<AB> = z.\\n    \\n* Case 2 : x < y\\n      \\n  Optimal Arrangement = BB \\\\<AB> \\\\<AABB> \\n  Number of pairs in \\\\<AB> = z, BB = 1, \\\\<AABB> = x * 2 \\n    \\n* Case 3 : x > y \\n    \\n    Optimal Arrangement = \\\\<AB> AA \\\\<BBAB> \\n    Number of pairs in \\\\<AB> = z, AA = 1, \\\\<BBAB> = y * 2\\n    \\nTherefore, \\nif(x = y) answer = pairs * 2 = (x + y + z) * 2\\nelse      answer = pairs * 2 = (z + 1 + min(x, y) * 2) * 2\\n    \\n**One liner : answer = (z + (x != y) + (min(x, y) << 1)) << 1**\\n\\nNote : x * 2^k is equivalent to (x << k).\\n\\n# Complexity\\n- Time complexity: $$0(1)$$\\n\\n- Space complexity: $$0(1)$$\\n\\n# Code\\n```\\nclass Solution \\n{    \\n    public:\\n    \\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    \\n    int longestString(int x, int y, int z) \\n    {\\n        return ((min(x, y) << 1) + (x != y) + z) << 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{    \\n    public:\\n    \\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    \\n    int longestString(int x, int y, int z) \\n    {\\n        return ((min(x, y) << 1) + (x != y) + z) << 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756734,
                "title": "python-python3-one-liner-with-explanation",
                "content": "# Intuition\\nWe will reach the longest string if we will alternate x and y (AA and BB), and then add z (AB)\\n# Approach\\nSo if x!=y then we choose minimal of them, multiply by 4 (it will be total length of AA/BB alternatings), add length of additional AA or BB (which equals to 2) and then add total length of AB\\'s (which is 2z). If x==y then we just pick any of them, multiply by 4 and add 2z \\n# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        return min(x,y)*4+2 + z*2 if x!=y else x*4 + z*2\\n```\\nIf this solution was helpful for you - please upvote, I would appreciate it (:",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        return min(x,y)*4+2 + z*2 if x!=y else x*4 + z*2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751583,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n\\n        //String will always be of type (\"BBAABBAABBAABB\" or \"AABBAABBAABBAA\") + \"ABABABABAB\"\\n        int min=Math.min(x, y);\\n\\n        x=x-min; y=y-min;\\n\\n        if(x>0 || y>0) \\n        {\\n            return 2+(min*2*2)+z*2;\\n        }\\n        else\\n        {\\n            return min*2*2+z*2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n\\n        //String will always be of type (\"BBAABBAABBAABB\" or \"AABBAABBAABBAA\") + \"ABABABABAB\"\\n        int min=Math.min(x, y);\\n\\n        x=x-min; y=y-min;\\n\\n        if(x>0 || y>0) \\n        {\\n            return 2+(min*2*2)+z*2;\\n        }\\n        else\\n        {\\n            return min*2*2+z*2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747824,
                "title": "one-line-o-1-solution",
                "content": "# Intuition\\nx and y have a 1 to 1 relationshiop. so take the minimum of them. zs can all go and can take one more from the remainder of the difference between the bigger of the number x or y and smaller between x or y.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return (min(x, y) * 2 + z + ((x != y) > 0)) * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return (min(x, y) * 2 + z + ((x != y) > 0)) * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736251,
                "title": "simple-maths-fastest-c",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    Approach\\n    \\n    Now We can always use all z \"AB\" strings it can be appended to last if BB is greater\\n    else to the front if AA is greater i.e. x > y,\\n    \\n    Now Let\\'s we use temp1 \"AA\" strings where temp1 <= x\\n    and temp2 \"BB\" strings where temp2 <= y\\n    \\n    for Condition to be fulfilled |temp1 - temp2| <= 1\\n    so whatever is minm we will use it for answer to be maximum \\n    \\n    For Eg is x = 5, y = 6, min is 5 so temp1 = 5 and according to mod condition \\n    temp2 can  be 6 so total x and y strings will be (x + y)\\n    \\n    */\\n    int longestString(int x, int y, int z) {\\n        int min_ = min(x, y);\\n        int max_ = max(x, y);\\n        int temp = 2 * min_;\\n        if(max_ > min_){\\n            temp++;\\n        }\\n        return 2*(temp + z);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Approach\\n    \\n    Now We can always use all z \"AB\" strings it can be appended to last if BB is greater\\n    else to the front if AA is greater i.e. x > y,\\n    \\n    Now Let\\'s we use temp1 \"AA\" strings where temp1 <= x\\n    and temp2 \"BB\" strings where temp2 <= y\\n    \\n    for Condition to be fulfilled |temp1 - temp2| <= 1\\n    so whatever is minm we will use it for answer to be maximum \\n    \\n    For Eg is x = 5, y = 6, min is 5 so temp1 = 5 and according to mod condition \\n    temp2 can  be 6 so total x and y strings will be (x + y)\\n    \\n    */\\n    int longestString(int x, int y, int z) {\\n        int min_ = min(x, y);\\n        int max_ = max(x, y);\\n        int temp = 2 * min_;\\n        if(max_ > min_){\\n            temp++;\\n        }\\n        return 2*(temp + z);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732818,
                "title": "c-visualize-all-possible-combination-brain-teaser",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return (z+min(x,y)*2 + (x!=y))*2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return (z+min(x,y)*2 + (x!=y))*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729708,
                "title": "fastest-c-solution-beats-100-time-and-memory",
                "content": "\\n# Approach\\nThe apprach is simple and intuitive:\\n\\n1. Initialize the variable $$res$$ as the maximum value $$z$$ initially.\\n2. Compare $$x$$ and $$y$$:\\n- If $$x$$ is less than $$y$$, add $$x$$ twice (representing two strings of length $$x$$) and one additional character (for the join) to $$res$$.\\n- If $$y$$ is less than $$x$$, add $$y$$ twice (representing two strings of length $$y$$) and one additional character (for the join) to $$res$$.\\n- If $$x$$ and $$y$$ are equal, add $$x$$ and $$y$$ (one string of length $$x$$ and one string of length $$y$$) to $$res$$.\\n3. Multiply $$res$$ by **2** to account for both the joined string and the reversed joined string.\\n4. Return the final value of $$res$$, representing the longest possible resulting string length.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) \\n    {\\n        int res = z;\\n        if(x<y)\\n        {\\n            res = res + x + x + 1;\\n        }\\n        else if(y<x)\\n        {\\n            res = res + y + y + 1;\\n        }\\n        else\\n        {\\n            res = res + x+ y;\\n        }\\n        \\n        res*=2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) \\n    {\\n        int res = z;\\n        if(x<y)\\n        {\\n            res = res + x + x + 1;\\n        }\\n        else if(y<x)\\n        {\\n            res = res + y + y + 1;\\n        }\\n        else\\n        {\\n            res = res + x+ y;\\n        }\\n        \\n        res*=2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724561,
                "title": "2-line-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x>y) x=y+1;\\n        else if(y>x) y=x+1;\\n\\n        return 2*(x+y+z);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x>y) x=y+1;\\n        else if(y>x) y=x+1;\\n\\n        return 2*(x+y+z);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724526,
                "title": "rust-python-constant-time-space-with-explanation",
                "content": "# Intuition\\nLets look at the situation where we do not have `AB` strings. The best string you can do is `AABB` repeated as many times as you can. Then if you have one element spare, you will just add it before (if `BB`) or after the string (if `AA`). If `v = min(x, y)`\\n\\nSo the answer is `4 * v + (2 if x > v or y > v else 0)`.\\n\\nNow what will happen if we have AB strings. We put them one after another `AB..AB` And then add the values after it in the same manner. \\n\\nYou can combine them together with `2 * z + 4 * v` and then add 2 if `x > v or y > v`\\n\\n\\n\\n# Complexity\\n- Time complexity: $O(1)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n\\n```Rust []\\nimpl Solution {\\n  pub fn longest_string(x: i32, y: i32, z: i32) -> i32 {\\n    let v = x.min(y);\\n    let mut res = 2 * z + 4 * v;\\n    if y > v || x > v {\\n      res += 2;\\n    }\\n    return res\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def longestString(self, x: int, y: int, z: int) -> int:\\n    v = min(x, y)\\n    if z == 0:\\n      return 4 * v + (2 if x + y - 2 * v > 0 else 0)\\n    \\n    return z * 2 + 4 * v + (2 if y > v or x > v else 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn longest_string(x: i32, y: i32, z: i32) -> i32 {\\n    let v = x.min(y);\\n    let mut res = 2 * z + 4 * v;\\n    if y > v || x > v {\\n      res += 2;\\n    }\\n    return res\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def longestString(self, x: int, y: int, z: int) -> int:\\n    v = min(x, y)\\n    if z == 0:\\n      return 4 * v + (2 if x + y - 2 * v > 0 else 0)\\n    \\n    return z * 2 + 4 * v + (2 if y > v or x > v else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718191,
                "title": "easiest-approach-possible",
                "content": "# Intuition\\n just saw the pattern \\n\\n# Approach\\n  the \\'aa\\' and \\'bb\\' can be put one on back for other for min(x,y) and the \\'ab\\' can be put as many as available as it is of form \\'abab....\\' and at last if any one of \\'aa\\' or \\'bb\\' is remaing that can be put only once as after that if we put it will come like \\'aaaa....\\' or \\'bbbb....\\'\\n# Complexity\\n- Time complexity:\\n  constant time\\n\\n- Space complexity:\\n  no extra space required\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return 2*(2*(min(x,y))+z+((x!=y)?1:0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return 2*(2*(min(x,y))+z+((x!=y)?1:0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717817,
                "title": "c-100-beats-solution-easy-to-understand-and-short-code",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int len = 2*z;\\n        len += (x == y) ? 2*(x+y) : 4 * min(x,y) + 2;\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int len = 2*z;\\n        len += (x == y) ? 2*(x+y) : 4 * min(x,y) + 2;\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710230,
                "title": "o-1-logic-in-one-line",
                "content": "# Intuition\\nThe problem requires constructing the longest possible string by concatenating \"AA\", \"BB\", and \"AB\" strings while avoiding forbidden substrings. To achieve this, we need to think about the problem with a greedy logic.\\n\\n# Approach\\n1. The formula comprises two parts: `2 * (z + 1 + (x == y))` and `4 * (x >= y ? min(--x, y) : x)`.\\n\\n2. The first part, `2 * (z + 1 + (x == y))`, calculates the maximum length achievable using \"AB\" strings. Here\\'s how it works:\\n   - `(z + 1)` represents the maximum number of \"AB\" strings that can be utilized without creating the forbidden substrings \"AAA\" or \"BBB\". Each \"AB\" string contributes two characters to the new string.\\n   - `(x == y)` checks if the count of \"AA\" strings is equal to that of \"BB\" strings. When they are equal, an extra \"AB\" string can be included without generating forbidden substrings.\\n   - Multiplying the entire expression by 2 yields the total number of characters that can be added using the \"AB\" strings.\\n\\n3. The second part, `4 * (x >= y ? min(--x, y) : x)`, calculates the maximum length achievable using \"AA\" and \"BB\" strings. Here\\'s how it works:\\n   - `(x >= y ? min(--x, y) : x)` checks if the count of \"AA\" strings is greater than or equal to the count of \"BB\" strings. If so, additional \"AA\" strings can be included in the new string.\\n   - `min(--x, y)` subtracts one from the count of \"AA\" strings and appends an equivalent number of \"BB\" strings to the new string. This ensures that the maximum length is not exceeded and forbidden substrings are avoided.\\n   - Multiplying the entire expression by 4 provides the total number of characters that can be added using the \"AA\" and \"BB\" strings.\\n\\n4. Finally, we sum the results of the two parts to obtain the maximum possible length of the new string.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return 2 * (z + 1 + (x == y)) + 4 * (x >= y ? min(--x, y) : x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return 2 * (z + 1 + (x == y)) + 4 * (x >= y ? min(--x, y) : x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705913,
                "title": "java-sol-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705895,
                "title": "easy-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y)\\n            return 2*(min(x,y)*2+z);\\n        return 2*(min(x,y)*2+1+z);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y)\\n            return 2*(min(x,y)*2+z);\\n        return 2*(min(x,y)*2+1+z);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705346,
                "title": "c-esay-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nz can be fully uesd, x only can be followed by y, so compute the max count of x->y \\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mn = min(x, y);\\n        int res = z * 2 + mn * 4;\\n        x -= mn;\\n        y -= mn;\\n        if (x > 0 or y > 0) {\\n            res += 2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mn = min(x, y);\\n        int res = z * 2 + mn * 4;\\n        x -= mn;\\n        y -= mn;\\n        if (x > 0 or y > 0) {\\n            res += 2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704825,
                "title": "python-o-1-approach-with-intuition",
                "content": "# Intuition\\n- Lets start from ...... we have \"X -> AA\", \"Y -> BB\", \"Z -> AB\"\\n\\n- Observation 1 - No Matter how large the value of Z can be, we can always have \\'Z\\' number of concatenations (ABABABABABABAB...... so it can never have \"AAA\" or \"BBB\")\\n\\n- Observation 2 - If the X and Y values are equal, then we can alternatively concatenate \\'AA\\'  and \\'BB\\' to fully utilize the strings available (X=2,Y=2 => AABBAABB...).\\n\\n- Observation 3 - If X and Y values are not equal, Then we can never utilize the entire X and Y. We can only have \"N + 1\" (N = min(x,y)) concateantions.\\n \\nExample: X = 100 , Y = 1, Z = 1\\n\\nIn this case we can have N + 1 i.e. 2 concatenations (min(X,Y) => 1).\\ni.e  \"AABBAA\". Beyond this any concatenations has to be from X which is not allowed as it will create duplicates which will violate the condition.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        ans = ( min(x,y) * 2) + (( min(x,y)+1) * 2) + (z*2)\\n        return ans if x != y else ans - 2\\n\\n\\n                        \\n                    \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        ans = ( min(x,y) * 2) + (( min(x,y)+1) * 2) + (z*2)\\n        return ans if x != y else ans - 2\\n\\n\\n                        \\n                    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704789,
                "title": "shortest-code-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int res=(z+min(x,y)*2)*2;\\n        if(x==y) return res;\\n        return res+2;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int res=(z+min(x,y)*2)*2;\\n        if(x==y) return res;\\n        return res+2;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703264,
                "title": "easy-recursion-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int max = 0;\\n    public int longestString(int x, int y, int z) {\\n        recurance(\"x\",x-1,y,z);\\n        recurance(\"y\",x,y-1,z);\\n        recurance(\"z\",x,y,z-1);\\n        return max*2;\\n    }\\n    \\n    public void recurance(String k,int x,int y,int z){\\n        if(x == 0 && y == 0 && z== 0){\\n            max = Math.max(max,k.length());\\n            return;\\n        }\\n        if(k.charAt(k.length() - 1) == \\'x\\'){\\n            if(y == 0){\\n                max = Math.max(max,k.length());\\n                return;\\n            }\\n            recurance(k + \"y\",x,y-1,z);\\n        }\\n        if(k.charAt(k.length() - 1) == \\'y\\' || k.charAt(k.length() - 1) == \\'z\\'){\\n            if(z == 0 && x == 0){\\n                max = Math.max(max,k.length());\\n                return;\\n            }\\n            else if(z == 0){\\n                recurance(k + \\'x\\',x-1,y,z);\\n            }\\n            else{\\n                recurance(k + \\'z\\',x,y,z-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int longestString(int x, int y, int z) {\\n        recurance(\"x\",x-1,y,z);\\n        recurance(\"y\",x,y-1,z);\\n        recurance(\"z\",x,y,z-1);\\n        return max*2;\\n    }\\n    \\n    public void recurance(String k,int x,int y,int z){\\n        if(x == 0 && y == 0 && z== 0){\\n            max = Math.max(max,k.length());\\n            return;\\n        }\\n        if(k.charAt(k.length() - 1) == \\'x\\'){\\n            if(y == 0){\\n                max = Math.max(max,k.length());\\n                return;\\n            }\\n            recurance(k + \"y\",x,y-1,z);\\n        }\\n        if(k.charAt(k.length() - 1) == \\'y\\' || k.charAt(k.length() - 1) == \\'z\\'){\\n            if(z == 0 && x == 0){\\n                max = Math.max(max,k.length());\\n                return;\\n            }\\n            else if(z == 0){\\n                recurance(k + \\'x\\',x-1,y,z);\\n            }\\n            else{\\n                recurance(k + \\'z\\',x,y,z-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703216,
                "title": "using-basic-math-c-o-1-space-and-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can solve using basic math\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nidea is we can keep AB AA and BB AB side to side,\\ncase 1 : so if number of BB > number of AA ,then we arrange BB and AA alternative and BB will be present at both ends,so answer can be (count of AA + count of AA+1+ count of AB)\\nex : BB AA BB.... BB AB AB ...\\ncase 2 : same as above when AA > BB count ,answer will be (count of BB + count of BB +1 + count of AB)\\nex : AB AB ..AA BB AA BB ... AA \\ncase 3: when AA count == BB count, then we will get sequence as AA,BB,AA,BB ... so on ,we can keep AB\\'s at the starting,or we can even think vice verse\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y)return 2*(x+y+z);\\n        else if(x<y)return 2*(x+x+1+z);\\n        else return 2*(y+y+1+z);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y)return 2*(x+y+z);\\n        else if(x<y)return 2*(x+x+1+z);\\n        else return 2*(y+y+1+z);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702948,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=0;\\n        int mini=min(min(x,y),z);\\n        x-=mini;\\n        y-=mini;\\n        z-=mini;\\n       \\n        ans+=mini*3*2;\\n        \\n        if(z==0){\\n            \\n            int m=min(x,y);\\n            ans+=m*2*2;\\n            x-=m;y-=m;\\n            if(x>0 || y>0) ans+=2;\\n        }\\n        else if(z!=0){\\n           \\n            ans+=z*2;\\n            if(x>0 || y>0) ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=0;\\n        int mini=min(min(x,y),z);\\n        x-=mini;\\n        y-=mini;\\n        z-=mini;\\n       \\n        ans+=mini*3*2;\\n        \\n        if(z==0){\\n            \\n            int m=min(x,y);\\n            ans+=m*2*2;\\n            x-=m;y-=m;\\n            if(x>0 || y>0) ans+=2;\\n        }\\n        else if(z!=0){\\n           \\n            ans+=z*2;\\n            if(x>0 || y>0) ans+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700336,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn longest_string(mut x: i32, mut y: i32, mut z: i32) -> i32 {\\n        let t = x.min(y).min(z);\\n        let mut count = t * 3;\\n        x -= t;\\n        y -= t;\\n        z -= t;\\n        if x == 0 {\\n            count += y.min(1) + z;\\n        } else if y == 0 {\\n            count += x.min(1) + z;\\n        } else {\\n            let t = x.min(y);\\n            count += t * 2;\\n            x -= t;\\n            y -= t;\\n            count += x.min(1) + y.min(1);\\n        }\\n        count * 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_string(mut x: i32, mut y: i32, mut z: i32) -> i32 {\\n        let t = x.min(y).min(z);\\n        let mut count = t * 3;\\n        x -= t;\\n        y -= t;\\n        z -= t;\\n        if x == 0 {\\n            count += y.min(1) + z;\\n        } else if y == 0 {\\n            count += x.min(1) + z;\\n        } else {\\n            let t = x.min(y);\\n            count += t * 2;\\n            x -= t;\\n            y -= t;\\n            count += x.min(1) + y.min(1);\\n        }\\n        count * 2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3700193,
                "title": "java-return-x-y-x-1-math-min-x-y-1-1-z-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int longestString(int x, int y, int z) {\\n    return ((x == y ? x<<1 : (Math.min(x,y)<<1) + 1) + z)<<1;       \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int longestString(int x, int y, int z) {\\n    return ((x == y ? x<<1 : (Math.min(x,y)<<1) + 1) + z)<<1;       \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699498,
                "title": "greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int d = 0;\\n        if (x != y) d = 1;\\n        return 2*(2*min(x,y)+d)+2*z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int d = 0;\\n        if (x != y) d = 1;\\n        return 2*(2*min(x,y)+d)+2*z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696866,
                "title": "tc-o-1-beats-99-93-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We can see that the elements in `z` will always occur, so the length of string will be z*2 for sure.\\n- Now We have to check which of x and y is minimum, take that element and multiply it by 4\\n- - Let\\'s understand this by example: We have x = 2 y = 4\\n- - We can write BB AA BB AA BB, here all elements of x occured and y elements occured x + 2.\\n- - So after noticing this we can get the length as `(z*2) + min(x,y)*4 + 2`\\n- Now let\\'s discuss one edge case what if x and y are equal\\n- - x = 3 y = 3\\n- - Then AA BB AA BB AA BB, All the elements will occur same so for that we can say the maximum length is `(z*2 + x*4)`\\n- return the count value.\\n- The code is given below.\\n****\\n***LEMME KNOW YOU FOUND THIS SOLUTION HELPFUL***\\n***\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int count = (z * 2);\\n        int min = Math.min(x,y);\\n        if(x == y){\\n            count = count + x*4;\\n        }else{\\n            count = count + min*4 + 2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int count = (z * 2);\\n        int min = Math.min(x,y);\\n        if(x == y){\\n            count = count + x*4;\\n        }else{\\n            count = count + min*4 + 2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696697,
                "title": "python-simple-python-solution-using-greedy",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 64 ms, faster than 25.03% of Python3 online submissions for Construct the Longest New String.\\n# Memory Usage: 16.2 MB, less than 85.57% of Python3 online submissions for Construct the Longest New String.\\n\\n\\tclass Solution:\\n\\t\\tdef longestString(self, x: int, y: int, z: int) -> int:\\n\\n\\t\\t\\tresult , position = \\'\\' , \\'\\'\\n\\n\\t\\t\\tz_string = \\'AB\\' * z\\n\\n\\t\\t\\tif x > y:\\n\\n\\t\\t\\t\\tfor count in range(y + 1):\\n\\t\\t\\t\\t\\tresult = result + \\'AABB\\'\\n\\n\\t\\t\\t\\tposition = \\'start\\'\\n\\t\\t\\t\\tresult = result[:-2]\\n\\n\\t\\t\\telif x < y:\\n\\n\\t\\t\\t\\tfor count in range(x + 1):\\n\\t\\t\\t\\t\\tresult = result + \\'BBAA\\'\\n\\n\\t\\t\\t\\tposition = \\'end\\'\\n\\t\\t\\t\\tresult = result[:-2]\\n\\n\\t\\t\\telse:\\n\\t\\t\\t\\tfor count in range(x):\\n\\t\\t\\t\\t\\tresult = result + \\'BBAA\\'\\n\\n\\t\\t\\t\\tposition = \\'end\\'\\n\\n\\t\\t\\tif position == \\'start\\':\\n\\n\\t\\t\\t\\tresult = z_string + result\\n\\n\\t\\t\\tif position == \\'end\\':\\n\\n\\t\\t\\t\\tresult = result + z_string\\n\\n\\t\\t\\treturn len(result)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 64 ms, faster than 25.03% of Python3 online submissions for Construct the Longest New String.\\n# Memory Usage: 16.2 MB, less than 85.57% of Python3 online submissions for Construct the Longest New String.\\n\\n\\tclass Solution:\\n\\t\\tdef longestString(self, x: int, y: int, z: int) -> int:\\n\\n\\t\\t\\tresult , position = \\'\\' , \\'\\'\\n\\n\\t\\t\\tz_string = \\'AB\\' * z\\n\\n\\t\\t\\tif x > y:\\n\\n\\t\\t\\t\\tfor count in range(y + 1):\\n\\t\\t\\t\\t\\tresult = result + \\'AABB\\'\\n\\n\\t\\t\\t\\tposition = \\'start\\'\\n\\t\\t\\t\\tresult = result[:-2]\\n\\n\\t\\t\\telif x < y:\\n\\n\\t\\t\\t\\tfor count in range(x + 1):\\n\\t\\t\\t\\t\\tresult = result + \\'BBAA\\'\\n\\n\\t\\t\\t\\tposition = \\'end\\'\\n\\t\\t\\t\\tresult = result[:-2]\\n\\n\\t\\t\\telse:\\n\\t\\t\\t\\tfor count in range(x):\\n\\t\\t\\t\\t\\tresult = result + \\'BBAA\\'\\n\\n\\t\\t\\t\\tposition = \\'end\\'\\n\\n\\t\\t\\tif position == \\'start\\':\\n\\n\\t\\t\\t\\tresult = z_string + result\\n\\n\\t\\t\\tif position == \\'end\\':\\n\\n\\t\\t\\t\\tresult = result + z_string\\n\\n\\t\\t\\treturn len(result)\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3695760,
                "title": "100-c-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y){\\n            return (2*x+z)*2;\\n        }\\n        else{\\n            int mini = min(x,y);\\n            return ((2*mini) + 1+z)*2;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(x==y){\\n            return (2*x+z)*2;\\n        }\\n        else{\\n            int mini = min(x,y);\\n            return ((2*mini) + 1+z)*2;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695132,
                "title": "with-explanation-o-1-single-line-2ms-beats-100",
                "content": "\\n# Approach\\n- Since \"AB\" can be added as many times we want we will never get \"AAA\" / \"BBB\" we\\'ll just add all the given z(\"AB\").\\n- To add \"AA\" or \"BB\" we need we either choose \"AA\" at first or \"BB\" no matter what we will get\"AABB\" or \"BBAA\" .\\n- To add further more \"AA\" or \"BB\" we need both of them to continue further .\\n- So maximum pair we can make is that minimum number out of them.\\n- And one more \"AA\" or \"BB\" can be added after all pairs are done if here is any x or y left.\\n- Meaning \"AABBAABB\" this string has two pair we can add one more AA or BB if any single one of them is left at the begining or at the end.\\n- After all the \"AA\" and \"BB\" is left we can add all the \"AB\" since it will not break the pattern.\\n- Both the given below program does the same work but second one is easy to understand.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n class Solution {\\n    public int longestString(int x, int y, int z) {\\n        return (Math.min(x,y)*2+z)*2 + ((x==y)?0:2);\\n    }\\n}\\n```\\n# Code\\n```\\n  class Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(x<y)\\n        {\\n            return (x+x+1+z)*2;\\n        }\\n        else if(x>y)\\n        {\\n            return (y+y+1+z)*2;\\n        }\\n        else\\n        {\\n            return (x+y+z)*2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution {\\n    public int longestString(int x, int y, int z) {\\n        return (Math.min(x,y)*2+z)*2 + ((x==y)?0:2);\\n    }\\n}\\n```\n```\\n  class Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(x<y)\\n        {\\n            return (x+x+1+z)*2;\\n        }\\n        else if(x>y)\\n        {\\n            return (y+y+1+z)*2;\\n        }\\n        else\\n        {\\n            return (x+y+z)*2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694377,
                "title": "easy-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int a=min(x,y);\\n        int c=0;\\n        if(x!=y)c=1;\\n        return(a+a+c+z)*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int a=min(x,y);\\n        int c=0;\\n        if(x!=y)c=1;\\n        return(a+a+c+z)*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694372,
                "title": "formula",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        if x == y:\\n            return (x + y + z) * 2\\n        else:\\n            return (min(x,y)*2 + 1 + z) * 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        if x == y:\\n            return (x + y + z) * 2\\n        else:\\n            return (min(x,y)*2 + 1 + z) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694006,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ct = z;\\n        int tp = min(x, y);\\n        if(x!=y) ct++;\\n        tp*=2;\\n        ct+=tp;\\n        return ct*2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ct = z;\\n        int tp = min(x, y);\\n        if(x!=y) ct++;\\n        tp*=2;\\n        ct+=tp;\\n        return ct*2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691790,
                "title": "o-1-solution-to-construct-the-longest-new-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans;\\n        if(x==y)\\n        {\\n            ans = 2*(x+y) + 2*z;\\n        }\\n        else if(x>y)\\n        {\\n            ans = 4*y + 2;\\n            x -= (y+1);\\n            ans += 2*z;\\n        }\\n        else\\n        {\\n            ans = 4*x + 2;\\n            y -= (x+1);\\n            ans += 2*z;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/98db2cbb-251c-42ea-a43d-552e1e10db78_1687934813.7676961.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans;\\n        if(x==y)\\n        {\\n            ans = 2*(x+y) + 2*z;\\n        }\\n        else if(x>y)\\n        {\\n            ans = 4*y + 2;\\n            x -= (y+1);\\n            ans += 2*z;\\n        }\\n        else\\n        {\\n            ans = 4*x + 2;\\n            y -= (x+1);\\n            ans += 2*z;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691629,
                "title": "one-line-solution-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs expalined in hint\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAlways include z times 2 + Min of (x, y) times (2+2)+ One time 2 if x!=y.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n  \\n     public int longestString(int x, int y, int z) {\\n      \\n       return (z*2 + ( Math.min(x, y) * 4) + (x!=y ? 2: 0));\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n  \\n     public int longestString(int x, int y, int z) {\\n      \\n       return (z*2 + ( Math.min(x, y) * 4) + (x!=y ? 2: 0));\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691199,
                "title": "java-code-with-o-1-runtime",
                "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int count = z*2;\\n        if(x>y) {\\n            count += y*4+2;\\n        }\\n        else if(x<y) count += x*4+2;\\n        else count += x*4;\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int count = z*2;\\n        if(x>y) {\\n            count += y*4+2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3691157,
                "title": "editorial-with-example-well-explained-step-by-step",
                "content": "# Intuition:\\nThe code seems to calculate the length of the longest string based on the given input values `x`, `y`, and `z`.\\n\\n# Approach:\\n1. The code starts by finding the minimum value between `x` and `y` and assigns it to variable `a`.\\n2. It then increments `a` by 1 and assigns the result to variable `b`.\\n3. The code checks if `x` is equal to `y`. If they are equal, it assigns `a` to `b`.\\n4. It calculates `c` as the sum of `a`, `b`, and `z`.\\n5. Finally, the code calculates the result by multiplying `c` by 2 and assigns it to `ans`, which is then returned.\\n\\n# Example\\nLet\\'s consider an example with `x = 3`, `y = 4`, and `z = 2`.\\n\\nStep 1: Finding the minimum value between `x` and `y`.\\n```\\na = min(3, 4) = 3\\n```\\n\\nStep 2: Incrementing `a` by 1 and assigning it to `b`.\\n```\\nb = a + 1 = 3 + 1 = 4\\n```\\n\\nStep 3: Checking if `x` is equal to `y`. Since they are not equal (`3 != 4`), `b` remains the same.\\n```\\nb = 4\\n```\\n\\nStep 4: Calculating `c` as the sum of `a`, `b`, and `z`.\\n```\\nc = a + b + z = 3 + 4 + 2 = 9\\n```\\n\\nStep 5: Calculating the result by multiplying `c` by 2 and assigning it to `ans`.\\n```\\nans = 2 * c = 2 * 9 = 18\\n```\\n\\nFinal Result:\\nThe longest string length for the given values `x = 3`, `y = 4`, and `z = 2` is `18`.\\n\\nPictorial Representation:\\n```\\n                    a = 3\\n                   /   \\\\\\n                  /     \\\\\\n                 x = 3   y = 4\\n                            \\\\\\n                             b = 4\\n                              |\\n                             x == y?\\n                              |\\n                            No\\n                              |\\n                    c = a + b + z = 3 + 4 + 2 = 9\\n                              |\\n                 ans = 2 * c = 2 * 9 = 18\\n```\\n\\nI hope this visual representation helps you understand the steps involved in the code.\\n\\n# Complexity:\\n- Time complexity: The code has a constant time complexity of O(1) since it performs a fixed number of operations regardless of the input values. The time complexity does not depend on the size of `x`, `y`, or `z`.\\n- Space complexity: The code has a space complexity of O(1) as it only uses a constant amount of memory to store variables `a`, `b`, `c`, and `ans`. The space used does not increase with the input size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z)\\n    {\\n        int a=min(x,y);\\n        int b=a+1;\\n        if(x==y)b=a;\\n        int c=a+b+z;\\n        int ans=2*c;\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\na = min(3, 4) = 3\\n```\n```\\nb = a + 1 = 3 + 1 = 4\\n```\n```\\nb = 4\\n```\n```\\nc = a + b + z = 3 + 4 + 2 = 9\\n```\n```\\nans = 2 * c = 2 * 9 = 18\\n```\n```\\n                    a = 3\\n                   /   \\\\\\n                  /     \\\\\\n                 x = 3   y = 4\\n                            \\\\\\n                             b = 4\\n                              |\\n                             x == y?\\n                              |\\n                            No\\n                              |\\n                    c = a + b + z = 3 + 4 + 2 = 9\\n                              |\\n                 ans = 2 * c = 2 * 9 = 18\\n```\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z)\\n    {\\n        int a=min(x,y);\\n        int b=a+1;\\n        if(x==y)b=a;\\n        int c=a+b+z;\\n        int ans=2*c;\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690780,
                "title": "java-topdown-bottomup-dp",
                "content": "# Code\\n## Top Down\\n```\\n    class Solution {\\n\\n        Integer[][][][] memo;\\n\\n        public int longestString(int x, int y, int z) {\\n            memo = new Integer[3][x + 1][y + 1][z + 1];\\n            return Math.max(Math.max(dp(0, x, y, z), dp(1, x, y, z)), dp(2, x, y, z));\\n        }\\n\\n        // end: 0 with AA, 1 with BB, 2 with AB\\n        // x: AA, y: BB, z: AB\\n        int dp(int end, int x, int y, int z) { // dp() - max len with x,y,z ending at \\'end\\'\\n            if (x + y + z == 0) return 0;\\n            if (memo[end][x][y][z] != null) return memo[end][x][y][z];\\n\\n            int len = 0;\\n            if (end != 0 && x > 0) len = Math.max(len, 2 + dp(0, x - 1, y, z)); // BB+AA, AB+AA\\n            if (end == 0 && y > 0) len = Math.max(len, 2 + dp(1, x, y - 1, z)); // AA+BB\\n            if (end != 0 && z > 0) len = Math.max(len, 2 + dp(2, x, y, z - 1)); // BB+AB, AB+AB\\n\\n            return memo[end][x][y][z] = len;\\n        }\\n    }\\n```\\n\\n## BottomUp\\n```\\nclass Solution {\\n\\n    // x=2,y=5,z=1\\n        // BotUp: 0,0,0; 1,0,0; 0,1,0; 0,0,1; 1,1,0; 0,1,1; 1,1,1; 2,1,1; 1,2,1; 1,1,2;\\n        // 4 nested loops: over x/y/z/end, 0,0,1;0,0,2;0,0,3;0,0,4;0,1,1;0,1,2;etc\\n        public int longestString(int maxX, int maxY, int maxZ) {\\n            var dp = new int[maxX + 1][maxY + 1][maxZ + 1][3];\\n            for (int x = 0; x <= maxX; x++) { // x: AA, y: BB, z: AB\\n                for (int y = 0; y <= maxY; y++) {\\n                    for (int z = 0; z <= maxZ; z++) {\\n                        for (int end = 0; end < 3; end++) { // end: 0 with AA, 1 with BB, 2 with AB\\n                            int len = 0;\\n                            if (end != 0 && x > 0) len = Math.max(len, 2 + dp[x - 1][y][z][0]); // BB+AA, AB+AA\\n                            if (end == 0 && y > 0) len = Math.max(len, 2 + dp[x][y - 1][z][1]); // AA+BB\\n                            if (end != 0 && z > 0) len = Math.max(len, 2 + dp[x][y][z - 1][2]); // BB+AB, AB+AB\\n                            dp[x][y][z][end] = len;\\n                        }\\n                    }\\n                }\\n            }\\n            return Arrays.stream(dp[maxX][maxY][maxZ]).max().getAsInt();\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    class Solution {\\n\\n        Integer[][][][] memo;\\n\\n        public int longestString(int x, int y, int z) {\\n            memo = new Integer[3][x + 1][y + 1][z + 1];\\n            return Math.max(Math.max(dp(0, x, y, z), dp(1, x, y, z)), dp(2, x, y, z));\\n        }\\n\\n        // end: 0 with AA, 1 with BB, 2 with AB\\n        // x: AA, y: BB, z: AB\\n        int dp(int end, int x, int y, int z) { // dp() - max len with x,y,z ending at \\'end\\'\\n            if (x + y + z == 0) return 0;\\n            if (memo[end][x][y][z] != null) return memo[end][x][y][z];\\n\\n            int len = 0;\\n            if (end != 0 && x > 0) len = Math.max(len, 2 + dp(0, x - 1, y, z)); // BB+AA, AB+AA\\n            if (end == 0 && y > 0) len = Math.max(len, 2 + dp(1, x, y - 1, z)); // AA+BB\\n            if (end != 0 && z > 0) len = Math.max(len, 2 + dp(2, x, y, z - 1)); // BB+AB, AB+AB\\n\\n            return memo[end][x][y][z] = len;\\n        }\\n    }\\n```\n```\\nclass Solution {\\n\\n    // x=2,y=5,z=1\\n        // BotUp: 0,0,0; 1,0,0; 0,1,0; 0,0,1; 1,1,0; 0,1,1; 1,1,1; 2,1,1; 1,2,1; 1,1,2;\\n        // 4 nested loops: over x/y/z/end, 0,0,1;0,0,2;0,0,3;0,0,4;0,1,1;0,1,2;etc\\n        public int longestString(int maxX, int maxY, int maxZ) {\\n            var dp = new int[maxX + 1][maxY + 1][maxZ + 1][3];\\n            for (int x = 0; x <= maxX; x++) { // x: AA, y: BB, z: AB\\n                for (int y = 0; y <= maxY; y++) {\\n                    for (int z = 0; z <= maxZ; z++) {\\n                        for (int end = 0; end < 3; end++) { // end: 0 with AA, 1 with BB, 2 with AB\\n                            int len = 0;\\n                            if (end != 0 && x > 0) len = Math.max(len, 2 + dp[x - 1][y][z][0]); // BB+AA, AB+AA\\n                            if (end == 0 && y > 0) len = Math.max(len, 2 + dp[x][y - 1][z][1]); // AA+BB\\n                            if (end != 0 && z > 0) len = Math.max(len, 2 + dp[x][y][z - 1][2]); // BB+AB, AB+AB\\n                            dp[x][y][z][end] = len;\\n                        }\\n                    }\\n                }\\n            }\\n            return Arrays.stream(dp[maxX][maxY][maxZ]).max().getAsInt();\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689584,
                "title": "super-easy-solution-c",
                "content": "# Intuition\\nOn observation\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mn=min(x,y);\\n       if(x!=y) return 2*(2*mn+1+z);\\n       else return 2*(2*mn+z);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mn=min(x,y);\\n       if(x!=y) return 2*(2*mn+1+z);\\n       else return 2*(2*mn+z);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689390,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int maxLen = 0;\\n\\n        // Concatenate \"AB\" strings as long as z is greater than zero\\n        while (z > 0) {\\n            maxLen += 2;\\n            z--;\\n        }\\n        \\n        while (x > 0 && y > 0) {\\n            maxLen += 4;\\n            x--;\\n            y--;\\n        }\\n\\n        if(x>0 and x%2!=0){\\n            maxLen += 2;\\n        }\\n        else if(y>0 and y%2!=0){\\n            maxLen += 2;\\n        }\\n        else if(x>0 and x%2==0){\\n            maxLen += 2;\\n        }\\n        else if(y>0 and y%2==0){\\n            maxLen += 2;\\n        }\\n\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int maxLen = 0;\\n\\n        // Concatenate \"AB\" strings as long as z is greater than zero\\n        while (z > 0) {\\n            maxLen += 2;\\n            z--;\\n        }\\n        \\n        while (x > 0 && y > 0) {\\n            maxLen += 4;\\n            x--;\\n            y--;\\n        }\\n\\n        if(x>0 and x%2!=0){\\n            maxLen += 2;\\n        }\\n        else if(y>0 and y%2!=0){\\n            maxLen += 2;\\n        }\\n        else if(x>0 and x%2==0){\\n            maxLen += 2;\\n        }\\n        else if(y>0 and y%2==0){\\n            maxLen += 2;\\n        }\\n\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688981,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(y>x){\\n            y=x+1;\\n            return 2*(x+y+z);\\n        }\\n        else if(x-y==1){\\n            return 2*(x+y+z);\\n        }\\n        else {\\n            int mn = Math.min(x,y);\\n            mn = 2*mn;\\n            int res = 2*(mn+z);\\n            if(x-y>=2) return res+2;\\n            else return res;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(y>x){\\n            y=x+1;\\n            return 2*(x+y+z);\\n        }\\n        else if(x-y==1){\\n            return 2*(x+y+z);\\n        }\\n        else {\\n            int mn = Math.min(x,y);\\n            mn = 2*mn;\\n            int res = 2*(mn+z);\\n            if(x-y>=2) return res+2;\\n            else return res;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688657,
                "title": "java-o-1",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int len = x + y  + z;\\n        int diff = Math.abs(x - y);\\n\\n        if (diff > 1) {\\n            diff -= 1;\\n            len -= diff;\\n        }\\n\\n        return len * 2;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        int len = x + y  + z;\\n        int diff = Math.abs(x - y);\\n\\n        if (diff > 1) {\\n            diff -= 1;\\n            len -= diff;\\n        }\\n\\n        return len * 2;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688091,
                "title": "c-easiest-solution-in-3-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int cnt=min(x,y)+min(x,y)+z;\\n        if(x!=y) cnt++;\\n        return 2*cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int cnt=min(x,y)+min(x,y)+z;\\n        if(x!=y) cnt++;\\n        return 2*cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687767,
                "title": "java-o-1-time-and-o-1-space-maths-commented",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(y>x){\\n            return 2*(x+x+1+z);\\n// if y is greater then x we can only use y as x+1 times or else we start forming AAAs and BBBs\\n        }\\n        if(y==x){\\n            return 2*(x+y+z);\\n//if y is equal to x then we can no AAAs and BBBs will form we can use all x and y\\n        }\\n        return 2*(y+1+y+z);\\n//if x is greater than y then x can only be used y+1 times \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(y>x){\\n            return 2*(x+x+1+z);\\n// if y is greater then x we can only use y as x+1 times or else we start forming AAAs and BBBs\\n        }\\n        if(y==x){\\n            return 2*(x+y+z);\\n//if y is equal to x then we can no AAAs and BBBs will form we can use all x and y\\n        }\\n        return 2*(y+1+y+z);\\n//if x is greater than y then x can only be used y+1 times \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687708,
                "title": "only-to-understand-recursion-memoisation-recursive",
                "content": "**NOTE:** This is not most effective approach for this problen. But those practicing Recursion and Memoisation can have a look.\\n\\n# Intuition\\n1. Give state to all the pairs. AA = 1, BB = 2, AB = 3\\n2. Take a dp array and each cell of that dp will represent the longest string with x, y, z and last state.\\n3. Make selective resursive calls, for instance if last added string was AA then you cannot again add AA, use similar logic for other calls.\\n4. No base case required because of selective recursive calls.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    String a = \"AA\"; // state = 1\\n    String b = \"BB\"; // state = 2\\n    String ab = \"AB\"; // state = 3\\n\\n     public int longestStringUtil(int x, int y, int z, int state,int[][][][] dp) {\\n        if (dp[x][y][z][state] != 0) return dp[x][y][z][state];\\n\\n        int maxLength = 0;\\n\\n        // Check if you have string left(x, y, z)\\n        // AA can only be added if the last added string was not AA\\n        if (x > 0 && state != 1) {\\n            maxLength = Math.max(maxLength, 2 + longestStringUtil(x - 1, y, z, 1, dp));\\n        }\\n\\n        // BB can only be added if the last added string was not BB or AB\\n        if (y > 0 && state != 3 && state != 2) {\\n            maxLength = Math.max(maxLength, 2 + longestStringUtil(x, y - 1, z, 2, dp));\\n        }\\n\\n        // AB can only be added if the last added string was not AA\\n        if (z > 0 && state != 1) {\\n            maxLength = Math.max(maxLength, 2 + longestStringUtil(x, y, z - 1, 3, dp));\\n        }\\n\\n        dp[x][y][z][state] = maxLength;\\n        return maxLength;\\n    }\\n\\n    public int longestString(int x, int y, int z) {\\n        int[][][][] dp = new int[x + 1][y + 1][z + 1][4];\\n        // Give all combination of strings, \\n        return Math.max(2 + longestStringUtil(x - 1, y, z, 1, dp), // Start from AA\\n                          Math.max(2 + longestStringUtil(x, y - 1, z, 2, dp),  // Start from BB\\n                                   2 + longestStringUtil(x, y, z - 1, 3, dp))); // Start from AB\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    String a = \"AA\"; // state = 1\\n    String b = \"BB\"; // state = 2\\n    String ab = \"AB\"; // state = 3\\n\\n     public int longestStringUtil(int x, int y, int z, int state,int[][][][] dp) {\\n        if (dp[x][y][z][state] != 0) return dp[x][y][z][state];\\n\\n        int maxLength = 0;\\n\\n        // Check if you have string left(x, y, z)\\n        // AA can only be added if the last added string was not AA\\n        if (x > 0 && state != 1) {\\n            maxLength = Math.max(maxLength, 2 + longestStringUtil(x - 1, y, z, 1, dp));\\n        }\\n\\n        // BB can only be added if the last added string was not BB or AB\\n        if (y > 0 && state != 3 && state != 2) {\\n            maxLength = Math.max(maxLength, 2 + longestStringUtil(x, y - 1, z, 2, dp));\\n        }\\n\\n        // AB can only be added if the last added string was not AA\\n        if (z > 0 && state != 1) {\\n            maxLength = Math.max(maxLength, 2 + longestStringUtil(x, y, z - 1, 3, dp));\\n        }\\n\\n        dp[x][y][z][state] = maxLength;\\n        return maxLength;\\n    }\\n\\n    public int longestString(int x, int y, int z) {\\n        int[][][][] dp = new int[x + 1][y + 1][z + 1][4];\\n        // Give all combination of strings, \\n        return Math.max(2 + longestStringUtil(x - 1, y, z, 1, dp), // Start from AA\\n                          Math.max(2 + longestStringUtil(x, y - 1, z, 2, dp),  // Start from BB\\n                                   2 + longestStringUtil(x, y, z - 1, 3, dp))); // Start from AB\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687514,
                "title": "easy-python-2-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        mini=min(x,y)\\n        return mini*2+(mini+1)*2+2*z if x!=y else mini*4+2*z\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        mini=min(x,y)\\n        return mini*2+(mini+1)*2+2*z if x!=y else mini*4+2*z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687238,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int LongestString(int x, int y, int z) {\\n        /*\\n        x = AA, y = BB, z = AB  ==> xy, yx, zx, yz, zz\\n        */\\n        var count = 0;\\n        \\n        // xy, yx ==> AABB, BBAA\\n        var temp = Math.Min(x, y);\\n        count += temp * 4;\\n        x -= temp;\\n        y -= temp;\\n\\n        // x ==> AA \\n        if(x > 0)\\n            count += z * 2 + 2;\\n        // y ==> BB\\n        else if( y > 0)\\n            count += z * 2 + 2;\\n        // x = y = 0\\n        else\\n            count += z * 2;\\n                  \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestString(int x, int y, int z) {\\n        /*\\n        x = AA, y = BB, z = AB  ==> xy, yx, zx, yz, zz\\n        */\\n        var count = 0;\\n        \\n        // xy, yx ==> AABB, BBAA\\n        var temp = Math.Min(x, y);\\n        count += temp * 4;\\n        x -= temp;\\n        y -= temp;\\n\\n        // x ==> AA \\n        if(x > 0)\\n            count += z * 2 + 2;\\n        // y ==> BB\\n        else if( y > 0)\\n            count += z * 2 + 2;\\n        // x = y = 0\\n        else\\n            count += z * 2;\\n                  \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686833,
                "title": "effective-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        return 2 * (2 * min(x, y) + (x != y) + z)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        return 2 * (2 * min(x, y) + (x != y) + z)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686704,
                "title": "easiest-solution-c-3-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int a = min (x,y);\\n        if(x==y) return (2*a +z)*2;\\n        else  return (2*a +1+z)*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int a = min (x,y);\\n        if(x==y) return (2*a +z)*2;\\n        else  return (2*a +1+z)*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685425,
                "title": "o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(x == y)\\n            return 2 * x + 2 * y + 2 * z;\\n        else{\\n            int min = Math.min(x,y);\\n            return 4 * min + 2 * z + 2;\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestString(int x, int y, int z) {\\n        if(x == y)\\n            return 2 * x + 2 * y + 2 * z;\\n        else{\\n            int min = Math.min(x,y);\\n            return 4 * min + 2 * z + 2;\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685034,
                "title": "simple-c-o-1-beginner-friendly",
                "content": "# Intuition\\nThe question is dependent on X and Y only. We have to use all the `\"AB\"` strings to make the largest possible string hence our answer will contain all the Z strings.\\nNow just take the minimum of X and Y and also add ((minimum of X and Y) + 1) to the answer for creating the largest string. \\nIn the end simply return `ans * 2`. \\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ \\n            ans+=x;\\n            ans+=x+1;\\n            ans+=z;\\n        }\\n        else if(x>y){\\n            ans+=y;\\n            ans+=y+1;\\n            ans+=z;\\n        }\\n        else if(x==y){\\n            ans+=x;\\n            ans+=y;\\n            ans+=z;\\n        }\\n        return ans*2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ \\n            ans+=x;\\n            ans+=x+1;\\n            ans+=z;\\n        }\\n        else if(x>y){\\n            ans+=y;\\n            ans+=y+1;\\n            ans+=z;\\n        }\\n        else if(x==y){\\n            ans+=x;\\n            ans+=y;\\n            ans+=z;\\n        }\\n        return ans*2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684839,
                "title": "1-liner-similar-from-cf",
                "content": "```ruby\\ndef longest_string x, y, z\\n    4 * [x, y].min + z * 2 + (x != y ? 2 : 0)\\nend\\n```\\nSimilar: https://codeforces.com/problemset/problem/1148/A",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef longest_string x, y, z\\n    4 * [x, y].min + z * 2 + (x != y ? 2 : 0)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3684584,
                "title": "one-liner-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNo requirement to match strings of the \"AB\" type with any specific string. These strings can be placed anywhere within the overall string as \"ABABABAB..\" .Hence we take all z type of strings\\nCombine \"AA\" and \"BB\" strings as \"AABB\" pairs.Thus,for the total length, we choose the minimum number of occurrences between the two patterns and multiply it by 4, as the resulting composite string will have the pattern \"AABB\".\\nIf there are remaining \"AA\" or \"BB\" strings, append a single occurrence at the end of the string. For example, with x=2, y=1, and z=0, the resulting string would be \"AABBA\".\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return (x==y)? 2*z + 4*x : 4*min(x,y) + 2*z + 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        return (x==y)? 2*z + 4*x : 4*min(x,y) + 2*z + 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684575,
                "title": "easy-to-understand-c-solution-o-1-time-o-1-space",
                "content": "# Intuition\\nWe dont have to generate xz and zy in line up make condition according to this \\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int val=0;\\n      \\n        if(x==y) val=x+y+z; // if condition will be true then arrangment  should zzxyxyxy..\\n        else {\\n            val=min(x,y)*2+1+z; // minimum of (x,y)  arrangement should be yxyxyz or zxyxyx  1 more possibility to add y or  x according to the number of x and y  so we add 1 in result \\n        }\\n        return val*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int val=0;\\n      \\n        if(x==y) val=x+y+z; // if condition will be true then arrangment  should zzxyxyxy..\\n        else {\\n            val=min(x,y)*2+1+z; // minimum of (x,y)  arrangement should be yxyxyz or zxyxyx  1 more possibility to add y or  x according to the number of x and y  so we add 1 in result \\n        }\\n        return val*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683863,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1) time complexity\\n\\n- Space complexity:\\nO(1) space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int longestString(int x, int y, int z) {\\n      int c=0;\\n      c+=2*z;\\n      int p=min(x,y);\\n      if(x!=y)\\n      c+=2*(2*p+1);\\n      else c+=4*p;\\n\\n      return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int longestString(int x, int y, int z) {\\n      int c=0;\\n      c+=2*z;\\n      int p=min(x,y);\\n      if(x!=y)\\n      c+=2*(2*p+1);\\n      else c+=4*p;\\n\\n      return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683660,
                "title": "python-solution-easy-longest-string-length-calculation-based-on-integers",
                "content": "# Intuition\\nThe goal of the longestString function is to determine the length of the longest string that can be formed using the given integers x, y, and z. Let\\'s analyze the given code to understand the logic.\\n\\n\\n\\n# Approach\\nThe function starts with an if-else statement based on the condition x!=y. This condition checks if x and y are not equal to each other.\\nIf x is not equal to y, it enters the if block.\\nIt initializes a variable a as the minimum of x and y.\\nIt returns the result of the expression ((2*a+1)*2+z*2). This expression calculates the length of the longest string based on the given formula.\\nIf x is equal to y, it enters the else block.\\nIt returns the result of the expression ((2*x)*2+z*2). This expression calculates the length of the longest string based on the given formula.\\n\\n# Complexity\\n- Time complexity:\\n The given code has a time complexity of O(1) since the execution time does not depend on the input size.\\n\\n- Space complexity:\\n The code has a space complexity of O(1) as it does not use any additional space that grows with the input size.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        if x!=y:\\n            a=min(x,y)\\n            return ((2*a+1)*2+z*2)\\n        else:\\n            return ((2*x)*2+z*2)\\n \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n        if x!=y:\\n            a=min(x,y)\\n            return ((2*a+1)*2+z*2)\\n        else:\\n            return ((2*x)*2+z*2)\\n \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683600,
                "title": "c-solution-using-2-approaches",
                "content": "# Using Dynamic Programming and Memoization\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, int z, int prev, int dp[51][51][51][4]) {\\n        if(dp[x][y][z][prev]!=0) {\\n            return dp[x][y][z][prev];\\n        }\\n             \\n        int maxLen = 0;\\n\\n        // For AA\\n        if(x!=0 && prev!=1) {\\n            maxLen = max(maxLen, 2+helper(x-1, y, z, 1,  dp));\\n        }\\n        // For BB\\n        if(y!=0 && prev<=1) {\\n            maxLen = max(maxLen, 2+helper(x, y-1, z, 2, dp));\\n        }\\n        // For AB\\n        if(z!=0 && prev!=1) {\\n            maxLen = max(maxLen, 2+helper(x, y, z-1, 3, dp));\\n        }\\n\\n        return dp[x][y][z][prev] = maxLen;\\n    }\\n    int longestString(int x, int y, int z) {\\n        int dp[51][51][51][4] = {0};\\n        return helper(x, y, z, 0, dp);\\n    }\\n};\\n\\n\\n```\\n\\n---\\n\\n\\n# Using Math\\n\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mini = min(x, y);\\n\\n        if(x==y)\\n            return (2*z + 4*mini);\\n\\n        return (2*z + 4*mini + 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int x, int y, int z, int prev, int dp[51][51][51][4]) {\\n        if(dp[x][y][z][prev]!=0) {\\n            return dp[x][y][z][prev];\\n        }\\n             \\n        int maxLen = 0;\\n\\n        // For AA\\n        if(x!=0 && prev!=1) {\\n            maxLen = max(maxLen, 2+helper(x-1, y, z, 1,  dp));\\n        }\\n        // For BB\\n        if(y!=0 && prev<=1) {\\n            maxLen = max(maxLen, 2+helper(x, y-1, z, 2, dp));\\n        }\\n        // For AB\\n        if(z!=0 && prev!=1) {\\n            maxLen = max(maxLen, 2+helper(x, y, z-1, 3, dp));\\n        }\\n\\n        return dp[x][y][z][prev] = maxLen;\\n    }\\n    int longestString(int x, int y, int z) {\\n        int dp[51][51][51][4] = {0};\\n        return helper(x, y, z, 0, dp);\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mini = min(x, y);\\n\\n        if(x==y)\\n            return (2*z + 4*mini);\\n\\n        return (2*z + 4*mini + 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683248,
                "title": "easy-cp-solution-with-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int cnt=-1;\\n        if(x==y){\\n            cnt=(4*x)+2*z;\\n        }else{\\n           int mini=min(x,y);\\n            cnt=(2*mini+1)*2+2*z;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int cnt=-1;\\n        if(x==y){\\n            cnt=(4*x)+2*z;\\n        }else{\\n           int mini=min(x,y);\\n            cnt=(2*mini+1)*2+2*z;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1942496,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1946124,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1942756,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1944174,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1942562,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1952146,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1945086,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1943501,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1943002,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1942889,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1942496,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1946124,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1942756,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1944174,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1942562,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1952146,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1945086,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1943501,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1943002,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            },
            {
                "id": 1942889,
                "content": [
                    {
                        "username": "Lewis0511",
                        "content": "If you don\\'t want to accept O(xyz) solutions, don\\'t make the constraints so small. Worst contest experience ever (plus server issues). "
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "[@coder42032](/coder42032)  If were Using 4 nested vectors then its giving TLE . Else if using arrays its passing :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "[@coder42032](/coder42032) why is it giving TLE?? Shouldnt it pass? "
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah same, I thought my 4D DP memoized solution will work, but my code gives TLE at 1083/1103 testcase."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Think of it from a mathematical approach.\\n\\n1. `AA`(x), `BB`(y), `AB`(z) are there, we can\\'t have `AAA` or `BBB` in the final string.\\n\\n2. Now this makes it clear that we can have these 4 combinations `xy, yz, zx, zz`.\\n\\n3. Imagine there are only z, so that we can use them all, there\\'s no issue as they form `ABABABAB`.\\n\\n4. Now for x and y, if they are equal(say 3) and z is 4, we can form this string for maximum length :-`xyxyxyzzzz.`\\n\\n5. If x and y are not equal, say (3 and 6) and z is say 2, we have only one option :- `yxyxyxyzz`\\n\\n6.So in case of unequal x and y, we can use the `2*min(x,y)+1+z` number of pairs.\\n\\n7.In case of equal x and y, we can use `2x+z` pairs\\n\\nI hope you can solve after this :) \\n"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Why is O(3*(N^3)) solution giving TLE ???"
                    },
                    {
                        "username": "calvinchankf",
                        "content": "Don't over-think the problem too much guys~\n\nFor an 'AB'\n- on its left we can only have BB - e.g. BB + AB\n- on its right we can only have AA - e.b. AB + AA\nIt means that we now simplified the problem to: Find the longest AABB....AABB or BBAA....BBAA, and the append AB...AB\n\n```\nvar longestString = function(x, y, z) {\n    const couple = Math.min(x, y)\n    if (x === y) {\n        return (couple*2 + z) * 2 // e.g. AA...BB + zAB \n    }\n    return (couple*2 + 1 + z) * 2 // e.g. AABB...BBAA + z*AB or BBAA..AABB + z*AB \n};\n```"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Can be solved using maths, idea being that:\\nx and y cancel each other out  1:1\\nz can be added entirely\\nand then you just have to check if you have a leftover x or y (you do this because if you have either an extra BB or AA, you can add it either to the beginning, or to the end).\\n\\nnote that z is always > 0"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int longestString(int x, int y, int z) {\\n        int ans=0;\\n        if(x<y){ans=x+x+1+z;return (int)2*ans;}\\n        if(y<x){ans= y+y+1+z;return (int)2*ans;}\\n        if(x==y){return (int)2*(x+y+z);}\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Octavius25",
                        "content": "Can any one let me know why my solution is giving tle even its time complexity o(10^4) at max.\\nclass Solution {\\n    static int recur(int l,int x,int y,int z,int dp[][][][]){\\n            if(dp[x][y][z][l+1]!=0)return dp[x][y][z][l+1];\\n            int maxl=0;\\n            \\n            if(l==-1){\\n                if(x>0){\\n                maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n\\n                }\\n                if(y>0){\\n                maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                \\n                }\\n                if(z>0)\\n                maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n            } \\n            else if(l==1){\\n                if(y>0){\\n                    maxl=Math.max(maxl,2+recur(2,x,y-1,z,dp));\\n                }\\n            }   \\n            else if(l==2){\\n               if(x>0){\\n                   maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n               } \\n               if(z>0){\\n                   maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n               }\\n            }\\n            else {\\n                if(x>0){\\n                    maxl=Math.max(maxl,2+recur(1,x-1,y,z,dp));\\n                }\\n                if(z>0){\\n                    maxl=Math.max(maxl,2+recur(3,x,y,z-1,dp));\\n                }\\n            }\\n            \\n            return dp[x][y][z][l+1]=maxl;\\n    }\\n    public int longestString(int x, int y, int z) {\\n        int dp[][][][]=new int[51][51][51][5];\\n        return recur(-1,x,y,z,dp);\\n    }\\n}"
                    },
                    {
                        "username": "21Cash",
                        "content": "How in the world a dp[] passes testcases and not vector<<<<>>>\\n"
                    },
                    {
                        "username": "kjcjwj007",
                        "content": "vector<<<>>> is a dynamic sized container type so it has more overhead. C style array and std::array are fix-size types and it directly accesses the memory, that\\'s why they are faster. But yeah I think this is a horribly designed suite of test cases."
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "vector<vector<vector<vector< int >>>> dp = TLE\nint dp[ ][ ][ ][ ] = Passed \nGot 1 Wrong Submission :)"
                    },
                    {
                        "username": "alex2266",
                        "content": "fun little math problem/brain teaser, terrible interview question"
                    }
                ]
            }
        ]
    }
]